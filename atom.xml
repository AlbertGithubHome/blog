<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Albert World</title>
  <icon>https://www.gravatar.com/avatar/8ccc6291d5bfd34e7aaf601c4ebec7e1</icon>
  
  <link href="/blog/atom.xml" rel="self"/>
  
  <link href="http://AlbertGithubHome.github.io/blog/"/>
  <updated>2021-07-11T16:28:07.032Z</updated>
  <id>http://AlbertGithubHome.github.io/blog/</id>
  
  <author>
    <name>Albert Shi</name>
    <email>347070901@qq.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>C/C++中的数据类型转换static_cast/dynamic_cast/const_cast/reinterpret_cast</title>
    <link href="http://AlbertGithubHome.github.io/blog/2021/07/10/C-C-%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"/>
    <id>http://AlbertGithubHome.github.io/blog/2021/07/10/C-C-中的数据类型转换/</id>
    <published>2021-07-10T09:06:15.000Z</published>
    <updated>2021-07-11T16:28:07.032Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>C/C++属于静态语言，也就是在编译时变量的数据类型即可确定的强类型语言。当不同的数据类型在一起运算或者相互赋值的时候，就需要进行数据类型转换。不同数据类型占用的内存空间不同，而各种数据类型的转换时有规则的，一种通用的规则就是“小转大”自动进行，“大转小”需要强制执行。这里的“大”和“小”指的是数据范围。</p><a id="more"></a><p>为什么会有数据范围大小的区别呢？这就和饭店里的盘子一样，不同的菜肴通常使用不同的盘子，盘子有大有小，如果把小盘子里的菜装到大盘子里没有问题，但是把大盘子里的菜放到小盘子中就会溢出来，假设都使用大盘子就不会产生溢出的问题，但是这样会产生空间的浪费。而C/C++中不同类型的变量占用的内存空间不同与这些盘子非常相似，当范围小的变量赋值给范围大的变量时没有问题，但是反过来也会出现溢出。</p><h1 id="数据类型自动转换"><a href="#数据类型自动转换" class="headerlink" title="数据类型自动转换"></a>数据类型自动转换</h1><p>当不同类型的变量同时运算时就会发生数据类型的自动转换，以常见的 <code>char</code>、<code>short</code>、<code>int</code>、<code>long</code>、<code>float</code>、<code>double</code> 这些类型为例，如果 <code>char</code> 和 <code>int</code> 两个类型的变量相加时，就会把 <code>char</code> 先转换成 <code>int</code> 再进行加法运算，如果是 <code>int</code> 和 <code>double</code> 类型的变量相乘就会把 <code>int</code> 转换成 <code>double</code> 再进行运算。</p><p>自动转换的行为如下图所示，方向是从左往右自动进行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">    A((char))--&gt;C(unsigned/int)</span><br><span class="line">    B((short))--&gt;C(unsigned/int)</span><br><span class="line">    C(unsigned/int)--&gt;D(unsigned/long)</span><br><span class="line">    D(unsigned/long)--&gt;F[double]</span><br><span class="line">    E(float)--&gt;F[double]</span><br></pre></td></tr></table></figure><h1 id="C语言中的强制类型转换"><a href="#C语言中的强制类型转换" class="headerlink" title="C语言中的强制类型转换"></a>C语言中的强制类型转换</h1><p>前面说了自动转换，从这里开始聊聊强制类型转换，需要强制类型转换往往程序不那么智能了，需要人工进行干预。比如把一个<code>int</code> 类型的变量赋值给 <code>char</code> 类型的变量，或者说把两个 <code>int</code> 相乘时可能会得到一个很大的数，所以需要先把 <code>int</code> 强制转换成 <code>double</code> 计算防止溢出。</p><p>强制类型转换的格式为：<code>(new_type_name) expression</code>，其中 <code>new_type_name</code> 为新类型名称，<code>expression</code>为表达式。例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">int</span> val = <span class="number">65535</span>;</span><br><span class="line"><span class="keyword">char</span> ch = (<span class="keyword">char</span>)val;</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> m = <span class="number">2147483647</span>, n = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">double</span> result = (<span class="keyword">double</span>)m * n;</span><br></pre></td></tr></table></figure><p>无论是自动的类型转换还是强制类型转换，都只是为了本次操作或运算而进行的临时转换，转换的结果也会保存到临时的内存空间内，不会改变数据本来的类型或者具体的值。</p><p>有些强制类型转换是对原有数据的重新解释，比如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">void</span>* p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>* buffer = (<span class="keyword">char</span>*)p;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>void*</code> 类型的变量p，经过强制类型转换以后变成了<code>char</code>类型的指针，此后就可以把这段内存空间当成字符数组来处理了。</p><h1 id="C-中的强制类型转换"><a href="#C-中的强制类型转换" class="headerlink" title="C++中的强制类型转换"></a>C++中的强制类型转换</h1><p>在C++语言中新增了四个用于强制类型转换的关键字，分别是 <code>static_cast</code>、 <code>dynamic_cast</code>, <code>const_cast</code>、 和 <code>reinterpret_cast</code>，使用语法为 <code>xxxx_cast&lt;new_type_name&gt;(expression)</code>。</p><p>相比于C语言中使用小括号<code>()</code>来完成强制类型转换，C++中这几个关键字的引入能更清晰的表明它要完成强制类型转换的意图，容易暴露出隐藏的问题。</p><p>其实很长一段时间以来，我对于这四种强转方式区分的不是很清晰，其中 <code>const_cast</code> 的功能还比较容易辨别，但是另外3种经常混作一团，所以才有了这篇总结，而仔细学习后才发现，这4种强转关键字的区别就在他们的名字上，下面逐个来看一下。</p><h2 id="static-cast"><a href="#static-cast" class="headerlink" title="static_cast"></a>static_cast</h2><p>这个关键字的作用主要表现在 <code>static</code> 上，是一种静态的转换，在编译期就能确定的转换，可以完成C语言中的强制类型转换中的大部分工作，但需要注意的是，它不能转换掉表达式的 <code>const</code>、<code>volitale</code> 或者 <code>__unaligned</code> 属性。</p><p>它主要有以下几种用法：</p><ol><li><p>用于基本数据类型之间的转换，如把<code>int</code>转换成<code>char</code>，把<code>int</code>转换成<code>double</code>等。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> val = <span class="number">110119</span>;</span><br><span class="line"><span class="keyword">char</span> c = <span class="keyword">static_cast</span>&lt;<span class="keyword">char</span>&gt;(val);</span><br><span class="line"><span class="keyword">double</span> d = <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(val);</span><br></pre></td></tr></table></figure></li><li><p>将表达式转换成<code>void</code>类型，并将转换后的结果丢弃</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> val = <span class="number">110119</span>;</span><br><span class="line"><span class="keyword">static_cast</span>&lt;<span class="keyword">void</span>&gt;(val);</span><br></pre></td></tr></table></figure></li><li><p>可以用于<code>void*</code> 和其他指针类类型之间的转换，但是不能用于两个无关指针类型的直接转换</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正常转换</span></span><br><span class="line"><span class="keyword">int</span> *p = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line"><span class="keyword">void</span>* p1 = <span class="keyword">static_cast</span>&lt;<span class="keyword">void</span>*&gt;(p);</span><br><span class="line"><span class="keyword">char</span>* p2 =  <span class="keyword">static_cast</span>&lt;<span class="keyword">char</span>*&gt;(p1);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译失败 //error: invalid static_cast from type ‘int*’ to type ‘char*’</span></span><br><span class="line"><span class="keyword">char</span>* p3 =  <span class="keyword">static_cast</span>&lt;<span class="keyword">char</span>*&gt;(p);</span><br></pre></td></tr></table></figure></li><li><p>可以用于类继承结构中基类和派生类之间指针或引用的转换，向上转型安全，向下转型由于没有动态类型检查，是不安全的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span> &#123;</span> &#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">D</span> :</span> B &#123; &#125;;</span><br><span class="line"></span><br><span class="line">D d;</span><br><span class="line">B&amp; rb = d;</span><br><span class="line">D&amp; rd = <span class="keyword">static_cast</span>&lt;D&amp;&gt;(rb);</span><br></pre></td></tr></table></figure></li><li><p>如果涉及左值到右值、数组到指针或函数到指针的转换，也可以通过static_cast显式执行。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">typename</span> <span class="built_in">std</span>::remove_reference&lt;_Tp&gt;::type&amp;&amp;</span><br><span class="line">move(_Tp&amp;&amp; <span class="keyword">__t</span>)</span><br><span class="line">&#123; <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">typename</span> <span class="built_in">std</span>::remove_reference&lt;_Tp&gt;::type&amp;&amp;&gt;(<span class="keyword">__t</span>); &#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="dynamic-cast"><a href="#dynamic-cast" class="headerlink" title="dynamic_cast"></a>dynamic_cast</h2><p>从名字上看，这个关键字与 <code>static_cast</code> 的静态转换是对立的，这是一个“动态”转换函数，只能对指针和引用的进行转换，并且只用于类继承结构中基类和派生类之间指针或引用的转换，可以进行向上、向下，或者横向的转换。</p><p>相比于 <code>static_cast</code> 的编译时转换， <code>dynamic_cast</code> 的转换还会在运行时进行类型检查，转换的条件也比较苛刻，必须有继承关系的类之间才能转换，并且在基类中有虚函数才可以，有一种特殊的情况就是可以把类指针转换成 <code>void*</code> 类型。</p><p>关于使用中的常见问题，参考以下几种情况：</p><ol><li><p>普通类型的指针无法转换</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> val = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> *p = &amp;val;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译失败 //error: cannot dynamic_cast ‘p’ (of type ‘int*’) to type ‘char*’ (target is not pointer or reference to class)</span></span><br><span class="line"><span class="keyword">char</span>* pc =  <span class="keyword">dynamic_cast</span>&lt;<span class="keyword">char</span>*&gt;(p);</span><br></pre></td></tr></table></figure></li><li><p>继承结构中基类里面没有虚函数无法转换</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span> &#123;</span> &#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">D</span> :</span> B &#123; &#125;;</span><br><span class="line"></span><br><span class="line">D d;</span><br><span class="line">B* pb = &amp;d;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译失败 //error: cannot dynamic_cast ‘pb’ (of type ‘struct test1()::B*’) to type ‘struct test1()::D*’ (source type is not polymorphic)</span></span><br><span class="line">D* pd = <span class="keyword">dynamic_cast</span>&lt;D*&gt;(pb)</span><br></pre></td></tr></table></figure></li><li><p>指针或引用转换的类型不是正确的类型，如果参数类型是指针会返回目标类型空指针，如果参数类型是引用则会抛出 <code>std::bad_cast</code> 异常。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span> &#123;</span> <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;&#125; &#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">D</span> :</span> B &#123; &#125;;</span><br><span class="line"></span><br><span class="line">B d;</span><br><span class="line">B* pb = &amp;d;</span><br><span class="line">D* pd = <span class="keyword">dynamic_cast</span>&lt;D*&gt;(pb);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译成功，但是pb指针指向的类型是 B，向下转型失败，输出结果是0，也就是空指针</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; pd &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure></li><li><p>一个正常转换的例子，包含向上、向下、横向转换</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span> &#123;</span> <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;&#125; &#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">D1</span> :</span> <span class="keyword">virtual</span> B &#123; &#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">D2</span> :</span> <span class="keyword">virtual</span> B &#123; &#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MD</span> :</span> D1, D2 &#123; &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">D1* pd1 = <span class="keyword">new</span> MD();</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; pd1 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向上转型</span></span><br><span class="line">B* pb = <span class="keyword">dynamic_cast</span>&lt;B*&gt;(pd1);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; pb &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向下转型</span></span><br><span class="line">MD* pmd = <span class="keyword">dynamic_cast</span>&lt;MD*&gt;(pd1);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; pmd &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 横向转型</span></span><br><span class="line">D2* pd2 = <span class="keyword">dynamic_cast</span>&lt;D2*&gt;(pd1);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; pd2 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>运行结果如下，在横向转换时指针发生了变化，可以看出 <code>dynamic_cast</code> 不是简单的数据强转，还进行了指针的偏移：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:/mnt/d/testconvert$ g++ cppconvert.cpp</span><br><span class="line">albert@home-pc:/mnt/d/testconvert$ ./a.out</span><br><span class="line">0x15c0c40</span><br><span class="line">0x15c0c40</span><br><span class="line">0x15c0c40</span><br><span class="line">0x15c0c48</span><br></pre></td></tr></table></figure></li></ol><h2 id="const-cast"><a href="#const-cast" class="headerlink" title="const_cast"></a>const_cast</h2><p>在C/C++中，const限定符通常被用来限定变量，用于表示该变量的值不能被修改，这种限定可以避免程序员犯一些初级错误，但同时也造成了一些不便，比如一些已有函数要求非常量指针，但是掉用这些函数的接口函数中都传递了常量指针，这时候就要对指针类型去常量化。</p><p>但需要特别注意的是 <code>const_cast</code> 不能去除变量的常量性，只能用来去除指向常数对象的指针或引用的常量性，且去除常量性的对象必须为指针或引用。</p><p>常量指针被转化成非常量指针，并且仍然指向原来的对象，常量引用被转换成非常量引用，并且仍然指向原来的对象；常量对象<strong>可能</strong>被转换成非常量对象。</p><ol><li><p>尝试去除非指针和引用的类型的常量性会编译失败</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> i = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译错误 //</span></span><br><span class="line"><span class="keyword">int</span> j = <span class="keyword">const_cast</span>&lt;<span class="keyword">int</span>&gt;(i);</span><br></pre></td></tr></table></figure></li><li><p>企图用一个指针来修改常量：</p></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> val = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//编译错误 //error: invalid conversion from ‘const int*’ to ‘int*’ [-fpermissive]</span></span><br><span class="line"><span class="keyword">int</span>* cp = &amp;val;</span><br></pre></td></tr></table></figure><ol><li><p>修改一个指针的常量性：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> val = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"&amp;val="</span> &lt;&lt; &amp;val &lt;&lt; <span class="string">", val="</span> &lt;&lt; val &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>* cp = &amp;val;</span><br><span class="line"><span class="keyword">int</span> *p = <span class="keyword">const_cast</span>&lt;<span class="keyword">int</span>*&gt;(cp);</span><br><span class="line">*p = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"&amp;val="</span> &lt;&lt; &amp;val &lt;&lt; <span class="string">", val="</span> &lt;&lt; val &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"p="</span> &lt;&lt; p &lt;&lt; <span class="string">", *p="</span> &lt;&lt; *p &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure></li></ol><p>运行结果如下：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&amp;val=0x7ffff7446bd4, val=6</span><br><span class="line">&amp;val=0x7ffff7446bd4, val=6</span><br><span class="line">p=0x7ffff7446bd4, *p=2</span><br></pre></td></tr></table></figure><p>运行之后，变量 <code>p</code> 指向了变量<code>val</code>地址，并改变了地址所指向的内存数据，但是打印 <code>val</code> 的值并没有发生变化，这是因为 <code>val</code> 作为常量在编译期使用它的地方就进行了替换，接下来再看另一种情况。</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> init = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> val = init;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"&amp;val="</span> &lt;&lt; &amp;val &lt;&lt; <span class="string">", val="</span> &lt;&lt; val &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>* cp = &amp;val;</span><br><span class="line"><span class="keyword">int</span> *p = <span class="keyword">const_cast</span>&lt;<span class="keyword">int</span>*&gt;(cp);</span><br><span class="line">*p = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"&amp;val="</span> &lt;&lt; &amp;val &lt;&lt; <span class="string">", val="</span> &lt;&lt; val &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"p="</span> &lt;&lt; p &lt;&lt; <span class="string">", *p="</span> &lt;&lt; *p &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>代码逻辑不变，只在开始的位置使用 <code>init</code> 这个变量来代替 <code>6</code> 这个常数，运行结果如下：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">val=0x7fffe8c71fa0, val=6</span><br><span class="line">&amp;val=0x7fffe8c71fa0, val=2</span><br><span class="line">p=0x7fffe8c71fa0, *p=2</span><br></pre></td></tr></table></figure><p>运行之后 <code>val</code> 本身的变化也应用到了使用它的地方，这里的编译器替换已经不起作用了。</p><p>实际上，使用const_cast通常是一种无奈之举，利用const_cast去掉指针或引用的常量性并且去修改原始变量的数值，这是一种非常不好的行为，如果可以的话，尽可能在程序设计阶段就规避这种情况。</p><h2 id="reinterpret-cast"><a href="#reinterpret-cast" class="headerlink" title="reinterpret_cast"></a>reinterpret_cast</h2><p>它被用于不同类型指针或引用之间的转换，或者指针和整数之间的转换，是对比特位的简单拷贝并重新解释，因此在使用过程中需要特别谨慎，比如前面提到的一个例子，<code>static_cast</code> 不能将 <code>int*</code> 直接强转成 <code>char*</code>，使用reinterpret_cast就可以办到。</p><ol><li><p>不同基础类型指针类型之间转换：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译失败 //error: invalid static_cast from type ‘int*’ to type ‘char*’</span></span><br><span class="line"><span class="keyword">char</span>* p1 =  <span class="keyword">static_cast</span>&lt;<span class="keyword">char</span>*&gt;(p);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译成功</span></span><br><span class="line"><span class="keyword">char</span>* p2 =  <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">char</span>*&gt;(p1);</span><br></pre></td></tr></table></figure></li><li><p>基础类型指针与类对象指针之间的转换：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span> &#123;</span> <span class="keyword">int</span> val;&#125;;</span><br><span class="line"></span><br><span class="line">B b&#123;<span class="number">100</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"b.val="</span> &lt;&lt; b.val &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>* p = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">int</span>*&gt;(&amp;b);</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"*p="</span> &lt;&lt; *p &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure></li></ol><p>运行之后可以得到 <code>*p</code> 的值为100，也就是重新解释了变量 <code>b</code> 的地址为整型指针。</p><ol><li><p>将地址值转换成整数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span> &#123;</span> <span class="keyword">int</span> val;&#125;;</span><br><span class="line"></span><br><span class="line">B b&#123;<span class="number">101</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"&amp;b="</span> &lt;&lt; &amp;b &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> addr = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">long</span>&gt;(&amp;b);</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"addr="</span> &lt;&lt; addr &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure></li></ol><p>运行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&amp;b=0x7ffffdc4f270</span><br><span class="line">addr=140737450930800</span><br></pre></td></tr></table></figure><p>这里的地址 <code>0x7ffffdc4f270</code> 被解释成了整数 <code>140737450930800</code>，因为涉及到字节序，这也是很多文章提到的 <code>reinterpret_cast</code> 不具备一致性的问题，我们需要知道这一个点，只要代码不依赖主机字节序就没有问题。</p><h2 id="强转关键字的选择"><a href="#强转关键字的选择" class="headerlink" title="强转关键字的选择"></a>强转关键字的选择</h2><p>好几个关键字，并且有些功能还是重复的，那么究竟该选哪一个呢？这个真得按照经验来选，我建议使用排除法，按照 <code>const_cast -&gt; dynamic_cast -&gt; reinterpret_cast -&gt; static_cast</code> 的顺序带入选择。</p><ol><li><p>先看是不是要去掉指针或引用的常量属性，如果是只能选择 <code>const_cast</code></p></li><li><p>再看转换的是不是继承体系下的多态结构，如果是这种结构下的指针和引用的转换最好使用 <code>dynamic_cast</code></p></li><li><p>接着看是不是偏底层的代码，需要将无关类型指针进行转换，或者指针与整数之间进行转换，如果是则选择 <code>reinterpret_cast</code></p></li><li><p>前三种情况都不满足，那就只能使用 <code>static_cast</code> 了</p></li></ol><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>C/C++中不同数据类型进行运算或者赋值的时候会发生数据转换，这种转换有些是自动进行的，有些需要进行显示的强制类型转换</li><li>在C语言中强制类型转换写成<code>(new_type_name) expression</code>的形式，<code>new_type_name</code> 是要转换的目标类型，<code>expression</code> 是待转换的表达式</li><li>在C++中强制类型转换通过更明显的关键字来完成，分别是<code>static_cast</code>、 <code>dynamic_cast</code>, <code>const_cast</code>、 和 <code>reinterpret_cast</code></li><li><code>static_cast</code> 是静态转换，在编译期完成完成转换，与C语言中的强制类型转换重合度最高</li><li><code>dynamic_cast</code> 是动态转换，在运行时转换会进行检查，必须用在有继承关系的多态结构中</li><li><code>const_cast</code> 是常量转换，用于取出指针或引用的常量属性，但是尽量通过设计杜绝它的使用场景</li><li><code>reinterpret_cast</code> 是一种内存数据的重新解释，比较原始，开发者使用它的时候应该明确的知道自己在做什么</li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/118470962" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>今夜的雨，好美~</p><p>2021-7-12 00:18:13</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;C/C++属于静态语言，也就是在编译时变量的数据类型即可确定的强类型语言。当不同的数据类型在一起运算或者相互赋值的时候，就需要进行数据类型转换。不同数据类型占用的内存空间不同，而各种数据类型的转换时有规则的，一种通用的规则就是“小转大”自动进行，“大转小”需要强制执行。这里的“大”和“小”指的是数据范围。&lt;/p&gt;
    
    </summary>
    
      <category term="C/C++" scheme="http://AlbertGithubHome.github.io/blog/categories/C-C/"/>
    
    
      <category term="C/C++" scheme="http://AlbertGithubHome.github.io/blog/tags/C-C/"/>
    
      <category term="数据转换" scheme="http://AlbertGithubHome.github.io/blog/tags/%E6%95%B0%E6%8D%AE%E8%BD%AC%E6%8D%A2/"/>
    
      <category term="自动" scheme="http://AlbertGithubHome.github.io/blog/tags/%E8%87%AA%E5%8A%A8/"/>
    
      <category term="强制类型转换" scheme="http://AlbertGithubHome.github.io/blog/tags/%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"/>
    
  </entry>
  
  <entry>
    <title>换个角度来看看C++中的左值、右值、左值引用、右值引用</title>
    <link href="http://AlbertGithubHome.github.io/blog/2021/07/04/%E6%8D%A2%E4%B8%AA%E8%A7%92%E5%BA%A6%E6%9D%A5%E7%9C%8B%E7%9C%8BC-%E4%B8%AD%E7%9A%84%E5%B7%A6%E5%80%BC%E3%80%81%E5%8F%B3%E5%80%BC%E3%80%81%E5%B7%A6%E5%80%BC%E5%BC%95%E7%94%A8%E3%80%81%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8/"/>
    <id>http://AlbertGithubHome.github.io/blog/2021/07/04/换个角度来看看C-中的左值、右值、左值引用、右值引用/</id>
    <published>2021-07-04T09:06:54.000Z</published>
    <updated>2021-07-04T16:37:51.353Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>对于左值和右值有一个不太严谨的定义——在赋值表达式 <code>=</code> 左侧是的左值，而在 <code>=</code> 右侧的是右值。通过不断学习和尝试，最近我发现一个新的说法更加贴切，那就是“左值是容器，右值是东西”。对于这个定义我们可以类比一下水杯和水，通过水杯可以操作水杯中的水，操作过程中的中间结果如果想要进一步操作，可以将其放入其他的水杯，如果没有水杯就无法找到曾经操作过的水了，也就无法继续操作了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">int</span> c = a + b;</span><br></pre></td></tr></table></figure><p>在这个例子中，变量 <code>a</code>，<code>b</code>, <code>c</code> 都是水杯，而 <code>2</code>、<code>6</code>、<code>a + b</code> 都是被用来操作的水，只有把这些“水”放到“水杯”中才能被找到，才可以进行下一步操作。</p><a id="more"></a><p>关于左值、右值、左值引用和右值引用的概念可以看看之前的总结：</p><ul><li><a href="https://blog.csdn.net/albertsh/article/details/105756674" target="_blank" rel="noopener">简单聊聊C/C++中的左值和右值</a></li><li><a href="https://blog.csdn.net/albertsh/article/details/105941232" target="_blank" rel="noopener">C++11在左值引用的基础上增加右值引用</a></li></ul><p>虽然温故不一定知新，但绝对可以增强记忆，参照着之前的理解，今天来换一种窥探本质的方式。</p><h1 id="汇编代码初探"><a href="#汇编代码初探" class="headerlink" title="汇编代码初探"></a>汇编代码初探</h1><p>为了熟悉一下汇编代码，我们先写个简单的例子，内容就是上述提到的那一段，新建一个文件 <code>main.cpp</code>，然后编写如下代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">6</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> c = a + b;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行 <code>g++ main.cpp --std=c++11 -S -o main.s</code> 编译这段代码，生成汇编文件 <code>main.s</code>，打开文件内容如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">    .file   <span class="string">"main.cpp"</span></span><br><span class="line">    .text</span><br><span class="line">    .globl  main</span><br><span class="line">    .type   main, @function</span><br><span class="line">main:</span><br><span class="line">.LFB0:</span><br><span class="line">    .cfi_startproc</span><br><span class="line">    pushq   %rbp</span><br><span class="line">    .cfi_def_cfa_offset <span class="number">16</span></span><br><span class="line">    .cfi_offset <span class="number">6</span>, <span class="number">-16</span></span><br><span class="line">    movq    %rsp, %rbp</span><br><span class="line">    .cfi_def_cfa_register <span class="number">6</span></span><br><span class="line">    movl    $<span class="number">6</span>, <span class="number">-12</span>(%rbp)</span><br><span class="line">    movl    $<span class="number">2</span>, <span class="number">-8</span>(%rbp)</span><br><span class="line">    movl    <span class="number">-12</span>(%rbp), %edx</span><br><span class="line">    movl    <span class="number">-8</span>(%rbp), %eax</span><br><span class="line">    addl    %edx, %eax</span><br><span class="line">    movl    %eax, <span class="number">-4</span>(%rbp)</span><br><span class="line">    movl    $<span class="number">0</span>, %eax</span><br><span class="line">    popq    %rbp</span><br><span class="line">    .cfi_def_cfa <span class="number">7</span>, <span class="number">8</span></span><br><span class="line">    ret</span><br><span class="line">    .cfi_endproc</span><br><span class="line">.LFE0:</span><br><span class="line">    .size   main, .-main</span><br><span class="line">    .ident  <span class="string">"GCC: (Ubuntu 5.4.0-6ubuntu1~16.04.12) 5.4.0 20160609"</span></span><br><span class="line">    .section        .note.GNU-<span class="built_in">stack</span>,<span class="string">""</span>,@progbits</span><br></pre></td></tr></table></figure><p>其中代表定义变量和做加法的语句转换成汇编代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">movl    $<span class="number">6</span>, <span class="number">-12</span>(%rbp)       <span class="comment">// 把立即数6放到内存地址为-12(%rbp)的位置，也就是变量a中</span></span><br><span class="line">movl    $<span class="number">2</span>, <span class="number">-8</span>(%rbp)        <span class="comment">// 把立即数2放到内存地址为-8(%rbp)的位置，也就是变量b中</span></span><br><span class="line">movl    <span class="number">-12</span>(%rbp), %edx     <span class="comment">// 把内存地址为-12(%rbp)的位置（变量a）的数据放到寄存器%edx中</span></span><br><span class="line">movl    <span class="number">-8</span>(%rbp), %eax      <span class="comment">// 把内存地址为-8(%rbp)的位置（变量b）的数据放到寄存器%eax中</span></span><br><span class="line">addl    %edx, %eax          <span class="comment">// 把寄存器%edx中的数据加到寄存器%eax中</span></span><br><span class="line">movl    %eax, <span class="number">-4</span>(%rbp)      <span class="comment">// 把寄存器%eax中的计算所得结果数据放到内存地址为-4(%rbp)的位置，也就是变量c中</span></span><br></pre></td></tr></table></figure><h1 id="指针变量"><a href="#指针变量" class="headerlink" title="指针变量"></a>指针变量</h1><p>首先来看看通过指针来修改变量值的过程，测试代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">int</span>* p = &amp;a;</span><br><span class="line">*p = <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>转换成汇编代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">movl    $<span class="number">6</span>, <span class="number">-20</span>(%rbp)       <span class="comment">// 把立即数6放到内存地址为-20(%rbp)的位置，也就是变量a中</span></span><br><span class="line">leaq    <span class="number">-20</span>(%rbp), %rax     <span class="comment">// 把这个内存地址-20(%rbp)，也就是变量a的地址保存在寄存器%rax中</span></span><br><span class="line">movq    %rax, <span class="number">-16</span>(%rbp)     <span class="comment">// 把寄存器%rax中的保存的变量a的地址，放到内存地址为-16(%rbp)的位置，也就是变量p中</span></span><br><span class="line">movq    <span class="number">-16</span>(%rbp), %rax     <span class="comment">// 把内存地址为-16(%rbp)的位置（变量p）的数据放到寄存器%rax中</span></span><br><span class="line">movl    $<span class="number">2</span>, (%rax)          <span class="comment">// 把立即数2放在寄存器%rax中保存的地址位置中，也就是p所指向的地址，即变量a中</span></span><br></pre></td></tr></table></figure><p>通过汇编代码可以发现，通过指针修改变量的值实际上是在指针变量中保存变量的地址值，修改变量时是通过指针变量直接找到变量所在内存，然后直接修改完成的。</p><h1 id="左值引用"><a href="#左值引用" class="headerlink" title="左值引用"></a>左值引用</h1><p>接着来看下通过引用来修改变量值的过程，测试代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">int</span>&amp; r = a;</span><br><span class="line">r = <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>转换成汇编代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">movl    $<span class="number">6</span>, <span class="number">-20</span>(%rbp)</span><br><span class="line">leaq    <span class="number">-20</span>(%rbp), %rax</span><br><span class="line">movq    %rax, <span class="number">-16</span>(%rbp)</span><br><span class="line">movq    <span class="number">-16</span>(%rbp), %rax</span><br><span class="line">movl    $<span class="number">2</span>, (%rax)</span><br></pre></td></tr></table></figure><p>看到这里是不是有点意思了，这几行通过引用修改变量值的代码转换成汇编代码以后，居然和之前通过指针修改变量值的汇编代码一模一样。咦？仿佛发现了引用的本质呀！</p><h1 id="常量引用"><a href="#常量引用" class="headerlink" title="常量引用"></a>常量引用</h1><p>在传统C++中我们知道，引用变量不能引用一个右值，但是常引用可以办到这一点，测试代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>&amp; a = <span class="number">6</span>;</span><br></pre></td></tr></table></figure><p>转换成汇编代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">movl    $<span class="number">6</span>, %eax            <span class="comment">//把立即数放到寄存器%eax中</span></span><br><span class="line">movl    %eax, <span class="number">-20</span>(%rbp)     <span class="comment">//把寄存器%eax中的数字6放到内存地址为-20(%rbp)的位置，一个临时变量中</span></span><br><span class="line">leaq    <span class="number">-20</span>(%rbp), %rax     <span class="comment">//把临时变量的内存地址-20(%rbp)放到寄存器%rax中</span></span><br><span class="line">movq    %rax, <span class="number">-16</span>(%rbp)     <span class="comment">//把寄存器%rax中存储的临时变量的内存地址-20(%rbp)放到内存地址为-16(%rbp)的位置</span></span><br></pre></td></tr></table></figure><p>这段代码的翻译结果与前面指针变量的例子很像，首先有一个变量（匿名变量）来存储值，然后是一个新的内存地址来保存之前变量的地址。</p><h1 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h1><p>右值引用需要C++11才能使用，与常引用对比的优点就是可以修改右值，实际上我认为还是修改的左值！测试代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>&amp;&amp; a = <span class="number">6</span>;</span><br><span class="line">a = <span class="number">2</span></span><br></pre></td></tr></table></figure><p>转换成汇编代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">movl    $<span class="number">6</span>, %eax            <span class="comment">//把立即数放到寄存器%eax中</span></span><br><span class="line">movl    %eax, <span class="number">-20</span>(%rbp)     <span class="comment">//把寄存器%eax中的数字6放到内存地址为-20(%rbp)的位置，一个临时变量中</span></span><br><span class="line">leaq    <span class="number">-20</span>(%rbp), %rax     <span class="comment">//把临时变量的内存地址-20(%rbp)放到寄存器%rax中</span></span><br><span class="line">movq    %rax, <span class="number">-16</span>(%rbp)     <span class="comment">//把寄存器%rax中存储的临时变量的内存地址-20(%rbp)放到内存地址为-16(%rbp)的位置</span></span><br><span class="line">movq    <span class="number">-16</span>(%rbp), %rax     <span class="comment">// 把内存地址为-16(%rbp)的位置（变量p）的数据放到寄存器%rax中</span></span><br><span class="line">movl    $<span class="number">2</span>, (%rax)          <span class="comment">// 把立即数2放在寄存器%rax中保存的地址位置中，也就是p所指向的地址，即变量a中</span></span><br></pre></td></tr></table></figure><p>这段汇编代码与常量引用相比只缺少赋值的部分，与左值引用相比几乎一样，只有在最开始立即数6的处理上有一点点差异，是不是感觉很神奇？</p><h1 id="一点点惊奇"><a href="#一点点惊奇" class="headerlink" title="一点点惊奇"></a>一点点惊奇</h1><p>对比了前面这些代码的汇编指令后有没有什么想法？什么常量引用，什么右值引用，这些不过都是“愚弄”程序员的把戏，但这些概念的出现并不是为了给程序员们带来麻烦，相反它们的出现使得程序编写更加可控，通过编译器帮助“粗心”的开发者们先暴露了一波问题。</p><p>通过汇编代码来看，常量引用其实引用的并非常量，而是引用了一个变量；右值引用引用的也并非右值，同样是一个保存了右值的变量。这年头常量都能变，还有什么不能变的呢？</p><p>来看看下面这段代码，仔细想想常量真的变了吗？运行之后各个变量的值是多少呢？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> a = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">int</span> *p = <span class="keyword">const_cast</span>&lt;<span class="keyword">int</span>*&gt;(&amp;a);</span><br><span class="line">*p = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> b = *p;</span><br><span class="line"><span class="keyword">int</span> c = a;</span><br></pre></td></tr></table></figure><p>这段代码运行之后的打印结果：a=6, b=2, c=6，变量a作为一个常量没有被改变，貌似常量还是有点用的，哈哈~</p><p>这段代码转换成汇编代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">movl    $<span class="number">6</span>, <span class="number">-28</span>(%rbp)</span><br><span class="line">leaq    <span class="number">-28</span>(%rbp), %rax</span><br><span class="line">movq    %rax, <span class="number">-16</span>(%rbp)</span><br><span class="line">movq    <span class="number">-16</span>(%rbp), %rax</span><br><span class="line">movl    $<span class="number">2</span>, (%rax)</span><br><span class="line">movq    <span class="number">-16</span>(%rbp), %rax</span><br><span class="line">movl    (%rax), %eax</span><br><span class="line">movl    %eax, <span class="number">-24</span>(%rbp)</span><br><span class="line">movl    $<span class="number">6</span>, <span class="number">-20</span>(%rbp)</span><br></pre></td></tr></table></figure><p>通过汇编来看你会发现，其实变量a的值已经通过指针 <code>p</code> 修改过了，只不过后面引用a变量的地方，因为它是常量，直接使用立即数6替换了。</p><p>改写一下代码，将常量6换成一个变量：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> a = i;</span><br><span class="line"><span class="keyword">int</span> *p = <span class="keyword">const_cast</span>&lt;<span class="keyword">int</span>*&gt;(&amp;a);</span><br><span class="line">*p = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> b = *p;</span><br><span class="line"><span class="keyword">int</span> c = a;</span><br></pre></td></tr></table></figure><p>转换成汇编代码为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">movl    $<span class="number">3</span>, <span class="number">-28</span>(%rbp)</span><br><span class="line">movl    <span class="number">-28</span>(%rbp), %eax</span><br><span class="line">movl    %eax, <span class="number">-32</span>(%rbp)</span><br><span class="line">leaq    <span class="number">-32</span>(%rbp), %rax</span><br><span class="line">movq    %rax, <span class="number">-16</span>(%rbp)</span><br><span class="line">movq    <span class="number">-16</span>(%rbp), %rax</span><br><span class="line">movl    $<span class="number">2</span>, (%rax)</span><br><span class="line">movq    <span class="number">-16</span>(%rbp), %rax</span><br><span class="line">movl    (%rax), %eax</span><br><span class="line">movl    %eax, <span class="number">-24</span>(%rbp)</span><br><span class="line">movl    <span class="number">-32</span>(%rbp), %eax</span><br><span class="line">movl    %eax, <span class="number">-20</span>(%rbp)</span><br></pre></td></tr></table></figure><p>这段代码运行的结果为：i=3, a=2, b=2, c=2，看来常量也禁不住我们这么折腾啊</p><p>所以从这一点可以看出C++代码中无常量，只要是定义出的变量都可以修改，而常量只是给编译器优化提供一份指导，比如可以把一些字面量在编译期间替换，但是运行时的常量还是能改的。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>左值和右值更像是容器与数据的关系，不过C++11提出的将亡值的概念又模糊这两者的界限，将亡值可以看成是即将失去容器的数据</li><li>在Ubuntu16.04、GCC5.4.0的环境下，通过左值引用和指针修改一个变量值生成的汇编代码完全一致</li><li>C++11中右值引用与常量引用生成的汇编代码一致，与左值引用生成的代码只在初始化时有一点差异</li><li>常量并非不可修改，它只是一种“君子协定”，你要知道什么情况下可以改，什么情况下绝对不可以改</li><li><code>const_cast</code> 目的并不是让你去修改一个本身被定义为const的值，这样修改后果是可能是无法预期的，它存在的目的是调整一些指针、引用的权限，比如在函数传递参数的时候</li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/118257275" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>身上若无千斤担，谁拿生命赌明天~<br>世间唯一不变的就是变化</p><p>2021-7-5 00:36:29</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;对于左值和右值有一个不太严谨的定义——在赋值表达式 &lt;code&gt;=&lt;/code&gt; 左侧是的左值，而在 &lt;code&gt;=&lt;/code&gt; 右侧的是右值。通过不断学习和尝试，最近我发现一个新的说法更加贴切，那就是“左值是容器，右值是东西”。对于这个定义我们可以类比一下水杯和水，通过水杯可以操作水杯中的水，操作过程中的中间结果如果想要进一步操作，可以将其放入其他的水杯，如果没有水杯就无法找到曾经操作过的水了，也就无法继续操作了。&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; a = &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; b = &lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; c = a + b;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在这个例子中，变量 &lt;code&gt;a&lt;/code&gt;，&lt;code&gt;b&lt;/code&gt;, &lt;code&gt;c&lt;/code&gt; 都是水杯，而 &lt;code&gt;2&lt;/code&gt;、&lt;code&gt;6&lt;/code&gt;、&lt;code&gt;a + b&lt;/code&gt; 都是被用来操作的水，只有把这些“水”放到“水杯”中才能被找到，才可以进行下一步操作。&lt;/p&gt;
    
    </summary>
    
      <category term="C/C++" scheme="http://AlbertGithubHome.github.io/blog/categories/C-C/"/>
    
    
      <category term="C++" scheme="http://AlbertGithubHome.github.io/blog/tags/C/"/>
    
      <category term="C++11" scheme="http://AlbertGithubHome.github.io/blog/tags/C-11/"/>
    
      <category term="左值" scheme="http://AlbertGithubHome.github.io/blog/tags/%E5%B7%A6%E5%80%BC/"/>
    
      <category term="右值" scheme="http://AlbertGithubHome.github.io/blog/tags/%E5%8F%B3%E5%80%BC/"/>
    
      <category term="右值引用" scheme="http://AlbertGithubHome.github.io/blog/tags/%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>C++11中std::move和std::forward到底干了啥</title>
    <link href="http://AlbertGithubHome.github.io/blog/2021/07/04/C-11%E4%B8%ADstd-move%E5%92%8Cstd-forward%E5%88%B0%E5%BA%95%E5%B9%B2%E4%BA%86%E5%95%A5/"/>
    <id>http://AlbertGithubHome.github.io/blog/2021/07/04/C-11中std-move和std-forward到底干了啥/</id>
    <published>2021-07-03T16:28:50.000Z</published>
    <updated>2021-07-18T13:28:18.637Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>C++11中的右值引用的出现，在特定情况下减少了对象的拷贝，提升了C++程序的效率，伴随而来的 <code>std::move</code> 和 <code>std::forward</code> 也大量出现在程序代码中，但是这两个函数究竟干了啥呢？其实他们的本质都是转换函数，也就是完成左值和右值之间的转换，需要注意的是左值可以转换成右值，但是右值无法转换成左值。</p><a id="more"></a><p>关于左值、右值、左值引用和右值引用的概念可以看看之前的总结：</p><ul><li><a href="https://blog.csdn.net/albertsh/article/details/105756674" target="_blank" rel="noopener">简单聊聊C/C++中的左值和右值</a></li><li><a href="https://blog.csdn.net/albertsh/article/details/105941232" target="_blank" rel="noopener">C++11在左值引用的基础上增加右值引用</a></li></ul><p>虽然温故不一定知新，但绝对可以增强记忆，本章的内容说起来很绕，我也是边学边总结，有不对的地方还请大佬们指出来。</p><h1 id="左值引用和右值引用"><a href="#左值引用和右值引用" class="headerlink" title="左值引用和右值引用"></a>左值引用和右值引用</h1><p>了解过基础的引用知识之后我们都知道左值引用的形式为 <code>T&amp; t</code>，一般会像成下面这样使用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(A&amp; obj)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">A obj;</span><br><span class="line">test(obj);</span><br></pre></td></tr></table></figure><p>而右值引用是在左值引用的基础上多加一个<code>&amp;</code>，形式变为 <code>T&amp;&amp; t</code>，使用方式如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(A&amp;&amp; obj)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test(A());</span><br></pre></td></tr></table></figure><p>这种通过 <code>&amp;</code> 的个数区分左值引用和右值引用的方法，在大多数的普通函数中没有问题，但是放到模板参数或者 <code>auto</code> 关键字之后的位置就不太灵了，因为这些地方会推导实际的类型，正式有了参数推导，才使得模板中出现了“万能引用”的说法，也就是下面这样：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(T&amp;&amp; val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; val &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> year = <span class="number">2020</span>;</span><br><span class="line">    func(year);</span><br><span class="line">    func(<span class="number">2020</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数 <code>func</code> 即能接受变量 <code>year</code> 这样的左值作为参数，也能接受 <code>2020</code> 这样的常数作为右值，简直太完美。那么这里是怎样推导的呢？这就要请出一个引用的这得规则了，描述如下：</p><blockquote><p>A&amp; &amp; 折叠成 A&amp;<br>  A&amp; &amp;&amp; 折叠成 A&amp;<br>  A&amp;&amp; &amp; 折叠成 A&amp;<br>  A&amp;&amp; &amp;&amp; 折叠成 A&amp;&amp;</p></blockquote><p>根据这个规则，<code>func</code> 函数在接受 <code>year</code> 作为参数时应该是一个左值引用，那么模板参数 <code>T</code> 会被推到为 <code>A&amp;</code> 与后面的 <code>&amp;&amp;</code> 折叠为 <code>A&amp;</code>，接受 <code>year</code> 没问题。而这个函数在接受 <code>2020</code> 作为参数时应该是一个右值引用，那么模板参数 <code>T</code> 会被推导成 <code>A</code>，与后面的 <code>&amp;&amp;</code> 形成 <code>A&amp;&amp;</code>，可以接受右值，知道了这些基础知识我们接着往后看。</p><h1 id="std-move"><a href="#std-move" class="headerlink" title="std::move"></a>std::move</h1><p>这个函数听起来好像是一个小人移动时调用的函数，但它却是一个把左值转化成右值的转化函数，我们看一下 <code>std::move</code> 函数的实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  @brief  Convert a value to an rvalue.</span></span><br><span class="line"><span class="comment"> *  @param  __t  A thing of arbitrary type.</span></span><br><span class="line"><span class="comment"> *  @return The parameter cast to an rvalue-reference to allow moving it.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line">  <span class="keyword">constexpr</span> <span class="keyword">typename</span> <span class="built_in">std</span>::remove_reference&lt;_Tp&gt;::type&amp;&amp;</span><br><span class="line">  move(_Tp&amp;&amp; <span class="keyword">__t</span>) <span class="keyword">noexcept</span></span><br><span class="line">  &#123; <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">typename</span> <span class="built_in">std</span>::remove_reference&lt;_Tp&gt;::type&amp;&amp;&gt;(<span class="keyword">__t</span>); &#125;</span><br></pre></td></tr></table></figure><p>这是一个模板函数，一共才4行，好像最麻烦的就是这个 <code>std::remove_reference&lt;_Tp&gt;::type&amp;&amp;</code> 了，先来看看它是什么，其实它的作用就是，<strong>移除类型的引用，返回原始类型。</strong></p><h2 id="std-remove-reference"><a href="#std-remove-reference" class="headerlink" title="std::remove_reference"></a>std::remove_reference</h2><p>它的可能实现如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">remove_reference</span> &#123;</span></span><br><span class="line">    <span class="keyword">using</span> type = T;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="comment">// 模板特化</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">remove_reference</span>&lt;T&amp;&gt; &#123;</span></span><br><span class="line">    <span class="keyword">using</span> type = T;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="comment">// 模板特化</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">remove_reference</span>&lt;T&amp;&amp;&gt; &#123;</span></span><br><span class="line">    <span class="keyword">using</span> type = T;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>它的作用可以参考 <a href="https://en.cppreference.com/w/cpp/types/remove_reference" target="_blank" rel="noopener">cppreference.com - remove_reference</a>，示例如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt; // std::cout</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;type_traits&gt; // std::is_same</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="title">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">print_is_same</span>() &#123;</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::is_same&lt;T1, T2&gt;() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::boolalpha;</span><br><span class="line"></span><br><span class="line">  print_is_same&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;();</span><br><span class="line">  print_is_same&lt;<span class="keyword">int</span>, <span class="keyword">int</span> &amp;&gt;();</span><br><span class="line">  print_is_same&lt;<span class="keyword">int</span>, <span class="keyword">int</span> &amp;&amp;&gt;();</span><br><span class="line"></span><br><span class="line">  print_is_same&lt;<span class="keyword">int</span>, <span class="built_in">std</span>::remove_reference&lt;<span class="keyword">int</span>&gt;::type&gt;();</span><br><span class="line">  print_is_same&lt;<span class="keyword">int</span>, <span class="built_in">std</span>::remove_reference&lt;<span class="keyword">int</span> &amp;&gt;::type&gt;();</span><br><span class="line">  print_is_same&lt;<span class="keyword">int</span>, <span class="built_in">std</span>::remove_reference&lt;<span class="keyword">int</span> &amp;&amp;&gt;::type&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">true</span><br><span class="line">false</span><br><span class="line">false</span><br><span class="line">true</span><br><span class="line">true</span><br><span class="line">true</span><br></pre></td></tr></table></figure><p>从这个例子可以清晰的看出 <code>std::remove_reference</code> 就是返回去掉引用的原始类型。</p><h2 id="static-cast"><a href="#static-cast" class="headerlink" title="static_cast"></a>static_cast</h2><p>明白了上面 <code>std::remove_reference</code> 的作用，整个 <code>std::move</code> 函数就剩下一个 <code>static_cast</code> 函数了，其实到这里也就清晰了，<code>std::move</code> 函数的作用就先通过 <code>std::remove_reference</code> 函数得到传入参数的原始类型 <code>X</code>，然后再把参数强转成 <code>T&amp;&amp;</code> 返回即可，参数的 <code>_Tp</code> 的推导参考引用折叠规则。</p><h2 id="std-move-到底干了啥"><a href="#std-move-到底干了啥" class="headerlink" title="std::move 到底干了啥"></a>std::move 到底干了啥</h2><p>通过前面的一通分析我们发现，<code>std::move</code> 的内部只做了一个强制类型转换，除此之外啥也没干，其实就是对传入的参数重新解释了一下，并没有实质性的动作。</p><p>那么为什么要使用 <code>std::move</code> 这个名字呢？这个名字更多的是起到提醒的作用，告诉使用者这里可能进行了到右值的转化，相关的对象后续可能发生移动，“被掏空”了，如果你继续使用这个对象，行为是未定义的，后果自负。</p><h1 id="std-forward"><a href="#std-forward" class="headerlink" title="std::forward"></a>std::forward</h1><p><code>std::forward</code> 被称为完美转发，听起来和 “万能引用”一样厉害，使用的头文件为 <code>&lt;utility&gt;</code>，在 <code>/usr/include/c++/5/bits/move.h</code> 文件中的定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  @brief  Forward an lvalue.</span></span><br><span class="line"><span class="comment"> *  @return The parameter cast to the specified type.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  This function is used to implement "perfect forwarding".</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line">  <span class="keyword">constexpr</span> _Tp&amp;&amp;</span><br><span class="line">  forward(<span class="keyword">typename</span> <span class="built_in">std</span>::remove_reference&lt;_Tp&gt;::type&amp; <span class="keyword">__t</span>) <span class="keyword">noexcept</span></span><br><span class="line">  &#123; <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;_Tp&amp;&amp;&gt;(<span class="keyword">__t</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  @brief  Forward an rvalue.</span></span><br><span class="line"><span class="comment"> *  @return The parameter cast to the specified type.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  This function is used to implement "perfect forwarding".</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line">  <span class="keyword">constexpr</span> _Tp&amp;&amp;</span><br><span class="line">  forward(<span class="keyword">typename</span> <span class="built_in">std</span>::remove_reference&lt;_Tp&gt;::type&amp;&amp; <span class="keyword">__t</span>) <span class="keyword">noexcept</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">static_assert</span>(!<span class="built_in">std</span>::is_lvalue_reference&lt;_Tp&gt;::value, <span class="string">"template argument"</span></span><br><span class="line">          <span class="string">" substituting _Tp is an lvalue reference type"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;_Tp&amp;&amp;&gt;(<span class="keyword">__t</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><code>std::forward</code> 用于函数模板中完成参数转发任务，我们必须在相应实参为左值，该形参成为左值引用时把它转发成左值，在相应实参为右值，该形参成为右值引用时把它转发成右值。</p><p>有了前面的铺垫我们直接来分析代码吧，第一个版本接受参数苏为左值引用的情况，因为 <code>std::remove_reference&lt;_Tp&gt;::type</code> 是 <code>_Tp</code> 的原始类型，所以 <code>t</code> 就是左值引用类型，调用这个函数时，<code>_Tp</code> 为 <code>X&amp;</code> 类型，经过引用这的 <code>_Tp&amp;&amp; =&gt; X&amp; &amp;&amp; =&gt; X&amp;</code>，所以返回值也是左值引用。</p><p>同理，第二个版本接受右值引用参数，返回值也是一个右值引用。</p><p>从目前的情况来看，<code>std::forward</code> 好像什么也没做，只是将参数强转以后返回，如果不使用这个函数会有什么问题呢？</p><h2 id="必要性"><a href="#必要性" class="headerlink" title="必要性"></a>必要性</h2><p>为什么要使用 <code>std::forward</code> 我们可以通过一个例子来看一下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">(<span class="keyword">int</span>&amp; val)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"lvalue refrence: val="</span> &lt;&lt; val &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">(<span class="keyword">int</span>&amp;&amp; val)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"rvalue refrence: val="</span> &lt;&lt; val &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TPrint</span><span class="params">(T &amp;&amp;t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Print(t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> date = <span class="number">1021</span>;</span><br><span class="line">    TPrint(date);</span><br><span class="line">    TPrint(<span class="number">501</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到这个例子可以先思考一下，运行结果会是什么呢？可能和你想的有点不一样哦，看看下面的答案：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lvalue refrence: val=1021</span><br><span class="line">lvalue refrence: val=501</span><br></pre></td></tr></table></figure><p>有点出乎意料啊，为什么 <code>Print(int&amp;&amp; val)</code> 这个函数没有被调用呢？原因在于“右值引用是一个左值”，很懵对不对，接着往下看：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">101</span>;</span><br><span class="line"><span class="keyword">int</span>&amp; li = i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>&amp;&amp; ri = <span class="number">120</span>;</span><br></pre></td></tr></table></figure><p>这段代码中哪些是左值，哪些是右值呢？可以肯定的是 <code>i</code>、<code>li</code> 是左值， <code>101</code>、<code>120</code> 是右值，而<code>ri</code>也是左值，因为它也一个可以取地址并长期有效的变量啊，只不过这个左值引用了一个右值而已。</p><p>接着回到刚才的例子，<code>TPrint(501);</code> 调用模板函数时，T被推导为 <code>int</code>，所以模板被实例化为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TPrint</span><span class="params">(<span class="keyword">int</span>&amp;&amp; t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Print(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行到这里，<code>t</code> 实际上是一个左值，所以调用了 <code>void Print(int&amp; val)</code> 这个函数，那么怎样才能调用 <code>void Print(int&amp;&amp; val)</code> 这个版本呢？是时候请出 <code>std::forward</code> 函数了，将模板函数进行如下修改：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TPrint</span><span class="params">(T&amp;&amp; t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Print(<span class="built_in">std</span>::forward&lt;T&gt;(t));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改之后再来分析一下，<code>TPrint(501);</code> 调用模板函数时，T被推导为 <code>int</code>，所以模板被实例化为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TPrint</span><span class="params">(<span class="keyword">int</span>&amp;&amp; t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Print(<span class="built_in">std</span>::forward&lt;<span class="keyword">int</span>&gt;(t));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里会调用 <code>std::forward</code> 的这个版本：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line">  <span class="keyword">constexpr</span> _Tp&amp;&amp;</span><br><span class="line">  forward(<span class="keyword">typename</span> <span class="built_in">std</span>::remove_reference&lt;_Tp&gt;::type&amp;&amp; <span class="keyword">__t</span>) <span class="keyword">noexcept</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">static_assert</span>(!<span class="built_in">std</span>::is_lvalue_reference&lt;_Tp&gt;::value, <span class="string">"template argument"</span></span><br><span class="line">          <span class="string">" substituting _Tp is an lvalue reference type"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;_Tp&amp;&amp;&gt;(<span class="keyword">__t</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>函数的返回类型为 <code>int&amp;&amp;</code>，然后就调用了 <code>void Print(int&amp;&amp; val)</code> 这个版本的打印函数。</p><h2 id="疑惑"><a href="#疑惑" class="headerlink" title="疑惑"></a>疑惑</h2><p>可能有人会说，这不对啊，使用 <code>std::forward</code> 修改之前函数参数就是 <code>int&amp;&amp;</code> 类型，修改之后得到的返回值还是 <code>int&amp;&amp;</code> 类型，这有什么区别吗？</p><p>这里的区别就在于，使用 <code>std::forward</code> 之前的 <code>int&amp;&amp;</code> 是有名字的变量 <code>t</code>，它是一个左值，而使用 <code>std::forward</code> 之后的 <code>int&amp;&amp;</code> 是有个匿名变量，它是一个右值，真正的差距就在这里。</p><h2 id="std-forward-到底干了啥"><a href="#std-forward-到底干了啥" class="headerlink" title="std::forward 到底干了啥"></a>std::forward 到底干了啥</h2><p>它和 <code>std::move</code> 一样，<code>std::forward</code> 也是做了一个强制类型转换，当形参成为左值引用时把它转换成左值引用返回，当形参成为右值引用时把它转换成右值引用返回。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li><code>std::move</code> 并没有实际的“移动”操作，只是在内部进行了强制类型转换，返回一个相关类型的右值引用</li><li><code>std::move</code> 的名字主要标识它后续可能会被其他人“掏空”，调用它之后如果继续使用，行为未定义，后果自负</li><li><code>std::forward</code> 的本质也是进行强制类型转换，形参为左值时返回左值引用，形参为右值时返回右值引用</li><li>从定义入手可以理解很多花里胡哨的东西，透过现象看其本质。</li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/118663176" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>日拱一卒无有尽，功不唐捐终入海~</p><p>我们追求的样子：十分沉静，九分气质，八分资产，七分现实，三分颜值，二分糊涂，一份自知之明。</p><p>2021-7-18 21:23:01</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;C++11中的右值引用的出现，在特定情况下减少了对象的拷贝，提升了C++程序的效率，伴随而来的 &lt;code&gt;std::move&lt;/code&gt; 和 &lt;code&gt;std::forward&lt;/code&gt; 也大量出现在程序代码中，但是这两个函数究竟干了啥呢？其实他们的本质都是转换函数，也就是完成左值和右值之间的转换，需要注意的是左值可以转换成右值，但是右值无法转换成左值。&lt;/p&gt;
    
    </summary>
    
      <category term="C/C++" scheme="http://AlbertGithubHome.github.io/blog/categories/C-C/"/>
    
    
      <category term="C++" scheme="http://AlbertGithubHome.github.io/blog/tags/C/"/>
    
      <category term="C++11" scheme="http://AlbertGithubHome.github.io/blog/tags/C-11/"/>
    
      <category term="move" scheme="http://AlbertGithubHome.github.io/blog/tags/move/"/>
    
      <category term="forward" scheme="http://AlbertGithubHome.github.io/blog/tags/forward/"/>
    
      <category term="完美转发" scheme="http://AlbertGithubHome.github.io/blog/tags/%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>手把手搭建一个redis集群</title>
    <link href="http://AlbertGithubHome.github.io/blog/2021/06/26/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AAredis%E9%9B%86%E7%BE%A4/"/>
    <id>http://AlbertGithubHome.github.io/blog/2021/06/26/手把手搭建一个redis集群/</id>
    <published>2021-06-26T02:42:50.000Z</published>
    <updated>2021-06-26T16:43:52.076Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>所谓“难者不会，会者不难”，这不只是一句简简单单的俗语，而是历经人类进化史而得到的历史经验，只有亲身体会过才会越发了解这句话的意义。当你苦思冥想几天几夜难以解决的问题，一句过来人的点拨便可瞬间化解，这是人生路上的需要经历的，愿每个人在关键时刻都能得到善良人的点拨。</p><p>人生有四个境界：①不知道自己不知道；②知道自己不知道；③不知道自己知道，④知道自己知道。不同的境界对应着不同的人生，仔细想想这四种境界并没有哪一种是绝对的好与坏，具体怎么选择取决于你想要什么样的人生，想想坐井观天的那只青蛙，属于“不知道自己不知道”的典型，如果它每天逍遥快活，完全没必要非得跳出井来卷入井外的纷争。</p><p>长久以来自给自足的小农经济，如果没有战乱，没有暴政，没有入侵，耕田织布的生活不也挺好，但是人性是贪婪的，欲望促使人们侵略、扩张，使得一些人进入了“知道自己不知道”的境界，于是加速了人与人之间的交流。进入现代社会以后，信息爆炸，越来越多的人“觉醒”了，但只是“觉醒”而不付出努力就会使自己陷入焦虑，其实焦虑不可怕，重要的是你要采取什么措施来缓解焦虑。</p><p>题外话扯多了，回归正题，写这篇总结的主要还是一个学习记录，也希望这样的记录可以解决一些人的困惑，这些东西并不复杂，也许只是我这个初学者才会关心的问题，但是现在有一种现象，就是大佬们不愿写基础的东西，而小白们想成为大佬从基础学习，却发现路上的坑让他们头破血流。一句学神们口中的“不难证明”，可能你几个月都证明不出来，这个问题是双方面的，一方面小白认为这东西很难，不知道怎么入手，另一方面大神感觉这东西这么简单还需要学？</p><p>屠龙勇士中成恶龙，大神们经过时间的洗礼，很多人已经忘记了自己曾经的头破血流，忘记了自己怎么从小白一步步走来，所以遇到困惑的人不要先入为主，不要认为这个东西太简单了怎么可能有人不会？耐心聆听给出建议，或许可以瞬间打通他的任督二脉。</p><p>好了，好了，又跑题了，拉回来，我们从头来搭建一个redis集群，不过搭建之前我们先来看看“安装”这个词。</p><h1 id="安装的含义"><a href="#安装的含义" class="headerlink" title="安装的含义"></a>安装的含义</h1><p>安装软件、安装程序、安装APP，自从电子设备飞入寻常百姓家，我们每天都在安装、安装、安装。但是这个词并不是电子设备出现后才诞生的。这个词自古就有，安装——本意是：把机件、器材等固定在一定的位置。那么软件、APP的安装就是把它们放在一定的位置。</p><p>软件是什么？至今我都记得初中的一道计算机的题目，我是04年在学校机房第一次接触到真的计算机，当时有一道题是问：Windows是系统软件，还是应用软件？当时这种题目真的是死记硬背啊，脑子里完全没有概念，每周只有一节课，还不一定每个人都有机器，那时的软件对我来说就是一个迷。</p><p>现在接触计算机也这么多年了，对软件也有了一些认识。软件可以说是用来向发出计算机发出任务的东西，当我们对一个人发号任务指令时，能通过声音传递给人，然后接到指令的人可以完成相应的任务，当我们给计算机发送指令时，可以通过键盘、鼠标等把指令输进去，也可以运行软件来完成某些计算机任务，其实软件就是一些提前编好的任务指令的集合。</p><p>那么安装软件就是把软件放到对应的地方，为什么要安装？为什么要放到指定的地方？随便放有什么问题？其实还是为了方便。就像生活中我们把床安装在卧室，把马桶安装在厕所一样，大家都是这样，已经成了习惯。如果你把床安装在厕所，并不是不能用来睡觉，只是其他人在来到厕所睡觉这件事上有些不太习惯。</p><p>因为软件并不只是一个东西，他还有数据啊、配置啊、服务啊等等，所以这些东西都要放在相应的位置，并且做一个登记，就像你把床放到厕所一样，这种不一样的习惯更要登记下来，否则对于一个普通人来说，肯定会去卧室找床，而不是厕所。</p><p>windows中软件的傻瓜式安装降低了软件的安装难度，它有一个注册表，里面记录了很多奇奇怪怪的东西，在windows上安装软件也就是把软件的各部分发到对应的位置，然后通过注册表这个总管登记入册，但是有些软件不太友好，安装的时候一顿乱放，卸载的时候不自己清理干净，导致出现很多问题，比如当年的SQLServer和3DMax，当时为了再次安装不得不重做了好多次系统。</p><p>在linux中安装软件就没有注册表这个东西，只要把软件各部分按照类型分别放好就行，比如可执行程序放<code>/usr/bin/</code>，库文件放<code>/usr/lib</code>，配置文件放 <code>/etc/</code>等等，卸载就是把这些新加的东西删除就可以了，相比windows的注册表要简单一些。</p><p>好了，接下来我们就来安装配置一下redis-cluster，看了一下，本地机器真的很干净，什么都没有，现在从安装redis开始吧。</p><h1 id="安装redis"><a href="#安装redis" class="headerlink" title="安装redis"></a>安装redis</h1><ol><li>系统是ubuntu16.04，偷个懒，直接通过命令 <code>sudo apt-get install redis-server</code> 安装吧，当然你也可以通过源码编译安装，这都是可以的，输出信息如下：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:/usr/src$$ sudo apt-get install redis-server</span><br><span class="line">Reading package lists... Done</span><br><span class="line">Building dependency tree</span><br><span class="line">Reading state information... Done</span><br><span class="line">The following additional packages will be installed:</span><br><span class="line">  libjemalloc1 redis-tools</span><br><span class="line">Suggested packages:</span><br><span class="line">  ruby-redis</span><br><span class="line">The following NEW packages will be installed:</span><br><span class="line">  libjemalloc1 redis-server redis-tools</span><br><span class="line">0 upgraded, 3 newly installed, 0 to remove and 125 not upgraded.</span><br><span class="line">Need to get 519 kB of archives.</span><br><span class="line">After this operation, 1,507 kB of additional disk space will be used.</span><br><span class="line">Do you want to <span class="built_in">continue</span>? [Y/n] Y</span><br><span class="line">Get:1 http://mirrors.tuna.tsinghua.edu.cn/ubuntu xenial/universe amd64 libjemalloc1 amd64 3.6.0-9ubuntu1 [78.9 kB]</span><br><span class="line">Get:2 http://mirrors.tuna.tsinghua.edu.cn/ubuntu xenial-updates/universe amd64 redis-tools amd64 2:3.0.6-1ubuntu0.4 [95.5 kB]</span><br><span class="line">Get:3 http://mirrors.tuna.tsinghua.edu.cn/ubuntu xenial-updates/universe amd64 redis-server amd64 2:3.0.6-1ubuntu0.4 [344 kB]</span><br><span class="line">Fetched 519 kB <span class="keyword">in</span> 13s (38.0 kB/s)</span><br><span class="line">Selecting previously unselected package libjemalloc1.</span><br><span class="line">(Reading database ... 33895 files and directories currently installed.)</span><br><span class="line">Preparing to unpack .../libjemalloc1_3.6.0-9ubuntu1_amd64.deb ...</span><br><span class="line">Unpacking libjemalloc1 (3.6.0-9ubuntu1) ...</span><br><span class="line">Selecting previously unselected package redis-tools.</span><br><span class="line">Preparing to unpack .../redis-tools_2%3a3.0.6-1ubuntu0.4_amd64.deb ...</span><br><span class="line">Unpacking redis-tools (2:3.0.6-1ubuntu0.4) ...</span><br><span class="line">Selecting previously unselected package redis-server.</span><br><span class="line">Preparing to unpack .../redis-server_2%3a3.0.6-1ubuntu0.4_amd64.deb ...</span><br><span class="line">Unpacking redis-server (2:3.0.6-1ubuntu0.4) ...</span><br><span class="line">Processing triggers <span class="keyword">for</span> libc-bin (2.23-0ubuntu11) ...</span><br><span class="line">Processing triggers <span class="keyword">for</span> man-db (2.7.5-1) ...</span><br><span class="line">Processing triggers <span class="keyword">for</span> ureadahead (0.100.0-19.1) ...</span><br><span class="line">Processing triggers <span class="keyword">for</span> systemd (229-4ubuntu21.27) ...</span><br><span class="line">Setting up libjemalloc1 (3.6.0-9ubuntu1) ...</span><br><span class="line">Setting up redis-tools (2:3.0.6-1ubuntu0.4) ...</span><br><span class="line">Setting up redis-server (2:3.0.6-1ubuntu0.4) ...</span><br><span class="line">invoke-rc.d: could not determine current runlevel</span><br><span class="line">Processing triggers <span class="keyword">for</span> libc-bin (2.23-0ubuntu11) ...</span><br><span class="line">Processing triggers <span class="keyword">for</span> ureadahead (0.100.0-19.1) ...</span><br><span class="line">Processing triggers <span class="keyword">for</span> systemd (229-4ubuntu21.27) ...</span><br><span class="line">albert@home-pc:/usr/src$</span><br></pre></td></tr></table></figure><ol><li>安装完查找一下命令安装的位置，redis服务器和客户端应该都在 <code>/usr/bin/</code></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:/usr/src$ <span class="built_in">which</span> redis-server</span><br><span class="line">/usr/bin/redis-server</span><br><span class="line">albert@home-pc:/usr/src$ <span class="built_in">which</span> redis-cli</span><br><span class="line">/usr/bin/redis-cli</span><br></pre></td></tr></table></figure><ol><li>修改配置文件，设置密码，通过 <code>sudo vim /etc/redis/redis.conf</code> 命令打开文件搜索 requirepass 找到下面这一行，把前面的#去掉，requirepass 后面的就是密码，可以自己修改。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># Warning: since Redis is pretty fast an outside user can try up to</span><br><span class="line"># 150k passwords per second against a good box. This means that you should</span><br><span class="line"># use a very strong password otherwise it will be very easy to break.</span><br><span class="line">#</span><br><span class="line"># requirepass foobared  #把这一行前面的&apos;#&apos;去掉就行，密码我就不改了</span><br><span class="line"></span><br><span class="line"># Command renaming.</span><br></pre></td></tr></table></figure><ol><li>启动redis，直接运行 <code>sudo redis-server /etc/redis/redis.conf</code>，redis服务器就起来了</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:/mnt/c/Users/Albert$ sudo redis-server /etc/redis/redis.conf</span><br><span class="line">albert@home-pc:/mnt/c/Users/Albert$ ps -ef | grep redis</span><br><span class="line">root       663     1  0 13:52 ?        00:00:00 redis-server 127.0.0.1:6379</span><br></pre></td></tr></table></figure><ol><li>启动客户端使用redis，连接默认的6379端口，密码<code>foobared</code></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:/mnt/c/Users/Albert$ redis-cli -a foobared -p 6379</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> name redis-test</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get name</span><br><span class="line"><span class="string">"redis-test"</span></span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> age 18</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get age</span><br><span class="line"><span class="string">"18"</span></span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure><ol><li>至此redis就可以使用了，测试了<code>set</code>和<code>get</code>两个命令如上</li></ol><h1 id="redis编译安装"><a href="#redis编译安装" class="headerlink" title="redis编译安装"></a>redis编译安装</h1><p>忽然发现Ubuntu16.04自带的 <code>redis3.0.6</code> 版本太低了，无法自动配置集群，所以决定编译安装，如果自动安装完redis版本在5以上，那就不需要编译安装了。</p><ol><li>新建<code>/usr/local/redis/</code>目录并进入，然后下载redis源码<a href="https://download.redis.io/releases/redis-6.2.4.tar.gz" target="_blank" rel="noopener">redis-6.2.4.tar.gz</a></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:/usr/<span class="built_in">local</span>$ mkdir redis</span><br><span class="line">albert@home-pc:/usr/<span class="built_in">local</span>$ sudo mkdir redis</span><br><span class="line">albert@home-pc:/usr/<span class="built_in">local</span>$ <span class="built_in">cd</span> redis/</span><br><span class="line">albert@home-pc:/usr/<span class="built_in">local</span>/redis$ sudo wget https://download.redis.io/releases/redis-6.2.4.tar.gz</span><br><span class="line">--2021-06-26 14:10:42--  https://download.redis.io/releases/redis-6.2.4.tar.gz</span><br><span class="line">Resolving download.redis.io (download.redis.io)... 45.60.125.1</span><br><span class="line">Connecting to download.redis.io (download.redis.io)|45.60.125.1|:443... connected.</span><br><span class="line">HTTP request sent, awaiting response... 200 OK</span><br><span class="line">Length: 2457940 (2.3M) [application/octet-stream]</span><br><span class="line">Saving to: ‘redis-6.2.4.tar.gz’</span><br><span class="line"></span><br><span class="line">redis-6.2.4.tar.gz               100%[========================================&gt;]   2.34M  45.4KB/s    <span class="keyword">in</span> 54s</span><br><span class="line"></span><br><span class="line">2021-06-26 14:11:37 (44.3 KB/s) - ‘redis-6.2.4.tar.gz’ saved [2457940/2457940]</span><br><span class="line"></span><br><span class="line">albert@home-pc:/usr/<span class="built_in">local</span>/redis$</span><br></pre></td></tr></table></figure><ol><li><p>运行 <code>sudo tar -zxvf redis-6.2.4.tar.gz</code> 命令解压文件</p></li><li><p>运行 <code>cd redis-6.2.4</code> 进入 redis-6.2.4 目录</p></li><li><p>直接运行 <code>sudo make &amp;&amp; make install</code> 即可，如果遇到了 ‘/bin/sh: 1: pkg-config: not found’ 错误，先通过 <code>sudo apt-get install pkg-config</code> 安装 <code>pkg-config</code>，再运行 <code>make</code> 即可。</p></li><li><p>这次 <code>redis-server</code> 和 <code>redis-cli</code> 都被安装到了 <code>/usr/local/bin/</code> 目录，版本是 <code>6.2.4</code>，接下来我们就用这个版本来搭建redis集群</p></li></ol><h1 id="redis集群"><a href="#redis集群" class="headerlink" title="redis集群"></a>redis集群</h1><p>为什么要用redis集群？很直接的原因就是一个redis不够用了，需要使用好几个来组合分摊数据量和压力，那么搭建redis集群其实就是启动多个redis程序实例，让他们配合工作就好了，他们之间的配合是redis本身实现的，我们只需要配置启动多个实例就行了，因为redis集群最少需要三主三从，所以我们启动6个实例，：</p><ol><li>新建 <code>/usr/local/redis-cluster</code> 目录并进入</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:/usr/<span class="built_in">local</span>$ sudo mkdir redis-cluster</span><br><span class="line">albert@home-pc:/usr/<span class="built_in">local</span>$ <span class="built_in">cd</span> redis-cluster/</span><br></pre></td></tr></table></figure><ol><li>为了彼此的配置、数据、日志不相互影响，6个实例需要分别配置，我们建立如下的目录结构，按照端口号配置6个配置文件</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── conf</span><br><span class="line">│   ├── redis-6301.conf</span><br><span class="line">│   ├── redis-6302.conf</span><br><span class="line">│   ├── redis-6303.conf</span><br><span class="line">│   ├── redis-6304.conf</span><br><span class="line">│   ├── redis-6305.conf</span><br><span class="line">│   └── redis-6306.conf</span><br><span class="line">├── data</span><br><span class="line">│   ├── redis-6301</span><br><span class="line">│   ├── redis-6302</span><br><span class="line">│   ├── redis-6303</span><br><span class="line">│   ├── redis-6304</span><br><span class="line">│   ├── redis-6305</span><br><span class="line">│   └── redis-6306</span><br><span class="line">└── <span class="built_in">log</span></span><br></pre></td></tr></table></figure><ol><li>修改redis配置文件，需要修改的配置文件中的内容如下，首先把下面几项前面的#去掉，然后按照端口号命名相互影响的目录和文件名，以第一个实例端口6301为例：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pidfile /var/run/redis/redis-server.pid</span><br><span class="line">port 6379</span><br><span class="line">logfile /var/log/redis/redis-server.log</span><br><span class="line">dir /var/ilib/redis</span><br><span class="line">dbfilename dump.rdb</span><br><span class="line"></span><br><span class="line">#requirepass foobared</span><br><span class="line">#cluster-enabled yes</span><br><span class="line">#cluster-config-file nodes-6379.conf</span><br><span class="line">#cluster-node-timeout 15000</span><br></pre></td></tr></table></figure><p>文件 <code>redis-6301.conf</code> 修改后的文件内容如下，接下来5个配置文件分别按照6302, 6303, 6304, 6305, 6306来配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pidfile /var/run/redis/redis-6301-server.pid</span><br><span class="line">port 6301</span><br><span class="line">logfile /usr/local/redis-cluster/log/redis-6301-server.log</span><br><span class="line">dir /usr/local/redis-cluster/data/redis-6301</span><br><span class="line">dbfilename dump-6301.rdb</span><br><span class="line"></span><br><span class="line">requirepass foobared</span><br><span class="line">cluster-enabled yes</span><br><span class="line">cluster-config-file nodes-6301.conf</span><br><span class="line">cluster-node-timeout 15000</span><br></pre></td></tr></table></figure><ol><li>进入 <code>/usr/local/redis-cluster</code> 目录并启动实例：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:/usr/<span class="built_in">local</span>/redis-cluster$ sudo /usr/<span class="built_in">local</span>/bin/redis-server conf/redis-6301.conf</span><br><span class="line">albert@home-pc:/usr/<span class="built_in">local</span>/redis-cluster$ sudo /usr/<span class="built_in">local</span>/bin/redis-server conf/redis-6302.conf</span><br><span class="line">albert@home-pc:/usr/<span class="built_in">local</span>/redis-cluster$ sudo /usr/<span class="built_in">local</span>/bin/redis-server conf/redis-6303.conf</span><br><span class="line">albert@home-pc:/usr/<span class="built_in">local</span>/redis-cluster$ sudo /usr/<span class="built_in">local</span>/bin/redis-server conf/redis-6304.conf</span><br><span class="line">albert@home-pc:/usr/<span class="built_in">local</span>/redis-cluster$ sudo /usr/<span class="built_in">local</span>/bin/redis-server conf/redis-6305.conf</span><br><span class="line">albert@home-pc:/usr/<span class="built_in">local</span>/redis-cluster$ sudo /usr/<span class="built_in">local</span>/bin/redis-server conf/redis-6306.conf</span><br><span class="line">albert@home-pc:/usr/<span class="built_in">local</span>/redis-cluster$ ps -ef | grep redis</span><br><span class="line">root       663     1  0 13:52 ?        00:00:00 redis-server 127.0.0.1:6379</span><br><span class="line">root      5928     1  0 14:57 ?        00:00:00 /usr/<span class="built_in">local</span>/bin/redis-server 127.0.0.1:6301 [cluster]</span><br><span class="line">root      5935     1  0 14:57 ?        00:00:00 /usr/<span class="built_in">local</span>/bin/redis-server 127.0.0.1:6302 [cluster]</span><br><span class="line">root      5942     1  0 14:57 ?        00:00:00 /usr/<span class="built_in">local</span>/bin/redis-server 127.0.0.1:6303 [cluster]</span><br><span class="line">root      5949     1  0 14:57 ?        00:00:00 /usr/<span class="built_in">local</span>/bin/redis-server 127.0.0.1:6304 [cluster]</span><br><span class="line">root      5956     1  0 14:57 ?        00:00:00 /usr/<span class="built_in">local</span>/bin/redis-server 127.0.0.1:6305 [cluster]</span><br><span class="line">root      5963     1  0 14:57 ?        00:00:00 /usr/<span class="built_in">local</span>/bin/redis-server 127.0.0.1:6306 [cluster]</span><br></pre></td></tr></table></figure><p>此时查看目录已经生成了默认的节点文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:/usr/local/redis-cluster$ tree</span><br><span class="line">.</span><br><span class="line">├── conf</span><br><span class="line">│   ├── redis-6301.conf</span><br><span class="line">│   ├── redis-6302.conf</span><br><span class="line">│   ├── redis-6303.conf</span><br><span class="line">│   ├── redis-6304.conf</span><br><span class="line">│   ├── redis-6305.conf</span><br><span class="line">│   └── redis-6306.conf</span><br><span class="line">├── data</span><br><span class="line">│   ├── redis-6301</span><br><span class="line">│   │   └── nodes-6301.conf</span><br><span class="line">│   ├── redis-6302</span><br><span class="line">│   │   └── nodes-6302.conf</span><br><span class="line">│   ├── redis-6303</span><br><span class="line">│   │   └── nodes-6303.conf</span><br><span class="line">│   ├── redis-6304</span><br><span class="line">│   │   └── nodes-6304.conf</span><br><span class="line">│   ├── redis-6305</span><br><span class="line">│   │   └── nodes-6305.conf</span><br><span class="line">│   └── redis-6306</span><br><span class="line">│       └── nodes-6306.conf</span><br><span class="line">└── log</span><br><span class="line">    ├── redis-6301-server.log</span><br><span class="line">    ├── redis-6302-server.log</span><br><span class="line">    ├── redis-6303-server.log</span><br><span class="line">    ├── redis-6304-server.log</span><br><span class="line">    ├── redis-6305-server.log</span><br><span class="line">    └── redis-6306-server.log</span><br><span class="line"></span><br><span class="line">9 directories, 18 files</span><br></pre></td></tr></table></figure><ol><li>虽然实例都启动起来了，但是现在每个实例是单独的，需要把它们连接到一起，运行如下命令 <code>redis-cli -a foobared --cluster create 127.0.0.1:6301 127.0.0.1:6302 127.0.0.1:6303 127.0.0.1:6304 127.0.0.1:6305 127.0.0.1:6306 --cluster-replicas 1</code> 即可，命令中的 <code>--cluster-replicas 1</code> 表示为每个主节点都提供一个从节点，中间还需要输入 yes，这样运行完就形成了一个三主三从的redis集群：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:/usr/<span class="built_in">local</span>/redis-cluster$ redis-cli -a foobared --cluster create 127.0.0.1:6301 127.0.0.1:6302 127.0.0.1:6303 127.0.0.1:6304 127.0.0.1:6305 127.0.0.1:6306 --cluster-replicas 1</span><br><span class="line">Warning: Using a password with <span class="string">'-a'</span> or <span class="string">'-u'</span> option on the <span class="built_in">command</span> line interface may not be safe.</span><br><span class="line">&gt;&gt;&gt; Performing <span class="built_in">hash</span> slots allocation on 6 nodes...</span><br><span class="line">Master[0] -&gt; Slots 0 - 5460</span><br><span class="line">Master[1] -&gt; Slots 5461 - 10922</span><br><span class="line">Master[2] -&gt; Slots 10923 - 16383</span><br><span class="line">Adding replica 127.0.0.1:6305 to 127.0.0.1:6301</span><br><span class="line">Adding replica 127.0.0.1:6306 to 127.0.0.1:6302</span><br><span class="line">Adding replica 127.0.0.1:6304 to 127.0.0.1:6303</span><br><span class="line">&gt;&gt;&gt; Trying to optimize slaves allocation <span class="keyword">for</span> anti-affinity</span><br><span class="line">[WARNING] Some slaves are <span class="keyword">in</span> the same host as their master</span><br><span class="line">M: 5d60bdad15a6f8ceec188a1081e9381f181a5c5e 127.0.0.1:6301</span><br><span class="line">   slots:[0-5460] (5461 slots) master</span><br><span class="line">M: 8c814d4a32763d47723398fcf8f596d7b6340afc 127.0.0.1:6302</span><br><span class="line">   slots:[5461-10922] (5462 slots) master</span><br><span class="line">M: 7bc53b512772c3a1df3217facca283ff9564d32d 127.0.0.1:6303</span><br><span class="line">   slots:[10923-16383] (5461 slots) master</span><br><span class="line">S: b39bdb5b6e720e9fbedd43e58b57661910dcc3d7 127.0.0.1:6304</span><br><span class="line">   replicates 5d60bdad15a6f8ceec188a1081e9381f181a5c5e</span><br><span class="line">S: 5fef2bedd430bf86cdff63cb2f852aeb21e1b18f 127.0.0.1:6305</span><br><span class="line">   replicates 8c814d4a32763d47723398fcf8f596d7b6340afc</span><br><span class="line">S: 0123b160087743a5296807145b426d9b9cefcf21 127.0.0.1:6306</span><br><span class="line">   replicates 7bc53b512772c3a1df3217facca283ff9564d32d</span><br><span class="line">Can I <span class="built_in">set</span> the above configuration? (<span class="built_in">type</span> <span class="string">'yes'</span> to accept): yes</span><br><span class="line">&gt;&gt;&gt; Nodes configuration updated</span><br><span class="line">&gt;&gt;&gt; Assign a different config epoch to each node</span><br><span class="line">&gt;&gt;&gt; Sending CLUSTER MEET messages to join the cluster</span><br><span class="line">Waiting <span class="keyword">for</span> the cluster to join</span><br><span class="line">.</span><br><span class="line">&gt;&gt;&gt; Performing Cluster Check (using node 127.0.0.1:6301)</span><br><span class="line">M: 5d60bdad15a6f8ceec188a1081e9381f181a5c5e 127.0.0.1:6301</span><br><span class="line">   slots:[0-5460] (5461 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">S: b39bdb5b6e720e9fbedd43e58b57661910dcc3d7 127.0.0.1:6304</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates 5d60bdad15a6f8ceec188a1081e9381f181a5c5e</span><br><span class="line">M: 7bc53b512772c3a1df3217facca283ff9564d32d 127.0.0.1:6303</span><br><span class="line">   slots:[10923-16383] (5461 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">S: 5fef2bedd430bf86cdff63cb2f852aeb21e1b18f 127.0.0.1:6305</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates 8c814d4a32763d47723398fcf8f596d7b6340afc</span><br><span class="line">M: 8c814d4a32763d47723398fcf8f596d7b6340afc 127.0.0.1:6302</span><br><span class="line">   slots:[5461-10922] (5462 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">S: 0123b160087743a5296807145b426d9b9cefcf21 127.0.0.1:6306</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates 7bc53b512772c3a1df3217facca283ff9564d32d</span><br><span class="line">[OK] All nodes agree about slots configuration.</span><br><span class="line">&gt;&gt;&gt; Check <span class="keyword">for</span> open slots...</span><br><span class="line">&gt;&gt;&gt; Check slots coverage...</span><br><span class="line">[OK] All 16384 slots covered.</span><br></pre></td></tr></table></figure><h1 id="redis集群的使用"><a href="#redis集群的使用" class="headerlink" title="redis集群的使用"></a>redis集群的使用</h1><p>当使用<code>redis-cli</code>连接集群的时候，直接连3个主节点的任意一个就可以，把cluster当成一个整理来看待，测试如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:/usr/local/redis-cluster$ redis-cli -a foobared -p 6301</span><br><span class="line">Warning: Using a password with &apos;-a&apos; or &apos;-u&apos; option on the command line interface may not be safe.</span><br><span class="line">127.0.0.1:6301&gt; get name</span><br><span class="line">(error) MOVED 5798 127.0.0.1:6302</span><br><span class="line">127.0.0.1:6301&gt; set name cluster-test</span><br><span class="line">(error) MOVED 5798 127.0.0.1:6302</span><br><span class="line">127.0.0.1:6301&gt;</span><br></pre></td></tr></table></figure><p>我们发现测试Redis命令的时候报错了，显示 <code>(error) MOVED 5798 127.0.0.1:6302</code>，这说明 <code>name</code> 这个键不在端口为 6301 这个实例上，而在端口为 6302 这个实例上，使用 <code>cluster nodes</code> 命令可以查询集群的节点信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6301&gt; cluster nodes</span><br><span class="line">b39bdb5b6e720e9fbedd43e58b57661910dcc3d7 127.0.0.1:6304@16304 slave 5d60bdad15a6f8ceec188a1081e9381f181a5c5e 0 1624711999000 1 connected</span><br><span class="line">7bc53b512772c3a1df3217facca283ff9564d32d 127.0.0.1:6303@16303 master - 0 1624712000000 3 connected 10923-16383</span><br><span class="line">5fef2bedd430bf86cdff63cb2f852aeb21e1b18f 127.0.0.1:6305@16305 slave 8c814d4a32763d47723398fcf8f596d7b6340afc 0 1624711998971 2 connected</span><br><span class="line">5d60bdad15a6f8ceec188a1081e9381f181a5c5e 127.0.0.1:6301@16301 myself,master - 0 1624712000000 1 connected 0-5460</span><br><span class="line">8c814d4a32763d47723398fcf8f596d7b6340afc 127.0.0.1:6302@16302 master - 0 1624711999978 2 connected 5461-10922</span><br><span class="line">0123b160087743a5296807145b426d9b9cefcf21 127.0.0.1:6306@16306 slave 7bc53b512772c3a1df3217facca283ff9564d32d 0 1624712000991 3 connected</span><br></pre></td></tr></table></figure><p>这种情况下可以手动连接端口为6302的节点，也可以在连接 6301 时添加一个 <code>-c</code> 参数，这样在当前实例找不到指定的键时会自动切换，下面测试一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:/usr/local/redis-cluster$ redis-cli -a foobared -p 6301 -c</span><br><span class="line">Warning: Using a password with &apos;-a&apos; or &apos;-u&apos; option on the command line interface may not be safe.</span><br><span class="line">127.0.0.1:6301&gt; set name cluster666</span><br><span class="line">-&gt; Redirected to slot [5798] located at 127.0.0.1:6302</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6302&gt; get name</span><br><span class="line">&quot;cluster666&quot;</span><br><span class="line">127.0.0.1:6302&gt;</span><br></pre></td></tr></table></figure><p>自动跳转到了端口为6302的实例上，这波操作挺666</p><h1 id="C-工程连接使用redis-cluster"><a href="#C-工程连接使用redis-cluster" class="headerlink" title="C++工程连接使用redis-cluster"></a>C++工程连接使用redis-cluster</h1><p><code>redis-cli</code> 可以在集群的各个节点之间自动跳转，那是人家的本事，如果是你想自己连接集群，首先看看你使用的是那个库了。</p><p>如果使用的语言是C/C++，并且用的是最常见的hiredis，那么很抱歉它本身不提供集群的便利访问，像 <code>MGET</code>，<code>MSET</code> 这种操作多个键的命令得自己花点力气了，不过如果你考虑换一个库那么这些问题就解决了。</p><p><code>hiredis-vip</code> 是第一个选择，这个名字听起来好像充了前才能用，实际上是“唯品会 一家专门做特卖的网站”，它先搞出来开源的，可以把集群看成一个整体，连接任一节点就可以操作，但是这个库有个问题，不支持认证，所以后来人在这个基础上进行了二次开发。<a href="https://github.com/vipshop/hiredis-vip" target="_blank" rel="noopener">hiredis-vip源码</a></p><p><code>hiredis-cluster</code> 就是这个二次创作的产物，现在算是官方推荐产品了，如果你想方便的操作集群，不妨下载这个库<a href="https://github.com/Nordix/hiredis-cluster" target="_blank" rel="noopener">hiredis-cluster源码</a>试试，另外<a href="https://github.com/sewenew/redis-plus-plus" target="_blank" rel="noopener">redis-plus-plus</a>也属于官方推荐产品，有时间可以了解一下。</p><h2 id="hiredis-cluster"><a href="#hiredis-cluster" class="headerlink" title="hiredis-cluster"></a>hiredis-cluster</h2><p>今天拿 <code>hiredis-cluster</code> 开刀，看看它怎么用，改天再研究那个 <code>redis-plus-plus</code>。</p><ol><li>首先创建一个目录 <code>/usr/local/redis-cluster-cli</code>，进入目录下载源码：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:/usr/<span class="built_in">local</span>/redis-cluster$ sudo mkdir -p /usr/<span class="built_in">local</span>/redis-cluster-cli</span><br><span class="line">albert@home-pc:/usr/<span class="built_in">local</span>/redis-cluster$ <span class="built_in">cd</span> /usr/<span class="built_in">local</span>/redis-cluster-cli</span><br><span class="line">albert@home-pc:/usr/<span class="built_in">local</span>/redis-cluster-cli$ sudo wget https://github.com/Nordix/hiredis-cluster/archive/refs/tags/0.6.0.tar.gz</span><br><span class="line">--2021-06-26 22:01:15--  https://github.com/Nordix/hiredis-cluster/archive/refs/tags/0.6.0.tar.gz</span><br><span class="line">Resolving github.com (github.com)... 140.82.114.3</span><br><span class="line">Connecting to github.com (github.com)|140.82.114.3|:443... connected.</span><br><span class="line">HTTP request sent, awaiting response... 302 Found</span><br><span class="line">Location: https://codeload.github.com/Nordix/hiredis-cluster/tar.gz/refs/tags/0.6.0 [following]</span><br><span class="line">--2021-06-26 22:01:16--  https://codeload.github.com/Nordix/hiredis-cluster/tar.gz/refs/tags/0.6.0</span><br><span class="line">Resolving codeload.github.com (codeload.github.com)... 13.229.189.0</span><br><span class="line">Connecting to codeload.github.com (codeload.github.com)|13.229.189.0|:443... connected.</span><br><span class="line">HTTP request sent, awaiting response... 200 OK</span><br><span class="line">Length: unspecified [application/x-gzip]</span><br><span class="line">Saving to: ‘0.6.0.tar.gz’</span><br><span class="line"></span><br><span class="line">0.6.0.tar.gz       [        &lt;=&gt;                                      ]  69.58K  19.4KB/s    <span class="keyword">in</span> 3.6s</span><br><span class="line"></span><br><span class="line">2021-06-26 22:01:21 (19.4 KB/s) - ‘0.6.0.tar.gz’ saved [71249]</span><br></pre></td></tr></table></figure><ol><li>解压源码，进入目录hiredis-cluster-0.6.0</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:/usr/<span class="built_in">local</span>/redis-cluster-cli$ sudo tar -zxvf 0.6.0.tar.gz</span><br><span class="line">hiredis-cluster-0.6.0/</span><br><span class="line">hiredis-cluster-0.6.0/.clang-format</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">hiredis-cluster-0.6.0/tests/test_utils.h</span><br><span class="line">hiredis-cluster-0.6.0/win32.h</span><br><span class="line">albert@home-pc:/usr/<span class="built_in">local</span>/redis-cluster-cli$ ls</span><br><span class="line">0.6.0.tar.gz  hiredis-cluster-0.6.0</span><br><span class="line">albert@home-pc:/usr/<span class="built_in">local</span>/redis-cluster-cli$ <span class="built_in">cd</span> hiredis-cluster-0.6.0/</span><br><span class="line">albert@home-pc:/usr/<span class="built_in">local</span>/redis-cluster-cli/hiredis-cluster-0.6.0$</span><br></pre></td></tr></table></figure><ol><li>按照README文档编译库文件</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:/usr/local/redis-cluster-cli/hiredis-cluster-0.6.0$ sudo mkdir build &amp;&amp; cd build</span><br><span class="line">albert@home-pc:/usr/local/redis-cluster-cli/hiredis-cluster-0.6.0/build$ sudo cmake -DCMAKE_BUILD_TYPE=RelWithDebInfo -DDISABLE_TESTS=ON ..</span><br><span class="line">CMake Error at CMakeLists.txt:1 (cmake_minimum_required):</span><br><span class="line">  CMake 3.11 or higher is required.  You are running version 3.5.1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-- Configuring incomplete, errors occurred!</span><br></pre></td></tr></table></figure><p>oh no！要求cmake版本最低3.11，而我的ubuntu16.04自带的cmake是3.5.1，好吧我先去升个级</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ wget http://www.cmake.org/files/v3.11/cmake-3.11.3.tar.gz</span><br><span class="line">$ tar xf cmake-3.11.3.tar.gz</span><br><span class="line">$ <span class="built_in">cd</span> cmake-3.11.3</span><br><span class="line">$ ./configure</span><br><span class="line">$ make</span><br><span class="line">$ sudo make install</span><br></pre></td></tr></table></figure><ol><li>继续编译 hiredis-cluster 库，先运行cmake生成Makefile文件，然后运行 <code>make</code> 命令开始编译：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:/usr/<span class="built_in">local</span>/redis-cluster-cli/hiredis-cluster-0.6.0/build$ sudo cmake -DCMAKE_BUILD_TYPE=RelWithDebInfo -DDISABLE_TESTS=ON ..</span><br><span class="line">-- The C compiler identification is GNU 5.4.0</span><br><span class="line">-- The CXX compiler identification is GNU 5.4.0</span><br><span class="line">-- Check <span class="keyword">for</span> working C compiler: /usr/bin/cc</span><br><span class="line">-- Check <span class="keyword">for</span> working C compiler: /usr/bin/cc -- works</span><br><span class="line">-- Detecting C compiler ABI info</span><br><span class="line">-- Detecting C compiler ABI info - <span class="keyword">done</span></span><br><span class="line">-- Detecting C compile features</span><br><span class="line">-- Detecting C compile features - <span class="keyword">done</span></span><br><span class="line">-- Check <span class="keyword">for</span> working CXX compiler: /usr/bin/c++</span><br><span class="line">-- Check <span class="keyword">for</span> working CXX compiler: /usr/bin/c++ -- works</span><br><span class="line">-- Detecting CXX compiler ABI info</span><br><span class="line">-- Detecting CXX compiler ABI info - <span class="keyword">done</span></span><br><span class="line">-- Detecting CXX compile features</span><br><span class="line">-- Detecting CXX compile features - <span class="keyword">done</span></span><br><span class="line">Detected version: 0.5.0</span><br><span class="line">Downloading dependency <span class="string">'hiredis'</span>..</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">albert@home-pc:/usr/<span class="built_in">local</span>/redis-cluster-cli/hiredis-cluster-0.6.0/build$ sudo make</span><br><span class="line">Scanning dependencies of target hiredis_cluster</span><br><span class="line">[  5%] Building C object CMakeFiles/hiredis_cluster.dir/adlist.c.o</span><br><span class="line">[ 11%] Building C object CMakeFiles/hiredis_cluster.dir/command.c.o</span><br><span class="line">[ 17%] Building C object CMakeFiles/hiredis_cluster.dir/crc16.c.o</span><br><span class="line">[ 23%] Building C object CMakeFiles/hiredis_cluster.dir/dict.c.o</span><br><span class="line">[ 29%] Building C object CMakeFiles/hiredis_cluster.dir/hiarray.c.o</span><br><span class="line">[ 35%] Building C object CMakeFiles/hiredis_cluster.dir/hircluster.c.o</span><br><span class="line">[ 41%] Building C object CMakeFiles/hiredis_cluster.dir/hiutil.c.o</span><br><span class="line">[ 47%] Linking C shared library libhiredis_cluster.so</span><br><span class="line">[ 47%] Built target hiredis_cluster</span><br><span class="line">Scanning dependencies of target hiredis</span><br><span class="line">[ 52%] Building C object _deps/hiredis-build/CMakeFiles/hiredis.dir/alloc.c.o</span><br><span class="line">[ 58%] Building C object _deps/hiredis-build/CMakeFiles/hiredis.dir/async.c.o</span><br><span class="line">[ 64%] Building C object _deps/hiredis-build/CMakeFiles/hiredis.dir/dict.c.o</span><br><span class="line">[ 70%] Building C object _deps/hiredis-build/CMakeFiles/hiredis.dir/hiredis.c.o</span><br><span class="line">[ 76%] Building C object _deps/hiredis-build/CMakeFiles/hiredis.dir/net.c.o</span><br><span class="line">[ 82%] Building C object _deps/hiredis-build/CMakeFiles/hiredis.dir/read.c.o</span><br><span class="line">[ 88%] Building C object _deps/hiredis-build/CMakeFiles/hiredis.dir/sds.c.o</span><br><span class="line">[ 94%] Building C object _deps/hiredis-build/CMakeFiles/hiredis.dir/sockcompat.c.o</span><br><span class="line">[100%] Linking C shared library libhiredis.so</span><br><span class="line">[100%] Built target hiredis</span><br></pre></td></tr></table></figure><ol><li>进入 <code>/usr/local/redis-cluster-cli/hiredis-cluster-0.6.0</code> 目录，新建 <code>cluster-cli.cpp</code> 文件，编写测试代码如下：</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"hircluster.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">timeout</span> = &#123;</span><span class="number">1</span>, <span class="number">500000</span>&#125;; <span class="comment">// 1.5s</span></span><br><span class="line"></span><br><span class="line">    redisClusterContext *cc = redisClusterContextInit();</span><br><span class="line">    redisClusterSetOptionAddNodes(cc, <span class="string">"127.0.0.1:6301"</span>);</span><br><span class="line">    redisClusterSetOptionConnectTimeout(cc, timeout);</span><br><span class="line">    redisClusterSetOptionPassword(cc, <span class="string">"foobared"</span>);</span><br><span class="line">    redisClusterSetOptionRouteUseSlots(cc);</span><br><span class="line">    redisClusterConnect2(cc);</span><br><span class="line">    <span class="keyword">if</span> (cc &amp;&amp; cc-&gt;err) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Error: %s\n"</span>, cc-&gt;errstr);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    redisReply *reply =</span><br><span class="line">        (redisReply *)redisClusterCommand(cc, <span class="string">"SET %s %s"</span>, <span class="string">"name"</span>, <span class="string">"cluster999"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"SET: %s\n"</span>, reply-&gt;str);</span><br><span class="line">    freeReplyObject(reply);</span><br><span class="line"></span><br><span class="line">    redisReply *reply2 = (redisReply *)redisClusterCommand(cc, <span class="string">"GET %s"</span>, <span class="string">"name"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"GET: %s\n"</span>, reply2-&gt;str);</span><br><span class="line">    freeReplyObject(reply2);</span><br><span class="line"></span><br><span class="line">    redisClusterFree(cc);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>运行如下命令，编译代码，然后运行，结果和预期一致，虽然连接的是端口为6301的实例，也成功取到了端口为6302实例上的数据：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:/usr/<span class="built_in">local</span>/redis-cluster-cli/hiredis-cluster-0.6.0$ sudo gcc cluster-cli.cpp -I ./build/_deps/ -L ./build/ -Wl,-rpath=./build -lhiredis_cluster -L ./build/_deps/hiredis-build/ -Wl,-rpath=./build/_deps/hiredis-build/ -lhiredis -o cluster-cli</span><br><span class="line">albert@home-pc:/usr/<span class="built_in">local</span>/redis-cluster-cli/hiredis-cluster-0.6.0$ ./cluster-cli</span><br><span class="line">SET: OK</span><br><span class="line">GET: cluster999</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>安装软件其实就是把软件的各部分数据放到它该放的地方而已，卸载软件就是把这些数据删掉了</li><li>redis也是一款软件，与其他软件并无不同，想要使用多个同时使用，启动多个实例就好了，需要注意配置别冲突</li><li>单独运行的redis实例之间不会有沟通，想要这些实例联合起来工作，需要把它们组成一个集群</li><li><code>hiredis-cluster</code> 和 <code>cluster-plus-plus</code> 是使用的C/C++连接redis集的官方推荐库</li></ul><hr><h2 id="gt-gt-反爬链接，请勿点击，原地爆炸，概不负责！-lt-lt"><a href="#gt-gt-反爬链接，请勿点击，原地爆炸，概不负责！-lt-lt" class="headerlink" title=" ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== "></a><center><a href="https://blog.csdn.net/albertsh/article/details/107587859" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center></h2><blockquote><p>一念动山海，一念山海平~</p><p>2021-6-27 00:35:13</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;所谓“难者不会，会者不难”，这不只是一句简简单单的俗语，而是历经人类进化史而得到的历史经验，只有亲身体会过才会越发了解这句话的意义。当你苦思
      
    
    </summary>
    
      <category term="redis" scheme="http://AlbertGithubHome.github.io/blog/categories/redis/"/>
    
    
      <category term="redis" scheme="http://AlbertGithubHome.github.io/blog/tags/redis/"/>
    
      <category term="集群" scheme="http://AlbertGithubHome.github.io/blog/tags/%E9%9B%86%E7%BE%A4/"/>
    
      <category term="实践" scheme="http://AlbertGithubHome.github.io/blog/tags/%E5%AE%9E%E8%B7%B5/"/>
    
  </entry>
  
  <entry>
    <title>cpplint中filter参数的每个可选项的含义</title>
    <link href="http://AlbertGithubHome.github.io/blog/2021/06/17/cpplint%E4%B8%ADfilter%E5%8F%82%E6%95%B0%E7%9A%84%E6%AF%8F%E4%B8%AA%E5%8F%AF%E9%80%89%E9%A1%B9%E7%9A%84%E5%90%AB%E4%B9%89/"/>
    <id>http://AlbertGithubHome.github.io/blog/2021/06/17/cpplint中filter参数的每个可选项的含义/</id>
    <published>2021-06-16T16:31:29.000Z</published>
    <updated>2021-06-20T14:02:49.982Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><code>cpplint</code> 是一款优秀的代码格式检查工具，有了它可以统一整个团队的代码风格，完整的工具就是一个Python脚本，如果安装了Python环境，直接使用 <code>pip install cpplint</code> 命令就可以安装了，非常的方便。</p><a id="more"></a><p>具体的使用方法可以通过 <code>cpplint --help</code> 查询，语法如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Syntax: cpplint.py [--verbose=<span class="comment">#] [--output=emacs|eclipse|vs7|junit|sed|gsed]</span></span><br><span class="line">                   [--filter=-x,+y,...]</span><br><span class="line">                   [--counting=total|toplevel|detailed] [--root=subdir]</span><br><span class="line">                   [--repository=path]</span><br><span class="line">                   [--linelength=digits] [--headers=x,y,...]</span><br><span class="line">                   [--recursive]</span><br><span class="line">                   [--exclude=path]</span><br><span class="line">                   [--extensions=hpp,cpp,...]</span><br><span class="line">                   [--includeorder=default|standardcfirst]</span><br><span class="line">                   [--quiet]</span><br><span class="line">                   [--version]</span><br><span class="line">        &lt;file&gt; [file] ...</span><br><span class="line"></span><br><span class="line">  Style checker <span class="keyword">for</span> C/C++ <span class="built_in">source</span> files.</span><br><span class="line">  This is a fork of the Google style checker with minor extensions.</span><br></pre></td></tr></table></figure><p>其中有一句 <code>[--filter=-x,+y,...]</code> 就是本文总结的重点。</p><h1 id="filter是什么"><a href="#filter是什么" class="headerlink" title="filter是什么"></a>filter是什么</h1><p>这个filter究竟是什么呢？我将它强行解释成代码的“过滤器”，cpplint 是一款检查C++源代码风格的工具，遵循的是Google的编码风格，但是这些规则并不是对于所有人都合适，我们应该有目的进行选择，这个filter参数就是用来屏蔽或者启用一些规则的，我们还是从帮助文档里来看，其中有一段</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">filter=-x,+y,...</span><br><span class="line">  Specify a comma-separated list of category-filters to apply: only</span><br><span class="line">  error messages whose category names pass the filters will be printed.</span><br><span class="line">  (Category names are printed with the message and look like</span><br><span class="line">  <span class="string">"[whitespace/indent]"</span>.)  Filters are evaluated left to right.</span><br><span class="line">  <span class="string">"-FOO"</span> means <span class="string">"do not print categories that start with FOO"</span>.</span><br><span class="line">  <span class="string">"+FOO"</span> means <span class="string">"do print categories that start with FOO"</span>.</span><br><span class="line"></span><br><span class="line">  Examples: --filter=-whitespace,+whitespace/braces</span><br><span class="line">            --filter=-whitespace,-runtime/<span class="built_in">printf</span>,+runtime/printf_format</span><br><span class="line">            --filter=-,+build/include_what_you_use</span><br><span class="line"></span><br><span class="line">  To see a list of all the categories used <span class="keyword">in</span> cpplint, pass no arg:</span><br><span class="line">     --filter=</span><br></pre></td></tr></table></figure><p>这一段说明了filter参数的用法，就是以<code>+</code>或者 <code>-</code> 开头接着写规则名，就表示启用或者屏蔽这些规则，使用 <code>--filter=</code> 参数会列举出所有规则，我们来看一下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\Albert&gt;cpplint --filter=</span><br><span class="line">  build/class</span><br><span class="line">  build/c++11</span><br><span class="line">  build/c++14</span><br><span class="line">  build/c++tr1</span><br><span class="line">  build/deprecated</span><br><span class="line">  build/endif_comment</span><br><span class="line">  build/explicit_make_pair</span><br><span class="line">  build/forward_decl</span><br><span class="line">  build/header_guard</span><br><span class="line">  build/include</span><br><span class="line">  build/include_subdir</span><br><span class="line">  build/include_alpha</span><br><span class="line">  build/include_order</span><br><span class="line">  build/include_what_you_use</span><br><span class="line">  build/namespaces_headers</span><br><span class="line">  build/namespaces_literals</span><br><span class="line">  build/namespaces</span><br><span class="line">  build/printf_format</span><br><span class="line">  build/storage_class</span><br><span class="line">  legal/copyright</span><br><span class="line">  readability/alt_tokens</span><br><span class="line">  readability/braces</span><br><span class="line">  readability/casting</span><br><span class="line">  readability/check</span><br><span class="line">  readability/constructors</span><br><span class="line">  readability/fn_size</span><br><span class="line">  readability/inheritance</span><br><span class="line">  readability/multiline_comment</span><br><span class="line">  readability/multiline_string</span><br><span class="line">  readability/namespace</span><br><span class="line">  readability/nolint</span><br><span class="line">  readability/nul</span><br><span class="line">  readability/strings</span><br><span class="line">  readability/todo</span><br><span class="line">  readability/utf8</span><br><span class="line">  runtime/arrays</span><br><span class="line">  runtime/casting</span><br><span class="line">  runtime/explicit</span><br><span class="line">  runtime/int</span><br><span class="line">  runtime/init</span><br><span class="line">  runtime/invalid_increment</span><br><span class="line">  runtime/member_string_references</span><br><span class="line">  runtime/memset</span><br><span class="line">  runtime/indentation_namespace</span><br><span class="line">  runtime/operator</span><br><span class="line">  runtime/<span class="built_in">printf</span></span><br><span class="line">  runtime/printf_format</span><br><span class="line">  runtime/references</span><br><span class="line">  runtime/string</span><br><span class="line">  runtime/threadsafe_fn</span><br><span class="line">  runtime/vlog</span><br><span class="line">  whitespace/blank_line</span><br><span class="line">  whitespace/braces</span><br><span class="line">  whitespace/comma</span><br><span class="line">  whitespace/comments</span><br><span class="line">  whitespace/empty_conditional_body</span><br><span class="line">  whitespace/empty_if_body</span><br><span class="line">  whitespace/empty_loop_body</span><br><span class="line">  whitespace/end_of_line</span><br><span class="line">  whitespace/ending_newline</span><br><span class="line">  whitespace/forcolon</span><br><span class="line">  whitespace/indent</span><br><span class="line">  whitespace/line_length</span><br><span class="line">  whitespace/newline</span><br><span class="line">  whitespace/operators</span><br><span class="line">  whitespace/parens</span><br><span class="line">  whitespace/semicolon</span><br><span class="line">  whitespace/tab</span><br><span class="line">  whitespace/todo</span><br></pre></td></tr></table></figure><p>这些选项还挺多的，一共有69项，但是现在有一个问题，我就一直没找到这些选项都代表什么含义，有些从名字可以推断出来，比如 <code>whitespace/line_length</code> 应该是指每行的长度限制，但是 <code>whitespace/comma</code> 单单从名字你知道他们是什么意思吗？所以我想简单总结一下。</p><h1 id="一个小实验"><a href="#一个小实验" class="headerlink" title="一个小实验"></a>一个小实验</h1><p>都说cpplint非常好用，那么接下来我们看看这个工具要怎么用，先新建一个文件<code>teststyle</code>，在里面随便写一些C++代码，如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Style</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"This is style class"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">showName</span><span class="params">(<span class="built_in">string</span>&amp; extraMsg)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; extraMsg &lt;&lt; className &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">string</span> className;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Style s;</span><br><span class="line">    <span class="built_in">string</span> msg_fjakdjfkadjfkadjffjadfkasdjffajsdfkadvljakdjfakdfjkadfjkasdjfkasdfj=<span class="string">"class_name:"</span>;</span><br><span class="line">    s.showName( msg_fjakdjfkadjfkadjffjadfkasdjffajsdfkadvljakdjfakdfjkadfjkasdjfkasdfj );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(s.className == <span class="string">""</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"class name for s is empty."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段临时“发挥”的代码可以正常编译运行，然后用<code>cpplint</code>工具检测一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&gt; cpplint .\teststyle.cpp</span><br><span class="line">.\teststyle.cpp:0:  No copyright message found.  You should have a line: &quot;Copyright [year] &lt;Copyright Owner&gt;&quot;  [legal/copyright] [5]</span><br><span class="line">.\teststyle.cpp:3:  Do not use namespace using-directives.  Use using-declarations instead.  [build/namespaces] [5]</span><br><span class="line">.\teststyle.cpp:6:  &#123; should almost always be at the end of the previous line  [whitespace/braces] [4]</span><br><span class="line">.\teststyle.cpp:7:  public: should be indented +1 space inside class Style  [whitespace/indent] [3]</span><br><span class="line">.\teststyle.cpp:8:  Tab found; better to use spaces  [whitespace/tab] [1]</span><br><span class="line">.\teststyle.cpp:12:  Is this a non-const reference? If so, make const or use a pointer: string&amp; extraMsg  [runtime/references] [2]</span><br><span class="line">.\teststyle.cpp:13:  &#123; should almost always be at the end of the previous line  [whitespace/braces] [4]</span><br><span class="line">.\teststyle.cpp:16:  public: should be indented +1 space inside class Style  [whitespace/indent] [3]</span><br><span class="line">.\teststyle.cpp:21:  &#123; should almost always be at the end of the previous line  [whitespace/braces] [4]</span><br><span class="line">.\teststyle.cpp:23:  Lines should be &lt;= 80 characters long  [whitespace/line_length] [2]</span><br><span class="line">.\teststyle.cpp:23:  Missing spaces around =  [whitespace/operators] [4]</span><br><span class="line">.\teststyle.cpp:24:  Lines should be &lt;= 80 characters long  [whitespace/line_length] [2]</span><br><span class="line">.\teststyle.cpp:24:  Extra space after ( in function call  [whitespace/parens] [4]</span><br><span class="line">.\teststyle.cpp:24:  Extra space before )  [whitespace/parens] [2]</span><br><span class="line">.\teststyle.cpp:26:  Missing space before ( in if(  [whitespace/parens] [5]</span><br><span class="line">.\teststyle.cpp:27:  &#123; should almost always be at the end of the previous line  [whitespace/braces] [4]</span><br><span class="line">.\teststyle.cpp:32:  Could not find a newline character at the end of the file.  [whitespace/ending_newline] [5]</span><br><span class="line">Done processing .\teststyle.cpp</span><br><span class="line">Total errors found: 17</span><br></pre></td></tr></table></figure><p>这么一小段代码居然报出了17个错误，厉不厉害？刺不刺激？下面来逐个解释一下：</p><blockquote><p>.\teststyle.cpp:0:  No copyright message found.  You should have a line: “Copyright [year] <copyright owner="">“  [legal/copyright] [5]</copyright></p></blockquote><p><code>[legal/copyright]</code> 表示文件中应该有形如 <code>Copyright [year] &lt;Copyright Owner&gt;</code> 版权信息</p><blockquote><p>\teststyle.cpp:3:  Do not use namespace using-directives.  Use using-declarations instead.  [build/namespaces] [5]</p></blockquote><p><code>[legal/copyright]</code> 表示第3行 <code>using namespace std;</code> 应该使用 <code>using-declarations</code> 而不要使用 <code>using-directives</code>，这个规则可以简单的理解为使用命名空间，每次只引用其中的成员，而不要把整个命名空间都引入。</p><blockquote><p>.\teststyle.cpp:6:  { should almost always be at the end of the previous line  [whitespace/braces] [4]</p></blockquote><p><code>[whitespace/braces]</code> 表示第6行的大括号应该放在上一行末尾</p><blockquote><p>.\teststyle.cpp:7:  public: should be indented +1 space inside class Style  [whitespace/indent] [3]</p></blockquote><p><code>[whitespace/indent]</code> 表示第7行 <code>public:</code> 应该在行首只保留一个空格</p><blockquote><p>.\teststyle.cpp:8:  Tab found; better to use spaces  [whitespace/tab] [1]</p></blockquote><p><code>[whitespace/tab]</code> 表示代码中第8行出现了Tab字符，应该使用空格代替</p><blockquote><p>.\teststyle.cpp:12:  Is this a non-const reference? If so, make const or use a pointer: string&amp; extraMsg  [runtime/references] [2]</p></blockquote><p><code>[runtime/references]</code> 表示代码第12行建议使用常引用</p><blockquote><p>.\teststyle.cpp:23:  Lines should be &lt;= 80 characters long  [whitespace/line_length] [2]</p></blockquote><p><code>[whitespace/line_length]</code> 表示代码第23行长度超过了80个字符</p><blockquote><p>.\teststyle.cpp:23:  Missing spaces around =  [whitespace/operators] [4]</p></blockquote><p><code>[whitespace/operators]</code> 表示代码第23行在赋值符号 <code>=</code> 前后应该有一个空格</p><blockquote><p>.\teststyle.cpp:24:  Extra space after ( in function call  [whitespace/parens] [4]</p></blockquote><p><code>[whitespace/parens]</code> 表示代码第24行在小括号后面出现了多余的空格</p><blockquote><p>.\teststyle.cpp:26:  Missing space before ( in if(  [whitespace/parens] [5]</p></blockquote><p><code>[whitespace/parens]</code> 表示代码第26行if后面缺少空格</p><blockquote><p>.\teststyle.cpp:32:  Could not find a newline character at the end of the file.  [whitespace/ending_newline] [5]</p></blockquote><p><code>[whitespace/ending_newline]</code> 表示32行，文件末尾应该是一个空行</p><p>按照上面<code>cpplint</code>提示修改代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Copyright [2021] &lt;Copyright albert&gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Style</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"This is style class"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showName</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; extraMsg)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; extraMsg &lt;&lt; className &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">string</span> className;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Style s;</span><br><span class="line">    <span class="built_in">string</span> msg = <span class="string">"class_name:"</span>;</span><br><span class="line">    s.showName(msg);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (s.className == <span class="string">""</span>) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"class name for s is empty."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="自己指定筛选规则"><a href="#自己指定筛选规则" class="headerlink" title="自己指定筛选规则"></a>自己指定筛选规则</h1><p>有些人按照上面默认的规则修改代码之后感觉清爽了不少，而有些人却更加郁闷了，因为这些规则是google内部自己根据需要制定的，并不能满足所有人的需求，所以自己需要有目的的做出选择，比如我就决定项目中不写版权信息，那么再使用<code>cpplint</code> 时可以把检测版权信息的规则过滤掉：<code>cpplint --filter=&quot;-legal/copyright&quot; .\teststyle.cpp</code>。</p><h1 id="对照表格"><a href="#对照表格" class="headerlink" title="对照表格"></a>对照表格</h1><p>总体来说规则还是很多的，想要在一段代码中展示出所有的情况不太容易，所以整理了下面的表格，对一些规则做了解释，因为有些情况我也没有遇到，所以先空着，后面再慢慢补充，这也是做这篇总结的目的，当有一种规则需求时先来查一下，越来越完整。</p><table><thead><tr><th style="text-align:left">filter</th><th style="text-align:left">解释</th></tr></thead><tbody><tr><td style="text-align:left">build/class</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">build/c++11</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">build/c++14</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">build/c++tr1</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">build/deprecated</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">build/endif_comment</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">build/explicit_make_pair</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">build/forward_decl</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">build/header_guard</td><td style="text-align:left">①头文件需要添加只被包含一次的宏，<code>#ifndef</code>、<code>#define</code></td></tr><tr><td style="text-align:left">build/include</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">build/include_subdir</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">build/include_alpha</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">build/include_order</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">build/include_what_you_use</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">build/namespaces_headers</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">build/namespaces_literals</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">build/namespaces</td><td style="text-align:left">①不要引入整个命名空间，仅引入需要使用的成员</td></tr><tr><td style="text-align:left">build/printf_format</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">build/storage_class</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">legal/copyright</td><td style="text-align:left">①文件中缺少版权信息</td></tr><tr><td style="text-align:left">readability/alt_tokens</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">readability/braces</td><td style="text-align:left">①如果if一个分支包含大括号，那么其他分支也应该包括大括号</td></tr><tr><td style="text-align:left">readability/casting</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">readability/check</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">readability/constructors</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">readability/fn_size</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">readability/inheritance</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">readability/multiline_comment</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">readability/multiline_string</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">readability/namespace</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">readability/nolint</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">readability/nul</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">readability/strings</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">readability/todo</td><td style="text-align:left">①TODO注释中应包括用户名</td></tr><tr><td style="text-align:left">readability/utf8</td><td style="text-align:left">①文件应该使用utf8编码</td></tr><tr><td style="text-align:left">runtime/arrays</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">runtime/casting</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">runtime/explicit</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">runtime/int</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">runtime/init</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">runtime/invalid_increment</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">runtime/member_string_references</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">runtime/memset</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">runtime/indentation_namespace</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">runtime/operator</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">runtime/printf</td><td style="text-align:left">①使用sprintf替换strcpy、strcat</td></tr><tr><td style="text-align:left">runtime/printf_format</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">runtime/references</td><td style="text-align:left">①确认是否要使用常引用</td></tr><tr><td style="text-align:left">runtime/string</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">runtime/threadsafe_fn</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">runtime/vlog</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">whitespace/blank_line</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">whitespace/braces</td><td style="text-align:left">①左大括号应该放在上一行末尾</td></tr><tr><td style="text-align:left">whitespace/comma</td><td style="text-align:left">①逗号后面应该有空格</td></tr><tr><td style="text-align:left">whitespace/comments</td><td style="text-align:left">①//后应该紧跟着一个空格</td></tr><tr><td style="text-align:left">whitespace/empty_conditional_body</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">whitespace/empty_if_body</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">whitespace/empty_loop_body</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">whitespace/end_of_line</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">whitespace/ending_newline</td><td style="text-align:left">①文件末尾需要空行</td></tr><tr><td style="text-align:left">whitespace/forcolon</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">whitespace/indent</td><td style="text-align:left">①public、protected、private前需要1个空格</td></tr><tr><td style="text-align:left">whitespace/line_length</td><td style="text-align:left">①代码行长度有限制</td></tr><tr><td style="text-align:left">whitespace/newline</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">whitespace/operators</td><td style="text-align:left">①操作符前后需要有空格</td></tr><tr><td style="text-align:left">whitespace/parens</td><td style="text-align:left">①if、while、for、switch后的小括号前需要有空格。②小括号中的首个参数前和最后参数尾不应有空格</td></tr><tr><td style="text-align:left">whitespace/semicolon</td><td style="text-align:left">①分号后缺少空格，比如<code>{ return 1;}</code></td></tr><tr><td style="text-align:left">whitespace/tab</td><td style="text-align:left">①使用空格代替tab</td></tr><tr><td style="text-align:left">whitespace/todo</td><td style="text-align:left">①TODO注释前空格太多。②TODO注释中用户名后应该有一个空格</td></tr></tbody></table><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li><code>cpplint</code> 是一个检查c++代码风格的小工具</li><li><code>cpplint.py</code> 其实是一个Python脚本文件，使用前可以先安装Python环境</li><li>使用 <code>cpplint</code> 时默认遵循的是<a href="https://google.github.io/styleguide/cppguide.html" target="_blank" rel="noopener">Google的代码风格</a></li><li>为了让代码检测符合自己的习惯，需要使用<code>--filter=</code>参数选项，有多种规则可以选择或者忽略</li><li><code>--filter=</code>中的规则是一个大类，比如 <code>whitespace/parens</code> 既检查小括号前缺少空格的情况，也会检查小括号中多空格的情况</li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/117393224" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>生活中会有一些感悟的瞬间，娃娃哭闹时大人们总是按照自己的经验来出处理，碰上倔脾气小孩往往毫无作用。其实孩子是最单纯的，想要什么不想要什么都摆在脸上，愿望一旦被满足立马就不哭了，而大人才世界是难处理的，长大的人类善于隐藏和伪装，想要的不一定说出来，说出来不一定是想要的，所以很多人才会羡慕小孩子的天真和无邪~</p><p>努力吧！哪管什么真理无穷，进一步有进一步的欢喜</p><p>2021-6-20 18:46:45</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&lt;code&gt;cpplint&lt;/code&gt; 是一款优秀的代码格式检查工具，有了它可以统一整个团队的代码风格，完整的工具就是一个Python脚本，如果安装了Python环境，直接使用 &lt;code&gt;pip install cpplint&lt;/code&gt; 命令就可以安装了，非常的方便。&lt;/p&gt;
    
    </summary>
    
      <category term="C/C++" scheme="http://AlbertGithubHome.github.io/blog/categories/C-C/"/>
    
    
      <category term="C/C++" scheme="http://AlbertGithubHome.github.io/blog/tags/C-C/"/>
    
      <category term="Python" scheme="http://AlbertGithubHome.github.io/blog/tags/Python/"/>
    
      <category term="cpplint" scheme="http://AlbertGithubHome.github.io/blog/tags/cpplint/"/>
    
      <category term="filter" scheme="http://AlbertGithubHome.github.io/blog/tags/filter/"/>
    
  </entry>
  
  <entry>
    <title>C++对我来说简直就是星辰大海，为了避免翻船，我选择从小河沟出发</title>
    <link href="http://AlbertGithubHome.github.io/blog/2021/05/24/C-%E5%AF%B9%E6%88%91%E6%9D%A5%E8%AF%B4%E7%AE%80%E7%9B%B4%E5%B0%B1%E6%98%AF%E6%98%9F%E8%BE%B0%E5%A4%A7%E6%B5%B7/"/>
    <id>http://AlbertGithubHome.github.io/blog/2021/05/24/C-对我来说简直就是星辰大海/</id>
    <published>2021-05-24T14:36:30.000Z</published>
    <updated>2021-05-27T16:42:25.666Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>你学的越多，不懂的东西反而越多~</p></blockquote><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>以前觉得 C++ 并没有什么复杂的，不就是 C 语言加上类定义、模板、容器、算法函数这些就可以了吗，只要我不用，它就难不倒我，用到了查查文档也就搞定了，真的是年少轻狂啊。</p><a id="more"></a><p>随着学习的深入渐渐发现，即使抛开那些算法函数、那些冗长的模板，单单是 C++ 核心的概念和类型就够喝上好几壶的，随便罗列几个，像 <code>std::furnitrue</code>、<code>std::memory_order</code>、<code>std::packaged_task</code> 等等这些，之前都没听说过，特别是C++20的协程，到现在还是一头雾水。</p><p>C++ 缺少了 C 语言的纯粹，总是喜欢在编译时加点料，但是这个协程加的料超多，一时间还有点接受不了。</p><p>不过第一次听说协程这个词是在 Lua 中，全称被叫做协同程序，记得没错是在 《Lua程序设计》这本书中看到的，里面专门有一章是讲coroutine的，并且在 Lua 中定义和使用协程很方便，所以决定先复习一下 Lua 中的协程，然后对比着 C++的协程来进行拓展学习。</p><h1 id="进程-vs-线程-vs-协程"><a href="#进程-vs-线程-vs-协程" class="headerlink" title="进程 vs 线程 vs 协程"></a>进程 vs 线程 vs 协程</h1><p>这三者常常被拿来比较，而引入多进程、多线程、多协程有一个简单而纯粹的目的，那就是榨干CPU，不过这三者侧重还有所不同。</p><p>进程是资源分配最小单位，每个进程都有独立的地址空间，来维护代码段、堆栈段和数据段，但是创建和切换进程的开销较大，可以在多台物理机和多核CPU上提高效率，依靠管道（pipe）、命名管道（named pipe/FIFO）、信号量（semophore）、消息队列（message queue）、信号（sinal）、共享内存（shared memory）、套接字（socket）、全双工管道等途径来进行通信。</p><p>线程是任务调度和执行的最小单位，没有独立的地址空间，但有独立的运行栈和程序计数器（PC），创建和切换线程的开销相比进程来说要小得多，线程之间通信更加方便，除了可以使用进程间通信的方式，还可以简单地通过共享全局变量，静态变量等进行通信，但是需要锁机制、信号量机制、信号机制来控制线程间互斥。</p><p>协程这个概念就比较迷了，其实它不像多进程和多线程那样可以在多核机器上提供并行的能力，而是侧重于相互协作共同完成某个任务，同一个线程中可以启动多个协程，但这些协程同一时刻只能有一个在运行。</p><p>协程其实可以看成是一个可以被随时停止和唤醒的函数，使用协程是为了在用户层面来控制调用逻辑，对比于多线程程序的线程调度完全看操作系统的心情的处境，多协程的程序就比较自主了，可以由开发者来控制函数执行顺序。</p><p>还有一个特性很重要，就是使用协程可以实现用“同步”的方式来写“异步”的代码，这一点不理解没关系，以后会慢慢明白的。说到这，不得不说一下关于同步和异步、阻塞和非阻塞这几个概念，它们常常被大家混在一起来说，实际上只是从不同维度来描述了一件事情，下面简单叙述下。</p><h1 id="同步-vs-异步"><a href="#同步-vs-异步" class="headerlink" title="同步 vs 异步"></a>同步 vs 异步</h1><p>同步和异步指的是消息通信的机制，或者说得到结果的方式。</p><ul><li><p>同步：调用函数后就能返回想要的结果，有点像去食堂买饭，自己去食堂付完钱（调用），饭（结果）就可以被拿回来了，这就是同步调用的方式，与返回结果的时间长短无关，得到结果之后直接执行后面的逻辑（吃饭）就可以了，所以同步的逻辑是最好写的。</p></li><li><p>异步：调用函数后并不能直接得到想要的结果，需要通过回调或者其他消息来通知，这就有点像定外卖了，打开APP选好饭菜输入地址（注册回调），开始付钱（调用），此时并不能直接得到饭（结果），而是一段时间之后，有外卖小哥将饭（结果）给你送来，这时才能执行后面的逻辑（吃饭）。</p></li></ul><p>总结来说，需要自己取结果的就是同步，依靠别人送结果的就是异步。</p><h1 id="阻塞-vs-非阻塞"><a href="#阻塞-vs-非阻塞" class="headerlink" title="阻塞 vs 非阻塞"></a>阻塞 vs 非阻塞</h1><p>阻塞和非阻塞指的是程序在等待调用结果时的状态，强调在获得结果之前的表现。</p><ul><li><p>阻塞：调用函数后由于不满足某种条件（比如读socket但是没有数据）被挂起，当条件满足（socket来数据了）时被唤醒，并将结果返回。</p></li><li><p>非阻塞：调用函数后如果不满足指定条件（比如读socket但是没有数据）不挂起，而是返回一个表示没有取到结果的值，你可以按照某种间隔再次调用函数，直到取到结果为止，当然你也可以调用一次就结束了。</p></li></ul><p>总结来说，不满足条件时调用方被挂起就是阻塞调用，否则就是非阻塞调用。</p><h1 id="协程学习"><a href="#协程学习" class="headerlink" title="协程学习"></a>协程学习</h1><p>C++的协程是暂时学不明白了，为了不翻车，我还是从熟悉的 Lua 入手，来举例说明什么是协程？有什么用？为什么这样用？弄明白以后再慢慢用 C++ 来实现相同的目的，毕竟 C++ 这一块需要实现的内容也有点多。</p><h2 id="消费者-生产者"><a href="#消费者-生产者" class="headerlink" title="消费者-生产者"></a>消费者-生产者</h2><p>提到 Lua 的协程就会想到 “消费者-生产者”的例子，网上关于这个的实现有特别多的版本，整体上来说大同小异，基本上都是 《C++程序设计》这本书中的内容，但是这一部分我看了很多遍，感觉这个例子并不太好。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">receive</span><span class="params">(prod)</span></span>  <span class="comment">-- 激活协同程序</span></span><br><span class="line">  <span class="keyword">local</span> <span class="built_in">status</span>,value = coroutine.<span class="built_in">resume</span>(prod)</span><br><span class="line">  <span class="keyword">return</span> value</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">send</span><span class="params">(x)</span></span>  <span class="comment">-- 挂起协同程序</span></span><br><span class="line">  coroutine.<span class="built_in">yield</span>(x)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">producer</span><span class="params">()</span></span>  <span class="comment">-- 生产者</span></span><br><span class="line">  <span class="keyword">return</span> coroutine.<span class="built_in">create</span>(  <span class="comment">-- 创建协同程序</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">          <span class="keyword">while</span> <span class="literal">true</span> <span class="keyword">do</span></span><br><span class="line">              <span class="keyword">local</span> x = <span class="built_in">io</span>.<span class="built_in">read</span>()  <span class="comment">-- 产生新值</span></span><br><span class="line">              send(x)</span><br><span class="line">          <span class="keyword">end</span></span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">  )</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">filter</span><span class="params">(prod)</span></span>  <span class="comment">-- 过滤器</span></span><br><span class="line">  <span class="keyword">return</span> coroutine.<span class="built_in">create</span>(  <span class="comment">-- 创建协同程序</span></span><br><span class="line">      <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">          <span class="keyword">for</span> line = <span class="number">1</span>, <span class="built_in">math</span>.<span class="built_in">huge</span> <span class="keyword">do</span></span><br><span class="line">              <span class="keyword">local</span> x = receive(prod)  <span class="comment">-- 激活协同程序来获取新值</span></span><br><span class="line">              x = <span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">"%5d %s"</span>,line , x )  <span class="comment">-- 过滤规则</span></span><br><span class="line">              send(x)  <span class="comment">-- 挂起激活程序</span></span><br><span class="line">          <span class="keyword">end</span></span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">  )</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">consumer</span><span class="params">(prod)</span></span></span><br><span class="line">  <span class="keyword">while</span> <span class="literal">true</span> <span class="keyword">do</span></span><br><span class="line">      <span class="keyword">local</span> x = receive(prod) <span class="comment">-- 获取新值</span></span><br><span class="line">      <span class="built_in">io</span>.<span class="built_in">write</span>(x, <span class="string">"\n"</span>)       <span class="comment">-- 消费新值</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">p= producer()  <span class="comment">-- 初始化生产者</span></span><br><span class="line">f = filter(p)  <span class="comment">-- 初始化过滤器</span></span><br><span class="line">consumer(f)    <span class="comment">-- 初始化消费者并启动程序</span></span><br></pre></td></tr></table></figure><p>这就是一个消费者驱动的模型，首先由启动消费者，然后调用生产者来生产资源，接着消费者消耗掉新的资源，再控制生产者生产新的资源，以此方式循环往复，其实就是下面代码的复杂化：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">consumer_producer</span><span class="params">()</span></span></span><br><span class="line">  <span class="keyword">while</span> <span class="literal">true</span> <span class="keyword">do</span></span><br><span class="line">      <span class="keyword">local</span> x = <span class="built_in">io</span>.<span class="built_in">read</span>()  <span class="comment">-- 产生新值</span></span><br><span class="line">      <span class="built_in">io</span>.<span class="built_in">write</span>(x, <span class="string">"\n"</span>)    <span class="comment">-- 消费新值</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">consumer_producer() <span class="comment">-- 启动生产者消费者</span></span><br></pre></td></tr></table></figure><p>这个例子以我现在的菜鸟水平来看没啥用，但是有一点比较好，就是展示了可以用协程来控制程序执行顺序的强大功能，只是这个消费者和生产者强耦合的设计实在是看不明白。</p><h2 id="自己想个例子"><a href="#自己想个例子" class="headerlink" title="自己想个例子"></a>自己想个例子</h2><p>既然他们的例子我都不喜欢，那我就自己想一个，叮铃铃！下面我收到了一个新的需求：</p><blockquote><p>计算1+2+3+4+5+6+7+8+9+10的和，然后等待5秒钟后，将结果显示在控制台上。</p></blockquote><p>乍一听，这个需求太简单了吧，没有一点难度，其实不然，其中蕴含着大量玄机，简直就是一个万能句式：</p><blockquote><p>做一件事情A，然后等待某件事发生，再做一件事情B（可能与A相关）</p></blockquote><p>仔细想想，这样的“句式”在开发中，生活中是不是经常出现？</p><ol><li>下载电影，下载完成后，播放电影</li><li>开始加载场景，加载完成后，隐藏加载进度条</li><li>发送一个请求，收到回复时，将回复结果显示出来</li><li>…</li></ol><p>看了吧，现实中有很多这类需求，我们接下来尝试着实现一下</p><h3 id="常规写法"><a href="#常规写法" class="headerlink" title="常规写法"></a>常规写法</h3><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- lua 没有 sleep 函数，使用while循环模拟</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sleep</span><span class="params">(n)</span></span></span><br><span class="line">    <span class="keyword">local</span> t = <span class="built_in">os</span>.<span class="built_in">clock</span>()</span><br><span class="line">    <span class="keyword">while</span> <span class="built_in">os</span>.<span class="built_in">clock</span>() - t &lt;= n <span class="keyword">do</span> <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">task_method_1</span><span class="params">()</span></span></span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">"program start at %s"</span>, <span class="built_in">os</span>.<span class="built_in">date</span>(<span class="string">"%H:%M:%S"</span>)))</span><br><span class="line"></span><br><span class="line">    <span class="comment">-- 求和</span></span><br><span class="line">    <span class="keyword">local</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> i=<span class="number">1</span>,<span class="number">10</span> <span class="keyword">do</span></span><br><span class="line">        sum = sum + i;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">-- 等待</span></span><br><span class="line">    sleep(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">-- 展示</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">"program end at %s and sum = %d"</span>, <span class="built_in">os</span>.<span class="built_in">date</span>(<span class="string">"%H:%M:%S"</span>), sum))</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">main1</span><span class="params">()</span></span></span><br><span class="line">    task_method_1()</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">main1()</span><br></pre></td></tr></table></figure><p>代码很简单，为了看起来更连贯这里就不分段展示了，首先模拟一个 <code>sleep</code> 函数，然后实现 <code>task_method_1</code> 函数来完成原始需求——求和、等待、展示，最后通过主函数来调用就可以了。</p><p>运行结果如下:</p><blockquote><p>program start at 01:30:27<br>program end at 01:30:32 and sum = 55</p></blockquote><h3 id="进阶写法"><a href="#进阶写法" class="headerlink" title="进阶写法"></a>进阶写法</h3><p>看了上面的代码有没有发现什么问题？这是一种同步的实现方式，整个程序在中间等待的5秒钟什么都不能做，必须等倒计时结束才能做后面的事情，这要是购物APP点了5秒没反应就直接X掉了，这可是赤果果的金钱损失啊，绝不能让这种事情发生。</p><p>怎么办呢？我确实需要5秒钟的处理时间，但是又不能让用户卡在那，我可以显示一个进度条，进度一直再变化，用户就不会以为程序卡死了，如果进度走的比较慢，他可能以为手机老旧该换了，没准还促进了手机的销量呢！</p><p>顺着这个思路写出了下面这种实现，这是一种异步的实现方式，通过回调函数来通知最终要显示的结果。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">task_method_2</span><span class="params">()</span></span></span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">"program start at %s"</span>, <span class="built_in">os</span>.<span class="built_in">date</span>(<span class="string">"%H:%M:%S"</span>)))</span><br><span class="line"></span><br><span class="line">    <span class="comment">-- 求和</span></span><br><span class="line">    <span class="keyword">local</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> i=<span class="number">1</span>,<span class="number">10</span> <span class="keyword">do</span></span><br><span class="line">        sum = sum + i;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">-- 注册回调函数，进行等待</span></span><br><span class="line">    add_callback(<span class="number">5</span>, call_back_print, sum)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">call_back_print</span><span class="params">(data)</span></span></span><br><span class="line">    <span class="comment">--展示结果</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">"program end at %s and sum = %d"</span>, <span class="built_in">os</span>.<span class="built_in">date</span>(<span class="string">"%H:%M:%S"</span>), data))</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add_callback</span><span class="params">(inteval, func, data)</span></span></span><br><span class="line">    interval_time = inteval</span><br><span class="line">    call_back = func</span><br><span class="line">    msg_data = data</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">main2</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">local</span> t0 = <span class="built_in">os</span>.<span class="built_in">clock</span>();</span><br><span class="line">    <span class="keyword">local</span> t = t0;</span><br><span class="line"></span><br><span class="line">    task_method_2()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">true</span> <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">local</span> now = <span class="built_in">os</span>.<span class="built_in">clock</span>()</span><br><span class="line">        <span class="keyword">if</span> now - t &gt;= <span class="number">1</span> <span class="keyword">then</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">"program run %f seconds"</span>, now - t0))</span><br><span class="line">            t = now;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> interval_time <span class="keyword">and</span> call_back <span class="keyword">and</span> now - t0 &gt;= interval_time <span class="keyword">then</span></span><br><span class="line">                call_back(msg_data)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">main2()</span><br></pre></td></tr></table></figure><p>在函数 <code>task_method_2</code> 中计算完求和的结果，并没有等待，而是通过 <code>add_callback</code> 函数注册了等待时间、回调函数、以及回调展示的结果，然后直接返回了调用方，调用主函数 <code>main2</code> 中计算这时间差并展示进度，等倒计时一结束就执行回调函数，进而展示出结果。</p><p>运行结果如下，通过打印信息展示处理进度条:</p><blockquote><p>program start at 01:44:56<br>program run 1.000000 seconds<br>program run 2.001000 seconds<br>program run 3.001000 seconds<br>program run 4.001000 seconds<br>program run 5.001000 seconds<br>program end at 01:45:01 and sum = 55</p></blockquote><h3 id="协程写法"><a href="#协程写法" class="headerlink" title="协程写法"></a>协程写法</h3><p>卡顿的问题解决了，但是添加了一大堆额外的注册和回调函数，有些麻烦啊，怎么把它们去掉呢？</p><p>终于等到协程出场了，同步调用很卡、异步回调很烦，那么协程可以实现用“同步”的方式来写“异步”的代码，既不卡也不烦，下面来看一下实现。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">task_method_3</span><span class="params">()</span></span></span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">"program start at %s"</span>, <span class="built_in">os</span>.<span class="built_in">date</span>(<span class="string">"%H:%M:%S"</span>)))</span><br><span class="line"></span><br><span class="line">    <span class="comment">-- 求和</span></span><br><span class="line">    <span class="keyword">local</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> i=<span class="number">1</span>,<span class="number">10</span> <span class="keyword">do</span></span><br><span class="line">        sum = sum + i;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">-- 等待</span></span><br><span class="line">    coroutine.<span class="built_in">yield</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">-- 展示</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">"program end at %s and sum = %d"</span>, <span class="built_in">os</span>.<span class="built_in">date</span>(<span class="string">"%H:%M:%S"</span>), sum))</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">main3</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">local</span> t0 = <span class="built_in">os</span>.<span class="built_in">clock</span>();</span><br><span class="line">    <span class="keyword">local</span> t = t0;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">local</span> co = coroutine.<span class="built_in">create</span>(task_method_3)</span><br><span class="line">    <span class="keyword">local</span> <span class="built_in">status</span>, interval = coroutine.<span class="built_in">resume</span>(co)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">true</span> <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">local</span> now = <span class="built_in">os</span>.<span class="built_in">clock</span>()</span><br><span class="line">        <span class="keyword">if</span> now - t &gt;= <span class="number">1</span> <span class="keyword">then</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">"program run %f seconds"</span>, now - t0))</span><br><span class="line">            t = now;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> now - t0 &gt;= interval <span class="keyword">then</span></span><br><span class="line">                coroutine.<span class="built_in">resume</span>(co)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">main3()</span><br></pre></td></tr></table></figure><p>对比 <code>task_method_3</code> 和 <code>task_method_1</code> 函数，只是将 <code>sleep</code> 函数换成了 <code>coroutine.yield(5)</code>，整个需求函数很紧凑。</p><p>程序运行逻辑是这样的，先将 <code>task_method_3</code> 函数包装成协程 <code>co</code>，然后启动 <code>co</code> 执行求和逻辑，执行到 <code>coroutine.yield(5);</code> 这句，协程被暂停并将5返回，主函数 <code>main3</code> 中收到返回值5后开始计时并展示进度值，直到5秒等待期结束再次唤醒协程 <code>co</code>，<code>coroutine.yield(5);</code> 后面的代码继续执行，完成最后的展示需求。</p><p>运行结果如下：</p><blockquote><p>program start at 01:50:59<br>program run 1.000000 seconds<br>program run 2.000000 seconds<br>program run 3.000000 seconds<br>program run 4.000000 seconds<br>program run 5.000000 seconds<br>program end at 01:51:04 and sum = 55</p></blockquote><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>多进程/多线程的引入并不是总能降低任务消耗的时间，还要考虑到进程/线程切换的消耗问题，参考Redis实现</li><li>多协程的引入本质上是为了更好的控制程序运行的逻辑，虽然它往往也能带来效率上的提升</li><li><code>coroutine.yield</code> 是协程的中核心函数，主动让出CPU，如果协程不自己挂起，外部无法干预</li><li>知识的迁移是一项重要的技能，下一步要用C++协程来实现这个需求啦，边学边写喽</li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/116868211" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>拨开那一片云，是你未曾实现的梦想，岁月流转，梦想在变，有些事不得不放弃坚守（固执），珍惜眼前的一切，迎接明天的朝阳~</p><p>2021-5-28 00:27:18</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;你学的越多，不懂的东西反而越多~&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;以前觉得 C++ 并没有什么复杂的，不就是 C 语言加上类定义、模板、容器、算法函数这些就可以了吗，只要我不用，它就难不倒我，用到了查查文档也就搞定了，真的是年少轻狂啊。&lt;/p&gt;
    
    </summary>
    
      <category term="C/C++" scheme="http://AlbertGithubHome.github.io/blog/categories/C-C/"/>
    
    
      <category term="C/C++" scheme="http://AlbertGithubHome.github.io/blog/tags/C-C/"/>
    
      <category term="C++20" scheme="http://AlbertGithubHome.github.io/blog/tags/C-20/"/>
    
      <category term="coruntine" scheme="http://AlbertGithubHome.github.io/blog/tags/coruntine/"/>
    
      <category term="recursion" scheme="http://AlbertGithubHome.github.io/blog/tags/recursion/"/>
    
  </entry>
  
  <entry>
    <title>使用AddressSanitizer搭配addr2line查找C/C++内存泄漏问题</title>
    <link href="http://AlbertGithubHome.github.io/blog/2021/05/15/%E4%BD%BF%E7%94%A8AddressSanitizer%E6%90%AD%E9%85%8Daddr2line%E6%9F%A5%E6%89%BEC-C-%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E9%97%AE%E9%A2%98/"/>
    <id>http://AlbertGithubHome.github.io/blog/2021/05/15/使用AddressSanitizer搭配addr2line查找C-C-内存泄漏问题/</id>
    <published>2021-05-15T07:23:13.000Z</published>
    <updated>2021-07-10T08:37:32.945Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>指针是C/C++程序中的利器，同时也引入了风险，现代C++中增加了智能指针来降低使用“裸”指针带来的风险，但是智能指针不是一颗银弹，它不能解决所有的指针问题，内存泄漏在C/C++程序开发中依旧是值得注意的，学会合理、合适的方法来查找内存泄漏问题也是一项有用的技能。</p><p>通常内存泄漏问题会在开发到一定程度时集中检查，一些检测方法长时间不去使用难免会忘记，所以本文记录一种自己常用的检测方法，方便日后查阅。</p><a id="more"></a><h1 id="AddressSanitizer"><a href="#AddressSanitizer" class="headerlink" title="AddressSanitizer"></a>AddressSanitizer</h1><p>AddressSanitizer 是什么东西呢？从名字上直接翻译叫“地址消毒剂”，其实就是用来检查地址问题的。</p><p>它是一款地址问题检测工具，简称 <code>ASAN</code>，开源项目主地址为 <a href="https://github.com/google/sanitizers" target="_blank" rel="noopener">google/sanitizers</a>，是众多检测工具<code>AddressSanitizer</code>, <code>MemorySanitizer</code>, <code>ThreadSanitizer</code>, <code>LeakSanitizer</code> 中的一款，功能非常强大，可以检测出栈上缓冲区溢出、堆上缓冲区溢出、引用已释放内存、内存泄漏等多种地址问题。</p><p>今天想记录的是使用 <code>AddressSanitizer</code> 检测内存泄漏的步骤，其实检测内存泄漏的功能目前已经被基本独立成了 <a href="https://github.com/google/sanitizers/wiki/AddressSanitizerLeakSanitizer" target="_blank" rel="noopener">LeakSanitizer</a>，不过仍可以通过在 AddressSanitizer 工具中通过参数来开启和关闭使用。</p><h1 id="检测步骤"><a href="#检测步骤" class="headerlink" title="检测步骤"></a>检测步骤</h1><p>其实使用 ASAN 检测内存泄漏还是比较简单的，g++4.8 以上的版本自带了 ASAN 工具，只要编译时指定好参数，编译完成后正常启动运行程序就可以了，只不过有些情况下只从检测报告中无法准确定位问题，需要借助一些工具进一步缩小检测范围。</p><h2 id="泄漏发生在可执行程序本身"><a href="#泄漏发生在可执行程序本身" class="headerlink" title="泄漏发生在可执行程序本身"></a>泄漏发生在可执行程序本身</h2><p>这种情况检测起来比较容易，编写如下测试代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//test.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>* p = <span class="keyword">new</span> <span class="keyword">int</span>(); <span class="comment">// 内存泄漏的位置</span></span><br><span class="line">    p = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    func();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"test leak"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用g++进行编译，编译时添加参数 <code>-fsanitize=leak</code> 就可以了，启动后可以清晰的展示出内存泄漏的位置 <code>test.cpp:5</code>，也就是 test.cpp 文件的第5行。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:/mnt/d/data/cpp/testleak$ g++ test.cpp -g -o <span class="built_in">test</span> --std=c++11 -fsanitize=leak</span><br><span class="line">albert@home-pc:/mnt/d/data/cpp/testleak$ ./<span class="built_in">test</span></span><br><span class="line"><span class="built_in">test</span> leak</span><br><span class="line"></span><br><span class="line">=================================================================</span><br><span class="line">==344==ERROR: LeakSanitizer: detected memory leaks</span><br><span class="line"></span><br><span class="line">Direct leak of 4 byte(s) <span class="keyword">in</span> 1 object(s) allocated from:</span><br><span class="line">    <span class="comment">#0 0x7fc7d796d815 in operator new(unsigned long) (/usr/lib/x86_64-linux-gnu/liblsan.so.0+0xd815)</span></span><br><span class="line">    <span class="comment">#1 0x400967 in func() /mnt/d/data/cpp/testleak/test.cpp:5</span></span><br><span class="line">    <span class="comment">#2 0x400985 in main /mnt/d/data/cpp/testleak/test.cpp:11</span></span><br><span class="line">    <span class="comment">#3 0x7fc7d722083f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x2083f)</span></span><br><span class="line"></span><br><span class="line">SUMMARY: LeakSanitizer: 4 byte(s) leaked <span class="keyword">in</span> 1 allocation(s).</span><br><span class="line">albert@home-pc:/mnt/d/data/cpp/testleak$</span><br></pre></td></tr></table></figure><p>这里有个小意外，将 <code>int* p = new int();</code> 这句代码改成 <code>int* p = new int[10];</code> 可以检测出内存泄漏如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:/mnt/d/data/cpp/testleak$ g++ test.cpp -fsanitize=leak -g -o <span class="built_in">test</span> --std=c++11</span><br><span class="line">albert@home-pc:/mnt/d/data/cpp/testleak$ ./<span class="built_in">test</span></span><br><span class="line"><span class="built_in">test</span> leak</span><br><span class="line"></span><br><span class="line">=================================================================</span><br><span class="line">==416==ERROR: LeakSanitizer: detected memory leaks</span><br><span class="line"></span><br><span class="line">Direct leak of 400 byte(s) <span class="keyword">in</span> 1 object(s) allocated from:</span><br><span class="line">    <span class="comment">#0 0x7fdc0c16d975 in operator new[](unsigned long) (/usr/lib/x86_64-linux-gnu/liblsan.so.0+0xd975)</span></span><br><span class="line">    <span class="comment">#1 0x400967 in func() /mnt/d/data/cpp/testleak/test.cpp:5</span></span><br><span class="line">    <span class="comment">#2 0x40097f in main /mnt/d/data/cpp/testleak/test.cpp:11</span></span><br><span class="line">    <span class="comment">#3 0x7fdc0ba2083f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x2083f)</span></span><br><span class="line"></span><br><span class="line">SUMMARY: LeakSanitizer: 400 byte(s) leaked <span class="keyword">in</span> 1 allocation(s).</span><br><span class="line">albert@home-pc:/mnt/d/data/cpp/testleak$</span><br></pre></td></tr></table></figure><p>但是将 <code>int* p = new int();</code> 这句代码改成 <code>int* p = new int[1024];</code> 就无法检测是内存泄漏了，只能修改编译选项为 <code>-fsanitize=address</code> 才能检测出泄漏，目前还不知道真正的原因是什么。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:/mnt/d/data/cpp/testleak$ g++ test.cpp -fsanitize=address -g -o <span class="built_in">test</span> --std=c++11</span><br><span class="line">albert@home-pc:/mnt/d/data/cpp/testleak$ ./<span class="built_in">test</span></span><br><span class="line"><span class="built_in">test</span> leak</span><br><span class="line"></span><br><span class="line">=================================================================</span><br><span class="line">==432==ERROR: LeakSanitizer: detected memory leaks</span><br><span class="line"></span><br><span class="line">Direct leak of 4096 byte(s) <span class="keyword">in</span> 1 object(s) allocated from:</span><br><span class="line">    <span class="comment">#0 0x7f1d42b296b2 in operator new[](unsigned long) (/usr/lib/x86_64-linux-gnu/libasan.so.2+0x996b2)</span></span><br><span class="line">    <span class="comment">#1 0x400b27 in func() /mnt/d/data/cpp/testleak/test.cpp:5</span></span><br><span class="line">    <span class="comment">#2 0x400b3f in main /mnt/d/data/cpp/testleak/test.cpp:11</span></span><br><span class="line">    <span class="comment">#3 0x7f1d4235083f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x2083f)</span></span><br><span class="line"></span><br><span class="line">SUMMARY: AddressSanitizer: 4096 byte(s) leaked <span class="keyword">in</span> 1 allocation(s).</span><br><span class="line">albert@home-pc:/mnt/d/data/cpp/testleak$</span><br></pre></td></tr></table></figure><h2 id="泄漏发生在编译所需动态库中"><a href="#泄漏发生在编译所需动态库中" class="headerlink" title="泄漏发生在编译所需动态库中"></a>泄漏发生在编译所需动态库中</h2><p>如果内存泄漏发生在编译时使用的动态库中，那么这和上一种情况基本一致，可以直接编译后运行就能发现，测试代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// myadd.h</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// myadd.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"myadd.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>* p = <span class="keyword">new</span> <span class="keyword">int</span>(); <span class="comment">// 内存泄漏的位置</span></span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"myadd.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"519 + 1 = "</span> &lt;&lt; add(<span class="number">519</span>, <span class="number">1</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加编译选项 <code>-fsanitize=leak</code> 编译后运行，也可以直接显示出内存泄漏的位置，内存泄漏在 <code>libmyadd.so</code> 动态库中的 <code>add</code> 函数中。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:/mnt/d/data/cpp/testleak$ g++ -shared -fPIC -o libmyadd.so myadd.cpp</span><br><span class="line">albert@home-pc:/mnt/d/data/cpp/testleak$ g++ test3.cpp -L. -lmyadd -o <span class="built_in">test</span> -Wl,-rpath=. -fsanitize=leak</span><br><span class="line">albert@home-pc:/mnt/d/data/cpp/testleak$ ./<span class="built_in">test</span></span><br><span class="line">519 + 1 = 520</span><br><span class="line"></span><br><span class="line">=================================================================</span><br><span class="line">==493==ERROR: LeakSanitizer: detected memory leaks</span><br><span class="line"></span><br><span class="line">Direct leak of 4 byte(s) <span class="keyword">in</span> 1 object(s) allocated from:</span><br><span class="line">    <span class="comment">#0 0x7ff1aff6d815 in operator new(unsigned long) (/usr/lib/x86_64-linux-gnu/liblsan.so.0+0xd815)</span></span><br><span class="line">    <span class="comment">#1 0x7ff1afd506b7 in add(int, int) (libmyadd.so+0x6b7)</span></span><br><span class="line">    <span class="comment">#2 0x4009cd in main (/mnt/d/data/cpp/testleak/test+0x4009cd)</span></span><br><span class="line">    <span class="comment">#3 0x7ff1af61083f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x2083f)</span></span><br><span class="line"></span><br><span class="line">SUMMARY: LeakSanitizer: 4 byte(s) leaked <span class="keyword">in</span> 1 allocation(s).</span><br><span class="line">albert@home-pc:/mnt/d/data/cpp/testleak$</span><br></pre></td></tr></table></figure><h2 id="泄漏发生在自定义加载的动态库中"><a href="#泄漏发生在自定义加载的动态库中" class="headerlink" title="泄漏发生在自定义加载的动态库中"></a>泄漏发生在自定义加载的动态库中</h2><p>这种情况要想精确定位问题就麻烦一些了，下面是用来测试的代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// myadd.h</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> <span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// myadd.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"myadd.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> <span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>* p = <span class="keyword">new</span> <span class="keyword">int</span>(); <span class="comment">// 内存泄漏的位置</span></span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"myadd.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dlfcn.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*FUNC)</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">void</span>* handle = dlopen(<span class="string">"./libmyadd.so"</span>, RTLD_LAZY);</span><br><span class="line">    FUNC myadd = (FUNC)dlsym(handle,<span class="string">"add"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> nVal = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; nVal;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"519 + 1 = "</span> &lt;&lt; myadd(<span class="number">519</span>, <span class="number">1</span>) &lt;&lt; <span class="string">", input:"</span> &lt;&lt; nVal &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    dlclose(handle);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加编译选项 <code>-fsanitize=leak</code> 编译后运行，输入数字618，程序运行结束，显示内存泄漏出现在 <code>0x7fc88f0f06b7  (&lt;unknown module&gt;)</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:/mnt/d/data/cpp/testleak$ g++ -shared -fPIC -o libmyadd.so myadd.cpp -g</span><br><span class="line">albert@home-pc:/mnt/d/data/cpp/testleak$ g++ test.cpp -ldl -o <span class="built_in">test</span> -Wl,-rpath=. -g -fsanitize=leak</span><br><span class="line">albert@home-pc:/mnt/d/data/cpp/testleak$ ./<span class="built_in">test</span></span><br><span class="line">618</span><br><span class="line">519 + 1 = 520, input:618</span><br><span class="line"></span><br><span class="line">=================================================================</span><br><span class="line">==817==ERROR: LeakSanitizer: detected memory leaks</span><br><span class="line"></span><br><span class="line">Direct leak of 4 byte(s) <span class="keyword">in</span> 1 object(s) allocated from:</span><br><span class="line">    <span class="comment">#0 0x7fc89076d815 in operator new(unsigned long) (/usr/lib/x86_64-linux-gnu/liblsan.so.0+0xd815)</span></span><br><span class="line">    <span class="comment">#1 0x7fc88f0f06b7  (&lt;unknown module&gt;)</span></span><br><span class="line">    <span class="comment">#2 0x400bc2 in main (/mnt/d/data/cpp/testleak/test+0x400bc2)</span></span><br><span class="line">    <span class="comment">#3 0x7fc88fe1083f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x2083f)</span></span><br><span class="line"></span><br><span class="line">SUMMARY: LeakSanitizer: 4 byte(s) leaked <span class="keyword">in</span> 1 allocation(s).</span><br><span class="line">albert@home-pc:/mnt/d/data/cpp/testleak$</span><br></pre></td></tr></table></figure><h3 id="unknown-module"><a href="#unknown-module" class="headerlink" title="unknown module"></a>unknown module</h3><p>当使用 <code>dlopen</code> 的方式加载的动态库时，产生的内存泄漏常显示为 <code>(&lt;unknown module&gt;)</code>，那是因为内存检测工具在程序退出时分析泄漏情况，而这时自定义加载的动态库往往已经手动调用 <code>dlclose</code> 关闭了，这时就会显示成 <code>0x7fc88f0f06b7  (&lt;unknown module&gt;)</code> 的显示。</p><h3 id="maps"><a href="#maps" class="headerlink" title="maps"></a>maps</h3><p>针对于出现 <code>(&lt;unknown module&gt;)</code> 的这种情况，可以通过查询 /proc/pid/maps 来辅助查询，maps 文件显示进程映射后的内存区域和访问权限，是程序正在运行时的信息，数据格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">7f8c7adb6000-7f8c7adba000 rw-p 00000000 00:00 0</span><br><span class="line">7f8c7adc0000-7f8c7af32000 r-xp 00000000 00:00 189413             /usr/lib/x86_64-linux-gnu/libstdc++.so.6.0.21</span><br><span class="line">7f8c7af32000-7f8c7af3f000 ---p 00172000 00:00 189413             /usr/lib/x86_64-linux-gnu/libstdc++.so.6.0.21</span><br><span class="line">7f8c7af3f000-7f8c7b132000 ---p 0017f000 00:00 189413             /usr/lib/x86_64-linux-gnu/libstdc++.so.6.0.21</span><br><span class="line">7f8c7b132000-7f8c7b13c000 r--p 00172000 00:00 189413             /usr/lib/x86_64-linux-gnu/libstdc++.so.6.0.21</span><br><span class="line">7f8c7b13c000-7f8c7b13e000 rw-p 0017c000 00:00 189413             /usr/lib/x86_64-linux-gnu/libstdc++.so.6.0.21</span><br><span class="line">7f8c7b13e000-7f8c7b142000 rw-p 00000000 00:00 0</span><br><span class="line">7f8c7b150000-7f8c7b153000 r-xp 00000000 00:00 243909             /lib/x86_64-linux-gnu/libdl-2.23.so</span><br><span class="line">7f8c7b153000-7f8c7b154000 ---p 00003000 00:00 243909             /lib/x86_64-linux-gnu/libdl-2.23.so</span><br><span class="line">7f8c7b154000-7f8c7b352000 ---p 00004000 00:00 243909             /lib/x86_64-linux-gnu/libdl-2.23.so</span><br><span class="line">7f8c7b352000-7f8c7b353000 r--p 00002000 00:00 243909             /lib/x86_64-linux-gnu/libdl-2.23.so</span><br><span class="line">7f8c7b353000-7f8c7b354000 rw-p 00003000 00:00 243909             /lib/x86_64-linux-gnu/libdl-2.23.so</span><br><span class="line">7f8c7b360000-7f8c7b39f000 r-xp 00000000 00:00 247365             /usr/lib/x86_64-linux-gnu/liblsan.so.0.0.0</span><br><span class="line">7f8c7b39f000-7f8c7b3a2000 ---p 0003f000 00:00 247365             /usr/lib/x86_64-linux-gnu/liblsan.so.0.0.0</span><br><span class="line">7f8c7b3a2000-7f8c7b59e000 ---p 00042000 00:00 247365             /usr/lib/x86_64-linux-gnu/liblsan.so.0.0.0</span><br><span class="line">7f8c7b59e000-7f8c7b5a0000 r--p 0003e000 00:00 247365             /usr/lib/x86_64-linux-gnu/liblsan.so.0.0.0</span><br><span class="line">7f8c7b5a0000-7f8c7b5a1000 rw-p 00040000 00:00 247365             /usr/lib/x86_64-linux-gnu/liblsan.so.0.0.0</span><br><span class="line">7f8c7b5a1000-7f8c7c1f4000 rw-p 00000000 00:00 0</span><br><span class="line">7f8c7c200000-7f8c7c225000 r-xp 00000000 00:00 243945             /lib/x86_64-linux-gnu/ld-2.23.so</span><br><span class="line">7f8c7c225000-7f8c7c226000 r-xp 00025000 00:00 243945             /lib/x86_64-linux-gnu/ld-2.23.so</span><br></pre></td></tr></table></figure><ul><li>第一列：7f8c7b360000-7f8c7b39f000，表示本段内存映射的虚拟地址空间范围。</li><li>第二列：r-xp，表示此段虚拟地址空间的属性。<code>r</code>表示可读，<code>w</code>表示可写，<code>x</code>表示可执行，<code>p</code>和<code>s</code>共用一个字段，互斥关系，<code>p</code>表示私有段，<code>s</code>表示共享段，<code>-</code>表示没有权限。</li><li>第三列：00000000，表示映射偏移。对有名映射，表示此段虚拟内存起始地址在文件中以页为单位的偏移。对匿名映射，它等于0或者vm_start/PAGE_SIZE。</li><li>第四列：00:00，表示映射文件所属设备号。对有名映射来说，是映射的文件所在设备的设备号，对匿名映射来说，因为没有文件在磁盘上，所以没有设备号，始终为00:00。</li><li>第五列：247365，表示映射文件所属节点号。对有名映射来说，是映射的文件的节点号。对匿名映射来说，因为没有文件在磁盘上，所以没有节点号，始终为0。<br>第六列：/usr/lib/x86_64-linux-gnu/liblsan.so.0.0.0，表示映射文件名或堆、栈。对匿名映射来说，是此段虚拟内存在进程中的角色。[stack]表示在进程中作为栈使用，[heap]表示堆。对有名来说，是映射的文件名。其余情况则无显示。</li></ul><blockquote><p>7f8c7b360000-7f8c7b39f000 r-xp 00000000 00:00 247365             /usr/lib/x86_64-linux-gnu/liblsan.so.0.0.0</p></blockquote><p>这一行就展示了 <code>liblsan.so</code> 这个动态库映射的内存中位置和权限情况，<code>liblsan.so</code> 也就是 ASAN 工具用来检测内存泄漏的工具所依赖的动态库。</p><h3 id="具体操作"><a href="#具体操作" class="headerlink" title="具体操作"></a>具体操作</h3><ol><li>启动一个终端，然后运行 test 程序，因为程序中要求从控制台读取一个变量，所以运行后程序会一直停留在控制台等待输入</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:/mnt/d/data/cpp/testleak$ ./<span class="built_in">test</span></span><br></pre></td></tr></table></figure><ol><li>重新打开一个终端，查询 test 程序的进程id，然后拷贝对应的 maps 文件</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:/mnt/d/data/cpp/testleak$ ps -ef | grep <span class="built_in">test</span></span><br><span class="line">albert     986   889  0 21:42 pts/0    00:00:00 ./<span class="built_in">test</span></span><br><span class="line">albert     988   953  0 21:42 pts/1    00:00:00 grep --color=auto <span class="built_in">test</span></span><br><span class="line">albert@home-pc:/mnt/d/data/cpp/testleak$ cp /proc/986/maps testmaps</span><br></pre></td></tr></table></figure><ol><li>在第一个终端中输入数字，程序运行结束，显示出内存泄漏信息</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:/mnt/d/data/cpp/testleak$ ./<span class="built_in">test</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 以下为新的信息，输入了515</span></span><br><span class="line"></span><br><span class="line">515</span><br><span class="line">519 + 1 = 520, input:515</span><br><span class="line"></span><br><span class="line">=================================================================</span><br><span class="line">==986==ERROR: LeakSanitizer: detected memory leaks</span><br><span class="line"></span><br><span class="line">Direct leak of 4 byte(s) <span class="keyword">in</span> 1 object(s) allocated from:</span><br><span class="line">    <span class="comment">#0 0x7f8c7b36d815 in operator new(unsigned long) (/usr/lib/x86_64-linux-gnu/liblsan.so.0+0xd815)</span></span><br><span class="line">    <span class="comment">#1 0x7f8c79cf06b7  (&lt;unknown module&gt;)</span></span><br><span class="line">    <span class="comment">#2 0x400bc2 in main (/mnt/d/data/cpp/testleak/test+0x400bc2)</span></span><br><span class="line">    <span class="comment">#3 0x7f8c7aa1083f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x2083f)</span></span><br><span class="line"></span><br><span class="line">SUMMARY: LeakSanitizer: 4 byte(s) leaked <span class="keyword">in</span> 1 allocation(s).</span><br><span class="line">albert@home-pc:/mnt/d/data/cpp/testleak$</span><br></pre></td></tr></table></figure><ol><li>从检测报告中看到 <code>0x7f8c79cf06b7  (&lt;unknown module&gt;)</code>，在备份的 testmaps 文件中查找范围，发现处于下面一段之中</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">640000000000-640000003000 rw-p 00000000 00:00 0</span><br><span class="line">7f8c79cf0000-7f8c79cf1000 r-xp 00000000 00:00 282                /mnt/d/data/cpp/testleak/libmyadd.so</span><br><span class="line">7f8c79cf1000-7f8c79cf2000 ---p 00001000 00:00 282                /mnt/d/data/cpp/testleak/libmyadd.so</span><br><span class="line">7f8c79cf2000-7f8c79ef0000 ---p 00002000 00:00 282                /mnt/d/data/cpp/testleak/libmyadd.so</span><br><span class="line">7f8c79ef0000-7f8c79ef1000 r--p 00000000 00:00 282                /mnt/d/data/cpp/testleak/libmyadd.so</span><br><span class="line">7f8c79ef1000-7f8c79ef2000 rw-p 00001000 00:00 282                /mnt/d/data/cpp/testleak/libmyadd.so</span><br><span class="line">7f8c79f00000-7f8c7a000000 rw-p 00000000 00:00 0</span><br></pre></td></tr></table></figure><ol><li>至此发现问题出现在 <code>libmyadd.so</code> 这个动态库中，再用 <code>0x7f8c79cf06b7</code> 减去动态链接库基地址 <code>7f8c79cf0000</code>，得到偏移量为 <code>0x6b7</code>，此时使用 addr2line 工具进行转化。</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:/mnt/d/data/cpp/testleak$ addr2line  -C -f -e /mnt/d/data/cpp/testleak/libmyadd.so 0x6b7</span><br><span class="line">add</span><br><span class="line">/mnt/d/data/cpp/testleak/myadd.cpp:4</span><br></pre></td></tr></table></figure><ol><li>至此就找到了内存泄漏的确切位置，在/mnt/d/data/cpp/testleak/myadd.cpp文件第4行的 <code>add</code> 函数之中。</li></ol><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>在 C++11 之后尽可能使用智能指针来管理在堆上申请的内存，<code>shared_ptr</code>、<code>weak_ptr</code>、<code>unique_ptr</code> 能帮我们减少许多麻烦</li><li>想要检测程序内存用用问题， AddressSanitizer 是一个不错的选择，其中有关内存泄漏的检测已经被整合到 LeakSanitizer 工具中</li><li>当程序中的内存泄漏发生在 <code>dlopen</code> 加载的动态库中时，常常出现 <code>(&lt;unknown module&gt;)</code> 的情况，这时需要借助 <code>proc/pid/maps</code> 文件和 addr2line 工具来完成精确定位。</li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/116312788" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>祝融落地。一百年了，还没有什么事情是做不到的，我们需要的是时间，我等着看你们在真正的力量面前瑟瑟发抖~</p><p>2021-5-16 00:08:24</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;指针是C/C++程序中的利器，同时也引入了风险，现代C++中增加了智能指针来降低使用“裸”指针带来的风险，但是智能指针不是一颗银弹，它不能解决所有的指针问题，内存泄漏在C/C++程序开发中依旧是值得注意的，学会合理、合适的方法来查找内存泄漏问题也是一项有用的技能。&lt;/p&gt;
&lt;p&gt;通常内存泄漏问题会在开发到一定程度时集中检查，一些检测方法长时间不去使用难免会忘记，所以本文记录一种自己常用的检测方法，方便日后查阅。&lt;/p&gt;
    
    </summary>
    
      <category term="C/C++" scheme="http://AlbertGithubHome.github.io/blog/categories/C-C/"/>
    
    
      <category term="C/C++" scheme="http://AlbertGithubHome.github.io/blog/tags/C-C/"/>
    
      <category term="linux" scheme="http://AlbertGithubHome.github.io/blog/tags/linux/"/>
    
      <category term="AddressSanitizer" scheme="http://AlbertGithubHome.github.io/blog/tags/AddressSanitizer/"/>
    
      <category term="addr2line" scheme="http://AlbertGithubHome.github.io/blog/tags/addr2line/"/>
    
      <category term="内存泄漏" scheme="http://AlbertGithubHome.github.io/blog/tags/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>linux文件权限简单备忘知识点</title>
    <link href="http://AlbertGithubHome.github.io/blog/2021/04/30/linux%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E7%AE%80%E5%8D%95%E5%A4%87%E5%BF%98%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>http://AlbertGithubHome.github.io/blog/2021/04/30/linux文件权限简单备忘知识点/</id>
    <published>2021-04-29T16:25:12.000Z</published>
    <updated>2021-05-05T14:17:24.015Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>已经拖更好几天了，有些坚持的事情一旦中断便很难再捡起来了，所以还是尽可能的坚持下去，今天就简单记录一下文件权限相关的操作。</p><a id="more"></a><p><img src="https://img-blog.csdnimg.cn/2021050101315534.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NoaWhlbmd6aGVuMTAx,size_16,color_FFFFFF,t_70" alt="file_ls"></p><p>这里先扔出一张图，这么懒的我居然画了一张图！不过前几天感冒状态不太好，这张图画了好几晚上才完成，就凑活看吧。</p><p>基本上看注释就能明白各列的含义，关于“文件硬链接数”这一列还有点疑问，在CentOS上测试，确实如注释所言，普通文件显示的硬链接数，目录文件显示的是第一级子目录的个数，但是在WSL上却不符合这个说法，暂时还没有找到原因，接下来还是列举下文件权限相关的操作吧。</p><h1 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h1><p>在linux系统中的每个用户必须属于一个组，不能独立于组外。而每个文件的权限区分所有者、所在组、其它人，就像图片中展示的那样</p><ul><li>所有者：指创建文件的人，拥有第一组权限</li><li>所在组：指的是和所有者在同组的人，拥有第二组权限</li><li>其他人：指排除掉前两类的其他人，拥有第三组权限</li></ul><p>每组权限都分为读、写、执行三种具体权限，对应数字分别是4、2、1，字母表示为r、w、x，没有权限可以用<code>-</code>表示，也就是0，因为有这些表示方法，修改文件的命令形式也有很多种。</p><p>一个文件的访问权限是可以进行修改的，用户可以使用 <code>chmod</code> 命令来重新设定不同的访问权限，可以使用 <code>chown</code> 命令来更改某个文件或目录的所有者，也可以利用 <code>chgrp</code> 命令来更改某个文件或目录的用户组。</p><h1 id="chmod-命令"><a href="#chmod-命令" class="headerlink" title="chmod 命令"></a>chmod 命令</h1><p>上面说到文件的权限分为所有者、同组人、其他人三组，每组权限又有r、w、x三种权限，分别用数字4、2、1表示，举几个对照的例子如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rwx r-x r–x  755</span><br><span class="line">rw- r–- –--  640</span><br><span class="line">rw- rw- r–-  664</span><br></pre></td></tr></table></figure><p>因为表示的多样性，该命令有通常有字母表达式和数字表达式两种用法，格式如下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod ［who］ ［+ | – | =］ ［mode］ filename</span><br></pre></td></tr></table></figure><p>命令中各选项的含义为：</p><p>命令中的 <code>who</code> 可是下述字母中的任一个或者它们的组合：</p><ul><li><code>u</code> 表示所有者user</li><li><code>g</code> 表示同组用户group</li><li><code>o</code> 表示其他人other</li><li><code>a</code> 表示所有用户all，是系统默认值</li></ul><p>权限改变的符号可以是：</p><ul><li><code>+</code> 添加某个权限</li><li><code>–</code> 取消某个权限</li><li><code>=</code> 赋予给定权限并取消其他所有权限（如果有的话）</li></ul><p>命令中的 <code>mode</code> 所表示的权限可用下述字母的任意组合：</p><ul><li><code>r</code> 可读权限</li><li><code>w</code> 可写权限</li><li><code>x</code> 可执行权限</li><li><code>X</code> 只有目标文件对某些用户是可执行的或该目标文件是目录时才追加 x 属性</li><li><code>u</code> 与文件属主拥有一样的权限</li><li><code>g</code> 与和文件属主同组的用户拥有一样的权限</li><li><code>o</code> 与其他用户拥有一样的权限</li></ul><p>常见写法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ chmod a+x happy.txt</span><br><span class="line">$ chmod ug+w file.xml</span><br><span class="line">$ chmod 755 a.out</span><br></pre></td></tr></table></figure><h1 id="chgrp-命令"><a href="#chgrp-命令" class="headerlink" title="chgrp 命令"></a>chgrp 命令</h1><p>该命令能改变文件或目录所属的组，语法如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chgrp ［option］ group filename</span><br></pre></td></tr></table></figure><p>option参数可选：</p><pre><code>-f,–quiet,–silent:  不显示错误信息-R,–recursive:      递归处理，将指定目录下的所有文件及子目录一并处理-v,–verbose:        显示指令执行过程</code></pre><p>命令中group可以是用户组ID，也可以是/etc/group文件中用户组的组名。文件名是以空格分开的要改变属组的文件列表，支持通配符。如果用户不是该文件的属主或超级用户，则不能改变该文件的组的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$chgrp</span> -R mysql /opt/<span class="built_in">local</span>/my.ini</span><br></pre></td></tr></table></figure><h1 id="chown-命令"><a href="#chown-命令" class="headerlink" title="chown 命令"></a>chown 命令</h1><p>该命令可以更改某个文件或目录的属主，也就是所有者。语法如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chown ［option］ groupname|username filename</span><br></pre></td></tr></table></figure><p>chown可以将指定文件的拥有者改为指定的用户或组。用户可以是用户名或用户ID。组可以是组名或组ID。与 chgrp命令一样，参数文件也是以空格分开的要改变权限的文件列表，支持通配符。</p><p>option参数可选：</p><pre><code>-f: 若该文件拥有者无法被更改也不要显示错误讯息-h: 只对于连结(link)进行变更，而非该 link 真正指向的文件-v: 显示拥有者变更的详细资料-R: 对目前目录下的所有档案与子目录进行相同的拥有者变更(即以递回的方式逐个变更)</code></pre><p>修改文件所有者的例子如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ chown redis /ect/redis/redis.config</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li><code>ls -l</code> 命令执行后的第5列，表示文件的硬连接数</li><li><code>chmod a+x happy.txt</code> 可以修改文件的权限信息</li><li><code>chgrp a+x fruit.txt</code> 可以修改文件的所有组信息</li><li><code>chown redis /ect/redis/redis.config</code> 可以修改文件的所有者信息</li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/115842171" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>鲁迅先生说“我向来是不惮以最坏的恶意，来推测中国人的，然而我还不料，也不信竟会下劣凶残到这地步。”<br>其实黑暗中往往也透露着光明~</p><p>2021-5-1 01:26:36</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;已经拖更好几天了，有些坚持的事情一旦中断便很难再捡起来了，所以还是尽可能的坚持下去，今天就简单记录一下文件权限相关的操作。&lt;/p&gt;
    
    </summary>
    
      <category term="linux" scheme="http://AlbertGithubHome.github.io/blog/categories/linux/"/>
    
    
      <category term="linux" scheme="http://AlbertGithubHome.github.io/blog/tags/linux/"/>
    
      <category term="chmod" scheme="http://AlbertGithubHome.github.io/blog/tags/chmod/"/>
    
      <category term="文件" scheme="http://AlbertGithubHome.github.io/blog/tags/%E6%96%87%E4%BB%B6/"/>
    
      <category term="权限" scheme="http://AlbertGithubHome.github.io/blog/tags/%E6%9D%83%E9%99%90/"/>
    
  </entry>
  
  <entry>
    <title>protobuf中SerializeToString和SerializePartialToString的区别</title>
    <link href="http://AlbertGithubHome.github.io/blog/2021/04/18/protobuf%E4%B8%ADSerializeToString%E5%92%8CSerializePartialToString%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://AlbertGithubHome.github.io/blog/2021/04/18/protobuf中SerializeToString和SerializePartialToString的区别/</id>
    <published>2021-04-18T13:26:09.000Z</published>
    <updated>2021-04-18T15:00:50.810Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>protobuf是Google提出的序列化方案，此方案独立于语言和平台，目前提供了如c++、go、python等多种语言的实现，使用比较广泛，具有性能开销小，压缩率高等优点，是值得学习的优秀开源库。</p><a id="more"></a><p>protobuf有 v2 和 v3 两个主要的并且差异很大的版本，有一些关于protobuf的文章中并没有说明版本，有些描述的内容给人造成了疑惑，所以在使用protobuf前要明确自己使用的版本，查找对应的特性。</p><h1 id="proto2"><a href="#proto2" class="headerlink" title="proto2"></a>proto2</h1><p>这个版本在编写 <code>.proto</code> 文件时的字段有三种限定符，分别是<code>required</code>、<code>optional</code> 和 <code>repeated</code>。</p><ul><li>required：必须设置该字段，如果是在debug模式下编译 libprotobuf，则序列化一个未初始化（未对required字段赋值）的 message 将导致断言失败。在release模式的构建中，将跳过检查并始终写入消息，但解析未初始化的消息将返回false表示失败。</li><li>optional：可以设置也可以不设置该字段。如果未设置可选字段值，则使用默认值，也可以用[default = value]进行设置。</li><li>repeated：该字段可以重复任意次数（包括零次），可以将 repeated 字段视为动态大小的数组。</li></ul><h2 id="message定义"><a href="#message定义" class="headerlink" title="message定义"></a>message定义</h2><p>定义一个简单的 message 结构如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">message Person &#123;</span><br><span class="line">  required string name = 1;</span><br><span class="line">  optional string email = 2;</span><br><span class="line">  optional int age = 3 [default = 18];</span><br><span class="line">  repeated bytes phones = 4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>观察 message 定义可以看到每个字段后面都有 <code>= 1</code>、<code>= 2</code> 的标记，这些被称为 Tags，在 protobuf 中同一个 message 中的每个字段都需要有独一无二的tag，tag 为 1-15 的是单字节编码，16-2047 使用2字节编码，所以1-15应该给频繁使用的字段。</p><p>关于tag的取值，还有一种范围是[1,536870911]的说法，同时 19000 到 19999 之间的数字也不能使用，因为它们是 protobuf 的实现中保留的，也就是 <code>FieldDescriptor::kFirstReservedNumber</code> 到 <code>FieldDescriptor::kLastReservedNumber</code> 指定的范围，如果使用其中的数字，导出 .proto 文件时会报错，此处存疑，需要验证一下。</p><h2 id="message扩展"><a href="#message扩展" class="headerlink" title="message扩展"></a>message扩展</h2><p>在使用的了 protobuf 的项目发布以后，绝对会遇到扩展原有 message 结构的需求，这一点不可避免，除非发布后的项目不再升级维护了，要想扩展就需要兼容之前的代码逻辑，这里有一些必须遵守的规则，否则就达不到兼容的目的。</p><ul><li>不能更改任何现有字段的 tag</li><li>不能添加或删除任何 required 字段</li><li>可以删除 optional 或 repeated 的字段</li><li>可以添加新的 optional 或 repeated 字段，但必须使用新的tag，曾经使用过又删除的 tag 也不能再使用了</li></ul><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>proto2 中对 required 的使用永远都应该非常小心。如果想在某个时刻停止写入或发送 required 字段，直接将字段更改为可选字段将会有问题。一些工程师得出的经验是，使用 required 弊大于利，他们更喜欢只使用 optional 和 repeated。</p><h1 id="proto3"><a href="#proto3" class="headerlink" title="proto3"></a>proto3</h1><p>proto3 比 proto2 支持更多语言但更简洁，去掉了一些复杂的语法和特性。</p><ul><li>在第一行非空白非注释行，必须写：<code>syntax = &quot;proto3&quot;;</code></li><li>直接从语法层面上移除了 required 规则，取消了 required 限定词</li><li>增加了对 Go、Ruby、JavaNano 等语言的支持</li><li>移除了 default 选项，字段的默认值只能根据字段类型由系统决定</li></ul><h1 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h1><p>将 message 结构对象序列化的函数有很多，即使是序列化成字符串也有多个函数可以使用，比如 <code>SerializeToString</code>、<code>SerializePartialToString</code>、<code>SerializeAsString</code>、<code>SerializePartialAsString</code> 等等。</p><h2 id="SerializeToString和SerializeAsString区别"><a href="#SerializeToString和SerializeAsString区别" class="headerlink" title="SerializeToString和SerializeAsString区别"></a>SerializeToString和SerializeAsString区别</h2><p>这两个还是很好区分的，从源码角度一眼就能够分辨出来：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> MessageLite::SerializeAsString() <span class="keyword">const</span> &#123;</span><br><span class="line">  <span class="comment">// If the compiler implements the (Named) Return Value Optimization,</span></span><br><span class="line">  <span class="comment">// the local variable 'output' will not actually reside on the stack</span></span><br><span class="line">  <span class="comment">// of this function, but will be overlaid with the object that the</span></span><br><span class="line">  <span class="comment">// caller supplied for the return value to be constructed in.</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> output;</span><br><span class="line">  <span class="keyword">if</span> (!AppendToString(&amp;output)) output.clear();</span><br><span class="line">  <span class="keyword">return</span> output;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> MessageLite::SerializeToString(<span class="built_in">std</span>::<span class="built_in">string</span>* output) <span class="keyword">const</span> &#123;</span><br><span class="line">  output-&gt;clear();</span><br><span class="line">  <span class="keyword">return</span> AppendToString(output);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从源代码可以很容易看出，两者仅仅是参数和返回值的类型不同，其内部调用的函数都是一样的，<code>SerializePartialToString</code> 和 <code>SerializePartialAsString</code> 两个函数也是这种区别，可以根据外部逻辑所需来调用合适的函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> MessageLite::SerializePartialToString(<span class="built_in">std</span>::<span class="built_in">string</span>* output) <span class="keyword">const</span> &#123;</span><br><span class="line">  output-&gt;clear();</span><br><span class="line">  <span class="keyword">return</span> AppendPartialToString(output);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> MessageLite::SerializePartialAsString() <span class="keyword">const</span> &#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> output;</span><br><span class="line">  <span class="keyword">if</span> (!AppendPartialToString(&amp;output)) output.clear();</span><br><span class="line">  <span class="keyword">return</span> output;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="SerializeToString和SerializePartialToString区别"><a href="#SerializeToString和SerializePartialToString区别" class="headerlink" title="SerializeToString和SerializePartialToString区别"></a>SerializeToString和SerializePartialToString区别</h2><p>这两个函数的区别在于内部调用的函数不同，一个调用 <code>AppendToString</code>，另一个调用 <code>AppendPartialToString</code>，两个被调用函数的源代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> MessageLite::AppendToString(<span class="built_in">std</span>::<span class="built_in">string</span>* output) <span class="keyword">const</span> &#123;</span><br><span class="line">  GOOGLE_DCHECK(IsInitialized()) &lt;&lt; InitializationErrorMessage(<span class="string">"serialize"</span>, *<span class="keyword">this</span>);</span><br><span class="line">  <span class="keyword">return</span> AppendPartialToString(output);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> MessageLite::AppendPartialToString(<span class="built_in">std</span>::<span class="built_in">string</span>* output) <span class="keyword">const</span> &#123;</span><br><span class="line">  <span class="keyword">size_t</span> old_size = output-&gt;size();</span><br><span class="line">  <span class="keyword">size_t</span> byte_size = ByteSizeLong();</span><br><span class="line">  <span class="keyword">if</span> (byte_size &gt; INT_MAX) &#123;</span><br><span class="line">    GOOGLE_LOG(ERROR) &lt;&lt; GetTypeName()</span><br><span class="line">               &lt;&lt; <span class="string">" exceeded maximum protobuf size of 2GB: "</span> &lt;&lt; byte_size;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原来 <code>AppendToString</code> 函数调用了 <code>AppendPartialToString</code>, 只是在调用之前先执行了一句 <code>GOOGLE_DCHECK(IsInitialized()) &lt;&lt; InitializationErrorMessage(&quot;serialize&quot;, *this);</code> 这句话什么意思呢？</p><p>其实就是一个调试状态下的检查，类似于 assert 这个断言函数吧，检查的内容是判断这个 message 是否初始化，之前提到 <code>required</code> 修饰的字段必须要设置一个值，否者就是未初始化的状态，那么现在两个函数的区别就知道了，带有 “Partial” 函数其实是忽略 <code>required</code> 字段检查的，另外还有没有别的不同需要再进一步研究下源码了。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>protobuf有 v2 和 v3 两个主要的并且差异较大的版本，使用前请注意版本号</li><li>proto3 直接从语法层面上移除了 required 规则，移除了 default 选项，字段的默认值只能根据字段类型由系统决定</li><li>SerializeToString和SerializeAsString区别在于参数和返回值的不同，内部调用的函数是相同的</li><li>SerializeToString和SerializePartialToString区别在于SerializePartialToString会忽略 required 字段必须赋值的要求</li><li>在应用过程中尽可能重用 message 结构，这样protobuf内部实现中内存的重用</li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/115609690" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>没有什么捷径，继续努力就好了<br>短期内不会看到什么成果，甚至说一辈子都可能看不到，但只有努力了才有可能看得到</p><p>2021-4-18 21:31:34</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;protobuf是Google提出的序列化方案，此方案独立于语言和平台，目前提供了如c++、go、python等多种语言的实现，使用比较广泛，具有性能开销小，压缩率高等优点，是值得学习的优秀开源库。&lt;/p&gt;
    
    </summary>
    
      <category term="protobuf" scheme="http://AlbertGithubHome.github.io/blog/categories/protobuf/"/>
    
    
      <category term="C++" scheme="http://AlbertGithubHome.github.io/blog/tags/C/"/>
    
      <category term="protobuf" scheme="http://AlbertGithubHome.github.io/blog/tags/protobuf/"/>
    
      <category term="序列化" scheme="http://AlbertGithubHome.github.io/blog/tags/%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    
      <category term="required" scheme="http://AlbertGithubHome.github.io/blog/tags/required/"/>
    
      <category term="message" scheme="http://AlbertGithubHome.github.io/blog/tags/message/"/>
    
  </entry>
  
  <entry>
    <title>C++中一些可以在偷懒时直接使用的函数</title>
    <link href="http://AlbertGithubHome.github.io/blog/2021/04/11/C-%E4%B8%AD%E4%B8%80%E4%BA%9B%E5%8F%AF%E4%BB%A5%E5%9C%A8%E5%81%B7%E6%87%92%E6%97%B6%E7%9B%B4%E6%8E%A5%E4%BD%BF%E7%94%A8%E7%9A%84%E5%87%BD%E6%95%B0/"/>
    <id>http://AlbertGithubHome.github.io/blog/2021/04/11/C-中一些可以在偷懒时直接使用的函数/</id>
    <published>2021-04-11T10:07:17.000Z</published>
    <updated>2021-04-11T15:44:08.954Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在解决一些算法题时，会遇到一些“嵌套”问题，也就是一个题目中包含多个小的算法知识点，比如计算一个整数的二进制表示中1的个数，或者计算两个数的最大公约数，如果这些小问题本身就是题目，那么就只能“手撕”了。</p><a id="more"></a><p>但是如果这些内容只是解决题目中的一小部分，我们其实是可以偷个懒的，有很多函数已经被纳入函数库，可以直接拿过来使用，接下来我们可以简单看几个。</p><h1 id="求解最大公约数"><a href="#求解最大公约数" class="headerlink" title="求解最大公约数"></a>求解最大公约数</h1><h2 id="自定义实现"><a href="#自定义实现" class="headerlink" title="自定义实现"></a>自定义实现</h2><p>求最大公约数的一种常用方法叫做辗转相除法，又名欧几里德算法(Euclidean algorithm)，算法本身并不复杂，可以写成如下逻辑实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">my_gcd</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (y != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> z = x % y;</span><br><span class="line">        x = y;</span><br><span class="line">        y = z;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者简单写成递归的实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">my_gcd</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> y ? my_gcd(y, x%y) : x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为计算机处理加减法的性能要远高于计算乘除法，所以辗转相除法有很多变形实现，比如辗转相减、用移位运算代替除法计算等。</p><h2 id="库函数"><a href="#库函数" class="headerlink" title="库函数"></a>库函数</h2><p>其实在C++17中，最大公约数计算已经被加到了函数库中，头文件为 <code>&lt;numeric&gt;</code>，直接调用 <code>std::gcd()</code> 就可以了，本身是一个模板函数，定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt; <span class="class"><span class="keyword">class</span> <span class="title">M</span>, <span class="title">class</span> <span class="title">N</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">constexpr</span> <span class="title">std</span>:</span>:<span class="keyword">common_type_t</span>&lt;M, N&gt; gcd(M m, N n);</span><br></pre></td></tr></table></figure><h1 id="计算一个整数的二进制表示中有多少个1"><a href="#计算一个整数的二进制表示中有多少个1" class="headerlink" title="计算一个整数的二进制表示中有多少个1"></a>计算一个整数的二进制表示中有多少个1</h1><h2 id="自定义实现-1"><a href="#自定义实现-1" class="headerlink" title="自定义实现"></a>自定义实现</h2><p>这也是一道经典的算法题了，常见的实现如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">count1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        cnt++;</span><br><span class="line">        n &amp;= (n<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种实现方法不能说最优解法，但是也算的上是一个优秀的实现思路了。</p><h2 id="内建函数"><a href="#内建函数" class="headerlink" title="内建函数"></a>内建函数</h2><p>关于二进制的形式的各种操作，GCC提供了一系列的builtin函数，可以实现一些简单快捷的功能来方便程序编写，并且可用来优化编译结果。</p><h3 id="builtin-popcount"><a href="#builtin-popcount" class="headerlink" title="__builtin_popcount"></a>__builtin_popcount</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回n的二进制表示形式中1的个数</span></span><br><span class="line"><span class="keyword">int</span> __builtin_popcount(<span class="keyword">unsigned</span> <span class="keyword">int</span> n)</span><br></pre></td></tr></table></figure><h3 id="builtin-ffs"><a href="#builtin-ffs" class="headerlink" title="__builtin_ffs"></a>__builtin_ffs</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回n的二进制表示形式中最后一位1的是从后向前第几位</span></span><br><span class="line"><span class="keyword">int</span> __builtin_ffs(<span class="keyword">unsigned</span> <span class="keyword">int</span> n)</span><br></pre></td></tr></table></figure><h3 id="builtin-clz"><a href="#builtin-clz" class="headerlink" title="__builtin_clz"></a>__builtin_clz</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回n的二进制表示形式中前导0的个数</span></span><br><span class="line"><span class="keyword">int</span> __builtin_clz(<span class="keyword">unsigned</span> <span class="keyword">int</span> n)</span><br></pre></td></tr></table></figure><h3 id="builtin-ctz"><a href="#builtin-ctz" class="headerlink" title="__builtin_ctz"></a>__builtin_ctz</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回n的二进制表示形式中结尾0个个数</span></span><br><span class="line"><span class="keyword">int</span> __builtin_ctz(<span class="keyword">unsigned</span> <span class="keyword">int</span> n)</span><br></pre></td></tr></table></figure><h3 id="builtin-parity"><a href="#builtin-parity" class="headerlink" title="__builtin_parity"></a>__builtin_parity</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回n的奇偶校验位，即n的二进制表示形式中的1的个数模2的结果</span></span><br><span class="line"><span class="keyword">int</span> __builtin_parity(<span class="keyword">unsigned</span> <span class="keyword">int</span> n)</span><br></pre></td></tr></table></figure><p>上述列举的这些函数参数都是 <code>unsigned int</code> 类型，如果参数为 <code>usigned long</code> 或者 <code>usigned long long</code>，只需要在函数名后面加上 <code>l</code> 或 <code>ll</code> 就可以了，比如 <code>__builtin_popcountl</code>。</p><p>遗憾的是，这些builtin函数一般没有可移植性，使用时要注意。</p><h2 id="库函数-1"><a href="#库函数-1" class="headerlink" title="库函数"></a>库函数</h2><p>但值得庆幸的是，这些优秀的函数在C++20中得以转正，成为了C++的标准函数，比如 <code>std::popcount</code>，定义在头文件 <code>&lt;bit&gt;</code> 中，函数定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">constexpr</span> <span class="title">int</span> <span class="title">popcount</span>(<span class="title">T</span> <span class="title">x</span>) <span class="title">noexcept</span>;</span></span><br></pre></td></tr></table></figure><h2 id="更快速的源码"><a href="#更快速的源码" class="headerlink" title="更快速的源码"></a>更快速的源码</h2><p>计算一个整数的二进制表示中包含1的个数，除了前面提到的 <code>n &amp;= (n-1)</code> 外，还有下面这种变形的二分法实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">popcount</span> <span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    u = (u &amp; <span class="number">0x55555555</span>) + ((u &gt;&gt; <span class="number">1</span>) &amp; <span class="number">0x55555555</span>);</span><br><span class="line">    u = (u &amp; <span class="number">0x33333333</span>) + ((u &gt;&gt; <span class="number">2</span>) &amp; <span class="number">0x33333333</span>);</span><br><span class="line">    u = (u &amp; <span class="number">0x0F0F0F0F</span>) + ((u &gt;&gt; <span class="number">4</span>) &amp; <span class="number">0x0F0F0F0F</span>);</span><br><span class="line">    u = (u &amp; <span class="number">0x00FF00FF</span>) + ((u &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0x00FF00FF</span>);</span><br><span class="line">    u = (u &amp; <span class="number">0x0000FFFF</span>) + ((u &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0x0000FFFF</span>);</span><br><span class="line">    <span class="keyword">return</span> u;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>采用这种二分法的实现，基本上可以媲美单字节打表的速度了，上述二分法是利用变量u来分组统计1的个数，两两合并到一起进而得到最后结果的。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>计算两个数的最大公约数可以在C++17环境下使用 <code>std::gcd()</code> 函数</li><li>计算一个整数二进制表示中1的个数可以在C++20环境下使用 <code>std::popcount()</code> 函数</li><li><code>__builtin</code> 开头的函数是GCC提供的方便程序编写的函数，并且可用来优化编译结，但是使用时要注意不可移植性</li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/115435926" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>在繁华中自律<br>在落魄中自愈<br>谋生的路上不抛弃良知<br>谋爱的路上不抛弃尊严</p><p>2021-4-11 21:27:25</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;在解决一些算法题时，会遇到一些“嵌套”问题，也就是一个题目中包含多个小的算法知识点，比如计算一个整数的二进制表示中1的个数，或者计算两个数的最大公约数，如果这些小问题本身就是题目，那么就只能“手撕”了。&lt;/p&gt;
    
    </summary>
    
      <category term="C/C++" scheme="http://AlbertGithubHome.github.io/blog/categories/C-C/"/>
    
    
      <category term="C/C++" scheme="http://AlbertGithubHome.github.io/blog/tags/C-C/"/>
    
      <category term="语法糖" scheme="http://AlbertGithubHome.github.io/blog/tags/%E8%AF%AD%E6%B3%95%E7%B3%96/"/>
    
      <category term="函数" scheme="http://AlbertGithubHome.github.io/blog/tags/%E5%87%BD%E6%95%B0/"/>
    
      <category term="函数库" scheme="http://AlbertGithubHome.github.io/blog/tags/%E5%87%BD%E6%95%B0%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>写给自己的KMP——C++版本</title>
    <link href="http://AlbertGithubHome.github.io/blog/2021/04/04/%E5%86%99%E7%BB%99%E8%87%AA%E5%B7%B1%E7%9A%84KMP%E2%80%94%E2%80%94C-%E7%89%88%E6%9C%AC/"/>
    <id>http://AlbertGithubHome.github.io/blog/2021/04/04/写给自己的KMP——C-版本/</id>
    <published>2021-04-04T15:03:12.000Z</published>
    <updated>2021-04-05T08:21:26.046Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h1><p>又翻到了这个算法，一个常用的子串（子数组）匹配算法，看一遍学一遍，学一遍忘一遍，反反复复，不过每次回忆起来所用的时间越来少了，其本质上就是在暴力搜索的基础上加上 next 数组加速匹配，算法的关键在于 next 数组的理解和求解方法。</p><a id="more"></a><p>不想画图，缺少图解的算法很难给初学者讲清楚，所以本文也仅仅是个人的笔记而已，用于记录算法中关键点、帮助回忆或者理解其中的一些关键因素，如果想从头学习 <code>KMP</code>，还是去搜索其他资料吧，相关的内容有很多，有些文章写的很详细的。</p><p>今天的示例代码用C++来写，上一版的自己写的KMP我查了一下是C语言版本的，初看起来已经有点费劲了，随着时间的推移，我决定根据理解再写一次，写完才发现，和之前的风格判若两人。</p><h1 id="二、暴力搜索"><a href="#二、暴力搜索" class="headerlink" title="二、暴力搜索"></a>二、暴力搜索</h1><p>在原字符串中搜索模式串，最容易想到的就是暴力搜索，匹配则向后移动，不匹配则原串回溯，模式串归0，代码很容易实现，列举如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">violence_find</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = s.size(), n = p.size(), i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt; m &amp;&amp; j &lt; n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == p[j]) &#123; <span class="comment">// match character</span></span><br><span class="line">            ++i;</span><br><span class="line">            ++j;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// mismatch</span></span><br><span class="line">            i -= j - <span class="number">1</span>;</span><br><span class="line">            j = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> j == n ? i - j : <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(<span class="string">"abdfdjfdkekfdaa5gsdsf"</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">p</span><span class="params">(<span class="string">"fdkekfd"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; violence_find(s, p) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>典型的 <code>O(MN)</code> 解法，这种解法慢就慢在原字符串的回溯上，也就是语句 <code>i -= j - 1;</code> 的效果，当出现失配时，原字符串之前的匹配几乎“白费”，每次最多移动一个字符，而 KMP 算法决定利用之前的“努力成果”。</p><h1 id="三、KMP算法"><a href="#三、KMP算法" class="headerlink" title="三、KMP算法"></a>三、KMP算法</h1><p>在 KMP 算法中先利用模式串构建一个 next 数组，当出现失配情况时根据模式串前缀和后缀情况，最大程序利用已经匹配的部分来达到加速查找的目的，只需要求一个 next 数组，其他部分和暴力匹配的代码很像：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kmp_tmp</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = s.size(), n = p.size(), i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; next = <span class="built_in">std</span>::move(gen_next(p));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt; m &amp;&amp; j &lt; n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == p[j]) &#123;</span><br><span class="line">            ++i;</span><br><span class="line">            ++j;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// mismatch</span></span><br><span class="line">            j = next[j];</span><br><span class="line">            <span class="keyword">if</span> (j == <span class="number">-1</span>) &#123;</span><br><span class="line">                ++i;</span><br><span class="line">                j = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> j == n ? i - j : <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和暴力搜索的代码对照下，只有 <code>else</code> 中语句块不太一样，这个 <code>i</code> 只前进不后退了，其实这个里的 <code>j == -1</code> 语句可以合并到判定相等的 <code>if</code> 语句块中，完成 KMP 代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; gen_next(<span class="built_in">string</span> p) &#123;</span><br><span class="line">    <span class="keyword">int</span> n = p.size(), i = <span class="number">0</span>, j = <span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; next(n, <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt; n - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">-1</span> || p[i] == p[j]) &#123;</span><br><span class="line">            ++i;</span><br><span class="line">            ++j;</span><br><span class="line">            next[i] = j;</span><br><span class="line">        &#125; <span class="keyword">else</span> j = next[j]; <span class="comment">// mismatch, move j</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kmp</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = s.size(), n = p.size(), i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; next = <span class="built_in">std</span>::move(gen_next(p));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt; m &amp;&amp; j &lt; n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">-1</span> || s[i] == p[j]) &#123;</span><br><span class="line">            ++i;</span><br><span class="line">            ++j;</span><br><span class="line">        &#125; <span class="keyword">else</span> j = next[j]; <span class="comment">// mismatch, move j</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> j == n ? i - j : <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(<span class="string">"abdfdjfdkekfdaa5gsdsf"</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">p</span><span class="params">(<span class="string">"fdkekfd"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; kmp(s, p) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="四、关键点记录"><a href="#四、关键点记录" class="headerlink" title="四、关键点记录"></a>四、关键点记录</h1><ol><li><p>next[i] 中记录的实际上是 <code>p[0,i-1]</code> 这个字符串中所有前缀和所有后缀交集中最长字符串的长度，比如<code>&#39;fdkekfd&#39;</code> 这个字符串所有前缀和所有后缀交集中最长字符串是 <code>&#39;fd&#39;</code>，其长度是2。</p></li><li><p>字符串的前缀和后缀不包括字符串本身。</p></li><li><p><code>next[0]</code> 初始化成-1仅仅是一个编程技巧，你可以初始化成任意值，只要你分辨出是失配的情况即可，这里初始成 -1 正好可以和 <code>s[i] == p[j]</code> 这种情况合并，所以初始化成 -1 会常用一点。</p></li><li><p>在 KMP 算法中原串索引 <code>i</code> 比较傲娇，它只前进不会回溯，这也是 KMP 速度快的一个主要原因。</p></li><li><p>当出现失配时，模式子串的前缀和后缀有重合，可以直接移动模式串的前缀到刚刚匹配的后缀部分，但要记住如果没有重合的前缀和后缀，失配时移动模式串的速度会更快，这里容易弄反。</p></li></ol><h1 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h1><ul><li>KMP 算法的关键是求解 next 数组，是一个被称为部分匹配表(Partial Match Table)的数组</li><li>KMP 算法相比暴力匹配时间复杂度提升到了O(N+M)，但是并不是最优秀的字符串匹配算法</li><li>想要更快或者选择更合适的算法可以了解下从模式串的尾部开始匹配的 <code>BM算法</code>，以及从模式串的头部开始匹配的 <code>Sunday算法</code></li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/115290419" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>想要看到更高的风景，除了让自己跳的更高以外，还可以选一个更高的平台站上去。找到一个2米高的平台并努力爬上去，远比你原地起跳2米要容易的多~</p><p>2021-4-5 00:22:35</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;一、前言&lt;/h1&gt;&lt;p&gt;又翻到了这个算法，一个常用的子串（子数组）匹配算法，看一遍学一遍，学一遍忘一遍，反反复复，不过每次回忆起来所用的时间越来少了，其本质上就是在暴力搜索的基础上加上 next 数组加速匹配，算法的关键在于 next 数组的理解和求解方法。&lt;/p&gt;
    
    </summary>
    
      <category term="C/C++" scheme="http://AlbertGithubHome.github.io/blog/categories/C-C/"/>
    
    
      <category term="C/C++" scheme="http://AlbertGithubHome.github.io/blog/tags/C-C/"/>
    
      <category term="find" scheme="http://AlbertGithubHome.github.io/blog/tags/find/"/>
    
      <category term="算法" scheme="http://AlbertGithubHome.github.io/blog/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="KMP" scheme="http://AlbertGithubHome.github.io/blog/tags/KMP/"/>
    
  </entry>
  
  <entry>
    <title>C++中常见的字符判断与处理方法</title>
    <link href="http://AlbertGithubHome.github.io/blog/2021/03/28/C-%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84%E5%AD%97%E7%AC%A6%E5%88%A4%E6%96%AD%E4%B8%8E%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95/"/>
    <id>http://AlbertGithubHome.github.io/blog/2021/03/28/C-中常见的字符判断与处理方法/</id>
    <published>2021-03-28T10:01:24.000Z</published>
    <updated>2021-03-28T15:34:08.874Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>字符串处理是编程世界中一项基础技能，特别是对于C/C++的程序员们，远没有那么多华丽的工具可以使用，大多数时候都需要一个个字符来判断和处理，甚至对于C语言来说都没有字符串类型，字符数组是其常见的等价结构，所以稳扎稳打的基本功尤其重要。</p><a id="more"></a><p>对于C++而言，确实有<code>string</code>这个字符串类型，在使用的时候有一些技巧和函数可以使用，比C语言要方便许多了，只是有些时候我们并不知道可以这样用，有时一些很朴素的写法会让程序更加简洁，而一些技巧的表达当明白之后也会感叹自己曾经的无知。</p><h1 id="ASCII-码"><a href="#ASCII-码" class="headerlink" title="ASCII 码"></a>ASCII 码</h1><p>作为字符编码的基础，ASCII码是需要先弄明白的，即使不能把所有的ASCII码对应的字符都记住，也要把常见的字母、数字、特殊字符记住，这样在处理字符问题时可以得心应手，常见的ASCII码对照表如下：</p><p>其中需要注意的知识点：</p><ul><li>前32个为非打印控制字符，后面的字符为打印字符</li><li>数字字符 <code>&#39;0&#39;-&#39;9&#39;</code> 对应的ASCII码范围是48-57</li><li>大写字母 <code>&#39;A&#39;-&#39;Z&#39;</code> 对应的ASCII码范围是65-90</li><li>小写字母 <code>&#39;a&#39;-&#39;z&#39;</code> 对应的ASCII码范围是97-122</li><li><code>NULL</code> 对应ASCII码0，回车的ASCII码是13，换行的ASCII码是10</li></ul><p>仔细观察这个ASCII表你会发现很多“秘密”，比如 windows 中的文件放到 linux 上打开时常常显示许多的 <code>^M</code>，其实这就是<code>\r</code> 的表现，因为在 windows 上用 <code>\r\n</code> 表示换行，而 linux 上使用 <code>\n</code> 换行，那么多余的 <code>\r</code> 在 linux 上就会显示成 <code>^M</code>。</p><p>再比如小写字母 <code>a</code> 和大写字母 <code>A</code> 中间差了32，为什么不是26呢？为什么要在中间插入几个别的字符，搞成连续的不好吗？之前没想过这个问题，但是前两天看了一个高手的代码后，我大概明白了，这个32的差距应该是一种“炫技”的表现，它可以使得许多代码逻辑变得简单。</p><h1 id="判断字符范围的函数"><a href="#判断字符范围的函数" class="headerlink" title="判断字符范围的函数"></a>判断字符范围的函数</h1><h2 id="C-语言"><a href="#C-语言" class="headerlink" title="C 语言"></a>C 语言</h2><p>C语言中判断的字符范围的函数都在头文件 <code>&lt;ctype.h&gt;</code> 中，常见的有下面这些</p><ul><li><code>int isalnum(int c)</code>：检查所传的字符是否是字母和数字</li><li><code>int isalpha(int c)</code>：检查所传的字符是否是字母</li><li><code>int isdigit(int c)</code>：检查所传的字符是否是十进制数字</li><li><code>int islower(int c)</code>：检查所传的字符是否是小写字母</li><li><code>int isupper(int c)</code>：检查所传的字符是否是大写字母</li><li><code>int ispunct(int c)</code>：检查所传的字符是否是标点符号字符</li></ul><h2 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h2><p>C++ 中其实大部分还是引用C语言里的这些函数，但是头文件的名字为 <code>&lt;cctype&gt;</code>，在C++11中加了一个 <code>int isblank(int c)</code> 函数。</p><h1 id="字符判断技巧"><a href="#字符判断技巧" class="headerlink" title="字符判断技巧"></a>字符判断技巧</h1><h2 id="判断两个字符互为大小写"><a href="#判断两个字符互为大小写" class="headerlink" title="判断两个字符互为大小写"></a>判断两个字符互为大小写</h2><p>看到这个问题第一直觉是什么？很简单的问题有木有？因为知道一个字母的大小写差了32，所以会写出下面的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isOk</span><span class="params">(<span class="keyword">char</span> x, <span class="keyword">char</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x - y == <span class="number">32</span> || y - x == <span class="number">32</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过我前两天看到一段代码，它是这样写的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(x ^ <span class="number">32</span>) == y;</span><br></pre></td></tr></table></figure><p>看到这里你还以为 <code>A</code> 和 <code>a</code> 之间差32而不是26感到迷惑吗？简单的字符编排透露着巨大的智慧。</p><h2 id="哨兵的使用"><a href="#哨兵的使用" class="headerlink" title="哨兵的使用"></a>哨兵的使用</h2><p>比如取出一个字符串 <code>string s</code> 中所有的数字，问题很简单，但是结尾字符的处理往往体现了编程的功底，加上一个哨兵字符可以使得编程逻辑简单许多，无须再对结尾字符特殊判断。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">find</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">    s = s + <span class="string">'A'</span>;</span><br><span class="line">    <span class="built_in">string</span> ans;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> c : s) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isdigit</span>(c)) ans += c;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            ans = <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li><code>&#39;0&#39;</code> 的ASCII码是48，<code>&#39;A&#39;</code> 的ASCII码是65，<code>&#39;a&#39;</code> 的ASCII码是97</li><li><code>isdigit</code> 可以判断字符是否是数字，<code>isalpha</code> 可以判断字符是否为字母</li><li>一个字母的大小写对应的ASCII码正好差32，判断互为大小写时可以使用异或符号 <code>(x ^ 32) == y</code></li><li>字符串结尾加哨兵字符可以使得处理逻辑更加简单统一，这种编程技巧在其他结构中也常常出现</li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/115059262" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>今天看到一个一直作为榜样的知识输出者宣布财富自由，满心羡慕，是真的羡慕！关键人家比我年轻，比我工作时间还短，已经依靠短短4、5年的努力达到了自由状态，不过了解他的经历会发现他确实付出了很多，而我们大多数作为普通人太安于现状了，有时候选择比努力重要，如果选择对了又付出了加倍的努力，那……</p><p>2021-3-28 23:27:32</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;字符串处理是编程世界中一项基础技能，特别是对于C/C++的程序员们，远没有那么多华丽的工具可以使用，大多数时候都需要一个个字符来判断和处理，甚至对于C语言来说都没有字符串类型，字符数组是其常见的等价结构，所以稳扎稳打的基本功尤其重要。&lt;/p&gt;
    
    </summary>
    
      <category term="C/C++" scheme="http://AlbertGithubHome.github.io/blog/categories/C-C/"/>
    
    
      <category term="C/C++" scheme="http://AlbertGithubHome.github.io/blog/tags/C-C/"/>
    
      <category term="string" scheme="http://AlbertGithubHome.github.io/blog/tags/string/"/>
    
      <category term="char" scheme="http://AlbertGithubHome.github.io/blog/tags/char/"/>
    
      <category term="判断" scheme="http://AlbertGithubHome.github.io/blog/tags/%E5%88%A4%E6%96%AD/"/>
    
      <category term="查询" scheme="http://AlbertGithubHome.github.io/blog/tags/%E6%9F%A5%E8%AF%A2/"/>
    
  </entry>
  
  <entry>
    <title>C++中反向遍历map时怎样删除元素</title>
    <link href="http://AlbertGithubHome.github.io/blog/2021/03/21/C-%E4%B8%AD%E5%8F%8D%E5%90%91%E9%81%8D%E5%8E%86map%E6%97%B6%E6%80%8E%E6%A0%B7%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0/"/>
    <id>http://AlbertGithubHome.github.io/blog/2021/03/21/C-中反向遍历map时怎样删除元素/</id>
    <published>2021-03-21T07:08:49.000Z</published>
    <updated>2021-03-21T12:02:17.918Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>今天在解决一个问题 <a href="https://leetcode-cn.com/problems/number-of-orders-in-the-backlog/" target="_blank" rel="noopener">《5710. 积压订单中的订单总数》</a> 时用到了map的反向遍历，看到问题时首先想到了优先队列，但是需要维护一个大根堆和一个小根堆，感觉操作起来比较麻烦，突发奇想使用map就能够解决。map本身就是有序的，正向遍历可以得到从小到大的序列，而反向遍历就可以得到从大到小的序列，这个思路本身没有错，但是解题时卡在了反向遍历时如何删除元素的知识点上，特此记录一下。</p><a id="more"></a><h1 id="map的正向遍历"><a href="#map的正向遍历" class="headerlink" title="map的正向遍历"></a>map的正向遍历</h1><p>map的正向遍历是一个基础知识点了，先简单复习一下，不管是用 for 还是 while，只要控制迭代器持续前进就可以了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt; mp&#123;&#123;<span class="number">1</span>, <span class="string">"A"</span>&#125;, &#123;<span class="number">2</span>, <span class="string">"E"</span>&#125;, &#123;<span class="number">3</span>, <span class="string">"I"</span>&#125;, &#123;<span class="number">4</span>, <span class="string">"O"</span>&#125;, &#123;<span class="number">6</span>, <span class="string">"U"</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;::iterator it = mp.begin(); it != mp.end(); ++it) &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">" "</span> &lt;&lt; it-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 输出内容</span></span><br><span class="line"><span class="comment">1 A</span></span><br><span class="line"><span class="comment">2 E</span></span><br><span class="line"><span class="comment">3 I</span></span><br><span class="line"><span class="comment">4 O</span></span><br><span class="line"><span class="comment">6 U</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>引入 <code>auto</code> 关键字以后，定义表示式的时候会更加方便一点</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt; mp&#123;&#123;<span class="number">1</span>, <span class="string">"A"</span>&#125;, &#123;<span class="number">2</span>, <span class="string">"E"</span>&#125;, &#123;<span class="number">3</span>, <span class="string">"I"</span>&#125;, &#123;<span class="number">4</span>, <span class="string">"O"</span>&#125;, &#123;<span class="number">6</span>, <span class="string">"U"</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = mp.begin(); it != mp.end(); ++it) &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">" "</span> &lt;&lt; it-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>引入冒号以后表达式更加简短，要注意的是这里的 <code>it</code> 已经不是指针了，而是 <code>value_type</code> 类型，所以需要是用 <code>.</code> 来访问</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt; mp&#123;&#123;<span class="number">1</span>, <span class="string">"A"</span>&#125;, &#123;<span class="number">2</span>, <span class="string">"E"</span>&#125;, &#123;<span class="number">3</span>, <span class="string">"I"</span>&#125;, &#123;<span class="number">4</span>, <span class="string">"O"</span>&#125;, &#123;<span class="number">6</span>, <span class="string">"U"</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it : mp) &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; it.first &lt;&lt; <span class="string">" "</span> &lt;&lt; it.second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>引入了结构化绑定声明之后，遍历方式还可以写成下面这样</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt; mp&#123;&#123;<span class="number">1</span>, <span class="string">"A"</span>&#125;, &#123;<span class="number">2</span>, <span class="string">"E"</span>&#125;, &#123;<span class="number">3</span>, <span class="string">"I"</span>&#125;, &#123;<span class="number">4</span>, <span class="string">"O"</span>&#125;, &#123;<span class="number">6</span>, <span class="string">"U"</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; [a, b] : mp) &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="string">" "</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="map-遍历时删除元素"><a href="#map-遍历时删除元素" class="headerlink" title="map 遍历时删除元素"></a>map 遍历时删除元素</h1><p>map 遍历时删除需要注意迭代器失效问题，常用的有下面两种写法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">it = mp.erase(it);</span><br></pre></td></tr></table></figure><p>或者<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mp.erase(it++);</span><br></pre></td></tr></table></figure></p><p>遍历删除时的例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt; mp&#123;&#123;<span class="number">1</span>, <span class="string">"A"</span>&#125;, &#123;<span class="number">2</span>, <span class="string">"E"</span>&#125;, &#123;<span class="number">3</span>, <span class="string">"I"</span>&#125;, &#123;<span class="number">4</span>, <span class="string">"O"</span>&#125;, &#123;<span class="number">6</span>, <span class="string">"U"</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = mp.begin(); it != mp.end();) &#123;</span><br><span class="line">    <span class="keyword">if</span> (it-&gt;second == <span class="string">"I"</span>)</span><br><span class="line">        mp.erase(it++);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        it++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it : mp) <span class="built_in">cout</span> &lt;&lt; it.first &lt;&lt; <span class="string">" "</span> &lt;&lt; it.second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 输出内容</span></span><br><span class="line"><span class="comment">1 A</span></span><br><span class="line"><span class="comment">2 E</span></span><br><span class="line"><span class="comment">4 O</span></span><br><span class="line"><span class="comment">6 U</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h1 id="map-的反向遍历"><a href="#map-的反向遍历" class="headerlink" title="map 的反向遍历"></a>map 的反向遍历</h1><p>map 反向遍历时可以使用 <a href="https://en.cppreference.com/w/cpp/iterator/reverse_iterator" target="_blank" rel="noopener">reverse_iterator</a> 迭代器，配合 <code>rbegin()</code> 和 <code>rend()</code> 方法就可以完成反向遍历</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt; mp&#123;&#123;<span class="number">1</span>, <span class="string">"A"</span>&#125;, &#123;<span class="number">2</span>, <span class="string">"E"</span>&#125;, &#123;<span class="number">3</span>, <span class="string">"I"</span>&#125;, &#123;<span class="number">4</span>, <span class="string">"O"</span>&#125;, &#123;<span class="number">6</span>, <span class="string">"U"</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = mp.rbegin(); it != mp.rend(); it++) &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">" "</span> &lt;&lt; it-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 输出内容</span></span><br><span class="line"><span class="comment">6 U</span></span><br><span class="line"><span class="comment">4 O</span></span><br><span class="line"><span class="comment">3 I</span></span><br><span class="line"><span class="comment">2 E</span></span><br><span class="line"><span class="comment">1 A</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h1 id="map-反向遍历时删除元素"><a href="#map-反向遍历时删除元素" class="headerlink" title="map 反向遍历时删除元素"></a>map 反向遍历时删除元素</h1><p>一开始也是用 <code>erase</code> 函数来删除元素，但是会报下面的编译错误</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">error: no matching function <span class="keyword">for</span> call to ‘<span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">std</span>::__cxx11::basic_string&lt;<span class="keyword">char</span>&gt; &gt;::erase(</span><br><span class="line">    <span class="built_in">std</span>::reverse_iterator&lt;<span class="built_in">std</span>::_Rb_tree_iterator&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">const</span> <span class="keyword">int</span>, <span class="built_in">std</span>::__cxx11::basic_string&lt;<span class="keyword">char</span>&gt; &gt; &gt; &gt;)’</span><br><span class="line">    mp.erase(it++);</span><br></pre></td></tr></table></figure><p>查询文档发现，<code>erase</code> 函数重载只有下面几种实现:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">erase</span><span class="params">( iterator pos )</span></span>;                                     (until C++<span class="number">11</span>)</span><br><span class="line"><span class="function">iterator <span class="title">erase</span><span class="params">( const_iterator pos )</span></span>;                           (since C++<span class="number">11</span>)</span><br><span class="line"><span class="function">iterator <span class="title">erase</span><span class="params">( iterator pos )</span></span>;                                 (since C++<span class="number">17</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">erase</span><span class="params">( iterator first, iterator last )</span></span>;                    (until C++<span class="number">11</span>)</span><br><span class="line"><span class="function">iterator <span class="title">erase</span><span class="params">( const_iterator first, const_iterator last )</span></span>;    (since C++<span class="number">11</span>)</span><br><span class="line"></span><br><span class="line"><span class="function">size_type <span class="title">erase</span><span class="params">( <span class="keyword">const</span> key_type&amp; key )</span></span>;</span><br></pre></td></tr></table></figure><p>参数是迭代器的函数并不支持 <code>reverse_iterator</code>，需要将 <code>reverse_iterator</code> 转化成 <code>iterator</code> 才可以，这时就需要用到 <code>base</code> 函数，对 <code>reverse_iterator</code> 类型的迭代器使用 <code>base</code> 函数得到的是上一个元素“原始指针”，这一点比较有意思，具体的解释可以参考 <a href="https://en.cppreference.com/w/cpp/iterator/reverse_iterator/base" target="_blank" rel="noopener">《std::reverse_iterator<iter>::base》</iter></a>，这种操作决定了我们遍历删除的写法，应该是先自增再调用 <code>base</code> 函数，代码如下；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt; mp&#123;&#123;<span class="number">1</span>, <span class="string">"A"</span>&#125;, &#123;<span class="number">2</span>, <span class="string">"E"</span>&#125;, &#123;<span class="number">3</span>, <span class="string">"I"</span>&#125;, &#123;<span class="number">4</span>, <span class="string">"O"</span>&#125;, &#123;<span class="number">6</span>, <span class="string">"U"</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = mp.rbegin(); it != mp.rend();) &#123;</span><br><span class="line">    <span class="keyword">if</span> (it-&gt;second == <span class="string">"I"</span>) mp.erase((++it).base());</span><br><span class="line">    <span class="keyword">else</span> it++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = mp.rbegin(); it != mp.rend(); it++)</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">" "</span> &lt;&lt; it-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 输出内容</span></span><br><span class="line"><span class="comment">6 U</span></span><br><span class="line"><span class="comment">4 O</span></span><br><span class="line"><span class="comment">2 E</span></span><br><span class="line"><span class="comment">1 A</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>map 默认会按照 key 排序，是一个常用的有序容器</li><li>配合使用 <code>rbegin()</code> 和 <code>rend()</code> 函数可以完成 map 的反向遍历</li><li>对 <code>reverse_iterator</code> 类型迭代器使用 <code>base()</code> 函数，可以转化成 <code>iterator</code> 相关类型，然后进行删除操作</li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/114806994" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>搬起砖，我抱不了你，放下砖 … 我尽力！</p><p>2021-3-21 19:44:27</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;今天在解决一个问题 &lt;a href=&quot;https://leetcode-cn.com/problems/number-of-orders-in-the-backlog/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《5710. 积压订单中的订单总数》&lt;/a&gt; 时用到了map的反向遍历，看到问题时首先想到了优先队列，但是需要维护一个大根堆和一个小根堆，感觉操作起来比较麻烦，突发奇想使用map就能够解决。map本身就是有序的，正向遍历可以得到从小到大的序列，而反向遍历就可以得到从大到小的序列，这个思路本身没有错，但是解题时卡在了反向遍历时如何删除元素的知识点上，特此记录一下。&lt;/p&gt;
    
    </summary>
    
      <category term="C/C++" scheme="http://AlbertGithubHome.github.io/blog/categories/C-C/"/>
    
    
      <category term="C/C++" scheme="http://AlbertGithubHome.github.io/blog/tags/C-C/"/>
    
      <category term="iterator" scheme="http://AlbertGithubHome.github.io/blog/tags/iterator/"/>
    
      <category term="reverse_iterator" scheme="http://AlbertGithubHome.github.io/blog/tags/reverse-iterator/"/>
    
      <category term="base" scheme="http://AlbertGithubHome.github.io/blog/tags/base/"/>
    
  </entry>
  
  <entry>
    <title>解决git命令会将结果输出到单独窗口必须按q才能退出的问题</title>
    <link href="http://AlbertGithubHome.github.io/blog/2021/03/14/%E8%A7%A3%E5%86%B3git%E5%91%BD%E4%BB%A4%E4%BC%9A%E5%B0%86%E7%BB%93%E6%9E%9C%E8%BE%93%E5%87%BA%E5%88%B0%E5%8D%95%E7%8B%AC%E7%AA%97%E5%8F%A3%E5%BF%85%E9%A1%BB%E6%8C%89q%E6%89%8D%E8%83%BD%E9%80%80%E5%87%BA%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://AlbertGithubHome.github.io/blog/2021/03/14/解决git命令会将结果输出到单独窗口必须按q才能退出的问题/</id>
    <published>2021-03-14T08:19:15.000Z</published>
    <updated>2021-03-14T14:26:22.534Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>平时会在 windows+linux 两种环境下进行开发，版本控制软件用 git 比较多，但是一直有个小问题，在 windows 下使用 <code>git Bash</code> 比较顺手，但是在 linux 使用 git 部分命令的时候，常常会打开一个新的窗口，按q键才能退出，比如 <code>git branch</code>、<code>git log</code>、<code>git show</code> 等等。</p><a id="more"></a><p>如果是使用 <code>git log</code> 查询日志后想进行合并或者回退等操作时，因为日志信息已经退出没有显示在当前窗口，这种情况会比较麻烦，有时候还需要额外再查询一次，还有就是 <code>git branch</code> 命显示内容常常较少，单独打开一个窗口也没有必要，所以想单独设置这种情况，后来查询资料发现，这与 git 的 pager 设置有关，特此记录一下。</p><h1 id="什么是-pager"><a href="#什么是-pager" class="headerlink" title="什么是 pager"></a>什么是 pager</h1><p>pager 其实就是分页器，也就是对一大段内容进行分页显示的工具，git 在一些版本中默认使用的是 less 工具，不同的版本默认设置会有差异，这也就是造成我在 windows 下没有自动分页，而在 linux 下会打开新窗口进行分页的原因。</p><p>git 的分页器可以通过 <code>core.pager</code> 来进行设置，他会被 git 命令行解释，影响分页器的变量有多个，他们起作用的顺序依次是 <code>$GIT_PAGER</code> 环境变量，<code>core.pager</code> git配置，<code>$PAGER</code> 环境变量，如果这些都没有设置，默认会选择编译时的选项（通常为less），具体细节可以参考官方文档 <a href="https://git-scm.com/docs/git-config#Documentation/git-config.txt-corepager" target="_blank" rel="noopener">git core.pager</a>。</p><h1 id="设置-core-pager"><a href="#设置-core-pager" class="headerlink" title="设置 core.pager"></a>设置 core.pager</h1><p>了解了上面的原理，我们就知道只要单独修改 git 配置就可以了，默认的分页器是 less，我们只要设置了 <code>core.pager</code> 就可以影响结果，所以在 git Bash 中执行下面的语句即可。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global core.pager <span class="string">''</span></span><br></pre></td></tr></table></figure><p>其实就是将分页器清空就行了，这样再执行 <code>git branch</code> 的时候就不会出现分页的情况了。</p><h1 id="更精细的设置"><a href="#更精细的设置" class="headerlink" title="更精细的设置"></a>更精细的设置</h1><p>设置 <code>core.pager</code> 这项配置后对 less 分页器进行了全局屏蔽，虽然 <code>git branch</code> 这种显示内容少的命令比较方便了，但是执行 <code>git show</code> 的时候不分页反而会显得混乱，有没有单独设置每个 git 命令的配置呢？</p><p>答案当然是肯定的，比如上面提到的这种情况，我们只想屏蔽 <code>git branch</code> 命令的分页，而想保留<code>git show</code> 和 <code>git log</code> 的分页显示，就可以单独执行下面的命令。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global pager.branch <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>这样就可以达到只屏蔽 <code>git branch</code> 命令的分页结果了。</p><h1 id="less-and-more"><a href="#less-and-more" class="headerlink" title="less and more"></a>less and more</h1><p>临时插播个知识点，less 和 more 都是 linux 的文本显示工具，那么它们谁更厉害一点呢？从名字上来看应该是 more 更厉害，但实际上是 less 更厉害，less 在 more 的基础上加上了后退功能（据说最初版本more不能后退，现在的常见版本已经支持后退功能了），支持上下键翻页，并且速度更快一点，所以在 linux 的世界一直流传着 “less is more” 这句话。另外 more 退出后会在 shell 上留下刚显示的内容，而 less 不会。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>使用 <code>git config --global core.pager &#39;&#39;</code> 命令可以屏蔽 git 默认的分页器 less</li><li>使用 <code>git config --global pager.branch false</code> 命令可以只关闭 <code>git branch</code> 命令的分页显示</li><li>less 命令比 more 命令更加强大，支持上下键翻页，退出后不会在 shell 显示刚才的内容</li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/114465098" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>学而不思则罔，思而不学则殆。动而不思则徒，思而不动则颓。</p><p>2021-3-14 17:14:55</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;平时会在 windows+linux 两种环境下进行开发，版本控制软件用 git 比较多，但是一直有个小问题，在 windows 下使用 &lt;code&gt;git Bash&lt;/code&gt; 比较顺手，但是在 linux 使用 git 部分命令的时候，常常会打开一个新的窗口，按q键才能退出，比如 &lt;code&gt;git branch&lt;/code&gt;、&lt;code&gt;git log&lt;/code&gt;、&lt;code&gt;git show&lt;/code&gt; 等等。&lt;/p&gt;
    
    </summary>
    
      <category term="Git" scheme="http://AlbertGithubHome.github.io/blog/categories/Git/"/>
    
    
      <category term="git" scheme="http://AlbertGithubHome.github.io/blog/tags/git/"/>
    
      <category term="branch" scheme="http://AlbertGithubHome.github.io/blog/tags/branch/"/>
    
      <category term="log" scheme="http://AlbertGithubHome.github.io/blog/tags/log/"/>
    
      <category term="pager" scheme="http://AlbertGithubHome.github.io/blog/tags/pager/"/>
    
      <category term="config" scheme="http://AlbertGithubHome.github.io/blog/tags/config/"/>
    
  </entry>
  
  <entry>
    <title>Python中int、str、bytes相互转化，还有2进制、16进制表示，你想要的都在这里了</title>
    <link href="http://AlbertGithubHome.github.io/blog/2021/03/05/Python%E4%B8%ADint%E3%80%81str%E3%80%81byte%E7%9B%B8%E4%BA%92%E8%BD%AC%E5%8C%96%EF%BC%8C%E8%BF%98%E6%9C%892%E8%BF%9B%E5%88%B6%E3%80%8116%E8%BF%9B%E5%88%B6%E8%A1%A8%E7%A4%BA%EF%BC%8C%E4%BD%A0%E6%83%B3%E8%A6%81%E7%9A%84%E9%83%BD%E5%9C%A8%E8%BF%99%E9%87%8C%E4%BA%86/"/>
    <id>http://AlbertGithubHome.github.io/blog/2021/03/05/Python中int、str、byte相互转化，还有2进制、16进制表示，你想要的都在这里了/</id>
    <published>2021-03-04T16:04:47.000Z</published>
    <updated>2021-03-06T16:25:58.861Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>数据类型转换是个很基础的操作，很多语言中都要做这些转换，例如前一段时间刚刚总结了<a href="https://blog.csdn.net/albertsh/article/details/113765130" target="_blank" rel="noopener">《C/C++中string和int相互转换的常用方法》</a>，python 自从分离出 python3 版本之后，<code>str</code> 和 <code>bytes</code> 两个类型弄蒙了一大票人，在这两种类型的转换上我可是花了不少时间，记住一点，别随随便便使用 <code>str()</code> 函数，很多数据使用 <code>str()</code> 变成字符串之后再想恢复可就难了。</p><a id="more"></a><p>本文所有示例均在 <code>Python 3.7.5</code> 上测试，<code>Python2</code> 已经被我抛弃了，我来试着把常见的转换都放到一起，把踩过的坑拿来开心一下，如果有些常用的类型转换这里没有的话，也欢迎小伙伴们提出来，我将持续补充，好了，可以开始了。</p><h1 id="数据类型转化"><a href="#数据类型转化" class="headerlink" title="数据类型转化"></a>数据类型转化</h1><p>数字中除了整数，还有浮点数、复数等，但是 <code>int</code> 是最常见的类型，所有转换中的数字只涉及 <code>int</code> 数字类型。</p><h2 id="int-gt-str"><a href="#int-gt-str" class="headerlink" title="int -&gt; str"></a>int -&gt; str</h2><h3 id="使用-str-函数"><a href="#使用-str-函数" class="headerlink" title="使用 str() 函数"></a>使用 str() 函数</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">num = <span class="number">10</span></span><br><span class="line">val = str(<span class="number">10</span>)</span><br><span class="line">print(type(val), val)</span><br><span class="line"></span><br><span class="line"><span class="comment">#&lt;class 'str'&gt; 10</span></span><br></pre></td></tr></table></figure><h3 id="使用-format-函数"><a href="#使用-format-函数" class="headerlink" title="使用 format() 函数"></a>使用 format() 函数</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">num = <span class="number">10</span></span><br><span class="line">val = <span class="string">'&#123;0&#125;'</span>.format(num)</span><br><span class="line">print(type(val), val)</span><br><span class="line"></span><br><span class="line"><span class="comment">#&lt;class 'str'&gt; 10</span></span><br></pre></td></tr></table></figure><h3 id="使用-hex-转换成16进制形式"><a href="#使用-hex-转换成16进制形式" class="headerlink" title="使用 hex() 转换成16进制形式"></a>使用 hex() 转换成16进制形式</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">num = <span class="number">10</span></span><br><span class="line">val = hex(num)</span><br><span class="line">print(type(val), val)</span><br><span class="line"></span><br><span class="line"><span class="comment">#&lt;class 'str'&gt; 0xa</span></span><br></pre></td></tr></table></figure><h3 id="使用-bin-转换成2进制形式"><a href="#使用-bin-转换成2进制形式" class="headerlink" title="使用 bin() 转换成2进制形式"></a>使用 bin() 转换成2进制形式</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">num = <span class="number">10</span></span><br><span class="line">val = bin(num).replace(<span class="string">'0b'</span>,<span class="string">''</span>)</span><br><span class="line">print(type(val), val)</span><br><span class="line"></span><br><span class="line"><span class="comment">#&lt;class 'str'&gt; 1010</span></span><br></pre></td></tr></table></figure><h2 id="str-gt-int"><a href="#str-gt-int" class="headerlink" title="str -&gt; int"></a>str -&gt; int</h2><p>这个转换比较专一，只使用 <code>int()</code> 函数就可以了，这个函数实际上有两个参数，第二个参数表示进制，默认是10进制，你可以改成2进制或者16进制，甚至是3进制、5进制等等</p><h3 id="使用-int-进行各进制数字转换"><a href="#使用-int-进行各进制数字转换" class="headerlink" title="使用 int() 进行各进制数字转换"></a>使用 int() 进行各进制数字转换</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">val = int(<span class="string">'10'</span>)</span><br><span class="line">print(type(val), val)</span><br><span class="line"></span><br><span class="line">val = int(<span class="string">'0xa'</span>, <span class="number">16</span>)</span><br><span class="line">print(type(val), val)</span><br><span class="line">val = int(<span class="string">'a'</span>, <span class="number">16</span>)</span><br><span class="line">print(type(val), val)</span><br><span class="line"></span><br><span class="line">val = int(<span class="string">'0b1010'</span>, <span class="number">2</span>)</span><br><span class="line">print(type(val), val)</span><br><span class="line">val = int(<span class="string">'1010'</span>, <span class="number">2</span>)</span><br><span class="line">print(type(val), val)</span><br><span class="line"></span><br><span class="line">val = int(<span class="string">'101'</span>, <span class="number">3</span>)</span><br><span class="line">print(type(val), val)</span><br><span class="line"></span><br><span class="line">val = int(<span class="string">'60'</span>, <span class="number">5</span>)</span><br><span class="line">print(type(val), val)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果均为 &lt;class 'int'&gt; 10</span></span><br></pre></td></tr></table></figure><p>使用 <code>int()</code> 函数的时候要主要注意一点，如果提供的字符串不能转换成指定进制的数字，那么会报异常，就像下面这样，所以在使用这个函数的时候最好放到 <code>try</code> 语句中。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">val = int(<span class="string">'128'</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">Traceback (most recent call last):</span></span><br><span class="line"><span class="string">  File "D:\python\convert\convert.py", line 41, in &lt;module&gt;</span></span><br><span class="line"><span class="string">    val = int('128', 2)</span></span><br><span class="line"><span class="string">ValueError: invalid literal for int() with base 2: '128'</span></span><br><span class="line"><span class="string">[Finished in 0.1s with exit code 1]</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><h2 id="什么是bytes"><a href="#什么是bytes" class="headerlink" title="什么是bytes"></a>什么是bytes</h2><p>在列举 bytes 相关的转化前，我们来先认识一下这个类型，在 Python3 中 <code>int</code>、<code>str</code>、<code>bytes</code> 类型的变量实际上都是一个 “类” 的对象，而 <code>bytes</code> 相比 <code>str</code> 而言更接近底层数据，也更接近存储的形式，它其实是一个字节的数组，类似于 <code>C</code> 语言中的 <code>char []</code>，每个字节是一个范围在 0-255 的数字。</p><p><code>bytes</code> 其实就是这样一连串的数字，计算机世界所有的信息都可以用这样一串数字表示，一幅画，一首歌，一部电影等等，如果对编码感兴趣可以看看这篇<a href="https://blog.csdn.net/albertsh/article/details/110357193" target="_blank" rel="noopener">《简单聊聊01世界中编码和解码这对磨人的小妖儿》</a>，现在清楚bytes是什么了，我们可以看看和它相关的转化了。</p><h2 id="int-gt-bytes"><a href="#int-gt-bytes" class="headerlink" title="int -&gt; bytes"></a>int -&gt; bytes</h2><h3 id="使用-to-bytes-转换成定长bytes"><a href="#使用-to-bytes-转换成定长bytes" class="headerlink" title="使用 to_bytes() 转换成定长bytes"></a>使用 to_bytes() 转换成定长bytes</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">num = <span class="number">4665</span></span><br><span class="line">val = num.to_bytes(length=<span class="number">4</span>, byteorder=<span class="string">'little'</span>, signed=<span class="keyword">False</span>)</span><br><span class="line">print(type(val), val)</span><br><span class="line"></span><br><span class="line"><span class="comment">#&lt;class 'bytes'&gt; b'9\x12\x00\x00'</span></span><br></pre></td></tr></table></figure><p>这段代码就是把数字 4665 转化成定长的4个字节，字节序为小端，我们来简单看一下是怎么转换的：</p><p>上面我们提到 <code>bytes</code> 类型一串 0-255 范围的数字，4665 肯定超出了这个范围，可以先转化成256进制，就变成了 <18><57>，也就是 4665 = 18 * 256 + 57，我们发现两个字节就能存储这个数字，一个18，一个57，要想组成4个字节的数组需要补充两个空位，也就是补充两个0，这时就涉及到一个排列顺序，是 [0,0,18,57] 还是 [57, 18, 0, 0] 呢，这就是函数参数中的字节序 <code>byteorder</code>，little 表示小端，big 表示大端，这里选择的小端 [57, 18, 0, 0] 的排列。</57></18></p><p>看到这里可能会迷糊，好像和结果不一样啊，其实这只是一个表示问题，57 的 ASCII 码对应这个字符 ‘9’，18 表示成16进制就是 ‘0x12’，这里写成 b’9\x12\x00\x00’ 只是便于识别而已，实际上内存存储的就是 [57, 18, 0, 0] 这一串数字对应的二进制编码 ‘00111001 00010010 00000000 00000000’。</p><h3 id="使用-bytes-函数把int数组转成bytes"><a href="#使用-bytes-函数把int数组转成bytes" class="headerlink" title="使用 bytes() 函数把int数组转成bytes"></a>使用 bytes() 函数把int数组转成bytes</h3><p>参考上面的生成的数组，可以通过数组生成相同的结果</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">num_array = [<span class="number">57</span>, <span class="number">18</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">val = bytes(num_array)</span><br><span class="line">print(type(val), val)</span><br><span class="line"></span><br><span class="line"><span class="comment">#&lt;class 'bytes'&gt; b'9\x12\x00\x00'</span></span><br></pre></td></tr></table></figure><h3 id="使用-struct-pack-函数把数字转化成bytes"><a href="#使用-struct-pack-函数把数字转化成bytes" class="headerlink" title="使用 struct.pack() 函数把数字转化成bytes"></a>使用 struct.pack() 函数把数字转化成bytes</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">num = <span class="number">4665</span></span><br><span class="line">val = struct.pack(<span class="string">"&lt;I"</span>, num)</span><br><span class="line">print(type(val), val)</span><br><span class="line"></span><br><span class="line"><span class="comment">#&lt;class 'bytes'&gt; b'9\x12\x00\x00'</span></span><br></pre></td></tr></table></figure><p>这里的 <code>&quot;&lt;I&quot;</code> 表示将一个整数转化成小端字节序的4字节数组，其他的类型还有：</p><table><thead><tr><th style="text-align:left">参数</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:left">&gt;</td><td style="text-align:center">大端序</td></tr><tr><td style="text-align:left">&lt;</td><td style="text-align:center">小端序</td></tr><tr><td style="text-align:left">B</td><td style="text-align:center">uint8类型</td></tr><tr><td style="text-align:left">b</td><td style="text-align:center">int8类型</td></tr><tr><td style="text-align:left">H</td><td style="text-align:center">uint16类型</td></tr><tr><td style="text-align:left">h</td><td style="text-align:center">int16类型</td></tr><tr><td style="text-align:left">I</td><td style="text-align:center">uint32类型</td></tr><tr><td style="text-align:left">i</td><td style="text-align:center">int32类型</td></tr><tr><td style="text-align:left">L</td><td style="text-align:center">uint64类型</td></tr><tr><td style="text-align:left">l</td><td style="text-align:center">int64类型</td></tr><tr><td style="text-align:left">s</td><td style="text-align:center">ascii码，s前带数字表示个数</td></tr></tbody></table><h2 id="bytes-gt-int"><a href="#bytes-gt-int" class="headerlink" title="bytes -&gt; int"></a>bytes -&gt; int</h2><p>明白了上面的转化过程，从 bytes 转化到 int 只需要反着来就行了</p><h3 id="使用-from-bytes-把-bytes-转化成int"><a href="#使用-from-bytes-把-bytes-转化成int" class="headerlink" title="使用 from_bytes() 把 bytes 转化成int"></a>使用 from_bytes() 把 bytes 转化成int</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">bys = <span class="string">b'9\x12\x00\x00'</span></span><br><span class="line">val = int.from_bytes(bys, byteorder=<span class="string">'little'</span>, signed=<span class="keyword">False</span>)</span><br><span class="line">print(type(val), val)</span><br><span class="line"></span><br><span class="line"><span class="comment">#&lt;class 'int'&gt; 4665</span></span><br></pre></td></tr></table></figure><h3 id="使用-struct-unpack-把-bytes-转化成int"><a href="#使用-struct-unpack-把-bytes-转化成int" class="headerlink" title="使用 struct.unpack() 把 bytes 转化成int"></a>使用 struct.unpack() 把 bytes 转化成int</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">bys = <span class="string">b'9\x12\x00\x00'</span></span><br><span class="line">val = struct.unpack(<span class="string">"&lt;I"</span>, bys)</span><br><span class="line">print(type(val), val)</span><br><span class="line"></span><br><span class="line"><span class="comment">#&lt;class 'tuple'&gt; (4665,)</span></span><br></pre></td></tr></table></figure><h2 id="str-和-bytes"><a href="#str-和-bytes" class="headerlink" title="str 和 bytes"></a>str 和 bytes</h2><p>前面的这些转化还算清晰，到了字符串str 和字节串 bytes，就开始进入了混沌的状态，这里会出现各种编码，各种乱码，各种报错，牢记一点 str 到 bytes 是编码过程，需要使用 <code>encode()</code> 函数， bytes 到 str 是解码过程，需要使用 <code>decode()</code> 函数，请勿使用 <code>str</code> 函数，否则后果自负。</p><h3 id="使用-encode-函数完成-str-gt-bytes"><a href="#使用-encode-函数完成-str-gt-bytes" class="headerlink" title="使用 encode() 函数完成  str -&gt; bytes"></a>使用 encode() 函数完成  str -&gt; bytes</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">'大漠孤烟直qaq'</span></span><br><span class="line">val = s.encode(<span class="string">'utf-8'</span>)</span><br><span class="line">print(type(val), val)</span><br><span class="line"></span><br><span class="line"><span class="comment"># &lt;class 'bytes'&gt; b'\xe5\xa4\xa7\xe6\xbc\xa0\xe5\xad\xa4\xe7\x83\x9f\xe7\x9b\xb4qaq'</span></span><br></pre></td></tr></table></figure><h3 id="使用-decode-函数完成-bytes-gt-str"><a href="#使用-decode-函数完成-bytes-gt-str" class="headerlink" title="使用 decode() 函数完成  bytes -&gt; str"></a>使用 decode() 函数完成  bytes -&gt; str</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">bys = <span class="string">b'\xe5\xa4\xa7\xe6\xbc\xa0\xe5\xad\xa4\xe7\x83\x9f\xe7\x9b\xb4qaq'</span></span><br><span class="line">val = bys.decode(<span class="string">'utf-8'</span>)</span><br><span class="line">print(type(val), val)</span><br><span class="line"></span><br><span class="line"><span class="comment"># &lt;class 'str'&gt; 大漠孤烟直qaq</span></span><br></pre></td></tr></table></figure><h2 id="假如使用了-str-函数"><a href="#假如使用了-str-函数" class="headerlink" title="假如使用了 str() 函数"></a>假如使用了 str() 函数</h2><p>从上面来看字符串和字节串的转化蛮简单的，甚至比整数的转化都要简单，但是你如果把一个 bytes 变量用 str() 转化成字符串，你就得手动来处理了，这个函数写过n次了，暂时还没找到好的处理办法。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">bys = <span class="string">b'\xe5\xa4\xa7\xe6\xbc\xa0\xe5\xad\xa4\xe7\x83\x9f\xe7\x9b\xb4qaq'</span></span><br><span class="line">s = str(bys)</span><br><span class="line">print(type(s), s)</span><br><span class="line"><span class="comment">#&lt;class 'str'&gt; b'\xe5\xa4\xa7\xe6\xbc\xa0\xe5\xad\xa4\xe7\x83\x9f\xe7\x9b\xb4qaq'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">str2bytes</span><span class="params">(str_content)</span>:</span></span><br><span class="line">    result_list = [];</span><br><span class="line">    pos = <span class="number">0</span></span><br><span class="line">    str_content = str_content.replace(<span class="string">"\\n"</span>, <span class="string">"\n"</span>).replace(<span class="string">"\\t"</span>, <span class="string">"\t"</span>).replace(<span class="string">"\\r"</span>, <span class="string">"\r"</span>)</span><br><span class="line">    content_len = len(str_content)</span><br><span class="line">    <span class="keyword">while</span> pos &lt; content_len:</span><br><span class="line">        <span class="keyword">if</span> str_content[pos] == <span class="string">'\\'</span> <span class="keyword">and</span> pos + <span class="number">3</span> &lt; content_len <span class="keyword">and</span> str_content[pos + <span class="number">1</span>] == <span class="string">'x'</span>:</span><br><span class="line">            sub_str = str_content[pos + <span class="number">2</span>: pos + <span class="number">4</span>]</span><br><span class="line">            result_list.append(int(sub_str, <span class="number">16</span>))</span><br><span class="line">            pos = pos + <span class="number">4</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            result_list.append(ord(str_content[pos]))</span><br><span class="line">            pos = pos + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> bytes(result_list)</span><br><span class="line"></span><br><span class="line">val = str2bytes(s[<span class="number">2</span>:<span class="number">-1</span>])</span><br><span class="line">print(type(val), val)</span><br><span class="line"></span><br><span class="line"><span class="comment"># &lt;class 'bytes'&gt; b'\xe5\xa4\xa7\xe6\xbc\xa0\xe5\xad\xa4\xe7\x83\x9f\xe7\x9b\xb4qaq'</span></span><br></pre></td></tr></table></figure><p>什么时候会遇到这种情况，就是有些数据是以 bytes 的形式给的，但是经过中间人复制转发变成了字节流形式的字符串，格式还不统一，有些已经翻译成了字符，有些还保留了0x或者\x形式，这时就要手工处理了。</p><h1 id="转化表格"><a href="#转化表格" class="headerlink" title="转化表格"></a>转化表格</h1><p>上面的转化方式和解释穿插在一起有些乱，这里总结一个表格，便于今后拿来就用</p><table><thead><tr><th style="text-align:left">源类型</th><th style="text-align:center">目标类型</th><th style="text-align:center">方式</th><th style="text-align:center">结果</th></tr></thead><tbody><tr><td style="text-align:left">int</td><td style="text-align:center">str</td><td style="text-align:center"><code>str(10)</code>、<code>&#39;{0}&#39;.format(10)</code></td><td style="text-align:center"><code>10</code> =&gt; <code>&#39;10&#39;</code></td></tr><tr><td style="text-align:left">int</td><td style="text-align:center">str（16进制）</td><td style="text-align:center"><code>hex(10)</code></td><td style="text-align:center"><code>10</code> =&gt; <code>&#39;0xa&#39;</code></td></tr><tr><td style="text-align:left">int</td><td style="text-align:center">str（2进制）</td><td style="text-align:center"><code>bin(10).replace(&#39;0b&#39;,&#39;&#39;)</code></td><td style="text-align:center"><code>10</code> =&gt; <code>&#39;1010&#39;</code></td></tr><tr><td style="text-align:left">str</td><td style="text-align:center">int</td><td style="text-align:center"><code>int(&#39;10&#39;)</code></td><td style="text-align:center"><code>&#39;10&#39;</code> =&gt; <code>10</code></td></tr><tr><td style="text-align:left">str（16进制）</td><td style="text-align:center">int</td><td style="text-align:center"><code>int(&#39;0xa&#39;, 16)</code></td><td style="text-align:center"><code>&#39;0xa&#39;</code> =&gt; <code>10</code></td></tr><tr><td style="text-align:left">str（2进制）</td><td style="text-align:center">int</td><td style="text-align:center"><code>int(&#39;1010&#39;, 2)</code></td><td style="text-align:center"><code>&#39;1010&#39;</code> =&gt; <code>10</code></td></tr><tr><td style="text-align:left">int</td><td style="text-align:center">bytes</td><td style="text-align:center"><code>num.to_bytes(length=4, byteorder=&#39;little&#39;, signed=False)</code></td><td style="text-align:center"><code>4665</code> =&gt; <code>b&#39;9\x12\x00\x00&#39;</code></td></tr><tr><td style="text-align:left">int</td><td style="text-align:center">bytes</td><td style="text-align:center"><code>struct.pack(&quot;&lt;I&quot;, 4665)</code></td><td style="text-align:center"><code>4665</code> =&gt; <code>b&#39;9\x12\x00\x00&#39;</code></td></tr><tr><td style="text-align:left">bytes</td><td style="text-align:center">int</td><td style="text-align:center"><code>int.from_bytes(b&#39;9\x12\x00\x00&#39;, byteorder=&#39;little&#39;, signed=False)</code></td><td style="text-align:center"><code>b&#39;9\x12\x00\x00&#39;</code> =&gt; <code>4665</code></td></tr><tr><td style="text-align:left">bytes</td><td style="text-align:center">int</td><td style="text-align:center"><code>struct.unpack(&quot;&lt;I&quot;, b&#39;9\x12\x00\x00&#39;)</code></td><td style="text-align:center"><code>b&#39;9\x12\x00\x00&#39;</code> =&gt; <code>4665</code></td></tr><tr><td style="text-align:left">int[]</td><td style="text-align:center">bytes</td><td style="text-align:center"><code>bytes([57, 18, 0, 0])</code></td><td style="text-align:center"><code>[57, 18, 0, 0]</code> =&gt; <code>b&#39;9\x12\x00\x00&#39;</code></td></tr><tr><td style="text-align:left">bytes</td><td style="text-align:center">int[]</td><td style="text-align:center"><code>[x for x in b&#39;9\x12\x00\x00&#39;]</code></td><td style="text-align:center"><code>b&#39;9\x12\x00\x00&#39;</code> =&gt; <code>[57, 18, 0, 0]</code></td></tr><tr><td style="text-align:left">str</td><td style="text-align:center">bytes</td><td style="text-align:center"><code>&#39;美好&#39;.encode(&#39;utf-8&#39;)</code></td><td style="text-align:center"><code>&#39;美好&#39;</code> =&gt; <code>b&#39;\xe7\xbe\x8e\xe5\xa5\xbd&#39;</code></td></tr><tr><td style="text-align:left">str</td><td style="text-align:center">bytes</td><td style="text-align:center"><code>bytes(&#39;美好&#39;, &#39;utf-8&#39;)</code></td><td style="text-align:center"><code>&#39;美好&#39;</code> =&gt; <code>b&#39;\xe7\xbe\x8e\xe5\xa5\xbd&#39;</code></td></tr><tr><td style="text-align:left">bytes</td><td style="text-align:center">str</td><td style="text-align:center"><code>b&#39;\xe7\xbe\x8e\xe5\xa5\xbd&#39;.decode(&#39;utf-8&#39;)</code></td><td style="text-align:center"><code>b&#39;\xe7\xbe\x8e\xe5\xa5\xbd&#39;</code> =&gt; <code>&#39;美好&#39;</code></td></tr><tr><td style="text-align:left">bytes</td><td style="text-align:center">bytes（无\x）</td><td style="text-align:center"><code>binascii.b2a_hex(b&#39;\xe7\xbe\x8eqaq&#39;)</code></td><td style="text-align:center"><code>b&#39;\xe7\xbe\x8eqaq&#39;</code> =&gt; <code>b&#39;e7be8e716171&#39;</code></td></tr><tr><td style="text-align:left">bytes</td><td style="text-align:center">bytes（有\x）</td><td style="text-align:center"><code>binascii.a2b_hex(b&#39;e7be8e716171&#39;)</code></td><td style="text-align:center"><code>b&#39;e7be8e716171&#39;</code> =&gt; <code>b&#39;\xe7\xbe\x8eqaq&#39;</code></td></tr><tr><td style="text-align:left">bytes</td><td style="text-align:center">str（hex）</td><td style="text-align:center"><code>b&#39;\xe7\xbe\x8eqaq&#39;.hex()</code></td><td style="text-align:center"><code>b&#39;\xe7\xbe\x8eqaq&#39;</code> =&gt; <code>&#39;e7be8e716171&#39;</code></td></tr><tr><td style="text-align:left">str（hex）</td><td style="text-align:center">bytes</td><td style="text-align:center"><code>bytes.fromhex(&#39;e7be8e716171&#39;)</code></td><td style="text-align:center"><code>&#39;e7be8e716171&#39;</code> =&gt; <code>b&#39;\xe7\xbe\x8eqaq&#39;</code></td></tr></tbody></table><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>Python3 对字符串和二进制数据流做了明确的区分，不会以任意隐式的方式混用 <code>str</code> 和 <code>bytes</code></li><li><code>bytes</code> 类型是一种比特流，它的存在形式是 01010001110 的形式，需要解码成字符才容易被人理解</li><li>struct 模块中的 <code>pack()</code> 和 <code>unpack()</code> 可以实现任意类型和 <code>bytes</code> 之间的转换</li><li><code>binascii.b2a_hex</code> 和 <code>binascii.a2b_hex</code> 可以实现16进制 bytes 的不同形式转换，不过转换前后长度发生了变化</li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/114199056" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>初识不知曲中意，再闻已是曲中人</p><p>2021-3-6 20:36:10</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;数据类型转换是个很基础的操作，很多语言中都要做这些转换，例如前一段时间刚刚总结了&lt;a href=&quot;https://blog.csdn.net/albertsh/article/details/113765130&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《C/C++中string和int相互转换的常用方法》&lt;/a&gt;，python 自从分离出 python3 版本之后，&lt;code&gt;str&lt;/code&gt; 和 &lt;code&gt;bytes&lt;/code&gt; 两个类型弄蒙了一大票人，在这两种类型的转换上我可是花了不少时间，记住一点，别随随便便使用 &lt;code&gt;str()&lt;/code&gt; 函数，很多数据使用 &lt;code&gt;str()&lt;/code&gt; 变成字符串之后再想恢复可就难了。&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="http://AlbertGithubHome.github.io/blog/categories/Python/"/>
    
    
      <category term="int" scheme="http://AlbertGithubHome.github.io/blog/tags/int/"/>
    
      <category term="Python" scheme="http://AlbertGithubHome.github.io/blog/tags/Python/"/>
    
      <category term="str" scheme="http://AlbertGithubHome.github.io/blog/tags/str/"/>
    
      <category term="bytes" scheme="http://AlbertGithubHome.github.io/blog/tags/bytes/"/>
    
      <category term="hex" scheme="http://AlbertGithubHome.github.io/blog/tags/hex/"/>
    
  </entry>
  
  <entry>
    <title>linux环境下的mount命令到底有什么玄机</title>
    <link href="http://AlbertGithubHome.github.io/blog/2021/02/22/linux%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%9A%84mount%E5%91%BD%E4%BB%A4%E5%88%B0%E5%BA%95%E6%9C%89%E4%BB%80%E4%B9%88%E7%8E%84%E6%9C%BA/"/>
    <id>http://AlbertGithubHome.github.io/blog/2021/02/22/linux环境下的mount命令到底有什么玄机/</id>
    <published>2021-02-22T14:54:42.000Z</published>
    <updated>2021-02-27T16:18:06.940Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>linux 环境下的 <code>mount</code> 命令可以挂载一个文件系统，这个命令目前是我所知命令中最陌生的一个，至今没有使用过，真的一次都没有挂载过，平时用的最多是的 Windwos 系统，完全不需要挂载，安装新硬盘自动就会出现盘符，稍微复杂点就是通过磁盘管理器来分区，或者使用魔术分区助手搞一点复杂的分区或格式化操作。</p><a id="more"></a><p>而 linux 系统下，无论是申请的开发机，还是购买的服务器，硬盘都是挂载好的，至今没有遇到需要手动挂载的情况，所以对这个命令并不是很熟悉，今天决定抽时间学一下，总结一下设备相关的知识，特别是磁盘相关的操作。</p><h1 id="文件类型"><a href="#文件类型" class="headerlink" title="文件类型"></a>文件类型</h1><p>“Everything is a file”（一切皆文件）是 linux 中的特点，所以在学习磁盘、设备之前先来看看文件类型，在 linux 并不通过后缀名来判断文件类型的，可以利用 <code>ll</code> （或 <code>ls -l</code>）命令可以列举指定目录下的内容，通过每一行的首个字母就可以判断出文件的大类型：</p><ul><li>-rw-r-r-：<code>-</code>开头的都普通文件</li><li>brw-r-r-：<code>b</code>开头的是块设备文件</li><li>crw-r-r-：<code>c</code>开头的是字符设备文件</li><li>drw-r-r-：<code>d</code>开头的是目录文件</li><li>lrw-r-r-：<code>l</code>开头的是软链接文件，也叫符号链接</li><li>prw-r-r-：<code>p</code>开头的是管道文件</li><li>srw-r-r-：<code>s</code>开头的是socket文件</li></ul><p>我们可以查一下CentOS系统设备目录 <code>dev</code>，这里的文件类型非常丰富，由于内容非常多，这里只展示一部分内容：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-0-3-centos ~]<span class="comment"># ll /dev</span></span><br><span class="line">total 0</span><br><span class="line">crw------- 1 root root     10, 235 Feb  9 11:13 autofs</span><br><span class="line">drwxr-xr-x 2 root root         120 Feb  9 11:13 block</span><br><span class="line">drwxr-xr-x 2 root root          60 Feb  9 11:13 bsg</span><br><span class="line">crw------- 1 root root     10, 234 Feb  9 11:13 btrfs-control</span><br><span class="line">drwxr-xr-x 3 root root          60 Feb  9 11:13 bus</span><br><span class="line">lrwxrwxrwx 1 root root           3 Feb  9 11:13 cdrom -&gt; sr0</span><br><span class="line">drwxr-xr-x 2 root root        2560 Feb  9 11:13 char</span><br><span class="line">crw------- 1 root root      5,   1 Feb  9 11:13 console</span><br><span class="line">lrwxrwxrwx 1 root root          11 Feb  9 11:13 core -&gt; /proc/kcore</span><br><span class="line">drwxr-xr-x 3 root root          60 Feb  9 11:13 cpu</span><br><span class="line">crw------- 1 root root     10,  61 Feb  9 11:13 cpu_dma_latency</span><br><span class="line">crw------- 1 root root     10,  62 Feb  9 11:13 crash</span><br><span class="line">drwxr-xr-x 6 root root         120 Feb  9 11:13 disk</span><br><span class="line">drwxr-xr-x 2 root root          60 Feb  9 11:13 dri</span><br><span class="line">crw-rw---- 1 root video    29,   0 Feb  9 11:13 fb0</span><br><span class="line">lrwxrwxrwx 1 root root          13 Feb  9 11:13 fd -&gt; /proc/self/fd</span><br><span class="line">crw-rw-rw- 1 root root      1,   7 Feb  9 11:13 full</span><br><span class="line">crw-rw-rw- 1 root root     10, 229 Feb  9 11:13 fuse</span><br><span class="line">crw------- 1 root root     10, 228 Feb  9 11:13 hpet</span><br><span class="line">drwxr-xr-x 2 root root           0 Feb  9 11:13 hugepages</span><br><span class="line">crw------- 1 root root     10, 183 Feb  9 11:13 hwrng</span><br><span class="line">lrwxrwxrwx 1 root root          25 Feb  9 11:13 initctl -&gt; /run/systemd/initctl/fifo</span><br><span class="line">drwxr-xr-x 3 root root         240 Feb  9 11:13 input</span><br><span class="line">crw-r--r-- 1 root root      1,  11 Feb  9 11:13 kmsg</span><br><span class="line">srw-rw-rw- 1 root root           0 Feb  9 11:13 <span class="built_in">log</span></span><br></pre></td></tr></table></figure><p>其实还有一个更精准的，专门用来查询文件类型的命令，那就是 <code>file</code> 命令，下面可以测试一下，执行后会输出关于文件类型的描述：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-0-3-centos ~]<span class="comment"># ll</span></span><br><span class="line">total 12</span><br><span class="line">-rwxr-xr-x 1 root root   67 Feb  9 13:44 connecttendis.sh</span><br><span class="line">drwxr-xr-x 2 root root 4096 Feb  9 13:44 tarlist</span><br><span class="line">drwxr-xr-x 4 root root 4096 Feb  9 13:40 tendis</span><br><span class="line">[root@VM-0-3-centos ~]<span class="comment"># file connecttendis.sh</span></span><br><span class="line">connecttendis.sh: Bourne-Again shell script, ASCII text executable</span><br><span class="line">[root@VM-0-3-centos ~]<span class="comment"># file tendis/</span></span><br><span class="line">tendis/: directory</span><br></pre></td></tr></table></figure><p>描述展示说明 connecttendis.sh 是一个 shell 脚本，而 tendis/ 是一个目录。</p><h1 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h1><p>说完文件类型还得说说文件系统，什么是文件系统，其实从名字就可以看出来，文件系统就是管文件的呗，不同的文件系统所支持的最大容量、对单个文件的大小限制、存取性能、是否可压缩、是否提供校验等都是不太一样的，当我们做系统或者烧制U盘、格式化硬盘时常常提到文件系统这个词。</p><p>在 Windows 中常用的文件系统有 <code>FAT16</code>、<code>FAT32</code>、<code>NTFS</code>、<code>exFAT</code> 等，而 Linux 中常用的文件系统有 <code>ext2</code>、<code>ext3</code>、<code>ext4</code>、<code>tmpfs</code>、<code>proc</code> 等，这些文件系统无需全部记住，在 Linux 上可以通过查看 <code>/proc/filesystems</code> 文件得知当前系统都支持哪些文件系统。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-0-3-centos ~]<span class="comment"># cat /proc/filesystems</span></span><br><span class="line">nodev   sysfs</span><br><span class="line">nodev   rootfs</span><br><span class="line">nodev   ramfs</span><br><span class="line">nodev   bdev</span><br><span class="line">nodev   proc</span><br><span class="line">nodev   cgroup</span><br><span class="line">nodev   cpuset</span><br><span class="line">nodev   tmpfs</span><br><span class="line">nodev   devtmpfs</span><br><span class="line">nodev   debugfs</span><br><span class="line">nodev   securityfs</span><br><span class="line">nodev   sockfs</span><br><span class="line">nodev   dax</span><br><span class="line">nodev   bpf</span><br><span class="line">nodev   pipefs</span><br><span class="line">nodev   configfs</span><br><span class="line">nodev   devpts</span><br><span class="line">nodev   hugetlbfs</span><br><span class="line">nodev   autofs</span><br><span class="line">nodev   pstore</span><br><span class="line">nodev   mqueue</span><br><span class="line">        ext3</span><br><span class="line">        ext2</span><br><span class="line">        ext4</span><br><span class="line">        iso9660</span><br><span class="line">nodev   binfmt_misc</span><br></pre></td></tr></table></figure><p>观察上述结果，第一列为空的文件系统需要挂载到块设备上才能访问其中的内容，之后才可以正常使用。</p><h1 id="挂载硬盘"><a href="#挂载硬盘" class="headerlink" title="挂载硬盘"></a>挂载硬盘</h1><p>Windows 中的目录是分盘符的，每个分区可以指定一个盘符，每个盘符就是这个分区的根，可以通过各个盘符依次向下访问其中的内容。在 Linux 中是没有盘符概念的，只有一个根目录 <code>/</code>，只存在一棵完整的目录树，硬盘设备需要挂载到这棵目录树上才能被正常使用。</p><p>我们知道 <code>/dev</code> 目录下存放着几乎所有的设备文件，从中就可以找到硬盘设备：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-0-3-centos ~]<span class="comment"># ll /dev/ | grep disk</span></span><br><span class="line">drwxr-xr-x 6 root root         120 Feb  9 11:13 disk</span><br><span class="line">brw-rw---- 1 root disk      7,   0 Feb  9 11:13 loop0</span><br><span class="line">crw-rw---- 1 root disk     10, 237 Feb  9 11:13 loop-control</span><br><span class="line">brw-rw---- 1 root disk    253,   0 Feb  9 11:13 vda</span><br><span class="line">brw-rw---- 1 root disk    253,   1 Feb  9 11:13 vda1</span><br></pre></td></tr></table></figure><p>从命令结果可以看出，这台计算机只有一块普通硬盘 <code>vda</code>，硬盘只有一个分区 <code>vda1</code>，这是目前一种通用的命名方式，<code>hd</code> 是指IDE接口的硬盘，<code>sd</code> 是指SATA接口的硬盘、<code>vd</code> 指 virtio 磁盘，现在的内核一般都会把硬盘，移动硬盘，U盘等识别为sdX的形式，第一块硬盘使用 <code>a</code> 作为后缀，例如 <code>sda</code>，后面的硬盘依次命名为 <code>sdb</code>、<code>sdc</code> 等，硬盘的第一个分区后缀为1，后面分区号依次递增。</p><h2 id="查硬盘分区"><a href="#查硬盘分区" class="headerlink" title="查硬盘分区"></a>查硬盘分区</h2><p>硬盘作为一种设备可以在 <code>/dev</code> 目录下查询，但是可以通过 <code>fdisk</code> 做更细致的查询</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-0-3-centos dev]<span class="comment"># fdisk -l</span></span><br><span class="line"></span><br><span class="line">Disk /dev/vda: 53.7 GB, 53687091200 bytes, 104857600 sectors</span><br><span class="line">Units = sectors of 1 * 512 = 512 bytes</span><br><span class="line">Sector size (logical/physical): 512 bytes / 512 bytes</span><br><span class="line">I/O size (minimum/optimal): 512 bytes / 512 bytes</span><br><span class="line">Disk label <span class="built_in">type</span>: dos</span><br><span class="line">Disk identifier: 0x000d64b4</span><br><span class="line"></span><br><span class="line">   Device Boot      Start         End      Blocks   Id  System</span><br><span class="line">/dev/vda1   *        2048   104857566    52427759+  83  Linux</span><br></pre></td></tr></table></figure><p>通过 <code>fdisk -l</code> 命令查询出的结果与 <code>/dev</code> 目录下查到的信息一致</p><h2 id="查看当前挂载的文件系统"><a href="#查看当前挂载的文件系统" class="headerlink" title="查看当前挂载的文件系统"></a>查看当前挂载的文件系统</h2><p>查看当前挂载的所有文件系统只需要一个 <code>mount</code> 命令就够了，也可以加 <code>-t tmpfs</code> 参数查看指定类型</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-0-3-centos ~]<span class="comment"># mount</span></span><br><span class="line">sysfs on /sys <span class="built_in">type</span> sysfs (rw,relatime)</span><br><span class="line">proc on /proc <span class="built_in">type</span> proc (rw,relatime)</span><br><span class="line">devtmpfs on /dev <span class="built_in">type</span> devtmpfs (rw,nosuid,size=930496k,nr_inodes=232624,mode=755)</span><br><span class="line">securityfs on /sys/kernel/security <span class="built_in">type</span> securityfs (rw,nosuid,nodev,noexec,relatime)</span><br><span class="line">tmpfs on /dev/shm <span class="built_in">type</span> tmpfs (rw,nosuid,nodev)</span><br><span class="line">devpts on /dev/pts <span class="built_in">type</span> devpts (rw,relatime,gid=5,mode=620,ptmxmode=000)</span><br><span class="line">tmpfs on /run <span class="built_in">type</span> tmpfs (rw,nosuid,nodev,mode=755)</span><br><span class="line">tmpfs on /sys/fs/cgroup <span class="built_in">type</span> tmpfs (ro,nosuid,nodev,noexec,mode=755)</span><br><span class="line">...</span><br><span class="line">cgroup on /sys/fs/cgroup/freezer <span class="built_in">type</span> cgroup (rw,nosuid,nodev,noexec,relatime,freezer)</span><br><span class="line">configfs on /sys/kernel/config <span class="built_in">type</span> configfs (rw,relatime)</span><br><span class="line">/dev/vda1 on / <span class="built_in">type</span> ext4 (rw,noatime,data=ordered)</span><br><span class="line">debugfs on /sys/kernel/debug <span class="built_in">type</span> debugfs (rw,relatime)</span><br><span class="line">hugetlbfs on /dev/hugepages <span class="built_in">type</span> hugetlbfs (rw,relatime)</span><br><span class="line">mqueue on /dev/mqueue <span class="built_in">type</span> mqueue (rw,relatime)</span><br><span class="line">tmpfs on /run/user/0 <span class="built_in">type</span> tmpfs (rw,nosuid,nodev,relatime,size=188204k,mode=700)</span><br><span class="line">binfmt_misc on /proc/sys/fs/binfmt_misc <span class="built_in">type</span> binfmt_misc (rw,relatime)</span><br></pre></td></tr></table></figure><p>输出每一行格式一致，均包含6列内容，通过空格来分割，具体形式为：</p><blockquote><p>&lt;块设备或者其他文件系统&gt; on &lt;挂载目录&gt; type &lt;文件系统类型&gt; &lt;(与文件系统内容相关的选项)&gt;</p></blockquote><p>以 ‘/dev/vda1 on / type ext4 (rw,noatime,data=ordered)’ 这一行为例，就表示 <code>/dev/vda</code> 这个硬盘的第一个分区挂载到了一个 类型为 <code>ext4</code> 的文件系统上，挂载点是根目录 <code>/</code>，括号中的 <code>rw</code> 表示可读写，<code>data=ordered</code> 表示有序，<code>relatime</code> 是一种更新文件访问时间属性的一种方式，此外还有 <code>noatime</code> 和 <code>lazytime</code> 类型，这一块内容也比较多，此处就不展开了，有兴趣可以转到 <a href="https://www.cnblogs.com/honpey/p/6637848.html" target="_blank" rel="noopener">《文件系统中 atime,lazytime,relatime 详聊》</a> 这篇文章中了解一下。</p><h2 id="格式化磁盘分区"><a href="#格式化磁盘分区" class="headerlink" title="格式化磁盘分区"></a>格式化磁盘分区</h2><p>使用 <code>mkfs</code> 可以格式化一个磁盘分区，格式化的同时可以修改文件系统的类型</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-0-3-centos ~]<span class="comment"># mkfs -t ext4 /dev/sda2</span></span><br></pre></td></tr></table></figure><h2 id="挂载新的磁盘分区"><a href="#挂载新的磁盘分区" class="headerlink" title="挂载新的磁盘分区"></a>挂载新的磁盘分区</h2><p>使用 <code>mount</code> 命令可以将新的磁盘分区挂载到目录树上</p><h3 id="普通挂载"><a href="#普通挂载" class="headerlink" title="普通挂载"></a>普通挂载</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-0-3-centos ~]<span class="comment"># mkdir -p /mnt/data</span></span><br><span class="line">[root@VM-0-3-centos ~]<span class="comment"># mount /dev/sda2 /mnt/data</span></span><br></pre></td></tr></table></figure><h3 id="以只读方式挂载"><a href="#以只读方式挂载" class="headerlink" title="以只读方式挂载"></a>以只读方式挂载</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-0-3-centos ~]<span class="comment"># mount -o ro /dev/sda2 /mnt/data</span></span><br></pre></td></tr></table></figure><h3 id="只读挂载改为读写模式"><a href="#只读挂载改为读写模式" class="headerlink" title="只读挂载改为读写模式"></a>只读挂载改为读写模式</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-0-3-centos ~]<span class="comment"># mount /mnt/data -o rw,remount</span></span><br></pre></td></tr></table></figure><h2 id="挂载光驱"><a href="#挂载光驱" class="headerlink" title="挂载光驱"></a>挂载光驱</h2><p>挂载光驱的方式与挂载硬盘是一样的，只不过光驱是单独的设备，对应着不同的文件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-0-3-centos ~]<span class="comment"># mount /dev/cdrom /media/cdrom</span></span><br></pre></td></tr></table></figure><h2 id="挂载-windows-共享文件"><a href="#挂载-windows-共享文件" class="headerlink" title="挂载 windows 共享文件"></a>挂载 windows 共享文件</h2><p>挂载 windows 共享文件时需要用到 windows 计算机的IP、用户名和密码</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-0-3-centos ~]<span class="comment"># mkdir -p /mnt/share</span></span><br><span class="line">[root@VM-0-3-centos ~]<span class="comment"># mount -t cifs -o username=admin,password=94741 //10.2.49.172/share /mnt/share</span></span><br></pre></td></tr></table></figure><h2 id="挂载-ios-文件"><a href="#挂载-ios-文件" class="headerlink" title="挂载 ios 文件"></a>挂载 ios 文件</h2><p>直接挂载 iso 文件就不需要光驱了，使用起来更加方便，先模拟创建一个 iso 文件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-0-3-centos ~]<span class="comment"># genisoimage -o test.iso tendis/</span></span><br><span class="line">I: -input-charset not specified, using utf-8 (detected <span class="keyword">in</span> locale settings)</span><br><span class="line">Using TENDI000.;1 <span class="keyword">for</span>  tendis/bin/tendisplus (tendisplus_static)</span><br><span class="line">  2.77% <span class="keyword">done</span>, estimate finish Sat Feb 27 23:03:08 2021</span><br><span class="line">  5.53% <span class="keyword">done</span>, estimate finish Sat Feb 27 23:03:08 2021</span><br><span class="line">  8.30% <span class="keyword">done</span>, estimate finish Sat Feb 27 23:03:08 2021</span><br><span class="line">...</span><br><span class="line"> 49.78% <span class="keyword">done</span>, estimate finish Sat Feb 27 23:03:10 2021</span><br><span class="line">...</span><br><span class="line"> 99.55% <span class="keyword">done</span>, estimate finish Sat Feb 27 23:03:11 2021</span><br><span class="line">Total translation table size: 0</span><br><span class="line">Total rockridge attributes bytes: 0</span><br><span class="line">Total directory bytes: 6144</span><br><span class="line">Path table size(bytes): 50</span><br><span class="line">Max brk space used 1a000</span><br><span class="line">180825 extents written (353 MB)</span><br></pre></td></tr></table></figure><p>把 iso 直接挂载到目录就可以了，之后就可以通过 <code>/mnt/iso</code> 目录访问 test.iso 文件中的内容了</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-0-3-centos ~]<span class="comment"># mkdir -p /mnt/iso</span></span><br><span class="line">[root@VM-0-3-centos ~]<span class="comment"># mount test.iso /mnt/iso</span></span><br><span class="line">mount: /dev/loop0 is write-protected, mounting <span class="built_in">read</span>-only</span><br></pre></td></tr></table></figure><h1 id="计算机设备中的概念"><a href="#计算机设备中的概念" class="headerlink" title="计算机设备中的概念"></a>计算机设备中的概念</h1><p>计算机科学中的概念有很多，常常记不清或者记混它们的内容，比如扇区、块、簇、页等，每次看完过后就忘记了，在此简单总结一下。</p><h2 id="扇区"><a href="#扇区" class="headerlink" title="扇区"></a>扇区</h2><p>硬盘的读写以扇区为基本单位，属于物理层面的概念，操作系统是不直接与扇区交互的，可以通过 <code>fdisk -l</code> 查看扇区大小</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-0-3-centos dev]<span class="comment"># fdisk -l</span></span><br><span class="line"></span><br><span class="line">Disk /dev/vda: 53.7 GB, 53687091200 bytes, 104857600 sectors</span><br><span class="line">Units = sectors of 1 * 512 = 512 bytes</span><br><span class="line">Sector size (logical/physical): 512 bytes / 512 bytes</span><br><span class="line">I/O size (minimum/optimal): 512 bytes / 512 bytes</span><br><span class="line">Disk label <span class="built_in">type</span>: dos</span><br><span class="line">Disk identifier: 0x000d64b4</span><br><span class="line"></span><br><span class="line">   Device Boot      Start         End      Blocks   Id  System</span><br><span class="line">/dev/vda1   *        2048   104857566    52427759+  83  Linux</span><br></pre></td></tr></table></figure><p>其中 Sector size，就表示扇区大小，从结果来看还分逻辑扇区和物理扇区，不过本例中为均为 512 bytes。</p><h2 id="块、簇"><a href="#块、簇" class="headerlink" title="块、簇"></a>块、簇</h2><p>块和簇其实是一种东西，通常 linux 系统叫做块，而 windows 系统叫做簇，它是文件系统读写数据的最小单位，每个磁盘块可以包括相邻的 2、4、8、16、32 或 64 个扇区，是操作系统所使用的逻辑概念，可以通过命令 <code>stat /boot</code> 来查看</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-0-3-centos mnt]<span class="comment"># stat /boot</span></span><br><span class="line">  File: ‘/boot’</span><br><span class="line">  Size: 4096        Blocks: 8          IO Block: 4096   directory</span><br><span class="line">Device: fd01h/64769d    Inode: 18          Links: 5</span><br><span class="line">Access: (0555/dr-xr-xr-x)  Uid: (    0/    root)   Gid: (    0/    root)</span><br><span class="line">Access: 2018-08-08 11:20:35.109000000 +0800</span><br><span class="line">Modify: 2021-02-09 11:14:21.799238058 +0800</span><br><span class="line">Change: 2021-02-09 11:14:21.799238058 +0800</span><br><span class="line"> Birth: -</span><br></pre></td></tr></table></figure><p>结果中 IO Block 就是磁盘块大小 4096 Bytes，也就是 4K，这样将相邻扇区合并为块来存取数据是为了更高效地、更好地管理磁盘空间。操作系统规定一个磁盘块中只能放置一个文件，这就会造成空间的浪费，那就意味着大多数情况会出现文件所占用的磁盘空间大于文件大小的情况。</p><h2 id="页"><a href="#页" class="headerlink" title="页"></a>页</h2><p>这是一个内存相关的概念，是内存的最小存储单位。它大小通常为磁盘块大小的 $2^n$ 倍，可以通过命令 <code>getconf PAGE_SIZE</code> 来获取页的大小</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-0-3-centos mnt]<span class="comment"># getconf PAGE_SIZE</span></span><br><span class="line">4096</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li><code>mount</code> 是 linux 系统中非常重要的一个命令，但是我感觉用的比较少</li><li>系统新挂载的硬盘关机后会被卸载，可以将挂载信息添加到 <code>/etc/fstab</code> 文件实现开机后自动挂载</li><li>可以把多个设备挂载到同一个目录，默认后面挂载的内容会隐藏前面挂载的内容，卸载后面的挂载，前面挂载的内容还会出现</li><li>可以把同一个设备挂载到不同的目录，并在挂载时可以指定不同的权限，这样在不同的目录中看到的是同样的内容，但是权限不同</li><li>扇区是硬盘的读写的基本单位，属于物理概念</li><li>块/簇是操作系统读写数据的基本单位，属于逻辑概念</li><li>页是内存的最小存储单位，通常为磁盘块大小的 $2^n$ 倍</li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/113907051" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>万里山河都踏过 天下又入谁手 分分合合 不过几十载春秋~</p><p>“你在教我做事啊”</p><p>2021-2-27 23:41:34</p></blockquote><!--https://www.cnblogs.com/sparkdev/p/9015312.htmlhttps://zhuanlan.zhihu.com/p/117375905 -->]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;linux 环境下的 &lt;code&gt;mount&lt;/code&gt; 命令可以挂载一个文件系统，这个命令目前是我所知命令中最陌生的一个，至今没有使用过，真的一次都没有挂载过，平时用的最多是的 Windwos 系统，完全不需要挂载，安装新硬盘自动就会出现盘符，稍微复杂点就是通过磁盘管理器来分区，或者使用魔术分区助手搞一点复杂的分区或格式化操作。&lt;/p&gt;
    
    </summary>
    
      <category term="linux" scheme="http://AlbertGithubHome.github.io/blog/categories/linux/"/>
    
    
      <category term="linux" scheme="http://AlbertGithubHome.github.io/blog/tags/linux/"/>
    
      <category term="mount" scheme="http://AlbertGithubHome.github.io/blog/tags/mount/"/>
    
      <category term="unmount" scheme="http://AlbertGithubHome.github.io/blog/tags/unmount/"/>
    
      <category term="挂载" scheme="http://AlbertGithubHome.github.io/blog/tags/%E6%8C%82%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>Go环境配置时遇到的GOPATH路径以及包管理问题</title>
    <link href="http://AlbertGithubHome.github.io/blog/2021/02/19/Go%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E6%97%B6%E9%81%87%E5%88%B0%E7%9A%84GOPATH%E8%B7%AF%E5%BE%84%E4%BB%A5%E5%8F%8A%E5%8C%85%E7%AE%A1%E7%90%86%E9%97%AE%E9%A2%98/"/>
    <id>http://AlbertGithubHome.github.io/blog/2021/02/19/Go环境配置时遇到的GOPATH路径以及包管理问题/</id>
    <published>2021-02-19T14:39:19.000Z</published>
    <updated>2021-02-21T15:29:58.021Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>过了个年回到工作岗位，发现之前好好的 <code>Go</code> 环境无法进行调试了，于是又重新配置了一次，弄好之后的新参数与原来有一些不一样的地方，甚至还有一些矛盾的地方，真搞不清楚原来的配置参数怎么能成功调试的，也是奇了怪了。配置过程中还遇到了一些问题，特别记录一下，防止今后遇到类似问题还要苦苦寻找。</p><a id="more"></a><h1 id="Go-的环境变量"><a href="#Go-的环境变量" class="headerlink" title="Go 的环境变量"></a>Go 的环境变量</h1><p>说起环境变量，写 <code>Java</code> 的时候倒是配置了不少，一般都需要配置 <code>JAVA_HOME</code> 和 <code>CLASSPATH</code>，后来 C/C++ 写的比较多，完全不需要这个东西，直接使用 <code>include</code> 把绝对路径或者相对路径引用进来就可以，或者使用VS的项目属性界面配置包含路径，也可以将包含路径写在 <code>CMakeLists.txt</code> 中。但是为了能找到和使用各种工具和软件，它们所在的路径一般会加到环境变量<code>Path</code>中。</p><p><code>Go</code> 中也有两个环境变量非常重要，它们分别是 <code>GOROOT</code> 和 <code>GOPATH</code>，其中 <code>GOROOT</code> 比较好理解，就是 <code>Go</code> 软件安装的目录，可以类比一下 <code>JAVA_HOME/bin</code>，而 <code>GOPATH</code> 就是一个神奇的存在，在go1.12版本之前，<code>Go</code> 语言编写的项目代码和下载的包都必须在 <code>GOPATH</code> 目录下，想像一下，在一个 <code>GOPATH</code> 目录下无数个项目go文件，那感觉真是酸爽。</p><h1 id="GOPATH-的设计"><a href="#GOPATH-的设计" class="headerlink" title="GOPATH 的设计"></a>GOPATH 的设计</h1><p><code>GOPATH</code>设计的出发点是好的，将代码包统一存储到一个目录下，直接引用包名就可以了，可是这样设计也缺少了自由，下载的第三方包和自己的项目文件混在一起虽然可以方便查看代码，但是结构看起来确实很乱。</p><p>什么？你说 <code>GOPATH</code> 可以指定多个目录，确实很多资料说 <code>GOPATH</code> 支持多个目录，下载的包会默认放在 <code>GOPATH</code> 指定的第一个目录下，需要注意的一个点是在windows下指定多个目录需要用分号分隔，而Linux下指定多个目录需要用冒号分隔，并且指定的目录需要是用绝对路径，如果指定的目录中包含相对路径，会报一个 <code>go: GOPATH entry is relative; must be absolute path: &quot;...</code> 错误，记得 <code>GOPATH</code> 变量末尾不要加 <code>:</code> 或者 <code>;</code>。</p><p>春节前我就是配置的多个目录，本来调试用的好好的，结果过完年现在不让用了，一调试就会报错 <code>unexpected directory layout:</code>，具体的报错内容结构如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">unexpected directory layout:</span><br><span class="line">        import path: _/go/src/firstgo</span><br><span class="line">        root: /go/src</span><br><span class="line">        dir: /go/src/firstgo</span><br><span class="line">        expand root: /go</span><br><span class="line">        expand dir: /go/src/firstgo</span><br><span class="line">        separator: /</span><br></pre></td></tr></table></figure><p>后来参考了下面两篇文章，把 <code>GOPATH</code> 改成单一目录就好了。</p><ul><li><a href="https://www.gitmemory.com/issue/golang/go/33752/523826861" target="_blank" rel="noopener">cmd/go: unexpected directory layout while building project</a></li><li><a href="https://www.jianshu.com/p/b226e1433bab" target="_blank" rel="noopener">go get 报错 unexpected directory layout</a></li></ul><p>也就是在linux下的 <code>~/.profile</code> 文件中把 <code>export GOPATH=/home/albert/go:/home/albert/WorkSpace/go</code> 改成 <code>export GOPATH=/home/albert/go</code> 就可以了。</p><h1 id="GOPATH-的发展"><a href="#GOPATH-的发展" class="headerlink" title="GOPATH 的发展"></a>GOPATH 的发展</h1><p>早期版本的 <code>GOPATH</code> 设计所有包下载到指定的目录，并且没有版本号，如果多个项目引用的同一个包的不同版本那就歇菜了，所以说这时的 <code>Go</code> 管理仅仅处于能用的状态，也就相当于一个下载器，达不到软件包管理器的及格水平，后来出现了一些例如 <code>dep</code>、<code>Godep</code> 的包管理工具，均属于官方推荐的第三方管理工具，都非 <code>Go</code> 语言自带。</p><p><code>Go</code> 的包管理工具并不像 Python 的 pip，或者 JS 的 npm 那样统一，本质上还是设计不同导致的，<code>Go</code> 想做的包管理是一种分布式的，没有Python 或者 JS 那种中心仓库，这样又带来了一个弊端，如果包的提供者频繁提交新版本怎么办，所以在包管理的工作中，版本号是必须要存在的。</p><p>关于之前GO项目为什么非要放在 <code>GOPATH</code> 下，以及 GO的包管理发展历程可以参考下面文章：</p><ul><li><a href="https://juejin.cn/post/6844903849916907534" target="_blank" rel="noopener">GO问答之为什么项目要在 GOPATH/src 目录下</a></li><li><a href="https://www.infoq.cn/article/history-go-package-management" target="_blank" rel="noopener">Go 包管理的前世今生</a></li></ul><p>直到 <code>go mod</code> 出现以后，在<code>Go</code> 中引入第三方模块算是方便了不少，参考<a href="https://segmentfault.com/a/1190000018690961" target="_blank" rel="noopener">《拜拜了，GOPATH君！新版本Golang的包管理入门教程》</a></p><ul><li><a href="https://www.jianshu.com/p/760c97ff644c" target="_blank" rel="noopener">go mod使用</a></li><li><a href="https://segmentfault.com/q/1010000020696591#" target="_blank" rel="noopener">go mod 怎么导入本地其它项目的包？</a></li><li><a href="https://studygolang.com/articles/25658" target="_blank" rel="noopener">谈谈go.sum</a></li></ul><h1 id="Go-的常用命令"><a href="#Go-的常用命令" class="headerlink" title="Go 的常用命令"></a>Go 的常用命令</h1><p><code>Go</code> 作为一种语言，同时也代表了一系列工具和生态环境，它的命令有不少，下面列举一些常见的：</p><ul><li><strong>go env</strong>: 打印go的环境信息</li><li><strong>go fmt</strong>: 运行gofmt对go代码进行格式化</li><li><strong>go build</strong>: 编译包和依赖</li><li><strong>go run</strong>: 编译并运行go程序</li><li><strong>go version</strong>: 显示go程序的版本</li><li><strong>go help</strong>: 打印命令的帮助信息</li><li><strong>go get</strong>: 下载并安装包和依赖（-v 显示操作流程的日志及信息；-u 下载丢失的包，但不会更新已经存在的包）</li></ul><p>其中 <code>go help</code> 不仅仅打印了这些命令的基本信息，还可以打印出一些概念的帮助信息， 例如 <code>go help gopath</code>，内容比较多，下面只列举一小部分:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">Here<span class="string">'s an example directory layout:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    GOPATH=/home/user/go</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    /home/user/go/</span></span><br><span class="line"><span class="string">        src/</span></span><br><span class="line"><span class="string">            foo/</span></span><br><span class="line"><span class="string">                bar/               (go code in package bar)</span></span><br><span class="line"><span class="string">                    x.go</span></span><br><span class="line"><span class="string">                quux/              (go code in package main)</span></span><br><span class="line"><span class="string">                    y.go</span></span><br><span class="line"><span class="string">        bin/</span></span><br><span class="line"><span class="string">            quux                   (installed command)</span></span><br><span class="line"><span class="string">        pkg/</span></span><br><span class="line"><span class="string">            linux_amd64/</span></span><br><span class="line"><span class="string">                foo/</span></span><br><span class="line"><span class="string">                    bar.a          (installed package object)</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="string">...</span></span><br></pre></td></tr></table></figure><p>运行 <code>go env</code> 展示一下当前使用的环境，方便以后做个对照：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">$ go env</span><br><span class="line">GO111MODULE=<span class="string">""</span></span><br><span class="line">GOARCH=<span class="string">"amd64"</span></span><br><span class="line">GOBIN=<span class="string">""</span></span><br><span class="line">GOCACHE=<span class="string">"/home/albert/.cache/go-build"</span></span><br><span class="line">GOENV=<span class="string">"/home/albert/.config/go/env"</span></span><br><span class="line">GOEXE=<span class="string">""</span></span><br><span class="line">GOFLAGS=<span class="string">""</span></span><br><span class="line">GOHOSTARCH=<span class="string">"amd64"</span></span><br><span class="line">GOHOSTOS=<span class="string">"linux"</span></span><br><span class="line">GOINSECURE=<span class="string">""</span></span><br><span class="line">GOMODCACHE=<span class="string">"/home/albert/WorkSpace/go1/pkg/mod"</span></span><br><span class="line">GONOPROXY=<span class="string">""</span></span><br><span class="line">GONOSUMDB=<span class="string">""</span></span><br><span class="line">GOOS=<span class="string">"linux"</span></span><br><span class="line">GOPATH=<span class="string">"/home/albert/WorkSpace/go1"</span></span><br><span class="line">GOPRIVATE=<span class="string">""</span></span><br><span class="line">GOPROXY=<span class="string">"https://proxy.golang.org,direct"</span></span><br><span class="line">GOROOT=<span class="string">"/usr/local/go"</span></span><br><span class="line">GOSUMDB=<span class="string">"sum.golang.org"</span></span><br><span class="line">GOTMPDIR=<span class="string">""</span></span><br><span class="line">GOTOOLDIR=<span class="string">"/usr/local/go/pkg/tool/linux_amd64"</span></span><br><span class="line">GCCGO=<span class="string">"gccgo"</span></span><br><span class="line">AR=<span class="string">"ar"</span></span><br><span class="line">CC=<span class="string">"gcc"</span></span><br><span class="line">CXX=<span class="string">"g++"</span></span><br><span class="line">CGO_ENABLED=<span class="string">"1"</span></span><br><span class="line">GOMOD=<span class="string">""</span></span><br><span class="line">CGO_CFLAGS=<span class="string">"-g -O2"</span></span><br><span class="line">CGO_CPPFLAGS=<span class="string">""</span></span><br><span class="line">CGO_CXXFLAGS=<span class="string">"-g -O2"</span></span><br><span class="line">CGO_FFLAGS=<span class="string">"-g -O2"</span></span><br><span class="line">CGO_LDFLAGS=<span class="string">"-g -O2"</span></span><br><span class="line">PKG_CONFIG=<span class="string">"pkg-config"</span></span><br><span class="line">GOGCCFLAGS=<span class="string">"-fPIC -m64 -pthread -fmessage-length=0</span></span><br><span class="line"><span class="string">    -fdebug-prefix-map=/tmp/go-build602227063=/tmp/go-build -gno-record-gcc-switches"</span></span><br></pre></td></tr></table></figure><h1 id="VSCode-Remote-时修改的环境变量不生效"><a href="#VSCode-Remote-时修改的环境变量不生效" class="headerlink" title="VSCode Remote 时修改的环境变量不生效"></a>VSCode Remote 时修改的环境变量不生效</h1><p>这个问题也是在这次配置 <code>Go</code> 调试环境时遇到的，我是在 <code>~/.profile</code> 文件中修改的 <code>GOPATH</code>的内容，但是在VSCode中调试时就是报错，其表现就跟修改的变量未生效一致，后来查资料发现，原来出现这种情况和配置文件的加载顺序有关，具体参考下列文章：</p><ul><li><a href="https://debug.fanzheng.org/post/vscode-remote-env-loading-sequel.html" target="_blank" rel="noopener">VSCode Remote环境变量加载——续</a></li><li><a href="https://github.com/microsoft/vscode-remote-release/issues/83" target="_blank" rel="noopener">remote-ssh: .profile not sourced for bash shells, only .bashrc? #83</a></li><li><a href="https://unix.stackexchange.com/questions/50665/what-is-the-difference-between-interactive-shells-login-shells-non-login-shell" target="_blank" rel="noopener">What is the difference between interactive shells, login shells, non-login shell and their use cases?</a></li></ul><p>其实在linux中的shell有 <code>interactive shell</code>、 <code>non-interactive shell</code>、 <code>login shell</code>、 <code>non-login shell</code> 的区分，每种情况下调用的初始化脚本不同，涉及到 <code>/etc/profile</code>、<code>~/.bash_profile</code> <code>~/.bash_login /</code> <code>~/.profile</code>等等，而在VSCode远程连接Linux时还会继承之前的环境，多次尝试之后还是不起效果，此时不得不高呼“重启大法好”，重启能解决80%的问题，剩下的20%只能靠重做系统来解决了。</p><p>在我这修改脚本内容不生效，脚本间调用还搞出了死循环的问题，不知道是不是因为我使用 <code>zsh</code> 这个 <code>shell</code>作为默认环境出的问题，但重启大法依然奏效，电脑重启后环境变量成功修改了。</p><h1 id="C-的包管理器"><a href="#C-的包管理器" class="headerlink" title="C++ 的包管理器"></a>C++ 的包管理器</h1><p>捣鼓这么久 <code>Go</code>，突然想到一个问题，<code>C++</code> 有没有包管理器呢？答案是有的，并且有很多，但是都存在着这样或那样的问题，可以重点看一下 <code>conan</code>，具体使用可以搜索官网，或者看看下面这些总结。</p><ul><li><a href="http://chu-studio.com/posts/2019/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84C++%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8CONAN%E4%B8%8A%E6%89%8B%E6%8C%87%E5%8D%97" target="_blank" rel="noopener">从零开始的C++包管理器CONAN上手指南</a></li><li><a href="https://www.cnblogs.com/xl2432/p/11873394.html" target="_blank" rel="noopener">conan使用(一)–安装和应用</a></li></ul><p><code>conan</code> 是一款使用 <code>python</code> 开发的包管理工具，所以需要依赖 <code>Python</code> 环境，CentOS 平台上安装 Python 环境可以参考 <a href="https://zhuanlan.zhihu.com/p/47508850" target="_blank" rel="noopener">Centos安装python3.6和pip步骤记录</a>，虽然CentOS即将被放弃，但是目前在各种云服务器上依旧是主流系统，安装 Python 环境时需要注意一步步跟着做，最好不要投机取巧，我就是因为少安装了一个依赖，导致我使用 <code>pip install conan</code>命令安装 <code>conan</code> 是报错 <code>ModuleNotFoundError: No module named &#39;_ctypes&#39;</code>，此时可以安装依赖，重新编译安装 ·conan· 就可以了，也就是运行 <code>yum install libffi-devel -y</code>，重新 <code>make clean &amp;&amp; make &amp;&amp; make install</code> 就可以了。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>Go 的项目在 1.12 版本之后不必放到 <code>GOPATH</code> 路径中了，灵活度大大提高</li><li>C++ 也是有包管理器的，其中 conan 排名比较靠前，它是由 Python 语言编写的</li><li><code>go get</code> 是安装依赖包常常要用到的 Go 命令， <code>go help</code> 会提供 Go 相关的许多知识</li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/113812016" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>有时正确的选择比刻苦努力更加重要，用战术上的勤奋来掩盖战略上的懒惰，其结果只是感动了自己，而不会带我们达到目标。将者，智信仁勇严也~</p><p>2021-2-21 01:19:01</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;过了个年回到工作岗位，发现之前好好的 &lt;code&gt;Go&lt;/code&gt; 环境无法进行调试了，于是又重新配置了一次，弄好之后的新参数与原来有一些不一样的地方，甚至还有一些矛盾的地方，真搞不清楚原来的配置参数怎么能成功调试的，也是奇了怪了。配置过程中还遇到了一些问题，特别记录一下，防止今后遇到类似问题还要苦苦寻找。&lt;/p&gt;
    
    </summary>
    
      <category term="Go" scheme="http://AlbertGithubHome.github.io/blog/categories/Go/"/>
    
    
      <category term="Go" scheme="http://AlbertGithubHome.github.io/blog/tags/Go/"/>
    
      <category term="GOPATH" scheme="http://AlbertGithubHome.github.io/blog/tags/GOPATH/"/>
    
      <category term="mod" scheme="http://AlbertGithubHome.github.io/blog/tags/mod/"/>
    
      <category term="包管理" scheme="http://AlbertGithubHome.github.io/blog/tags/%E5%8C%85%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>TCP/IP协议簇中的子网掩码有什么作用</title>
    <link href="http://AlbertGithubHome.github.io/blog/2021/02/14/TCP-IP%E5%8D%8F%E8%AE%AE%E7%B0%87%E4%B8%AD%E7%9A%84%E5%AD%90%E7%BD%91%E6%8E%A9%E7%A0%81%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8/"/>
    <id>http://AlbertGithubHome.github.io/blog/2021/02/14/TCP-IP协议簇中的子网掩码有什么作用/</id>
    <published>2021-02-14T15:55:30.000Z</published>
    <updated>2021-02-19T13:57:45.278Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>前几天在配置数据库主从结构时查询了一些IP配置，后来编写远程执行脚本时又配置了一些IP数据，在<code>linux</code>上使用 <code>ifconfig</code> 命令查询IP配置时发现子网掩码不是常用的3个255，而是 <code>255.255.254.0</code>，只是简单记得这样配置扩大了子网的范围，但是具体子网掩码怎么使用还是记不清楚了，所以查询了这些还给老师的知识，在此总结一下。</p><a id="more"></a><h1 id="IP地址分类"><a href="#IP地址分类" class="headerlink" title="IP地址分类"></a>IP地址分类</h1><p>关于IPv4的地址分类之前有专门的总结，可以参考这一篇<a href="https://blog.csdn.net/albertsh/article/details/88914811" target="_blank" rel="noopener">《IP地址常见分类：A类、B类、C类、D类、E类》</a>，其中常用到的也就是A类、B类、C类这三种，默认的子网掩码分别为 <code>255.0.0.0</code>、<code>255.255.0.0</code>、<code>255.255.255.0</code>，通过IP地址和子网掩码进行与运算可以得出IP地址所对应的网络地址。</p><h1 id="子网掩码"><a href="#子网掩码" class="headerlink" title="子网掩码"></a>子网掩码</h1><p>子网掩码通过它的名字来判断肯定和子网有关系，掩码又有遮遮掩掩之意，合在一起其实就是通过其作用来进行的命名，也就是对IP地址进行遮掩，然后得到子网地址的作用。</p><h2 id="掩码的作用"><a href="#掩码的作用" class="headerlink" title="掩码的作用"></a>掩码的作用</h2><p>刚刚说通过子网掩码和IP地址可以获得网络地址，那么没有子网掩码可不可以呢？实际上如果进行某些约定就可以不使用子网掩码来获得网络地址，比如IPv4是通过4个字节来表示一个IP地址的，分为网络号和主机号两部分，A类IP地址可以使用第一字节表示网络号，B类地址使用前两个字节表示网络号，C类地址使用前3个字节表示网络号，其实这也是默认的表示方法。</p><p>加入子网掩码只是为了更灵活的配置子网，如果都按照默认的“规矩”进行划分就太死板了，难以适应复杂的需求环境，比如一个A类地址 <code>10.0.48.36</code> 默认的子网 <code>10.0.0.0</code>，可以容纳16777214台主机，这样如果一个子网的所需IP数量远远小于这个数字就会产生巨大的浪费。</p><p>再比如一个C类地址 <code>192.168.0.1</code> 的默认子网是 <code>192.168.0.0</code>，可以容纳254台主机，如果一个公司或者组织有500人，那么一个C类的子网就无法满足要求，需要分配B类地址才能解决问题，所以才有了子网掩码的出现，可以使子网的划分更加合理。</p><h2 id="掩码表示"><a href="#掩码表示" class="headerlink" title="掩码表示"></a>掩码表示</h2><p>掩码的表示比较简单，它由四个字节构成，表示成二进制形式时为前1后0，可以像IP地址一样的格式来书写，也可以写出掩码中有多少个1，举个例子，下面表示一个IP和子网：</p><ul><li><code>192.168.1.1</code> 和 <code>255.255.254.0</code></li></ul><p>也可以将掩码中1的个数写在IP地址后面表示成：</p><ul><li><code>192.168.1.1/23</code></li></ul><h2 id="子网拆分"><a href="#子网拆分" class="headerlink" title="子网拆分"></a>子网拆分</h2><p>增加子网掩码中1的个数可以将子网进行拆分，比如地址 <code>192.168.1.1</code> 和 <code>192.168.1.130</code> 在子网掩码是 <code>255.255.255.0</code>时都属于 <code>192.168.1.0</code> 这个子网，但是将子网掩码换成 <code>255.255.255.128</code>， 那么这两个IP地址就分别属于 <code>192.168.1.0</code> 和 <code>192.168.1.128</code> 这两个子网。</p><h2 id="子网合并"><a href="#子网合并" class="headerlink" title="子网合并"></a>子网合并</h2><p>减少子网掩码中1的个数可以将子网进行合并，比如地址 <code>192.168.1.1</code> 和 <code>192.168.0.1</code> 在子网掩码是 <code>255.255.255.0</code>时分别属于 <code>192.168.1.0</code> 和 <code>192.168.0.0</code> 这两个子网，但是将子网掩码换成 <code>255.255.254.0</code>， 那么这两个IP地址就都属于 <code>192.168.0.0</code> 这个子网了。</p><h1 id="网络包的传播"><a href="#网络包的传播" class="headerlink" title="网络包的传播"></a>网络包的传播</h1><p>网络包在子网内是以广播的形式传播，靠的是MAC地址，通过ARP协议可以获得，但是子网间的传播依赖IP地址，需通过路由或者三层交换机才能实现。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>通过IP地址和子网掩码进行按位与运算可以计算出IP地址所在的网络地址</li><li>通过子网掩码可以更合理的划分子网，对默认子网进行拆分与合并，一定程度上减少浪费和拥堵</li><li>子网内通信需要MAC地址，广播的形式来传递消息，这就是为什么网卡设置为混合模式可以截获到发给他人的消息</li><li>子网间通信需要借助IP地址才能实现，不过MAC地址也是需要的，通常被设置为网管的MAC地址</li><li>平时使用的 <code>ping</code> 命令，其实是 <code>ICMP</code> 协议的一部分，它是TCP/IP协议族的一个子协议，用于在IP主机、路由器之间传递控制消息</li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/113765130" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>勤劳的人总能挤出时间来坚持自己的习惯，懒惰的人总能找到借口来逃避应该做的事情，认定的目标就要大胆的开始，无论什么想法只要迈出了第一步就不算晚~</p><p>2021-2-14 23:57:52</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;前几天在配置数据库主从结构时查询了一些IP配置，后来编写远程执行脚本时又配置了一些IP数据，在&lt;code&gt;linux&lt;/code&gt;上使用 &lt;code&gt;ifconfig&lt;/code&gt; 命令查询IP配置时发现子网掩码不是常用的3个255，而是 &lt;code&gt;255.255.254.0&lt;/code&gt;，只是简单记得这样配置扩大了子网的范围，但是具体子网掩码怎么使用还是记不清楚了，所以查询了这些还给老师的知识，在此总结一下。&lt;/p&gt;
    
    </summary>
    
      <category term="Network" scheme="http://AlbertGithubHome.github.io/blog/categories/Network/"/>
    
    
      <category term="network" scheme="http://AlbertGithubHome.github.io/blog/tags/network/"/>
    
      <category term="ip" scheme="http://AlbertGithubHome.github.io/blog/tags/ip/"/>
    
      <category term="ping" scheme="http://AlbertGithubHome.github.io/blog/tags/ping/"/>
    
      <category term="子网掩码" scheme="http://AlbertGithubHome.github.io/blog/tags/%E5%AD%90%E7%BD%91%E6%8E%A9%E7%A0%81/"/>
    
      <category term="MAC" scheme="http://AlbertGithubHome.github.io/blog/tags/MAC/"/>
    
  </entry>
  
  <entry>
    <title>C/C++中string和int相互转换的常用方法</title>
    <link href="http://AlbertGithubHome.github.io/blog/2021/02/08/C-C-%E4%B8%ADstring%E5%92%8Cint%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/"/>
    <id>http://AlbertGithubHome.github.io/blog/2021/02/08/C-C-中string和int相互转换的常用方法/</id>
    <published>2021-02-08T15:41:12.000Z</published>
    <updated>2021-02-08T16:49:27.058Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>字符串操作是各种算法题中的常客，很多数据常常以字符串形式给出，其中有的需要自己转化成整数，而一些整型数据有时转换成字符串处理起来更加方便，比如判断一个整数是否是回文数，所以字符串和整数的转换是一些问题处理的基础步骤，<code>C++</code> 在处理这类问题时并不像 <code>Python</code> 那样方便，但是也有许多方法能够实现，为了今后查找方便，整理如下。</p><a id="more"></a><h1 id="int-转-string"><a href="#int-转-string" class="headerlink" title="int 转 string"></a>int 转 string</h1><h2 id="通过-std-to-string-函数转换"><a href="#通过-std-to-string-函数转换" class="headerlink" title="通过 std::to_string() 函数转换"></a>通过 std::to_string() 函数转换</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">123</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::to_string(num);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方式在 C++11 中才能使用，编译时记得加上 <code>--std=c++11</code> 的选项</p><h2 id="通过-ostringstream-转换"><a href="#通过-ostringstream-转换" class="headerlink" title="通过 ostringstream 转换"></a>通过 ostringstream 转换</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">123</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">ostringstream</span> ss;</span><br><span class="line">    ss &lt;&lt; num;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ss.str();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一种通过字符流的方式将整数转换成字符串，这种方式在C++11之前也可以使用</p><h2 id="通过-sprintf-转换"><a href="#通过-sprintf-转换" class="headerlink" title="通过 sprintf 转换"></a>通过 sprintf 转换</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">123</span>;</span><br><span class="line">    <span class="keyword">char</span> buffer[<span class="number">256</span>];</span><br><span class="line">    <span class="built_in">sprintf</span>(buffer, <span class="string">"%d"</span>, num);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s"</span>, buffer);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一种C语言中的转换方式，<code>sprintf</code> 也可以换成更安全的 <code>snprintf</code> 函数</p><h1 id="string-转-int"><a href="#string-转-int" class="headerlink" title="string 转 int"></a>string 转 int</h1><h2 id="通过-istringstream-转换"><a href="#通过-istringstream-转换" class="headerlink" title="通过 istringstream 转换"></a>通过 istringstream 转换</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> str = <span class="string">"668"</span>;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="function"><span class="built_in">istringstream</span> <span class="title">ss</span><span class="params">(str)</span></span>;</span><br><span class="line">    ss &gt;&gt; num;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; num;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 <code>istringstream</code> 可以从字符流中读取整数，与 <code>ostringstream</code> 是一种相反的操作</p><h2 id="使用-sscanf-来转化"><a href="#使用-sscanf-来转化" class="headerlink" title="使用 sscanf 来转化"></a>使用 sscanf 来转化</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> str = <span class="string">"668"</span>;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sscanf</span>(str.c_str(), <span class="string">"%d"</span>, &amp;num);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; num;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意 <code>sscanf</code> 函数的第一个参数类型是 <code>const char *</code>，<code>string</code>类型的参数需要转换一下</p><h2 id="使用-atoi-转换"><a href="#使用-atoi-转换" class="headerlink" title="使用 atoi 转换"></a>使用 atoi 转换</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> str = <span class="string">"668"</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; atoi(str.c_str());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>atoi</code> 函数的头文件是 <code>stdlib.h</code>，同样是一个C语言中的函数</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li><code>itoa</code> 不是c语言标准函数，在跨平台的整数转字符串的代码中不要使用这个函数</li><li><code>atoi</code> 是一个标准函数，需要将它和 <code>itoa</code> 区别开来，这一点很容易记混的</li><li>如果是在C++环境中进行转换，推荐使用 <code>stringstream</code> 字符流的形式和 <code>to_string</code> 函数</li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/113487945" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>这个世界真的很有趣，只要活着，就会有无限可能~</p><p>2021-2-9 00:44:34</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;字符串操作是各种算法题中的常客，很多数据常常以字符串形式给出，其中有的需要自己转化成整数，而一些整型数据有时转换成字符串处理起来更加方便，比如判断一个整数是否是回文数，所以字符串和整数的转换是一些问题处理的基础步骤，&lt;code&gt;C++&lt;/code&gt; 在处理这类问题时并不像 &lt;code&gt;Python&lt;/code&gt; 那样方便，但是也有许多方法能够实现，为了今后查找方便，整理如下。&lt;/p&gt;
    
    </summary>
    
      <category term="C/C++" scheme="http://AlbertGithubHome.github.io/blog/categories/C-C/"/>
    
    
      <category term="C/C++" scheme="http://AlbertGithubHome.github.io/blog/tags/C-C/"/>
    
      <category term="string" scheme="http://AlbertGithubHome.github.io/blog/tags/string/"/>
    
      <category term="int" scheme="http://AlbertGithubHome.github.io/blog/tags/int/"/>
    
      <category term="相互转化" scheme="http://AlbertGithubHome.github.io/blog/tags/%E7%9B%B8%E4%BA%92%E8%BD%AC%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>C++中一些方便的算法函数和吃不够的语法糖</title>
    <link href="http://AlbertGithubHome.github.io/blog/2021/01/30/C-%E4%B8%AD%E4%B8%80%E4%BA%9B%E6%96%B9%E4%BE%BF%E7%9A%84%E7%AE%97%E6%B3%95%E5%87%BD%E6%95%B0%E5%92%8C%E5%90%83%E4%B8%8D%E5%A4%9F%E7%9A%84%E8%AF%AD%E6%B3%95%E7%B3%96/"/>
    <id>http://AlbertGithubHome.github.io/blog/2021/01/30/C-中一些方便的算法函数和吃不够的语法糖/</id>
    <published>2021-01-30T08:09:01.000Z</published>
    <updated>2021-01-31T15:53:29.537Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>C++由于其复杂性，学习成本很高。但是作为接近底层的语言，学会之后能做的事情相当多，C++给了开发者极大的自由，只要符合规范就可以尽情的折腾，不过对于日常使用来说确实不太“方便”，特别是相比于Python、JS这类脚本语言，处理一些小问题时前奏太长，很多常用操作都需要自己造轮子，这一点在刷题时感觉很明显，C++一碰到字符串分析就“头大”，Python用一行搞定，用C++则需要N行。</p><a id="more"></a><h1 id="变化"><a href="#变化" class="headerlink" title="变化"></a>变化</h1><p>其实很多人对C++的认识还停留在 <code>C++98</code> 或者 <code>C++03</code> 版本，然而从 <code>C++11</code> 版本开始C++就发生了翻天覆地的变化，近期在使用的过程中发现C++也有很多方便的函数，越高的版本越方便，语法糖也越多，今天先总结几个，后续再补充吧。</p><h1 id="优秀函数和语法糖"><a href="#优秀函数和语法糖" class="headerlink" title="优秀函数和语法糖"></a>优秀函数和语法糖</h1><h2 id="使用find系列实现trim函数"><a href="#使用find系列实现trim函数" class="headerlink" title="使用find系列实现trim函数"></a>使用find系列实现trim函数</h2><p><code>trim</code>函数在很多语言中都是内置函数，可以去除收尾两端的空格，在C++中是没有trim函数的，需要自己实现一下，需要用到的工具函数有下面两个：</p><ul><li><code>find_first_not_of</code>：在字符串s中找到第一个不等于指定字符序列<code>ACDE..</code>的位置</li><li><code>find_last_not_of</code>：在字符串s中找到最后一个不等于指定字符序列<code>ACDE..</code>的位置</li></ul><p><code>find_first_not_of(&quot;hello world&quot;, &quot;he&quot;)</code> 指的就是找到第一个不等于 <code>h</code> 且不等于 <code>e</code> 字母的字符位置，要想去除字符串首尾空格就需要找到第一个不等于空格的位置，和最后一个不等于空格的位置，保留这两个位置中的部分即可，实现如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="function"><span class="built_in">string</span>&amp; <span class="title">trim</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> &amp;s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s.empty()) <span class="keyword">return</span> s;</span><br><span class="line"></span><br><span class="line">    s.erase(<span class="number">0</span>, s.find_first_not_of(<span class="string">" "</span>));</span><br><span class="line">    <span class="keyword">return</span> s.erase(s.find_last_not_of(<span class="string">" "</span>) + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="function"><span class="built_in">string</span>&amp; <span class="title">trim</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> &amp;s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s.empty()) <span class="keyword">return</span> s;</span><br><span class="line"></span><br><span class="line">    s.erase(<span class="number">0</span>, s.find_first_not_of(<span class="string">" "</span>));</span><br><span class="line">    <span class="keyword">return</span> s.erase(s.find_last_not_of(<span class="string">" "</span>) + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(<span class="string">" Hello world  "</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"before trim ==&gt;"</span> &lt;&lt; s &lt;&lt; <span class="string">"&lt;&lt;=="</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"after trim ==&gt;"</span> &lt;&lt; trim(s) &lt;&lt; <span class="string">"&lt;&lt;=="</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:/mnt/d/data/cpp/cplusplusadvance$ g++ stringtrim.cpp -o stringtrim</span><br><span class="line">albert@home-pc:/mnt/d/data/cpp/cplusplusadvance$ ./stringtrim</span><br><span class="line">before trim ==&gt; Hello world  &lt;&lt;==</span><br><span class="line">after trim ==&gt;Hello world&lt;&lt;==</span><br></pre></td></tr></table></figure><h2 id="使用regex实现split函数"><a href="#使用regex实现split函数" class="headerlink" title="使用regex实现split函数"></a>使用regex实现split函数</h2><p><code>split</code> 也是一个常用但C++不提供的函数，在C语言和早期的C++中一般通过 <code>strtok</code> 函数来实现，但是从 <code>C++11</code> 开始可以通过 <code>regex</code> 来实现，可以看下面这个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;regex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(<span class="string">"c++11 test split"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">regex <span class="title">reg</span><span class="params">(<span class="string">" "</span>)</span></span>; <span class="comment">// "\\s+" for blank</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; v(sregex_token_iterator(s.begin(), s.end(), reg, <span class="number">-1</span>), sregex_token_iterator());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> str : v)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"==&gt;"</span> &lt;&lt; str &lt;&lt; <span class="string">"&lt;&lt;=="</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结构如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:/mnt/d/data/cpp/cplusplusadvance$ g++ stringsplit.cpp -o stringsplit --std=c++17</span><br><span class="line">albert@home-pc:/mnt/d/data/cpp/cplusplusadvance$ ./stringsplit</span><br><span class="line">==&gt;c++11&lt;&lt;==</span><br><span class="line">==&gt;<span class="built_in">test</span>&lt;&lt;==</span><br><span class="line">==&gt;split&lt;&lt;==</span><br></pre></td></tr></table></figure><h2 id="使用auto遍历map结构"><a href="#使用auto遍历map结构" class="headerlink" title="使用auto遍历map结构"></a>使用auto遍历map结构</h2><p>很早以前C++中遍历map、set等复杂结构的时候需要写很长的代码来定义迭代器，自从出现了auto之后这种遍历简单了许多，最近发现针对map的遍历还有更简单的方法，使用方法如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; m&#123;&#123;<span class="string">"tom"</span>, <span class="number">20</span>&#125;, &#123;<span class="string">"albert"</span>, <span class="number">18</span>&#125;, &#123;<span class="string">"bella"</span>, <span class="number">19</span>&#125;, &#123;<span class="string">"bily"</span>, <span class="number">30</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; [name, age] : m) &#123;</span><br><span class="line">        <span class="keyword">if</span> (age &gt; <span class="number">18</span>)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; name &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:/mnt/d/data/cpp/cplusplusadvance$ g++ autonew.cpp -o autonew --std=c++17</span><br><span class="line">albert@home-pc:/mnt/d/data/cpp/cplusplusadvance$ ./stringsplit</span><br><span class="line">bella</span><br><span class="line">bily</span><br><span class="line">tom</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li><code>find_first_not_of</code>、<code>find_last_not_of</code>、<code>find_first_of</code> 这系列函数功能虽简单，但是使用它们可以简化代码逻辑</li><li>正则表达式是处理字符串查找的强有力的工具，合理的使用正则表达式可以达到事半功倍的效果，C++中请使用 <code>std::regex</code></li><li><code>C++17</code>中引入了结构化绑定声明，可以使用auto来声明多个变量，所有变量都必须用中括号括起来</li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/113065257" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>做自己认为对的事情，剩下的交给时间~</p><p>2021-1-31 23:04:17</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;C++由于其复杂性，学习成本很高。但是作为接近底层的语言，学会之后能做的事情相当多，C++给了开发者极大的自由，只要符合规范就可以尽情的折腾，不过对于日常使用来说确实不太“方便”，特别是相比于Python、JS这类脚本语言，处理一些小问题时前奏太长，很多常用操作都需要自己造轮子，这一点在刷题时感觉很明显，C++一碰到字符串分析就“头大”，Python用一行搞定，用C++则需要N行。&lt;/p&gt;
    
    </summary>
    
      <category term="C/C++" scheme="http://AlbertGithubHome.github.io/blog/categories/C-C/"/>
    
    
      <category term="C/C++" scheme="http://AlbertGithubHome.github.io/blog/tags/C-C/"/>
    
      <category term="auto" scheme="http://AlbertGithubHome.github.io/blog/tags/auto/"/>
    
      <category term="algorithm" scheme="http://AlbertGithubHome.github.io/blog/tags/algorithm/"/>
    
      <category term="语法糖" scheme="http://AlbertGithubHome.github.io/blog/tags/%E8%AF%AD%E6%B3%95%E7%B3%96/"/>
    
  </entry>
  
</feed>
