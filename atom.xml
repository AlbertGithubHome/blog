<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Albert World</title>
  <icon>https://www.gravatar.com/avatar/8ccc6291d5bfd34e7aaf601c4ebec7e1</icon>
  
  <link href="/blog/atom.xml" rel="self"/>
  
  <link href="http://AlbertGithubHome.github.io/blog/"/>
  <updated>2024-09-28T07:23:52.684Z</updated>
  <id>http://AlbertGithubHome.github.io/blog/</id>
  
  <author>
    <name>Albert Shi</name>
    <email>347070901@qq.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>AWS上迁移WordPress遭遇若干问题及处理办法</title>
    <link href="http://AlbertGithubHome.github.io/blog/2024/09/27/AWS%E4%B8%8A%E8%BF%81%E7%A7%BBWordPress%E9%81%AD%E9%81%87%E8%8B%A5%E5%B9%B2%E9%97%AE%E9%A2%98%E5%8F%8A%E5%A4%84%E7%90%86%E5%8A%9E%E6%B3%95/"/>
    <id>http://AlbertGithubHome.github.io/blog/2024/09/27/AWS上迁移WordPress遭遇若干问题及处理办法/</id>
    <published>2024-09-26T17:00:00.000Z</published>
    <updated>2024-09-28T07:23:52.684Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>前段时间不是在<a href="https://blog.csdn.net/albertsh/article/details/142427271" target="_blank" rel="noopener">迁移AWS</a>嘛，采用了分享AMI的方式，废了九牛二虎之力，终于在没有密钥的情况下成功登录了转移后的EC2实例，那么我们肯定不单单是为了转移一个EC2实例而大费周章，实际目的还是为了里面的数据和服务，具体来说就是一套WordPress网站，对于一个新的知识和事物围绕它的有很多知识点，一旦发散的过快就发现东西太多了，什么也讲不明白，造成虎头蛇尾的现象，做技术内容输出的人经常有这种力不从心的感觉。</p><a id="more"></a><p>为了避免这种现象，我尽量保持克制，不随意发散，按着时间先后发生的主线，来说说遇到了哪些问题，又是怎么解决的，解决方案或许不完美，只是提供一种思路。</p><h1 id="问题的产生"><a href="#问题的产生" class="headerlink" title="问题的产生"></a>问题的产生</h1><p>前文提到我已经把原来的AWS实例迁移到新的账号下了，其实繁杂的工作才刚刚起步，首先是访问IP，为了每次重启后IP地址不发生变化，我们不能采用自动分配的公共IP，而要申请弹性IP关联到对应的实例上，注意弹性IP关联到正在运行的实例上时不收费，但是如果不关联或者关联的实例不运行，则需要支付费用，大约$0.005/小时。</p><p>当然这都是小问题，真正的问题还在后面，比如域名需要转移，域名的解析需要重新配置，SSL证书要重新申请，花费时间最多的还是网站用户上报信息发送邮件功能不可用的问题，不过还好，凭借这知识积累和渊博的互联网，基本都找到了解决方案，下面逐项来介绍一下。</p><h1 id="域名转移与DNS解析"><a href="#域名转移与DNS解析" class="headerlink" title="域名转移与DNS解析"></a>域名转移与DNS解析</h1><p>域名转移据说在国外非常顺畅，但这次不是常用的GoDaddy，也不是上次虐我千百遍的JPDirect，是一个叫Onamae服务网站，使用这个网站最大的难点不是技术上的，而是语言层面的，全网站只有日文，凭借着我的有道词典和小伙伴的日语助攻，域名顺利转移，但是我废了九牛二虎之力也没找到原来的DNS记录配置在哪里，找不到DNS记录意味着我无法将域名解析到新的EC2。</p><p>后来想起了Vercel验证域名的经历，这个域名不会也把域名服务器改到别处了吧，一查果然是改到aws了，那必然是用了Route53啊。</p><p><strong>Amazon Route 53</strong> 是 AWS 提供的高度可用和可扩展的云域名系统（DNS）服务，主要用于将用户访问的域名（如 <code>example.com</code>）映射到网络资源（如 EC2 实例、负载均衡器、S3 存储桶等）。Route 53 提供域名注册、DNS 解析、流量管理、以及健康检查等功能。</p><p>Route53 提供高度可用的 DNS 解析服务，将域名映射到 AWS 资源或其他 IP 地址，支持 A 记录（IPv4 地址）、AAAA 记录（IPv6 地址）、CNAME、MX 等常见 DNS 记录类型。支持多种路由策略，如简单路由、加权路由、基于延迟的路由、地理位置路由、故障转移路由等，帮助实现流量优化和高可用性。</p><p>每月前 25 个托管区域每个 $0.50，超过部分按 $0.10/托管区域/月收费。首 10 亿次查询为 $0.40 每百万次查询，超过部分按 $0.20 每百万次查询计费。在全球多个 AWS 区域提供服务，确保最快速的 DNS 解析速度。</p><p>总的来说就是Onamae甩锅了，有人查询DNS记录，Onamae指着AWS说你问他，我不管了，这个域名由他全权负责。</p><h1 id="解析域名到EC2与启用SSL"><a href="#解析域名到EC2与启用SSL" class="headerlink" title="解析域名到EC2与启用SSL"></a>解析域名到EC2与启用SSL</h1><p>现在是个网站就HTTPS，也不管是不是有隐私数据，反正我就得加上显得安全，那我们也随大流别特立独行了，去搞个SSL证书吧，虽然给官网买个好点的证书也付得起，但毕竟免费的更具性价比，在AWS上有免费的证书可用，访问ACM即可申请。</p><p><strong>AWS Certificate Manager (ACM)</strong> 是 Amazon Web Services 提供的服务，用于轻松管理 SSL/TLS 证书，来保护网站和应用程序的网络流量。ACM 自动化了证书的申请、颁发、续订、以及配置过程，从而简化了安全管理。</p><p>ACM 支持免费申请 <strong>公有 SSL/TLS 证书</strong>，用于保护基于 HTTPS 协议的流量。支持单域名、多域名和通配符证书。可以将 ACM 证书快速部署到多个 AWS 服务上，如 <strong>Elastic Load Balancers (ELB/ALB/NLB)</strong>、<strong>CloudFront</strong>、<strong>API Gateway</strong>、和 <strong>Elastic Beanstalk</strong>。</p><p>申请时，需要验证域名的所有权，ACM 支持 <strong>DNS 验证</strong> 和 <strong>Email 验证</strong>，证书可以直接部署在 ALB、CloudFront 等 AWS 服务上，无需手动上传证书，ACM 会自动检测到即将到期的证书，并在过期前完成自动续订。ACM 是一个简化 SSL/TLS 证书管理的服务，特别适合不希望手动处理证书申请、安装和续订的用户。它与 AWS 其他服务深度集成，确保用户在 AWS 上可以轻松实现网站和应用的安全性。</p><p>看了这些介绍是不是心动了，申请步骤也非常方便，基本上填写一个域名<code>example.com</code> 其他参数默认就可以了，前文提到ACM需要验证域名的所有权，这一点AWS做的非常方便，之前我们已经修改Onamae购买的域名NS指向了Route53，这里可以选择<strong>DNS 验证</strong>，在申请SSL证书后会有一个按钮，将验证的DNS记录添加到Route53，一步到位非常的人性化，添加完验证DNS记录后，证书状态会显示为 <code>等待验证</code>，这个过程我等待了1-2小时，然后状态切换成了 <code>已颁发</code>，可能因为我使用新买的域名进行的测试。</p><p>进行到这遇到了一个难题，SSL给谁用？如果我在Route53中将域名解析到EC2，那么我这个SSL证书就得放到EC2上，不管是配置到Nginx、Apache，还是应用程序自己处理都比较麻烦，所以我们充分利用AWS的服务架构，申请一个ELB，将SSL证书分配到ELB上，然后Route53将域名解析到ELB，ELB收到请求后再将流量转发到EC2。</p><h2 id="申请ALB完成转发"><a href="#申请ALB完成转发" class="headerlink" title="申请ALB完成转发"></a>申请ALB完成转发</h2><p>AWS ELB（Elastic Load Balancing）是亚马逊云服务（AWS）提供的一项负载均衡服务，主要分为ALB、NLB、CLB，旨在自动分配进入应用程序的流量，以确保高可用性和可靠性。ELB 可以帮助你管理和优化应用程序的流量，同时确保后端服务器不会因过载而失效。</p><p>ELB 能够根据流量自动扩展和缩减负载均衡能力，以适应流量的变化，支持 SSL/TLS 加密，确保数据在传输过程中安全。集成了 AWS CloudWatch，可以实时监控负载均衡器的性能和流量，并提供访问日志。支持 HTTP、HTTPS、TCP 和 WebSocket 等多种协议。</p><h3 id="ELB分类"><a href="#ELB分类" class="headerlink" title="ELB分类"></a>ELB分类</h3><ol><li><p><strong>应用负载均衡器（ALB）</strong>：</p><ul><li>最适合 HTTP 和 HTTPS 流量，能够根据请求的内容进行智能路由。</li><li>支持基于内容的路由、SSL 终止、WebSocket 和 HTTP/2。</li><li>提供更细粒度的流量控制和监控功能。</li></ul></li><li><p><strong>网络负载均衡器（NLB）</strong>：</p><ul><li>设计用于处理 TCP 流量，能够提供极低的延迟和高吞吐量。</li><li>可以处理数百万个请求，并支持静态 IP 地址。</li><li>适合高性能、低延迟的应用场景，如游戏和实时数据处理。</li></ul></li><li><p><strong>经典负载均衡器（CLB）</strong>：</p><ul><li>早期的负载均衡器，支持 HTTP、HTTPS 和 TCP。</li><li>提供基本的负载均衡功能，但不具备 ALB 和 NLB 的高级功能。</li><li>目前已不再推荐用于新应用，AWS 建议用户使用 ALB 或 NLB。</li></ul></li></ol><p>因为使用的是 HTTP 和 HTTPS 流量的应用程序，所以需要选择 ALB，NLB是不会解析到应用层协议的，使用ALB可以进行SSL终止，那什么是SSL终止呢？</p><p><strong>SSL终止</strong>（SSL Termination）是在负载均衡器或代理服务器等中间设备上处理SSL/TLS加密和解密的技术。</p><h3 id="SSL终止及优点"><a href="#SSL终止及优点" class="headerlink" title="SSL终止及优点"></a>SSL终止及优点</h3><p><strong>SSL终止</strong>指的是当客户端与服务器之间的连接使用SSL/TLS加密时，SSL连接在中间设备（如负载均衡器）上终止（解密）。之后，终止SSL加密的数据将作为未加密的数据在中间设备和后端服务器之间传输。</p><ul><li><strong>性能提升</strong>：后端服务器不需要处理SSL/TLS加解密工作，减轻了服务器的负担，特别是对于高流量的网站，能够提高整体的性能和响应速度。</li><li><strong>集中管理SSL证书</strong>：SSL证书只需要在负载均衡器等设备上配置，无需在每台后端服务器上安装SSL证书，简化了证书的管理和更新流程。</li><li><strong>简化架构</strong>：SSL终止简化了网络架构，尤其适合需要将流量分配给多台服务器的负载均衡环境。</li><li><strong>支持多种协议</strong>：可以支持HTTP、WebSocket等不加密协议的通信形式，而客户端仍然认为其连接是安全的。</li></ul><h3 id="SSL终止的工作流程"><a href="#SSL终止的工作流程" class="headerlink" title="SSL终止的工作流程"></a>SSL终止的工作流程</h3><ol><li>客户端发起HTTPS请求。</li><li>负载均衡器或代理服务器接收请求，并在此解密SSL加密的数据。</li><li>解密后，负载均衡器将未加密的数据转发给后端服务器（通过HTTP等协议）。</li><li>服务器处理请求并将结果返回给负载均衡器。</li><li>负载均衡器将响应数据重新加密，并返回给客户端。</li></ol><p>在创建ALB时有几个需要注意的点，面向互联网还是内部？IPv4还是双栈？网络映射到哪？安全组怎么配？侦听器和路由是什么？这些问题看着深奥，其实一点也不简单，我用大白话试着解释一下？</p><ul><li>面向互联网还是内部，就是问给公网用户访问还是内网访问，这个就是字面意思</li><li>IPv4还是双栈，就是问只用IPv4还是需要支持IPv6，我不太懂，选了双栈，功能多总没坏处</li><li>网络映射到哪，就是选一个子网和至少两个可用区域，为了说明流量的去向</li><li>安全组怎么配，按照EC2的规则配就行了，这个就是EC2的前面的一道门，注意开启443端口的流入哈</li><li>侦听器和路由是什么，这个是个重点，就是说监听某个端口，然后将流量导入到目标组，按照我们的目的肯定是监听443，然后导向EC2实例的80啊，选择443时就可以使用前文里申请的SSL证书了</li></ul><p>回答了上面的问题，又引出了新的问题，我选择的子网不让我选择双栈怎么办？目标组又是什么？</p><p>如果你选择的是双栈（IPv4/IPv6），确保子网有 IPv6 CIDR 块。<strong>CIDR块</strong>（Classless Inter-Domain Routing Block）是一种表示IP地址范围的方式。它用于描述一个网络及其子网的大小，并且广泛应用于现代网络，特别是在分配和管理IP地址时。如果没有就去子网里添加。</p><p>目标组就是把流量目标组到一起，定义一个目标组，目的就是精确表示流量去到的地方，我目前的需求是导向到具体的EC2，所以目标组里可以只选择一个EC2实例，其实你也可以选择多个实例去做类似负载均衡的需求</p><p>到这里ALB基本就配置完了，这时可以将这个ALB的DNS信息复制添加到Route53里，以别名的形式添加，这一套路径就走下来了</p><p>用于访问域名，交给Route53解析地址，Route53将ALB地址返回，流量以HTTPS形式到达ALB，使用证书解密出数据，数据以HTTP形式从ALB到达目标组中的EC2实例，完成一次请求，EC2不用关心证书的问题，多数一句，这样的EC2如果不直接访问可以不配置公网IP和弹性IP。</p><p>进行到这里网站跑起来了，访问也正常了，貌似问题都解决了，但旅途怎会如此顺利？接下来就将迎来业务引发的问题——发邮件不成功，经历了这次的折腾我看到了更本质的东西。</p><h1 id="邮件发送问题"><a href="#邮件发送问题" class="headerlink" title="邮件发送问题"></a>邮件发送问题</h1><p>当你不熟悉一件事情的时候总会认为它很神秘，就像我之前认为邮件特别复杂、特别庞大一样，经过这次折腾之后发现它的轮廓清晰了起来，再说问题之前，我们先来看一段历史。</p><p>1987 年 9 月14 日晚上，北京车道沟十号院中一座树木掩映的小楼里，李澄炯教授等13 位中、德科学家聚拢在一台西门子7760 大型计算机周围，成功发出中国第一封电子邮件。 这座小楼，就是中国兵器工业计算机应用技术研究所的所在地。</p><blockquote><p>“Across the Great Wall we can reach every corner in the world”（“越过长城，走向世界”）。这是西方世界第一次通过互联网听到中国的声音。</p></blockquote><p>看到Great Wall和这个句子含义总联想到另一个词，有点讽刺~</p><p>现在看来，邮件本质是数据的发送，从数据层面来看与HTTP请求并无不同，只是使用了另一种更适合它的协议，将数据传递到目的地罢了。</p><p>我很早就不觉得HTTP神秘了，为什么呢？因为整天接触它，但是我在前两天还在觉得Email神秘，因为平时用的少也没有过多研究过，这次趁着解决问题稍微拓展了一下，感觉知识面又变宽了一点点。</p><p>好了，接下来说遇到的问题，迁移的WordPress有一个提交表单发邮件的功能，使用了一个叫 <code>MW WP WPForm</code> 的插件，可以<a href="https://mw-wp-form.web-soudan.co.jp/manual/auto_mail/" target="_blank" rel="noopener">自动回复邮件</a>以及<a href="https://mw-wp-form.web-soudan.co.jp/manual/admin_mail/" target="_blank" rel="noopener">向管理员发送表单邮件</a>，但是我将WordPress迁移到新的AWS实例后，这个功能失效了</p><p>官方也给出了一些<a href="https://mw-wp-form.web-soudan.co.jp/faq/" target="_blank" rel="noopener">FAQ</a></p><blockquote><p>“There was an error trying to send your message. Please try again later.” is a message that appears when an email fails to send. There are two main reasons why this message appears:</p><ul><li>WordPress itself cannot send emails</li><li>The email body is not set on the MW WP Form form editing screen</li></ul></blockquote><p>虽然不能直接解决我的问题，但是我发现了一件事，就是这个插件本身不能发送邮件，它要求WordPress必须本身可以发送邮件才可以，怎么理解这句话呢？首先你要理解插件的作用，插件是在原项目或作品上通过加载的方式丰富完善原来的内容，本身并不能提供一些基础的能力。</p><p>因为插件一般与源系统是解耦的，所以只能通过系统提供的一些钩子或事件来改善原系统功能，就以 <code>MW WP WPForm</code> 这个插件为例，WordPress本身是可以利用 PHP 的 <code>WP_Mail</code> 发送邮件的，但是相对来说使用较复杂，需要传递很多参数，而 <code>MW WP WPForm</code> 就是将这些参数便利化的插件，当我收到你要发邮件的请求时由插件负责组装参数和调用函数，大大方便了邮件发送的操作。</p><p>但是如果本身调用 <code>WP_Mail</code> 都发不了邮件，那么这个插件也就无能为力了。</p><p>其实 <code>WP_Mail</code> 只是为 WordPress 提供了发送邮件的功能逻辑，并不是发邮件的基础架构，以Linux为例，与邮件相关的命令有 <code>mail</code>、<code>sendmail</code>、<code>postfix</code> 等，其中 <code>mail</code> 是一个邮件客户端，用于发送和接收邮件，可以这样使用 <code>mail -s &quot;Subject&quot; user@example.com</code>，<code>sendmail</code> 和 <code>postfix</code> 是邮件传输代理（MTA），主要用于处理邮件的发送和接收。在现代 Linux 系统中，<code>postfix</code> 通常被认为是比 <code>sendmail</code> 更好的选择，因为它更安全、易于管理且性能优越。</p><p>这些才是Linux系统发送邮件的基础结构，WordPress的 <code>WP_Mail</code> 函数主要依赖于 PHP 的 <code>mail()</code> 函数来发送邮件，而PHP 的 <code>mail()</code> 函数通过系统的邮件传输代理（通常是 <code>sendmail</code> 或 <code>postfix</code>）来发送邮件，确保适当的 MTA 已安装并配置正确，才能保证 PHP 可以成功发送邮件。</p><p>初步分析是这台机器邮件服务没有配置好，那就查查log吧，打开 <code>/var/log/maillog</code> 文件看到以下字样：</p><blockquote><p>Sep 26 16:14:29 ip-192-168-2-26 postfix/smtp[9198]: connect to mx2.qq.com[240d:c040:1:40::133]:25: Network is unreachable</p></blockquote><p>咦？25号端口咋不通呢？看了看安全规则也没限制25号端口，还有就是我现在的系统是直接镜像过来的，配置应该一模一样才对，为什么之前的实例可以发送邮件，而镜像过来的新实例就不行呢？</p><p>后来我又创建一个简单实例，然后搭建了WordPress，依旧发不了邮件，然后我就查了一下发现<a href="https://aws.amazon.com/cn/ec2/faqs/" target="_blank" rel="noopener">AWS-FAQ</a>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EC2 SMTP 端点策略的变化</span><br><span class="line">问：ID 格式会发生怎样的变化？</span><br><span class="line"></span><br><span class="line">自 2020 年 1 月 7 日起，Amazon EC2 开始推出一项变化来限制默认情况下通过端口 25 的电子邮件流量，</span><br><span class="line">从而防止客户和其他收件人收到垃圾邮件和电子邮件滥用。端口 25 通常用作发送电子邮件的默认 SMTP 端口。</span><br><span class="line">在过去请求并取消了端口 25 限制的 AWS 账户将不受此变化影响。</span><br></pre></td></tr></table></figure><p>原来是AWS把新实例的25端口封锁了，之前的实例是2019年申请的没有受到影响，进一步查询，发现不只AWS这样做，阿里云也封锁了25号端口，要是申请解封会花一些时间还不一定成功，我还是想想别的办法。</p><h2 id="解决邮件问题"><a href="#解决邮件问题" class="headerlink" title="解决邮件问题"></a>解决邮件问题</h2><p>既然25号端口不好用，我就用SMTP的SSL端口465吧，可是怎么改变发送的端口呢？我查到了WordPress的 <code>WP MIAL SMTP</code> 插件，填写qq邮箱的SMPT服务器，添加qq邮箱和授权码，就搞定了，真是太方便，设置完终于可以发邮件了，泪流满面，天知道这个过程我持续了多久，熬了多少个夜晚。</p><p>这个插件的安装我是在测试实例时搞得，正当我想要在正式实例上安装 <code>WP MIAL SMTP</code> 插件时，提示我WordPress版本5.2.4太低无法安装，之前安装的那个测试环境是6.2.4，天塌了呀，那没办法升级WordPress吧，找到升级按钮那么一点，开始转圈圈，然后提示我升级失败，天又塌了呀。</p><p>鬼知道我都遇到了什么，既然不让我安装 <code>WP MIAL SMTP</code>，那我安装个别的呗，后来找到了 <code>Easy WP SMTP</code> 可以在当前版本安装，整个使用过程和 <code>WP MIAL SMTP</code> 几乎一毛一样，看起来就像换了个主题，结果就是一样好使，事情还没完。</p><p>刚刚配置的是我的QQ邮箱，但是这里总不能把邮件都扔我邮箱吧，最终要换成企业微信邮箱，但是当我配置为公司企业微信邮箱再提交表单发邮件时，虽然邮件正常回复给QQ邮箱了，但是插件 <code>WP MIAL SMTP</code> 测试页面报了一个警告和错误</p><blockquote><p>Domain Check Results</p><ul><li>spf<blockquote><p>Action Needed: It doesn’t look like the SPF record required by your SMTP server has been added to your domain. Please contact your SMTP server provider for details on how to find the SPF record, and how to add this record to your domain’s DNS.</p></blockquote></li><li>dmarc<blockquote><p>Action Recommended: It doesn’t look like DMARC has been set up on your domain (xxx.com). We recommend using the DMARC protocol because it helps protect your domain from &gt;&gt;unauthorized use. Please check out this step-by-step guide for details on how to add the DMARC record to your domain’s DNS.</p></blockquote></li></ul></blockquote><p>其实一开始我也没当回事，查了<code>Easy WP SMTP</code>插件的<a href="https://easywpsmtp.com/docs/how-to-create-dmarc-record/" target="_blank" rel="noopener">文档</a>，还提供了一个<a href="https://mxtoolbox.com/SuperTool.aspx" target="_blank" rel="noopener">查询DNS信息的工具</a>,但是我没有放在心上，不撞南墙怎会回头，后来再给Gmail发邮件的时候，邮件被退回了，错误原因写的还算清楚</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">无法发送到 yyy@gmail.com</span><br><span class="line">退信原因    发件人（support@xxx.com）域名的DNS记录未设置或设置错误导致对方拒收此邮件。</span><br><span class="line">host gmail-smtp-in.l.google.com[172.253.118.27] said: 550-5.7.26 Your email has been blocked because</span><br><span class="line">the sender is unauthenticated. Gmail requires all senders to authenticate with either SPF or DKIM.</span><br><span class="line">Authentication results:  DKIM = did not pass  SPF [xxx.com] with ip: [18.169.211.239] = did not pass</span><br><span class="line">For instructions on setting up authentication,</span><br><span class="line">go to  https://support.google.com/mail/answer/81126#authentication d9443c01a7336-20af16e543csi13995695ad.54 - gsmtp (in reply to end of DATA command)</span><br><span class="line">解决方案    请通知你的邮箱管理员为邮箱域名设置正确的DNS(SPF、DKIM、DMARC)记录。</span><br><span class="line">详细请见 http://service.exmail.qq.com/cgi-bin/help?subtype=1&amp;&amp;no=1000580&amp;&amp;id=20012。</span><br></pre></td></tr></table></figure><p>在自己企业微信的域名上添加两行记录就可以了，这样就可以顺利的发邮件给GMail了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">主机记录：@</span><br><span class="line">记录类型：TXT</span><br><span class="line">记录值为：v=spf1 include:spf.mail.qq.com ~all</span><br><span class="line"></span><br><span class="line">主机记录： _dmarc</span><br><span class="line">记录类型：TXT</span><br><span class="line">记录值: v=DMARC1; p=none; rua=mailto:mailauth-reports@qq.com</span><br></pre></td></tr></table></figure><p><strong>SPF（Sender Policy Framework）</strong> 是一种电子邮件验证协议，用于防止邮件伪造和垃圾邮件。SPF 的验证原理基于 DNS（域名系统）记录。<strong>DMARC（Domain-based Message Authentication, Reporting &amp; Conformance）</strong> 是一种邮件身份验证协议，用于增强电子邮件的安全性，防止邮件伪造和钓鱼攻击。它建立在 SPF（Sender Policy Framework）和 DKIM（DomainKeys Identified Mail）之上，通过提供发送方的政策声明和报告机制来实现。</p><p>有关SPF和DMARC的详细原理可以自己去扩展，这里只做简单介绍了。</p><p>本来事情到这里就比较完美了，但是架不住技术人有一个爱折腾的心，我不装插件行不行呢？</p><h2 id="原生解决邮件问题"><a href="#原生解决邮件问题" class="headerlink" title="原生解决邮件问题"></a>原生解决邮件问题</h2><h3 id="临时测试"><a href="#临时测试" class="headerlink" title="临时测试"></a>临时测试</h3><p>既然装了个插件能解决发邮件的问题，那我能不能自己搞个简单配置文件来做（貌似写代码的人有技术洁癖），说干就干，我先是在测试的WordPress上进行，版本6.2.4，ChatGPT提示我直接在主题下面的 <code>functions.php</code> 文件里加代码就行，路径 <code>/wp-content/themes/你的主题名/functions.php</code></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">configure_smtp</span><span class="params">( PHPMailer $phpmailer )</span> </span>&#123;</span><br><span class="line">    $phpmailer-&gt;isSMTP();</span><br><span class="line">    $phpmailer-&gt;Host       = <span class="string">'smtp.qq.com'</span>;       <span class="comment">// 你的 SMTP 服务器</span></span><br><span class="line">    $phpmailer-&gt;SMTPAuth   = <span class="keyword">true</span>;</span><br><span class="line">    $phpmailer-&gt;Port       = <span class="number">465</span>;                 <span class="comment">// SMTP 端口，465 是 SSL 的常用端口</span></span><br><span class="line">    $phpmailer-&gt;Username   = <span class="string">'707070901@qq.com'</span>;  <span class="comment">// 你的 SMTP 用户名</span></span><br><span class="line">    $phpmailer-&gt;Password   = <span class="string">'SMTPjyiqwhzlSMTP'</span>;  <span class="comment">// 你的 SMTP 密码</span></span><br><span class="line">    $phpmailer-&gt;SMTPSecure = <span class="string">'ssl'</span>;               <span class="comment">// 加密类型，使用 ssl</span></span><br><span class="line">    $phpmailer-&gt;From       = <span class="string">'707070901@qq.com'</span>;  <span class="comment">// 发件人地址</span></span><br><span class="line">    $phpmailer-&gt;FromName   = <span class="string">'Your Name'</span>;         <span class="comment">// 发件人姓名</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add_action( <span class="string">'phpmailer_init'</span>, <span class="string">'configure_smtp'</span> );</span><br></pre></td></tr></table></figure><p>一测试发邮件，网站崩溃了，最后在开头加了一句 <code>use PHPMailer\PHPMailer\PHPMailer;</code> 问题解决</p><h3 id="正式修改"><a href="#正式修改" class="headerlink" title="正式修改"></a>正式修改</h3><p>后来我又到正式的WordPress上修改，这次为6.2.4版本，但是这个WordPress主题是自定义的，我没找到 <code>functions.php</code>，ChatGPT又给我出了主意，让我自己创建一个我没听，而是采用了他说的另一种方法，使用 mu-plugins 文件夹，如果你确保这段代码始终运行（甚至在你切换主题时），可以使用 WordPress 的 mu-plugins 机制（”must-use plugins”）。</p><p>在/var/www/sanctus-senki.com/cms/wp-content/下新建文件夹 <code>mu-plugins</code></p><p>在这个文件夹下新建文件 <code>custom-smtp.php</code> 编写下面内容，这个版本不能在开头加 <code>use PHPMailer\PHPMailer\PHPMailer;</code>代码段，否则报错</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">// Custom SMTP configuration for WordPress</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">configure_smtp</span><span class="params">( PHPMailer $phpmailer )</span> </span>&#123;</span><br><span class="line">    $phpmailer-&gt;isSMTP();</span><br><span class="line">    $phpmailer-&gt;Host       = <span class="string">'smtp.qq.com'</span>;       <span class="comment">// 你的 SMTP 服务器</span></span><br><span class="line">    $phpmailer-&gt;SMTPAuth   = <span class="keyword">true</span>;</span><br><span class="line">    $phpmailer-&gt;Port       = <span class="number">465</span>;                 <span class="comment">// SMTP 端口，465 是 SSL 的常用端口</span></span><br><span class="line">    $phpmailer-&gt;Username   = <span class="string">'707070901@qq.com'</span>;  <span class="comment">// 你的 SMTP 用户名</span></span><br><span class="line">    $phpmailer-&gt;Password   = <span class="string">'SMTPjyiqwhzlSMTP'</span>;  <span class="comment">// 你的 SMTP 密码</span></span><br><span class="line">    $phpmailer-&gt;SMTPSecure = <span class="string">'ssl'</span>;               <span class="comment">// 加密类型，使用 ssl</span></span><br><span class="line">    <span class="comment">//$phpmailer-&gt;From       = '707070901@qq.com';// 发件人地址（这里不强制发件人可以显示转发哦）</span></span><br><span class="line">    $phpmailer-&gt;FromName   = <span class="string">'Your Name'</span>;         <span class="comment">// 发件人姓名</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add_action( <span class="string">'phpmailer_init'</span>, <span class="string">'configure_smtp'</span> );</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>好了，这件事告一段落了，大道至简，经历了由简到繁，由繁化简的历程，才明白简约的可贵。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>AWS Route53 提供高度可用的 DNS 解析服务，将域名映射到 AWS 资源或其他 IP 地址</li><li>ACM 支持免费申请 <strong>公有 SSL/TLS 证书</strong>，用于保护基于 HTTPS 协议的流量</li><li>AWS ELB（Elastic Load Balancing）是AWS提供的一项负载均衡服务，主要分为ALB、NLB、CLB，旨在自动分配进入应用程序的流量，以确保高可用性和可靠性</li><li>Linux系统下 <code>mail</code> 是一个邮件客户端，用于发送和接收邮件，<code>sendmail</code> 和 <code>postfix</code> 是邮件传输代理（MTA），主要用于处理邮件的发送和接收</li><li>自 2020 年 1 月 7 日起，Amazon EC2 开始限制默认情况下通过端口 25 的电子邮件流量</li><li>记住WordPress的 <code>MW WP WPForm</code>、<code>WP MIAL SMTP</code>、<code>Easy WP SMTP</code> 插件，你或许以后用的上</li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/142427271" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p> 过钢者易折，善柔者不败</p><p>不必为人性感到意外，哪个人强大了不对弱者动武，哪个女人漂亮了不被男人惦记，<br>利刃在手，易起杀心，权大无边，总想乱来</p><p>2024-9-26 20:26:55</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;前段时间不是在&lt;a href=&quot;https://blog.csdn.net/albertsh/article/details/142427271&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;迁移AWS&lt;/a&gt;嘛，采用了分享AMI的方式，废了九牛二虎之力，终于在没有密钥的情况下成功登录了转移后的EC2实例，那么我们肯定不单单是为了转移一个EC2实例而大费周章，实际目的还是为了里面的数据和服务，具体来说就是一套WordPress网站，对于一个新的知识和事物围绕它的有很多知识点，一旦发散的过快就发现东西太多了，什么也讲不明白，造成虎头蛇尾的现象，做技术内容输出的人经常有这种力不从心的感觉。&lt;/p&gt;
    
    </summary>
    
      <category term="Practical" scheme="http://AlbertGithubHome.github.io/blog/categories/Practical/"/>
    
    
      <category term="aws" scheme="http://AlbertGithubHome.github.io/blog/tags/aws/"/>
    
      <category term="ALB" scheme="http://AlbertGithubHome.github.io/blog/tags/ALB/"/>
    
      <category term="Route53" scheme="http://AlbertGithubHome.github.io/blog/tags/Route53/"/>
    
      <category term="WordPress" scheme="http://AlbertGithubHome.github.io/blog/tags/WordPress/"/>
    
      <category term="ACM" scheme="http://AlbertGithubHome.github.io/blog/tags/ACM/"/>
    
      <category term="postfix" scheme="http://AlbertGithubHome.github.io/blog/tags/postfix/"/>
    
  </entry>
  
  <entry>
    <title>AWS镜像迁移登录问题二三则</title>
    <link href="http://AlbertGithubHome.github.io/blog/2024/09/22/AWS%E9%95%9C%E5%83%8F%E8%BF%81%E7%A7%BB%E7%99%BB%E5%BD%95%E9%97%AE%E9%A2%98%E4%BA%8C%E4%B8%89%E5%88%99/"/>
    <id>http://AlbertGithubHome.github.io/blog/2024/09/22/AWS镜像迁移登录问题二三则/</id>
    <published>2024-09-21T16:26:14.000Z</published>
    <updated>2024-09-28T07:21:26.652Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>关于云服务器之前用的多的还是国内的阿里云和腾讯云，也用过一点点的华为云，而今年接触的AWS和GCP比较多，使用场景渐渐多了起来，遇到的问题也渐渐多了起来，之前这些都是有专门的运维同事负责的，而现在降本增效之后只能自己上了，这两条在捣鼓AWS，就先记录一些AWS上遇到的问题和解决办法吧，关于问题我尽量贴一些原始的报错，便于有相同问题的人进行对照。</p><a id="more"></a><h1 id="EC2镜像迁移"><a href="#EC2镜像迁移" class="headerlink" title="EC2镜像迁移"></a>EC2镜像迁移</h1><p>此文章的本意是记录遇到的问题和解决办法，所以我在这不会详细描述怎样做镜像，自己去搜索文档吧，要实在找不到可以留言等有空我帮你找下，说说镜像有什么用，在AWS中的系统镜像被称为AMI，全称Amazon Machine Image，可以简单的连接为操作系统，不过要更好用一些。</p><p>现实中我们买一台新电脑是先挑硬件组装好，然后安装操作系统，Windows、Linux都可以，如果是云服务器比如AWS，也是先选配置比如CPU、内存、硬盘等等，然后选择一个AMI就可以安装使用了，如果你操作很熟练的话，大概几秒钟就可以得到一台可以立即使用的特定配置的云服务器。</p><p>这里的镜像可以选择官方Windows、Linux、Mac等官方支持的系统，也可以选择第三方的，甚至是自己可以定制的，比如你的项目大量使用Ubuntu+XXX的机器，每次创建Ubuntu实例后都要安装XXX软件，这就很麻烦，你可以使用安装好XXX的实例创建映像，保存下来，以后创建新的实例时直接使用这个AMI就很方便了，有点像Docker，但这比Docker要重度一些。</p><p>而我使用这个映像的情景是项目的迁移，将AWS实例从一个账号迁移到另一个账号，这里有几个问题需要注意：</p><ol><li>AMI可以分享，但只能在同一个区域内，如果跨区域只能先复制到同区域再进行分享</li><li>使用AMI镜像时需要分配大于制作镜像时磁盘大小，所以在创建实例时磁盘应该尽可能合理，否则分配了100G实际只用3G，那么用这个AMI最少也要分配100G才行</li><li>使用共享AMI先要浏览获取基础映像的授权，我在这遇到了一个问题，选择了另一个账号的AMI，但是启动失败，提示错误如下：</li></ol><blockquote><p>In order to use this AWS Marketplace product you need to accept terms and subscribe. To do so please visit <a href="https://aws.amazon.com/marketplace/pp?sku=aw0evgkw8e5c1q413zgy5pjce" target="_blank" rel="noopener">https://aws.amazon.com/marketplace/pp?sku=aw0evgkw8e5c1q413zgy5pjce</a></p></blockquote><p>其实你访问提供的<a href="https://aws.amazon.com/marketplace/pp?sku=aw0evgkw8e5c1q413zgy5pjce" target="_blank" rel="noopener">链接</a>会看到产品的详细信息和定价。你需要阅读并接受产品条款，然后点击“Continue”或类似的按钮完成订阅。之后你就可以返回 AWS 管理控制台，再次尝试启动实例，这时候应该可以成功启动。</p><h1 id="无法登录古老的AWS实例"><a href="#无法登录古老的AWS实例" class="headerlink" title="无法登录古老的AWS实例"></a>无法登录古老的AWS实例</h1><p>无法登录的原因，并不一定是因为AWS出问题了，AWS本身出问题不能说完全没有，但是这种情况概率比较小，来聊聊我遇到的情况。</p><p>接手别的项目组的AWS，密钥已经无法找到，这种情况我已经遇到了两次，都是经了几手的项目，密钥早已经找不到了，我们知道这个密钥只能在创建时下载一次，丢了就几乎无法再登录这个实例了，很多时候需要删除重建了。</p><p>为什么说几乎呢？因为没有密钥也不是完全没有办法再登录进去，我在这走了很多弯路，你可以先检测一下这几个问题，对你或许有帮助</p><ol><li>再找找原来的密钥，如果能找到这是最方便的途径</li><li>使用AWS网站后台的“连接”按钮，来直连实例</li><li>检查实例的安全规则，看看22端口是否放行，是否使用其他端口来运行ssh服务了</li></ol><p>查询端口是否连通的办法有 <code>telnet ip port</code> 或 <code>nmap -p port ip</code> 等多种办法</p><p>前两种方法我都试了行不通，而第三种遇到问题时还没意识到，所以我使用了“必杀技”，将无法连接的实例硬盘分离，然后挂载到其他可以登录的实例，然后挂载修改ssh密钥，再挂载回去重新登录即可，挂载到其他实例的命令如下，根据实际情况调整</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir /mnt/temp</span><br><span class="line">sudo mount /dev/xvdb1 /mnt/temp</span><br></pre></td></tr></table></figure><p>这时你可能会遇到报错，提示你挂载报错，大概率是UUID重复了，可以修改挂载命令 <code>sudo mount -o nouuid /dev/xvdb1 /mnt/temp</code></p><p>但我修改后还是不能登录，后来发现端口22不通，我一度以为这个实例没有启动ssh服务，尝试了多种方法，走了很多弯路，比如 <code>chroot</code> 或者修改用户数据添加启动ssh命令的脚本但都没有效果，最终发现是ssh服务器被改到了2022端口，废了九牛二虎之力终于可以访问ssh服务了，但还是认证失败</p><p>ssh登录时添加 <code>-vvv</code> 选项，输出以下关键调试信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">debug3: send packet: type 50</span><br><span class="line">debug2: we sent a publickey packet, wait for reply</span><br><span class="line">debug3: receive packet: type 51</span><br><span class="line">debug1: Authentications that can continue: publickey,gssapi-keyex,gssapi-with-mic</span><br><span class="line">debug2: we did not send a packet, disable method</span><br></pre></td></tr></table></figure><p>关键是 <code>receive packet: type 51</code> 这一句表示publickey验证失败，如果能登录这里应该是 <code>receive packet: type 52</code>，原因大概率就是publickey出了问题，我是因为没把publickey放到服务器上，不过我也很奇怪，创建实例时明明选了密钥，可能因为一开始启动报错就没放上去，导致了后面一系列弯路</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>AWS 和 GCP 是全球主流的云服务，Microsoft 的 Azure至今还没用过</li><li>如果想重用一个云服务环境，可以将这个实例创建成一个AMI保存</li><li>如果无法登录实例看看安全规则有没有换ssh的端口</li><li>如果密钥真的丢了就把实例的硬盘挂载到其他的实例上修改密钥吧</li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/141725939" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p> 你我皆凡人，生在人世间。终日奔波苦，一刻不得闲。既然不是仙，难免有杂念。道义放两旁，利字摆中间~</p><p>无德无行而取厚利，必有奇祸；善行善德而受磨难，必有后福；修德以配位，自谦以远祸。以色相交者，色衰而爱弛；以利相交者，利尽而交疏；以势相交者，势倾而交绝；以道相交者，天荒而地老；以德相交者，地久而天长；你用什么吸引人，你吸引的就是什么样的人。</p><p>2024-9-22 00:10:51</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;关于云服务器之前用的多的还是国内的阿里云和腾讯云，也用过一点点的华为云，而今年接触的AWS和GCP比较多，使用场景渐渐多了起来，遇到的问题也渐渐多了起来，之前这些都是有专门的运维同事负责的，而现在降本增效之后只能自己上了，这两条在捣鼓AWS，就先记录一些AWS上遇到的问题和解决办法吧，关于问题我尽量贴一些原始的报错，便于有相同问题的人进行对照。&lt;/p&gt;
    
    </summary>
    
      <category term="Practical" scheme="http://AlbertGithubHome.github.io/blog/categories/Practical/"/>
    
    
      <category term="aws" scheme="http://AlbertGithubHome.github.io/blog/tags/aws/"/>
    
      <category term="云计算" scheme="http://AlbertGithubHome.github.io/blog/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
      <category term="AMI" scheme="http://AlbertGithubHome.github.io/blog/tags/AMI/"/>
    
      <category term="ssh" scheme="http://AlbertGithubHome.github.io/blog/tags/ssh/"/>
    
      <category term="密钥丢失" scheme="http://AlbertGithubHome.github.io/blog/tags/%E5%AF%86%E9%92%A5%E4%B8%A2%E5%A4%B1/"/>
    
      <category term="mount" scheme="http://AlbertGithubHome.github.io/blog/tags/mount/"/>
    
  </entry>
  
  <entry>
    <title>在Supabase创建用户登录并获取token的操作实践</title>
    <link href="http://AlbertGithubHome.github.io/blog/2024/08/31/%E5%9C%A8Supabase%E5%88%9B%E5%BB%BA%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95%E5%B9%B6%E8%8E%B7%E5%8F%96token%E7%9A%84%E6%93%8D%E4%BD%9C%E5%AE%9E%E8%B7%B5/"/>
    <id>http://AlbertGithubHome.github.io/blog/2024/08/31/在Supabase创建用户登录并获取token的操作实践/</id>
    <published>2024-08-30T16:30:00.000Z</published>
    <updated>2024-09-28T07:18:37.547Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>网站是我今年加点儿比较重的技能，另一项是物理机与云主机，既要接网线做系统换硬盘，又要对比多个运营商买点互联网基础服务，反正截止到现在来看今年过的有些不一样，小游戏的兴起预示着前端快速出demo的时代到来，看看市场上对游戏后端的招聘的寥寥岗位，或许服务器开发正在迎来冰点，今天不聊游戏，我们来看看网站开发的相关内容。</p><a id="more"></a><p>说起网站开发，这算是大学软件工程里专业里比较拿的出手的产品了，毕竟真的可以从头做一个网站，虽然简陋但五脏俱全，是一项真真正正的计算机技能，从最原始的html，到ASP、jSP，我那时都是有所涉猎的，毕业之后便从事了游戏开发，网站这条路也就放下了。</p><p>到后来写博客，自己折腾hexo静态站，github pages等等，又接触了图床、云主机、域名、SSL证书、网站备案等等，虽然学的不是主流开发技术，但是一直和网站是有点联系的，在我看来静态网站是比较好弄的，大多数是将创作内容编译成html文件，放到互联网上供人们访问就好了，即使样式做出花来，也缺乏交互的部分，比如静态站的聊天一定得引入第三方插件来维护才行，要想做动态站一定得引入后端，引入一个非html语言来写后端的逻辑，最常见的就是访问数据库、登录验证等等，说到网站后端我除了用ASP、JSP写过，也就是C#和Java，后来还用C语言、Python、Golang、JavaScript写过，我的思维还一直停留在这。</p><h1 id="初识Supabase"><a href="#初识Supabase" class="headerlink" title="初识Supabase"></a>初识Supabase</h1><p>当我接触了supabase以后我发现一切都变了，使用它根本就不需要网站后端来编写什么查询数据和登录鉴权的逻辑，这些操作都可以由前端完成，这是把网站后端吃饭的碗给砸了呀，说到supabase就不得不提到Vercel以及Nextjs，最近几年Nodejs大火，大有统一前后端铸就全栈之势，Vercel和Nextjs就是在Nodejs上发展起来的，起初我以为Nextjs和Hexo类似，都是生成的一些静态站点页面的，但随着学习的深入它这是把前后端的开发都包了呀，编写好的页面可以根据需要选择在服务器执行还是客户端执行，有一段时间我觉得它和Gin等go语言的web框架很像，由go语言完成后端逻辑和前端页面的编写，但仔细对比下来还是不同的，go语言编写的网站总的来说都运行在服务端，前端表现有些弱，而Nodejs这一套写下来完成分不出来哪是前端，哪是后端，放在哪运行完全看你的需要，想要交互多一点就放前端，想要安全认证多一些就放后端。</p><p>虽然Nodejs的框架Nextjs有后端的概念，但是如果引入了supabase作为项目后端的存储，那么像登录鉴权这些通用需求完全不用编写后端的逻辑，supabase自带的，你敢相信？</p><p>supabase自带文件存储和数据库，虽然Vercel本身也带这些，但是supabase更胜一筹，它提出实现了 RLS（Row-Level Security）规则，这是Supabase中的一种安全机制，用于限制特定用户对数据库表中行的访问权限。</p><p>在Supabase中，可以使用RLS规则来定义哪些用户可以访问或修改特定的数据行。这些规则可以基于用户的标识符、角色或其他属性进行设置。通过定义RLS规则，您可以确保只有符合规则的用户才能访问或修改相应的数据行，从而保护数据的隐私和完整性。</p><p>例如，你可以创建一个RLS规则，只允许管理员访问某个表的所有数据，而普通用户只能访问他们自己的数据行。这样，你可以根据不同的用户角色和需求来定制数据库的访问权限。这样说有些懵，可以举个具体的例子，比如网站上你的个性签名存放在一个Table表里，这个表允许所有注册的用户来插入，每个人插入自己的个性签名这没有问题，当要修改签名时你只能修改归属于你这个用户的行，这样就保证了数据的安全性，并且这些插入和更新的操作都可以在前端的代码里来写，而不用像以往的网站开发那样，将数据表单发送到后端在通过后端更新数据库。</p><h1 id="使用Supabase"><a href="#使用Supabase" class="headerlink" title="使用Supabase"></a>使用Supabase</h1><p>接下来通过一个实例感受一下，这些内容<a href="https://supabase.com/docs/reference/python/introduction" target="_blank" rel="noopener">官方文档</a>大部分都有，感兴趣的可以取翻一翻，我一般使用python写工具，下面主要用python的API来举例，比如说注册用户:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> supabase <span class="keyword">import</span> create_client, Client</span><br><span class="line"></span><br><span class="line">url: str = <span class="string">"https://vtarqsksexgmfbotqnve.supabase.co"</span></span><br><span class="line">key: str = <span class="string">"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InZ0YXJxc2tzZXhnbWZib3RxbmN3Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3MjA2ODIxODcsImV4cCI6MjAzNjI1ODE4N30.72bccRrlebY8rDTbVjYX5hlzhvU1llO96JDhLNZvN88"</span></span><br><span class="line">supabase: Client = create_client(url, key)</span><br><span class="line"></span><br><span class="line">response = supabase.auth.sign_up(</span><br><span class="line">    credentials=&#123;<span class="string">"email"</span>: <span class="string">"myname@qq.com"</span>, <span class="string">"password"</span>: <span class="string">"my-pwd"</span>&#125;</span><br><span class="line">)</span><br><span class="line">print(response)</span><br></pre></td></tr></table></figure><p>这段代码就完成了用户注册的逻辑，前端就能完成，url是supabase提供的项目地址，key是这个项目的<code>anon key</code>，这个key是public的可以放在前端页面里用于验证项目信息，当然很多网站不用python来写，使用js同样可以轻松完成这项任务</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createClient &#125; <span class="keyword">from</span> <span class="string">'@supabase/supabase-js'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a single supabase client for interacting with your database</span></span><br><span class="line"><span class="keyword">const</span> supabase = createClient(<span class="string">'https://vtarqsksexgmfbotqnve.supabase.co'</span>, <span class="string">'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InZ0YXJxc2tzZXhnbWZib3RxbmN3Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3MjA2ODIxODcsImV4cCI6MjAzNjI1ODE4N30.72bccRrlebY8rDTbVjYX5hlzhvU1llO96JDhLNZvN88'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; data, error &#125; = <span class="keyword">await</span> supabase.auth.signUp(&#123;</span><br><span class="line">  email: <span class="string">'myname@qq.com'</span>,</span><br><span class="line">  password: <span class="string">'my-pwd'</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>以上是注册部分，使用 <code>anon key</code> 就可以完成，但是当你需要插入数据或更新数据时，假如数据要求认证用户才能操作，这就需要你获取一个证明你身份的token，看起来就像JWT，代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> supabase <span class="keyword">import</span> create_client, Client</span><br><span class="line"></span><br><span class="line">url: str = <span class="string">"https://vtarqsksexgmfbotqnve.supabase.co"</span></span><br><span class="line">key: str = <span class="string">"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InZ0YXJxc2tzZXhnbWZib3RxbmN3Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3MjA2ODIxODcsImV4cCI6MjAzNjI1ODE4N30.72bccRrlebY8rDTbVjYX5hlzhvU1llO96JDhLNZvN88"</span></span><br><span class="line">supabase: Client = create_client(url, key)</span><br><span class="line"></span><br><span class="line">data = supabase.auth.sign_in_with_password(&#123;<span class="string">"email"</span>: <span class="string">"myname@qq.com"</span>, <span class="string">"password"</span>: <span class="string">"my-pwd"</span>&#125;)</span><br><span class="line">print(data)</span><br></pre></td></tr></table></figure><p>JavaScript版本如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createClient &#125; <span class="keyword">from</span> <span class="string">'@supabase/supabase-js'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a single supabase client for interacting with your database</span></span><br><span class="line"><span class="keyword">const</span> supabase = createClient(<span class="string">'https://vtarqsksexgmfbotqnve.supabase.co'</span>, <span class="string">'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InZ0YXJxc2tzZXhnbWZib3RxbmN3Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3MjA2ODIxODcsImV4cCI6MjAzNjI1ODE4N30.72bccRrlebY8rDTbVjYX5hlzhvU1llO96JDhLNZvN88'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; data, error &#125; = <span class="keyword">await</span> supabase.auth.signInWithPassword(&#123;</span><br><span class="line">  email: <span class="string">'myname@qq.com'</span>,</span><br><span class="line">  password: <span class="string">'my-pwd'</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>有些情况下使用Restful API更方便</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">curl -X POST <span class="string">'https://vtarqsksexgmfbotqnve.supabase.co/auth/v1/token?grant_type=password'</span> \</span><br><span class="line">-H <span class="string">"apikey: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InZ0YXJxc2tzZXhnbWZib3RxbmN3Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3MjA2ODIxODcsImV4cCI6MjAzNjI1ODE4N30.72bccRrlebY8rDTbVjYX5hlzhvU1llO96JDhLNZvN88"</span> \</span><br><span class="line">-H <span class="string">"Content-Type: application/json"</span> \</span><br><span class="line">-d <span class="string">'&#123;</span></span><br><span class="line"><span class="string">  "email": "myname@qq.com",</span></span><br><span class="line"><span class="string">  "password": "my-pwd",</span></span><br><span class="line"><span class="string">&#125;'</span></span><br></pre></td></tr></table></figure><p>tokne默认3600，我没找到自定义有效时间的方式，但是找到了刷新token的方式，可以按照下面的格式刷新token，这样你可以获得新的token</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">curl -X POST <span class="string">'https://vtarqsksexgmfbotqnve.supabase.co/auth/v1/token?grant_type=refresh_token'</span> \</span><br><span class="line">-H <span class="string">"apikey: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InZ0YXJxc2tzZXhnbWZib3RxbmN3Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3MjA2ODIxODcsImV4cCI6MjAzNjI1ODE4N30.72bccRrlebY8rDTbVjYX5hlzhvU1llO96JDhLNZvN88"</span> \</span><br><span class="line">-H <span class="string">"Content-Type: application/json"</span> \</span><br><span class="line">-d <span class="string">'&#123;</span></span><br><span class="line"><span class="string">  "refresh_token": "6wFEh3rwgRzdM_VGHK3OJg"</span></span><br><span class="line"><span class="string">&#125;'</span></span><br></pre></td></tr></table></figure><p>有了登录的token就可以调用supabase的各种接口来操作数据啦，比如创建一个桶，上传一个文档，获取某个表的全部数据等等，supabase的接口客户端支持多种语言，但是Restful API就不太全，不知道什么原因，可能是我没有找对地方。</p><h1 id="Supabase经验之谈"><a href="#Supabase经验之谈" class="headerlink" title="Supabase经验之谈"></a>Supabase经验之谈</h1><p>我是一个supabase新手，在使用过程中积累了一点点经验，有些东西是网上查来的，有些是官网文档里看来的，不得不说这官方文档写的是真棒，但有些东西查文档很难定位，还是需要实际操作，比如怎样修改Project API keys，在后台 <code>Project API keys</code> 这个区域并没有修改和重新生成的按钮，通过时间发现，重新生成一个<code>JWT secret</code> 后， <code>anon key</code> 和 <code>service_role key</code> 就都跟着变了，看官方操作提示：</p><blockquote><p>Confirm to generate a new JWT secret</p><p>This will invalidate all existing API keys</p><p>Generating a new JWT secret will invalidate all of your API keys, including your service_role and anon keys. Your project will also be restarted during this process, which will terminate any existing connections. You may receive API errors for up to 2 minutes while the new secret is deployed.</p><p>This action cannot be undone and the old JWT secret will be lost. All existing API keys will be invalidated, and any open connections will be terminated.</p></blockquote><p>而关于<code>anon key</code> 和 <code>service_role key</code>使用注意事项，其实一直都在这两个 key 的旁边写着，我还到处查资料，甚至做了很多实验来验证，虽然多花了些时间，但记忆更深一些：</p><h3 id="anon-public"><a href="#anon-public" class="headerlink" title="anon public"></a>anon public</h3><blockquote><p>This key is safe to use in a browser if you have enabled Row Level Security for your tables and configured policies.</p></blockquote><h3 id="service-role-secret"><a href="#service-role-secret" class="headerlink" title="service_role secret"></a>service_role secret</h3><blockquote><p>This key has the ability to bypass Row Level Security. Never share it publicly.</p></blockquote><p>总结来说 <code>anon key</code> 能放在浏览器不用担心泄露，可以查询符合RLS规则的数据，而 <code>service_role key</code> 一定要保管好，它可以绕过RLS规则，或者数据的完全控制权限。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>不管是游戏行业还是网站开发，单纯的后端开发人员正在慢慢缩减走向淘汰，可以转前端也可以走全栈</li><li>supabase的使用可以一定程度上去掉单独的后端逻辑，鉴权和数据获取完全交给前端和supabase配合</li><li>使用supabase需要用到<code>Project API keys</code>，这包括<code>anon key</code> 和 <code>service_role key</code></li><li><code>anon key</code> 可以暴露给任何人，所以放到前端页面中下载到用户浏览器也没有关系</li><li><code>service_role key</code> 一定要保管好，它拥有着对整个项目的控制权，完全不遵守 RLS 规则</li><li>RLS（Row-Level Security）规则是Supabase中的一种安全机制，用于限制特定用户对数据库表中行的访问权限</li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/141200033" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p> 如果你想活成你自己，就不要在乎别人说什么，且当他人之凝视如盏盏鬼火，大胆的走你的夜路，待你功成名就之时，自有大儒替你辨经</p><p>2024-8-30 19:51:50</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;网站是我今年加点儿比较重的技能，另一项是物理机与云主机，既要接网线做系统换硬盘，又要对比多个运营商买点互联网基础服务，反正截止到现在来看今年过的有些不一样，小游戏的兴起预示着前端快速出demo的时代到来，看看市场上对游戏后端的招聘的寥寥岗位，或许服务器开发正在迎来冰点，今天不聊游戏，我们来看看网站开发的相关内容。&lt;/p&gt;
    
    </summary>
    
      <category term="Web" scheme="http://AlbertGithubHome.github.io/blog/categories/Web/"/>
    
    
      <category term="supabse" scheme="http://AlbertGithubHome.github.io/blog/tags/supabse/"/>
    
      <category term="anonkey" scheme="http://AlbertGithubHome.github.io/blog/tags/anonkey/"/>
    
      <category term="service_role" scheme="http://AlbertGithubHome.github.io/blog/tags/service-role/"/>
    
      <category term="RLS" scheme="http://AlbertGithubHome.github.io/blog/tags/RLS/"/>
    
      <category term="token" scheme="http://AlbertGithubHome.github.io/blog/tags/token/"/>
    
      <category term="鉴权" scheme="http://AlbertGithubHome.github.io/blog/tags/%E9%89%B4%E6%9D%83/"/>
    
  </entry>
  
  <entry>
    <title>记一次购买希捷二手盘并挂载到WSL2上的经历</title>
    <link href="http://AlbertGithubHome.github.io/blog/2024/08/15/%E8%AE%B0%E4%B8%80%E6%AC%A1%E8%B4%AD%E4%B9%B0%E5%B8%8C%E6%8D%B7%E4%BA%8C%E6%89%8B%E7%9B%98%E5%B9%B6%E6%8C%82%E8%BD%BD%E5%88%B0WSL2%E4%B8%8A%E7%9A%84%E7%BB%8F%E5%8E%86/"/>
    <id>http://AlbertGithubHome.github.io/blog/2024/08/15/记一次购买希捷二手盘并挂载到WSL2上的经历/</id>
    <published>2024-08-14T17:00:00.000Z</published>
    <updated>2024-09-28T07:16:24.124Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>事情的起因是上一个合作的运维小伙伴告诉我不要过分依赖Raid5，他每周要从机房更换10几块坏掉的Dell服务器硬盘，最好准备几块大容量硬盘做额外的数据备份，一般是1主2备，刚开始接触这块准备先搞一个备份盘，毕竟有Raid5可以在前面顶一顶，主要还是因为穷，哈哈。</p><a id="more"></a><h1 id="采购"><a href="#采购" class="headerlink" title="采购"></a>采购</h1><p>一开始从某多上看了一些成品移动硬盘，大品牌太贵，小品牌价格可以但是不知道是否靠谱，最后搜到了Seagate Exos系列，作为希捷的银河系列，专为数据中心、企业级存储和高负载环境设计的，具有高容量、高性能和高可靠性，品牌应该值得信赖，但是全新的还是太贵，一块12T的全新盘大概要2100大洋，最后我转向了二手拆机盘。</p><p>购买的过程就是比价，差评哪里都有，找一个销量多又便宜的就下手了，大概600块拿下，价格还是真香的，但是二手盘水太深了，盘买回来以后还是需要检测一下。</p><h1 id="检测"><a href="#检测" class="headerlink" title="检测"></a>检测</h1><p>使用希捷专门的工具Sea Tools可以查序列号，通电时间等，打开软件检查通电时间为0，看来硬盘数据被刷过了，序列号也对不上了，然后在希捷的官网，输入硬盘标签上的序列号，提示硬盘作为系统一部分出售的，不提供单独的保修，那么基本可以断定是希捷官方的OEM盘，也就是从品牌机上拆下来，刷掉了硬盘使用数据，勉强可以接受吧。</p><p>接着使用 HD Tune Pro 5.75 查看硬盘信息，序列号是对的，<code>Error Scan</code> 用了将近18个小时，也没发现坏道，读取速度200M/s左右，姑且就这么认为安全的下车了，但是一直也没看到这款硬盘的生产日期，通电时间还被刷成了0，拆机盘不单独保修所以通过序列号也查不出生产日期。</p><p>后来通过HD Tune Pro给出的信息 <code>Frimware G006</code> 来推断固件版本 6.0 在 2018 年左右可能开始发布，这块盘大概率是18年以后的，要问我为什么不直接看硬盘标签上的生产日期，因为商家用一个保修贴着故意把那个位置帖死了，撕毁无效，你说气不气人。</p><p>可是看不到生产日期总觉得心里不踏实，所以第二天我找了把小刀悄悄把贴纸取下了，后面内容写着 <code>DOM: 08JUN2019 Product of Thailand</code>，好吧，2019年6月，这硬盘还不是太老，电子设备上的 <code>DOM</code> 通常代表 <strong>Date of Manufacture</strong>（制造日期），它标识了设备的生产日期，我们姑且认为他是真的。</p><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>说到数据备份，我那几台服务器都是Linux，硬盘文件系统为 <code>ext4</code>，而之前我问了一些成品移动硬盘根本就不支持，我也没有额外的Linux系统的机器，适应windows系统备份linux的数据把文件属性不兼容，所以想了一招折中的法子，找一台一直开机的windows机器，安装WSL2，在WSL2安装Ubuntu来执行rsync命令完成数据的备份</p><p>在硬盘收到之前我已经用NTFS格式的U盘测试过了，有些符号链接同步到NTFS格式的U盘上虽然打不开，但是再同步回Linux系统下的ext4硬盘上就可正常使用了，所以通过WSL2将Linux系统ext4硬盘上的数据备份到NTFS系统上是可行的，所以我用USB连接了新买的硬盘，开始同步数据，下面直接给出操作命令</p><ol><li>创建目录 <code>/mnt/e</code>，原因是新插入的硬盘不会自动挂载，需要手动创建目录挂载</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir -p /mnt/e</span><br></pre></td></tr></table></figure><ol><li>修改目录权限，默认为root，设置为正常使用的用户</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chown -R albert:albert /mnt/e</span><br></pre></td></tr></table></figure><ol><li>挂载E盘到 <code>/mnt/e</code> 并尽可能保留归属和权限，这个命令比较长，后面详细介绍每个参数，主要目的就是保留源文件的所有信息，比如归属、属性、时间戳等</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mount -t drvfs E: /mnt/e -o metadata -o uid=$(id -u),gid=$(id -g)</span><br></pre></td></tr></table></figure><ul><li><code>sudo</code> 用于以超级用户（root）的权限执行命令。这是因为挂载文件系统通常需要管理员权限。</li><li><code>mount</code> 是一个用于挂载文件系统的命令，将存储设备（如磁盘分区）或文件系统挂载到目录中，使其能够被访问。</li><li><code>-t</code> 参数指定挂载文件系统的类型。</li><li><code>drvfs</code> 是 WSL 中用于挂载 Windows 文件系统的驱动器的文件系统类型。这是 WSL 特有的文件系统类型，允许在 Linux 子系统中访问 Windows 驱动器。</li><li><code>E:</code> 指定要挂载的 Windows 驱动器。Windows 驱动器用字母（如 <code>C:</code>、<code>D:</code>、<code>E:</code> 等）来标识，这里 <code>E:</code> 代表 E 盘。</li><li><code>/mnt/e</code> 这是挂载点目录，即你希望将 Windows 驱动器挂载到 Linux 文件系统中的位置。在 WSL 中，通常将 Windows 驱动器挂载到 <code>/mnt</code> 下的相应目录，例如 <code>/mnt/e</code>。</li><li><code>-o metadata</code> 选项使得挂载的 Windows 文件系统能够支持 POSIX 文件权限和元数据。这对于 Linux 应用程序处理文件权限和所有权等元数据是必需的，否则属性都是777。</li><li><code>-o</code> 参数指定挂载选项。</li><li><code>uid=$(id -u)</code>：设置挂载文件系统中的文件和目录的用户 ID（UID），<code>$(id -u)</code> 会被替换为当前用户的 UID，否则都是root。</li><li><code>gid=$(id -g)</code>：设置挂载文件系统中的文件和目录的组 ID（GID），<code>$(id -g)</code> 会被替换为当前用户的 GID，否则都是root。</li></ul><ol><li>从服务器同步数据到本地</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">albert@qyg-pc:/mnt/e$ sudo rsync -av --delete root@10.0.10.10:/tmp/<span class="built_in">test</span> ./new-backup</span><br></pre></td></tr></table></figure><ol><li>其他常用cmd命令</li></ol><ul><li><code>wsl --terminate Ubuntu</code>： 关闭子系统实例</li><li><code>wsl -d Ubuntu</code>：启动子系统实例</li></ul><h1 id="突变"><a href="#突变" class="headerlink" title="突变"></a>突变</h1><p>事情进行到这里本来可以完美的结束了，但是我手贱的打开了软件 <code>CrystalDiskInfo</code>，发现新买的这块盘报警告了，而原装的两块跑了6年的盘一点问题也没有，警告信息为【<strong>警告[05] 重新分配扇区计数：8</strong>】，我用其他的几个软件比如 SeaTools、Victoria等查看都是这个数据，意思就是这个盘有8个扇区坏了，但是通过硬件的磁盘映射功能，已经将坏的位置指向了硬盘保留区，所以这种情况下没有检测出坏道。</p><p>其实我倒是不担心坏了这8个点，我担心的是这块硬盘的状态，已经坏了8个马上到临界值了，后面会不会马上突然坏一大片呢？我主要怕它突然寿终正寝啊，思来想去还是联系商家换一块吧，虽然新换的可能还不如这一块，但现在毕竟已经查出问题了，这么用下去心里很担心啊。干脆联系了售后，明天退回去再换一块好了，虽然商家的回复有点不情愿。</p><h1 id="关键参数"><a href="#关键参数" class="headerlink" title="关键参数"></a>关键参数</h1><p>因为一个参数我决定换货，顺便说几个其他比较重要的参数吧：</p><p>（05/005）重新分配扇区计数：显示当前有多少瑕疵的扇区被发现并重映射到了备用扇区。数据显示的就是成功被重映射的扇区数。如果数据不为0，状态一般显示为警告。大概率出现了坏道，但可能被修复了，建议退货。</p><p>（C4/196）重新分配事件计数：计算重映射操作数。这个数字记录了重映瑕疵射扇区到备用扇区的总数，包括了成功和未成功的总数。如果数据不为0，状态一般显示为警告。大概率出现了坏道，建议退货。</p><p>（C5/197）当前待映射扇区计数：显示当前有多少被怀疑瑕疵的扇区被发现等待重新验证，如果验证不通过就会进入重映射扇区。如果数据不为0，状态一般显示为警告。大概率出现了坏道，建议退货。</p><p>（C6/198）离线无法校正：显示无法修复的错误扇区总数，说明硬盘碟片或机械结构有问题。建议退货。</p><p>在论坛里已网友的回复听中肯，05和C5值不是0，闲鱼二手都卖不上价了，但凡你认为数据重要，就抓紧更换硬盘，不要赌；如果不在乎数据，那就继续用。</p><p>反正05值不是0就说明硬盘的存在坏点并且被映射解决了，可以正常用，性能下降一点点，但是当保留区域用完无法再未新坏点完成映射时，丢数据就是家常便饭了</p><p>我们怕的不是现在这几个坏点，而是担心硬盘使用到了一个极限值，后面快速垮掉了，但是也有可能继续使用个3年5年的还是这8个坏点，这也是有可能的。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li><code>Raid5</code> 对于数据安全并不完全保险，有精力和财力还是把重要数据多备几份</li><li>Seagate Exos系列，专为数据中心、企业级存储和高负载环境设计的，具有高容量、高性能和高可靠性，还不知道是不是真的靠谱</li><li>常用的硬盘检测工具有 <code>SeaTools</code>、<code>HD Tune Pro</code>、<code>CrystalDiskInfo</code> 和 <code>Victoria</code> 等</li><li>硬盘中的 <code>SMART</code> 信息中重点关注 <code>05</code>、<code>C4</code>、<code>C5</code>、<code>C6</code> 这几项，值不为0的话就有丢失数据的前兆了</li><li><code>sudo mount -t drvfs E: /mnt/e -o metadata -o uid=$(id -u),gid=$(id -g)</code> 注意挂载硬盘的参数</li><li>我就静静地等着我换回来的盘了，到手后再备份数据</li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/140936012" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>走在路的右边，望着左边的风景是那样的默认，虽然昨晚才刚刚从那边走过，人生呢？是不是也这样，未必经历过就会熟悉~</p><p>2024-8-14 20:44:22</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;事情的起因是上一个合作的运维小伙伴告诉我不要过分依赖Raid5，他每周要从机房更换10几块坏掉的Dell服务器硬盘，最好准备几块大容量硬盘做额外的数据备份，一般是1主2备，刚开始接触这块准备先搞一个备份盘，毕竟有Raid5可以在前面顶一顶，主要还是因为穷，哈哈。&lt;/p&gt;
    
    </summary>
    
      <category term="Practical" scheme="http://AlbertGithubHome.github.io/blog/categories/Practical/"/>
    
    
      <category term="Seagate" scheme="http://AlbertGithubHome.github.io/blog/tags/Seagate/"/>
    
      <category term="磁盘检测" scheme="http://AlbertGithubHome.github.io/blog/tags/%E7%A3%81%E7%9B%98%E6%A3%80%E6%B5%8B/"/>
    
      <category term="WSL2" scheme="http://AlbertGithubHome.github.io/blog/tags/WSL2/"/>
    
      <category term="SMART" scheme="http://AlbertGithubHome.github.io/blog/tags/SMART/"/>
    
      <category term="CrystalDiskInfo" scheme="http://AlbertGithubHome.github.io/blog/tags/CrystalDiskInfo/"/>
    
      <category term="HD-Tune-Pro" scheme="http://AlbertGithubHome.github.io/blog/tags/HD-Tune-Pro/"/>
    
      <category term="SeaTools" scheme="http://AlbertGithubHome.github.io/blog/tags/SeaTools/"/>
    
  </entry>
  
  <entry>
    <title>安装了Anaconda并简单使用了以后谈谈自己的理解</title>
    <link href="http://AlbertGithubHome.github.io/blog/2024/08/06/%E5%AE%89%E8%A3%85%E4%BA%86Anaconda%E5%B9%B6%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%E4%BA%86%E4%BB%A5%E5%90%8E%E8%B0%88%E8%B0%88%E8%87%AA%E5%B7%B1%E7%9A%84%E7%90%86%E8%A7%A3/"/>
    <id>http://AlbertGithubHome.github.io/blog/2024/08/06/安装了Anaconda并简单使用了以后谈谈自己的理解/</id>
    <published>2024-08-05T18:00:00.000Z</published>
    <updated>2024-09-28T07:09:48.676Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>因为需要使用多个版本的Python解释器，在寻找方案时找到了 <code>conda</code>,真正用过之后理解了conda所说的虚拟环境，Anaconda是一个创造小房间的工具，小房间内的主力环境可以是Python也可以是R。</p><a id="more"></a><h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><p>因为对Python相对熟悉，所以谈谈Python的使用，Python的新版本会更新很多内容，虽然基本上是向下兼容的，但是各种包的依赖不是说升级就能升级的，</p><p>特别是Python3.x和Python2.x简直就是两种语言，那么如果在一台电脑负责依赖两个不同版本的Python库时，就会很头疼，环境变量和依赖关系搞得人抓耳挠腮</p><p>而 conda 相当与提供了小房子搬的隔离，类似于VMWare Workstation的作用，比如我平时使用Windows开发，但是有个项目需要在Ununtu 16.04版本运行，怎么办？</p><p>我当然可以把系统换成Ununtu 16.04，但是如果不久又有新的项目需要在Ununtu 20.04下进行，我还要换系统吗？万一两个项目同时进行呢？</p><p>这时就可以利用VMWare创建一个个隔离的操作系统，在不同的虚拟机系统下完成对应系统项目的开发和运行</p><p>Python也有这样的问题，不同的Python版本安装了不同的Python库，想要不相互影响就得完成隔离。</p><p>Python 其实自带了一个 venv 模块，可以完成Python库的隔离，但是Conda更加强大，不仅隔离 Python 库，还可以隔离 C 库、二进制文件和其他依赖项。同时支持多种编程语言的环境管理，不仅限于 Python，还可以管理 R、Ruby 等语言的环境。</p><p>Conda 环境的 Python 解释器是独立的，可以与系统安装的 Python 解释器不同，这样就可以在不同的环境中使用不同版本的 Python。</p><p>Conda 可以启动不同的Python环境，不同的环境下可以安装不同的库和各种依赖版本，在特定环境下完成开发和测试任务。</p><h1 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h1><p>前面说的这些都是理论和个人理解，说说我为什么会找到 Conda 并使用它</p><p>我本地使用的是<code>Python 3.7.6</code>，最近在处理Supabase相关的事情，核心下载其项目中的Objects文件，暂时可以把它当成是一个OSS平台，客户端API中有我比较常用的Python语言，所以自然而然的使用Python来写下载数据的接口</p><p>但是通过 pip 安装的 <code>supabase</code> 库只有 <code>0.7.1</code>，执行示例代码时总是遇到一些符号问题，查官方的代码库已经 <code>2.6.0</code>了，差距有点大，一开始我想着把 <code>pip</code> 升级了，应该能获得一些库的新版本吧，但升级后无果。</p><p>然后就想到把Python升级了，但是我之前的很多工具都是在 <code>Python 3.7.6</code> 的环境下编写的，各种库以及依赖也是在这个环境下安装的，如果要把Python升级到最新的<code>Python 3.12.4</code> 可能导致我之前的脚本都出现问题。</p><p>所以在这种情况下我搜索能不能给我一个临时的 <code>Python 3.12</code> 的环境，我临时测一些问题，搞定后删掉就行，主力开发环境还是保留 <code>Python 3.7.6</code>，结果我就搜到了 Conda，以及 Conda 两种常用的发行版<strong>Anaconda</strong> 和 <strong>Miniconda</strong>，使用后发现它完全能满足我的要求。</p><p>利用 <code>Anaconda</code> 可以创建各个版本的 Python 解释器，每个解释器有相互隔离的环境，可以安装自己的库，针对每个环境启动不同的命令行工具</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">(conda-py-3-12-4) E:\opensource\supabase&gt;pip list</span><br><span class="line">Package           Version</span><br><span class="line">----------------- --------</span><br><span class="line">annotated-types   0.7.0</span><br><span class="line">anyio             4.4.0</span><br><span class="line">certifi           2024.7.4</span><br><span class="line">deprecation       2.1.0</span><br><span class="line">exceptiongroup    1.2.2</span><br><span class="line">gotrue            2.6.1</span><br><span class="line">h11               0.14.0</span><br><span class="line">h2                4.1.0</span><br><span class="line">hpack             4.0.0</span><br><span class="line">httpcore          1.0.5</span><br><span class="line">httpx             0.25.2</span><br><span class="line">hyperframe        6.0.1</span><br><span class="line">idna              3.7</span><br><span class="line">packaging         24.1</span><br><span class="line">pip               24.0</span><br><span class="line">postgrest         0.16.9</span><br><span class="line">pydantic          2.5.3</span><br><span class="line">pydantic_core     2.14.6</span><br><span class="line">python-dateutil   2.9.0</span><br><span class="line">realtime          1.0.0</span><br><span class="line">setuptools        69.5.1</span><br><span class="line">six               1.16.0</span><br><span class="line">sniffio           1.3.1</span><br><span class="line">storage3          0.7.7</span><br><span class="line">StrEnum           0.4.15</span><br><span class="line">supabase          2.6.0</span><br><span class="line">supafunc          0.5.1</span><br><span class="line">typing_extensions 4.12.2</span><br><span class="line">websockets        10.4</span><br><span class="line">wheel             0.43.0</span><br></pre></td></tr></table></figure><p>在这里我轻松的就安装上了 <code>supabase:2.6.0</code></p><p>Python 自带的虚拟环境（通过 venv 模块创建）对于大多数开发需求来说是非常好用的，venv 是 Python 内置的模块，不需要额外安装或配置，非常方便。适用于所有支持 Python 的操作系统，且与主流的包管理工具如 pip 完美兼容。</p><p>使用 venv 创建虚拟环境时，它会基于你当前系统中的 Python 解释器版本创建环境，因此 venv 本身不提供安装或管理不同 Python 版本的功能。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>Conda 支持多种编程语言的环境管理，不仅限于 Python，还可以管理 R、Ruby 等语言的环境</li><li>Conda 环境的 Python 解释器是独立的，可以多个版本的 Python 解释器</li><li>Python 其实自带了一个 venv 模块，对于大多数开发需求来说是非常好用的</li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/140835274" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>知其不可奈何而安之若命，是智慧还是无奈？她开心的对我说“北京真好”，是的，北京挺不错的，对于金钱数字的生物来说，这里是享受的天堂，应有尽有，偶尔还会给人一点小惊喜，难的是迈过金钱数字的这个坎，99.999%的物种还停留在坎的这一边</p><p>2024-8-5 21:37:46</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;因为需要使用多个版本的Python解释器，在寻找方案时找到了 &lt;code&gt;conda&lt;/code&gt;,真正用过之后理解了conda所说的虚拟环境，Anaconda是一个创造小房间的工具，小房间内的主力环境可以是Python也可以是R。&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="http://AlbertGithubHome.github.io/blog/categories/Python/"/>
    
    
      <category term="conda" scheme="http://AlbertGithubHome.github.io/blog/tags/conda/"/>
    
      <category term="python" scheme="http://AlbertGithubHome.github.io/blog/tags/python/"/>
    
      <category term="supabase" scheme="http://AlbertGithubHome.github.io/blog/tags/supabase/"/>
    
      <category term="Anaconda" scheme="http://AlbertGithubHome.github.io/blog/tags/Anaconda/"/>
    
      <category term="venv" scheme="http://AlbertGithubHome.github.io/blog/tags/venv/"/>
    
  </entry>
  
  <entry>
    <title>当Vercel的域名验证规则碰上JPDirect这种不配合的同学把我的脑袋擦出了火星子</title>
    <link href="http://AlbertGithubHome.github.io/blog/2024/08/01/%E5%BD%93Vercel%E7%9A%84%E5%9F%9F%E5%90%8D%E9%AA%8C%E8%AF%81%E8%A7%84%E5%88%99%E7%A2%B0%E4%B8%8AJPDirect%E8%BF%99%E7%A7%8D%E4%B8%8D%E9%85%8D%E5%90%88%E7%9A%84%E5%90%8C%E5%AD%A6%E6%8A%8A%E6%88%91%E7%9A%84%E8%84%91%E8%A2%8B%E6%93%A6%E5%87%BA%E4%BA%86%E7%81%AB%E6%98%9F%E5%AD%90/"/>
    <id>http://AlbertGithubHome.github.io/blog/2024/08/01/当Vercel的域名验证规则碰上JPDirect这种不配合的同学把我的脑袋擦出了火星子/</id>
    <published>2024-08-01T02:04:57.000Z</published>
    <updated>2024-09-28T07:06:53.883Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>处理域名转移这件事已经过去好几天，终于抽出点时间来总结一下，解决这件事大概花了2周多时间，因为时差的原因导致沟通缓慢，今天准备长话短说，省略掉中间的细枝末节，只讲讲遇到了什么问题，最后怎么解决的。</p><a id="more"></a><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>需要将域名 <code>xxx.com</code> 从A项目移动到B项目，一般来说项目和域名没有绑定关系，如果是两个项目部署在不同的服务器上，在域名提供商后台改一下域名绑定的IP就行，但是现在A项目和B项目都是部署在 <code>Vercel</code> 上的，当把原来绑定在A项目上的域名 <code>xxx.com</code> 添加到B项目时，要求在域名提供商后台添加一条 <code>TXT</code> 记录来验证B项目对其存在所有权，本来挺简单的一件事，但是碰上了这个域名提供商 <code>JPDirect</code> 不让添加特定格式的<code>TXT</code>记录，事情就僵在这里了，我很少发图片，这次为了说明问题贴两张</p><p><img src="https://i-blog.csdnimg.cn/direct/7dc7d50f1cb444adb52d4d988a96c80d.png" alt="xxx.com"></p><p><img src="https://i-blog.csdnimg.cn/direct/4b0eceec04614bc4a5ac369289633e9e.png" alt="JPDirect"></p><h1 id="简单说明"><a href="#简单说明" class="headerlink" title="简单说明"></a>简单说明</h1><p>为了说清楚这个问题，也为了讲明后面的解决方案，我简单介绍几个概念：</p><h2 id="Vercel"><a href="#Vercel" class="headerlink" title="Vercel"></a>Vercel</h2><p>Vercel 是一个前端开发平台，专注于帮助开发者快速构建、部署和优化现代Web应用。它最初是由Guillermo Rauch于2015年创建的，最早被称为ZEIT，后来在2020年改名为Vercel。Vercel的核心目标是简化从开发到生产的整个流程，使得开发者可以专注于编写代码，而不需要花费太多时间在基础设施和运维上。</p><h3 id="主要功能和特点"><a href="#主要功能和特点" class="headerlink" title="主要功能和特点"></a>主要功能和特点</h3><ol><li><p><strong>无缝部署</strong>：Vercel 提供了自动化的部署流程，每次代码提交时，它会自动构建并部署最新的应用版本。Vercel还支持即时回滚，确保部署过程简单且安全。</p></li><li><p><strong>支持多种框架</strong>：虽然Vercel是Next.js的创建者，并对其提供最佳支持，但它也兼容其他常见的前端框架和静态网站生成器，如React、Vue、Svelte、Gatsby等。</p></li><li><p><strong>全球CDN</strong>：Vercel 的应用部署在全球边缘网络中，提供了快速的内容交付和低延迟的用户体验。其自动优化机制有助于提高应用的性能。</p></li><li><p><strong>Serverless Functions</strong>：Vercel支持无服务器函数（Serverless Functions），允许开发者在前端项目中轻松集成后端逻辑。</p></li><li><p><strong>实时预览</strong>：Vercel 提供了分支预览（Preview Deployments），可以让团队成员在代码合并之前查看应用的运行情况。</p></li><li><p><strong>集成与扩展</strong>：Vercel可以与GitHub、GitLab、Bitbucket等版本控制系统进行无缝集成，并且支持通过API和插件进行扩展。</p></li></ol><h2 id="JPDirect"><a href="#JPDirect" class="headerlink" title="JPDirect"></a>JPDirect</h2><p>JPDirect是由日本注册服务公司（JPRS）提供的服务，主要负责“.jp”域名的注册和管理。JPDirect不仅提供域名注册，还支持SSL/TLS证书的发放，以确保网站的安全性。用户可以通过该平台管理和更新其域名设置，适用于企业和个人用户。JPRS也为用户提供了详细的域名管理教程和技术支持，确保用户能够顺利管理他们的域名。</p><h2 id="NameServers"><a href="#NameServers" class="headerlink" title="NameServers"></a>NameServers</h2><p>NameServers（名称服务器）是在域名系统（DNS）中用于将域名转换为IP地址的服务器。它们的作用是通过查询和返回对应的IP地址，使用户能够通过域名访问网站。每个域名通常至少有两个NameServers，以确保服务的可靠性和冗余。配置NameServers是域名管理中的重要环节，域名注册商通常提供默认的NameServers，但用户也可以配置自定义的NameServers来指向特定的服务器或托管服务。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>Vercel 要验证域名需要添加一条名为 <code>_vercel</code> 的DNS记录，但是域名提供商JPDirect不允许添加名称带下划线的记录，死锁了，呀呼嘿。</p><p>有问题找客服啊，先找JPDirect的客服，据联络人说人家不管，好，那我去找 Vercel 客服，去了论坛，issue找相关问题并留了言，没想到第二天真的收到 Verce<a href="https://vercel.community/t/having-trouble-verifying-my-domain-name-with-txt-record-vercel/194" target="_blank" rel="noopener">l</a> 工作人员回复了，所以根据现实情况说明了问题，她们也会回复，只是总在后半夜，由于时差问题，我们每天只完成一次问答，我白天问，他们后半夜回答，本来想让她们帮忙自定义一个TXT记录的，一直最后也没实现，不过在问答过程中我得到了一些启示。</p><p><strong>最终的解决办法是，我在JPDirect的后台填了Vercel两个域名服务器地址 <code>ns1.vercel-dns.com</code> 和 <code>ns2.vercel-dns.com</code>，然后在Vercel的域名管理后台，添加了名为 <code>_vercel</code> 的DNS记录，完成了验证</strong>。</p><p>中间设置JPDirect的时候还把所有的DNS清空了，不知道怎么搞的，它的保存和设置有些问题，大半夜等到1点半才恢复，也是醉了，一波三折，最后终于弄好了。JPDirect重新填写恢复之前的DNS记录，用了半个多小时才生效，大半夜的让人心惊肉跳。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>Vercel 是一个前端开发平台，专注于帮助开发者快速构建、部署和优化现代Web应用</li><li>JPDirect是由日本注册服务公司（JPRS）提供的服务，主要负责“.jp”域名的注册和管理</li><li>NameServers（名称服务器）是在域名系统（DNS）中用于将域名转换为IP地址的服务器</li><li>借助NameServer绕道而行，通过 <code>ns1.vercel-dns.com</code>跳板完成域名验证服务</li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/140557465" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>逢敌必亮剑，血溅七步，勇者胜。</p><p>2024-8-1 01:22:26</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;处理域名转移这件事已经过去好几天，终于抽出点时间来总结一下，解决这件事大概花了2周多时间，因为时差的原因导致沟通缓慢，今天准备长话短说，省略掉中间的细枝末节，只讲讲遇到了什么问题，最后怎么解决的。&lt;/p&gt;
    
    </summary>
    
      <category term="Web" scheme="http://AlbertGithubHome.github.io/blog/categories/Web/"/>
    
    
      <category term="Vercel" scheme="http://AlbertGithubHome.github.io/blog/tags/Vercel/"/>
    
      <category term="JPDirect" scheme="http://AlbertGithubHome.github.io/blog/tags/JPDirect/"/>
    
      <category term="NameServers" scheme="http://AlbertGithubHome.github.io/blog/tags/NameServers/"/>
    
      <category term=".vercel-dns.com" scheme="http://AlbertGithubHome.github.io/blog/tags/vercel-dns-com/"/>
    
      <category term="域名转移" scheme="http://AlbertGithubHome.github.io/blog/tags/%E5%9F%9F%E5%90%8D%E8%BD%AC%E7%A7%BB/"/>
    
  </entry>
  
  <entry>
    <title>因为glibc版本不兼容不得已我重装了Dell R620的系统</title>
    <link href="http://AlbertGithubHome.github.io/blog/2024/07/20/%E5%9B%A0%E4%B8%BAglibc%E7%89%88%E6%9C%AC%E4%B8%8D%E5%85%BC%E5%AE%B9%E4%B8%8D%E5%BE%97%E5%B7%B2%E6%88%91%E9%87%8D%E8%A3%85%E4%BA%86Dell-R620%E7%9A%84%E7%B3%BB%E7%BB%9F/"/>
    <id>http://AlbertGithubHome.github.io/blog/2024/07/20/因为glibc版本不兼容不得已我重装了Dell-R620的系统/</id>
    <published>2024-07-19T16:30:00.000Z</published>
    <updated>2024-07-20T15:09:51.572Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我总以为这件事发生很久了，但刚刚去翻了聊天记录居然是上周发生的事情，趁着还没忘干净赶紧记录一下，对于服务器安装系统来说这还是第一次。</p><p>好久很久以前（大概是1个月前），我找运维装了一台服务器Dell PowerEdge R620，当时说好是Ubuntu20.04版本，但是装完后我也没注意，期间发生了很多事情，终于到上周的时候开始在这台机器上搭建Jenkins打包环境，整个过程还是比较顺利的，但是发现打包机上编译的程序版本无法在本地环境下运行，这时候仔细看才发现，原来运维安装的系统是 Ubuntu22.04，也不知道是因为粗心还是大意，不能运行的原因就是打包机上的glibc版本过高，本地环境无法支持，但这却引起了我的疑惑。</p><a id="more"></a><h1 id="glibc版本和常用命令"><a href="#glibc版本和常用命令" class="headerlink" title="glibc版本和常用命令"></a>glibc版本和常用命令</h1><p>先附一个Linux发行版本和默认glibc版本对应关系的图表</p><table><thead><tr><th style="text-align:center">Ubuntu</th><th style="text-align:center">Debian</th><th style="text-align:center">CentOS</th><th style="text-align:center">Glibc</th></tr></thead><tbody><tr><td style="text-align:center">22.04</td><td style="text-align:center">-</td><td style="text-align:center">-</td><td style="text-align:center">2.34</td></tr><tr><td style="text-align:center">20.04</td><td style="text-align:center">11</td><td style="text-align:center">-</td><td style="text-align:center">2.31</td></tr><tr><td style="text-align:center">-</td><td style="text-align:center">10</td><td style="text-align:center">8</td><td style="text-align:center">2.28</td></tr><tr><td style="text-align:center">18.04</td><td style="text-align:center">-</td><td style="text-align:center">-</td><td style="text-align:center">2.27</td></tr><tr><td style="text-align:center">-</td><td style="text-align:center">9</td><td style="text-align:center">-</td><td style="text-align:center">2.24</td></tr><tr><td style="text-align:center">16.04</td><td style="text-align:center">-</td><td style="text-align:center">-</td><td style="text-align:center">2.23</td></tr><tr><td style="text-align:center">14.04</td><td style="text-align:center">8</td><td style="text-align:center">-</td><td style="text-align:center">2.19</td></tr><tr><td style="text-align:center">13.04</td><td style="text-align:center">-</td><td style="text-align:center">7</td><td style="text-align:center">2.17</td></tr><tr><td style="text-align:center">12.04</td><td style="text-align:center">-</td><td style="text-align:center">-</td><td style="text-align:center">2.15</td></tr><tr><td style="text-align:center">-</td><td style="text-align:center">7</td><td style="text-align:center">-</td><td style="text-align:center">2.13</td></tr><tr><td style="text-align:center">-</td><td style="text-align:center">-</td><td style="text-align:center">6</td><td style="text-align:center">2.12</td></tr></tbody></table><p>查询glibc版本的命令为</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ldd --version</span><br></pre></td></tr></table></figure><p>查询动态库和可执行文件中的符号版本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">objdump -T my-program-or-so | grep GLIBC_</span><br><span class="line"></span><br><span class="line">strings /lib/x86_64-linux-gnu/libc.so.6 | grep GLIBC</span><br></pre></td></tr></table></figure><p>查询一个目录下所有动态库中使用符号的glibc版本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls | grep <span class="string">'.so'</span> | xargs objdump -T | grep GLIBC_ &gt; /tmp/symbol.log</span><br></pre></td></tr></table></figure><h1 id="glibc版本差异的疑问"><a href="#glibc版本差异的疑问" class="headerlink" title="glibc版本差异的疑问"></a>glibc版本差异的疑问</h1><p>目前我维护了两个项目，对于编译环境和运行环境不一样的问题，两个项目中都存在，但是A项目没问题，但是B项目有问题，具体的情况如下：</p><h2 id="A项目"><a href="#A项目" class="headerlink" title="A项目"></a>A项目</h2><p>C++11编写，打包机Ubuntu16.04，glibc版本2.23，运行环境有CentOS7和Ubuntu16.04，相同的系统大概率没问题，而CentOS7的glibc是2.17版本，也没有问题，这让我很奇怪</p><h3 id="打包机编译环境"><a href="#打包机编译环境" class="headerlink" title="打包机编译环境"></a>打包机编译环境</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">root@jenkins1604:~<span class="comment"># cat /etc/os-release</span></span><br><span class="line">NAME=<span class="string">"Ubuntu"</span></span><br><span class="line">VERSION=<span class="string">"16.04.2 LTS (Xenial Xerus)"</span></span><br><span class="line">ID=ubuntu</span><br><span class="line">ID_LIKE=debian</span><br><span class="line">PRETTY_NAME=<span class="string">"Ubuntu 16.04.2 LTS"</span></span><br><span class="line">VERSION_ID=<span class="string">"16.04"</span></span><br><span class="line">HOME_URL=<span class="string">"http://www.ubuntu.com/"</span></span><br><span class="line">SUPPORT_URL=<span class="string">"http://help.ubuntu.com/"</span></span><br><span class="line">BUG_REPORT_URL=<span class="string">"http://bugs.launchpad.net/ubuntu/"</span></span><br><span class="line">VERSION_CODENAME=xenial</span><br><span class="line">UBUNTU_CODENAME=xenial</span><br><span class="line">root@jenkins1604:~<span class="comment"># ldd --version</span></span><br><span class="line">ldd (Ubuntu GLIBC 2.23-0ubuntu5) 2.23</span><br><span class="line">Copyright (C) 2016 Free Software Foundation, Inc.</span><br><span class="line">This is free software; see the <span class="built_in">source</span> <span class="keyword">for</span> copying conditions.  There is NO</span><br><span class="line">warranty; not even <span class="keyword">for</span> MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</span><br><span class="line">Written by Roland McGrath and Ulrich Drepper.</span><br><span class="line">root@jenkins1604:~<span class="comment">#</span></span><br></pre></td></tr></table></figure><h3 id="运行环境1"><a href="#运行环境1" class="headerlink" title="运行环境1"></a>运行环境1</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$ cat /etc/os-release</span><br><span class="line">NAME=<span class="string">"Ubuntu"</span></span><br><span class="line">VERSION=<span class="string">"16.04.6 LTS (Xenial Xerus)"</span></span><br><span class="line">ID=ubuntu</span><br><span class="line">ID_LIKE=debian</span><br><span class="line">PRETTY_NAME=<span class="string">"Ubuntu 16.04.6 LTS"</span></span><br><span class="line">VERSION_ID=<span class="string">"16.04"</span></span><br><span class="line">HOME_URL=<span class="string">"http://www.ubuntu.com/"</span></span><br><span class="line">SUPPORT_URL=<span class="string">"http://help.ubuntu.com/"</span></span><br><span class="line">BUG_REPORT_URL=<span class="string">"http://bugs.launchpad.net/ubuntu/"</span></span><br><span class="line">VERSION_CODENAME=xenial</span><br><span class="line">UBUNTU_CODENAME=xenial</span><br><span class="line"></span><br><span class="line"><span class="comment"># shz @ 20200116GF in /mnt/e/linux on git:7bd9be2 x [9:47:34]</span></span><br><span class="line">$ ldd --version</span><br><span class="line">ldd (Ubuntu GLIBC 2.23-0ubuntu11) 2.23</span><br><span class="line">Copyright (C) 2016 Free Software Foundation, Inc.</span><br><span class="line">This is free software; see the <span class="built_in">source</span> <span class="keyword">for</span> copying conditions.  There is NO</span><br><span class="line">warranty; not even <span class="keyword">for</span> MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</span><br><span class="line">Written by Roland McGrath and Ulrich Drepper.</span><br></pre></td></tr></table></figure><h3 id="运行环境2"><a href="#运行环境2" class="headerlink" title="运行环境2"></a>运行环境2</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">[root@hk-dev Debug]<span class="comment"># cat /etc/os-release</span></span><br><span class="line">NAME=<span class="string">"CentOS Linux"</span></span><br><span class="line">VERSION=<span class="string">"7 (Core)"</span></span><br><span class="line">ID=<span class="string">"centos"</span></span><br><span class="line">ID_LIKE=<span class="string">"rhel fedora"</span></span><br><span class="line">VERSION_ID=<span class="string">"7"</span></span><br><span class="line">PRETTY_NAME=<span class="string">"CentOS Linux 7 (Core)"</span></span><br><span class="line">ANSI_COLOR=<span class="string">"0;31"</span></span><br><span class="line">CPE_NAME=<span class="string">"cpe:/o:centos:centos:7"</span></span><br><span class="line">HOME_URL=<span class="string">"https://www.centos.org/"</span></span><br><span class="line">BUG_REPORT_URL=<span class="string">"https://bugs.centos.org/"</span></span><br><span class="line"></span><br><span class="line">CENTOS_MANTISBT_PROJECT=<span class="string">"CentOS-7"</span></span><br><span class="line">CENTOS_MANTISBT_PROJECT_VERSION=<span class="string">"7"</span></span><br><span class="line">REDHAT_SUPPORT_PRODUCT=<span class="string">"centos"</span></span><br><span class="line">REDHAT_SUPPORT_PRODUCT_VERSION=<span class="string">"7"</span></span><br><span class="line"></span><br><span class="line">You have mail <span class="keyword">in</span> /var/spool/mail/root</span><br><span class="line">[root@hk-dev Debug]<span class="comment"># ldd --version</span></span><br><span class="line">ldd (GNU libc) 2.17</span><br><span class="line">Copyright (C) 2012 Free Software Foundation, Inc.</span><br><span class="line">This is free software; see the <span class="built_in">source</span> <span class="keyword">for</span> copying conditions.  There is NO</span><br><span class="line">warranty; not even <span class="keyword">for</span> MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</span><br><span class="line">Written by Roland McGrath and Ulrich Drepper.</span><br></pre></td></tr></table></figure><h2 id="B项目"><a href="#B项目" class="headerlink" title="B项目"></a>B项目</h2><p>C++20编写，原打包机Ubuntu20.04，glibc版本2.31，运行环境有Ubuntu20.04，相同的系统没出问题，后来因打包机替换系统升到Ubuntu22.04后，glibc版本为2.34，再到Ubuntu20.04系统上运行就报错了</p><blockquote><p>./server: /lib/x86_64-linux-gnu/libc.so.6: version <code>GLIBC_2.34&#39; not found (required by ./server)</code></p></blockquote><p>看起来是glibc版本问题导致的</p><h3 id="原打包机编译环境"><a href="#原打包机编译环境" class="headerlink" title="原打包机编译环境"></a>原打包机编译环境</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu2004:~<span class="comment"># cat /etc/os-release</span></span><br><span class="line">NAME=<span class="string">"Ubuntu"</span></span><br><span class="line">VERSION=<span class="string">"20.04.2 LTS (Focal Fossa)"</span></span><br><span class="line">ID=ubuntu</span><br><span class="line">ID_LIKE=debian</span><br><span class="line">PRETTY_NAME=<span class="string">"Ubuntu 20.04.2 LTS"</span></span><br><span class="line">VERSION_ID=<span class="string">"20.04"</span></span><br><span class="line">HOME_URL=<span class="string">"https://www.ubuntu.com/"</span></span><br><span class="line">SUPPORT_URL=<span class="string">"https://help.ubuntu.com/"</span></span><br><span class="line">BUG_REPORT_URL=<span class="string">"https://bugs.launchpad.net/ubuntu/"</span></span><br><span class="line">PRIVACY_POLICY_URL=<span class="string">"https://www.ubuntu.com/legal/terms-and-policies/privacy-policy"</span></span><br><span class="line">VERSION_CODENAME=focal</span><br><span class="line">UBUNTU_CODENAME=focal</span><br><span class="line">root@ubuntu2004:~<span class="comment"># ldd --version</span></span><br><span class="line">ldd (Ubuntu GLIBC 2.31-0ubuntu9.16) 2.31</span><br><span class="line">Copyright (C) 2020 Free Software Foundation, Inc.</span><br><span class="line">This is free software; see the <span class="built_in">source</span> <span class="keyword">for</span> copying conditions.  There is NO</span><br><span class="line">warranty; not even <span class="keyword">for</span> MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</span><br><span class="line">Written by Roland McGrath and Ulrich Drepper.</span><br></pre></td></tr></table></figure><h3 id="新打包编译环境环境"><a href="#新打包编译环境环境" class="headerlink" title="新打包编译环境环境"></a>新打包编译环境环境</h3><ul><li>Ubuntu22.04</li><li>glibc 2.34</li></ul><h3 id="运行环境"><a href="#运行环境" class="headerlink" title="运行环境"></a>运行环境</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$ cat /etc/os-release</span><br><span class="line">NAME=<span class="string">"Ubuntu"</span></span><br><span class="line">VERSION=<span class="string">"20.04.2 LTS (Focal Fossa)"</span></span><br><span class="line">ID=ubuntu</span><br><span class="line">ID_LIKE=debian</span><br><span class="line">PRETTY_NAME=<span class="string">"Ubuntu 20.04.2 LTS"</span></span><br><span class="line">VERSION_ID=<span class="string">"20.04"</span></span><br><span class="line">HOME_URL=<span class="string">"https://www.ubuntu.com/"</span></span><br><span class="line">SUPPORT_URL=<span class="string">"https://help.ubuntu.com/"</span></span><br><span class="line">BUG_REPORT_URL=<span class="string">"https://bugs.launchpad.net/ubuntu/"</span></span><br><span class="line">PRIVACY_POLICY_URL=<span class="string">"https://www.ubuntu.com/legal/terms-and-policies/privacy-policy"</span></span><br><span class="line">VERSION_CODENAME=focal</span><br><span class="line">UBUNTU_CODENAME=focal</span><br><span class="line"></span><br><span class="line"><span class="comment"># shzhen @ 20200116GF in /mnt/c/Users/Administrator [20:42:28]</span></span><br><span class="line">$ ldd --version</span><br><span class="line">ldd (Ubuntu GLIBC 2.31-0ubuntu9.2) 2.31</span><br><span class="line">Copyright (C) 2020 Free Software Foundation, Inc.</span><br><span class="line">This is free software; see the <span class="built_in">source</span> <span class="keyword">for</span> copying conditions.  There is NO</span><br><span class="line">warranty; not even <span class="keyword">for</span> MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</span><br><span class="line">Written by Roland McGrath and Ulrich Drepper.</span><br></pre></td></tr></table></figure><h2 id="问题疑惑"><a href="#问题疑惑" class="headerlink" title="问题疑惑"></a>问题疑惑</h2><p>同样是高版本glibc的机器上编译，在低版本的glibc上运行，为什么A项目没问题，但是B项目出了问题呢，而且A项目的glibc版本2.23–&gt;2.17相差的还多，B项目的glibc版本2.34–&gt;2.31相差的还少，出问题的却是B项目，分析原因glibc应该是向下兼容的，高编译低运行本就不可行，属于正常现象，如果想实现这样运行，就要保证调用的符号在两个版本的库中没有变化，所以我查了A项目和B项目的符号表，发现：</p><ul><li>A项目中符号最高的版本是GLIBC_2.17，所以即使“高编译低运行”也是满足条件的</li><li>B项目中符号最高的版本是GLIBC_2.34，所以不能在glibc.2.31的Ubuntu20.04上运行</li></ul><p>但B项目中使用高版本符号的就有几个，剩下的都低于2.29版本，理论上只要去掉这几个符号的引用就可以在Ubuntu20.04上运行，但是为了避免后续的麻烦，我还是把打包编译的机器重新做了系统Ubuntu20.04</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">0000000000000000      DF *UND*        0000000000000000 (GLIBC_2.33) <span class="built_in">stat</span></span><br><span class="line">0000000000000000  w   DF *UND*        0000000000000000 (GLIBC_2.34) pthread_once</span><br><span class="line">0000000000000000  w   DF *UND*        0000000000000000 (GLIBC_2.34) __pthread_key_create</span><br><span class="line">0000000000000000      DF *UND*        0000000000000000 (GLIBC_2.34) sem_trywait</span><br><span class="line">0000000000000000      DF *UND*        0000000000000000 (GLIBC_2.34) dladdr</span><br><span class="line">0000000000000000      DF *UND*        0000000000000000 (GLIBC_2.34) sem_wait</span><br><span class="line">0000000000000000      DF *UND*        0000000000000000 (GLIBC_2.34) sem_init</span><br><span class="line">0000000000000000      DF *UND*        0000000000000000 (GLIBC_2.34) sem_timedwait</span><br><span class="line">0000000000000000      DF *UND*        0000000000000000 (GLIBC_2.34) sem_destroy</span><br><span class="line">0000000000000000      DF *UND*        0000000000000000 (GLIBC_2.34) dlclose</span><br><span class="line">0000000000000000      DF *UND*        0000000000000000 (GLIBC_2.34) dlsym</span><br><span class="line">0000000000000000      DF *UND*        0000000000000000 (GLIBC_2.34) dlerror</span><br><span class="line">0000000000000000      DF *UND*        0000000000000000 (GLIBC_2.34) dlopen</span><br><span class="line">0000000000000000  w   DF *UND*        0000000000000000 (GLIBC_2.34) pthread_once</span><br><span class="line">0000000000000000  w   DF *UND*        0000000000000000 (GLIBC_2.34) __pthread_key_create</span><br><span class="line">0000000000000000      DF *UND*        0000000000000000 (GLIBC_2.34) dladdr</span><br></pre></td></tr></table></figure><h1 id="将服务器系统改为Ubuntu20-04"><a href="#将服务器系统改为Ubuntu20-04" class="headerlink" title="将服务器系统改为Ubuntu20.04"></a>将服务器系统改为Ubuntu20.04</h1><p>对于重装系统我内心是拒绝的，前两天刚安装了一个PC电脑的windows系统，再往前推都好几年没装过了，不想来回折腾，再者说PC电脑安装Windows很熟悉，即使有问题网上搜一下也解决了，但是服务器安装系统之前确实没做过，并且还有一个我不愿意安装服务器系统的原因，就是这些服务器的硬盘配置的是Raid5磁盘阵列，因为不熟悉我真怕给它做坏了。</p><p>所以对于改为Ubuntu20.04系统这件事，我首先想到的就是将系统降级，但是尝试了一圈没有成功之后，我不得不硬着头皮重装系统了，当然在重装之前还查了Raid5相关信息，发现硬盘配置有专门的Raid卡控制，与操作系统没有关系，只要安装的时候不要把系统安装到原来的数据盘就不会影响原来的数据信息，单纯对做系统来说，硬盘可以当成普通的硬盘来看待，安装时选对盘符就行了。</p><h2 id="开始安装"><a href="#开始安装" class="headerlink" title="开始安装"></a>开始安装</h2><p>安装教程可以参考<a href="https://blog.csdn.net/zjy660358/article/details/131068796" target="_blank" rel="noopener">《Dell服务器安装Ubuntu系统》</a>、<a href="https://www.ikaros.love/?p=340" target="_blank" rel="noopener">《dell r620安装Ubuntu全过程》</a></p><p>镜像地址参考 <a href="https://old-releases.ubuntu.com/releases/" target="_blank" rel="noopener">官方镜像下载</a>、<a href="https://mirrors.tuna.tsinghua.edu.cn/ubuntu-releases/releases/releases/" target="_blank" rel="noopener">清华镜像</a>，注意要选择服务器版本的，不需要带桌面那一套东西，体积会小一点，性能会好一点</p><p>首先是做系统启动盘，按照教程选择了UltraISO，之前用这个比较多，本来一直点下一步就行了，但是无论选择官方镜像还是清华的镜像，在制作的时候都会提示一个可能无法引导系统的警告，但最后是成功的，我就用它试了试</p><p>把U盘插到服务器上，开机按F11进入System BOIS设置，把U盘调到第一启动项，重启后进入U盘拷贝的进度条，但总是无法正确安装，还多次进入了 Emergency mode，重启关机都不好使，最后不得不强行关机了</p><p>然后我换成了使用Rufus来烧制启动U盘，这里涉及到几种选项，比如选BOIS还是UEFI，文件系统选GPT还是MBR，提供一个详细的步骤</p><ol><li><strong>运行 Rufus</strong>：打开 Rufus 应用程序（无需安装）。</li><li><strong>选择设备</strong>：在 “Device” 下拉菜单中选择你的 U 盘。</li><li><strong>选择引导类型</strong>：点击 “Boot selection” 旁边的 “Select” 按钮，选择你下载的 Ubuntu ISO 文件。</li><li><strong>分区方案</strong>：<ul><li>如果 Dell R620 使用 UEFI 固件模式，选择 “GPT” 作为分区方案。</li><li>如果你希望使用传统的 BIOS 模式，选择 “MBR” 作为分区方案。</li></ul></li><li><strong>目标系统</strong>：<ul><li>如果选择 “GPT” 分区方案，目标系统应自动设置为 “UEFI (non CSM)”。</li><li>如果选择 “MBR” 分区方案，目标系统应自动设置为 “BIOS or UEFI”.</li></ul></li><li><strong>文件系统</strong>：选择 “FAT32”。</li><li><strong>卷标</strong>：可以给你的 U 盘设置一个名称，比如 “Ubuntu_Install”。</li><li><strong>启动创建</strong>：点击 “Start” 按钮，Rufus 会开始创建启动盘。过程大约需要几分钟。</li></ol><h3 id="BOIS-和-UEFI的区别"><a href="#BOIS-和-UEFI的区别" class="headerlink" title="BOIS 和 UEFI的区别"></a>BOIS 和 UEFI的区别</h3><p>BIOS（Basic Input/Output System）和UEFI（Unified Extensible Firmware Interface）是两种计算机固件接口，用于在操作系统启动之前初始化硬件和加载操作系统。它们在功能、性能和设计上有一些显著的区别。</p><h4 id="BIOS，Basic-Input-Output-System"><a href="#BIOS，Basic-Input-Output-System" class="headerlink" title="BIOS，Basic Input/Output System"></a>BIOS，Basic Input/Output System</h4><ol><li><strong>传统固件接口</strong>：BIOS是较早的固件接口，起源于20世纪80年代。</li><li><strong>16位模式</strong>：运行在16位处理器模式下，具有1MB的地址空间限制。</li><li><strong>MBR分区表</strong>：使用主引导记录（MBR）分区表，最多支持4个主分区，每个分区最大支持2TB。</li><li><strong>启动速度较慢</strong>：由于初始化硬件的方式较为低效，启动速度较慢。</li><li><strong>用户界面</strong>：通常是文本模式的界面，操作较为复杂。</li><li><strong>扩展性差</strong>：扩展性和灵活性较差，难以适应现代硬件和软件的需求。</li></ol><h4 id="UEFI，Unified-Extensible-Firmware-Interface"><a href="#UEFI，Unified-Extensible-Firmware-Interface" class="headerlink" title="UEFI，Unified Extensible Firmware Interface"></a>UEFI，Unified Extensible Firmware Interface</h4><ol><li><strong>现代固件接口</strong>：UEFI是BIOS的继任者，设计初衷是替代BIOS，提供更丰富的功能和更好的性能。</li><li><strong>32位或64位模式</strong>：运行在32位或64位处理器模式下，具有更大的地址空间。</li><li><strong>GPT分区表</strong>：使用GUID分区表（GPT），支持更多的分区（最多128个），且每个分区可以超过2TB。</li><li><strong>启动速度较快</strong>：初始化硬件的方式更高效，启动速度更快。</li><li><strong>用户界面</strong>：支持图形用户界面（GUI），操作更加直观和友好。</li><li><strong>扩展性强</strong>：具有更好的扩展性和灵活性，支持网络启动、远程诊断和修复等现代功能。</li></ol><h4 id="具体区别"><a href="#具体区别" class="headerlink" title="具体区别"></a>具体区别</h4><ol><li><p><strong>启动过程</strong>：</p><ul><li><strong>BIOS</strong>：在启动过程中，BIOS执行一系列的POST（Power-On Self Test）检查，然后查找并加载MBR中的引导代码。</li><li><strong>UEFI</strong>：在启动过程中，UEFI固件会查找并执行EFI系统分区（ESP）中的引导管理程序，可以直接加载操作系统。</li></ul></li><li><p><strong>分区表支持</strong>：</p><ul><li><strong>BIOS</strong>：仅支持MBR分区表，存在4个主分区的限制。</li><li><strong>UEFI</strong>：支持GPT分区表，可以有更多的分区，且每个分区大小不受2TB限制。</li></ul></li><li><p><strong>硬件支持</strong>：</p><ul><li><strong>BIOS</strong>：对现代硬件的支持有限，尤其在大容量存储设备和新型设备的支持上存在不足。</li><li><strong>UEFI</strong>：设计时考虑了现代硬件的需求，支持更大容量的存储设备和多种新型设备。</li></ul></li><li><p><strong>安全性</strong>：</p><ul><li><strong>BIOS</strong>：安全性较低，缺乏现代安全特性。</li><li><strong>UEFI</strong>：支持Secure Boot等安全特性，防止恶意软件和未授权操作系统的启动。</li></ul></li></ol><p>BIOS和UEFI是两种不同的固件接口，UEFI是BIOS的继任者，提供了更丰富的功能、更好的性能和更强的扩展性。随着计算机技术的发展，UEFI已经成为现代计算机系统中广泛采用的固件接口，逐渐取代了传统的BIOS。</p><p>之前我不太关心这些，这次我听了ChatGPT的建议选择了UEFI、GPT、FAT32的选项，这也为我后面启动埋下了一个坑</p><h2 id="再次安装"><a href="#再次安装" class="headerlink" title="再次安装"></a>再次安装</h2><p>这次无比顺利，将U盘设置为启动盘</p><ul><li>选择语言</li><li>选择键盘</li><li>选择服务器类型Ubuntu Server</li><li>手动配置IP和网关</li><li>跳过代理设置</li><li>选择安装的盘符，注意别选错了，我这里是小心再小心，这是我最担心的一步了</li><li>输入主机名、用户名和密码</li><li>跳过升级Ubuntu Pro</li><li>安装OpenSSH Server</li><li>不勾选其他Feature安装</li><li>然后就等着安装完、更新完重启就行了</li></ul><p>然后等它安装完我就等不及了，没等更新我就重启了，因为从早上捣鼓到下午了，然后电脑就打不开了，一直卡在开机界面，启动项也重新调整了，就是不起作用</p><h2 id="解决开机问题"><a href="#解决开机问题" class="headerlink" title="解决开机问题"></a>解决开机问题</h2><p>每次开机屏幕就卡在下面这些信息上：</p><blockquote><p>No boot device avaiable<br>Current boot node is set to BIOS<br>Please ensure aompatible bootable dedia is available<br>Use the system setup pargram to chaneg the boot mode as needed</p><p>strlke F1 to retry boot, F2 for system setup, F11 for BIOS boot manager</p></blockquote><p>一开始我总是把注意力放在最后一句，每个选项都尝试了也不行，找到两篇相关问题的解答，但是没解决问题</p><ul><li><a href="https://blog.csdn.net/2301_78006725/article/details/131871579" target="_blank" rel="noopener">戴尔服务器安装Ubuntu系统时跳过strlke F1 to retry boot, F2 for system setup,F11 for BIOS boot manager解决方法</a></li><li><a href="https://blog.csdn.net/zbx199110/article/details/80005077" target="_blank" rel="noopener">windowsServer2008开机出现strike f1 to retry boot，f2 for system setup ，f11 for BIOS boot manager</a></li></ul><p>于是仔细看到这一句 “Use the system setup pargram to chaneg the boot mode as needed”</p><p>按F2 进入 System BOIS，将Boot Mode改为 UEFI 模式，成功进入系统，因为之前是BIOS，我制作的引导盘采用的是UEFI模式，后续买云服务器用的也是 Ubuntu 20.04 64位 UEFI版，保持统一吧</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>保证开发环境、打包环境、运行环境一致，可以避免很多坑，这或许就是docker火起来的意义</li><li>使用系统自带的glibc版本，千万不要自己升级或降级，会引起连锁反应，这是很多前人给出的忠告</li><li>glibc的特点，兼容低版本的内容，所以理论上“低版本编译高版本运行”没问题，反过来一般不行，但存在特例</li><li>BIOS（Basic Input/Output System）和UEFI（Unified Extensible Firmware Interface）是两种计算机固件接口</li><li>UEFI是BIOS的继任者，提供了更丰富的功能、更好的性能和更强的扩展性，使用GUID分区表（GPT），支持更多的分区</li><li><code>Use the system setup pargram to chaneg the boot mode as needed</code></li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/140083813" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>是你一直坚持走熟悉舒服的老路，过一眼望到头的人生，那看不见新的风景，遇不到新的经历也就怨不得别人了~</p><p>2024-7-19 19:56:16</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;我总以为这件事发生很久了，但刚刚去翻了聊天记录居然是上周发生的事情，趁着还没忘干净赶紧记录一下，对于服务器安装系统来说这还是第一次。&lt;/p&gt;
&lt;p&gt;好久很久以前（大概是1个月前），我找运维装了一台服务器Dell PowerEdge R620，当时说好是Ubuntu20.04版本，但是装完后我也没注意，期间发生了很多事情，终于到上周的时候开始在这台机器上搭建Jenkins打包环境，整个过程还是比较顺利的，但是发现打包机上编译的程序版本无法在本地环境下运行，这时候仔细看才发现，原来运维安装的系统是 Ubuntu22.04，也不知道是因为粗心还是大意，不能运行的原因就是打包机上的glibc版本过高，本地环境无法支持，但这却引起了我的疑惑。&lt;/p&gt;
    
    </summary>
    
      <category term="linux" scheme="http://AlbertGithubHome.github.io/blog/categories/linux/"/>
    
    
      <category term="linux" scheme="http://AlbertGithubHome.github.io/blog/tags/linux/"/>
    
      <category term="Dell" scheme="http://AlbertGithubHome.github.io/blog/tags/Dell/"/>
    
      <category term="R620" scheme="http://AlbertGithubHome.github.io/blog/tags/R620/"/>
    
      <category term="glibc" scheme="http://AlbertGithubHome.github.io/blog/tags/glibc/"/>
    
      <category term="BIOS" scheme="http://AlbertGithubHome.github.io/blog/tags/BIOS/"/>
    
      <category term="UEFI" scheme="http://AlbertGithubHome.github.io/blog/tags/UEFI/"/>
    
  </entry>
  
  <entry>
    <title>忙忙碌碌的混沌之中差点扑了个空而错过年中这条线</title>
    <link href="http://AlbertGithubHome.github.io/blog/2024/06/30/%E5%BF%99%E5%BF%99%E7%A2%8C%E7%A2%8C%E7%9A%84%E6%B7%B7%E6%B2%8C%E4%B9%8B%E4%B8%AD%E5%B7%AE%E7%82%B9%E6%89%91%E4%BA%86%E4%B8%AA%E7%A9%BA%E8%80%8C%E9%94%99%E8%BF%87%E5%B9%B4%E4%B8%AD%E8%BF%99%E6%9D%A1%E7%BA%BF/"/>
    <id>http://AlbertGithubHome.github.io/blog/2024/06/30/忙忙碌碌的混沌之中差点扑了个空而错过年中这条线/</id>
    <published>2024-06-30T14:54:44.000Z</published>
    <updated>2024-07-20T14:26:08.023Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>突然意识到过完这个周末已经7月份了，他预示着我的2024年已经过半了，过年回家仿佛还是昨天的事情，怎么转眼间已经到了年中了。心里还是不愿承认这件事，翻开自己2024年的打卡清单，列表显示已经到了26周，从另一方面证明了年中这条线已经到来，再看看打卡清单上这惨不忍睹的“成果”，真的有点难以接受。</p><a id="more"></a><p>2024打卡清单是2023年终总结的产物，为的是将时间周期细化，每周记录自己的变化，分别从总结、刷题、跑步、读书来简单记录自己完成了哪些，如今看看这清单，已经有一个月没总结了、一个月没刷题了、2个半月没有读书了，跑步属于硬蹭，每周忙忙碌碌的奔跑我暂且将其归为跑步，否则这一两个月的打卡就是0蛋了。</p><p>一个规律行进的人突然出现了一两个月的空白一定是遇到了什么问题，也不算是找借口，我也来回忆一下这两个月究竟发生了什么，借口也罢、困难也罢，这些暂时都过去了。</p><h1 id="初见端倪"><a href="#初见端倪" class="headerlink" title="初见端倪"></a>初见端倪</h1><p>面对周围环境的不景气，同学们即将被毕业的传闻在2023年底传了出来，在真真假假的传闻过后，同组一位同学不得不离开去寻找新的出路，剩下的伙伴报团取暖，也在努力探索着的新的途径，忙忙碌碌工作到年底，随着新年的喜气洋洋的气息，毕业的寒风好像被冲淡了很多，但是新年回来后的工作热情并没有持续多久，就有更多悲观的信息陆续流传出来。</p><p>话说无风不起浪，这种环境下大家还是宁可信其有，不可信其无，也有不少人早早的开始做了准备，平时我也是会和大家聊聊做好总结，寻找新机会的话题，但接下来这次的毕业信息雷厉风行，4月中旬组内另一小伙伴在3天内毕业离开了，从此也拉开了我这最近两个月的混沌经历。</p><h1 id="混沌初始"><a href="#混沌初始" class="headerlink" title="混沌初始"></a>混沌初始</h1><p>随着并肩战斗的小伙伴被迫依次离开，其实剩下的人都如履薄冰，好在这股风已经刮了很久，大家在心里上没有很意外，无非是对未来出路的迷茫，虽然不知道自己什么时候离开，但是基本默认自己离开只是时间早晚的事。</p><p>而这段时间我在做什么呢？简单来说就是总结加准备吧，因为项目组是有游戏在线上运行的，不管后续项目组的人要怎样处理，必然涉及到项目的整理和交接，所以提早做准备免得最后被毕业时手忙脚乱吧。</p><p>当然这段时间还没到真正混乱时刻，我还在接触新的知识，比如Go的语法、新的框架、帧同步，k8s，AI应用等等，就这样在边总结、边准备的情况下，我的时间来到了五一劳动节，平稳的度过了这个节日，而混沌的经历也从此开始。</p><h1 id="力不从心"><a href="#力不从心" class="headerlink" title="力不从心"></a>力不从心</h1><p>自劳动节过完从河北回京，到端午结束从天津回京，这一个月的时间，真正的体会了一次力不从心的感觉，老人生病，带着挂号、看病、预约检查、手术排期、住院，最多一天跑3家医院。而我也迎来了毕业通知，准备办理离职、项目交接、指定方案、反复沟通、新工作的寻找，办卡。小孩子看病、挂号、运动会的参加、儿童节参与、跟老师的互动和沟通。租住的出租屋要换上下水管道，要有人盯着。老家的麦收，农忙，播种，全家人多地的来回奔波。其中很多事情我并没有参与多少，这都是一家人一起挺过来的，但是真的心累，累的不行，每天歇下来时只想睡觉，好在事情一件一件地解决了。</p><p>这也是为什么最近这段时间的生活打卡清单上只有“跑步”这一项了，每天都是风风火火的奔跑忙碌。</p><h1 id="心力交瘁"><a href="#心力交瘁" class="headerlink" title="心力交瘁"></a>心力交瘁</h1><p>因为之前意识到要做项目交接，所以上文提到我已经做了准备，对于数据的交接基本没什么问题，但是数据量巨大，每次同步得10个小时左右，只要有一点问题那便是再花费个10小时，另外工作流程的移交才是交接工作的难点。</p><p>时间来到了6月初，已经完成了数据交接，并在月初按预定计划申请了交接的各类账号和权限，其中各种求爷爷告奶奶的心酸只有自己才懂，最后一天因数据同步验证问题忙到了很晚，没有拿到离职证明，不得不第二周星期一办完最后手续，本来以为在入职新公司前这段时间可以好好休息一下了，不曾想去拿离职证明那天却是我接下来一个月最轻松的一天。</p><p>6月份这将近一个月对我的洗礼不仅是知识层面的，更多的是精神上的，作为游戏服务端的主程，对比之前的执行大兵，免不了要处理团队内外沟通的事情，相比之前闷头开发时的纯粹真的是累了很多，但是这一个月的洗礼让我认识到，跟人打交道真的必跟计算机打交道累的太多了。</p><p>很多流程只能按照规章制度办，但是如果你的权限足够高，或者你有一个可以说得上话的领导，那么这些规章制度就可以靠边站，流程也可以特批特办，倒不是说去做违规的事，比如半夜12点让流程线上的人帮你审批多少有点不近人情，并且大半夜的你也找不到人，但是在紧急情况下，你如果可以联系到对方的领导，还是可以紧急特批特办的，毕竟是合规的事情，也不需要担什么风险，只是一个大头兵对于半夜卡流程这件事一般还是推不动的，只能向上反映。</p><p>这一个月说了太多的好话，请了太多的人帮忙，走了太多的审批流，特批了太多的紧急状况，吃了太多的外卖，过去几年我都没吃这么多外卖，回望上周的工作总结，我觉得自己就是个超人，这工作强度已经赶上前年出版本，以及去年上线测试时的强度了，这种活真的挺难干的，一方面是专业技能的掌握，而另一方面也考验着人际关系。</p><h1 id="拾遗补缺"><a href="#拾遗补缺" class="headerlink" title="拾遗补缺"></a>拾遗补缺</h1><p>最近这一个月的工作环境错综复杂，工作地点就换了好几次，有过忍饥挨饿，也有过通宵处理，有时连最基本的网络都保证不了，原本一个月都用不了3个G流量的我，这个月竟然破天荒的使用了20多个G，虽然有很多需要靠人际关系才能解决的问题，但是也有很多专业性的问题，即使不是第一次遇到，也有了新的认知和理解，所以简单罗列下，作为后续深入理解的源头吧。</p><p>首先是网络Vlan的搭建，重温了子网的划分与设计，网络拓扑查看，无线网与有线网的连通，3层路由器与二层交换机的数据转发，IP与MAC地址的绑定，DHCP的配置与地址池的设定，CentOS和Ubuntu静态IP的配置，WiFi6对老旧网卡的不兼容性。</p><p>Dell R620服务器的基本硬件构成，iDrac接口的IP配置和用户信息配置，通过iDrac对机器的功率、温度、硬盘的监控，服务器硬盘的保护，服务器周围环境注意的问题，温度的控制，UPS电源的选择等等。</p><p>Raid的构成和分类，独立硬盘冗余阵列 Raid0、Raid1、Raid2、Raid3、Raid4、Raid5、Raid6、Raid10、Raid50、Raid100等，根据情况不同，选择不同的配置，但是2、4、6好像很少用，而比较中庸的Raid5是常常出现的选择，可以容忍一块硬盘损坏，出现问题后，将损坏的硬盘取下，换上Dell原装硬盘可以自动重建。</p><p>gitlab备份和还原，解决git库迁移是lfs check出错的问题，svn服务器备份，svn在linux环境下保存密码，Linux查看硬件配置dmidecode，查看硬盘信息，第一次完成硬盘挂载，虚拟机向物理机同步数据，rysnc-daemon模式的配置。</p><p>docker环境下搭建jenkins，gitlab，svn等，docker虽然可以挂在硬盘保证数据不丢失，但是如果出现镜像内访问外部服务实现起来会比较麻烦，如果访问镜像内原本没有的程序也比较麻烦，举个例子，用docker搭建gitlab，只对外提供访问，可以很方便的实现，也能快速升级，但是docker搭建jenkins就很麻烦了，单独的jenkins镜像缺少某些特定工具，并且作为打包环境需要经常访问其他的服务，放在容器中我感觉不太方便。</p><p>在一天之内接触了4种苹果类型的设备，这是之前都没碰过的，iMac、Mac Studio、Mac Mini、黑苹果，了解了Darwin名字的来源，Mac Os系统的变迁，我觉的“访达”这个对Finder的翻译非常棒，苹果打包所需的Unity和XCode的安装，jenkins-lts的安装，MacOs的开机启动程序，jenkins版本的替换，Java11的安装，Grooxy语法等。</p><p>服务器的迁移，注意应用程序目录的数据迁移，还有用户目录下各个隐藏文件的迁移，比如<code>.ssh</code>、<code>.subversion</code>、<code>.gitconfig</code> 等等，这决定你是否可以用新机器完全替代旧机器。</p><p>Microsoft  Intune的认证、Mac系统公司门户的认证，VPN远程访问，办公网、研发网，解决WOA无法登录问题，网络验证授权等。</p><!--go的更新最近两个月没有读书流量用了20多个G新知识，网络，raid，年中总结，2个月的忙碌gitlab备份svn备份raid5linux svn密码保存机器迁移，更新配置申请账号rysnc-daemonmacmini mac studio iMac 黑苹果Unity xcode groovywifi6虚拟机数据同步到物理机VPN远程访问，办公网、研发网解决WOA无法登录问题邮件确认，外网IP推包网络拓扑网络验证Microsoft  IntunelfsSSD访达VLANIDracSmartBI--><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>2024年已经过半，突然间才发现今年已经过了26周，而最近的打卡清单缺惨不忍睹</li><li>辛苦奔忙的一个月让自己感觉力不从心，而最近过渡的一个月仿佛让自己又回到了备战上线时的强度</li><li>程序员的工作本来只费身体和脑子，最近接触的人有点多，感觉心也跟着累了</li><li>人际关系的积累不是一朝一夕能实现的，而技术知识的学习却可以速成，多总结吧</li></ul><p><img src="https://img-blog.csdnimg.cn/direct/4d3129f10247443f8e1aee3b2348362c.jpeg" alt="PerfecWorld"></p><hr><center><a href="https://blog.csdn.net/albertsh/article/details/139248122" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>但凡是由人操作的流程，都可以有一些例外，当你被告知仅能等待流程审批时，说明你还不够硬，起码没有硬到可以帮你特批的地步~</p><p>2024-6-30 22:45:56</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;突然意识到过完这个周末已经7月份了，他预示着我的2024年已经过半了，过年回家仿佛还是昨天的事情，怎么转眼间已经到了年中了。心里还是不愿承认这件事，翻开自己2024年的打卡清单，列表显示已经到了26周，从另一方面证明了年中这条线已经到来，再看看打卡清单上这惨不忍睹的“成果”，真的有点难以接受。&lt;/p&gt;
    
    </summary>
    
      <category term="Thinking" scheme="http://AlbertGithubHome.github.io/blog/categories/Thinking/"/>
    
    
      <category term="年中" scheme="http://AlbertGithubHome.github.io/blog/tags/%E5%B9%B4%E4%B8%AD/"/>
    
      <category term="2024" scheme="http://AlbertGithubHome.github.io/blog/tags/2024/"/>
    
      <category term="离职" scheme="http://AlbertGithubHome.github.io/blog/tags/%E7%A6%BB%E8%81%8C/"/>
    
      <category term="新起点" scheme="http://AlbertGithubHome.github.io/blog/tags/%E6%96%B0%E8%B5%B7%E7%82%B9/"/>
    
      <category term="人际关系" scheme="http://AlbertGithubHome.github.io/blog/tags/%E4%BA%BA%E9%99%85%E5%85%B3%E7%B3%BB/"/>
    
  </entry>
  
  <entry>
    <title>有关服务器安全的反思</title>
    <link href="http://AlbertGithubHome.github.io/blog/2024/05/28/%E6%9C%89%E5%85%B3%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%89%E5%85%A8%E7%9A%84%E5%8F%8D%E6%80%9D/"/>
    <id>http://AlbertGithubHome.github.io/blog/2024/05/28/有关服务器安全的反思/</id>
    <published>2024-05-27T17:30:00.000Z</published>
    <updated>2024-07-20T14:20:44.102Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>人都说学的越多，不懂的东西也就越多，很多人都会有这个感受，面对信息爆炸的互联网时代，有种“学不完，根本学不完”沧桑无力感，最近有关服务器安全的了解又扩展了我的知识面，填补了部分认知盲区，究竟什么是服务器安全？</p><a id="more"></a><h1 id="MySQL数据库的安全"><a href="#MySQL数据库的安全" class="headerlink" title="MySQL数据库的安全"></a>MySQL数据库的安全</h1><p>这是前段时间的疑问，<a href="https://blog.csdn.net/albertsh/article/details/133655454" target="_blank" rel="noopener">《linux环境下如果掌控了系统root账户就能对上面安装的MySQL数据为所欲为了吗》</a>，当时出现这个疑问是因为安装完MySQL数据库，提示我有这样一样配置文件 /etc/mysql/debian.cnf，打开文件内容展示如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># Automatically generated for Debian scripts. DO NOT TOUCH!</span><br><span class="line">[client]</span><br><span class="line">host     = localhost</span><br><span class="line">user     = debian-sys-maint</span><br><span class="line">password = xg9vyvjNly3vUSsm</span><br><span class="line">socket   = /var/run/mysqld/mysqld.sock</span><br><span class="line">[mysql_upgrade]</span><br><span class="line">host     = localhost</span><br><span class="line">user     = debian-sys-maint</span><br><span class="line">password = xg9vyvjNly3vUSsm</span><br><span class="line">socket   = /var/run/mysqld/mysqld.sock</span><br></pre></td></tr></table></figure><p>明明白白的写着用户名和密码，当时感觉不可思议，这数据库不是轻松就被破解了吗？事实确实如此，因为你是root用户，即便没有这个配置文件，你也可以通过修改MySQL配置重启服务来跳过密码，所以如果你拿到root密码，那么你就是这服务器世界的主宰，你就可以为所欲为。</p><h1 id="物理服务器"><a href="#物理服务器" class="headerlink" title="物理服务器"></a>物理服务器</h1><p>假设你没有服务器root用户密码，或者忘记了服务器root密码要怎么办呢？你可以在开机的时候按e修改grub的kernel行到single模式下，就可以轻易获得root权限，并且能够改root密码，有没有颠覆你的认知。什么？任何人只要重启下服务器就把我的root密码改了？这是真的吗？这确实是真的。</p><p>下面我摘录了一些网友的回复，挺逗的，但仔细想想说的很有道理</p><blockquote><p>能接触到物理机的，都别说什么安全</p><p>这个事吧，放在机房的玩意有个不成文的规矩：能物理摸到的设备都允许你重置密码。</p><p>90年代的一句老话：能物理摸到设备的人，都可以看作是这台设备的主人。</p><p>Linux：我就是一个软件，你搞物理袭击，讲武德吗？</p><p>退一万步说，就算在机器旁边也不能重设密码，那把硬盘拆了拿回去不也一样？</p><p>物理安全是信息安全的基础。摸到你机器了，还谈什么安全。</p><p>日常运维或者使用当中需要面临的更大的挑战是丢失了，改错了密码。从我的经验来看，丢失密码的机会比丢失硬件的机会大至少100倍</p><p>比如海底电缆可以被剪断，怎么保证安全性？</p></blockquote><p>为什么要这样设计呢？仔细想想也能明白个大概，就是能触碰到物理机的人一定默认拥有所有权，他去改密码一定是到了不得不改的情况，如果你非说改密码的人是偷偷进去的，那是保安的责任，Linux系统不背这个锅！</p><blockquote><p>机器设计有一个规矩就是机器的物理持有者对机器拥有事实上的超管理员权限。比如说路由器背后的reset。比如说主板cmos清除针。因为事实上，管理员忘记密码往往比密码受到黑客攻击更常见，造成的损失也更大。至于提数据加密的，那是另一个话题，我们这里说的是操作权。黑客无法窃取你用bitlocker加密的数据，但这不妨碍他把你数据删光，所以从这个角度上，bitlocker不能保证你的数据安全，它保证的只是不泄密。</p></blockquote><p>所以看到这些是不是就释然了，系统保证的安全是建立在物理机安全的基础之上的，连机器都在人家手里，还谈什么安全呢？</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>在Linux系统上如果登录了root用户就可以为所欲为进入任何一个MySQL数据库</li><li>如果摸到了物理服务器默认你就是它的主人，你可以通过很便捷的方式来修改它的密码</li><li>物理安全是信息安全基础，Linux就是一个软件，你搞物理偷袭它可扛不住</li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/138507927" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>凡是人总有取舍，你取了你认为重要的东西，舍弃了我，这只是你的选择而已，若是我因为没有被选择，就心生怨恨，那这世界岂不是有太多不可原谅之处，毕竟谁也没有责任要以我为先，以我为重，无论我如何希望也不能强求。</p><p>2024-5-27 21:16:17</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;人都说学的越多，不懂的东西也就越多，很多人都会有这个感受，面对信息爆炸的互联网时代，有种“学不完，根本学不完”沧桑无力感，最近有关服务器安全的了解又扩展了我的知识面，填补了部分认知盲区，究竟什么是服务器安全？&lt;/p&gt;
    
    </summary>
    
      <category term="Thinking" scheme="http://AlbertGithubHome.github.io/blog/categories/Thinking/"/>
    
    
      <category term="linux" scheme="http://AlbertGithubHome.github.io/blog/tags/linux/"/>
    
      <category term="root" scheme="http://AlbertGithubHome.github.io/blog/tags/root/"/>
    
      <category term="安全" scheme="http://AlbertGithubHome.github.io/blog/tags/%E5%AE%89%E5%85%A8/"/>
    
      <category term="密码" scheme="http://AlbertGithubHome.github.io/blog/tags/%E5%AF%86%E7%A0%81/"/>
    
      <category term="物理机" scheme="http://AlbertGithubHome.github.io/blog/tags/%E7%89%A9%E7%90%86%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>面对AI你到底能做什么？怎样能让其为我所用</title>
    <link href="http://AlbertGithubHome.github.io/blog/2024/05/07/%E9%9D%A2%E5%AF%B9AI%E4%BD%A0%E5%88%B0%E5%BA%95%E8%83%BD%E5%81%9A%E4%BB%80%E4%B9%88%EF%BC%9F%E6%80%8E%E6%A0%B7%E8%83%BD%E8%AE%A9%E5%85%B6%E4%B8%BA%E6%88%91%E6%89%80%E7%94%A8/"/>
    <id>http://AlbertGithubHome.github.io/blog/2024/05/07/面对AI你到底能做什么？怎样能让其为我所用/</id>
    <published>2024-05-06T18:15:00.000Z</published>
    <updated>2024-07-20T14:17:20.284Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>面对AI铺天盖地的新闻，大有替代万事万物的之势，但如果要问AI能做什么？你是否会在心里打个问号？它好像只能用来聊天，又好像什么都能做，ChatGPT现在是我每天都要使用的工具，每天只是对话问问题，特定领域的问题确实比搜索引擎更精准一些，但是对AI的使用也就仅限于此，难道AI只有这么大点能力吗？</p><a id="more"></a><p>仔细想想不是的，起码还有Midjourney这个生成图的应用，还有Sora 这个文本转视频的工具，但是在这些工具出现之前我怎么就没想到呢？我们是不是可以抛弃这种被动使用的局面，自动动手做一些AI方面的应用呢？答案是肯定的，之前没做出来是因为我们没有这样想过，一旦开了这个头，你会发现AI真的可以做很多东西！</p><h1 id="思路引导"><a href="#思路引导" class="headerlink" title="思路引导"></a>思路引导</h1><p>究竟怎么开始呢？先得找到需求，然后实现需求。作为一个程序员我们就从程序编码的例子出手，我们都会算两个数的加法，一开始数据比较小，需求计算的总量也比较小，所以口算、笔算都能满足需求，随着应用场景的增加，数据量也越来越大，那么人工计算就有些力不从心了。</p><p>这时作为以懒著称的程序员转了转脑筋，干脆实现一个加法计算器吧，需要计算时我把两个数字输入进去，直接就能得到结果，大大加快了计算速度</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num1, num2;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"请输入两个整数："</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; num1 &gt;&gt; num2;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"两数之和为："</span> &lt;&lt; add(num1, num2) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们使用已经掌握的代码知识，解决了现有的需求，提高了工作效率，那么AI相关的应用要怎么样实现呢？</p><h1 id="为AI找活干"><a href="#为AI找活干" class="headerlink" title="为AI找活干"></a>为AI找活干</h1><p>在创建AI应用之前，我们先来想想AI的特点，或者局限一点，想想ChatGPT的特点：语言理解与知识问答、逻辑推理与数学问题解答、编程代码的理解与编写、智能教育产品、儿童英语教育等等，我们抓住其中一点，来完成我们的工作，比如语言理解。</p><p>想想在学校时是否经常需要总结文章大意？看材料时是否经常需要概括全文思想？这些事不正是AI所擅长的吗，如果我们偷懒会把要总结的内容告诉ChatGPT，让它帮我们总结一下，第二天又有这个题目，再次告诉ChatGPT，让它帮我们总结一下，有没有发现？我们又陷入了经常做重复工作的情景，怎么抽象出一个需求呢？</p><p>需求就是：实现一个应用，接受输入一段文字，20个字概括文字内容的大意，要求总结文字通俗易懂、言简意赅</p><p>这仿佛变成了我们上面的<code>add</code>函数，只是总结的过程是调用AI来完成的，我们只需要输入一段文字就能得到总结性输出，去除了中间多余的人工步骤</p><h1 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h1><p>面对这个AI需求，我们可以利用ChatGPT的API接口从头搭建一个接受输入和返回输出的应用，类似实现一个 <code>add</code> 函数，也可以利用一些开放平台的能力，比如 <a href="https://www.xfyun.cn/" target="_blank" rel="noopener">讯飞开放平台</a>，通过低代码的形式来快速搭建AI应用。</p><ul><li>登录讯飞星火SparkDesk产品<a href="https://xinghuo.xfyun.cn/desk" target="_blank" rel="noopener">首页</a>，在左上角，点击进入“助手中心”<br><img src="https://img-blog.csdnimg.cn/direct/6ee9cfa8ba7546aba337f0da93e90c2b.png#pic_center" alt="xunfei1"></li><li><p>在星火助手中心页面，点击右上方“助手创作中心”<br><img src="https://img-blog.csdnimg.cn/direct/95919ca5bc2645abbb784a21342ace3c.png#pic_center" alt="xunfei2"></p></li><li><p>在助手创作中心，点击“立即创建”，进入新建助手页面，开始创建助手的创建之旅<br><img src="https://img-blog.csdnimg.cn/direct/a869dad0b7e8400d8bb806c067c11fcf.png#pic_center" alt="xunfei3"><br><img src="https://img-blog.csdnimg.cn/direct/ed5d089212be432c8fd4c0addce29dde.png#pic_center" alt="xunfei4"></p></li><li>接下来的内容就自己探索吧，根据需求在左侧填写内容，右侧可以进行调试，觉得运行还不错的话可以点击创建按钮，也可以上架后给更多人使用<img src="https://img-blog.csdnimg.cn/direct/9aa164798c26477e957f4ec970ce316d.png#pic_center" alt="xunfei5"><br>至此，一个利用AI特点制作的应用就完成了，虽然很简单，但是开启了一个怎样使用AI的时代，话说我之前真不知道怎么用AI，做平台的这些人脑子真是太灵光了</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>AI不是万能的，要学会利用AI，合理掌控AI为我所用</li><li>利用AI庞大知识库的特点，进一步封装成特定的应用，可以更好的满足需求</li><li>完事开头难，有时不是你不会，只是你不知，一旦开了头便打开了一扇窗</li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/138169455" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>面对未知的状况，每个人心里都会有些小九九，根据自己的状况做出合适的选择，一旦选了便不需再回头，水有舟可渡，山有路可行~</p><p>2024-5-6 21:41:21</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;面对AI铺天盖地的新闻，大有替代万事万物的之势，但如果要问AI能做什么？你是否会在心里打个问号？它好像只能用来聊天，又好像什么都能做，ChatGPT现在是我每天都要使用的工具，每天只是对话问问题，特定领域的问题确实比搜索引擎更精准一些，但是对AI的使用也就仅限于此，难道AI只有这么大点能力吗？&lt;/p&gt;
    
    </summary>
    
      <category term="AI" scheme="http://AlbertGithubHome.github.io/blog/categories/AI/"/>
    
    
      <category term="人工智能" scheme="http://AlbertGithubHome.github.io/blog/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
      <category term="AI" scheme="http://AlbertGithubHome.github.io/blog/tags/AI/"/>
    
      <category term="Thinking" scheme="http://AlbertGithubHome.github.io/blog/tags/Thinking/"/>
    
      <category term="卖铲子" scheme="http://AlbertGithubHome.github.io/blog/tags/%E5%8D%96%E9%93%B2%E5%AD%90/"/>
    
  </entry>
  
  <entry>
    <title>帧同步入门项目LockstepDemo的初步学习</title>
    <link href="http://AlbertGithubHome.github.io/blog/2024/04/25/%E5%B8%A7%E5%90%8C%E6%AD%A5%E5%85%A5%E9%97%A8%E9%A1%B9%E7%9B%AELockstepDemo%E7%9A%84%E5%88%9D%E6%AD%A5%E5%AD%A6%E4%B9%A0/"/>
    <id>http://AlbertGithubHome.github.io/blog/2024/04/25/帧同步入门项目LockstepDemo的初步学习/</id>
    <published>2024-04-24T17:00:00.000Z</published>
    <updated>2024-04-29T14:56:38.580Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>上一篇文章介绍了 <a href="https://github.com/ookcode/LockstepDemo" target="_blank" rel="noopener">LockstepDemo</a> 这个项目可以作为帧同步入门读物，解决了跨域限制的问题以后，这个开源项目就可以运行起来啦，虽然我没有使用js写过实际的项目，但看的多了自然也能看懂大部分的js代码了，作为一个帧同步领域的小白，我开始了阅读这个项目代码的旅程，看过之后确实解开了我之前的迷惑，所以简单记录一下学习心得。</p><ul><li>基础的帧同步模式，每个客户端必须回报给服务器收到帧数，服务器再次发送确认包才执行帧数据，否则所有人等待，也就是一卡全卡。</li><li>基于现在手游的流行程度和弱网环境，手游一般都采取乐观锁模式。即收到服务器推帧后，客户端立即执行，不等待其他人。这样卡顿的人自己卡，不影响其他人的游戏体验。同时卡顿的人在收到数据后，自行加速补帧来追赶上正确的游戏速度。</li></ul><a id="more"></a><h2 id="连帧同步都出SDK了"><a href="#连帧同步都出SDK了" class="headerlink" title="连帧同步都出SDK了"></a>连帧同步都出SDK了</h2><p>插播一条消息，今天在搜索帧同步资料的时候，无意间发现了游戏巨头——腾讯居然发布了<a href="https://gcloud.tencent.com/pages/documents/details.html?projectId=208&amp;docId=3013" target="_blank" rel="noopener">帧同步SDK-LockStep</a>，简直“丧心病狂”，真的是盘子大了什么都做啊，不过也挺好，我可以从中学到不少问题的处理方案，我摘抄官方文档部分内容，感兴趣的可以去看看</p><blockquote><p>帧同步（LockStep）服务为手游开发提供一套快速、可靠的帧同步游戏开发框架。基于GCloud云服务<br>进行快速部署，同时支持TCP、UDP、RUDP三种通道。帧同步开发框架提供一致性数学库与一致性检测工具，并且针对弱网设计具有高可靠、低延时的特性。</p><p>帧同步与更为传统的状态同步均为游戏常见同步方案，主要区别在于：状态同步主要逻辑计算放在服务器端，将计算结果下发给客户端；而帧同步服务器仅仅起到收集客户端输入并广播的作用。基于帧同步相对状态同步流量消耗更低、开发效率更高、打击感更好等优点，《王者荣耀》选择了帧同步方案。</p><p>《拳皇命运》项目从完全不熟悉帧同步技术的情况下，接入SDK仅用了两个月时间，将原有状态同步游戏，改造成为帧同步游戏；项目仅需编写游戏逻辑，无需关心同步、网络品质、录像回放等核心功能。</p></blockquote><p>专业的事情交给专业的人来做，如果之前没有积累，将这套SDK直接拿过来用也是不错的，我看到支持C++和C#两种语言，其他的语言就得自己去沟通了</p><h1 id="LockstepDemo"><a href="#LockstepDemo" class="headerlink" title="LockstepDemo"></a>LockstepDemo</h1><p>言归正传，开始阅读LockstepDemo这个项目的源码，服务端app.js使用node运行，前端main.js+main.css+index.html，在浏览器中运行，其实主要的逻辑代码就在main.js中，后端就只有app.js一个文件，总共166行，前端还引用了jquery.min.js和socket.io.js两个库文件，但包含主要逻辑代码的main.js文件仅有328行。</p><p>在开始阅读自定义逻辑代码之前先来看看引用的这两个库：</p><h2 id="socket-io-js"><a href="#socket-io-js" class="headerlink" title="socket.io.js"></a>socket.io.js</h2><p>负责网络的建立、管理，消息的发送等等，看了逻辑中的调用真的是挺方便的</p><ul><li><code>var io = require(&quot;socket.io&quot;)(server）</code>: 创建基于 Node.js 的 WebSocket 服务器，并将其绑定到了一个 HTTP 服务器实例 server 上</li><li><code>io.on(&#39;connection&#39;, function (socket) {...])</code>: 使用Socket.IO 的服务器实例的 on 方法来监听客户端与服务器建立连接的事件</li><li><code>socket.on(&#39;join&#39;, function(account) {...})</code>: 使用与客户端建立的连接的对象 socket 的 on 方法来监听客户端发送的 ‘join’ 事件</li><li><code>socket.emit(&quot;open&quot;, {...})</code>: 使用了 Socket.IO 库的 emit 方法来向当前客户端发送一个名为 “open” 的自定义事件，并附带自定义对象作为数据</li><li><code>socket.broadcast.emit(&#39;system&#39;, ...)</code>: 用于向除当前连接的客户端之外的所有客户端发送消息</li><li><code>io.sockets.emit(&#39;start&#39;, {...})</code>: 用于向所有连接的客户端发送消息</li></ul><h2 id="jquery-min-js"><a href="#jquery-min-js" class="headerlink" title="jquery.min.js"></a>jquery.min.js</h2><p>即使没有做过前端，jQuery这个库的大名也应该听过，它是一个流行的 JavaScript 库，简化了在网页开发中的 JavaScript 编程。它提供了一系列功能强大且易于使用的 API，使得诸如 DOM 操作、事件处理、动画效果、AJAX 请求等任务变得更加简单和高效，主要特点如下：</p><ul><li>简化 DOM 操作：提供了简洁而强大的 DOM 操作方法，使得选择元素、修改元素属性、添加/删除元素等操作变得更加便捷</li><li>事件处理：提供了简单易用的事件处理方法，可以方便地为元素绑定事件、移除事件、触发事件等，大大简化了事件处理的代码编写</li><li>动画效果：提供了丰富的动画效果和特效，可以通过简单的方法实现页面元素的平滑过渡、淡入淡出、滑动等效果，为用户提供更流畅的交互体验</li><li>AJAX 请求：提供了简洁的 AJAX 方法，可以方便地进行异步数据加载和交互，从而实现更灵活和动态的网页内容加载和更新</li><li>跨浏览器兼容性：封装了复杂的跨浏览器兼容性处理，使得开发者可以更加轻松地编写跨浏览器兼容的代码</li></ul><p>简单来说它就是一个封装了常用操作的库，稍后会在main.js发现它的使用方法，简单摘录如下：</p><ul><li><strong>文档加载完成事件</strong>：<code>$(function () {...})</code> 用于在文档加载完成后执行的函数，这是 jQuery 的快捷方式，等同于 <code>$(document).ready(function() {...})</code>，表示在 DOM 树构建完成后执行指定的函数</li><li><strong>元素选择</strong>：<code>$(&#39;body&#39;)</code>、<code>$(&#39;#start_btn&#39;)</code>、<code>$(&#39;#reconnect_btn&#39;)</code> 等通过 jQuery 选择器选择了 HTML 元素。这些选择器能够基于元素的标签名、ID、类名等来选择元素，返回 jQuery 对象，以便进行后续的操作</li><li><strong>事件处理</strong>：<code>$(&#39;body&#39;).keydown(function(e) {...})</code> 注册了键盘事件处理函数，当键盘按键按下时执行相应的操作</li><li><strong>动画效果</strong>：<code>$(&quot;#tips&quot;).animate({...})</code> 使用了 jQuery 的动画效果，在提示框显示时执行动画效果，让提示框从屏幕中间上方滑动到屏幕中间</li><li><strong>样式操作</strong>：<code>$(&quot;#tips&quot;).show()</code>、<code>$(&quot;#tips&quot;).fadeOut()</code> 等使用了 jQuery 提供的方法来控制元素的显示和隐藏</li></ul><p>在阅读app.js和main.js之前还是得说明一下，今天只介绍核心逻辑，像断线重连、消息提示、显示网络延迟等功能，都是在核心逻辑上的补充和优化，可以先忽略不看，并且这次看代码发现，整个运动的表现和实现逻辑是符合牛顿第一定律的，真的挺有意思：</p><blockquote><p>一切物体总保持匀速直线运动状态或静止状态，直到有外力迫使它改变这种状态为止</p></blockquote><p>这只是这个项目的特点，并不是所有的游戏都是这样的，有些游戏的实现就是和这惯性定律相违背的，比如很多游戏必须一直拖动摇杆才会移动，否则就会停住静止，它们所表达出来的就是，“力是维持物体运动的关键”，好了，扯得有点远了，一起看看代码实现吧</p><h2 id="服务器app-js"><a href="#服务器app-js" class="headerlink" title="服务器app.js"></a>服务器app.js</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> server = <span class="built_in">require</span>(<span class="string">'http'</span>).Server()</span><br><span class="line"><span class="keyword">var</span> io = <span class="built_in">require</span>(<span class="string">"socket.io"</span>)(server, &#123;</span><br><span class="line">    allowEIO3: <span class="literal">true</span>,</span><br><span class="line">    cors: &#123;</span><br><span class="line">      origin: [<span class="string">"http://127.0.0.1:8080"</span>, <span class="string">"null"</span>],</span><br><span class="line">      methods: [<span class="string">"GET"</span>, <span class="string">"POST"</span>],</span><br><span class="line">      credentials: <span class="literal">true</span> <span class="comment">// 设置为true以允许使用凭据</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听3000端口</span></span><br><span class="line">server.listen(<span class="number">3000</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">"服务器启动成功，监听端口3000"</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>定义服务器实例，启动并监听3000端口，这里已经做了跨域允许访问的配置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> g_onlines = &#123;&#125; <span class="comment">// 所有在线玩家</span></span><br><span class="line"><span class="keyword">var</span> g_commands = <span class="keyword">new</span> <span class="built_in">Array</span>() <span class="comment">// 指令数组</span></span><br><span class="line"><span class="keyword">var</span> g_commands_histroy = <span class="keyword">new</span> <span class="built_in">Array</span>() <span class="comment">// 历史指令，用于断线重连</span></span><br><span class="line"><span class="keyword">var</span> g_joinCount = <span class="number">0</span> <span class="comment">// 已准备的人数</span></span><br><span class="line"><span class="keyword">var</span> g_maxJoinCount = <span class="number">2</span> <span class="comment">// 最大人数</span></span><br><span class="line"><span class="keyword">var</span> g_stepTime = <span class="number">0</span> <span class="comment">// 当前step时间戳</span></span><br><span class="line"><span class="keyword">var</span> g_stepInterval = <span class="number">100</span> <span class="comment">// 每个step的间隔ms</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 游戏状态枚举</span></span><br><span class="line"><span class="keyword">var</span> STATUS = &#123;</span><br><span class="line">   WAIT:<span class="number">1</span>,</span><br><span class="line">   START:<span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> g_gameStatus = STATUS.WAIT</span><br></pre></td></tr></table></figure><p>一些游戏全局变量和游戏状态枚举的定义，注释写的很详细，记一遍看下面的逻辑时能想起来就行</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// frame定时器</span></span><br><span class="line"><span class="keyword">var</span> stepUpdateCounter = <span class="number">0</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">update</span>(<span class="params">dt</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">var</span> now = <span class="built_in">Date</span>.now()</span><br><span class="line">   <span class="keyword">if</span>(g_gameStatus == STATUS.START) &#123;</span><br><span class="line">      stepUpdateCounter += dt</span><br><span class="line">      <span class="keyword">if</span>(stepUpdateCounter &gt;= g_stepInterval) &#123;</span><br><span class="line">         g_stepTime++</span><br><span class="line">         stepUpdate()</span><br><span class="line">         stepUpdateCounter -= g_stepInterval</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动定时器</span></span><br><span class="line"><span class="keyword">var</span> lastUpdate = <span class="built_in">Date</span>.now()</span><br><span class="line">setInterval(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="keyword">var</span> now = <span class="built_in">Date</span>.now()</span><br><span class="line">   <span class="keyword">var</span> dt = now - lastUpdate</span><br><span class="line">   lastUpdate = now</span><br><span class="line">   update(dt)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>开始进入主要逻辑，lastUpdate是上次走过的时间，在游戏开始<code>g_gameStatus == STATUS.START</code>后不断将 <code>dt</code> 积累到变量 <code>stepUpdateCounter</code>，超过一帧的间隔后执行一帧逻辑 <code>stepUpdate()</code>，<code>setInterval</code> 是内部函数，第二个参数表示调用的时间间隔，默认为0，可以可以认为是游戏中常用的 <code>tick()</code> 函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// step定时器</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">stepUpdate</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="comment">// 过滤同帧多次指令</span></span><br><span class="line">   <span class="keyword">var</span> message = &#123;&#125;</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> g_onlines) &#123;</span><br><span class="line">      message[key] = &#123;<span class="attr">step</span>:g_stepTime, <span class="attr">id</span>:key&#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; g_commands.length; ++i) &#123;</span><br><span class="line">      <span class="keyword">var</span> command = g_commands[i]</span><br><span class="line">      command.step = g_stepTime</span><br><span class="line">      message[command.id] = command</span><br><span class="line">   &#125;</span><br><span class="line">   g_commands = <span class="keyword">new</span> <span class="built_in">Array</span>()</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 发送指令</span></span><br><span class="line">   <span class="keyword">var</span> commands = <span class="keyword">new</span> <span class="built_in">Array</span>()</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> message) &#123;</span><br><span class="line">      commands.push(message[key])</span><br><span class="line">   &#125;</span><br><span class="line">   g_commands_histroy.push(commands)</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> g_onlines) &#123;</span><br><span class="line">      g_onlines[key].socket.emit(<span class="string">'message'</span>, <span class="keyword">new</span> <span class="built_in">Array</span>(commands))</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是转发客户端操作的核心函数，首先是遍历所有玩家 <code>g_onlines</code>，执行 <code>message[key] = {step:g_stepTime, id:key}</code> 为每个玩家构建一个空指令，然后遍历当前收到的所有命令 <code>g_commands</code>，将命令的帧值设置为当前帧，并且过掉一帧中的多个指令，保证一帧只能朝一个方向运动，将收集到的所有指令 <code>commands</code> 通过 <code>socket.emit()</code> 函数发送给所有玩家 <code>g_onlines</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">io.on(<span class="string">'connection'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">socket</span>) </span>&#123;</span><br><span class="line">   socket.emit(<span class="string">"open"</span>, &#123;<span class="attr">id</span>:socket.id, <span class="attr">stepInterval</span>:g_stepInterval&#125;)</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 获取用户账户</span></span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">getAccount</span>(<span class="params">socketId</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> g_onlines) &#123;</span><br><span class="line">         <span class="keyword">if</span>(socketId == g_onlines[key].socket.id) &#123;</span><br><span class="line">            <span class="keyword">return</span> key</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这是服务器上所有事件监听的基础，<code>io</code> 监听新玩家连接事件，建立连接后向客户端发送一个名为 “open” 的自定义事件，并附带了一个包含 id 和 stepInterval 属性的对象作为数据，id的值是 <code>socket.id</code>，<code>stepInterval</code>表示每帧的时间间隔，<code>getAccount()</code> 函数的作用通过<code>socket.id</code>获取账号名</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">socket.on(<span class="string">'join'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">account</span>) </span>&#123;</span><br><span class="line">   <span class="comment">// 顶号/断线重连</span></span><br><span class="line">   <span class="keyword">if</span>(g_onlines[account]) &#123;</span><br><span class="line">      g_onlines[account].socket.emit(<span class="string">'system'</span>, <span class="string">"被顶号了"</span>)</span><br><span class="line">      g_onlines[account].socket.disconnect()</span><br><span class="line">      <span class="keyword">if</span>(g_gameStatus == STATUS.START) &#123;</span><br><span class="line">         g_onlines[account] = &#123;<span class="attr">socket</span>: socket, <span class="attr">online</span>: <span class="literal">true</span>&#125;</span><br><span class="line">         socket.emit(<span class="string">'join'</span>, &#123;<span class="attr">result</span>:<span class="literal">true</span>, <span class="attr">message</span>:<span class="string">"正在断线重连..."</span>&#125;)</span><br><span class="line">         <span class="built_in">console</span>.log(account, <span class="string">"重连游戏"</span>)</span><br><span class="line">         socket.broadcast.emit(<span class="string">'system'</span>, account + <span class="string">"重新连接！"</span>)</span><br><span class="line">         socket.emit(<span class="string">'start'</span>, &#123;<span class="attr">player</span>:<span class="built_in">Object</span>.keys(g_onlines)&#125;)</span><br><span class="line">         socket.emit(<span class="string">'message'</span>, g_commands_histroy)</span><br><span class="line">         <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 房间已满</span></span><br><span class="line">   <span class="keyword">if</span>(g_joinCount == g_maxJoinCount) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"房间已满"</span>, account, <span class="string">"加入失败"</span>)</span><br><span class="line">      socket.emit(<span class="string">'system'</span>, <span class="string">"房间已满"</span>)</span><br><span class="line">      socket.disconnect()</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 加入游戏</span></span><br><span class="line">   <span class="keyword">if</span>(g_joinCount &lt; g_maxJoinCount) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(account, <span class="string">"加入游戏"</span>)</span><br><span class="line">      socket.emit(<span class="string">'join'</span>, &#123;<span class="attr">result</span>:<span class="literal">true</span>, <span class="attr">message</span>:<span class="string">"匹配中..."</span>&#125;)</span><br><span class="line">      g_onlines[account] = &#123;<span class="attr">socket</span>: socket, <span class="attr">online</span>: <span class="literal">true</span>&#125;</span><br><span class="line">      g_joinCount++</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 开始游戏</span></span><br><span class="line">   <span class="keyword">if</span>(g_joinCount == g_maxJoinCount) &#123;</span><br><span class="line">      g_commands = <span class="keyword">new</span> <span class="built_in">Array</span>()</span><br><span class="line">      g_commands_histroy = <span class="keyword">new</span> <span class="built_in">Array</span>()</span><br><span class="line">      g_gameStatus = STATUS.START</span><br><span class="line">      io.sockets.emit(<span class="string">'start'</span>, &#123;<span class="attr">player</span>:<span class="built_in">Object</span>.keys(g_onlines)&#125;)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这是监听socket收到 <code>&#39;join&#39;</code> 事件的处理函数，实现逻辑有些技巧，通过查询账号是否已经登录过服务器，来判定是否为重连，如果为重连则一次发送 <code>&#39;join&#39;</code>、<code>&#39;start&#39;</code>、<code>&#39;message&#39;</code>事件和数据，其中 <code>&#39;message&#39;</code> 事件中的数据是从游戏开始以来的所有指令</p><p>如果不是重连就要判断匹配人数，超过到 <code>g_maxJoinCount</code> 不允许进入，达到<code>g_maxJoinCount</code>游戏开始，通知客户开始游戏，否则通知客户端正在匹配中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">socket.on(<span class="string">'timeSync'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">time</span>) </span>&#123;</span><br><span class="line">   socket.emit(<span class="string">'timeSync'</span>, &#123;<span class="attr">client</span>:time, <span class="attr">server</span>:<span class="built_in">Date</span>.now()&#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">socket.on(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">json</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(g_gameStatus == STATUS.START) &#123;</span><br><span class="line">      <span class="comment">// <span class="doctag">TODO:</span>过滤高延迟的包 (json.step)</span></span><br><span class="line">      json.id = getAccount(socket.id)</span><br><span class="line">      <span class="keyword">if</span>(json.id) &#123;</span><br><span class="line">         g_commands.push(json)</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><code>socket.on(&#39;timeSync&#39;, function(time) {...})</code> 收到后立即返回，用于客户端计算延迟，<code>socket.on(&#39;message&#39;, function(json) {...})</code>，收到客户端指令后将其放入全局缓存指令，等待每帧处理</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">socket.on(<span class="string">'disconnect'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="keyword">var</span> account = getAccount(socket.id)</span><br><span class="line">   <span class="keyword">if</span>(account) &#123;</span><br><span class="line">      g_onlines[account].online = <span class="literal">false</span></span><br><span class="line">      <span class="built_in">console</span>.log(account, <span class="string">"离开游戏"</span>)</span><br><span class="line">      <span class="keyword">var</span> isGameOver = <span class="literal">true</span></span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> g_onlines) &#123;</span><br><span class="line">         <span class="keyword">if</span>(g_onlines[key].online) &#123;</span><br><span class="line">            isGameOver = <span class="literal">false</span></span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(isGameOver) &#123;</span><br><span class="line">         io.sockets.emit(<span class="string">'system'</span>, <span class="string">"游戏结束"</span>)</span><br><span class="line">         g_joinCount = <span class="number">0</span></span><br><span class="line">         g_stepTime = <span class="number">0</span></span><br><span class="line">         g_gameStatus = STATUS.WAIT</span><br><span class="line">         g_onlines = &#123;&#125;</span><br><span class="line">         <span class="built_in">console</span>.log(<span class="string">"游戏结束"</span>)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         io.sockets.emit(<span class="string">'system'</span>, account + <span class="string">"离开了游戏！"</span>)</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><code>socket.on(&#39;disconnect&#39;, function () {...})</code> 断开连接是否要结束游戏的处理逻辑，如果在玩家断开后还有其他玩家在线，则游戏继续，等待玩家重连回来，否则有些结束</p><p>完整的游戏代码就这么多，还是比较清晰的，记住服务器上监听和发送的各种事件，比如 <code>&#39;join&#39;</code>、<code>&#39;start&#39;</code>、<code>&#39;message&#39;</code>、<code>&#39;disconnect&#39;</code> 等，一会再客户端代码分析的时候也会出现，对照着分析逻辑就串起来了</p><h2 id="客户端main-js"><a href="#客户端main-js" class="headerlink" title="客户端main.js"></a>客户端main.js</h2><p>客户端的代码行数相对多一些，我只把重要的部分列举出来：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 游戏对象</span></span><br><span class="line"><span class="keyword">var</span> GameObject = <span class="function"><span class="keyword">function</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">this</span>.id = id</span><br><span class="line">   <span class="keyword">this</span>.x = <span class="number">0</span></span><br><span class="line">   <span class="keyword">this</span>.y = <span class="number">0</span></span><br><span class="line">   <span class="keyword">this</span>.direction = DIRECTION.STOP</span><br><span class="line">   <span class="keyword">this</span>.speed = <span class="number">100</span></span><br><span class="line">   <span class="keyword">this</span>.move = <span class="function"><span class="keyword">function</span> (<span class="params">dt</span>) </span>&#123;</span><br><span class="line">      dt = dt / <span class="number">1000</span></span><br><span class="line">      <span class="keyword">var</span> x = <span class="keyword">this</span>.x</span><br><span class="line">      <span class="keyword">var</span> y = <span class="keyword">this</span>.y</span><br><span class="line">      <span class="keyword">switch</span>(<span class="keyword">this</span>.direction) &#123;</span><br><span class="line">         <span class="keyword">case</span> DIRECTION.UP:</span><br><span class="line">         &#123;</span><br><span class="line">            y -= <span class="keyword">this</span>.speed * dt</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">case</span> DIRECTION.DOWN:</span><br><span class="line">         &#123;</span><br><span class="line">            y += <span class="keyword">this</span>.speed * dt</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">case</span> DIRECTION.LEFT:</span><br><span class="line">         &#123;</span><br><span class="line">            x -= <span class="keyword">this</span>.speed * dt</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">case</span> DIRECTION.RIGHT:</span><br><span class="line">         &#123;</span><br><span class="line">            x += <span class="keyword">this</span>.speed * dt</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(x &lt;= (WIDTH - BOX_SIZE) &amp;&amp; x &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">         <span class="keyword">this</span>.x = x</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(y &lt;= (HEIGHT - BOX_SIZE) &amp;&amp; y &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">         <span class="keyword">this</span>.y = y</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码定义了一个函数，该函数可以用来创建游戏对象（Game Objects）的实例，在 JavaScript 中，函数也可以用来定义对象的构造函数。在这个例子中，函数 <code>GameObject</code> 就是一个构造函数，用于创建具有特定属性和方法的游戏对象。当你使用 <code>new GameObject(id)</code> 来调用这个函数时，它会返回一个新的对象实例，该实例拥有指定的 <code>id</code>、<code>x</code>、<code>y</code>、<code>direction</code>、<code>speed</code> 属性以及 <code>move()</code> 方法，尽管这段代码中的 <code>GameObject</code> 是一个函数，但它被设计用来创建具有特定属性和行为的对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="comment">// 画布</span></span><br><span class="line">   <span class="keyword">var</span> context = <span class="built_in">document</span>.getElementById(<span class="string">"canvas"</span>).getContext(<span class="string">"2d"</span>)</span><br><span class="line">   <span class="comment">// 每个step的间隔ms，服务器返回</span></span><br><span class="line">   <span class="keyword">var</span> stepInterval = <span class="number">0</span></span><br><span class="line">   <span class="comment">// 当前step时间戳</span></span><br><span class="line">   <span class="keyword">var</span> stepTime = <span class="number">0</span></span><br><span class="line">   <span class="comment">// 输入方向</span></span><br><span class="line">   <span class="keyword">var</span> inputDirection = <span class="literal">null</span></span><br><span class="line">   <span class="comment">// 游戏状态</span></span><br><span class="line">   <span class="keyword">var</span> gameStatus = STATUS.WAIT</span><br><span class="line">   <span class="comment">// 接受指令</span></span><br><span class="line">   <span class="keyword">var</span> recvCommands = <span class="keyword">new</span> <span class="built_in">Array</span>()</span><br><span class="line">   <span class="comment">// 所有游戏对象</span></span><br><span class="line">   <span class="keyword">var</span> gameObjects = &#123;&#125;</span><br><span class="line">   <span class="comment">// 是否连接socket</span></span><br><span class="line">   <span class="keyword">var</span> isConnected = <span class="literal">false</span></span><br><span class="line">   <span class="comment">// 当前执行中的指令</span></span><br><span class="line">   <span class="keyword">var</span> runningCommands = <span class="literal">null</span></span><br><span class="line">   <span class="comment">// 当前用户</span></span><br><span class="line">   <span class="keyword">var</span> currentAccount = <span class="literal">null</span></span><br><span class="line">   <span class="comment">// 是否正在加速运行延迟到达的包</span></span><br><span class="line">   <span class="keyword">var</span> isFastRunning = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 初始化UI显示</span></span><br><span class="line">   $(<span class="string">"#content"</span>).hide()</span><br><span class="line">   $(<span class="string">"#login"</span>).show()</span><br><span class="line">   $(<span class="string">"#tips"</span>).hide()</span><br><span class="line"></span><br><span class="line">   <span class="comment">//...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这是利用jQuery库的写法，等同于 <code>$(document).ready(function() {...})</code>，表示在 DOM 树构建完成后执行指定的函数，也就是每次加载完页面都会执行这个函数，这个函数里包含了客户端绝大部分逻辑，函数的开始定义了一些变量，用于记录游戏数据，具体含义参考注释即可，之后便初始化了界面显示</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 连接socket</span></span><br><span class="line">socket = io.connect(<span class="string">'http://127.0.0.1:3000'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// socket连接成功</span></span><br><span class="line">socket.on(<span class="string">'open'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">json</span>) </span>&#123;</span><br><span class="line">   isConnected = <span class="literal">true</span></span><br><span class="line">   stepInterval = json.stepInterval</span><br><span class="line">   id = json.id</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">"Socket连接成功："</span>, id)</span><br><span class="line">   <span class="comment">// 断线重连自动登录</span></span><br><span class="line">   <span class="keyword">if</span>(localStorage.account) &#123;</span><br><span class="line">      setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">         $(<span class="string">"#account"</span>).val(localStorage.account)</span><br><span class="line">         localStorage.account = <span class="string">""</span></span><br><span class="line">         $(<span class="string">'#start_btn'</span>).click()</span><br><span class="line">      &#125;, <span class="number">0</span>)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>使用 <code>socket = io.connect(&#39;http://127.0.0.1:3000&#39;)</code> 语句连接服务器，再接收到 <code>&#39;open&#39;</code> 事件之后，使用服务器同步数据给客户端变量赋值，函数末尾是根据本地存储情况决定是否需要重连，这部分逻辑可以先不看</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 收到游戏开始事件</span></span><br><span class="line">socket.on(<span class="string">'start'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">json</span>) </span>&#123;</span><br><span class="line">   <span class="comment">// 初始化GameObject</span></span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; json.player.length; ++i) &#123;</span><br><span class="line">      <span class="keyword">var</span> id = json.player[i]</span><br><span class="line">      gameObjects[id] = <span class="keyword">new</span> GameObject(id)</span><br><span class="line">   &#125;</span><br><span class="line">   gameStatus = STATUS.START</span><br><span class="line">   stepTime = <span class="number">0</span></span><br><span class="line">   showTips(<span class="string">"游戏开始"</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 收到指令</span></span><br><span class="line">socket.on(<span class="string">'message'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">json</span>)</span>&#123;</span><br><span class="line">   <span class="comment">// 储存收到的指令</span></span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; json.length; ++i) &#123;</span><br><span class="line">      <span class="keyword">var</span> command = json[i]</span><br><span class="line">      recvCommands.push(command)</span><br><span class="line">      stepTime = command[command.length - <span class="number">1</span>].step</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"**** recv "</span> + stepTime + <span class="string">" ****"</span>)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>收到游戏开始事件<code>&#39;start&#39;</code>之后，根据服务器下发的数据创建游戏对象 <code>gameObjects[id] = new GameObject(id)</code>， 收到<code>&#39;message&#39;</code>缓存服务器发送的指令到 <code>recvCommands</code> 中，后续在tick函数中处理</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发送指令</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sendCommand</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(isFastRunning) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"正在加速执行延迟包，无法发送指令！"</span>)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">var</span> direction = inputDirection</span><br><span class="line">   socket.emit(<span class="string">"message"</span>, &#123;</span><br><span class="line">      direction: direction,</span><br><span class="line">      step:stepTime,</span><br><span class="line">   &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 键盘事件</span></span><br><span class="line">$(<span class="string">'body'</span>).keydown(<span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(gameStatus != STATUS.START) <span class="keyword">return</span></span><br><span class="line">   <span class="keyword">switch</span>(e.keyCode) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">38</span>:</span><br><span class="line">      &#123;</span><br><span class="line">         inputDirection = DIRECTION.UP</span><br><span class="line">         <span class="keyword">break</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">40</span>:</span><br><span class="line">      &#123;</span><br><span class="line">         inputDirection = DIRECTION.DOWN</span><br><span class="line">         <span class="keyword">break</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">37</span>:</span><br><span class="line">      &#123;</span><br><span class="line">         inputDirection = DIRECTION.LEFT</span><br><span class="line">         <span class="keyword">break</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">39</span>:</span><br><span class="line">      &#123;</span><br><span class="line">         inputDirection = DIRECTION.RIGHT</span><br><span class="line">         <span class="keyword">break</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">13</span>:</span><br><span class="line">      &#123;</span><br><span class="line">         inputDirection = DIRECTION.STOP</span><br><span class="line">         <span class="keyword">break</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   sendCommand()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>监听键盘按键，键盘上下左右键移动方块，回车键停止方块，每次将按键指令发送给服务器，重点看下这段实现，这就涉及到我们前边提到的牛顿第一定律，也就是每次按键时向服务器发送一次，可以改变物体的运动方向或者停止，之后便不再向服务器发消息了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// frame定时器</span></span><br><span class="line"><span class="keyword">var</span> stepUpdateCounter = <span class="number">0</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">update</span>(<span class="params">dt</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(gameStatus == STATUS.START) &#123;</span><br><span class="line">      <span class="comment">// <span class="doctag">TODO:</span> 逻辑/UI分离</span></span><br><span class="line">      stepUpdateCounter += dt</span><br><span class="line">      <span class="keyword">if</span>(stepUpdateCounter &gt;= stepInterval) &#123;</span><br><span class="line">         stepUpdate()</span><br><span class="line">         stepUpdateCounter -= stepInterval</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 积攒的包过多时要加速运行</span></span><br><span class="line">      <span class="keyword">var</span> scale = <span class="built_in">Math</span>.ceil(recvCommands.length / <span class="number">3</span>)</span><br><span class="line">      <span class="keyword">if</span>(scale &gt; <span class="number">10</span>) scale = <span class="number">10</span></span><br><span class="line">      isFastRunning = (scale &gt; <span class="number">1</span>)</span><br><span class="line">      <span class="comment">// 执行指令</span></span><br><span class="line">      <span class="keyword">if</span>(recvCommands.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">         <span class="keyword">var</span> ms = dt * scale</span><br><span class="line">         <span class="keyword">if</span>(runningCommands == <span class="literal">null</span>) &#123;</span><br><span class="line">            runningCommands = recvCommands[<span class="number">0</span>]</span><br><span class="line">            runningCommands.ms = stepInterval</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span>(runningCommands.ms &lt; ms) &#123;</span><br><span class="line">            ms = runningCommands.ms</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; runningCommands.length; i++) &#123;</span><br><span class="line">            <span class="keyword">var</span> command = runningCommands[i]</span><br><span class="line">            <span class="keyword">if</span>(runningCommands.ms == stepInterval) <span class="built_in">console</span>.log(command)</span><br><span class="line">            <span class="keyword">var</span> obj = gameObjects[command.id]</span><br><span class="line">            <span class="keyword">if</span>(command.direction) &#123;</span><br><span class="line">               obj.direction = command.direction</span><br><span class="line">            &#125;</span><br><span class="line">            obj.move(ms)</span><br><span class="line">         &#125;</span><br><span class="line">         runningCommands.ms = runningCommands.ms - ms</span><br><span class="line">         <span class="keyword">if</span>(runningCommands.ms == <span class="number">0</span>) &#123;</span><br><span class="line">            recvCommands.shift()</span><br><span class="line">            runningCommands = <span class="literal">null</span></span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 绘制</span></span><br><span class="line">      context.clearRect(<span class="number">0</span>, <span class="number">0</span>, WIDTH, HEIGHT)</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> gameObjects) &#123;</span><br><span class="line">         <span class="keyword">var</span> obj = gameObjects[key]</span><br><span class="line">         context.fillStyle = <span class="string">"#000000"</span></span><br><span class="line">         context.fillRect(obj.x, obj.y, BOX_SIZE, BOX_SIZE)</span><br><span class="line">         context.font = <span class="string">"15px Courier New"</span>;</span><br><span class="line">         context.fillStyle = <span class="string">"#FFFFFF"</span>;</span><br><span class="line">         context.fillText(key, obj.x, obj.y + BOX_SIZE, BOX_SIZE);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动定时器</span></span><br><span class="line"><span class="keyword">var</span> lastUpdate = <span class="built_in">Date</span>.now()</span><br><span class="line">setInterval(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="keyword">var</span> now = <span class="built_in">Date</span>.now()</span><br><span class="line">   <span class="keyword">var</span> dt = now - lastUpdate</span><br><span class="line">   lastUpdate = now</span><br><span class="line">   update(dt)</span><br><span class="line">   <span class="keyword">if</span>(isConnected == <span class="literal">true</span>) &#123;</span><br><span class="line">      socket.emit(<span class="string">"timeSync"</span>, now)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这段代码是客户端的核心逻辑，需要多看几遍，看懂了这一段，帧同步的思想也就基本算掌握了，调用 <code>setInterval</code> 的逻辑比较好理解，之前在服务器代码中也存在，就是启动tick函数，不断积累 <code>dt</code>，用于做客户端物体移动的表现</p><p>重点在 <code>setInterval</code> 我们化繁为简，不用看函数末尾的绘制部分，这一段就是根据GameObject的坐标绘制图形，因为这个项目没有实现UI表现和逻辑分离，所以函数开始更新变量 <code>stepUpdateCounter</code>的逻辑也没有用，简化完成后函数逻辑就剩下这些：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">update</span>(<span class="params">dt</span>) </span>&#123;</span><br><span class="line">   <span class="comment">// 积攒的包过多时要加速运行</span></span><br><span class="line">   <span class="keyword">var</span> scale = <span class="built_in">Math</span>.ceil(recvCommands.length / <span class="number">3</span>)</span><br><span class="line">   <span class="keyword">if</span>(scale &gt; <span class="number">10</span>) scale = <span class="number">10</span></span><br><span class="line">   isFastRunning = (scale &gt; <span class="number">1</span>)</span><br><span class="line">   <span class="comment">// 执行指令</span></span><br><span class="line">   <span class="keyword">if</span>(recvCommands.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">var</span> ms = dt * scale</span><br><span class="line">      <span class="keyword">if</span>(runningCommands == <span class="literal">null</span>) &#123;</span><br><span class="line">         runningCommands = recvCommands[<span class="number">0</span>]</span><br><span class="line">         runningCommands.ms = stepInterval</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(runningCommands.ms &lt; ms) &#123;</span><br><span class="line">         ms = runningCommands.ms</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; runningCommands.length; i++) &#123;</span><br><span class="line">         <span class="keyword">var</span> command = runningCommands[i]</span><br><span class="line">         <span class="keyword">if</span>(runningCommands.ms == stepInterval) <span class="built_in">console</span>.log(command)</span><br><span class="line">         <span class="keyword">var</span> obj = gameObjects[command.id]</span><br><span class="line">         <span class="keyword">if</span>(command.direction) &#123;</span><br><span class="line">            obj.direction = command.direction</span><br><span class="line">         &#125;</span><br><span class="line">         obj.move(ms)</span><br><span class="line">      &#125;</span><br><span class="line">      runningCommands.ms = runningCommands.ms - ms</span><br><span class="line">      <span class="keyword">if</span>(runningCommands.ms == <span class="number">0</span>) &#123;</span><br><span class="line">         recvCommands.shift()</span><br><span class="line">         runningCommands = <span class="literal">null</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意这个参数 <code>dt</code> 很微妙，虽然传入的值是tick实际的时间间隔，但分析完代码你会发现这个dt传入任意值，因为真正调用<code>obj.move</code>函数进行移动出入的参数是 <code>ms</code>，当 <code>ms</code> 等于 <code>dt</code> 时，是正常播放，当 <code>ms</code> &gt; <code>dt</code> 时，是加速播放，当 <code>ms</code> &lt; <code>dt</code> 时是减速播放，这里的代码只存在加速和正常两种情况</p><p>看到没有，你可以通过 <code>scale</code> 变量人为的改变时间的快慢，是不是很神奇，所以在帧同步中绝对顺序是靠帧数来决定的，而物理时间只是一个数字，想快就快，想慢就慢</p><p>思考下为什么会有这个判断 <code>if(runningCommands.ms &lt; ms) { ms = runningCommands.ms }</code>, 它的含义是无论你怎么加速，每个指令执行时间不能超过一帧的时间间隔，不然就和正常播放的逻辑数据不一致了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(command.direction) &#123;</span><br><span class="line">   obj.direction = command.direction</span><br><span class="line">&#125;</span><br><span class="line">obj.move(ms)</span><br></pre></td></tr></table></figure><p>这几句比较有意思，翻译过来就是如果命令我改变方向，那么我就改变方向后移动，否则我按照原来的方向移动或者保持静止，再想想是不是惯性定律？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">runningCommands.ms = runningCommands.ms - ms</span><br><span class="line"><span class="keyword">if</span>(runningCommands.ms == <span class="number">0</span>) &#123;</span><br><span class="line">   recvCommands.shift()</span><br><span class="line">   runningCommands = <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后这几句处理的是一个tick跑不完一帧时间间隔的情况，逐个tick改变物体坐标，其实就是一个指令运行一帧的分段表现</p><p>好了，写到这里基本上也讲完了，有什么疑问欢迎交流哈，我要睡觉去了</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>严格的帧同步，服务器必须等待所有客户端上报帧数才会下发当前帧命令，会造成一卡全卡</li><li>乐观锁模式，服务器不等，会定时推帧，卡顿的人在收到数据后，自行加速补帧来追赶上正确的游戏速度</li><li>一切物体总保持匀速直线运动状态或静止状态，直到有外力迫使它改变这种状态为止</li><li>在帧同步中绝对顺序是靠帧数来决定的，而物理时间只是一个数字，想快就快，想慢就慢</li><li>对于UDP丢包问题，上行采用重发3次，下行采用根据网络情况在2次到9次范围内调整</li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/138139329" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>纵有千古，横有八荒，沧海一粟，还妄图超脱三界吗？</p><p>2024-4-24 20:47:44</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;上一篇文章介绍了 &lt;a href=&quot;https://github.com/ookcode/LockstepDemo&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LockstepDemo&lt;/a&gt; 这个项目可以作为帧同步入门读物，解决了跨域限制的问题以后，这个开源项目就可以运行起来啦，虽然我没有使用js写过实际的项目，但看的多了自然也能看懂大部分的js代码了，作为一个帧同步领域的小白，我开始了阅读这个项目代码的旅程，看过之后确实解开了我之前的迷惑，所以简单记录一下学习心得。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;基础的帧同步模式，每个客户端必须回报给服务器收到帧数，服务器再次发送确认包才执行帧数据，否则所有人等待，也就是一卡全卡。&lt;/li&gt;
&lt;li&gt;基于现在手游的流行程度和弱网环境，手游一般都采取乐观锁模式。即收到服务器推帧后，客户端立即执行，不等待其他人。这样卡顿的人自己卡，不影响其他人的游戏体验。同时卡顿的人在收到数据后，自行加速补帧来追赶上正确的游戏速度。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="LockStep" scheme="http://AlbertGithubHome.github.io/blog/categories/LockStep/"/>
    
    
      <category term="Lockstep" scheme="http://AlbertGithubHome.github.io/blog/tags/Lockstep/"/>
    
      <category term="帧同步" scheme="http://AlbertGithubHome.github.io/blog/tags/%E5%B8%A7%E5%90%8C%E6%AD%A5/"/>
    
      <category term="js" scheme="http://AlbertGithubHome.github.io/blog/tags/js/"/>
    
      <category term="demo" scheme="http://AlbertGithubHome.github.io/blog/tags/demo/"/>
    
      <category term="源码分析" scheme="http://AlbertGithubHome.github.io/blog/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>帧同步入门之日遭遇CORS（跨域资源共享）问题的暴击</title>
    <link href="http://AlbertGithubHome.github.io/blog/2024/04/24/%E5%B8%A7%E5%90%8C%E6%AD%A5%E5%85%A5%E9%97%A8%E4%B9%8B%E6%97%A5%E9%81%AD%E9%81%87CORS%EF%BC%88%E8%B7%A8%E5%9F%9F%E8%B5%84%E6%BA%90%E5%85%B1%E4%BA%AB%EF%BC%89%E9%97%AE%E9%A2%98%E7%9A%84%E6%9A%B4%E5%87%BB/"/>
    <id>http://AlbertGithubHome.github.io/blog/2024/04/24/帧同步入门之日遭遇CORS（跨域资源共享）问题的暴击/</id>
    <published>2024-04-24T12:55:59.000Z</published>
    <updated>2024-04-29T14:56:41.451Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>工作以来的每个游戏项目都是用的状态同步，所以一直想找时间看一下帧同步的实现细节，网上搜到了一些开源项目，有cocos的、有Unity的，有原生C#的，大多数项目作为入门资料来看都比较重，虽然定点数计算、UDP加速这些已经成为了帧同步策略的标配，但是对于一个初学者来说，这些内容的引入无疑增加了学习成本，所以我还是想找一款帧同步纯逻辑实现的代码，后来发现 <a href="https://github.com/ookcode/LockstepDemo" target="_blank" rel="noopener">LockstepDemo</a> 这个项目还不错，那就从它开始学吧。</p><a id="more"></a><h2 id="可以学习的帧同步项目"><a href="#可以学习的帧同步项目" class="headerlink" title="可以学习的帧同步项目"></a>可以学习的帧同步项目</h2><ul><li><a href="https://github.com/ahuangege/lockstep" target="_blank" rel="noopener">ahuangege/lockstep</a> ：cocos creator客户端demo</li><li><a href="https://github.com/dudu502/LittleBee" target="_blank" rel="noopener">dudu502/LittleBee</a> ：Unity客户端，相当绚丽的演示demo</li><li><a href="https://github.com/Zealous-w/LockStep" target="_blank" rel="noopener">Zealous-w/LockStep</a> ：C++实现，内容较少</li><li><a href="https://github.com/JiepengTan/Lockstep-Tutorial" target="_blank" rel="noopener">JiepengTan/Lockstep-Tutorial</a> ：Unity客户端，较为复杂，太重度</li><li><a href="https://github.com/wechat-miniprogram/minigame-lockstep-demo" target="_blank" rel="noopener">minigame-lockstep-demo</a> ：小游戏帧同步服务配套示例，js实现</li><li><a href="https://github.com/ookcode/LockstepDemo" target="_blank" rel="noopener">ookcode/LockstepDemo</a> ：js+html实现，网页作为前端，浏览器就可运行，个人认为很适合初学者</li></ul><h1 id="LockstepDemo"><a href="#LockstepDemo" class="headerlink" title="LockstepDemo"></a>LockstepDemo</h1><p>这个项目比较轻量，如何运行Readme中写的很清楚：</p><ul><li><p>服务端</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> server</span><br><span class="line">$ npm install</span><br><span class="line">$ node app.js</span><br></pre></td></tr></table></figure></li><li><p>客户端（也可使用任意方法启动一个web服务）</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> client</span><br><span class="line">$ python3 -m http.server 8080</span><br></pre></td></tr></table></figure></li><li><p>启动完成后访问：<a href="http://127.0.0.1:8080/" target="_blank" rel="noopener">http://127.0.0.1:8080/</a></p></li></ul><h2 id="大概的原理"><a href="#大概的原理" class="headerlink" title="大概的原理"></a>大概的原理</h2><p>利用node运行app.js监听3000作为服务器，然后启动监听8080端口的web服务，浏览器访问web页面作为客户端，来展示CS架构下的帧同步</p><p>打开两个浏览器都访问这个页面，登录后就匹配成功了，操作简单，演示方便，真是入门必备读物，但是到这里不出意外的情况下，要出意外了</p><p>我打开界面输入用户名之后提示我“连接服务器失败！”，真是醉了</p><h2 id="查找问题"><a href="#查找问题" class="headerlink" title="查找问题"></a>查找问题</h2><p>幸好我还有一段网站开发的经历，所以熟练的按下F12打开了浏览器的调试页面，看到了如下报错</p><blockquote><p>Access to XMLHttpRequest at ‘<a href="http://127.0.0.1:3000/socket.io/?EIO=3&amp;transport=polling&amp;t=OyAd7iL" target="_blank" rel="noopener">http://127.0.0.1:3000/socket.io/?EIO=3&amp;transport=polling&amp;t=OyAd7iL</a>‘ from origin ‘<a href="http://127.0.0.1:8080" target="_blank" rel="noopener">http://127.0.0.1:8080</a>‘ has been blocked by CORS policy: No ‘Access-Control-Allow-Origin’ header is present on the requested resource.<br>GET <a href="http://127.0.0.1:3000/socket.io/?EIO=3&amp;transport=polling&amp;t=OyAd7iL" target="_blank" rel="noopener">http://127.0.0.1:3000/socket.io/?EIO=3&amp;transport=polling&amp;t=OyAd7iL</a> net::ERR_FAILED 400 (Bad Request)</p></blockquote><p>这个报错什么意思呢？就是说从’<a href="http://127.0.0.1:8080" target="_blank" rel="noopener">http://127.0.0.1:8080</a>‘ 发起的原始请求在访问’<a href="http://127.0.0.1:3000" target="_blank" rel="noopener">http://127.0.0.1:3000</a>‘ 时，其地址并不在访问资源允许的地址范围内，这个问题有个很常见的名字——跨域问题</p><p>好在前段时间做小游戏解决过跨域问题（其实第一次遇到这个问题在小游戏之前，先积累了经验才在小游戏中解决了这个问题），基本上知道朝哪个方向修改，所以一切还在可控范围之内，不过为了记录的全面一点，还是单独解释下跨域问题</p><h1 id="CORS跨域问题"><a href="#CORS跨域问题" class="headerlink" title="CORS跨域问题"></a>CORS跨域问题</h1><p>跨域问题的英文简写是 “CORS”，全称是 “Cross-Origin Resource Sharing”，是一种用于在不同源之间共享资源的机制。”源”是由协议（如 http 或 https）、主机名和端口号组成的组合，如果两个 URL 的这三个部分都相同，那么它们属于相同的源。</p><p>在 Web 开发中，浏览器会实施同源策略，这是一种安全机制，用于防止在一个网页的上下文中加载的资源（例如 JavaScript、CSS、图像等）去访问另一个不同源的资源。换句话说，网页只能访问与其自身相同源的资源，不能直接访问其他源的资源。</p><p>CORS 提供了一种机制，允许服务器声明哪些源的请求是被允许的，以及允许在响应中附加一些特定的头信息来告诉浏览器是否允许跨源请求。如果服务器允许跨源请求，浏览器将允许网页访问该资源，并将响应头中包含的额外信息传递给网页的 JavaScript。</p><p><strong>跨域限制是浏览器行为，不是服务器行为</strong>（看你个人理解，服务器只是配合，可以什么都不做），通过代理服务器，或者其他工具发送请求就能轻松绕过。</p><p>因为浏览器使用门槛非常低，为了防止别有用心的人攻击普通用户，所以引入同源策略。服务器间没有跨域这种说法，使用和破解难度较大，就交给用户自己防备了。</p><p>浏览器的同源策略，对于不同源的站点之间的相互请求会做限制，具体限制了以下行为：</p><ul><li>Cookie、LocalStorage 和 IndexDB 无法读取</li><li>DOM 和 JS 对象无法获取</li><li>Ajax请求发送不出去</li></ul><p>跨域资源共享（CORS）的目的之一就是在允许跨源资源共享的同时保证安全性。如果不限制跨域，可能会引发以下安全问题：</p><ul><li>跨站脚本攻击（XSS）： 恶意网站可以在用户访问时向另一个网站发送请求，并执行在受害者浏览器中执行恶意脚本，从而窃取用户的敏感信息、篡改页面内容或执行其他恶意操作。</li><li>跨站请求伪造（CSRF）： 恶意网站可以伪造请求，利用用户在其他网站上的登录状态，发送未经用户授权的请求，例如修改用户信息、发起转账等。</li><li>信息泄露： 恶意网站可以发送跨域请求，并读取其他网站的敏感信息，例如 Cookie、本地存储、IndexedDB 中的数据，从而获取用户的个人信息或其他敏感数据。</li><li>点击劫持： 恶意网站可以通过嵌入透明的 iframe 将另一个网站的页面覆盖在自己的页面上，并诱使用户在不知情的情况下点击覆盖的页面上的按钮或链接，执行未经用户授权的操作。</li><li>缓存投毒： 恶意网站可以通过发送恶意请求并利用缓存投毒技术来污染浏览器的缓存，从而在用户之后访问相同资源时执行恶意代码。</li><li>数据冒充和篡改： 恶意网站可以发送伪造的请求，并篡改或冒充其他网站的数据，例如修改在线购物网站的购物车内容。</li></ul><p>说到这里可能还迷迷糊糊的，举个具体点的例子吧，如果觉得不对尽可以来喷，我改就是了：</p><p>假如你访问了一个恶意网站，如果没有同源策略，恶意网站可以向一个你已经登录的敏感信息上网站发送http请求，因为带着你的cookie信息，可以直接获取敏感数据，但有同源策略，这种行为就被浏览器限制住了，在服务器端不需要做任何设置就能实现。</p><p>但是如果A网站和B网站是兄弟网站，B网站的资源允许A网站访问，那么就可以在B网站的服务器上将A网站域名配置成可以跨域访问的origin，这样就可以了</p><h1 id="解决跨域问题"><a href="#解决跨域问题" class="headerlink" title="解决跨域问题"></a>解决跨域问题</h1><p>说了这么多，下面要开始解决问题了，从前面解释来看，这个问题应该在服务器上处理，也就是在 <code>http://127.0.0.1:3000</code> 上允许 <code>http://127.0.0.1:8080</code> 就行了</p><p>找到 <code>LockstepDemo/server/app.js</code> 文件，其中服务器部分是这样定义的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> server = <span class="built_in">require</span>(<span class="string">'http'</span>).Server()</span><br><span class="line"><span class="keyword">var</span> io = <span class="built_in">require</span>(<span class="string">'socket.io'</span>)(server)</span><br></pre></td></tr></table></figure><p>改为如下写法，允许所有跨域请求，注意 <code>origin</code> 字段的值：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> server = <span class="built_in">require</span>(<span class="string">'http'</span>).Server()</span><br><span class="line"><span class="keyword">var</span> io = <span class="built_in">require</span>(<span class="string">"socket.io"</span>)(server, &#123;</span><br><span class="line">    allowEIO3: <span class="literal">true</span>,</span><br><span class="line">    cors: &#123;</span><br><span class="line">      origin: <span class="string">"*"</span>,</span><br><span class="line">      methods: [<span class="string">"GET"</span>, <span class="string">"POST"</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>依旧报错</p><blockquote><p>Access to XMLHttpRequest at ‘<a href="http://127.0.0.1:3000/socket.io/?EIO=3&amp;transport=polling&amp;t=OyAeQnU" target="_blank" rel="noopener">http://127.0.0.1:3000/socket.io/?EIO=3&amp;transport=polling&amp;t=OyAeQnU</a>‘ from origin ‘<a href="http://127.0.0.1:8080" target="_blank" rel="noopener">http://127.0.0.1:8080</a>‘ has been blocked by CORS policy: The value of the ‘Access-Control-Allow-Origin’ header in the response must not be the wildcard ‘*‘ when the request’s credentials mode is ‘include’. The credentials mode of requests initiated by the XMLHttpRequest is controlled by the withCredentials attribute.<br>GET <a href="http://127.0.0.1:3000/socket.io/?EIO=3&amp;transport=polling&amp;t=OyAeQnU" target="_blank" rel="noopener">http://127.0.0.1:3000/socket.io/?EIO=3&amp;transport=polling&amp;t=OyAeQnU</a> net::ERR_FAILED 200 (OK)</p></blockquote><p>根据CORS规范，当请求中包含凭据时，响应中的Access-Control-Allow-Origin头不能设置为通配符*，而必须指定允许请求的具体来源。</p><p>换句话说，如果你在客户端发起了带有凭据的请求（例如cookies或HTTP认证信息），服务器在响应中必须指定确切的来源，而不能使用通配符。</p><p>要解决这个问题，你需要在服务器端设置Access-Control-Allow-Origin头，将其设置为允许请求的确切来源。如果你的请求是来自特定的域（例如<a href="http://127.0.0.1:8080）" target="_blank" rel="noopener">http://127.0.0.1:8080）</a> ，那么你的服务器应该将Access-Control-Allow-Origin头设置为该域，修改如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> server = <span class="built_in">require</span>(<span class="string">'http'</span>).Server()</span><br><span class="line"><span class="keyword">var</span> io = <span class="built_in">require</span>(<span class="string">"socket.io"</span>)(server, &#123;</span><br><span class="line">    allowEIO3: <span class="literal">true</span>,</span><br><span class="line">    cors: &#123;</span><br><span class="line">      origin: <span class="string">"http://127.0.0.1:8080"</span>,</span><br><span class="line">      methods: [<span class="string">"GET"</span>, <span class="string">"POST"</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>还是报错</p><blockquote><p>Access to XMLHttpRequest at ‘<a href="http://127.0.0.1:3000/socket.io/?EIO=3&amp;transport=polling&amp;t=OyAgWOx" target="_blank" rel="noopener">http://127.0.0.1:3000/socket.io/?EIO=3&amp;transport=polling&amp;t=OyAgWOx</a>‘ from origin ‘<a href="http://127.0.0.1:8080" target="_blank" rel="noopener">http://127.0.0.1:8080</a>‘ has been blocked by CORS policy: The value of the ‘Access-Control-Allow-Credentials’ header in the response is ‘’ which must be ‘true’ when the request’s credentials mode is ‘include’. The credentials mode of requests initiated by the XMLHttpRequest is controlled by the withCredentials attribute.<br>socket.io.js:1456<br>GET <a href="http://127.0.0.1:3000/socket.io/?EIO=3&amp;transport=polling&amp;t=OyAgWOx" target="_blank" rel="noopener">http://127.0.0.1:3000/socket.io/?EIO=3&amp;transport=polling&amp;t=OyAgWOx</a> net::ERR_FAILED 200 (OK)</p></blockquote><p>这个错误表明在响应的Access-Control-Allow-Credentials头中设置了空字符串，而应该设置为true。这是因为当请求中包含凭据（例如使用了withCredentials属性），并且服务器允许使用凭据时，响应的Access-Control-Allow-Credentials头必须设置为true，修改如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> server = <span class="built_in">require</span>(<span class="string">'http'</span>).Server()</span><br><span class="line"><span class="keyword">var</span> io = <span class="built_in">require</span>(<span class="string">"socket.io"</span>)(server, &#123;</span><br><span class="line">    allowEIO3: <span class="literal">true</span>,</span><br><span class="line">    cors: &#123;</span><br><span class="line">      origin: <span class="string">"http://127.0.0.1:8080"</span>,</span><br><span class="line">      methods: [<span class="string">"GET"</span>, <span class="string">"POST"</span>],</span><br><span class="line">      credentials: <span class="literal">true</span> <span class="comment">// 设置为true以允许使用凭据</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这次再刷新页面，控制台打印信息“Socket连接成功： 0LLd8Rm9mO3zbOkZAAAD”</p><p>这个问题算解决了，这里指定了 <code>http://127.0.0.1:8080</code> 可以跨域访问，如果不是通过web服务，而是使用浏览器直接打开index.html文件，地址为 <code>file:///E:/WorkSpace/opensource/LockstepDemo/client/index.html</code>，还会出现以下错误：</p><blockquote><p>Access to XMLHttpRequest at ‘<a href="http://127.0.0.1:3000/socket.io/?EIO=3&amp;transport=polling&amp;t=OyAg_nn" target="_blank" rel="noopener">http://127.0.0.1:3000/socket.io/?EIO=3&amp;transport=polling&amp;t=OyAg_nn</a>‘ from origin ‘null’ has been blocked by CORS policy: The ‘Access-Control-Allow-Origin’ header has a value ‘<a href="http://127.0.0.1:8080" target="_blank" rel="noopener">http://127.0.0.1:8080</a>‘ that is not equal to the supplied origin.</p></blockquote><p>相信你也知道怎么改了，把 “null” 加到允许列表就行了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> server = <span class="built_in">require</span>(<span class="string">'http'</span>).Server()</span><br><span class="line"><span class="keyword">var</span> io = <span class="built_in">require</span>(<span class="string">"socket.io"</span>)(server, &#123;</span><br><span class="line">    allowEIO3: <span class="literal">true</span>,</span><br><span class="line">    cors: &#123;</span><br><span class="line">      origin: [<span class="string">"http://127.0.0.1:8080"</span>, <span class="string">"null"</span>],,</span><br><span class="line">      methods: [<span class="string">"GET"</span>, <span class="string">"POST"</span>],</span><br><span class="line">      credentials: <span class="literal">true</span> <span class="comment">// 设置为true以允许使用凭据</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>演示界面如下，还挺不错的，今天就先写到这，以后抽时间再分析代码</p><p><img src="https://img-blog.csdnimg.cn/direct/77db3d08faf34984aed51275184b2aca.png#pic_center" alt="demo"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li><a href="https://github.com/ookcode/LockstepDemo" target="_blank" rel="noopener">ookcode/LockstepDemo</a> 项目可作为帧同步入门教程</li><li>跨域限制是浏览器行为，不是服务器行为，服务器只是配合，可以什么都不做，想实现跨域可以让服务器参与配置</li><li><code>Access-Control-Allow-Origin</code> 和 <code>Access-Control-Allow-Origin</code> 都是跨域问题处理中常见字段，但不同语言中字段赋值形式不同</li><li>浏览器的同源策略是保护小白使用者的，在服务器间访问资源并不用遵守同源策略</li><li>这次尝试有一个问题没解决，就是怎样允许所有的跨域行为，origin配置成 <code>*</code>不行，说是客户端带有认证信息，但是我没找到在哪</li><li>客户端请求连接很简单 <code>socket = io.connect(&#39;http://127.0.0.1:3000&#39;)</code>，并未发现认证信息，有知道的大佬欢迎指出</li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/137091129" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>不同的维度品不同的人生，你认为你还在，我看你已经无了~</p><p>2024-4-23 21:33:52</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;工作以来的每个游戏项目都是用的状态同步，所以一直想找时间看一下帧同步的实现细节，网上搜到了一些开源项目，有cocos的、有Unity的，有原生C#的，大多数项目作为入门资料来看都比较重，虽然定点数计算、UDP加速这些已经成为了帧同步策略的标配，但是对于一个初学者来说，这些内容的引入无疑增加了学习成本，所以我还是想找一款帧同步纯逻辑实现的代码，后来发现 &lt;a href=&quot;https://github.com/ookcode/LockstepDemo&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LockstepDemo&lt;/a&gt; 这个项目还不错，那就从它开始学吧。&lt;/p&gt;
    
    </summary>
    
      <category term="LockStep" scheme="http://AlbertGithubHome.github.io/blog/categories/LockStep/"/>
    
    
      <category term="Lockstep" scheme="http://AlbertGithubHome.github.io/blog/tags/Lockstep/"/>
    
      <category term="CORS" scheme="http://AlbertGithubHome.github.io/blog/tags/CORS/"/>
    
      <category term="跨域" scheme="http://AlbertGithubHome.github.io/blog/tags/%E8%B7%A8%E5%9F%9F/"/>
    
      <category term="帧同步" scheme="http://AlbertGithubHome.github.io/blog/tags/%E5%B8%A7%E5%90%8C%E6%AD%A5/"/>
    
      <category term="js" scheme="http://AlbertGithubHome.github.io/blog/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>k8s小白的学习初体验</title>
    <link href="http://AlbertGithubHome.github.io/blog/2024/03/29/k8s%E5%B0%8F%E7%99%BD%E7%9A%84%E5%AD%A6%E4%B9%A0%E5%88%9D%E4%BD%93%E9%AA%8C/"/>
    <id>http://AlbertGithubHome.github.io/blog/2024/03/29/k8s小白的学习初体验/</id>
    <published>2024-03-29T02:04:18.000Z</published>
    <updated>2024-04-29T15:06:36.360Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>有些时候的巧合让人匪夷所思，前两周刚刚尝试了一遍Docker操作，紧接着就收到好朋友说要学习k8s容器部署的建议，最近两周抽空看了一些关于k8s的知识，相关概念真的是太多了，概念本身是枯燥的，但是当概念运行起来就有意思多了，这时候取出费曼学习大法，尝试着用自己的话来描述这些概念，看看自己是不是真的学会了。本文k8s相关概念均来自个人理解，后续随着学习深入可能会有改正，勿喷。</p><a id="more"></a><h1 id="学习资料"><a href="#学习资料" class="headerlink" title="学习资料"></a>学习资料</h1><p>找到一些官方文档和一些写的比较通俗的教程，再有疑问直接去官网查吧</p><ul><li><a href="https://kubernetes.io/zh-cn/docs/tutorials/kubernetes-basics/" target="_blank" rel="noopener">学习 Kubernetes 基础知识</a></li><li><a href="https://ranchermanager.docs.rancher.com/zh/" target="_blank" rel="noopener">什么是 Rancher？</a></li><li><a href="https://k8s.easydoc.net/docs/dRiQjyTY/28366845/6GiNOzyZ/9EX8Cp45" target="_blank" rel="noopener">Kubernetes（K8S）简介</a></li><li><a href="https://juejin.cn/column/6962026171823292452" target="_blank" rel="noopener">K8S学习教程</a></li></ul><h1 id="学到了什么"><a href="#学到了什么" class="headerlink" title="学到了什么"></a>学到了什么</h1><p>我就尝试用直白的语言来描述一下，不一定准确，听听看</p><p>ks8是<code>Kubernetes</code>的简称，<code>Rancher</code>是一个管理k8s的工具，可以操作k8s定义 <code>Deployment</code> 在 <code>Node</code> 上创建一系列包含若干 <code>Container</code> 的 <code>Pod</code>，也可以操作k8定义 <code>Service</code> 在指定 <code>Pod</code> 上建立统一对外的服务，<code>Deployment</code>、<code>Service</code>、<code>Node</code>、<code>Pod</code> 这些在k8s中被称为资源，为了便于管理可以划分到不同的 <code>Namespace</code> 中。</p><p>单单就这两句话包含了7、8个名词概念，要是把他们的定义列出来，保准得晕晕乎乎的，并且有些名词在不同的语境下有不同的含义，比如Docker是一个工具、是一个运行时、是一个平台等等，所以有些概念不结合具体的情景还真是说不清楚，我们还是来想想为什么出现这些东西吧。</p><p>当项目规模还小的时候，我们把程序放到服务器上运行起来就行了，简单方便，后来随着规模的扩大，部署的机器越来越多，发现机器资源分配不好控制，可能机器的大部分资源被某个应用占用，导致其他应用无法正常运行，无法做到应用隔离。</p><p>后来引入了虚拟机，虽然解决了资源控制问题，但在单个物理机上运行多个虚拟机，每个虚拟机都是完整独立的系统，性能损耗大，还有一个之前遗留的问题，就是运行环境的差异引发的问题常常使人焦头烂额，所以容器部署应运而生。</p><p>将运行程序和所依赖的环境打包成镜像，放到容器运行时上运行，可以保证所有程序的运行环境都一样，容器相比虚拟机性能损耗小，可实现资源隔离，CPU和内存可按需分配，所有容器共享主机的系统，最有名的要数Docker了</p><p>从这个角度来看docker或者容器运行时很像JVM，当年Java号称一次编写处处运行，靠的就是Java虚拟机，所有的Java源码会被编译成字节码，在不同平台上的JVM中被翻译中对应平台的指令，而Docker的身份和地位很像这个JVM，容器运行时可以在运行之前打包好的镜像，并且在不同的系统平台上模拟出目标平台的环境，来保证“一次打包处处运行”</p><p>现在知道了，我把应用程序和它依赖的运行环境打包成镜像，就可以在任何安装了Docker的机器上运行，不管这台机器是什么系统，这样就可以快速扩展程序规模了，但是新的问题还是会出现的</p><p>因为程序员太懒了，让他部署几个服务器还没啥问题，要是成百上千台服务器，每次扩展或更新都需要逐个拉取镜像、版本回滚、逐个启动，简直痛不欲生，在半夜被薅起来更新维护时还容易出错，所以这时候 Kubernetes 就诞生了，因其K和s中间有8个字母简称为k8s，它可以让你管理让你轻松管理成千上万台机器的集群，这些机器上的容器都归它管，一个命令就可以搞定版本升级、版本回滚等操作，还可以不停机的灰度更新，确保高可用、高性能、高扩展。</p><p>我的天，k8s都这么牛了，那 Rancher 又是啥？难道他比 k8s 还厉害，人类的懒惰是无极限的，k8s 虽然一个命令可以完成很多需求，但有些人就是一个命令也不想输啊，哈哈！</p><p>尽管 k8s 是一个强大的容器编排平台，可以同时管理集群中数以万计的机器，但人们为了方便还是开发了Rancher吗，它提供了用户友好的图形用户界面、RBAC（基于角色的访问控制）、日志和监控、多集群管理等，同时它还提供了一个集成的应用商店，其中包含了许多常用的容器化应用程序和工具，如数据库、监控、日志、CI/CD 等，通过 Rancher 的界面轻松部署这些应用程序，并与 Kubernetes 集群集成。</p><p>有些人用k8s为了方便部署和管理容器，而有些人只想更方便，选择了 Rancher 来管理看 k8s，之后会不会有人开发的新东西来管理 Rancher 呢，这有什么不可能的呢？</p><h1 id="概念白话文"><a href="#概念白话文" class="headerlink" title="概念白话文"></a>概念白话文</h1><p>前面提到了很多概念，也讲了一些有关这些东西的来历，接下来让我用自己的理解来说说这些名词到底指什么。</p><p><strong>镜像</strong>：最早听说这个词是系统镜像，将后缀为 <code>.iso</code> 的系统镜像文件刻录成光盘，或者烧制成U盘启动盘来安装系统，容器化中的镜像含义和系统镜像类似，就是用过用程序以及用于运行应用程序所需的所有依赖项打个包，称为镜像，它可以放到容器运行时中运行，相同的镜像可以重现相同的环境，就像相同的ISO文件会安装出相同的系统一样</p><p><strong>Docker</strong>：往大点说这是指一个容器化平台，当然也可以是一个软件，或者是一项技术规范，用它可以开发、打包、部署和运行应用程序。通过使用 Docker，开发人员可以将应用程序及其依赖项（如库、运行时环境等）打包成一个轻量级的容器，然后在任何支持 Docker 的环境中运行这个容器，而不用担心环境的差异性。简单点说，它是一个工具，可以打包一个镜像，也可以运行一个镜像</p><p><strong>Dockerfile</strong>：用来说明怎么打包镜像的，使用特定的描述性语言，告诉Docker怎么打包出一个镜像</p><p><strong>容器化</strong>：将引用程序和运行环境打包成镜像，并批量运行到其他容器运行时上的过程</p><p>镜像和容器的关系：镜像是 Docker 中用于打包应用程序及其依赖项的静态文件，是只读的，一旦构建完成就不能修改，容器是镜像的一个运行时实例，它可以被启动、停止、暂停、删除等操作。可以简单类比下 class 和 object 的关系</p><p><strong>k8s</strong>：为了管理和编排大量的容器而开发出来的工具，可以批量自动化的完成一些容器的操作，由他又引出了大量新的概念</p><p><strong>k3s</strong>：一个轻量级的 Kubernetes 发行版，体积小、资源消耗低，采用了更少的组件和依赖项，并且对 Kubernetes 的安装和配置进行了简化，使得部署和管理更加容易</p><p><strong>Pod</strong>：k8s调度、管理的最小单位，它包含一个或多个紧密关联的容器</p><p><strong>Node</strong>：是集群中的计算节点，有master主节点和worker工作节点之分，负责提供计算资源、网络和存储服务，可以是真实的物理机，也可以是运行在物理机上的虚拟机。</p><p><strong>Deployment</strong>: 是 k8s 中用于声明式管理 Pod 和 ReplicaSet 的控制器，可以认为是一个描述怎样使用 Pod 资源的规则，应用一个Deployment就是按照它的描述来组织和使用Pod</p><p><strong>Service</strong>：是 k8s 中用于提供对一组 Pod 的网络访问的抽象，可以将一组 Pod 绑定统一对外提供服务</p><p><strong>Namespace</strong>：k8s 中用于将资源分类的一个逻辑概念，类似于编程语言中的命名空间</p><p><strong>Docker Compose</strong>：与k8s同类，也是用于管理容器化应用程序的工具，但规模较小适用于小型项目和开发环境</p><p><strong>Rancher</strong>：一个开源的容器管理平台，拥有统一的可视化界面，可以同时管理多个k8s，括本地、云端或混合部署的集群</p><p><strong>Rancher Desktop</strong>：是一款用于本地开发的工具，基于K3s构建，旨在提供轻量级的开发环境，使开发人员能够轻松地在自己的计算机上进行容器化应用的开发和测试</p><p><strong>Workloads</strong>：工作负载，有哪些类型的活，包括Deployment（部署无状态Pod），StatefulSet（部署有状态Pod），DaemonSet（节点监控和日志收集），Job（一次性任务），CronJob（定时重复任务）</p><p><strong>组件</strong>：每个角色要干指定活所以需要配备的一些功能模块，比如每个 Node 都有Kubelet组件，会与k8s控制平面进行通信，接收指令来管理此Node 上的 Pod</p><p><strong>控制平面</strong>：运行在主节点上的集群的核心组件之一，负责管理集群的各种操作、监控集群状态，并确保集群的稳定运行，通常包含 <code>kube-apiserver</code>、<code>etcd</code>、<code>kube-controller-manager</code>、<code>kube-scheduler</code>、<code>cloud-controller-manager</code> 等</p><h1 id="一些疑问"><a href="#一些疑问" class="headerlink" title="一些疑问"></a>一些疑问</h1><ul><li><p>容器化是不是只能用Docker?</p><p>不是的，Docker只是实现容器化的一种可选的途径，只要实现了容器化标准的工具都可以实现容器化，作为容器运行时，比如 k8s 为了提高效率，减少不必要的开销，已经将默认的容器运行时从 Docker 改成了 containerd，其他类似于Docker的运行时还有 <code>Podman</code>、<code>rkt（Rocket）</code>、<code>LXC（Linux Containers</code>、<code>CRI-O</code>等</p></li><li><p>k8s 是唯一的容器编排工具吗？</p><p>不是的，就像前文提到的 Docker Compose 也能管理容器的使用，只是适用规模较小，除此之外类似的工具还有 <code>Docker Swarm</code>、<code>Apache Mesos</code>、<code>Nomad</code>、<code>OpenShift</code>等</p></li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>Docker 生成和运行镜像，k8s 管理这些被Pod包装并运行在Node上的容器，Rancher 管理 k8s 集群</li><li>部署无状态Pod使用 Deployment，部署有状态Pod使用 StatefulSet，StatefulSet 会固定每个 Pod 的名字</li><li>k8s不会为你处理数据的存储，我们可以为运行数据库的Pod挂载一个磁盘来确保数据的安全，云存储、本地磁盘、NFS都是可以选择的对象</li><li><code>kubectl get all</code> 可用于查看常用资源，包括Pod、Service、Deployment、ReplicaSet等</li><li>也可以单独查询某项信息 <code>kubectl get namespace</code>、<code>kubectl get pod</code>、<code>kubectl get node</code>、<code>kubectl get deployment</code></li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/136572038" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>惟愿吾儿愚且鲁，无灾无难到公卿，可能不是东坡的心里话吧，但一定是受到刺激以后才有的感想~</p><p>2024-3-28 20:34:05</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;有些时候的巧合让人匪夷所思，前两周刚刚尝试了一遍Docker操作，紧接着就收到好朋友说要学习k8s容器部署的建议，最近两周抽空看了一些关于k8s的知识，相关概念真的是太多了，概念本身是枯燥的，但是当概念运行起来就有意思多了，这时候取出费曼学习大法，尝试着用自己的话来描述这些概念，看看自己是不是真的学会了。本文k8s相关概念均来自个人理解，后续随着学习深入可能会有改正，勿喷。&lt;/p&gt;
    
    </summary>
    
      <category term="k8s" scheme="http://AlbertGithubHome.github.io/blog/categories/k8s/"/>
    
    
      <category term="k8s" scheme="http://AlbertGithubHome.github.io/blog/tags/k8s/"/>
    
      <category term="Kubernetes" scheme="http://AlbertGithubHome.github.io/blog/tags/Kubernetes/"/>
    
      <category term="docker" scheme="http://AlbertGithubHome.github.io/blog/tags/docker/"/>
    
      <category term="概念" scheme="http://AlbertGithubHome.github.io/blog/tags/%E6%A6%82%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>将python编写的网站制作成docker镜像并上传到Github Packages上</title>
    <link href="http://AlbertGithubHome.github.io/blog/2024/03/09/%E5%B0%86python%E7%BC%96%E5%86%99%E7%9A%84%E7%BD%91%E7%AB%99%E5%88%B6%E4%BD%9C%E6%88%90docker%E9%95%9C%E5%83%8F%E5%B9%B6%E4%B8%8A%E4%BC%A0%E5%88%B0Github-Packages%E4%B8%8A/"/>
    <id>http://AlbertGithubHome.github.io/blog/2024/03/09/将python编写的网站制作成docker镜像并上传到Github-Packages上/</id>
    <published>2024-03-08T18:00:00.000Z</published>
    <updated>2024-04-29T14:44:17.003Z</updated>
    
    <content type="html"><![CDATA[<p>@[toc]</p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>还记得上一篇<a href="https://blog.csdn.net/albertsh/article/details/136406152" target="_blank" rel="noopener">《借助ChatGPT使用Python搭建一个工具网站》</a>总结中我利用ChatGPT写了一个网站，最终它运行良好，就在昨天我看到了Github Packages，不久前刚刚使用了GitHub Actions，我发现Github在被微软收购后，并没有变的更“闭源”，之前广大网友还在调侃，最大的闭源软件公司收购了最大的开源平台，看来一切还在向好的方向发展，简单介绍下前面提到的这两个都是什么东西。</p><a id="more"></a><p><a href="https://github.com/features/actions" target="_blank" rel="noopener">GitHub Actions</a> 是一个Github原生的持续集成和部署的工作流组件。通俗来说就是Github免费给你提供虚拟主机，由你编写工作流脚本来进行源码的检出，编译，测试，和发布。类似的我们可以想象成Github给每个仓库都免费绑定了一个Jenkins服务，编写pipeline脚本即可进行源码的集成和发布。</p><p><a href="https://github.com/features/packages" target="_blank" rel="noopener">GitHub Packages</a> 是一个和每一个代码仓库关联的软件包仓库。通俗来说就是代码仓库中存放的是源码，软件包仓库中存放的是编译输出后的可以被各个语言生态的依赖管理工具直接依赖的lib，类似的我们熟知的有maven中央仓库和nmp仓库。</p><p>今天我们只看GitHub Packages这部分，并且将范围缩小到制作一个Docker镜像并上传到GitHub Packages，用来制作的项目就是前文中我们在ChatGPT辅助下编写的网站，本文只写流程，对于其中的概念不会过多解释，大家可以借助网络来解决概念性问题，但是我在完成目标过程中遇到的坑会列举出来，希望能帮助有相同经历的人，同时自己记录一下防止忘记。</p><h1 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h1><p>既然要制作docker镜像，那先简单了解下docker是什么</p><blockquote><p>Docker 使用 Google 公司推出的 Go 语言 进行开发实现，基于 Linux 内核的 cgroup，namespace，以及 OverlayFS 类的 Union FS 等技术，对进程进行封装隔离，属于 操作系统层面的虚拟化技术。由于隔离的进程独立于宿主和其它的隔离的进程，因此也称其为容器。最初实现是基于 LXC，从 0.7 版本以后开始去除 LXC，转而使用自行开发的 libcontainer，从 1.11 版本开始，则进一步演进为使用 runC 和 containerd</p><p>Docker 可以通过定制应用镜像来实现持续集成、持续交付、部署。开发人员可以通过 Dockerfile 来进行镜像构建，并结合 持续集成(Continuous Integration) 系统进行集成测试，而运维人员则可以直接在生产环境中快速部署该镜像，甚至结合 持续部署(Continuous Delivery/Deployment) 系统进行自动部署。而且使用 Dockerfile 使镜像构建透明化，不仅仅开发团队可以理解应用运行环境，也方便运维团队理解应用运行所需条件，帮助更好的生产环境中部署该镜像。</p></blockquote><p>以上我只是摘抄了一部分，想要看更详细的解释请跳转至 <a href="https://yeasy.gitbook.io/docker_practice/" target="_blank" rel="noopener">《Docker 技术入门与实战》</a>，总的来说就是能解决环境一致性问题，并且可以方便部署的，把你的软件及运行环境打个包，在目标机器上直接运行，最大程度的去除环境差异，被打成的这个包就是docker镜像，我们可以把这个镜像丢到“任何”一台机器上去执行，不用再操心安装繁琐的运行环境。</p><p>但是无论是制作docker镜像还是运行docker镜像都需要先安装docker环境，相当于它来做软件和机器之间的代理，是不是听起来像虚拟机，他俩常常被拿来比较，而docker更加轻量级，目前应用广泛，我们来列举下安装步骤，事先说明操作系统是Ubuntu20.04，项目是<a href="https://github.com/AlbertGithubHome/minimalist-tool-web" target="_blank" rel="noopener">minimalist-tool-web</a>，未特殊说明时则是在项目根目录下执行命令。</p><h2 id="安装docker"><a href="#安装docker" class="headerlink" title="安装docker"></a>安装docker</h2><ul><li><p>更新apt包列表</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br></pre></td></tr></table></figure></li><li><p>安装依赖包，以允许apt通过HTTPS使用存储库</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install -y apt-transport-https ca-certificates curl gnupg2 software-properties-common</span><br></pre></td></tr></table></figure></li><li><p>添加Docker的官方GPG密钥</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -</span><br></pre></td></tr></table></figure></li><li><p>添加Docker的APT存储库</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo add-apt-repository <span class="string">"deb [arch=amd64] https://download.docker.com/linux/ubuntu <span class="variable">$(lsb_release -cs)</span> stable"</span></span><br></pre></td></tr></table></figure></li><li><p>再次更新apt包列表</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br></pre></td></tr></table></figure></li><li><p>安装Docker</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install -y docker-ce</span><br></pre></td></tr></table></figure></li><li><p>验证Docker是否安装成功：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker --version</span><br></pre></td></tr></table></figure></li></ul><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ol><li><p>添加GPG密钥的时候有可能报错 <code>curl: (35) OpenSSL SSL_connect: SSL_ERROR_SYSCALL in connection to download.docker.com:443</code>，相同命令多尝试几次就能看见 <code>OK</code></p></li><li><p>我在 <code>sudo apt update</code> 的时候报错 <code>Failed to fetch https://dl.google.com/linux/chrome/deb/dists/stable/InRelease The following signatures couldn&#39;t be verified because the public key is not available: NO_PUBKEY E88979FB9B30ACF2</code>，通过执行 <code>wget -q -O - https://dl.google.com/linux/linux_signing_key.pub | sudo apt-key add -</code> 修复好的，不过这可能是个例，你们不一定遇到</p></li></ol><h2 id="创建Dockerfile"><a href="#创建Dockerfile" class="headerlink" title="创建Dockerfile"></a>创建Dockerfile</h2><p>在项目根目录下创建一个名为 <code>Dockerfile</code> 的文件，并编写 Docker 镜像的构建指令，以下是一个示例的 <code>Dockerfile</code> 文件，它是在初始命令模板下精简而成，目的是缩小镜像大小，调整命令后镜像从1.1G缩小到65M</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用 Alpine Linux 作为基础镜像</span></span><br><span class="line"><span class="keyword">FROM</span> python:<span class="number">3.8</span>-alpine</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置工作目录</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /app</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash"><span class="comment"># 将当前目录下的所有文件复制到工作目录</span></span></span><br><span class="line"><span class="bash">COPY . .</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash"><span class="comment"># 安装项目依赖</span></span></span><br><span class="line"><span class="bash">RUN pip install --no-cache-dir -r requirements.txt</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash"><span class="comment"># 清理不必要的缓存</span></span></span><br><span class="line"><span class="bash">RUN rm -rf /var/cache/apk/*</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash"><span class="comment"># 暴露应用端口</span></span></span><br><span class="line"><span class="bash">EXPOSE 9206</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash"><span class="comment"># 运行应用</span></span></span><br><span class="line"><span class="bash">CMD [<span class="string">"python3"</span>, <span class="string">"main.py"</span>]</span></span><br></pre></td></tr></table></figure><h3 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li><code>WORKDIR /app</code> 是指镜像中的目录，在当前操作系统中可能并不存在</li><li><code>COPY . .</code> 很奇怪的写法，但是两个<code>.</code>含义是不同的，第一个只当前目录，第二个指镜像中的当前目录，也就是 <code>/app</code></li></ul><h2 id="构建-Docker-镜像"><a href="#构建-Docker-镜像" class="headerlink" title="构建 Docker 镜像"></a>构建 Docker 镜像</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker build -t minimalist-tool-web .</span><br></pre></td></tr></table></figure><p>其中 <code>-t minimalist-tool-web</code> 指定了镜像的名称为 <code>minimalist-tool-web</code>，构建完成后，可以查看当前镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker images</span><br><span class="line">REPOSITORY            TAG       IMAGE ID       CREATED          SIZE</span><br><span class="line">minimalist-web-tool   latest    f11497961379   5 minutes ago    65.6MB</span><br><span class="line">hello-world           latest    d2c94e258dcb   10 months ago    13.3kB</span><br></pre></td></tr></table></figure><h2 id="运行-Docker-镜像"><a href="#运行-Docker-镜像" class="headerlink" title="运行 Docker 镜像"></a>运行 Docker 镜像</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 9206:9205 minimalist-tool-web</span><br></pre></td></tr></table></figure><p>其中 <code>-d</code>参数表示在后台运行容器，<code>-p 9206:9205</code> 将容器内部的 9205 端口映射到宿主机的 9206 端口，这样就可以通过 <code>http://localhost:9206</code> 访问应用程序，至此，我的项目就已经制作成了 Docker 镜像，并且可以在 Docker 容器中运行了。</p><h1 id="发布到Github-Packages"><a href="#发布到Github-Packages" class="headerlink" title="发布到Github Packages"></a>发布到Github Packages</h1><p>这部分确实花了我不少时间，我先把正确的流程描述完，然后再说一下我遇到的问题。</p><ol><li><p>到<a href="https://github.com/settings/tokens" target="_blank" rel="noopener">Developer Settings (classic)</a> 申请一个token，记得至少勾选 <code>read:packages</code> 和 <code>write:packages</code> 权限</p></li><li><p>登录docker，使用上一步申请的token</p></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker login ghcr.io --username your-github-username --password-stdin your-personal-access-token</span><br></pre></td></tr></table></figure><ol><li>给镜像添加标签</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker tag your-image-id ghcr.io/your-github-username/your-image-name:1.0.0</span><br></pre></td></tr></table></figure><ol><li>将docker镜像推送到Github Packages上</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker push ghcr.io/your-github-username/your-image-name:1.0.0</span><br></pre></td></tr></table></figure><h2 id="坑坑到位"><a href="#坑坑到位" class="headerlink" title="坑坑到位"></a>坑坑到位</h2><h3 id="申请token的坑"><a href="#申请token的坑" class="headerlink" title="申请token的坑"></a>申请token的坑</h3><p>许多教程上申请token截图还是只有一个页面，但是现在（2024-3-8）的Github上申请的token的页面已经分成了两类，具体导航路径在<code>『Github头像』</code>-&gt;<code>『Settings』</code>-&gt;<code>『Developer Settings』</code>-&gt;<code>『Personal access tokens』</code>，到此处申请token页面分成了两个，分别是 <code>Fine-grained tokens</code>和 <code>Tokens (classic)</code>，最近几次其他的访问权限分配我都是用的前面这种<code>Fine-grained tokens</code>，虽然标记着 <code>Beta</code>，但这是官方推荐的形式。</p><p>但这一次我却遇到了 <code>unauthorized: unauthenticated: User cannot be authenticated with the token provided.</code> 这个问题，后来改成Tokens (classic)这种类型的token才解决，可以看到的是第一个Fine-grained tokens中我没有找到<code>read:packages</code> 和 <code>write:packages</code> 权限，不知道是不是和这个有关，我还在尝试。</p><p>那么在申请 <code>Tokens (classic)</code> 时要记得勾选<code>read:packages</code> 和 <code>write:packages</code> 权限，最好把 <code>delete:packages</code> 和 <code>repo</code> 也勾选上，如果想通过token更新Github Actions，最好也要勾选上 <code>workflow</code></p><p><code>Fine-grained tokens</code>：这种token形如 <code>github_pat_xxx</code>，位数较长</p><p><code>Tokens (classic)</code>：这种token形如 <code>ghp_xxx</code>，位数较短</p><h3 id="docker登录的坑"><a href="#docker登录的坑" class="headerlink" title="docker登录的坑"></a>docker登录的坑</h3><p>很多帖子可能是时间太久远了，里面提到的地址都是 <code>docker.pkg.github.com</code>，我这里倒是都显示登录成功，但是每次推送都会提示 <code>no basic auth credentials</code>，就像下面这样</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$ cat ~/TOKEN.txt | docker login https://docker.pkg.github.com -u AlbertGithubHome --password-stdin</span><br><span class="line">WARNING! Your password will be stored unencrypted <span class="keyword">in</span> /home/shz/.docker/config.json.</span><br><span class="line">Configure a credential helper to remove this warning. See</span><br><span class="line">https://docs.docker.com/engine/reference/commandline/login/<span class="comment">#credentials-store</span></span><br><span class="line"></span><br><span class="line">Login Succeeded</span><br><span class="line"></span><br><span class="line">$ sudo docker push docker.pkg.github.com/albertgithubhome/minimalist-tool-web/tools-web:1.0.0</span><br><span class="line">The push refers to repository [docker.pkg.github.com/albertgithubhome/minimalist-tool-web/tools-web]</span><br><span class="line">c0f047bfac29: Preparing</span><br><span class="line">87174263225b: Preparing</span><br><span class="line">5462d39b06ad: Preparing</span><br><span class="line">2c604764da2f: Preparing</span><br><span class="line">a469c5a79f90: Preparing</span><br><span class="line">7402639a4746: Waiting</span><br><span class="line">42672d5bf49e: Waiting</span><br><span class="line">678cac8b069e: Waiting</span><br><span class="line">d4fc045c9e3a: Waiting</span><br><span class="line">no basic auth credentials</span><br></pre></td></tr></table></figure><p>后来在 Stack Overflow 上找到一个问题，里面用的是 <code>ghcr.io</code> 修改之后发现才可以</p><h3 id="给镜像添加标签的坑"><a href="#给镜像添加标签的坑" class="headerlink" title="给镜像添加标签的坑"></a>给镜像添加标签的坑</h3><p>这个需要注意的点是整个标签的字母必须都是小写的，而我的用户名是大写，所以我按照老版本的教程创建了类似 <code>docker tag f11497961379 docker.pkg.github.com/albertgithubhome/minimalist-tool-web/tools-web:1.0.0</code> 的标签，但是我的用户名是大写的，每次推送失败告诉我未验证时，我无法确定是哪类的问题:</p><ol><li>token类型有问题</li><li>权限有问题，登录没有用sudo</li><li>登录地址有问题，<a href="https://docker.pkg.github.com地址打不开" target="_blank" rel="noopener">https://docker.pkg.github.com地址打不开</a></li><li>我的用户名有大写字母，与推送的镜像名中的用户名不匹配</li></ol><p>反正费了九牛二虎之力吧，把这些原因一一排除掉，总算能推送上去了</p><p>还有一点，之前老版本的教程标签格式要求是 <code>docker.pkg.github.com/your-github-username/your-repository/your-image-name:1.0.0</code>，在新版的教程中改为了 <code>ghcr.io/your-github-username/your-image-name:1.0.0</code>，不要求添加库的名称了</p><h3 id="docker推送的坑"><a href="#docker推送的坑" class="headerlink" title="docker推送的坑"></a>docker推送的坑</h3><p>这一步的坑都是前面几步积累得来的，因为这一步的失败根本不知道前边哪一步出错了，更离谱的是在登录这一步，无论用户名是什么，token是什么都显示登录成功，导致后面查找原因浪费了不少时间</p><p>推送时直接填写前面的标签名即可</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker push ghcr.io/albertgithubhome/minimalist-tool-web:1.0.0</span><br><span class="line">The push refers to repository [ghcr.io/albertgithubhome/minimalist-tool-web]</span><br><span class="line">c0f047bfac29: Pushed</span><br><span class="line">87174263225b: Pushed</span><br><span class="line">5462d39b06ad: Pushed</span><br><span class="line">2c604764da2f: Pushed</span><br><span class="line">a469c5a79f90: Pushed</span><br><span class="line">7402639a4746: Pushed</span><br><span class="line">42672d5bf49e: Pushed</span><br><span class="line">678cac8b069e: Pushed</span><br><span class="line">d4fc045c9e3a: Pushed</span><br><span class="line">1.0.0: digest: sha256:f749fd2eba021248c97c8a44374772165372354b9d48f4f6b845bbce46d02402 size: 2201</span><br></pre></td></tr></table></figure><p>这些参数可以在 <a href="https://ghcr.io" target="_blank" rel="noopener">ghcr.io</a> 查看，页面上有一个示例</p><p><img src="https://img-blog.csdnimg.cn/direct/14a5633c75174979a6d8da967063fac5.png#pic_center" alt="ghcr.io"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$PAT</span> | docker login ghcr.io --username phanatic --password-stdin</span><br><span class="line">docker tag app ghcr.io/phanatic/app:1.0.0</span><br><span class="line">docker push ghcr.io/phanatic/app:1.0.0</span><br></pre></td></tr></table></figure><h1 id="在Github-Packages上查看"><a href="#在Github-Packages上查看" class="headerlink" title="在Github Packages上查看"></a>在Github Packages上查看</h1><p>打开你账号下的Packages页签就能看到了，点击进去可以将这个 package 关联到指定项目，这样在项目的首页右侧的packages区域就能看到这个package，在package的介绍页面会教你怎么使用这个镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull ghcr.io/albertgithubhome/minimalist-tool-web:1.0.0</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/direct/885fb2900d52414b961e562e9b9131c4.png#pic_center" alt="minimalist-tool-web"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li><code>GitHub Actions</code> 是一个Github原生的持续集成和部署的工作流组件，相当免费绑定了一个Jenkins服务</li><li><code>GitHub Packages</code> 是和每一个代码仓库关联的软件包仓库，类似我们熟知的maven中央仓库和nmp仓库</li><li>运行docker命令 <code>docker run -d -p 9206:9205 minimalist-tool-web</code>，其中minimalist-tool-web是镜像名</li><li>停止docker命令 <code>sudo docker stop af98cf2f93bf</code>，其中af98cf2f93bf是容器ID</li><li>推送docker命令 <code>sudo docker push ghcr.io/albertgithubhome/minimalist-tool-web:1.0.0</code></li><li>拉取docker命令 <code>sudo docker pull ghcr.io/albertgithubhome/minimalist-tool-web:1.0.0</code></li><li>最终<code>Fine-grained tokens</code>应该会替换到<code>Tokens (classic)</code>，但现在感觉还不能完全代替</li><li>接下来会尝试用.yml编写一个<code>GitHub Action</code>控制项目更新时自动创建镜像和发布</li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/136406152" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>从秦灭六国、焚书坑儒开始，从罢黜百家、独尊儒术开始，洗脑便已经登峰造极了~</p><p>2024-3-8 20:59:13</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;@[toc]&lt;/p&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;还记得上一篇&lt;a href=&quot;https://blog.csdn.net/albertsh/article/details/136406152&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《借助ChatGPT使用Python搭建一个工具网站》&lt;/a&gt;总结中我利用ChatGPT写了一个网站，最终它运行良好，就在昨天我看到了Github Packages，不久前刚刚使用了GitHub Actions，我发现Github在被微软收购后，并没有变的更“闭源”，之前广大网友还在调侃，最大的闭源软件公司收购了最大的开源平台，看来一切还在向好的方向发展，简单介绍下前面提到的这两个都是什么东西。&lt;/p&gt;
    
    </summary>
    
      <category term="docker" scheme="http://AlbertGithubHome.github.io/blog/categories/docker/"/>
    
    
      <category term="docker" scheme="http://AlbertGithubHome.github.io/blog/tags/docker/"/>
    
      <category term="python" scheme="http://AlbertGithubHome.github.io/blog/tags/python/"/>
    
      <category term="容器" scheme="http://AlbertGithubHome.github.io/blog/tags/%E5%AE%B9%E5%99%A8/"/>
    
      <category term="GithubPackages" scheme="http://AlbertGithubHome.github.io/blog/tags/GithubPackages/"/>
    
  </entry>
  
  <entry>
    <title>借助ChatGPT使用Python搭建一个工具网站</title>
    <link href="http://AlbertGithubHome.github.io/blog/2024/03/02/%E5%80%9F%E5%8A%A9ChatGPT%E4%BD%BF%E7%94%A8Python%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%B7%A5%E5%85%B7%E7%BD%91%E7%AB%99/"/>
    <id>http://AlbertGithubHome.github.io/blog/2024/03/02/借助ChatGPT使用Python搭建一个工具网站/</id>
    <published>2024-03-01T18:00:00.000Z</published>
    <updated>2024-04-29T15:06:43.236Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>不知不觉ChatGPT已经风靡一年多了，现在基本每天工作时都会用到，相比于传统的搜索引擎它究竟强在哪呢？我觉得以往的搜索引擎是一个机器，你给它关键信息它能返回匹配关键词的内容数据，而ChatGPT更像是一个机器“人”，它同样可以返回给你匹配关键信息的数据，同时可以按照你的指令进行加工，更优秀的是它还记得你跟它说过的每一句话，就像拥有一个可以存储交流记录的大脑一样，你可以赋予它一些性格和规则，让它来帮你做事情，交流的多了它就能变成一个性格鲜明的“生物”，并且可以无条件接受你的命令，所以最近突发奇想让它帮我搭一个网站怎么样，说干就干起来了。</p><a id="more"></a><h1 id="网站搭建过程"><a href="#网站搭建过程" class="headerlink" title="网站搭建过程"></a>网站搭建过程</h1><p>怀着期望的心情我给了它一个比较简单的任务</p><p><img src="https://img-blog.csdnimg.cn/direct/5a266ee4f4144cd1a8f6c441920767fb.png#pic_center" alt="chatgpt1"><br>完成的还不错，按照他的代码和步骤确实得到了一个可以转换文字编码的单页面网站，但是flask有点陌生，我想了解更多，于是它给了我解答</p><p><img src="https://img-blog.csdnimg.cn/direct/8c97b97eb08b47b5b42e366c972d1d4e.png#pic_center" alt="chatgpt2"><br>但是这个网站在运行过程中控制台输出了一些警告，我让它帮我解决一下</p><p><img src="https://img-blog.csdnimg.cn/direct/d76e79a0dfd44f558aaf5343a997cdef.png#pic_center" alt="chatgpt3"><br>虽然没解决，但我知道了警告的含义，于是我想改善一下页面工具使用体验</p><p><img src="https://img-blog.csdnimg.cn/direct/0966bf50ecee435496bfbe556c6e8d71.png#pic_center" alt="chatgpt4"><br>目前这个网站只能在本机访问，在其他机器访问时被拒绝，我又找它想办法</p><p><img src="https://img-blog.csdnimg.cn/direct/a1ac560c90a04c748f47a36544d5021d.png#pic_center" alt="chatgpt5"><br>此时我发现了一个错误，不知什么时候它不能转base64了，通知它修正一下</p><p><img src="https://img-blog.csdnimg.cn/direct/6e800ad9f7724d67b68462ddeca22355.png#pic_center" alt="chatgpt6"><br>现在是在控制台启动的，把它变成一个真正的后台网站</p><p><img src="https://img-blog.csdnimg.cn/direct/a2f4706a9b3247a1a0673733e4de591a.png#pic_center" alt="chatgpt7"><br>继续优化，将页面拆分，各司其职</p><p><img src="https://img-blog.csdnimg.cn/direct/62a8eb7cadf74d82a80693fe199f78c1.png#pic_center" alt="chatgpt8"><br><img src="https://img-blog.csdnimg.cn/direct/9cf71e59d3aa4e4c9f7110fa9bbac89a.png#pic_center" alt="chatgpt9"><br>页面分离后报了错误找它解决<br><img src="https://img-blog.csdnimg.cn/direct/9248028a53664b9a9332b02500020156.png#pic_center" alt="chatgpt10"><br>更改页面跳转样式<br><img src="https://img-blog.csdnimg.cn/direct/b43c4dfa74464609b6484f24c24428d2.png#pic_center" alt="chatgpt11"></p><p>即使你说第一版最好它也不会发脾气</p><p><img src="https://img-blog.csdnimg.cn/direct/0a1852352fb446d28735c59d41968f14.png#pic_center" alt="chatgpt12"><br>让它帮你记录当前项目以备后续扩展<br><img src="https://img-blog.csdnimg.cn/direct/ab5d830be2a34010a4f2ceedc02f7dbd.png#pic_center" alt="chatgpt13"></p><p>就这样一步一步的，我又加了新的需求，网站出来后效果还不错，以下是展示页</p><p><img src="https://img-blog.csdnimg.cn/direct/7288aee4ece34a449fa10950dc15e02d.png#pic_center" alt="page1"><br>这是主页面，点击卡片会进行跳转</p><p><img src="https://img-blog.csdnimg.cn/direct/d136f750155c43928ed334a28d88a332.png#pic_center" alt="page2">)</p><p>功能都可以正常使用，基本实现了我想要做一个极简工具网站的需求</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li><code>ChatGPT</code> 是真的强，可以按照你的指令一步步思考和总结，再也不是搜索引擎的匹配规则了</li><li>强大的工具要学着使用，每一波新生代的工具都会带来一些变革，别再只把它当成搜索引擎了</li><li>这周参加了一堂课，讲解ChatGPT的一些实际应用，其实已经遍地开花了，很多项目组都已经玩出花了</li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/136154906" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>想要逃却逃不掉，只能转身面对~</p><p>2024-3-1 21:49:59</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;不知不觉ChatGPT已经风靡一年多了，现在基本每天工作时都会用到，相比于传统的搜索引擎它究竟强在哪呢？我觉得以往的搜索引擎是一个机器，你给它关键信息它能返回匹配关键词的内容数据，而ChatGPT更像是一个机器“人”，它同样可以返回给你匹配关键信息的数据，同时可以按照你的指令进行加工，更优秀的是它还记得你跟它说过的每一句话，就像拥有一个可以存储交流记录的大脑一样，你可以赋予它一些性格和规则，让它来帮你做事情，交流的多了它就能变成一个性格鲜明的“生物”，并且可以无条件接受你的命令，所以最近突发奇想让它帮我搭一个网站怎么样，说干就干起来了。&lt;/p&gt;
    
    </summary>
    
      <category term="ChatGPT" scheme="http://AlbertGithubHome.github.io/blog/categories/ChatGPT/"/>
    
    
      <category term="Python" scheme="http://AlbertGithubHome.github.io/blog/tags/Python/"/>
    
      <category term="工具" scheme="http://AlbertGithubHome.github.io/blog/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="ChatGPT" scheme="http://AlbertGithubHome.github.io/blog/tags/ChatGPT/"/>
    
      <category term="web" scheme="http://AlbertGithubHome.github.io/blog/tags/web/"/>
    
      <category term="tools" scheme="http://AlbertGithubHome.github.io/blog/tags/tools/"/>
    
  </entry>
  
  <entry>
    <title>在golang语言中简单使用protobuf时遭遇go_package困难重重</title>
    <link href="http://AlbertGithubHome.github.io/blog/2024/02/18/%E5%9C%A8golang%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8protobuf%E6%97%B6%E9%81%AD%E9%81%87go-package%E5%9B%B0%E9%9A%BE%E9%87%8D%E9%87%8D/"/>
    <id>http://AlbertGithubHome.github.io/blog/2024/02/18/在golang语言中简单使用protobuf时遭遇go-package困难重重/</id>
    <published>2024-02-18T13:00:00.000Z</published>
    <updated>2024-02-19T15:27:44.989Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Protobuf，全称Protocol Buffers，是一种由Google开发的用于序列化结构化数据的开源数据交换格式，Golang作为一种后端语言，免不了使用protobuf这种数据交换格式，本来打算写个小例子展示一下怎样在go语言中使用protobuf，结果遇到的问题到不少，特别是这个go_package的要求，也是之前在项目开发过程中遇到的，这次就查找一下具体原因以及怎么使用吧。</p><a id="more"></a><h1 id="编写示例"><a href="#编写示例" class="headerlink" title="编写示例"></a>编写示例</h1><p>为了能对这个示例有一个整体的轮廓，我先把编写好的目录结构展示一下，后面再逐步实现</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ tree lib_protobuf</span><br><span class="line">lib_protobuf</span><br><span class="line">├── go.mod</span><br><span class="line">├── go.sum</span><br><span class="line">├── lib_protobuf.go</span><br><span class="line">├── msgproto</span><br><span class="line">│   └── examplemsg.pb.go</span><br><span class="line">└── srcproto</span><br><span class="line">    └── examplemsg.proto</span><br></pre></td></tr></table></figure><p>简单解释下，<code>examplemsg.proto</code> proto源文件，<code>examplemsg.pb.go</code> 是proto导出文件，<code>lib_protobuf.go</code> 是proto协议使用和测试文件</p><h2 id="示例初始化"><a href="#示例初始化" class="headerlink" title="示例初始化"></a>示例初始化</h2><p>执行下面的命令，创建示例基础目录文件结构</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir lib_protobuf</span><br><span class="line">$ <span class="built_in">cd</span> lib_protobuf</span><br><span class="line">$ mkdir srcproto</span><br><span class="line">$ touch srcproto/examplremsg.proto</span><br><span class="line">$ touch lib_protobuf.go</span><br><span class="line">$ go mod init lib_protobuf</span><br><span class="line">go: creating new go.mod: module lib_protobuf</span><br><span class="line">go: to add module requirements and sums:</span><br><span class="line">        go mod tidy</span><br><span class="line"></span><br><span class="line">$ go mod tidy</span><br><span class="line">$ ls</span><br><span class="line">go.mod  lib_protobuf.go  srcproto</span><br></pre></td></tr></table></figure><h2 id="编写协议文件内容"><a href="#编写协议文件内容" class="headerlink" title="编写协议文件内容"></a>编写协议文件内容</h2><p>先编写proto文件，文件内容如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">"proto3"</span>;</span><br><span class="line"></span><br><span class="line">message Person &#123;</span><br><span class="line">    <span class="keyword">string</span> name = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int32</span> age = <span class="number">2</span>;</span><br><span class="line">    repeated <span class="keyword">string</span> hobbies = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个协议文件只定义了一个名为 <code>Person</code> 的结构，其中包括 <code>name</code> 、<code>age</code>、<code>hobbies</code> 三个字段</p><h2 id="导出协议文件"><a href="#导出协议文件" class="headerlink" title="导出协议文件"></a>导出协议文件</h2><p>这是本文的重点，至于怎么用proto文件定义结构，各个语言都是相通的，但是在导出时遇到 <code>go_package</code> 文件却是 golang 语言特有的，所以本文重点在这部分多花些篇幅，解释一下遇到的各种问题</p><h3 id="protoc-和-protoc-gen-go"><a href="#protoc-和-protoc-gen-go" class="headerlink" title="protoc 和 protoc-gen-go"></a>protoc 和 protoc-gen-go</h3><p>导出时需要是使用工具 <code>protoc</code>，而平时你可能听说过或者在.pb.go文件中看到过 <code>protoc-gen-go</code> 这个工具的名字，其实 <code>protoc-gen-go</code> 是一个用于生成 Go 代码的插件，它是 Protocol Buffers 编译器 <code>protoc</code> 的一部分。当您使用 <code>protoc</code> 编译 <code>.proto</code> 文件时，可以通过指定 <code>--go_out</code> 标志来指定要使用的 <code>protoc-gen-go</code> 插件，从而生成对应的 Go 代码文件。这个插件会根据 <code>.proto</code> 文件中定义的消息和服务等内容，生成与之对应的 Go 结构体、接口和方法等代码。因此，<code>protoc-gen-go</code> 和 <code>protoc</code> 是紧密相关的，它们共同用于将 Protocol Buffers 文件编译为 Go 语言中的数据结构和服务定义。</p><h3 id="执行导出命令"><a href="#执行导出命令" class="headerlink" title="执行导出命令"></a>执行导出命令</h3><p>使用<code>protoc</code>将proto文件导出golang可用的文件最重要的两个参数如下：</p><p><code>--proto_path</code>：proto源文件所在文件夹<br><code>--go_out</code>：proto文件导出的目标文件夹</p><p>执行命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> lib_protobuf</span><br><span class="line">$ protoc --proto_path=srcproto --go_out=. examplemsg.proto</span><br><span class="line">protoc-gen-go: unable to determine Go import path <span class="keyword">for</span> <span class="string">"examplemsg.proto"</span></span><br><span class="line"></span><br><span class="line">Please specify either:</span><br><span class="line">        • a <span class="string">"go_package"</span> option <span class="keyword">in</span> the .proto <span class="built_in">source</span> file, or</span><br><span class="line">        • a <span class="string">"M"</span> argument on the <span class="built_in">command</span> line.</span><br><span class="line"></span><br><span class="line">See https://developers.google.com/protocol-buffers/docs/reference/go-generated<span class="comment">#package for more information.</span></span><br><span class="line"></span><br><span class="line">--go_out: protoc-gen-go: Plugin failed with status code 1.</span><br></pre></td></tr></table></figure><p>不出意外的果然出意外了，告诉我不能确定 <code>examplemsg.proto</code> 文件的导入路径，换句话说就是现在这样不能导出一个可以被正常导入的包，有两种解决办法，第一种就是在.proto文件中添加 <code>go_package</code> 选项，第二种是在执行导出的命令行中添加<code>M</code>参数，详细的解释参考链接 <a href="https://developers.google.com/protocol-buffers/docs/reference/go-generated#package" target="_blank" rel="noopener">https://developers.google.com/protocol-buffers/docs/reference/go-generated#package</a></p><p>官方推荐是用第一种方式，也就是直接在.proto文件中添加 <code>go_package</code> 选项，假如我们这样写：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">option go_package = <span class="string">"msgproto"</span>;</span><br></pre></td></tr></table></figure><p>然后直接导出会遇到新的错误，提示”msgproto”并不是文件”examplemsg.proto”的一个有效的导入路径</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ protoc --proto_path=srcproto --go_out=. examplemsg.proto</span><br><span class="line">protoc-gen-go: invalid Go import path <span class="string">"msgproto"</span> <span class="keyword">for</span> <span class="string">"examplemsg.proto"</span></span><br><span class="line"></span><br><span class="line">The import path must contain at least one period (<span class="string">'.'</span>) or forward slash (<span class="string">'/'</span>) character.</span><br><span class="line"></span><br><span class="line">See https://developers.google.com/protocol-buffers/docs/reference/go-generated<span class="comment">#package for more information.</span></span><br><span class="line"></span><br><span class="line">--go_out: protoc-gen-go: Plugin failed with status code 1.</span><br></pre></td></tr></table></figure><p>要求必须至少包含一个 <code>.</code> 或者 <code>/</code>，那么把选项改成下面这样就可以了</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">option go_package = <span class="string">"./msgproto"</span>;</span><br></pre></td></tr></table></figure><p>有时为了在当前目录下生成，又要指定包名，可以写成这样：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">option go_package = <span class="string">"./;msgproto"</span>;</span><br></pre></td></tr></table></figure><p>使用分号将包路径和包名分开，但这种方法官方并不推荐，因为按照golang的包管理习惯，文件夹下的所有文件包名应该与文件名相同，通过包的路径能够推测是包名才对，否则写成 <code>option go_package = &quot;./msgprotoA;msgprotoB&quot;;</code> 就很奇怪了</p><p>关于go_package至少包含一个 <code>.</code> 或者 <code>/</code>的要求，据说v1.4.0以上的版本就要求必须加<code>/</code>了，最近查了一些资料，解释如下：</p><blockquote><p>在 Protocol Buffers（Protobuf）中，go_package 选项用于指定生成的 Go 代码的包名和导入路径。要求导入路径（import path）必须包含至少一个点（.）或正斜杠（/）的原因与 Go 语言的模块系统和包导入机制有关</p><p>这个要求是因为在导出时，<code>protoc</code> 需要能够将生成的代码文件放置在文件系统的适当位置，并且需要能够以合适的包路径来导入这些生成的代码。在大多数情况下，包路径应该具有与文件系统路径相对应的结构，因此至少需要包含一个句点（<code>.</code>）或正斜杠（<code>/</code>）字符来指示层次结构。</p><p>如果导入路径不包含这些字符，那么生成的代码文件将无法以合适的方式组织和导入，可能会导致编译器无法正确识别代码的位置和包结构。因此，为了确保生成的代码能够被正确导入和使用，<code>protoc</code> 对导入路径设置了这个最低要求。</p></blockquote><p>但是我觉得这个解释不能让人信服，我把go_package的值写成 <code>.msgproto</code>、<code>msgproto.</code> 或者 <code>..msgproto</code> 都是能正常导出的，并没有看到这种限制的好处，其中深层次的原因还得在今后的使用过程中慢慢体会了</p><h2 id="编写协议使用文件"><a href="#编写协议使用文件" class="headerlink" title="编写协议使用文件"></a>编写协议使用文件</h2><p>在文件 lib_protobuf.go 中编写如下内容，执行 <code>go mod tidy</code> 和 <code>go run .</code> 查看输出结果</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">"fmt"</span></span><br><span class="line">   <span class="string">"log"</span></span><br><span class="line"></span><br><span class="line">   msg <span class="string">"lib_protobuf/msgproto"</span></span><br><span class="line"></span><br><span class="line">   <span class="string">"google.golang.org/protobuf/proto"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   p := &amp;msg.Person&#123;</span><br><span class="line">      Name:    <span class="string">"Alice"</span>,</span><br><span class="line">      Age:     <span class="number">30</span>,</span><br><span class="line">      Hobbies: []<span class="keyword">string</span>&#123;<span class="string">"reading"</span>, <span class="string">"running"</span>&#125;,</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 序列化</span></span><br><span class="line">   data, err := proto.Marshal(p)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      log.Fatalf(<span class="string">"Failed to encode person: %v"</span>, err)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 反序列化</span></span><br><span class="line">   newP := &amp;msg.Person&#123;&#125;</span><br><span class="line">   err = proto.Unmarshal(data, newP)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      log.Fatalf(<span class="string">"Failed to decode person: %v"</span>, err)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   fmt.Println(<span class="string">"Original Person:"</span>, p)</span><br><span class="line">   fmt.Println(<span class="string">"Decoded Person:"</span>, newP)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ go run .</span><br><span class="line">Original Person: name:<span class="string">"Alice"</span>  age:30  hobbies:<span class="string">"reading"</span>  hobbies:<span class="string">"running"</span></span><br><span class="line">Decoded Person: name:<span class="string">"Alice"</span>  age:30  hobbies:<span class="string">"reading"</span>  hobbies:<span class="string">"running"</span></span><br></pre></td></tr></table></figure><h1 id="体会"><a href="#体会" class="headerlink" title="体会"></a>体会</h1><p>有关 <code>go_package</code> 值官方给出的示例是这种 <code>example.com/project/protos/fizz</code>，这就跟go.mod文件中的module定义一样，比如 <code>module github.com/tealeg/xlsx</code> 或 <code>module github.com/peterbourgon/diskv/v3</code>，提供的是一种导出之后的引用写法</p><p>但是 <code>go_package</code> 和 <code>module</code> 还确实有一些不同，因为它在导出时真的会根据 <code>go_package</code> 生成相应的路径，所以针对这些去情况我觉得一种比较好的写法是从项目根目录开始写，导出的目录也是根目录，这样在引用时直接写 <code>go_package</code> 就可以了，但是具体情况还需灵活应对</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">option go_package = <span class="string">"lib_protobuf/msgproto"</span>;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ lib_protobuf</span><br><span class="line">$ protoc --proto_path=srcproto --go_out=.. examplemsg.proto</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">"fmt"</span></span><br><span class="line">   <span class="string">"log"</span></span><br><span class="line"></span><br><span class="line">   msg <span class="string">"lib_protobuf/msgproto"</span></span><br><span class="line"></span><br><span class="line">   <span class="string">"google.golang.org/protobuf/proto"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>Protobuf是一种由Google开发的用于序列化结构化数据的开源数据交换格式</li><li>使用<code>protoc</code> 工具可以将 <code>.proto</code> 文件导出成golang可用的数据交换文件</li><li><code>protoc-gen-go</code> 是一个用于生成 Go 代码的插件，它是 Protocol Buffers 编译器 <code>protoc</code> 的一部分</li><li>.proto文件中的<code>go_package</code>选项的值至少需要包含一个 <code>.</code> 或者 <code>/</code></li><li><code>go_package</code> 的值官方给出的示例是这种类似module名的写法 <code>example.com/project/protos/fizz</code></li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/136074333" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>仰天大笑出门去，我辈岂是蓬蒿人。不好意思，我们绝大多数都是蓬蒿人，都是陪跑的NPC，只是在穷尽一生的努力想做一颗稍微不那么矮的蓬蒿而已~</p><p>2024-2-18 16:44:18</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;Protobuf，全称Protocol Buffers，是一种由Google开发的用于序列化结构化数据的开源数据交换格式，Golang作为一种后端语言，免不了使用protobuf这种数据交换格式，本来打算写个小例子展示一下怎样在go语言中使用protobuf，结果遇到的问题到不少，特别是这个go_package的要求，也是之前在项目开发过程中遇到的，这次就查找一下具体原因以及怎么使用吧。&lt;/p&gt;
    
    </summary>
    
      <category term="Go" scheme="http://AlbertGithubHome.github.io/blog/categories/Go/"/>
    
    
      <category term="开发语言" scheme="http://AlbertGithubHome.github.io/blog/tags/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/"/>
    
      <category term="golang" scheme="http://AlbertGithubHome.github.io/blog/tags/golang/"/>
    
      <category term="protobuf" scheme="http://AlbertGithubHome.github.io/blog/tags/protobuf/"/>
    
      <category term="protoc" scheme="http://AlbertGithubHome.github.io/blog/tags/protoc/"/>
    
      <category term="go_package" scheme="http://AlbertGithubHome.github.io/blog/tags/go-package/"/>
    
  </entry>
  
  <entry>
    <title>简单聊聊go语言中引用模块的版本控制以及invalid: should be v0 or v1, not v2问题的解决</title>
    <link href="http://AlbertGithubHome.github.io/blog/2024/02/09/%E7%AE%80%E5%8D%95%E8%81%8A%E8%81%8Ago%E8%AF%AD%E8%A8%80%E4%B8%AD%E5%BC%95%E7%94%A8%E6%A8%A1%E5%9D%97%E7%9A%84%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E4%BB%A5%E5%8F%8Ainvalid-should-be-v0-or-v1-not-v2%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3/"/>
    <id>http://AlbertGithubHome.github.io/blog/2024/02/09/简单聊聊go语言中引用模块的版本控制以及invalid-should-be-v0-or-v1-not-v2问题的解决/</id>
    <published>2024-02-08T16:45:00.000Z</published>
    <updated>2024-02-19T15:48:12.961Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>如果你接触go语言比较早，一定有过当年所有go源码全部放入 <code>GOPATH</code> 下的混乱经历，不过发展到今天，go的包管理使用 <code>go.mod</code> 和 <code>go.work</code> 已经能得心应手，满足绝大多数的开发不成问题，其实在 <code>go.mod</code> 引入之后，go的包管理就有了明显的改善，再也不像原来那样好似闹着玩一样了，关于go.mod使用和管理我也是一知半解，想要教程可去官网或者查找各种详解资料，只是最近有点疑惑，这个go.mod以及go.sum要不要自己手动管理，带着这个疑问我做了一些测试可以得出，go.mod 的最初不需要手动管理，如果后来需要调整引入包的版本，可以手动调整。</p><a id="more"></a><p>以下是来自ChatGPT的关于 <code>go.mod</code> 和 <code>go.sum</code> 作用的回答，还是比较清晰的，如果还不太明白可以看看后面的例子感受一下</p><blockquote><p><code>go.mod</code> 和 <code>go.sum</code> 文件是 Go Modules 的重要组成部分，用于管理项目的依赖关系。共同为 Go 项目提供了依赖管理的基础，确保了项目的稳定性和可维护性：</p><ol><li><p><strong>go.mod</strong>：</p><ul><li>定义了项目的模块信息，包括模块名称、版本和依赖项等。</li><li>确定了项目的模块根目录。</li><li>记录了项目所依赖的其他模块及其版本信息。</li><li>提供了一种清晰的方式来管理项目的依赖关系，使得项目的构建和维护更加可靠和可控。</li></ul></li><li><p><strong>go.sum</strong>：</p><ul><li>记录了每个依赖模块的哈希值，以保证项目的构建是可复现的。</li><li>确保了项目依赖项的完整性，防止恶意篡改或不完整的依赖项被用于构建项目。</li><li>当使用 <code>go mod verify</code> 命令时，<code>go.sum</code> 文件会被用来验证依赖项的完整性。</li></ul></li></ol></blockquote><p>&gt;</p><blockquote><p>通常情况下，<code>go.mod</code> 文件是由 <code>go</code> 工具自动生成和管理的，不需要手动修改。当你执行一些与模块相关的操作时（例如使用 <code>go get</code> 安装新的依赖、使用 <code>go mod tidy</code> 整理依赖、或者更新依赖版本等），<code>go</code> 工具会自动更新 <code>go.mod</code> 文件以反映这些变化，但是，在某些特定情况下，你可能需要手动编辑 <code>go.mod</code> 文件，例如：</p><ol><li><p>手动添加或删除依赖项：你可能希望手动添加新的依赖项，或者删除不再需要的依赖项。在这种情况下，你需要手动编辑 <code>go.mod</code> 文件，并执行 <code>go mod tidy</code> 命令以确保依赖关系的一致性。</p></li><li><p>手动指定依赖版本：有时你可能希望显式地指定某个依赖项的特定版本。在这种情况下，你需要编辑 <code>go.mod</code> 文件，并指定对应的版本号。</p></li></ol><p>总的来说，虽然 <code>go.mod</code> 文件通常是由 <code>go</code> 工具自动维护的，但在某些情况下手动编辑是必要的。在编辑 <code>go.mod</code> 文件时，确保遵循 Go 模块的规范，并注意保持文件的格式正确和依赖关系的一致性。</p></blockquote><h1 id="具体示例"><a href="#具体示例" class="headerlink" title="具体示例"></a>具体示例</h1><p>假设有一个需求，要读取 <code>.xlsx</code> 格式表格文件的所有页签名，解析Excel文件这么基础的工作肯定有人写好了，我们直接引入module不需要重新再写一遍了，我们新建一个包含go.mod的工程来使用它</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir lib_xlsx</span><br><span class="line">$ <span class="built_in">cd</span> lib_xlsx</span><br><span class="line">$ go mod init lib_xlsx</span><br><span class="line">go: creating new go.mod: module lib_xlsx</span><br><span class="line"></span><br><span class="line">$ touch lib_xlsx.go</span><br><span class="line">$ ls</span><br><span class="line">go.mod  lib_xlsx.go</span><br></pre></td></tr></table></figure><p>go.mod的初始文件内容为</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">module lib_xlsx</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="number">1.19</span></span><br></pre></td></tr></table></figure><p>打开 <code>lib_xlsx.go</code> 文件编写如下代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">"fmt"</span></span><br><span class="line">   <span class="string">"log"</span></span><br><span class="line"></span><br><span class="line">   <span class="string">"github.com/tealeg/xlsx"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">   xlFile, err := xlsx.OpenFile(<span class="string">"example.xlsx"</span>)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      log.Fatalf(<span class="string">"Error opening file: %s"</span>, err)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> _, sheet := <span class="keyword">range</span> xlFile.Sheets &#123;</span><br><span class="line">      fmt.Println(<span class="string">"Sheet Name:"</span>, sheet.Name)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码是不是很简单，此时不出意外IDE会提醒你 <code>could not import github.com/tealeg/xlsx</code> 的错误，因为我们还没下载这个包，只需要在命令行执行 <code>go get github.com/tealeg/xlsx</code> 既可下载，同时会自动更新 <code>go.mod</code> 和 <code>go.sum</code> 文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ go get github.com/tealeg/xlsx</span><br><span class="line">go: added github.com/tealeg/xlsx v1.0.5</span><br></pre></td></tr></table></figure><p>自动更新后的 go.mod 文件内容，引用了 <code>github.com/tealeg/xlsx</code> 库的 <code>v1.0.5</code> 版本</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">module lib_xlsx</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="number">1.19</span></span><br><span class="line"></span><br><span class="line">require github.com/tealeg/xlsx v1<span class="number">.0</span><span class="number">.5</span></span><br></pre></td></tr></table></figure><p>自动更新后的 go.sum 文件内容，记录了各个依赖库、间接依赖库以及项目go.mod文件的hash值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">github.com/kr/pretty v0<span class="number">.1</span><span class="number">.0</span> h1:L/CwN0zerZDmRFUapSPitk6f+Q3+<span class="number">0</span>za1rQkzVuMiMFI=</span><br><span class="line">github.com/kr/pretty v0<span class="number">.1</span><span class="number">.0</span>/<span class="keyword">go</span>.mod h1:dAy3ld7l9f0ibDNOQOHHMYYIIbhfbHSm3C4ZsoJORNo=</span><br><span class="line">github.com/kr/pty v1<span class="number">.1</span><span class="number">.1</span>/<span class="keyword">go</span>.mod h1:pFQYn66WHrOpPYNljwOMqo10TkYh1fy3cYio2l3bCsQ=</span><br><span class="line">github.com/kr/text v0<span class="number">.1</span><span class="number">.0</span> h1:<span class="number">45s</span>CR5RtlFHMR4UwH9sdQ5TC8v0qDQCHnXt+kaKSTVE=</span><br><span class="line">github.com/kr/text v0<span class="number">.1</span><span class="number">.0</span>/<span class="keyword">go</span>.mod h1:<span class="number">4</span>Jbv+DJW3UT/LiOwJeYQe1efqtUx/iVham/<span class="number">4</span>vfdArNI=</span><br><span class="line">github.com/tealeg/xlsx v1<span class="number">.0</span><span class="number">.5</span> h1:+f8oFmvY8Gw1iUXzPk+kz+<span class="number">4</span>GpbDZPK1FhPiQRd+ypgE=</span><br><span class="line">github.com/tealeg/xlsx v1<span class="number">.0</span><span class="number">.5</span>/<span class="keyword">go</span>.mod h1:btRS8dz54TDnvKNosuAqxrM1QgN1udgk9O34bDCnORM=</span><br><span class="line">gopkg.in/check.v1 v1<span class="number">.0</span><span class="number">.0</span><span class="number">-20190902080502</span><span class="number">-41f</span>04d3bba15 h1:YR8cESwS4TdDjEe65xsg0ogRM/Nc3DYOhEAlW+xobZo=</span><br><span class="line">gopkg.in/check.v1 v1<span class="number">.0</span><span class="number">.0</span><span class="number">-20190902080502</span><span class="number">-41f</span>04d3bba15/<span class="keyword">go</span>.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=</span><br></pre></td></tr></table></figure><p>此时程序已经写完，依赖关系也已经下载好了，直接运行就可以</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ go run .</span><br><span class="line">Sheet Name: Sheet1</span><br><span class="line">Sheet Name: Sheet2</span><br><span class="line">Sheet Name: Sheet3</span><br></pre></td></tr></table></figure><p>因为 <code>go.mod</code> 和 <code>go.sum</code> 文件共同为这个项目提供了依赖管理，别人在下载你这份<a href="https://github.com/AlbertGithubHome/go/tree/master/lib_xlsx" target="_blank" rel="noopener">源码</a>时，先执行 <code>go mod tidy</code> 根据依赖关系下载正确的版本库，之后就可以直接编译运行了</p><h1 id="手动升级依赖库"><a href="#手动升级依赖库" class="headerlink" title="手动升级依赖库"></a>手动升级依赖库</h1><p>到目前为止，我们并没有手动编辑过 go.mod 文件，只是在使用 <code>go get github.com/tealeg/xlsx</code> 自动更新了这个文件，假设这个例子的需求要扩展，引用的 <code>github.com/tealeg/xlsx</code> 功能是在<code>v1.0.6</code> 版本新加的，那么我么只需要将 <code>go.mod</code> 文件中的 <code>v1.0.5</code> 替换成 <code>v1.0.6</code>，然后执行 <code>go mod tidy</code> 即可下载正确的依赖库。</p><p>但如果要引用的依赖库版本不是 <code>v0</code> 或者 <code>v1</code> 版本的就不能这么处理了，具体做法看下面的问题。</p><h1 id="should-be-v0-or-v1-not-v2"><a href="#should-be-v0-or-v1-not-v2" class="headerlink" title="should be v0 or v1, not v2"></a>should be v0 or v1, not v2</h1><p>当你手动把 <code>go.mod</code> 文件中的 <code>v1.0.5</code> 替换成 <code>v2.x.x</code> 执行 <code>go mod tidy</code> 时就会报一个错误</p><blockquote><p>errors parsing go.mod: /xxx/lib_xlsx/go.mod:5: require github.com/tealeg/xlsx: version “v2.0.0” invalid: should be v0 or v1, not v2</p></blockquote><p>问题的原因及细节可以参考这篇文档<a href="https://mileslin.github.io/2020/08/Golang/%E5%88%B0%E5%BA%95-go-get-%E7%9A%84%E7%89%88%E8%99%9F%E6%80%8E%E9%BA%BC%E9%81%8B%E4%BD%9C%E7%9A%84/" target="_blank" rel="noopener">《[Go] 到底 go get 的版號怎麼運作的?》</a>中关于“Semantic import version”的描述</p><p>复杂的原因简单说：Go有一个规范，就是在启用了Go Module的仓库上如果想使用 v2 及以上版本，需要在原引用库上添加版本标识简写，比如这个例子中，我们需要将 <code>lib_xlsx.go</code> 文件中引用包的代码改成下面这样</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">"fmt"</span></span><br><span class="line">   <span class="string">"log"</span></span><br><span class="line"></span><br><span class="line">   <span class="string">"github.com/tealeg/xlsx/v3"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>执行 <code>go mod tidy</code> 命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ go mod tidy</span><br><span class="line">go: finding module <span class="keyword">for</span> package github.com/tealeg/xlsx/v3</span><br><span class="line">go: found github.com/tealeg/xlsx/v3 <span class="keyword">in</span> github.com/tealeg/xlsx/v3 v3.3.5</span><br></pre></td></tr></table></figure><p>如果遇到下面这个问题，确认修改无误的话多尝试几次</p><blockquote><p>$ go mod tidy<br>go: finding module for package github.com/tealeg/xlsx/v3<br>lib_xlsx imports<br>       github.com/tealeg/xlsx/v3: module github.com/tealeg/xlsx/v3: Get “<a href="https://proxy.golang.org/github.com/tealeg/xlsx/v3/@v/list" target="_blank" rel="noopener">https://proxy.golang.org/github.com/tealeg/xlsx/v3/@v/list</a>“: EOF</p></blockquote><p>执行过后 go.mod 和 go.sum 两个文件改变后的内容如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">module lib_xlsx</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="number">1.19</span></span><br><span class="line"></span><br><span class="line">require github.com/tealeg/xlsx/v3 v3<span class="number">.3</span><span class="number">.5</span></span><br><span class="line"></span><br><span class="line">require (</span><br><span class="line">   github.com/frankban/quicktest v1<span class="number">.14</span><span class="number">.6</span> <span class="comment">// indirect</span></span><br><span class="line">   github.com/google/btree v1<span class="number">.0</span><span class="number">.0</span> <span class="comment">// indirect</span></span><br><span class="line">   github.com/google/<span class="keyword">go</span>-cmp v0<span class="number">.5</span><span class="number">.9</span> <span class="comment">// indirect</span></span><br><span class="line">   github.com/kr/pretty v0<span class="number">.3</span><span class="number">.1</span> <span class="comment">// indirect</span></span><br><span class="line">   github.com/kr/text v0<span class="number">.2</span><span class="number">.0</span> <span class="comment">// indirect</span></span><br><span class="line">   github.com/peterbourgon/diskv/v3 v3<span class="number">.0</span><span class="number">.1</span> <span class="comment">// indirect</span></span><br><span class="line">   github.com/rogpeppe/fastuuid v1<span class="number">.2</span><span class="number">.0</span> <span class="comment">// indirect</span></span><br><span class="line">   github.com/rogpeppe/<span class="keyword">go</span>-internal v1<span class="number">.9</span><span class="number">.0</span> <span class="comment">// indirect</span></span><br><span class="line">   github.com/shabbyrobe/xmlwriter v0<span class="number">.0</span><span class="number">.0</span><span class="number">-20200208144257</span><span class="number">-9f</span>ca06d00ffa <span class="comment">// indirect</span></span><br><span class="line">   golang.org/x/text v0<span class="number">.3</span><span class="number">.8</span> <span class="comment">// indirect</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">github.com/creack/pty v1<span class="number">.1</span><span class="number">.9</span>/<span class="keyword">go</span>.mod h1:oKZEueFk5CKHvIhNR5MUki03XCEU+Q6VDXinZuGJ33E=</span><br><span class="line">github.com/frankban/quicktest v1<span class="number">.14</span><span class="number">.6</span> h1:<span class="number">7</span>Xjx+VpznH+oBnejlPUj8oUpdxnVs4f8XU8WnHkI4W8=</span><br><span class="line">github.com/frankban/quicktest v1<span class="number">.14</span><span class="number">.6</span>/<span class="keyword">go</span>.mod h1:<span class="number">4</span>ptaffx2x8+WTWXmUCuVU6aPUX1/Mz7zb5vbUoiM6w0=</span><br><span class="line">github.com/google/btree v1<span class="number">.0</span><span class="number">.0</span> h1:<span class="number">0</span>udJVsspx3VBr5FwtLhQQtuAsVc79tTq0ocGIPAU6qo=</span><br><span class="line">github.com/google/btree v1<span class="number">.0</span><span class="number">.0</span>/<span class="keyword">go</span>.mod h1:lNA+<span class="number">9</span>X1NB3Zf8V7Ke586lFgjr2dZNuvo3lPJSGZ5JPQ=</span><br><span class="line">github.com/google/<span class="keyword">go</span>-cmp v0<span class="number">.5</span><span class="number">.9</span> h1:O2Tfq5qg4qc4AmwVlvv0oLiVAGB7enBSJ2x2DqQFi38=</span><br><span class="line">github.com/google/<span class="keyword">go</span>-cmp v0<span class="number">.5</span><span class="number">.9</span>/<span class="keyword">go</span>.mod h1:<span class="number">17d</span>UlkBOakJ0+DkrSSNjCkIjxS6bF9zb3elmeNGIjoY=</span><br><span class="line">github.com/kr/pretty v0<span class="number">.3</span><span class="number">.1</span> h1:flRD4NNwYAUpkphVc1HcthR4KEIFJ65n8Mw5qdRn3LE=</span><br><span class="line">github.com/kr/pretty v0<span class="number">.3</span><span class="number">.1</span>/<span class="keyword">go</span>.mod h1:hoEshYVHaxMs3cyo3Yncou5ZscifuDolrwPKZanG3xk=</span><br><span class="line">github.com/kr/text v0<span class="number">.2</span><span class="number">.0</span> h1:<span class="number">5</span>Nx0Ya0ZqY2ygV366QzturHI13Jq95ApcVaJBhpS+AY=</span><br><span class="line">github.com/kr/text v0<span class="number">.2</span><span class="number">.0</span>/<span class="keyword">go</span>.mod h1:eLer722TekiGuMkidMxC/pM04lWEeraHUUmBw8l2grE=</span><br><span class="line">github.com/niemeyer/pretty v0<span class="number">.0</span><span class="number">.0</span><span class="number">-20200227124842</span>-a10e7caefd8e h1:fD57ERR4JtEqsWbfPhv4DMiApHyliiK5xCTNVSPiaAs=</span><br><span class="line">github.com/peterbourgon/diskv/v3 v3<span class="number">.0</span><span class="number">.1</span> h1:x06SQA46+PKIUftmEujdwSEpIx8kR+M9eLYsUxeYveU=</span><br><span class="line">github.com/peterbourgon/diskv/v3 v3<span class="number">.0</span><span class="number">.1</span>/<span class="keyword">go</span>.mod h1:kJ5Ny7vLdARGU3WUuy6uzO6T0nb/<span class="number">2</span>gWcT1JiBvRmb5o=</span><br><span class="line">github.com/pkg/diff v0<span class="number">.0</span><span class="number">.0</span><span class="number">-20210226163009</span><span class="number">-20</span>ebb0f2a09e/<span class="keyword">go</span>.mod h1:pJLUxLENpZxwdsKMEsNbx1VGcRFpLqf3715MtcvvzbA=</span><br><span class="line">github.com/pkg/profile v1<span class="number">.5</span><span class="number">.0</span> h1:<span class="number">042</span>Buzk+NhDI+DeSAA62RwJL8VAuZUMQZUjCsRz1Mug=</span><br><span class="line">github.com/rogpeppe/fastuuid v1<span class="number">.2</span><span class="number">.0</span> h1:Ppwyp6VYCF1nvBTXL3trRso7mXMlRrw9ooo375wvi2s=</span><br><span class="line">github.com/rogpeppe/fastuuid v1<span class="number">.2</span><span class="number">.0</span>/<span class="keyword">go</span>.mod h1:jVj6XXZzXRy/MSR5jhDC/<span class="number">2</span>q6DgLz+nrA6LYCDYWNEvQ=</span><br><span class="line">github.com/rogpeppe/<span class="keyword">go</span>-internal v1<span class="number">.9</span><span class="number">.0</span> h1:<span class="number">73</span>kH8U+JUqXU8lRuOHeVHaa/SZPifC7BkcraZVejAe8=</span><br><span class="line">github.com/rogpeppe/<span class="keyword">go</span>-internal v1<span class="number">.9</span><span class="number">.0</span>/<span class="keyword">go</span>.mod h1:WtVeX8xhTBvf0smdhujwtBcq4Qrzq/fJaraNFVN+nFs=</span><br><span class="line">github.com/shabbyrobe/xmlwriter v0<span class="number">.0</span><span class="number">.0</span><span class="number">-20200208144257</span><span class="number">-9f</span>ca06d00ffa h1:<span class="number">2</span>cO3RojjYl3hVTbEvJVqrMaFmORhL6O06qdW42toftk=</span><br><span class="line">github.com/shabbyrobe/xmlwriter v0<span class="number">.0</span><span class="number">.0</span><span class="number">-20200208144257</span><span class="number">-9f</span>ca06d00ffa/<span class="keyword">go</span>.mod h1:Yjr3bdWaVWyME1kha7X0jsz3k2DgXNa1Pj3XGyUAbx8=</span><br><span class="line">github.com/tealeg/xlsx/v3 v3<span class="number">.3</span><span class="number">.5</span> h1:dzmns01jRf0SveBe7VqkcO2LCLOcypcDI6H66PiZycQ=</span><br><span class="line">github.com/tealeg/xlsx/v3 v3<span class="number">.3</span><span class="number">.5</span>/<span class="keyword">go</span>.mod h1:KV4FTFtvGy0TBlOivJLZu/YNZk6e0Qtk7eOSglWksuA=</span><br><span class="line">golang.org/x/text v0<span class="number">.3</span><span class="number">.2</span>/<span class="keyword">go</span>.mod h1:bEr9sfX3Q8Zfm5fL9x+<span class="number">3i</span>togRgK3+ptLWKqgva+<span class="number">5d</span>Ak=</span><br><span class="line">golang.org/x/text v0<span class="number">.3</span><span class="number">.8</span> h1:nAL+RVCQ9uMn3vJZbV+MRnydTJFPf8qqY42YiA6MrqY=</span><br><span class="line">golang.org/x/text v0<span class="number">.3</span><span class="number">.8</span>/<span class="keyword">go</span>.mod h1:E6s5w1FMmriuDzIBO73fBruAKo1PCIq6d2Q6DHfQ8WQ=</span><br><span class="line">golang.org/x/tools v0<span class="number">.0</span><span class="number">.0</span><span class="number">-20180917221912</span><span class="number">-90f</span>a682c2a6e/<span class="keyword">go</span>.mod h1:n7NCudcB/nEzxVGmLbDWY5pfWTLqBcC2KZ6jyYvM4mQ=</span><br><span class="line">gopkg.in/check.v1 v1<span class="number">.0</span><span class="number">.0</span><span class="number">-20200902074654</span><span class="number">-038f</span>dea0a05b h1:QRR6H1YWRnHb4Y/HeNFCTJLFVxaq6wH4YuVdsUOr75U=</span><br></pre></td></tr></table></figure><p>将 github.com/tealeg/xlsx 从 <code>v1.0.5</code> 升级到 <code>v3.3.5</code> 真是加了不少间接依赖库啊</p><p>至此 go.mod 文件的自动更新和手动维护我们就都尝试过了</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li><code>go.mod</code> 和 <code>go.sum</code> 文件是 Go Modules 的重要组成部分，用于管理项目的依赖关系</li><li><code>go.mod</code> 文件是由 <code>go</code> 工具自动生成和管理的，不需要手动修改，常用命令 <code>go get xxx</code> 和 <code>go mod tidy</code></li><li>如果想显式地指定某个依赖项的特定版本才需要手动编辑 <code>go.mod</code> 文件</li><li><code>go.sum</code> 文件记录了每个依赖模块的哈希值，以保证项目的构建是可复现的</li><li>如果在启用了Go Module的仓库想使用 v2 及以上版本，需要在原引用库路径末尾添加版本标识简写，比如v2、v3等</li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/135922149" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>穷则独善其身，达则兼济天下，如今在这纷繁的世间，独善其身已实属不易，天下交给你们，我自顺其自然吧~</p><p>2024-2-8 15:59:19</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;如果你接触go语言比较早，一定有过当年所有go源码全部放入 &lt;code&gt;GOPATH&lt;/code&gt; 下的混乱经历，不过发展到今天，go的包管理使用 &lt;code&gt;go.mod&lt;/code&gt; 和 &lt;code&gt;go.work&lt;/code&gt; 已经能得心应手，满足绝大多数的开发不成问题，其实在 &lt;code&gt;go.mod&lt;/code&gt; 引入之后，go的包管理就有了明显的改善，再也不像原来那样好似闹着玩一样了，关于go.mod使用和管理我也是一知半解，想要教程可去官网或者查找各种详解资料，只是最近有点疑惑，这个go.mod以及go.sum要不要自己手动管理，带着这个疑问我做了一些测试可以得出，go.mod 的最初不需要手动管理，如果后来需要调整引入包的版本，可以手动调整。&lt;/p&gt;
    
    </summary>
    
      <category term="Go" scheme="http://AlbertGithubHome.github.io/blog/categories/Go/"/>
    
    
      <category term="Go" scheme="http://AlbertGithubHome.github.io/blog/tags/Go/"/>
    
      <category term="mod" scheme="http://AlbertGithubHome.github.io/blog/tags/mod/"/>
    
      <category term="import" scheme="http://AlbertGithubHome.github.io/blog/tags/import/"/>
    
      <category term="xlsx" scheme="http://AlbertGithubHome.github.io/blog/tags/xlsx/"/>
    
      <category term="依赖库版本" scheme="http://AlbertGithubHome.github.io/blog/tags/%E4%BE%9D%E8%B5%96%E5%BA%93%E7%89%88%E6%9C%AC/"/>
    
  </entry>
  
  <entry>
    <title>使用nslookup命令查询域名系统的信息</title>
    <link href="http://AlbertGithubHome.github.io/blog/2024/01/29/%E4%BD%BF%E7%94%A8nslookup%E5%91%BD%E4%BB%A4%E6%9F%A5%E8%AF%A2%E5%9F%9F%E5%90%8D%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BF%A1%E6%81%AF/"/>
    <id>http://AlbertGithubHome.github.io/blog/2024/01/29/使用nslookup命令查询域名系统的信息/</id>
    <published>2024-01-29T14:11:51.000Z</published>
    <updated>2024-02-19T15:22:29.280Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这个命令出现在与运维同学沟通过程中，在此之前要是问我一个域名对应的服务器是IP地址是什么，我肯定优先想到的是 <code>ping</code> 这个命令，这个命令确实可以在回复的信息中看到IP地址，但是不全面，有时一个域名对应不止一个IP地址，这时就要用到 nslookup 命令了，这也是在沟通中学到的新知识点。</p><a id="more"></a><h1 id="常规使用"><a href="#常规使用" class="headerlink" title="常规使用"></a>常规使用</h1><p>学这个命令就是拿来用的，最常见的用法就是 <code>nslookup 域名</code> 来查询域名对应的IP，并且这个用法在Windows(cmd)、Mac、Linux下都是通用的，算是一个不错的跨平台命令，对比一下 <code>ping</code> 看看有什么区别：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\Administrator&gt;ping a1.easemob.com</span><br><span class="line"></span><br><span class="line">正在 Ping a1-v2.easemob.com.x.easeslb.com [47.93.162.59] 具有 32 字节的数据:</span><br><span class="line">来自 47.93.162.59 的回复: 字节=32 时间=7ms TTL=88</span><br><span class="line">来自 47.93.162.59 的回复: 字节=32 时间=7ms TTL=88</span><br><span class="line">来自 47.93.162.59 的回复: 字节=32 时间=6ms TTL=88</span><br><span class="line">来自 47.93.162.59 的回复: 字节=32 时间=6ms TTL=88</span><br><span class="line"></span><br><span class="line">47.93.162.59 的 Ping 统计信息:</span><br><span class="line">    数据包: 已发送 = 4，已接收 = 4，丢失 = 0 (0% 丢失)，</span><br><span class="line">往返行程的估计时间(以毫秒为单位):</span><br><span class="line">    最短 = 6ms，最长 = 7ms，平均 = 6ms</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\Administrator&gt;nslookup a1.easemob.com</span><br><span class="line">服务器:  UnKnown</span><br><span class="line">Address:  10.20.30.40</span><br><span class="line"></span><br><span class="line">名称:    a1-v2.easemob.com.x.easeslb.com</span><br><span class="line">Addresses:  2408:4000:200::c5</span><br><span class="line">          2408:4000:200::17</span><br><span class="line">          47.93.162.59</span><br><span class="line">          39.97.9.52</span><br><span class="line">Aliases:  a1.easemob.com</span><br></pre></td></tr></table></figure><p>以上都是在cmd下执行的，如果在PowerShell中有一个名叫 <code>Resolve-DnsName</code> 的替代命令，执行结果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\Administrator&gt; Resolve-DnsName a1.easemob.com</span><br><span class="line"></span><br><span class="line">Name                           Type   TTL   Section    NameHost</span><br><span class="line">----                           ----   ---   -------    --------</span><br><span class="line">a1.easemob.com                 CNAME  0     Answer     a1-v2.easemob.com.x.easeslb.com</span><br><span class="line"></span><br><span class="line">Name       : a1-v2.easemob.com.x.easeslb.com</span><br><span class="line">QueryType  : AAAA</span><br><span class="line">TTL        : 0</span><br><span class="line">IP6Address : 2408:4000:200::17</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Name       : a1-v2.easemob.com.x.easeslb.com</span><br><span class="line">QueryType  : AAAA</span><br><span class="line">TTL        : 0</span><br><span class="line">Section    : Answer</span><br><span class="line">IP6Address : 2408:4000:200::c5</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">QueryType  : A</span><br><span class="line">TTL        : 0</span><br><span class="line">Section    : Answer</span><br><span class="line">IP4Address : 47.93.162.59</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Name       : a1-v2.easemob.com.x.easeslb.com</span><br><span class="line">QueryType  : A</span><br><span class="line">TTL        : 0</span><br><span class="line">Section    : Answer</span><br><span class="line">IP4Address : 39.97.9.213</span><br></pre></td></tr></table></figure><p>对于上述 <code>Resolve-DnsName</code> 命令的输出的结果解释如下：</p><ol><li><p><strong>CNAME 记录：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a1.easemob.com                 CNAME  0     Answer     a1-v2.easemob.com.x.easeslb.com</span><br></pre></td></tr></table></figure><p>这一行表示 <code>a1.easemob.com</code> 是一个别名（CNAME）记录，指向了 <code>a1-v2.easemob.com.x.easeslb.com</code>。</p></li><li><p><strong>AAAA 记录（IPv6 地址）：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Name       : a1-v2.easemob.com.x.easeslb.com</span><br><span class="line">QueryType  : AAAA</span><br><span class="line">TTL        : 0</span><br><span class="line">Section    : Answer</span><br><span class="line">IP6Address : 2408:4000:200::17</span><br></pre></td></tr></table></figure><p>这一行表示 <code>a1-v2.easemob.com.x.easeslb.com</code> 对应的 IPv6 地址是 <code>2408:4000:200::17</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Name       : a1-v2.easemob.com.x.easeslb.com</span><br><span class="line">QueryType  : AAAA</span><br><span class="line">TTL        : 0</span><br><span class="line">Section    : Answer</span><br><span class="line">IP6Address : 2408:4000:200::c5</span><br></pre></td></tr></table></figure><p>这一行表示 <code>a1-v2.easemob.com.x.easeslb.com</code> 对应的另一个 IPv6 地址是 <code>2408:4000:200::c5</code>。</p></li><li><p><strong>A 记录（IPv4 地址）：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Name       : a1-v2.easemob.com.x.easeslb.com</span><br><span class="line">QueryType  : A</span><br><span class="line">TTL        : 0</span><br><span class="line">Section    : Answer</span><br><span class="line">IP4Address : 47.93.162.59</span><br></pre></td></tr></table></figure><p>这一行表示 <code>a1-v2.easemob.com.x.easeslb.com</code> 对应的 IPv4 地址是 <code>47.93.162.59</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Name       : a1-v2.easemob.com.x.easeslb.com</span><br><span class="line">QueryType  : A</span><br><span class="line">TTL        : 0</span><br><span class="line">Section    : Answer</span><br><span class="line">IP4Address : 39.97.9.213</span><br></pre></td></tr></table></figure><p>这一行表示 <code>a1-v2.easemob.com.x.easeslb.com</code> 对应的另一个 IPv4 地址是 <code>39.97.9.213</code>。</p></li></ol><p>综上所述，查询结果显示了域名 <code>a1.easemob.com</code> 的别名记录（CNAME）以及对应的IPv6和IPv4地址。IPv6地址有两个，分别是 <code>2408:4000:200::17</code> 和 <code>2408:4000:200::c5</code>，而IPv4地址有两个，分别是 <code>47.93.162.59</code> 和 <code>39.97.9.213</code>。</p><h1 id="再从linux环境下学点不一样的"><a href="#再从linux环境下学点不一样的" class="headerlink" title="再从linux环境下学点不一样的"></a>再从linux环境下学点不一样的</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ nslookup a1.easemob.com</span><br><span class="line">Server:         127.0.0.53</span><br><span class="line">Address:        127.0.0.53<span class="comment">#53</span></span><br><span class="line"></span><br><span class="line">Non-authoritative answer:</span><br><span class="line">a1.easemob.com  canonical name = a1-v2.easemob.com.x.easeslb.com.</span><br><span class="line">Name:   a1-v2.easemob.com.x.easeslb.com</span><br><span class="line">Address: 39.97.9.213</span><br><span class="line">Name:   a1-v2.easemob.com.x.easeslb.com</span><br><span class="line">Address: 47.93.162.59</span><br><span class="line">Name:   a1-v2.easemob.com.x.easeslb.com</span><br><span class="line">Address: 2408:4000:200::17</span><br><span class="line">Name:   a1-v2.easemob.com.x.easeslb.com</span><br><span class="line">Address: 2408:4000:200::c5</span><br></pre></td></tr></table></figure><p>在linux环境下使用基础命令，还在cmd环境下的输出结果类似，但是比<code>Resolve-DnsName</code>命令输出的结果要简陋许多，但是可以通过添加参数来扩展命令。</p><h2 id="type选项"><a href="#type选项" class="headerlink" title="type选项"></a>type选项</h2><p><code>nslookup</code> 命令中的 <code>type</code> 参数用于指定查询的记录类型，即你想要获取的特定 DNS 记录的类型。以下是一些常见的 <code>type</code> 参数及其解释：</p><ul><li><p><strong>A (Address Record):</strong><code>nslookup example.com type=A</code> 查询域名 <code>example.com</code> 的 IPv4 地址</p></li><li><p><strong>AAAA (IPv6 Address Record):</strong><code>nslookup example.com type=AAAA</code> 查询域名 <code>example.com</code> 的 IPv6 地址</p></li><li><p><strong>CNAME (Canonical Name Record):</strong><code>nslookup example.com type=CNAME</code> 查询域名 <code>example.com</code> 的别名记录</p></li><li><p><strong>MX (Mail Exchange Record):</strong><code>nslookup example.com type=MX</code> 查询域名 <code>example.com</code> 的邮件交换记录</p></li><li><p><strong>NS (Name Server Record):</strong><code>nslookup example.com type=NS</code> 查询域名 <code>example.com</code> 的域名服务器记录</p></li><li><p><strong>PTR (Pointer Record):</strong><code>nslookup 192.168.1.1 type=PTR</code> 查询 IP 地址 <code>192.168.1.1</code> 对应的域名</p></li><li><p><strong>SOA (Start of Authority Record):</strong><code>nslookup example.com type=SOA</code> 查询域名 <code>example.com</code> 的权威区域起始记录</p></li><li><p><strong>TXT (Text Record):</strong><code>nslookup example.com type=TXT</code> 查询域名 <code>example.com</code> 的文本记录</p></li><li><p><strong>SRV (Service Record):</strong><code>nslookup _ldap._tcp.example.com type=SRV</code> 查询服务记录，例如 LDAP 服务</p></li><li><p><strong>ANY (Any Record):</strong><code>nslookup example.com type=ANY</code>   查询域名 <code>example.com</code> 的所有记录类型</p></li></ul><p>这些是常见的 <code>type</code> 参数，可以根据需要选择合适的类型来获取特定类型的 DNS 记录信息。在命令中，<code>type</code> 参数通常是可选的，如果不指定，默认为 <code>A</code> 记录</p><h2 id="retry选项"><a href="#retry选项" class="headerlink" title="retry选项"></a>retry选项</h2><p>该参数用于设置在没有收到响应时的重试次数。如果发送的 DNS 查询请求没有得到响应，<code>nslookup</code> 将会尝试重新发送请求，次数由 <code>-retry</code> 指定</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nslookup -retry=3 example.com</span><br></pre></td></tr></table></figure><p>  这个示例中，<code>-retry=3</code> 表示设置重试次数为3次。如果第一次查询没有得到响应，<code>nslookup</code> 将尝试再次发送查询请求，最多重试3次</p><h2 id="timeout选项"><a href="#timeout选项" class="headerlink" title="timeout选项"></a>timeout选项</h2><p>该参数用于设置等待响应的超时时间，以秒为单位。如果在指定的超时时间内没有收到响应，<code>nslookup</code> 将认为查询失败</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nslookup -timeout=5 example.com</span><br></pre></td></tr></table></figure><p>  这个示例中，<code>-timeout=5</code> 表示设置超时时间为5秒。如果在5秒内没有收到查询响应，<code>nslookup</code> 将认为查询失败</p><h1 id="使用更强大的dig命令"><a href="#使用更强大的dig命令" class="headerlink" title="使用更强大的dig命令"></a>使用更强大的dig命令</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">$ dig a1.easemob.com</span><br><span class="line"></span><br><span class="line">; &lt;&lt;&gt;&gt; DiG 9.16.1-Ubuntu &lt;&lt;&gt;&gt; a1.easemob.com</span><br><span class="line">;; global options: +cmd</span><br><span class="line">;; Got answer:</span><br><span class="line">;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 1464</span><br><span class="line">;; flags: qr rd ra; QUERY: 1, ANSWER: 3, AUTHORITY: 0, ADDITIONAL: 1</span><br><span class="line"></span><br><span class="line">;; OPT PSEUDOSECTION:</span><br><span class="line">; EDNS: version: 0, flags:; udp: 65494</span><br><span class="line">;; QUESTION SECTION:</span><br><span class="line">;a1.easemob.com.                        IN      A</span><br><span class="line"></span><br><span class="line">;; ANSWER SECTION:</span><br><span class="line">a1.easemob.com.         0       IN      CNAME   a1-v2.easemob.com.x.easeslb.com.</span><br><span class="line">a1-v2.easemob.com.x.easeslb.com. 0 IN   A       47.93.162.59</span><br><span class="line">a1-v2.easemob.com.x.easeslb.com. 0 IN   A       39.97.9.213</span><br><span class="line"></span><br><span class="line">;; Query time: 0 msec</span><br><span class="line">;; SERVER: 127.0.0.53<span class="comment">#53(127.0.0.53)</span></span><br><span class="line">;; WHEN: 一 1月 29 21:53:40 CST 2024</span><br><span class="line">;; MSG SIZE  rcvd: 117</span><br></pre></td></tr></table></figure><p>上述 <code>dig</code> 命令对域名 <code>a1.easemob.com</code> 进行查询的输出结构的含义解释如下：</p><ol><li><p><strong>头部信息 (<code>HEADER</code> 部分):</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 1464</span><br></pre></td></tr></table></figure><ul><li><code>opcode</code>: 查询操作的类型，这里是 <code>QUERY</code> 表示标准查询。</li><li><code>status</code>: 查询的状态，<code>NOERROR</code> 表示没有错误。</li><li><code>id</code>: 查询的唯一标识符，这里是 1464。</li></ul></li><li><p><strong>标志部分 (<code>flags</code> 部分):</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">;; flags: qr rd ra; QUERY: 1, ANSWER: 3, AUTHORITY: 0, ADDITIONAL: 1</span><br></pre></td></tr></table></figure><ul><li><code>qr</code>: 查询响应标志位，这里是 <code>qr</code> 表示响应。</li><li><code>rd</code>: 递归查询标志位，这里是 <code>rd</code> 表示递归查询。</li><li><code>ra</code>: 递归可用标志位，这里是 <code>ra</code> 表示递归可用。</li><li><code>QUERY: 1</code>: 查询的问题部分包含1个查询。</li><li><code>ANSWER: 3</code>: 响应部分包含3个回答。</li><li><code>AUTHORITY: 0</code>: 授权部分不包含任何信息。</li><li><code>ADDITIONAL: 1</code>: 附加部分包含1个附加记录。</li></ul></li><li><p><strong>OPT PSEUDOSECTION 部分:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">; EDNS: version: 0, flags:; udp: 65494</span><br></pre></td></tr></table></figure><ul><li><code>EDNS</code>: 扩展域名系统 (Extended DNS) 的信息。</li><li><code>version: 0</code>: EDNS 的版本。</li><li><code>flags:;</code>: EDNS 标志，这里为空。</li><li><code>udp: 65494</code>: 用于 DNS 查询和响应的最大 UDP 数据包大小。</li></ul></li><li><p><strong>请求部分 (<code>QUESTION SECTION</code>):</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">;; QUESTION SECTION:</span><br><span class="line">;a1.easemob.com.                        IN      A</span><br></pre></td></tr></table></figure><ul><li>查询的问题部分，这里是查询域名 <code>a1.easemob.com</code> 的 <code>A</code> 记录。</li></ul></li><li><p><strong>应答部分 (<code>ANSWER SECTION</code>):</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">;; ANSWER SECTION:</span><br><span class="line">a1.easemob.com.         0       IN      CNAME   a1-v2.easemob.com.x.easeslb.com.</span><br><span class="line">a1-v2.easemob.com.x.easeslb.com. 0 IN   A       47.93.162.59</span><br><span class="line">a1-v2.easemob.com.x.easeslb.com. 0 IN   A       39.97.9.213</span><br></pre></td></tr></table></figure><ul><li>响应部分包含了查询的回答，这里包含了3个记录。</li><li><code>CNAME</code> 记录：<code>a1.easemob.com</code> 是一个别名，指向 <code>a1-v2.easemob.com.x.easeslb.com</code>。</li><li><code>A</code> 记录：<code>a1-v2.easemob.com.x.easeslb.com</code> 对应两个IPv4地址，分别是 <code>47.93.162.59</code> 和 <code>39.97.9.213</code>。</li></ul></li><li><p><strong>查询时间 (<code>Query time</code>):</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">;; Query time: 0 msec</span><br></pre></td></tr></table></figure><ul><li>响应的查询时间，这里是 0 毫秒。</li></ul></li><li><p><strong>DNS 服务器信息 (<code>SERVER</code> 和 <code>WHEN</code> 部分):</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">;; SERVER: 127.0.0.53#53(127.0.0.53)</span><br><span class="line">;; WHEN: 一 1月 29 21:53:40 CST 2024</span><br></pre></td></tr></table></figure><ul><li><code>SERVER</code>: 显示响应的 DNS 服务器的IP地址和端口号。</li><li><code>WHEN</code>: 显示响应的时间戳。</li></ul></li><li><p><strong>消息大小 (<code>MSG SIZE</code>):</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">;; MSG SIZE  rcvd: 117</span><br></pre></td></tr></table></figure><ul><li>响应消息的大小，这里是 117 字节。</li></ul></li></ol><p>综上所述，这个 <code>dig</code> 查询输出提供了关于域名 <code>a1.easemob.com</code> 的详细信息，包括查询问题、响应部分（包括 CNAME 和 A 记录）、查询时间、DNS 服务器信息以及响应消息的大小。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>使用 <code>nslookup</code> 命令可以用来查询域名对应的IP <code>nslookup a1.easemob.com</code></li><li>使用 <code>nslookup</code> 命令也可以用来查询IP对应的域名 <code>nslookup 8.8.8.8 -ty=PTR 1.1.1.1</code></li><li><code>nslookup</code> 是一个跨平台的命令，Windows(cmd)、Mac、Linux都可以使用</li><li>在PowerShell中等价的命令是 <code>Resolve-DnsName</code>，默认输出信息较为详细</li><li><code>dig</code> 命令也可用于查询域名的详细信息 <code>dig a1.easemob.com</code></li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/135734670" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>曾经沧海难为水，除却巫山不是云，可以被压缩的时间才是生活，不得不花费的时间只是为了活着~</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;这个命令出现在与运维同学沟通过程中，在此之前要是问我一个域名对应的服务器是IP地址是什么，我肯定优先想到的是 &lt;code&gt;ping&lt;/code&gt; 这个命令，这个命令确实可以在回复的信息中看到IP地址，但是不全面，有时一个域名对应不止一个IP地址，这时就要用到 nslookup 命令了，这也是在沟通中学到的新知识点。&lt;/p&gt;
    
    </summary>
    
      <category term="Network" scheme="http://AlbertGithubHome.github.io/blog/categories/Network/"/>
    
    
      <category term="linux" scheme="http://AlbertGithubHome.github.io/blog/tags/linux/"/>
    
      <category term="Tools" scheme="http://AlbertGithubHome.github.io/blog/tags/Tools/"/>
    
      <category term="nslookup" scheme="http://AlbertGithubHome.github.io/blog/tags/nslookup/"/>
    
  </entry>
  
  <entry>
    <title>一个golang小白使用vscode搭建Ununtu20.04下的go开发环境</title>
    <link href="http://AlbertGithubHome.github.io/blog/2024/01/21/%E4%B8%80%E4%B8%AAgolang%E5%B0%8F%E7%99%BD%E4%BD%BF%E7%94%A8vscode%E6%90%AD%E5%BB%BAgo%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"/>
    <id>http://AlbertGithubHome.github.io/blog/2024/01/21/一个golang小白使用vscode搭建go开发环境/</id>
    <published>2024-01-21T05:13:55.000Z</published>
    <updated>2024-04-29T14:46:14.847Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>先交代一下背景，距离正式接触golang这门语言已经有5年时间，平时偶尔也会用go写写工具和功能，但其实充其量就是语言小白，基本上就是按照教程配置好环境，按照需求写写逻辑，能跑起来就行了。golang随着这几年的变化，这门语言的变化还是非常大的，之前写过一篇<a href="https://blog.csdn.net/albertsh/article/details/113907051" target="_blank" rel="noopener">《Go环境配置时遇到的GOPATH路径以及包管理问题》</a>，可以看出之前配置的变量很像Java早期的配置环境，从1.11 版本之后go工程不必放到 <code>GOPATH</code> 路径中了，通过go.mod文件来标记并跟踪每个软件包的版本，灵活度大大提高，从此 <code>GOPATH</code> 概念逐渐淡化，在1.18版本新引入一个新功能<code>go.work</code>，它被设计为解决在同一工作空间中处理多个模块的问题，使得go工程的模块管理更加方便。</p><a id="more"></a><p>简单描述下我的开发环境，<code>Windows10</code> + <code>VSCode1.58.0</code> + <code>WLS1.0 - Ubuntu20.04</code>，平时工作都是在Ubuntu上，习惯了在Linux上的开发，所以即使是自己家的电脑也安装了子系统，就当成<code>Ubuntu</code> 来用就行了，Vscode安装在Windows上，直接连接到子系统上进行代码编写，以上是前提，本文的重点是在Ubuntu20.04系统上安装go的编译和运行环境。</p><h1 id="搭建go环境"><a href="#搭建go环境" class="headerlink" title="搭建go环境"></a>搭建go环境</h1><p>我选择的go版本是1.19，已经支持 <code>go.sum</code> 和 <code>go.work</code>，同时也为了和工作开发保持一致，没必要用太新的特性，现在的go包管理已经不想早期的Java，不再依赖 <code>GOPATH</code>，和 Python3.x 更像了，只管下载包然后在各自的工程目录下使用就行了，必要时需要指定使用库的版本。</p><h2 id="下载go安装包"><a href="#下载go安装包" class="headerlink" title="下载go安装包"></a>下载go安装包</h2><p>go语言的官网是 <a href="https://golang.google.cn/dl/" target="_blank" rel="noopener">https://golang.google.cn/dl/</a>，下载1.19版本的Linux包<a href="https://golang.google.cn/dl/go1.19.linux-amd64.tar.gz" target="_blank" rel="noopener">go1.19.linux-amd64.tar.gz</a>，这个网址通常下载很慢，可以改为go语言中文网<a href="https://studygolang.com/dl" target="_blank" rel="noopener">https://studygolang.com/dl</a>来下载1.19版本<a href="https://studygolang.com/dl/golang/go1.19.linux-amd64.tar.gz" target="_blank" rel="noopener">go1.19.linux-amd64.tar.gz</a></p><p>可以通过浏览器下载拷贝到指定位置，也可以通过<code>wget</code>命令下载</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">alberts@home-pc:~$ wget https://golang.google.cn/dl/go1.19.linux-amd64.tar.gz</span><br><span class="line">--2024-01-21 17:22:11--  https://golang.google.cn/dl/go1.19.linux-amd64.tar.gz</span><br><span class="line">Resolving golang.google.cn (golang.google.cn)... 203.208.50.34</span><br><span class="line">Connecting to golang.google.cn (golang.google.cn)|203.208.50.34|:443... connected.</span><br><span class="line">HTTP request sent, awaiting response... 302 Found</span><br><span class="line">Location: https://dl.google.com/go/go1.19.linux-amd64.tar.gz [following]</span><br><span class="line">--2024-01-21 17:22:12--  https://dl.google.com/go/go1.19.linux-amd64.tar.gz</span><br><span class="line">Resolving dl.google.com (dl.google.com)... 220.181.174.161, 2401:3800:4001:807::1001</span><br><span class="line">Connecting to dl.google.com (dl.google.com)|220.181.174.161|:443... connected.</span><br><span class="line">HTTP request sent, awaiting response... 200 OK</span><br><span class="line">Length: 148796421 (142M) [application/x-gzip]</span><br><span class="line">Saving to: ‘go1.19.linux-amd64.tar.gz’</span><br><span class="line"></span><br><span class="line">go1.19.linux-amd64.tar.gz      100%[==============================&gt;] 141.90M  3.62MB/s    <span class="keyword">in</span> 31s</span><br><span class="line"></span><br><span class="line">2024-01-21 17:22:43 (4.54 MB/s) - ‘go1.19.linux-amd64.tar.gz’ saved [148796421/148796421]</span><br></pre></td></tr></table></figure><h2 id="解压go压缩包完成安装"><a href="#解压go压缩包完成安装" class="headerlink" title="解压go压缩包完成安装"></a>解压go压缩包完成安装</h2><p>go的运行环境直接解压拷贝到指定位置就可以了，我把go解压安装到了 <code>/usr/local/go</code> 目录，解压之前也清理掉老的目录，如果之前没安装过，<code>rm</code>这条命令可以不使用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo su</span><br><span class="line">rm -rf /usr/<span class="built_in">local</span>/go</span><br><span class="line">tar -C /usr/<span class="built_in">local</span> -xzf go1.19.linux-amd64.tar.gz</span><br></pre></td></tr></table></figure><h2 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h2><p>这一步有点类似Windows中的修改注册表，我安装了新的程序，需要通知系统当使用 <code>go</code> 命令时需要去哪个目录下寻找可执行程序，具体操作如下</p><ul><li><p>使用vim编辑.bashrc文件</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alberts@home-pc:~$ vim ~/.bashrc</span><br></pre></td></tr></table></figure></li><li><p>到文件的末尾添加以下代码</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alberts@home-pc:~$ <span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:/usr/<span class="built_in">local</span>/go/bin</span><br></pre></td></tr></table></figure></li><li><p>重新加载配置文件</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alberts@home-pc:~$ <span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure></li><li><p>查看版本是否安装成功</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alberts@home-pc:~$ go version</span><br><span class="line">go version go1.19 linux/amd64</span><br></pre></td></tr></table></figure></li></ul><p>查看版本显示出 <code>go1.19 linux/amd64</code>, 至此go语言的基础开发环境就配置好了</p><h2 id="编写一个helloword程序"><a href="#编写一个helloword程序" class="headerlink" title="编写一个helloword程序"></a>编写一个helloword程序</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">alberts@home-pc:/mnt/g$ mkdir wlsworkspace</span><br><span class="line">alberts@home-pc:/mnt/g$ <span class="built_in">cd</span> wlsworkspace</span><br><span class="line">alberts@home-pc:/mnt/g/wlsworkspace$ mkdir hello</span><br><span class="line">alberts@home-pc:/mnt/g/wlsworkspace$ <span class="built_in">cd</span> hello/</span><br><span class="line">alberts@home-pc:/mnt/g/wlsworkspace/hello$ go mod init github.com/alberts/go/hello</span><br><span class="line">go: creating new go.mod: module github.com/alberts/go/hello</span><br><span class="line">alberts@home-pc:/mnt/g/wlsworkspace/hello$ touch hello.go</span><br><span class="line">alberts@home-pc:/mnt/g/wlsworkspace/hello$ ls</span><br><span class="line">go.mod  hello.go</span><br></pre></td></tr></table></figure><p>打开 <code>hello.go</code> 文件编写以下内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line">func <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">    fmt.Println(<span class="string">"Hello,World!"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>保存文件后使用 <code>go run</code> 命令运行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alberts@home-pc:/mnt/g/wlsworkspace/hello$ go run hello.go</span><br><span class="line">Hello,World!</span><br></pre></td></tr></table></figure><h1 id="安装VSCode插件"><a href="#安装VSCode插件" class="headerlink" title="安装VSCode插件"></a>安装VSCode插件</h1><h2 id="安装智能提示插件"><a href="#安装智能提示插件" class="headerlink" title="安装智能提示插件"></a>安装智能提示插件</h2><p>为了编写go代码方便，可以安装这个名为<code>Go</code>的插件，这个插件不是必须安装的，但是你在写go代码时VSCode会自动提示你安装这个插件，为了实现Go语法只能提醒，我们可以直接点击提示安装，或者在插件市场里搜索安装</p><p>go插件</p><p>插件安装完成后会提示下面的报错</p><blockquote><p>The “gopls” command is not available. Run “go get -v golang.org/x/tools/gopls” to install.</p></blockquote><p>说明安装这个插件需要依赖 <code>golang.org/x/tools/gopls</code> 这个包，我们可以根据提示安装</p><h2 id="安装go依赖包"><a href="#安装go依赖包" class="headerlink" title="安装go依赖包"></a>安装go依赖包</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alberts@home-pc:/mnt/g/wlsworkspace/hello$ go get -v golang.org/x/tools/gopls</span><br><span class="line">go: module golang.org/x/tools/gopls: Get <span class="string">"https://proxy.golang.org/golang.org/x/tools/gopls/@v/list"</span>: dial tcp 142.251.42.241:443: connect: connection refused</span><br></pre></td></tr></table></figure><p>直接安装通常会因无法下载而失败，需要修改代理来改变下载地址</p><h2 id="修改代理并重新安装依赖包"><a href="#修改代理并重新安装依赖包" class="headerlink" title="修改代理并重新安装依赖包"></a>修改代理并重新安装依赖包</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">alberts@home-pc:/mnt/g/wlsworkspace/hello$ go env -w GO111MODULE=on</span><br><span class="line">alberts@home-pc:/mnt/g/wlsworkspace/hello$ go env -w GOPROXY=https://goproxy.cn,direct</span><br><span class="line">alberts@home-pc:/mnt/g/wlsworkspace/hello$ go env -w GOSUMDB=<span class="string">"sum.golang.org"</span></span><br></pre></td></tr></table></figure><p>安装依赖包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">alberts@home-pc:/mnt/g/wlsworkspace/hello$ go get -v golang.org/x/tools/gopls</span><br><span class="line">go: downloading golang.org/x/tools v0.17.0</span><br><span class="line">go: downloading golang.org/x/tools/gopls v0.14.2</span><br><span class="line">go: downloading golang.org/x/tools v0.14.1-0.20231114185516-c9d3e7de13fd</span><br><span class="line">go: downloading golang.org/x/telemetry v0.0.0-20231114163143-69313e640400</span><br><span class="line">go: downloading github.com/sergi/go-diff v1.1.0</span><br><span class="line">go: downloading honnef.co/go/tools v0.4.5</span><br><span class="line">go: downloading mvdan.cc/gofumpt v0.4.0</span><br><span class="line">go: downloading mvdan.cc/xurls/v2 v2.4.0</span><br><span class="line">go: downloading golang.org/x/mod v0.14.0</span><br><span class="line">go: downloading golang.org/x/sync v0.4.0</span><br><span class="line">go: downloading golang.org/x/text v0.13.0</span><br><span class="line">go: downloading golang.org/x/exp/typeparams v0.0.0-20221212164502-fae10dda9338</span><br><span class="line">go: downloading golang.org/x/sys v0.14.0</span><br><span class="line">go: downloading golang.org/x/vuln v1.0.1</span><br><span class="line">go: downloading github.com/google/go-cmp v0.5.9</span><br><span class="line">go: downloading github.com/BurntSushi/toml v1.2.1</span><br><span class="line">go: added github.com/BurntSushi/toml v1.2.1</span><br><span class="line">go: added github.com/google/go-cmp v0.5.9</span><br><span class="line">go: added github.com/sergi/go-diff v1.1.0</span><br><span class="line">go: added golang.org/x/exp/typeparams v0.0.0-20221212164502-fae10dda9338</span><br><span class="line">go: added golang.org/x/mod v0.14.0</span><br><span class="line">go: added golang.org/x/sync v0.4.0</span><br><span class="line">go: added golang.org/x/sys v0.14.0</span><br><span class="line">go: added golang.org/x/telemetry v0.0.0-20231114163143-69313e640400</span><br><span class="line">go: added golang.org/x/text v0.13.0</span><br><span class="line">go: added golang.org/x/tools v0.14.1-0.20231114185516-c9d3e7de13fd</span><br><span class="line">go: added golang.org/x/tools/gopls v0.14.2</span><br><span class="line">go: added golang.org/x/vuln v1.0.1</span><br><span class="line">go: added honnef.co/go/tools v0.4.5</span><br><span class="line">go: added mvdan.cc/gofumpt v0.4.0</span><br><span class="line">go: added mvdan.cc/xurls/v2 v2.4.0</span><br></pre></td></tr></table></figure><p>这次安装成功了，这些依赖包默认安装到了 <code>~/go/pkg</code>目录下，使用时直接在go文件中引用就行了 <code>import golang.org/x/sys</code></p><p>以上这些包是Go语言的依赖管理工具，它们的作用如下：</p><ul><li>golang.org/x/tools: 提供了一系列用于开发Go语言的工具，如gopls等</li><li>golang.org/x/tools/gopls: 是一个基于Go语言的代码补全和导航工具，它可以帮助开发者更高效地编写和调试Go代码</li><li>golang.org/x/telemetry: 提供了一套用于收集和分析应用程序性能数据的库</li><li>github.com/sergi/go-diff: 是一个用于比较两个Go源代码文件差异的工具</li><li>honnef.co/go/tools: 提供了一些用于处理Go源代码的工具，如goimports（自动导入缺失的包）等</li><li>mvdan.cc/gofumpt: 是一个用于格式化Go源代码的工具，它可以自动调整代码格式以符合Go语言的最佳实践</li><li>mvdan.cc/xurls/v2: 是一个用于解析URL的库，它可以将URL分解为各个组成部分，方便开发者处理</li><li>golang.org/x/mod: 是一个用于管理Go模块的库，它可以帮助你更好地组织和管理项目的依赖关系</li><li>golang.org/x/sync: 提供了一组同步原语，如互斥锁、条件变量等，用于实现多线程编程中的同步机制</li><li>golang.org/x/text: 提供了一个用于处理Unicode文本的库，它可以帮助你更方便地处理和操作文本数据</li><li>golang.org/x/exp/typeparams: 提供了一个用于处理类型参数的库，它可以帮助你更方便地处理泛型编程中的类型参数问题</li><li>golang.org/x/sys: 提供了一个用于访问操作系统功能的库，它可以帮助你更方便地处理操作系统相关的任务</li><li>golang.org/x/vuln: 提供了一个用于管理已知安全漏洞的库，它可以帮助你更容易地识别和修复项目中的安全漏洞</li><li>github.com/stamblerre/gocode: 提供Go语言的代码自动补全功能，用于IDEs和编辑器</li><li>github.com/uudashr/gopkgs/v2/cmd/gopkgs: 命令行工具，帮助发现和使用Go语言软件包</li><li>github.com/ramya-rao-a/go-outline: VSCode插件，为Go源代码文件生成结构大纲以便于导航</li></ul><p>总结一下需要安装的依赖包</p><blockquote><p>go get -v golang.org/x/tools/gopls<br>go get -v github.com/stamblerre/gocode<br>go get -v github.com/uudashr/gopkgs/v2/cmd/gopkgs<br>go get -v github.com/ramya-rao-a/go-outline</p></blockquote><p>根据VSCode提示安装后续的Tools，得到的控制台输出信息如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Tools environment: GOPATH=/home/alberts/go</span><br><span class="line">Installing 6 tools at /home/alberts/go/bin <span class="keyword">in</span> module mode.</span><br><span class="line">  gopkgs</span><br><span class="line">  go-outline</span><br><span class="line">  dlv</span><br><span class="line">  dlv-dap</span><br><span class="line">  staticcheck</span><br><span class="line">  gopls</span><br><span class="line"></span><br><span class="line">Installing github.com/uudashr/gopkgs/v2/cmd/gopkgs (gopkgs) SUCCEEDED</span><br><span class="line">Installing github.com/ramya-rao<span class="_">-a</span>/go-outline (go-outline) SUCCEEDED</span><br><span class="line">Installing github.com/go-delve/delve/cmd/dlv (dlv) SUCCEEDED</span><br><span class="line">Installing github.com/go-delve/delve/cmd/dlv@master (/home/alberts/go/bin/dlv-dap) SUCCEEDED</span><br><span class="line">Installing honnef.co/go/tools/cmd/staticcheck (staticcheck) SUCCEEDED</span><br><span class="line">Installing golang.org/x/tools/gopls (gopls) SUCCEEDED</span><br><span class="line"></span><br><span class="line">All tools successfully installed. You are ready to Go :).</span><br></pre></td></tr></table></figure><h1 id="go-mod-和-go-work"><a href="#go-mod-和-go-work" class="headerlink" title="go.mod 和 go.work"></a>go.mod 和 go.work</h1><h2 id="go-mod"><a href="#go-mod" class="headerlink" title="go.mod"></a>go.mod</h2><p><strong>Go语言从1.11版本开始引入了Go Modules，这个版本之后不再需要将项目放到GOPATH中</strong>。</p><p>Go Modules是Go语言的依赖管理工具，它改变了之前必须使用GOPATH来管理依赖的模式。在Go 1.11及之后的版本中，通过go.mod文件来标记并跟踪每个软件包的版本，这意味着开发者可以在任何地方创建项目，而不必遵循GOPATH目录结构。</p><p>此外，Go团队还增加了一个环境变量<code>GO111MODULE</code>来控制模块支持的启用和禁用。这个环境变量的命名中的”111”象征着它是在Go 1.11版本中引入的。</p><p>总的来说，Go语言自1.11版本起，通过引入Go Modules，使得开发者不再受限于GOPATH，可以更加灵活地管理项目和依赖。这一变化被广泛认为是Go语言发展中的一个重大改进。</p><h2 id="go-work"><a href="#go-work" class="headerlink" title="go.work"></a>go.work</h2><p>“go.work” 是Go 1.18版本新引入的一个功能，它被设计为解决在同一工作空间中处理多个模块的问题。在之前的版本中，开发者常常会遇到路径问题、版本冲突问题等挑战。为了应对这些情况，他们可能需要对每个模块的go.mod文件进行手动修改，过程繁琐且容易出错。</p><p>“go.work”文件的主要作用就是来解决这些问题。它是一个特殊的文件，其中包含了use和replace指令，这些指令会覆盖工作区目录下的每个Go Module的go.mod文件中的内容。因此，开发者无需再对每个Go Module的go.mod文件进行手动修改，极大地简化了操作流程并提高了效率。</p><p>此外，”go.work”文件的优先级高于go.mod文件中的定义。也就是说，如果在go.work和go.mod中同时指定了不同的代码仓库路径，那么go.work中的设置将会被优先采用。这一特性进一步加强了”go.work”文件在依赖管理中的重要性。</p><h2 id="小试一下go-work"><a href="#小试一下go-work" class="headerlink" title="小试一下go.work"></a>小试一下go.work</h2><p>当前工作目录下有 <code>base</code> 和 <code>hello</code> 两个包含go.mod的工程，使用 <code>go work init</code> 命令可以初始化一个工作空间</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">alberts@home-pc:/mnt/g/wlsworkspace$ ls</span><br><span class="line">base  hello</span><br><span class="line">alberts@home-pc:/mnt/g/wlsworkspace$ go work init base hello</span><br><span class="line">alberts@home-pc:/mnt/g/wlsworkspace$ cat go.work</span><br><span class="line">go 1.19</span><br><span class="line"></span><br><span class="line">use (</span><br><span class="line">        ./base</span><br><span class="line">        ./hello</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>初始化之后工程之间就可以相互引用彼此对外的包内容了</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>下载go压缩包 <code>wget https://golang.google.cn/dl/go1.19.linux-amd64.tar.gz</code></li><li>初始化工程目录hello <code>go mod init github.com/alberts/go/hello</code>，包名通常是支持https访问的网络地址</li><li>初始化工作空间 <code>go work init base hello</code>，base 和 hello 都是包含go.mod文件的go工程</li><li>安装依赖包 <code>go get -v golang.org/x/tools/gopls</code></li><li>安装依赖包 <code>github.com/stamblerre/gocode</code></li><li>安装依赖包 <code>github.com/uudashr/gopkgs/v2/cmd/gopkgs</code></li><li>安装依赖包 <code>github.com/ramya-rao-a/go-outline</code></li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/135586502" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>放下助人情节，尊重他人命运~</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;先交代一下背景，距离正式接触golang这门语言已经有5年时间，平时偶尔也会用go写写工具和功能，但其实充其量就是语言小白，基本上就是按照教程配置好环境，按照需求写写逻辑，能跑起来就行了。golang随着这几年的变化，这门语言的变化还是非常大的，之前写过一篇&lt;a href=&quot;https://blog.csdn.net/albertsh/article/details/113907051&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《Go环境配置时遇到的GOPATH路径以及包管理问题》&lt;/a&gt;，可以看出之前配置的变量很像Java早期的配置环境，从1.11 版本之后go工程不必放到 &lt;code&gt;GOPATH&lt;/code&gt; 路径中了，通过go.mod文件来标记并跟踪每个软件包的版本，灵活度大大提高，从此 &lt;code&gt;GOPATH&lt;/code&gt; 概念逐渐淡化，在1.18版本新引入一个新功能&lt;code&gt;go.work&lt;/code&gt;，它被设计为解决在同一工作空间中处理多个模块的问题，使得go工程的模块管理更加方便。&lt;/p&gt;
    
    </summary>
    
      <category term="Go" scheme="http://AlbertGithubHome.github.io/blog/categories/Go/"/>
    
    
      <category term="Go" scheme="http://AlbertGithubHome.github.io/blog/tags/Go/"/>
    
      <category term="golang" scheme="http://AlbertGithubHome.github.io/blog/tags/golang/"/>
    
      <category term="vscode" scheme="http://AlbertGithubHome.github.io/blog/tags/vscode/"/>
    
      <category term="proxy" scheme="http://AlbertGithubHome.github.io/blog/tags/proxy/"/>
    
  </entry>
  
  <entry>
    <title>推荐一款通过ssh连接linux服务的开源工具WindTerm</title>
    <link href="http://AlbertGithubHome.github.io/blog/2024/01/14/%E6%8E%A8%E8%8D%90%E4%B8%80%E6%AC%BE%E9%80%9A%E8%BF%87ssh%E8%BF%9E%E6%8E%A5linux%E6%9C%8D%E5%8A%A1%E7%9A%84%E5%BC%80%E6%BA%90%E5%B7%A5%E5%85%B7WindTerm/"/>
    <id>http://AlbertGithubHome.github.io/blog/2024/01/14/推荐一款通过ssh连接linux服务的开源工具WindTerm/</id>
    <published>2024-01-14T11:39:08.000Z</published>
    <updated>2024-01-21T12:47:38.943Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>工作一入门便是游戏服务器开发，所以常常有连接Linux服务器的需求，之前用的最多的是Xshell，最近这个软件个人版只能免费使用一个月了，超过时间会提示更新无法正常使用，工作当中用的最多的是SecureCRT，不过这个软件是收费的，公司买了授权，可以正常用，但是在家时就不行了，最近我找到了WindTerm这个软件，用起来还不错，记录一下。</p><a id="more"></a><h1 id="WindTerm介绍"><a href="#WindTerm介绍" class="headerlink" title="WindTerm介绍"></a>WindTerm介绍</h1><blockquote><p>A Quicker and better SSH/Telnet/Serial/Shell/Sftp client for DevOps.</p></blockquote><p>WindTerm一款使用使用C语言开发的跨平台SSH客户端WindTerm，完全免费开源，软件包只有20多M，性能很好，Windows、Linux、Mac均提供程序包下载，免按照，下载解压即可使用，官方地址为 <a href="https://github.com/kingToolbox/WindTerm/releases" target="_blank" rel="noopener">https://github.com/kingToolbox/WindTerm/releases</a>，最新版本为2.6.0</p><p><img src="https://img-blog.csdnimg.cn/direct/675fda112cc34909909ad7647c3fce5e.png#pic_center" alt="windterm download">最近github访问又变慢了，如果你下载不下来，可以从这个平台地址下载<a href="https://download.csdn.net/download/shihengzhen101/88740938" target="_blank" rel="noopener">CSDN下载-WindTerm_2.6.0_Prerelease_7_Windows_Portable_x86_64.zip</a>，我已经设置成免积分了，方便有需要的人直接取用，简单罗列下它的功能。</p><ul><li>多平台支持Linux，Mac，Win，免安装解压即可使用</li><li>实施了 SSH v2、Telnet、Raw Tcp、串行、Shell 协议</li><li>会话认证时支持 SSH 自动执行</li><li>支持 SSH ProxyCommand 或 ProxyJump</li><li>支持SSH代理转发。</li><li>支持使用密码、公钥、键盘交互、gssapi-with-mic 的 SSH 自动登录</li><li>支持直接/本地端口转发、反向/远程端口转发和动态端口转发</li><li>支持 XModem、YModem 和 ZModem，可以使用rz、sz上传和下载文件</li><li>集成sftp、scp客户端，支持下载、上传、删除、重命名、新建文件/目录</li><li>集成本地文件管理器，支持移动到、复制到、复制自、删除、重命名、新建文件/目录</li><li>支持 Windows Cmd、PowerShell 和 Cmd、PowerShell 作为管理员</li><li>支持Linux bash、zsh、powershell core</li><li>支持 MacOS bash、zsh、powershell core</li><li>有较好的操作界面</li></ul><h1 id="WindTerm使用"><a href="#WindTerm使用" class="headerlink" title="WindTerm使用"></a>WindTerm使用</h1><p>下载WindTerm_2.6.0_Prerelease_7_Windows_Portable_x86_64.zip 后解压，双击WindTerm.exe即可打开软件，会弹出下面的界面，提示存储配置文件的地方，我就选择放到应用程序目录了</p><p><img src="https://img-blog.csdnimg.cn/direct/cdbbedbd143f4841bc4575ca9b6c37d4.png#pic_center" alt="windterm open"></p><p>直接通过【会话】-&gt;【新建会话】便可以建立连接Linux服务器的通道，这与之前用的软件都大同小异，基本没有差别，输入主机地址点击【连接】，后续再输入密码就可以开始连接了</p><p><img src="https://img-blog.csdnimg.cn/direct/f387f7832a1549bf93726ab773c611a6.png" alt="new session">如果是第一个使用的时候，会弹出下面这个界面，让自定义一个主密码，其实就是这个软件的使用密码，后续锁屏或者更新会话信息时会用到。</p><p><img src="https://img-blog.csdnimg.cn/direct/a22b701407c24290be4b440aa906d879.png#pic_center" alt="main password"></p><p>因为我是自己在家使用，我就不设置主密码了，直接点击OK完成，后面会让输入Linux账户和密码，到这一步相信大家都会用了。</p><h1 id="主密码和锁屏"><a href="#主密码和锁屏" class="headerlink" title="主密码和锁屏"></a>主密码和锁屏</h1><p>这个问题我也是查了一些资料才解决的，因为我没有输入主密码，所以每次锁屏时我只要回车就可以了，如果想修改锁屏时间，在【会话】-&gt;【首选项】-&gt;【设置】中可以找到</p><p><img src="https://img-blog.csdnimg.cn/direct/e143aec960c4491fb4fcc22d14ca502a.png#pic_center" alt="windterm setting"><br>也可以直接通过配置文件修改，找到刚启动软件时你选择的目录 <code>D:\app\WindTerm_2.6.0\.wind\profiles\default.v10</code>，直接修改配置文件内容，通过字段名也很清楚要改哪些值</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"application.fingerprint"</span> : <span class="string">"c5QR13M1iEkNPGlVNjDBWadi1uS0PiXR4Y+79cp09PAXr7G6WQxg/7WFj9RJ9dIsKKOWqm5Xq2N6w5Jx4v2mTw=="</span>,</span><br><span class="line">    <span class="attr">"application.language"</span> : <span class="string">"zh-CN"</span>,</span><br><span class="line">    <span class="attr">"application.lockScreenTimeout"</span> : <span class="number">1</span>,</span><br><span class="line">    <span class="attr">"application.masterPassword"</span> : <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">"terminal.loginWizard.defaultAuthType"</span> : <span class="string">"Account"</span>,</span><br><span class="line">    <span class="attr">"terminal.reimportShellSessions"</span> : <span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>application.lockScreenTimeout</code>：是控制锁屏时间的</li><li><code>application.masterPassword</code>：是代表是否有主密码的</li></ul><p>整个页面布局和配色还是挺漂亮的，不喜欢可以自己调整的哈</p><p><img src="https://img-blog.csdnimg.cn/direct/ea41dd99bf6b430ba5023eb358cd5752.png#pic_center" alt="windterm shell"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>WindTerm是一款可以通过ssh连接Linux服务器的客户端工具</li><li>WindTerm免费开源，支持Windows、Linux、Mac系统，无需安装，解压即可使用</li><li>WindTerm集成sftp、scp客户端，支持下载、上传、删除、重命名、新建文件/目录</li><li>WindTerm默认需要指定一个主密码，相当于验证使用者身份的功能，当然也可以为空</li><li>WindTerm的锁屏时间可以通过首选项菜单设置，也可通过配置修改</li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/135315104" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>人生就是一本账，欠下的东西总要还的，茫茫人生路之后，你是想在历史长河中留下一笔，还是“隐藏”的毫无痕迹呢？</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;工作一入门便是游戏服务器开发，所以常常有连接Linux服务器的需求，之前用的最多的是Xshell，最近这个软件个人版只能免费使用一个月了，超过时间会提示更新无法正常使用，工作当中用的最多的是SecureCRT，不过这个软件是收费的，公司买了授权，可以正常用，但是在家时就不行了，最近我找到了WindTerm这个软件，用起来还不错，记录一下。&lt;/p&gt;
    
    </summary>
    
      <category term="linux" scheme="http://AlbertGithubHome.github.io/blog/categories/linux/"/>
    
    
      <category term="ssh" scheme="http://AlbertGithubHome.github.io/blog/tags/ssh/"/>
    
      <category term="linux" scheme="http://AlbertGithubHome.github.io/blog/tags/linux/"/>
    
      <category term="运维" scheme="http://AlbertGithubHome.github.io/blog/tags/%E8%BF%90%E7%BB%B4/"/>
    
      <category term="windterm" scheme="http://AlbertGithubHome.github.io/blog/tags/windterm/"/>
    
      <category term="免安装" scheme="http://AlbertGithubHome.github.io/blog/tags/%E5%85%8D%E5%AE%89%E8%A3%85/"/>
    
  </entry>
  
</feed>
