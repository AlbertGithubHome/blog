<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Albert World</title>
  <icon>https://www.gravatar.com/avatar/8ccc6291d5bfd34e7aaf601c4ebec7e1</icon>
  
  <link href="/blog/atom.xml" rel="self"/>
  
  <link href="http://AlbertGithubHome.github.io/blog/"/>
  <updated>2020-07-11T07:54:07.068Z</updated>
  <id>http://AlbertGithubHome.github.io/blog/</id>
  
  <author>
    <name>Albert Shi</name>
    <email>347070901@qq.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Shell脚本中获取命令运行结果、特殊变量使用、条件判断等常用操作</title>
    <link href="http://AlbertGithubHome.github.io/blog/2020/07/07/Shell%E8%84%9A%E6%9C%AC%E4%B8%AD%E8%8E%B7%E5%8F%96%E5%91%BD%E4%BB%A4%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C%E3%80%81%E6%9D%A1%E4%BB%B6%E5%88%A4%E6%96%AD%E7%AD%89%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/"/>
    <id>http://AlbertGithubHome.github.io/blog/2020/07/07/Shell脚本中获取命令运行结果、条件判断等常用操作/</id>
    <published>2020-07-07T15:27:09.000Z</published>
    <updated>2020-07-11T07:54:07.068Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近在处理一个 <code>Python</code> 局部变量的作用域问题时发现有些奇怪，想起了之前常写的 <code>Lua</code> 脚本，于是想写个函数测试一下，结果发现短短的十几行代码出现了多个错误，这可是我写了近三年的代码啊，才放下半年就记不清了，所以知识这个东西还是要不断“温故”，今天要总结的 <code>Shell</code> 脚本命令也是，基本属于一看就会，一写不对的状态，所以还是要把常用的操作总结到一起，方便查找和复习。</p><a id="more"></a><h1 id="获取命令执行结果"><a href="#获取命令执行结果" class="headerlink" title="获取命令执行结果"></a>获取命令执行结果</h1><p>脚本中常常要获取一些命令的执行结果，比如当前目录 <code>pwd</code>、当前时间 <code>date</code> 等等，如果在控制台时直接输入后回车就能看到结果，但是在 <code>Shell</code> 脚本中却不能这样做，常见的有以下两种方式。</p><h2 id="使用反引号-command-来执行命令"><a href="#使用反引号-command-来执行命令" class="headerlink" title="使用反引号 `command `来执行命令"></a>使用反引号 <code>`</code>command <code>`</code>来执行命令</h2><p>反引号就是键盘上 <code>Tab</code> 键上方的那个按键对应的符号，常写 Markdown 的小伙伴知道这个符号就是包裹代码块的那个符号，在 <code>Shell</code> 脚本中被用来执行命令得到结果，举个简单的例子</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">result=date</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$result</span></span><br><span class="line"></span><br><span class="line">result=`date`</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$result</span></span><br></pre></td></tr></table></figure><p>将上述命令保存到文件 <code>cmd.sh</code> 中运行 <code>./cmd.sh</code> 得到结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ./cmd.sh</span><br><span class="line">date</span><br><span class="line">Tue Jul 7 23:48:03 CST 2020</span><br></pre></td></tr></table></figure><p>从运行结果可以看出，如果不加反引号，我们常用的这些命令会被当成普通的字符串处理。</p><h2 id="使用括号组合-command-来执行命令"><a href="#使用括号组合-command-来执行命令" class="headerlink" title="使用括号组合 $(command) 来执行命令"></a>使用括号组合 $(command) 来执行命令</h2><p>除了上面的反引号，使用美元符和小括号组合也可以在 Shell 脚本中运行命令，使用同样的例子测试</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">result=`date`</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$result</span></span><br><span class="line"></span><br><span class="line">result=$(date)</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$result</span></span><br></pre></td></tr></table></figure><p>保存到文件 <code>cmd.sh</code> 中运行 <code>./cmd.sh</code> 得到结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ./cmd.sh</span><br><span class="line">Tue Jul 7 23:53:27 CST 2020</span><br><span class="line">Tue Jul 7 23:53:27 CST 2020</span><br></pre></td></tr></table></figure><p>对比可以看出两种方式在这个命令下运行结果是一样的。</p><h2 id="两种方式的区别"><a href="#两种方式的区别" class="headerlink" title="两种方式的区别"></a>两种方式的区别</h2><p>虽然上述两种方式都可以在 <code>Shell</code> 脚本中得到命令运行的结果，但是有一点是不一样的，那就是反引号执行命令不支持嵌套，不能实现反引号中再出现反引号，而 <code>$(command)</code>的方式是支持嵌套的，关于这一点可以看下面这个例子。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> $(ls $(<span class="built_in">pwd</span>))</span><br><span class="line">cmd.sh</span><br></pre></td></tr></table></figure><p>分析一下这个命令 <code>echo $(ls $(pwd))</code>，最里面的命令是 <code>$(pwd)</code>先执行得到当前目录，然后执行命令 <code>$(ls 当前目录)</code>得到目录下的文件，再通过 <code>echo</code> 命令把这个结果输出，就得到了 <code>cmd.sh</code> 这个文件名，因为我这个目录下只有这一个文件。</p><p>系统的命令使用反引号的方式改写就不生效了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> `ls `<span class="built_in">pwd</span>``</span><br><span class="line">cmd.shpwd</span><br></pre></td></tr></table></figure><p>我们还是仿照上面嵌套来写，但是 <code>echo</code> 后面的内容其实被分成了3部分，一个<code>ls</code>命令，一个<code>pwd</code>字符串、一个空命令，这样就能解释运行结果 <code>cmd.shpwd</code>了。</p><p>对照着结果我们就可以知道了， <code>$(command)</code>的方式更加强大，可以支持命令的嵌套，应用更广泛一点，而反引号的方式跟多出现在之前的脚本中。</p><h1 id="特殊变量使用"><a href="#特殊变量使用" class="headerlink" title="特殊变量使用"></a>特殊变量使用</h1><p>从学习语言的第一天起就记住了变量名中只能有数字、字母、下划线，并且数字不能打头（Shell中只能字母开头），但是在 <code>Shell</code> 脚本中有一些特殊的变量，包含各种奇奇怪怪的符号。</p><h2 id="0-1-2-…"><a href="#0-1-2-…" class="headerlink" title="$0 $1 $2 …"></a>$0 $1 $2 …</h2><p>这些是运行 <code>Shell</code> 脚本时传递给脚本的命令行参数。命令行参数用 $n 表示，$0表示当前脚本的文件名，$1 表示第一个参数，$2 表示第二个参数，依次类推，可以类比 Windows 下的 <code>%0</code>、<code>%1</code>、<code>%2</code>…</p><h2 id=""><a href="#" class="headerlink" title="$$"></a>$$</h2><p>当前 <code>Shell</code> 脚本的进程ID。如果在命令行执行得到的是当前 <code>bash</code> 的进程ID，如果放到脚本中，得到的是脚本的进程ID。</p><h2 id="-1"><a href="#-1" class="headerlink" title="$?"></a>$?</h2><p>可以获取上一个命令执行后的返回结果。</p><h2 id="-2"><a href="#-2" class="headerlink" title="$"></a>$</h2><p>传递给脚本的命令行参数的个数。</p><h2 id="-3"><a href="#-3" class="headerlink" title="$*"></a>$*</h2><p>传递给脚本的命令行参数的所有参数。</p><h2 id="-4"><a href="#-4" class="headerlink" title="$@"></a>$@</h2><p>传递给脚本的命令行参数的所有参数，与 <code>$*</code> 稍有不同。</p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>写个脚本测试一下，新建 <code>cmdargs.sh</code> 文件，编写下面代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> \<span class="variable">$0</span> is <span class="variable">$0</span></span><br><span class="line"><span class="built_in">echo</span> \<span class="variable">$1</span> is <span class="variable">$1</span></span><br><span class="line"><span class="built_in">echo</span> \<span class="variable">$2</span> is <span class="variable">$2</span></span><br><span class="line"><span class="built_in">echo</span> \$$ is $$</span><br><span class="line"><span class="built_in">echo</span> \<span class="variable">$#</span> is <span class="variable">$#</span></span><br><span class="line"><span class="built_in">echo</span> \$* is $*</span><br><span class="line"><span class="built_in">echo</span> \<span class="variable">$@</span> is <span class="variable">$@</span></span><br></pre></td></tr></table></figure><p>先执行 <code>./cmdargs.sh</code> 脚本， 然后输出 <code>$?</code> 脚本的退出状态，运行结果如下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ ./cmdargs.sh I love my daughter</span><br><span class="line"><span class="variable">$0</span> is ./cmdargs.sh</span><br><span class="line"><span class="variable">$1</span> is I</span><br><span class="line"><span class="variable">$2</span> is love</span><br><span class="line">$$ is 197</span><br><span class="line"><span class="variable">$#</span> is 4</span><br><span class="line">$* is I love my daughter</span><br><span class="line"><span class="variable">$@</span> is I love my daughter</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">echo</span> $?</span><br><span class="line">0</span><br></pre></td></tr></table></figure><h2 id="和-的区别"><a href="#和-的区别" class="headerlink" title="$* 和 $@ 的区别"></a><code>$*</code> 和 <code>$@</code> 的区别</h2><p>对照这个源码和输出结果，这些特殊变量应该可以分清楚了，其中 <code>$*</code> 和 <code>$@</code> 都是把所有内容都列出来了，但它俩还是有点区别的，当这两个变量都被双引号包裹时，通过 <code>for</code> 循环会得到不同结果，写个脚本 <code>cmdargs2.sh</code> 试一下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"test for \"\$*\""</span></span><br><span class="line"><span class="keyword">for</span> var <span class="keyword">in</span> <span class="string">"$*"</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"<span class="variable">$var</span>"</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"test for \"\$@\""</span></span><br><span class="line"><span class="keyword">for</span> var <span class="keyword">in</span> <span class="string">"<span class="variable">$@</span>"</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"<span class="variable">$var</span>"</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>运行结果如下, <code>&quot;$*&quot;</code>把所有的参数当成了一个整体，而 <code>&quot;$@&quot;</code> 把各个参数都拆分开了，可以通过循环依次打印出来。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ ./cmdargs2.sh I love my daughter</span><br><span class="line"><span class="built_in">test</span> <span class="keyword">for</span> <span class="string">"$*"</span></span><br><span class="line">I love my daughter</span><br><span class="line"><span class="built_in">test</span> <span class="keyword">for</span> <span class="string">"<span class="variable">$@</span>"</span></span><br><span class="line">I</span><br><span class="line">love</span><br><span class="line">my</span><br><span class="line">daughter</span><br></pre></td></tr></table></figure><h1 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h1><p>说起条件判断第一反应就是 <code>if</code> 了，在 <code>Shell</code> 脚本中也有 <code>if</code> 语句，同样是条件判断的中坚力量，先来看看 <code>if</code> 语句的写法：</p><h2 id="if-语句格式"><a href="#if-语句格式" class="headerlink" title="if 语句格式"></a><code>if</code> 语句格式</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ -d <span class="variable">$filename</span> ]; <span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"this is a directory."</span></span><br><span class="line"><span class="keyword">elif</span> [ -a <span class="variable">$filename</span> ]; <span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"the file is exist."</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"the file is not exist."</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p>直接提供一个最复杂的情况，如果不需要 <code>elif</code> 或者 <code>else</code> 分支，直接删掉就可以，但是 <code>if</code>、<code>then</code>、<code>fi</code> 这些都是必须的，并且中括号里面的表达式与中括号之间都要有空格，如果挨着写会报错的。</p><h2 id="中括号-的作用"><a href="#中括号-的作用" class="headerlink" title="中括号 [] 的作用"></a>中括号 <code>[]</code> 的作用</h2><p>一度认为 <code>if</code> 条件语句就是这样写，中括号 <code>[]</code> 应该是语法的一部分，但是查询后发现这居然是一个命令，和 <code>ls</code>，<code>pwd</code> 一样是一个可以执行命令，放在 <code>if</code> 条件判断时基本等同于 <code>test</code> 命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">which</span> [</span><br><span class="line">/usr/bin/[</span><br><span class="line">$ <span class="built_in">which</span> <span class="built_in">test</span></span><br><span class="line">/usr/bin/<span class="built_in">test</span></span><br></pre></td></tr></table></figure><p>看着这个查询结果感觉神奇吧，此外还有一个 <code>[[]]</code> 双中括号的操作，这个就不是命令了，而是 <code>Shell</code> 的一个关键字，比 <code>[]</code> 要强大的多。</p><h2 id="具体条件"><a href="#具体条件" class="headerlink" title="具体条件"></a>具体条件</h2><p><code>Shell</code> 脚本最常见的条件就是文件判断，数字判断和字符串判断了，接下来列举一下这些判断的常见写法。</p><h3 id="文件判断"><a href="#文件判断" class="headerlink" title="文件判断"></a>文件判断</h3><table><thead><tr><th style="text-align:center">命令</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">-a $filename</td><td style="text-align:center">文件存在时为真</td></tr><tr><td style="text-align:center">-d $filename</td><td style="text-align:center">文件名对应的是目录时为真</td></tr><tr><td style="text-align:center">-s $filename</td><td style="text-align:center">文件非空时为真</td></tr><tr><td style="text-align:center">-r $filename</td><td style="text-align:center">文件可读时为真</td></tr><tr><td style="text-align:center">-w $filename</td><td style="text-align:center">文件可写时为真</td></tr><tr><td style="text-align:center">-x $filename</td><td style="text-align:center">文件可执行时为真</td></tr></tbody></table><h3 id="数字判断"><a href="#数字判断" class="headerlink" title="数字判断"></a>数字判断</h3><table><thead><tr><th style="text-align:center">命令</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">n1 -eq n2</td><td style="text-align:center">n1等于n2时为真</td></tr><tr><td style="text-align:center">n1 -ne n2</td><td style="text-align:center">n1不等n2时为真</td></tr><tr><td style="text-align:center">n1 -gt n2</td><td style="text-align:center">n1大于n2时为真</td></tr><tr><td style="text-align:center">n1 -lt n2</td><td style="text-align:center">n1小于n2时为真</td></tr><tr><td style="text-align:center">n1 -ge n2</td><td style="text-align:center">n1大于等于n2时为真</td></tr><tr><td style="text-align:center">n1 -le n2</td><td style="text-align:center">n1小于等于n2时为真</td></tr></tbody></table><h3 id="字符串判断"><a href="#字符串判断" class="headerlink" title="字符串判断"></a>字符串判断</h3><table><thead><tr><th style="text-align:center">命令</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">-n str1</td><td style="text-align:center">str1字符串不为空串时值为真</td></tr><tr><td style="text-align:center">-z str1</td><td style="text-align:center">str1字符串为空串时值为真</td></tr><tr><td style="text-align:center">str1 == str2</td><td style="text-align:center">str1与str2相等时为真</td></tr><tr><td style="text-align:center">str1 != str2</td><td style="text-align:center">str1与str2不等时为真</td></tr><tr><td style="text-align:center">str1 &gt; str2</td><td style="text-align:center">按字典序str1排在str2后面时为真</td></tr><tr><td style="text-align:center">str1 &lt; str2</td><td style="text-align:center">按字典序str1排在str2前面时为真</td></tr></tbody></table><h3 id="数字判断特殊写法"><a href="#数字判断特殊写法" class="headerlink" title="数字判断特殊写法"></a>数字判断特殊写法</h3><table><thead><tr><th style="text-align:center">命令</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center"><code>((&quot;$n1&quot; == &quot;$n2&quot;))</code></td><td style="text-align:center">n1等于n2时为真</td></tr><tr><td style="text-align:center"><code>((&quot;$n1&quot; != &quot;$n2&quot;))</code></td><td style="text-align:center">n1不等n2时为真</td></tr><tr><td style="text-align:center"><code>((&quot;$n1&quot; &gt; &quot;$n2&quot;))</code></td><td style="text-align:center">n1大于n2时为真</td></tr><tr><td style="text-align:center"><code>((&quot;$n1&quot; &lt; &quot;$n2&quot;))</code></td><td style="text-align:center">n1小于n2时为真</td></tr><tr><td style="text-align:center"><code>((&quot;$n1&quot; &gt;= &quot;$n2&quot;))</code></td><td style="text-align:center">n1大于等于n2时为真</td></tr><tr><td style="text-align:center"><code>((&quot;$n1&quot; &lt;= &quot;$n2&quot;))</code></td><td style="text-align:center">n1小于等于n2时为真</td></tr></tbody></table><h3 id="逻辑关系运算符"><a href="#逻辑关系运算符" class="headerlink" title="逻辑关系运算符"></a>逻辑关系运算符</h3><table><thead><tr><th style="text-align:center">命令</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">-a</td><td style="text-align:center">与操作，用于<code>[]</code> 和 <code>test</code> 操作符</td></tr><tr><td style="text-align:center">-o</td><td style="text-align:center">或操作，用于<code>[]</code> 和 <code>test</code> 操作符</td></tr><tr><td style="text-align:center">！</td><td style="text-align:center">取反操作，用于<code>[]</code> 、 <code>test</code> 操作符 和 <code>[[]]</code> 关键字</td></tr><tr><td style="text-align:center">&amp;&amp;</td><td style="text-align:center">与操作，用于<code>[[]]</code> 关键字</td></tr><tr><td style="text-align:center">\</td><td style="text-align:center">\</td><td></td><td>或操作，用于<code>[[]]</code> 关键字</td></tr></tbody></table><p>这些逻辑写法千奇百怪的，写两个例子就慢慢就慢慢理解了，比如判断一个字符串不为空，并且这个字符串指定的目录还存在就可以写成</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ -n <span class="string">"<span class="variable">$1</span>"</span> -a -d <span class="string">"<span class="variable">$1</span>"</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$1</span> directory is exist</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p>使用双小括号来比较数值变量，写在双小括号中的变量前面可以不加 <code>$</code> 符号，还有诸多特权等着你去发现</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">num1=<span class="variable">$1</span></span><br><span class="line">num2=<span class="variable">$2</span></span><br><span class="line"><span class="keyword">if</span> (( num1 &gt; num2)); <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> num1 \&gt; num2</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p>总之在学习这些条件比较的时候踩了不少坑，有很多情况都没有注意到，不过慢慢也适应了这种语法，但还是免不了会出现一个小问题，这里提供一个 <code>Shell</code> 语法检查的在线网站 <a href="https://www.shellcheck.net/" target="_blank" rel="noopener">《shellcheck》</a>，将要检查的脚本放到页面上检测，会给出详细的错误信息，当然也有命令版本，可以自己到对应的 github 页面上下载哦~</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li><code>Shell</code> 脚本中获取命令的执行结果，可以通过反引号<code>`</code>command<code>`</code>，或者小括号 <code>$(command)</code> 的方式得到</li><li><code>Shell</code> 脚本中有一系列 <code>$</code> 开头的变量，用好他们是脚本和函数传递参数的关键</li><li><code>Shell</code> 脚本中的条件判断对于初学者来说很头大，有许多注意的点要记住，判断形式也多种多样</li><li>脚本中有单引号、双引号、反引号，简单来记就是单引号中原样输出，双引号中变量求值后输出，反引号中只能写需要执行的命令</li><li>脚本中还要中括号、双中括号、小括号、双小括号等，上面都提到过，可以自己练习下，具体的细节怕是要单独总结了，放到一起太多了</li><li>脚本的中的分号起到语句结束的作用，如果有换行就不需要分号了，比如 <code>if</code> 条件后面的 <code>then</code> 如果换行，那么 <code>then</code> 前面的分号可以省略</li><li>再记住一个坑，脚本赋值等号两端不能有空格，脚本判断等号两端必须有空格</li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/107147803" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>有些局，选择不入便立于不败之地，选择介入，即使曾身经百战，也恐难全身而退，更不要谈什么收益了~</p></blockquote><hr><blockquote><p>2020-7-11 00:30:00</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;最近在处理一个 &lt;code&gt;Python&lt;/code&gt; 局部变量的作用域问题时发现有些奇怪，想起了之前常写的 &lt;code&gt;Lua&lt;/code&gt; 脚本，于是想写个函数测试一下，结果发现短短的十几行代码出现了多个错误，这可是我写了近三年的代码啊，才放下半年就记不清了，所以知识这个东西还是要不断“温故”，今天要总结的 &lt;code&gt;Shell&lt;/code&gt; 脚本命令也是，基本属于一看就会，一写不对的状态，所以还是要把常用的操作总结到一起，方便查找和复习。&lt;/p&gt;
    
    </summary>
    
      <category term="shell" scheme="http://AlbertGithubHome.github.io/blog/categories/shell/"/>
    
    
      <category term="if" scheme="http://AlbertGithubHome.github.io/blog/tags/if/"/>
    
      <category term="Shell" scheme="http://AlbertGithubHome.github.io/blog/tags/Shell/"/>
    
      <category term="command" scheme="http://AlbertGithubHome.github.io/blog/tags/command/"/>
    
  </entry>
  
  <entry>
    <title>根证书的应用和信任基础</title>
    <link href="http://AlbertGithubHome.github.io/blog/2020/07/06/%E6%A0%B9%E8%AF%81%E4%B9%A6%E7%9A%84%E5%BA%94%E7%94%A8%E5%92%8C%E4%BF%A1%E4%BB%BB%E5%9F%BA%E7%A1%80/"/>
    <id>http://AlbertGithubHome.github.io/blog/2020/07/06/根证书的应用和信任基础/</id>
    <published>2020-07-06T14:54:28.000Z</published>
    <updated>2020-07-11T07:54:29.538Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>人生在世总要相信点什么，信亲人、信朋友、信你面前的陌生人，即便这些你都不信，也要信自己吧，假如连自己都不信了，那在地球上恐怕很难生存了。</p><a id="more"></a><p>我们把钱存入银行，因为我们相信当我们需要用钱时可以通过银行卡把钱取出来；我们拿着车票准时来到候车大厅，因为我们相信除非特殊情况，我们买的那趟车绝不会提前丢下我们而去；遇到纠纷我们会选择打官司，因为我们相信法官最后会给我们公正的判决结果。</p><p>生活中我们信任自己的经验，信任自己的亲人朋友，并依赖这些信任来做许多事情，这些信任是我们正常生活学习的前提，缺了这些我们将寸步难行。而在网络中我们同样需要信任，这些信任是筑造网络社会的基石。</p><p>有些信任是有条件的，比如银行贷款时不能通过空口白话就借来白花花的银子，而抵押物是贷款银行为了相信你附加的筹码；有些信任是无条件的，比如前面一篇总结 <a href="https://blog.csdn.net/albertsh/article/details/106754135" target="_blank" rel="noopener">《认证、HTTPS、证书的基本含义》</a>中提到的根证书，我们必须无条件信任，否则我们将置身于网络猜疑的海洋之中，无法正常利用网络带给我们的便利。</p><h1 id="信任链"><a href="#信任链" class="headerlink" title="信任链"></a>信任链</h1><p>我们常听说 <code>HTTPS</code> 更加安全，它是通过非对称加密技术，让我们可以在不确定的网络环境中可以确认对方的身份，安全传输密钥，但这一切都是有前提的，你得相信你的操作环境是安全的，你没有被人监控，你的电脑没有被人控制，你的数据没有被人篡改，抛开环境谈安全都是耍流氓~</p><p>好了，我们可以回顾一下，要想验证一个网站的身份，我们需要得到网站的公钥，如果可以解开网站拿私钥加密的消息，我们就证明了网站的身份，而网站的公钥不能由网站直接发给我们，需要找权威机构给它证明，相当于找了个担保人。</p><p>权威机构会用自己的私钥把网站的信息和公钥合在一起生成证书，当我们访问网站时首先得到这个证书，然后用权威机构的公钥来解开证书内容，得到网站的信息和网站的公钥，然后进行信息比对和公钥解密来认证身份，这时我们需要思考，权威机构的公钥从哪里来？</p><p>权威机构可以找更加权威的机构按照相同的方式给它做证书，这样一环一环的就走下去，形成了信任链，然后就无穷无尽了，一个权威机构给另一个权威机构证明，我可以玩到天荒地老，到底什么时候是个头啊，其实我们可以人为的确定一个，那就是根证书，他不需要找别的人给它证明，如果一个网站证书最终信任链顶端是有效的根证书，那么网站身份被确认。</p><h1 id="根证书"><a href="#根证书" class="headerlink" title="根证书"></a>根证书</h1><p>接下来看看根证书在哪呢？它内置在我们的浏览器（Firefox）和操作系统中，我们需要无条件的信任，从理论上讲没办法判断根证书的真假，它是自证清白的。这里需要注意，根证书不止有一个，它可以有很多个，“根”只是说明信任链到此为止，整条信任链上的节点都是“可信”的。所以说还是不要随意安装根证书，因为有了它就可以在你的电脑为所欲为。</p><p>说到这里有些人会想，根证书内置在操作系统和浏览器（Firefox）中，如果我下载一个被恶意修改的浏览器岂不是危险了，这种担心是有必要的，所以请尽量在正规网站下载，可是怎么证明哪些网站是正规网站呢？可以使用系统自带的根证书判断。</p><p>如果我的系统是盗版系统，根证书被人改过，那不是更危险了，事实确实如此，算了吧，还是暂时不相信网络了，我去买个系统光盘吧（不知道现在还有没有人用光盘装系统），可是卖你光盘的人能保证光盘的内容不被篡改吗？你说那不能，因为他是微软高级经理的小舅子，应该不能卖盗版碟吧。</p><p>即使光盘不是盗版的，但是制作光盘的内容有没有人动过手脚呢？这些我们还是无法确认，我们能做的只是尽可能的在正规渠道购买正版系统，这种情况遇到证书被篡改的情况很小，然后就无条件相信这个系统了，这就是我文章开头说的，我么总要信点什么，试想如果盖茨在 <code>Windows</code> 操作系统的证书中留有后门，你又能做些什么呢，所以还是不要纠结了，既然用就在正常使用的前提下信任它。</p><h1 id="应用及分析"><a href="#应用及分析" class="headerlink" title="应用及分析"></a>应用及分析</h1><p>说是应用，实际上我只是想吐槽而已，在吐槽之前我们应该了解，证书可以跟各大证书机构（也就是各种CA）来买，也可以自己生成，可能有人会想了，自己生成挺好啊，不用花钱谁还买啊？可是刚刚说过了，跟CA买的证书都是操作系统内置证书认证过的，自己生成的证书操作系统和浏览器可不认，那怎么办呢？</p><p>干脆自己安装个根证书，自己给自己认证得了，用户岂是你想让安装就安装的，别说，还真是这样，只要你说的情况很危急，必须安装，那么大多数的小白用户是会自动安装的，这时你想到了谁？</p><p>不知道大家想到了谁，反正我是想到了建行网银证书和令人“可歌可气”的12306，接下来简单扒一扒他们两个的故事…</p><h2 id="建行网银证书"><a href="#建行网银证书" class="headerlink" title="建行网银证书"></a>建行网银证书</h2><p>最先接触的证书就是建行网银证书，我的第一代网银盾用了将近10年，去年才刚刚升级成2代，可以说真的是太稳定了，不知道做网银的产品经理是谁，你简直就是程序员的福音，在2020年的今天打开建行的官网，首页倒是好看了许多，但是有些内容，比如证书安装、U盾介绍的页面还是原来丑丑的样子。</p><p><img src="https://cdn.jsdelivr.net/gh/albertgithubhome/cdn/img/auth03/ccb2.png" alt="ccb2"></p><p>之前办理U盾时还花钱，根本都不懂啊，使用U盾必须装证书啊，不装就不安全啊，现在回想起来，和我说这话的人可能根本就不懂什么是安全，什么是不安全，反正装就是了，每次付款都要启动建行验证程序，这也是我手动安装过的次数最多的证书，是它开启了我网上购物的里程。</p><p>已经2020年了，打开建行的官网依旧提示我正在使用不安全的连接，使用网银依旧让我自己安装证书，可能作为一个大银行，官方网站迟迟不启用 <code>HTTPS</code>，使用网银盾坚持要用户自己安装证书，应该不仅仅是证书价格的问题，可能还有什么其他的原因。</p><p><img src="https://cdn.jsdelivr.net/gh/albertgithubhome/cdn/img/auth03/ccb3.png" alt="ccb3"></p><h2 id="神奇的12306"><a href="#神奇的12306" class="headerlink" title="神奇的12306"></a>神奇的12306</h2><p>毕业后直接在12306买票的次数就少了，现在一般使用 APP 来解决，前一阵发现12306居然不要求自己安装证书了，仔细一查原来从2017年开始，12306官网就购买了 <code>DigiCert Inc</code> 认证的证书，确实是一个进步的boy，终于舍得花点钱买证书了，作为一个巨大型的网站，它方便了人们购票的方式，是值得歌颂和称赞的，但是每次购票前还要安装烦人的证书，确实挺令人生气的。</p><p><img src="https://cdn.jsdelivr.net/gh/albertgithubhome/cdn/img/auth03/12306_0.png" alt="12306_0"></p><p>原来“根证书”3个红字显示在页面正中间，确实起到了提醒的作用，挺扎眼的，不过那已经一去不复返了，我再放个图，大家一起回顾一下。</p><p><img src="https://cdn.jsdelivr.net/gh/albertgithubhome/cdn/img/auth03/12306.png" alt="12306"></p><h2 id="ESET-SSL-Filter-CA"><a href="#ESET-SSL-Filter-CA" class="headerlink" title="ESET SSL Filter CA"></a>ESET SSL Filter CA</h2><p>最后放一个例子，让你感受下根证书的威力，ESET是总部位于斯洛伐克布拉迪斯拉发的一家世界知名的电脑安全软件公司，主要做杀毒软件，前不久复习 <code>HTTPS</code> 知识的时候发现，我访问各大网站的证书全都变成了 <code>ESET SSL Filter CA</code>，这是什么鬼，难道 <code>ESET SSL Filter CA</code> 是个特别大的证书机构？</p><p>当时还没有意识到是杀毒软件的证书，以为大家都是买的这家证书，后来发现不太对，百度、谷歌、GitHub、Stack Overflow，怎么都是一样的证书，继续深究才发现被“窃听”了。</p><p>我们知道使用 <code>HTTPS</code> 通信因为使用了非对称加密，没有私钥是无法窃听加密内容的，但是这款杀毒软件做到了，它有一个HTTPS 内容过滤的功能，做了我的电脑和各大网站的中间人，按理说 <code>HTTPS</code> 是可以检测出中间人的，但是这款软件在电脑中安装了根证书，所有浏览器认为它是合法的，理论上可以窃听你所有内容，甚至为所欲为。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>信任不仅是人类社会的基石，在网络世界同样重要</li><li>证书之间的层层信任构成了信任链，而根证书是不需要被其他人证明的</li><li>不要随意安装来历不明的根证书，那样可能会使的电脑更容易遭受到攻击</li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/106976688" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>若衣食无忧，谁甘愿拼搏！努力鞭策自己无非是为了挣得可以选择生活的权利~</p></blockquote><hr><blockquote><p>2020-7-5 23:44:41</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;人生在世总要相信点什么，信亲人、信朋友、信你面前的陌生人，即便这些你都不信，也要信自己吧，假如连自己都不信了，那在地球上恐怕很难生存了。&lt;/p&gt;
    
    </summary>
    
      <category term="加密与认证" scheme="http://AlbertGithubHome.github.io/blog/categories/%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%AE%A4%E8%AF%81/"/>
    
    
      <category term="认证" scheme="http://AlbertGithubHome.github.io/blog/tags/%E8%AE%A4%E8%AF%81/"/>
    
      <category term="非对称加密" scheme="http://AlbertGithubHome.github.io/blog/tags/%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/"/>
    
      <category term="HTTPS" scheme="http://AlbertGithubHome.github.io/blog/tags/HTTPS/"/>
    
      <category term="根证书" scheme="http://AlbertGithubHome.github.io/blog/tags/%E6%A0%B9%E8%AF%81%E4%B9%A6/"/>
    
      <category term="中间人" scheme="http://AlbertGithubHome.github.io/blog/tags/%E4%B8%AD%E9%97%B4%E4%BA%BA/"/>
    
  </entry>
  
  <entry>
    <title>码龄10年工作6年的搬砖小哥，最常访问的学习网站都在这里了</title>
    <link href="http://AlbertGithubHome.github.io/blog/2020/06/18/%E7%A0%81%E9%BE%8410%E5%B9%B4%E5%B7%A5%E4%BD%9C6%E5%B9%B4%E7%9A%84%E6%90%AC%E7%A0%96%E5%B0%8F%E5%93%A5%EF%BC%8C%E6%9C%80%E5%B8%B8%E8%AE%BF%E9%97%AE%E7%9A%84%E5%AD%A6%E4%B9%A0%E7%BD%91%E7%AB%99%E9%83%BD%E5%9C%A8%E8%BF%99%E9%87%8C%E4%BA%86/"/>
    <id>http://AlbertGithubHome.github.io/blog/2020/06/18/码龄10年工作6年的搬砖小哥，最常访问的学习网站都在这里了/</id>
    <published>2020-06-18T14:31:18.000Z</published>
    <updated>2020-06-20T04:09:35.073Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这完全是一篇水文，主要看别人分享的文章很有收藏价值，所以也想试着总结一下这种类型的文章，不过之前确实用过一些比较好的网站，有些网站是查找问题时找到的，但是解决完问题就找不到了很可惜，所以我养成了收藏网址的习惯，感觉有用就会分门别类的添加到书签中，再次遇到之前解决过的问题就先在书签里搜一下，有时候会加快解决问题的进度，下面这幅图是我浏览器书签中的一部分。</p><a id="more"></a><p><img src="https://img-blog.csdnimg.cn/20200618224021946.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9hbGJlcnRnaXRodWJob21lLmdpdGh1Yi5pby9ibG9nL2Fib3V0,size_10,color_FFFFFF,t_70#pic_center" alt="bookmark"><br>网络技术飞速发展到今天，越来越多的功能被搬到了“云”上，导致原来需要在本地安装的多种开发环境完全不需要搭建了，如果是临时使用完全可以在浏览器中实现，比如对于程序猿来说不可或缺的编程开发环境，已经出现很多在线编译和运行的网站，再比如原来被称作 <code>PS大神</code> 的设计者们必须要在电脑上安装 <code>Photoshop</code> 这个庞然大物，可是现在你可以发现很多在线 <code>PS</code> 的软件，处理简单功能分分钟搞定，这是我截取的网页上 <code>在线PS软件</code> 的一部分，足以以假乱真。</p><p><img src="https://img-blog.csdnimg.cn/2020061822583286.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9hbGJlcnRnaXRodWJob21lLmdpdGh1Yi5pby9ibG9nL2Fib3V0,size_10,color_FFFFFF,t_70#pic_center" alt="onlinePS"><br>好了，开始进入正题了，作为一个天天写代码的搬砖小伙，每天都在敲敲敲，不是在敲代码就是在敲代码的路上，还有一种可能就是在学习如何敲代码，那么这样的榆木脑袋每天都会访问哪些学习网站呢？接下来我把最常访问的一些网站列举一下，有可能后续会更新，但我要是犯懒就算了。</p><h1 id="网站列表"><a href="#网站列表" class="headerlink" title="网站列表"></a>网站列表</h1><p>接下来会分成几个大类来列举一个我最常用的一些网站，每个人的喜好不同，但是仔细看看，或许有些你会感兴趣哦！</p><h2 id="一、文档项目"><a href="#一、文档项目" class="headerlink" title="一、文档项目"></a>一、文档项目</h2><p>如果写一个功能有现成的轮子给我用就好了，其实网络上有很多现成的轮子，我们要善于利用别人的成果转换为自己进步的阶梯。</p><p>1、<strong>cppreference</strong> &gt;&gt; <a href="https://en.cppreference.com/w/" target="_blank" rel="noopener">https://en.cppreference.com/w/</a></p><p>首推这个网站其实是有点偏心的，因为每天都在写C++，所以还是首先就想到了这个网站，这个网站中可以查到已经发布的各个C++标准的库函数，特性、头文件等等，对于不确定的函数返回值、新标准的特性、函数的常见用法都可以在这个网站找到，这个网站还有中文版的，学习C++的小伙伴可以常来逛逛。</p><p><img src="https://img-blog.csdnimg.cn/20200618233424911.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9hbGJlcnRnaXRodWJob21lLmdpdGh1Yi5pby9ibG9nL2Fib3V0,size_10,color_FFFFFF,t_70#pic_center" alt="cppreference"></p><p>2、 <strong>GitHub</strong> &gt;&gt; <a href="https://github.com/" target="_blank" rel="noopener">https://github.com/</a></p><p>被广大程序员调侃成“全球最大的同性交友网站”怎么能不上榜，<code>GitHub</code> 这个网站就算你不常用但也会常听到吧，上面充满了全世界精英团队编写的轮子，有趣的是这样一个最支持开源的网站居然被微软的这个最大的闭源厂商受够了，不过现在还是发展的越来越好了。你可以在上面阅读一些开源代码，看看那些明星产品究竟是怎样实现的，真正为我所用。</p><p><img src="https://img-blog.csdnimg.cn/20200618233959952.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9hbGJlcnRnaXRodWJob21lLmdpdGh1Yi5pby9ibG9nL2Fib3V0,size_10,color_FFFFFF,t_70#pic_center" alt="github"></p><h2 id="二、数据仓库"><a href="#二、数据仓库" class="headerlink" title="二、数据仓库"></a>二、数据仓库</h2><p>程序发展离不开数据存储，数据是支撑程序发展的基石，现在的数据库已经不是当初的关系数据满天下了，各种各样的数据库类型被发明了出来，列数据库、文档数据库、键值数据库等等，真的是太多了。</p><p>1、 <strong>Redis</strong> &gt;&gt; <a href="https://redis.io/commands" target="_blank" rel="noopener">https://redis.io/commands</a></p><p>非关系型数据库中最火的一个了吧，在认真学习之前一度认为它是一个新产品，后来才知道 <code>Redis</code> 其实在 2009 年就已经诞生了，作为一款键值型的内存数据库，现在被广泛引用于各个领域，而 <code>Redis</code> 的官方文档是需要不断去翻阅的，最近发布了 <code>Redis 6.0</code>，引入了网络多线程，以后的面试题可能要留神了。</p><p><img src="https://img-blog.csdnimg.cn/20200618235824411.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9hbGJlcnRnaXRodWJob21lLmdpdGh1Yi5pby9ibG9nL2Fib3V0,size_10,color_FFFFFF,t_70#pic_center" alt="redis"></p><p>2、 <strong>MySQL</strong>  &gt;&gt; <a href="https://dev.mysql.com/doc/refman/8.0/en/" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/8.0/en/</a></p><p>虽然 <code>NoSQL</code> 数据库在各个领域兴起，但是现在还是关系数据库占据着主导地位，<code>MySQL</code> 就是关系数据库中的明星产品了，自从被 <code>ORACLE</code> 收购以后也在不断发展，最近版本从5.7一跃直接到8.0，据说<code>MySQL 8</code> 要比 <code>MySQL 5.7</code> 快 2 倍，还带来了大量的改进和更快的性能！感兴趣的可以查阅一下 <code>MySQL</code> 的文档，它的文档格式特别棒，看着就让人赏心悦目。</p><p><img src="https://img-blog.csdnimg.cn/20200619000455910.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9hbGJlcnRnaXRodWJob21lLmdpdGh1Yi5pby9ibG9nL2Fib3V0,size_10,color_FFFFFF,t_70#pic_center" alt="MySQL"><br>3、 <strong>墨天轮</strong> &gt;&gt; <a href="https://www.modb.pro/dbRank" target="_blank" rel="noopener">https://www.modb.pro/dbRank</a></p><p>墨天轮上聚集了很多数据库爱好者，是一个新兴的数据库技术交流平台，一直渴望成为一个专业的技术社区，高效便捷、开放互助、乐于分享，能够承载我们数据人的学习和成长，促进整个行业的发展和创新，在这个网站上我们可以看到各大数据库排行，了解数据库相关的最新发展和方向。</p><p><img src="https://img-blog.csdnimg.cn/20200619002322531.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9hbGJlcnRnaXRodWJob21lLmdpdGh1Yi5pby9ibG9nL2Fib3V0,size_10,color_FFFFFF,t_70#pic_center" alt="modb"></p><h2 id="三、工具集合"><a href="#三、工具集合" class="headerlink" title="三、工具集合"></a>三、工具集合</h2><p>文章开头也提到了，如今很多工具都搬到了线上，这样既节省了电脑空间，也免去了安装和配置工具的麻烦，只要不是IDE的重度依赖者，使用在线工具还是很方便的。</p><p>1、 <strong>在线工具</strong> &gt;&gt; <a href="https://tool.lu/" target="_blank" rel="noopener">https://tool.lu/</a></p><p>这个网站提供了众多的在线工具，每次一用到时间戳转换或者URL编码等操作，我肯定会第一时间打开这个页面，因为本地调 <code>API</code> 太麻烦了，有时还需要搭建环境，在网站上找到对应的工具直接操作就可以了，还带有实时刷新的功能，完全没必要自己在本地写代码。</p><p><img src="https://img-blog.csdnimg.cn/2020061922082255.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9hbGJlcnRnaXRodWJob21lLmdpdGh1Yi5pby9ibG9nL2Fib3V0,size_10,color_FFFFFF,t_70#pic_center" alt="tool"></p><p>2、<strong>AlbertWorld</strong> &gt;&gt; <a href="http://www.008ct.top/blog/tools/" target="_blank" rel="noopener">http://www.008ct.top</a></p><p>这个网站收录了很多有用的网址，不仅仅是工具，文档、教程、数据、资源包括方方面面，其中包括很多讲解原理的知识和有用的素材，很像一个小小的杂货铺，偶尔上新哦！</p><p><img src="https://img-blog.csdnimg.cn/20200619220657719.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9hbGJlcnRnaXRodWJob21lLmdpdGh1Yi5pby9ibG9nL2Fib3V0,size_10,color_FFFFFF,t_70#pic_center" alt="008ct"></p><h2 id="四、疑难解答"><a href="#四、疑难解答" class="headerlink" title="四、疑难解答"></a>四、疑难解答</h2><p>解决问题是程序员每天都要面临的功课，而程序员要解决的问题往往是没见过的，如果一个程序猿天天值只处理那么几个相同的问题，那么他已经走上了被淘汰的道路，查找问题原因，给出解决方案，祝贺你，你今天又进步了。</p><p>1、 <strong>CSDN</strong> &gt;&gt; <a href="https://www.csdn.net/" target="_blank" rel="noopener">https://www.csdn.net/</a></p><p>用了这么久的 <code>CSDN</code> 一直不知道全称是什么？前几天才查了一下全称是 <code>Chinese Software Developer Network</code>，立意很深远的样子，不过确实是一个不错的网站，从去年开始大面积调整，原来的广告真是惨不忍睹，改版后现在好多了，工作中很多解决方案都出自这个网站，之前在论坛里没少逛，解答问题的同时，自己的知识也得到了巩固。</p><p><img src="https://img-blog.csdnimg.cn/20200619220017417.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9hbGJlcnRnaXRodWJob21lLmdpdGh1Yi5pby9ibG9nL2Fib3V0,size_10,color_FFFFFF,t_70#pic_center" alt="csdn"></p><p>2、 <strong>StackOverflow</strong> &gt;&gt; <a href="https://stackoverflow.com/" target="_blank" rel="noopener">https://stackoverflow.com/</a></p><p>一个和 <code>GitHub</code> 比肩的网站，一个专门解决程序猿问题的网站，你要坚信，作为一个普通的程序搬砖工，你遇到的问题别人也遇到过，所以遇到问题来这个网站查一查，有时问题瞬间就被解决了，特别是一些专业的工具仅仅报了一个错误代码，通过搜索引擎很难定位具体问题，但是在这个网站上的前辈已经为你趟好路了。</p><p><img src="https://img-blog.csdnimg.cn/20200619002926880.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9hbGJlcnRnaXRodWJob21lLmdpdGh1Yi5pby9ibG9nL2Fib3V0,size_10,color_FFFFFF,t_70#pic_center" alt="stackoverflow"></p><h2 id="五、进阶刷题"><a href="#五、进阶刷题" class="headerlink" title="五、进阶刷题"></a>五、进阶刷题</h2><p>程序猿就是一个活到老学到老的职业（如果35岁被淘汰就不用学了），必须时刻保证自己的学习状态，更新自己的知识储备，刷题成为了一项锻炼脑力的活动，因为很多公司特别是大公司都会要求算法达到一定的水平，所以没事多刷刷题，不要让自己的大脑锈住了。</p><p>1、<strong>力扣</strong> &gt;&gt; <a href="https://leetcode-cn.com/problemset/all/" target="_blank" rel="noopener">https://leetcode-cn.com/problemset/all/</a></p><p>这个网站貌似有很多名字，现在显示的是力扣，之前是在全球服注册的，后来莫名其妙的有注册了一次，变成了家门口的版本，这上面有很多算法题，一段时间没看居然还加上了面试题，不过它搞的那个竞赛挺有意思的，作为长期的两题选手，看着高手们10分钟做完4题，犹如神仙打架一般。</p><p><img src="https://img-blog.csdnimg.cn/20200619220440231.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9hbGJlcnRnaXRodWJob21lLmdpdGh1Yi5pby9ibG9nL2Fib3V0,size_10,color_FFFFFF,t_70#pic_center" alt="leetcode"></p><p>2、 <strong>POJ</strong> &gt;&gt; <a href="http://poj.org/" target="_blank" rel="noopener">http://poj.org/</a></p><p>这个 <code>Online Judge</code> 有些历史了，不过一直保持着更新，<code>ACM</code> 竞赛时也尝试在这里刷过题，和 <code>LeetCode</code> 比起来这里的题似乎更难一些，如果想挑战更高难度，不妨来这里试一下。</p><p><img src="https://img-blog.csdnimg.cn/20200619221129502.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9hbGJlcnRnaXRodWJob21lLmdpdGh1Yi5pby9ibG9nL2Fib3V0,size_10,color_FFFFFF,t_70#pic_center" alt="poj"></p><h2 id="六、教程案例"><a href="#六、教程案例" class="headerlink" title="六、教程案例"></a>六、教程案例</h2><p>当我们想学习一门新技术的时候，很渴望得到一份简单明了的教程，实际上很多技术的官方网站文档都非常完整，但是对于初学者来说理解起来会有些难度，这时候可以看一些边学边做的教程，在不断尝试中学习知识。</p><p>1、<strong>廖雪峰官网</strong> &gt;&gt; <a href="https://www.liaoxuefeng.com/wiki/1016959663602400" target="_blank" rel="noopener">https://www.liaoxuefeng.com/wiki/1016959663602400</a></p><p>廖雪峰此乃神人也，看看我截取的这篇教程的访问量你就清楚了，前两年我看到这篇文章的时候访问量才几亿，跟着教程完整的学了一遍，现在访问量已经400多亿了，受欢迎程序难以想象，廖大神写得教程浅显易懂，非常适合初学者，从头来一步步的就学会了，想当初我跟着他学爬虫把他的文章都爬了，哈哈~<br><img src="https://img-blog.csdnimg.cn/20200619221531788.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9hbGJlcnRnaXRodWJob21lLmdpdGh1Yi5pby9ibG9nL2Fib3V0,size_10,color_FFFFFF,t_70#pic_center" alt="liaoxuefeng"><br>2、 <strong>菜鸟教程</strong> &gt;&gt; <a href="https://www.runoob.com/" target="_blank" rel="noopener">https://www.runoob.com/</a></p><p>同样是一个接地气的教程网站，谁刚开始学的时候不是一只菜鸟呢，这个网站教程很多，只要你想学总能找到你喜欢的那款，并且在讲解时会有例子和函数参数说明，非常适合初学者。<br><img src="https://img-blog.csdnimg.cn/20200619221355785.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9hbGJlcnRnaXRodWJob21lLmdpdGh1Yi5pby9ibG9nL2Fib3V0,size_10,color_FFFFFF,t_70#pic_center" alt="runoob"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>总有小伙伴调侃说：收藏从未停止，学习从未开始，其实收藏是一个好苗头，只有想学才有可能去学</li><li>如果仔细看了这些网站，你会发现有些网站的设计让人真的很舒服，临时补充一个 <code>https://git-scm.com/</code></li><li>真正应了那句话，比你优秀的人比你还努力，你的产品都那么强了，网站居然还那么好看，还让不让人活了~</li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/106754135" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>我们没有生活在和平的年代，只是生活在了和平的国度，想开点，珍惜眼前的一切，灾难都会过去，我们还有一双手去争夺属于自己的未来。</p><p>2020-6-20 00:16:49</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;这完全是一篇水文，主要看别人分享的文章很有收藏价值，所以也想试着总结一下这种类型的文章，不过之前确实用过一些比较好的网站，有些网站是查找问题时找到的，但是解决完问题就找不到了很可惜，所以我养成了收藏网址的习惯，感觉有用就会分门别类的添加到书签中，再次遇到之前解决过的问题就先在书签里搜一下，有时候会加快解决问题的进度，下面这幅图是我浏览器书签中的一部分。&lt;/p&gt;
    
    </summary>
    
      <category term="Thinking" scheme="http://AlbertGithubHome.github.io/blog/categories/Thinking/"/>
    
    
      <category term="收集" scheme="http://AlbertGithubHome.github.io/blog/tags/%E6%94%B6%E9%9B%86/"/>
    
      <category term="网站" scheme="http://AlbertGithubHome.github.io/blog/tags/%E7%BD%91%E7%AB%99/"/>
    
      <category term="working" scheme="http://AlbertGithubHome.github.io/blog/tags/working/"/>
    
  </entry>
  
  <entry>
    <title>C++中的std::lower_bound()和std::upper_bound()函数</title>
    <link href="http://AlbertGithubHome.github.io/blog/2020/06/15/C-%E4%B8%AD%E7%9A%84std-lower-bound-%E5%92%8Cstd-upper-bound-%E5%87%BD%E6%95%B0/"/>
    <id>http://AlbertGithubHome.github.io/blog/2020/06/15/C-中的std-lower-bound-和std-upper-bound-函数/</id>
    <published>2020-06-15T15:17:39.000Z</published>
    <updated>2020-06-27T02:12:52.819Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>问题是躲不掉的，该来的总会来，这不是代码中又遇到了 <code>std::upper_bound()</code> 函数，再来学习一遍好了，在我的印象中每次看到这 <code>lower_bound</code> 和 <code>upper_bound</code> 两个函数都有些别扭，凡是见到他们必须查一遍，因为我记得它们两个函数的作用不对称，这一点记得很清楚，但是它们两个函数查找的细节却记不住，这次总结一下，强化记忆，下次回忆起来应该会快一点。</p><a id="more"></a><h1 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h1><p>今天看到这两个函数时挠挠头又打开了搜索引擎，看到文章里写到 <code>std::lower_bound()</code> 是返回大于等于 <code>value</code> 值的位置，而 <code>std::upper_bound()</code> 是返回第一个大于 <code>value</code> 值的位置，第一反应真是瞎写，怎么俩都是大于，肯定应该是一个大于一个小于啊，这样才“合理”嘛！</p><p>但是当看到多个文章中采用相同的说法时，刚刚还“坚定”的想法开始动摇，然后开始查C++标准文档，一遍遍读着那有些拗口的文字:</p><blockquote><p>std::lower_bound returns an iterator pointing to the first element in the range [first, last) that is not less than (i.e. greater or equal to) value, or last if no such element is found.</p><p>std::upper_bound returns an iterator pointing to the first element in the range [first, last) that is greater than value, or last if no such element is found.</p></blockquote><p>这些标准文档上的文字印证了刚刚查询到的结果，两个函数返回的结果都是迭代器，<code>std::lower_bound()</code> 是在区间内找到第一个大于等于 <code>value</code> 的值的位置并返回，如果没找到就返回 <code>end()</code> 位置。而 <code>std::upper_bound()</code> 是找到第一个大于 <code>value</code> 值的位置并返回，如果找不到同样返回 <code>end()</code> 位置。</p><p>两个函数都提到了大于操作，而没有涉及到小于操作，这就是我前面提到的不对称，也是我感觉不合理的地方，但是当尝试使用了几次这两个函数之后，我发现这两个函数的设计的恰到好处，这样的设计很方便我们来做一些具体的操作。</p><h1 id="实际例子"><a href="#实际例子" class="headerlink" title="实际例子"></a>实际例子</h1><p>首先说明这两个函数内部使用了二分查找，所以必须用在有序的区间上，满足有序的结构中有两个常见的面孔：<code>std::map</code> 和 <code>std::set</code>，他们本身就是有序的，所以提供了 <code>std::map::lower_bound()</code> 和 <code>std::set::lower_bound()</code> 这种类似的成员函数，但是原理都是一样的，我们可以弄明白一个，另外类似的函数就都清楚了。</p><h2 id="自己设计"><a href="#自己设计" class="headerlink" title="自己设计"></a>自己设计</h2><p>如果你看了这两个函数的具体含义也和我一样不太理解为什么这样设计，可以思考一下接下来这个需求，找出数组内所有值为2和3的元素，图例如下：</p><p><img src="https://cdn.jsdelivr.net/gh/albertgithubhome/cdn/img/lower_bound.png" alt="lower_bound()"></p><p>对于一个有序数组，我们在实现 <code>lower_bound()</code> 函数和 <code>upper_bound()</code> 函数时可以让它返回指定的位置来确定取值区间，第①种情况就是标准函数库的实现方式，而第②种和第③种就是我第一印象中感觉应该对称的样子，这样看起来也没什么问题，下面具体来分析下后两种设计有哪些不好的地方。</p><h2 id="具体分析"><a href="#具体分析" class="headerlink" title="具体分析"></a>具体分析</h2><p>假如我们采用第②种实现方式，那么实现打印元素2和3的代码要写成下面这样：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v&#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">8</span>&#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::const_iterator itorLower = <span class="built_in">std</span>::lower_bound(v.begin(), v.end(), <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::const_iterator itorUpper = <span class="built_in">std</span>::upper_bound(v.begin(), v.end(), <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *itorLower &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">if</span> (itorLower == itorUpper)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        ++itorLower;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码看起来还可以，打印完元素后判断到达了结尾直接跳出循环，但是如果要是数组中不包含元素2和3呢，那么也会打印出一个元素，还有可能导致程序崩溃。</p><p>如果我们采用第③种实现方式，那么实现打印元素2和3的代码要写成下面这样：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v&#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">8</span>&#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::const_iterator itorLower = <span class="built_in">std</span>::lower_bound(v.begin(), v.end(), <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::const_iterator itorUpper = <span class="built_in">std</span>::upper_bound(v.begin(), v.end(), <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">for</span>(++itorLower; itorLower != itorUpper; ++itorLower)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *itorLower &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这代码看起来简洁了很多，但是在循环开始前需要先调用 <code>++itorLower</code>，因为第一个元素并不是需要找到的元素，所以要先跳过它，这样看来确实多做了一步操作，一开始就让 <code>itorLow</code> 指向第一个2就好了呀。</p><h2 id="最终版本"><a href="#最终版本" class="headerlink" title="最终版本"></a>最终版本</h2><p>当你尝试几种实现方式就会发现，还是标准库提供的这种方式使用起来更加方便，虽然采取的不是对称的方式，但是统一了存在查找元素和不存在查找元素的的情况，写出的代码也比较简洁，没有多余的步骤，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v&#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">8</span>&#125;;</span><br><span class="line">    <span class="keyword">auto</span> itorUpper = <span class="built_in">std</span>::upper_bound(v.begin(), v.end(), <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> itorLower = <span class="built_in">std</span>::lower_bound(v.begin(), v.end(), <span class="number">2</span>); itorLower != itorUpper; ++itorLower)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *itorLower &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>有些函数的实现方式和我们想象的并不一样，但是我们可以通过熟练使用来了解它为什么这样设计</li><li>对称结构虽然是很美的，但是非对称的结构在编程中常常出现，同样有其美丽所在</li><li>遇到类似的问题可以动笔画一画，列举出各种情况会有利于你做出正确的判断</li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/106844850" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>有时会很焦虑，看到优秀的人比你还努力时总让人感到急迫，但是一味的忧患是无意义的，脚下迈出的每一步才是真真正正的前进，不要去忧虑可能根本就不会发生的事情，那样你会轻松许多</p><p>2020-6-26 23:21:40</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;问题是躲不掉的，该来的总会来，这不是代码中又遇到了 &lt;code&gt;std::upper_bound()&lt;/code&gt; 函数，再来学习一遍好了，在我的印象中每次看到这 &lt;code&gt;lower_bound&lt;/code&gt; 和 &lt;code&gt;upper_bound&lt;/code&gt; 两个函数都有些别扭，凡是见到他们必须查一遍，因为我记得它们两个函数的作用不对称，这一点记得很清楚，但是它们两个函数查找的细节却记不住，这次总结一下，强化记忆，下次回忆起来应该会快一点。&lt;/p&gt;
    
    </summary>
    
      <category term="C/C++" scheme="http://AlbertGithubHome.github.io/blog/categories/C-C/"/>
    
    
      <category term="C/C++" scheme="http://AlbertGithubHome.github.io/blog/tags/C-C/"/>
    
      <category term="lower_bound" scheme="http://AlbertGithubHome.github.io/blog/tags/lower-bound/"/>
    
      <category term="upper_bound" scheme="http://AlbertGithubHome.github.io/blog/tags/upper-bound/"/>
    
      <category term="查找" scheme="http://AlbertGithubHome.github.io/blog/tags/%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>认证、HTTPS、证书的基本含义</title>
    <link href="http://AlbertGithubHome.github.io/blog/2020/06/14/%E8%AE%A4%E8%AF%81%E3%80%81HTTPS%E3%80%81%E8%AF%81%E4%B9%A6%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%90%AB%E4%B9%89/"/>
    <id>http://AlbertGithubHome.github.io/blog/2020/06/14/认证、HTTPS、证书的基本含义/</id>
    <published>2020-06-14T14:50:35.000Z</published>
    <updated>2020-06-15T14:53:13.612Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>通过前面的总结 <a href="https://blog.csdn.net/albertsh/article/details/106536857" target="_blank" rel="noopener">《对称加密、非对称加密、公钥、私钥究竟是个啥？》</a>，我们基本了解了对称加密和非对称加密的概念和特点，考虑到效率和安全性，一般可以使用非对称加密来传递对称加密所需密钥，之后就采取对称加密通信了，这样可以大大提高数据发送的的效率。</p><a id="more"></a><p>其实密码技术除了应用在加密领域外还有很多其他的用途，比如验证数据的完整性、用来做认证、提供一些不可否认的证据等，这些应用也常常出现在我们的日常生活中，比如很多官方网站在提供软件下载链接的同时，还附带一个验证的字符串，实际上很多就是md5码或者hash码，这些就是供下载的人来验证完整性的，防止被其他人篡改。</p><p><img src="https://img-blog.csdnimg.cn/20200614233255231.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9hbGJlcnRnaXRodWJob21lLmdpdGh1Yi5pby9ibG9nL2Fib3V0,size_18,color_FFFFFF,t_70#pic_center" alt="download"></p><p>我们下载完软件之后，使用工具来将软件转化成一串字符，听起来很神奇，实际上就是计算一下软件的md5码或hash码，然后和网站上的标注的信息进行对比，如果一致那么软件就是完整的。我曾经就遇到过一次，当时做的游戏发包，同事给我发了测试包，安装之后无法正常使用，检查包的大小与发送端的一样，后来使用检测工具计算发现md5是不同的，原因可能是发送包的时候电脑卡死过，导致最后发来数据包与原始数据产生了差异。</p><p>但是你有没有想过，这个软件虽然是完整的，通过md5计算发现也没有被其他人篡改，那么怎么证明你下载的网站真的是官网呢？万一官网也是伪造的呢？如果有人伪造了官网，又将上面的软件进行修改重新计算md5然后上传到自己伪造的界面上，你要怎么来识别呢？</p><p><img src="https://img-blog.csdnimg.cn/20200614233512429.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9hbGJlcnRnaXRodWJob21lLmdpdGh1Yi5pby9ibG9nL2Fib3V0,size_18,color_FFFFFF,t_70#pic_center" alt="fish"></p><p>可能有的人会想到看网址啊，<code>taobao.com</code> 就一定是淘宝的网站吗？这个域名是可以伪造的，所以要验证网站上东西是真的，那么首先要验证你看到的网站是真的，这就涉及到了认证身份，接下来可以简单了解下什么是认证。</p><h1 id="认证"><a href="#认证" class="headerlink" title="认证"></a>认证</h1><p>其实密钥不仅仅可以用来加密，还可以用来认证的，那么什么是认证？认证是一种信用保证形式，表示对一种事物或一个人的信任和认可，比如常见的毕业证书、结婚证书都是对人一段经历或一种关系的证明和认可。最简单的网站登录是基于密码的验证，这实际上就是利用对称加密的认证。</p><p>网站保存了你的用户信息和密码，下次再登录的时候输入密码后，网站会用你输入的密码和之前保存的密码进行对比，如果密码相同则认证成功，成功的证明了“你”就是“你”，而非对称加密同样可以用来做认证。</p><p>在非对称加密的实现中，私钥是只有自己保存的，而私钥加密的内容可以使用公钥解开，如果一份加密数据可以用 <code>Jerry</code>的公钥解开，那么我们就可以认为这份数据是 <code>Jerry</code> 发出的，因为只有 <code>Jerry</code> 自己有私钥，所以可以通过这种方式来进行认证。</p><p>而在网络上想要认证一个网站的身份，确认它不是钓鱼网站，第一个映入脑海中的就是 <code>https</code>，一般提到 <code>https</code> 都会说它是加密的、安全的，是 <code>http</code> 的升级版，但是 <code>https</code> 的安全不仅仅体现在加密上，还有它的认证功能，可以使你免受钓鱼网站的侵害。</p><h1 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h1><p>简单了解下 <code>HTTPS</code>，一般来说网络模型常说的有OSI七层模型和五层模型，<code>HTTPS</code> 的诞生并没有增加模型的层数，<code>HTTP</code> 是建立在 <code>TCP</code>基础上的应用层协议，而 <code>HTTPS</code> 是在 <code>TCP</code> 和 <code>HTTP</code> 之间的会话层中加了一些特殊操作，使原来明文传输的内容，在会话层这一步进行加密，并且可以对数据来源进行认证。</p><p>提到 <code>HTTPS</code> 就不得不说 <code>SSL</code> 和 <code>TSL</code>， <code>SSL</code> 是应用在 <code>HTTP</code>上的一个协议加密层，最初是由网络大佬网景公司（Netscape）研发，后来升级为 <code>TSL</code>，简单的理解就是 <code>HTTP + SSL/TSL = HTTPS</code>。</p><p><img src="https://img-blog.csdnimg.cn/20200614233628484.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9hbGJlcnRnaXRodWJob21lLmdpdGh1Yi5pby9ibG9nL2Fib3V0,size_18,color_FFFFFF,t_70#pic_center" alt="safe"></p><p>随着网络安全逐渐得到大家的认识，一些主流网站基本都都将访问方式改成了 <code>https</code>，支持 <code>https</code> 的网站在浏览器的地址栏中通常有一把小锁，点开会提醒你访问的是安全的连接，如果你访问的连接疑似被人篡改或者仿冒，那么这把小锁会被斜线划掉，提醒你网站危险请谨慎访问。</p><p><img src="https://img-blog.csdnimg.cn/20200614233645628.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9hbGJlcnRnaXRodWJob21lLmdpdGh1Yi5pby9ibG9nL2Fib3V0,size_18,color_FFFFFF,t_70#pic_center" alt="dangerous"></p><p>那么 <code>https</code> 是怎么判断出来哪些网站是安全的，哪些网站是仿冒的呢？毕竟有些网址都很像甚至可以做成一模一样的，这就用到了非对称加密的认证功能，当我用 <code>A</code> 的公钥可以解密一段消息，那么就可以证明消息是 <code>A</code> 发来的，<code>https</code> 的认证功能正是利用了这个特点。</p><p>当访问一个网站的时候，网站先给我发一个用它的私钥加密的数据，然后我用它的公钥来解密，如果解密成功就说明我访问的网站是正常的，可以继续访问，如果解密失败则很有可能是虚假或者仿冒的网站，应该仔细辨别一下了。</p><p>这里会有一个问题，我怎么才能得到网站的公钥呢？之前说过密钥配送问题，直接由网站发给我肯定不行，中间可能被篡改，也有可能一个虚假网站把它自己的公钥发给我了，我用假的公钥验证对应的假的私钥也是成功的，这样就起不到认证的效果了，必须给他找个证明人才行，这就要用到我们下面要说的证书了。</p><h1 id="证书"><a href="#证书" class="headerlink" title="证书"></a>证书</h1><p>证书是用来证明一件事情或东西的，刚才说网站的公钥不能它自己来发，这样不能证明它的身份，我们可以找一个权威的机构给它认证一下，我每次从权威机构获得网站的证书，从这个证书中取得公钥，如果用这个公钥可以解开网站私钥加密的内容，那么就可以认证它的身份了。</p><p>这里提到的证书就是网站所有者找权威机构申请的，权威机构把网站信息、有效时期、对应的公钥、序列号消息等数据存储到证书中，当我们需要能某个网站的公钥时，去证书中取就可以了，这里的证书有点像营业执照了，由权威机构发布，用来证明你的身份。</p><p>但是权威机构的证书怎么发给我呢？我们有理由认为网络是不安全的，那证书如果直接通过网络发给我同样是不安全的，还有一个问题就是网站虽然找了一个权威机构，但是我认为它不够权威怎么办？这时这个权威机构可以找一个更权威的机构证明自己，让更权威的机构给自己颁发一个证书，这样就形成了证书链。</p><p><img src="https://img-blog.csdnimg.cn/20200614233914722.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9hbGJlcnRnaXRodWJob21lLmdpdGh1Yi5pby9ibG9nL2Fib3V0,size_18,color_FFFFFF,t_70#pic_center" alt="capath"></p><p>就像现实生活中我要找个人来干活，因为工期比较紧所以找的人要求踏实，必须能老老实实把活干完，不能半路撂挑子，张三过来应聘，正在我犹豫时，走过来一个叫李四的人说张三没问题，但是我还是不能确定，因为李四我也不熟悉，然后李四居然把我爸叫来了，我爸和我说李四这个人特别诚实，从来不说谎，这时一条证书链就形成了，李四为张三证明，我爸为李四证明，那谁来证明我爸说的是真的呢？不需要的，我无条件相信他。</p><p>这在计算机的证书链中就是根证书，根证书不需要别人来证明，你只能无条件相信它，它是整个信息链的源头，通常内置在操作系统或者浏览器中，关于根证书还要一些好玩的故事和一些变态的应用，下次再说吧，准备睡觉了~</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>密码技术除了应用在加密领域，还可以用来验证数据的完整性、用来做认证、提供一些不可否认的证据</li><li><code>HTTPS</code> 不仅可以用来加密通信内容，还可以用来验证网站的真实性</li><li>正规的支持 <code>HTTPS</code>的网站在访问时会地址栏会有一把安全的小锁头，但是有些不出现小锁头的网站并不一定都是非法的</li><li><code>HTTP</code> 网站是没有小锁头的，因为有些数据不需要加密，毕竟绝大多数的 <code>HTTPS</code> 证书是要钱的，有很多网站由于经费问题还未投身于 <code>HTTPS</code> 的怀抱</li><li>根证书通常内置的操作系统或者浏览器中，是证书链的源头，你必须无条件的信任他。</li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/106536857" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>当我们拼劲全力到达自己的终点时，可能会看到同行的人正在你的终点线前伸伸懒腰准备出发，然后一骑绝尘消失在你震惊的目光中，但是这不是我们放弃努力的理由，因为如果你不努力，你甚至连他们的背影也看不到~</p></blockquote><hr><blockquote><p>2020-6-14 23:20:21</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;通过前面的总结 &lt;a href=&quot;https://blog.csdn.net/albertsh/article/details/106536857&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《对称加密、非对称加密、公钥、私钥究竟是个啥？》&lt;/a&gt;，我们基本了解了对称加密和非对称加密的概念和特点，考虑到效率和安全性，一般可以使用非对称加密来传递对称加密所需密钥，之后就采取对称加密通信了，这样可以大大提高数据发送的的效率。&lt;/p&gt;
    
    </summary>
    
      <category term="加密与认证" scheme="http://AlbertGithubHome.github.io/blog/categories/%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%AE%A4%E8%AF%81/"/>
    
    
      <category term="加密" scheme="http://AlbertGithubHome.github.io/blog/tags/%E5%8A%A0%E5%AF%86/"/>
    
      <category term="认证" scheme="http://AlbertGithubHome.github.io/blog/tags/%E8%AE%A4%E8%AF%81/"/>
    
      <category term="非对称加密" scheme="http://AlbertGithubHome.github.io/blog/tags/%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/"/>
    
      <category term="HTTPS" scheme="http://AlbertGithubHome.github.io/blog/tags/HTTPS/"/>
    
      <category term="证书" scheme="http://AlbertGithubHome.github.io/blog/tags/%E8%AF%81%E4%B9%A6/"/>
    
  </entry>
  
  <entry>
    <title>对称加密、非对称加密、公钥、私钥究竟是个啥？</title>
    <link href="http://AlbertGithubHome.github.io/blog/2020/06/07/%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E3%80%81%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E3%80%81%E5%85%AC%E9%92%A5%E3%80%81%E7%A7%81%E9%92%A5%E7%A9%B6%E7%AB%9F%E6%98%AF%E4%B8%AA%E5%95%A5%EF%BC%9F/"/>
    <id>http://AlbertGithubHome.github.io/blog/2020/06/07/对称加密、非对称加密、公钥、私钥究竟是个啥？/</id>
    <published>2020-06-07T14:50:10.000Z</published>
    <updated>2020-06-15T14:52:08.577Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>进入正题之前先唠叨几句，不久前听到一个名词叫——费曼学习法，核心思想就是用通俗的话语把复杂道理或技术讲清楚，如果你已经明白了这个方法的含义，那么我好像离成功又进了一步。其实这个方法一直在尝试使用，但是没想到它居然有个“洋气”的名字。</p><a id="more"></a><p>由于之前学习时接触了加密、验证、HTTPS、证书等知识，感觉挺有意思的，最近也用到了一些这方面的内容，所以决定把这些概念重新梳理一下，免得一段时间不复习又还给书本了。本打算写一篇总结把这些概念整理到一起，但是初步想了一下很难实现，涉及到的概念实在太多了，所有还是决定分成几次来写吧。</p><p>分开写就比较随便了，写到哪完全看心情，不过我还是力图用最简单的描述来讲清楚问题，抛开具体的实现细节（其实我也不懂），梳理流程和概念性的知识，想了解具体的实现细节还是找专业的书籍去补充吧，我曾经看了一遍《图解密码技术》，过了这么久整本书我就记得两个词——异或、求余，再比如使用公钥和私钥来完成非对称加密，就是利用了两个大质数 <code>(p,q)</code> 乘积 <code>(n)</code> 难以逆向求解，这些太细节的东西很难展开一点点讲清楚。</p><p>最理想的状态是把学习知识当成是看故事书，阅读完一个个情节就吸收的差不多了，而不是把这些知识当成武功秘籍，然后一点点参悟，最后觉得枯燥而放弃，所以为了知识解惑，也算是将学习成果做个笔记，我们开始从最基础的知识学起。</p><h1 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h1><p>对称加密一般指：加密和解密使用的是同一个密钥的加密方式。就像防盗门的钥匙一样，可以用钥匙把门锁上，也可以用这同一把钥匙再把门打开。</p><h2 id="对称加密示例"><a href="#对称加密示例" class="headerlink" title="对称加密示例"></a>对称加密示例</h2><p>至于密钥怎么使用要看具体的加密算法了，可以举一个简单的例子，比如有下面这样一句话：</p><blockquote><p>I like cat</p></blockquote><p>我想把它发给一个好朋友，但是又不想被别人看到，万一有其他人一眼看到，那我的喜好就暴露了（那有怎样呢？），这时我们可以把这句话改的稍微隐晦一点，我可以和好友约定一个密码，假设是 <code>1</code>，然后我把原来这句话的每个非空白字母都替换一下，按字母表顺序使用后一个字母替换前一个字母，比如用字母 <code>b</code> 替换字母 <code>a</code>，那么这句话就变成了：</p><blockquote><p>J mjlf dbu</p></blockquote><p>这时就不怕被别人一眼看穿消息内容了，没有意义的字符串是比较难记的，但是当我的好友收到这句话时，使用我们约定的密码 <code>1</code> 就知道字母顺序变换了1位，所以他再将将字母反向替换回来就能够将文字还原。</p><p>这个例子很简单，但可以说明对称加密的关键，就是加密解密使用同一个密钥，例子中的 <code>1</code> 就是这个密钥，它可以让解密者知道，还原信息时需要反向移动1位即可，消息发送流程如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">A[I like cat] -- 用1加密 --&gt; B((J mjlf dbu))</span><br><span class="line">B((J mjlf dbu))-- 发送给好友 --&gt; C((J mjlf dbu))</span><br><span class="line">C((J mjlf dbu))-- 用1解密  --&gt; D[I like cat]</span><br></pre></td></tr></table></figure><h2 id="对称加密的问题"><a href="#对称加密的问题" class="headerlink" title="对称加密的问题"></a>对称加密的问题</h2><p>刚才的例子已经说了对称加密的流程，但是有一个问题需要解决，这个密码 <code>1</code> 我要怎么告诉我的好友呢？直接发消息被别人看到怎么办，打电话也有可能被别人窃听啊！</p><h2 id="密钥配送"><a href="#密钥配送" class="headerlink" title="密钥配送"></a>密钥配送</h2><p>这就涉及到了一个密钥配送的问题，如果想让对方解密就需要把密码发过去，但是密钥有可能被其他人窃取，这样秘密就不再是秘密了，可能你会想即使密码被别人窃取了也不要紧，因为他根本不知道怎么用。</p><p>请不要做这种假设，简单的情况没有密码都能破解，更何况在密码和数据都被窃取的情况下呢，另外在密码领域我们建议使用完全公开的密码算法，这样的算法经过时间的检验才能被用于加密，千万不要独创一套自认为很安全的加密算法，单靠隐藏算法的细节来达到加密的目的是很危险的。</p><p>发送密钥可能被窃取，不发送密钥对方无法解密，这个加密的密钥配送问题是使用对称加密必须要解决的，而下面要说的这种非对称就不同了，可以将一把密钥直接发送给对方，即使被窃取也没有关系。</p><h1 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h1><p>看这个名字就知道它有点“针对”那个叫做对称加密的小伙伴，从定义上来说对称加密指的是加密和解密使用相同的密钥（为啥不叫同钥加密咧），而非对称加密指的是加密和解密过程使用不同的密钥来进行。</p><p>乍一听好像有点不可思议啊，怎么滴，难道还能两把不同的钥匙开一把锁？确实可以！这有点像中学物理里面的两个开关控制一个灯泡。在一个漆黑的楼梯两端，分别有一个开关，控制着楼梯上方的一个灯泡，上楼前先打开楼梯下面的开关，然后上楼后关掉楼梯上面的开关，而下楼时进行相反的操作，先打开楼梯上面的开关，然后下楼后默认楼梯下面的开关，找了张电路图，感兴趣可以再分析一下。</p><p><img src="https://cdn.jsdelivr.net/gh/albertgithubhome/cdn/img/card/elecswitch.png" alt="单刀双掷开关"></p><p>不过非对称加密和这种双掷开关不完全相同，使用开关时可以在同一端打开或关闭，但是非对称加密时，只能在一端加密，然后在另一端解密，同一端是不能同时加密和解密的。</p><h2 id="公钥与私钥"><a href="#公钥与私钥" class="headerlink" title="公钥与私钥"></a>公钥与私钥</h2><p>具体地，非对称加密指的是根据特殊规则生成两把密钥 <code>A</code> 和 <code>B</code>，分别叫做公钥和私钥。私钥自己保留，公钥则分发给自己的小伙伴用来用来和自己通信，理论上生成的两把密钥选择哪一把作为私钥都可以，但是出于效率和安全等方面的要求，公钥和私钥再生成时会给出特殊的条件，所以在实际使用过程中，两者通常是不会互换的。</p><h2 id="非对称加密的示例"><a href="#非对称加密的示例" class="headerlink" title="非对称加密的示例"></a>非对称加密的示例</h2><p>使用公钥和私钥怎样完成非对称加密呢？下面来看一个具体的场景，比如有 Tom 、Jerry 、Spike 三个小伙伴，有一天 Jerry 想给 Tom 发点小秘密，又不想让 Spike 发现，首先他想到的是对称加密，先和 Tom 约定一个密码，再给 Tom 发送加密消息，但是想到前几天，自己和 Tom 的消息被 Spike 破解了，因为两个人发送密钥和加密消息的过程都被窃听了，如果这次的消息再被窃听到怎么办？</p><p>后来Jerry想起Tom曾经自己生成了一对公钥和私钥，然后把公钥发给了自己和 Spike，那这样就可以使用非对称加密了，Jerry 使用 Tom 给的公钥把要发送的小秘密进行加密，然后发送给了 Tom。这时 Spike 果然在窃听，但是窃听到的消息使用了 Tom 的公钥进行了加密，只有 Tom 拥有解开这条消息的私钥，而 Spike 虽然拥有 Tom 的公钥也是解不开的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">A[I like cat] -- Jerry用Tom公钥加密 --&gt; B((密文))</span><br><span class="line">B((密文))-- 发送给Tom --&gt; C((密文))</span><br><span class="line">C((密文))-- Tom用自己的私钥解密  --&gt; D[I like cat]</span><br></pre></td></tr></table></figure><h2 id="怎么判断解开"><a href="#怎么判断解开" class="headerlink" title="怎么判断解开"></a>怎么判断解开</h2><p>上面的描述中出现了“解开”一词，这两个字在我刚开始学习加密这些知识的时候困扰了我好久，查了好多讲解也没弄明白，什么叫能解开，什么叫解不开。它不像现实生活中的事物那么形象，比如把电视打开，那么电视就出现图像了，把锁解开门就能打开了。在数据加密的过程中，数据本质上是一堆二进制数据，加密之后还是一堆二进制数据，解密时使用密钥进行特定的运算就会得到解密后的二进制数据，怎么判定这些“解开”的数据是否是原数据呢？</p><p>后来在不断的学习过程中，接触了一些开源的非对称加密算法实现，比如常用的 RSA，基础的函数包括公钥加密、私钥解密、私钥加密、公钥解密等，当你在解密时将密文和密钥传入解密函数进行特定的运算，计算过程和计算结果必须满足特定的条件，这些条件是算法保证的，如果有条件不满足那么解密失败，这就是上面所提到的解不开。</p><h2 id="非对称加密的问题"><a href="#非对称加密的问题" class="headerlink" title="非对称加密的问题"></a>非对称加密的问题</h2><p>之前提到对称加密时，密钥配送问题是一个难题，因为网络上发送密钥很容易被截获，无法保证密钥不被窃取。很多情况下又不能面对面的传递密钥，而非对称加密的出现解决了这个问题，因为公钥是可以被任何人知道的，所以网络上发送公钥就不怕被窃取，但是如果例子中，Jerry 收到的 Tom 的公钥实际上在途中被 Spike 替换了怎么办？</p><p>这就又引入了一个问题——中间人攻击，形象的来表述就是有第三方 Spike 侵入了原本两个人 Tom 和 Jerry 的通信中，Spike 对 Tom 时把自己伪装成 Jerry，和 Jerry 沟通时又将自己伪装成 Tom，这样原本两个人的沟通信息全都被第三方窃取了，这个问题的根本就是获取公钥不可信，不过证书中心可以解决这个问题，后面我们再继续深入了解，这里就不展开了。</p><h1 id="对称加密和非对称加密对比"><a href="#对称加密和非对称加密对比" class="headerlink" title="对称加密和非对称加密对比"></a>对称加密和非对称加密对比</h1><table><thead><tr><th style="text-align:left">加密类型</th><th style="text-align:center">常见算法</th><th style="text-align:center">加密处理速度</th><th style="text-align:center">遇到的问题</th><th style="text-align:center">解决办法</th></tr></thead><tbody><tr><td style="text-align:left">对称加密</td><td style="text-align:center">DES、AES</td><td style="text-align:center">快</td><td style="text-align:center">密钥配送问题</td><td style="text-align:center">面对面交换或者使用非对称加密传送秘密</td></tr><tr><td style="text-align:left">非对称加密</td><td style="text-align:center">RSA、DSA</td><td style="text-align:center">慢</td><td style="text-align:center">中间人攻击问题</td><td style="text-align:center">通过证书中心来解决中间人攻击</td></tr></tbody></table><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>虽然想写的尽可能的通俗易懂，但还是不免会引入一些令人犯困的概念，一开始记住就好，后面理解了不会觉得枯燥</li><li>还在不断尝试表达方式，总结中融入了一些我当时学习时的想法和疑惑，我遇到的这些问题应该很多人也遇到过</li><li>使用对称加密方法，速度快，效率高，但是会面临密钥配送的问题</li><li>非对称加密虽然很巧妙的，但是效率较低，所以一般的用法是使用非对称加密来传送简短的对称加密密钥，然后再使用对称加密的方式传送数据</li><li>为了更好的加密你的数据，应使用公开的加密算法，他们都是经过时间考验的，单靠隐藏加密细节来加密时很危险的</li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/106448035" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>见过了外面的大千世界，便不再甘心留在原地，而这种不甘心恰恰就是动力~</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;进入正题之前先唠叨几句，不久前听到一个名词叫——费曼学习法，核心思想就是用通俗的话语把复杂道理或技术讲清楚，如果你已经明白了这个方法的含义，那么我好像离成功又进了一步。其实这个方法一直在尝试使用，但是没想到它居然有个“洋气”的名字。&lt;/p&gt;
    
    </summary>
    
      <category term="加密与认证" scheme="http://AlbertGithubHome.github.io/blog/categories/%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%AE%A4%E8%AF%81/"/>
    
    
      <category term="加密" scheme="http://AlbertGithubHome.github.io/blog/tags/%E5%8A%A0%E5%AF%86/"/>
    
      <category term="认证" scheme="http://AlbertGithubHome.github.io/blog/tags/%E8%AE%A4%E8%AF%81/"/>
    
      <category term="非对称加密" scheme="http://AlbertGithubHome.github.io/blog/tags/%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/"/>
    
      <category term="公钥" scheme="http://AlbertGithubHome.github.io/blog/tags/%E5%85%AC%E9%92%A5/"/>
    
      <category term="私钥" scheme="http://AlbertGithubHome.github.io/blog/tags/%E7%A7%81%E9%92%A5/"/>
    
  </entry>
  
  <entry>
    <title>git在回退版本时HEAD\~和HEAD^的作用和区别</title>
    <link href="http://AlbertGithubHome.github.io/blog/2020/05/30/git%E5%9C%A8%E5%9B%9E%E9%80%80%E7%89%88%E6%9C%AC%E6%97%B6HEAD%E2%80%A6-%E5%92%8CHEAD-%E7%9A%84%E4%BD%9C%E7%94%A8%E5%92%8C%E5%8C%BA%E5%88%AB/"/>
    <id>http://AlbertGithubHome.github.io/blog/2020/05/30/git在回退版本时HEAD…-和HEAD-的作用和区别/</id>
    <published>2020-05-29T16:39:59.000Z</published>
    <updated>2020-06-15T14:49:16.945Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>今天总结一个小知识点，虽然不难，但是对新手有很强的迷惑性，了解一下也挺好。我们在使用 Git 回退到版本的时候，可能见过这种写法 <code>git reset --hard HEAD~</code>，有时候也会遇到这种写法 <code>git reset --hard HEAD^</code>，这两个语句都是将代码库还原到上一个版本，但是只差了一个符号，他们究竟有什么区别呢？这里先给出结论：<code>HEAD~</code> 和 <code>HEAD^</code> 含义不同，功能一样！</p><a id="more"></a><h1 id="HEAD"><a href="#HEAD" class="headerlink" title="HEAD"></a>HEAD</h1><p><code>HEAD</code> 这个词在 <code>git</code> 使用过程中经常出现，作用很像是数据结构中指向二叉树根节点<code>root</code>的指针。有个 <code>root</code> 指针我们就可以对二叉树进行任意操作，它是二叉树的根基。而 <code>git</code> 中的 <code>HEAD</code> 概念也类似一个指针，它指向是当前分支的“头”，通过这个头节点可以追寻到当前分支之前的所有提交记录。</p><p><code>git</code> 的提交记录之间的关系很像一棵树，或者说是一张图，通过当前的提交记录指向上一次提交记录串联起来，形成一个头结构，而在 <code>git</code> 中我们常常说的切换分支，只不过是 <code>git</code> 客户端帮你把要操作的那条路径的头节点，存储到了 <code>HEAD</code> 文件中。</p><p><code>HEAD</code> 在 <code>git</code> 版本控制中代表头节点，也就是分支的最后一次提交，同时也是一个文件，通常在版本库中 <code>repository/.git/HEAD</code>，其中保存的一般是 <code>ref: refs/heads/master</code> 这种分支的名字，而本质上就是指向一次提交的 <code>hash</code> 值，一般长成这个样子 <code>ce11d9be5cc7007995b607fb12285a43cd03154b</code>。</p><h1 id="HEAD-和-HEAD"><a href="#HEAD-和-HEAD" class="headerlink" title="HEAD~ 和 HEAD^"></a>HEAD~ 和 HEAD^</h1><p>在 <code>HEAD</code> 后面加 <code>^</code> 或者 <code>~</code> 其实就是以 <code>HEAD</code> 为基准，来表示之前的版本，因为 <code>HEAD</code> 被认为是当前分支的最新版本，那么 <code>HEAD~</code> 和 <code>HEAD^</code> 都是指次新版本，也就是倒数第二个版本，<code>HEAD~~</code> 和 <code>HEAD^^</code> 都是指次次新版本，也就是倒数第三个版本，以此类推。</p><p>这个说法在之前的总结 <a href="https://blog.csdn.net/albertsh/article/details/104719370" target="_blank" rel="noopener">《git checkout/git reset/git revert/git restore常用回退操作》</a> 中提到过，但是并未展开说，今天就来测试一下。</p><h1 id="HEAD-后面-和-的区别"><a href="#HEAD-后面-和-的区别" class="headerlink" title="HEAD 后面 ~ 和 ^ 的区别"></a>HEAD 后面 ~ 和 ^ 的区别</h1><p>其实 <code>HEAD~</code> 和 <code>HEAD^</code> 的作用是相同的，这两者的区别出现在重复使用或者加数字的情况，下面来分情况说明一下。</p><h2 id="HEAD-和-HEAD-后面都加1"><a href="#HEAD-和-HEAD-后面都加1" class="headerlink" title="HEAD~ 和 HEAD^后面都加1"></a><code>HEAD~</code> 和 <code>HEAD^</code>后面都加1</h2><p>加上参数1之后变成了 <code>HEAD~1</code> 和 <code>HEAD^1</code>，其实这就是他们本来的面貌，在参数为 1 的情况下可以省略，<code>HEAD~1</code> 表示回退一步，参数1表示后退的步数，默认推到第一个父提交上，而<code>HEAD^1</code>表示后退一步，直接后退到第n个父提交上，数字1表示是第一个父提交。</p><p>这里引入一个父提交的概念，也就是在最新提交之前的最近的提交我称它为父提交，但是父提交会有两个吗？实际上会的，直接的父提交可能会有很多，分支合并是产生父提交的一种常见原因，两个分支合并到一起时，这两个分支的原 <code>HEAD</code> 都会成为合并后最新提交的父提交。</p><p>理解了这个概念，我们发现虽然数字是一样的，但是含义却不相同，<code>HEAD~1</code> 中指的是后退的步数，<code>HEAD^1</code>指的是退到第几个父提交上。</p><h2 id="HEAD-和-HEAD-后面都加0"><a href="#HEAD-和-HEAD-后面都加0" class="headerlink" title="HEAD~ 和 HEAD^后面都加0"></a><code>HEAD~</code> 和 <code>HEAD^</code>后面都加0</h2><p>这是一种比较特殊的情况， 加上参数0之后变成了 <code>HEAD~0</code> 和 <code>HEAD^0</code>，其实他们指向的节点没有改变，还是代表了 <code>HEAD</code>，只要了解这种情况就行了，我还没有见过谁这样写过。</p><h2 id="HEAD-和-HEAD-后面都加大于1的数字"><a href="#HEAD-和-HEAD-后面都加大于1的数字" class="headerlink" title="HEAD~ 和 HEAD^后面都加大于1的数字"></a><code>HEAD~</code> 和 <code>HEAD^</code>后面都加大于1的数字</h2><p>这时就会发现两者的不同了，比如我们把数字都定为2，那么 <code>HEAD~2</code> 代表后退两步，每一步都后退到第一个父提交上，而 <code>HEAD^2</code> 代表后退一步，这一步退到第二个父提交上，如果没有第二个父提交就会报出以下错误：</p><blockquote><p>fatal: ambiguous argument ‘HEAD^2’: unknown revision or path not in the working tree.<br>Use ‘–’ to separate paths from revisions, like this:<br>‘git <command> [<revision>…] – [<file>…]’</file></revision></p></blockquote><h1 id="具体示例"><a href="#具体示例" class="headerlink" title="具体示例"></a>具体示例</h1><p>上面说了几种加数字的情况，如果是第一次接触可能还是不太明白，没关系，我可以实际操作一下，看个具体的例子就明白了。</p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>下面是一个测试代码库的分支结构，一共有 <code>dev1</code>、<code>dev2</code>、<code>dev3</code>、<code>dev4</code> 四个分支，最终合并到 <code>dev1</code> 分支，提交记录如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc MINGW64 /d/gitstart (dev1)</span><br><span class="line">$ git alllog</span><br><span class="line">*   ce11d9b (HEAD -&gt; dev1) Merge branch <span class="string">'dev3'</span> into dev1</span><br><span class="line">|\</span><br><span class="line">| * e330eac (dev3) update at dev3 - 3</span><br><span class="line">| *   7ab3c98 Merge branch <span class="string">'dev4'</span> into dev3</span><br><span class="line">| |\</span><br><span class="line">| | * c8795e8 (dev4) update at dev4 - 2</span><br><span class="line">| | * 155d3db update at dev4 - 1</span><br><span class="line">| * | ccdf16a update at dev3 - 2</span><br><span class="line">| * | 9f08bb0 update at dev3 - 1</span><br><span class="line">| |/</span><br><span class="line">* | f82b57b update at dev1 - 3</span><br><span class="line">* |   dcdcb87 Merge branch <span class="string">'dev2'</span> into dev1</span><br><span class="line">|\ \</span><br><span class="line">| * | 32d6213 (dev2) update at dev2 - 2</span><br><span class="line">| * | ca4db4a update at dev2 - 1</span><br><span class="line">| |/</span><br><span class="line">| * d8d80b7 update readme at dev2</span><br><span class="line">* | 034ccb6 update readme at dev1 - 2</span><br><span class="line">* | d58fedc update readme at dev1 - 1</span><br></pre></td></tr></table></figure><p>也许有颜色标记会看得更清楚一些，所以截个图放在这：</p><p><img src="https://cdn.jsdelivr.net/gh/albertgithubhome/cdn/img/card/githead.png" alt="git_branch_head"></p><p>刚看这种图的时候要注意一点，记录列表中的先后关系不代表提交时间的先后，如果习惯于看SVN的记录以后，很容易在看日志信息时加上时间因素，但是这个时间因素在 <code>git</code> 查看记录时变得不再明显，比如上面记录中的 <code>e330eac</code> 在图形上要比 <code>f82b57b</code> 更接近 HEAD 提交 <code>ce11d9b</code>，但是因为处在不同的分支上，在合并之前他俩的修改时间还真不一定是哪个更早一些。</p><h2 id="树形记录"><a href="#树形记录" class="headerlink" title="树形记录"></a>树形记录</h2><p>在 <code>git</code> 的提交记录图上，我们可以确定当前提交的父提交（所依赖的提交）是哪一个或者哪几个，但是不能确定任意两个提交的时间先后，为了能更清楚的看清分支提交的依赖关系，还是看下面这个树形图更方便一些。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">graph TB</span><br><span class="line">    ce11d9b--&gt;f82b57b;</span><br><span class="line">    f82b57b--&gt;dcdcb87;</span><br><span class="line">    dcdcb87--&gt;034ccb6;</span><br><span class="line">    034ccb6--&gt;d58fedc;</span><br><span class="line">    d58fedc--&gt;dev1;</span><br><span class="line"></span><br><span class="line">    dcdcb87--&gt;32d6213;</span><br><span class="line">    32d6213--&gt;ca4db4a;</span><br><span class="line">    ca4db4a--&gt;dev2;</span><br><span class="line"></span><br><span class="line">    ce11d9b--&gt;e330eac;</span><br><span class="line">    e330eac--&gt;7ab3c98;</span><br><span class="line">    7ab3c98--&gt;ccdf16a;</span><br><span class="line">    ccdf16a--&gt;9f08bb0;</span><br><span class="line">    9f08bb0--&gt;dev3;</span><br><span class="line"></span><br><span class="line">    7ab3c98--&gt;c8795e8;</span><br><span class="line">    c8795e8--&gt;155d3db;</span><br><span class="line">    155d3db--&gt;dev4;</span><br></pre></td></tr></table></figure><h2 id="查看命令"><a href="#查看命令" class="headerlink" title="查看命令"></a>查看命令</h2><p>在验证 <code>HEAD~</code> 和 <code>HEAD^</code> 之前我们先学习一个命令 <code>git rev-parse HEAD</code> 这个命令可以显示出 <code>HEAD</code> 对应的提交的 hash 值，加上 <code>--short</code> 参数就可以显示出长度为7位的短 hash，用起来比较方便，测试如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc MINGW64 /d/gitstart (dev1)</span><br><span class="line">$ git rev-parse HEAD</span><br><span class="line">ce11d9be5cc7007995b607fb12285a43cd03154b</span><br><span class="line"></span><br><span class="line">albert@home-pc MINGW64 /d/gitstart (dev1)</span><br><span class="line">$ git rev-parse --short HEAD</span><br><span class="line">ce11d9b</span><br></pre></td></tr></table></figure><h2 id="开始测试"><a href="#开始测试" class="headerlink" title="开始测试"></a>开始测试</h2><p>下面可以用 <code>git rev-parse --short</code> 命令来测试 <code>HEAD</code> 后面跟不同参数时对应的提交是哪一个了，测试如下：</p><h3 id="HEAD-、HEAD-、HEAD-1、HEAD-1"><a href="#HEAD-、HEAD-、HEAD-1、HEAD-1" class="headerlink" title="HEAD~、HEAD^、HEAD~1、HEAD^1"></a><code>HEAD~</code>、<code>HEAD^</code>、<code>HEAD~1</code>、<code>HEAD^1</code></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc MINGW64 /d/gitstart (dev1)</span><br><span class="line">$ git rev-parse --short HEAD~</span><br><span class="line">f82b57b</span><br><span class="line"></span><br><span class="line">albert@home-pc MINGW64 /d/gitstart (dev1)</span><br><span class="line">$ git rev-parse --short HEAD^</span><br><span class="line">f82b57b</span><br><span class="line"></span><br><span class="line">albert@home-pc MINGW64 /d/gitstart (dev1)</span><br><span class="line">$ git rev-parse --short HEAD~1</span><br><span class="line">f82b57b</span><br><span class="line"></span><br><span class="line">albert@home-pc MINGW64 /d/gitstart (dev1)</span><br><span class="line">$ git rev-parse --short HEAD^1</span><br><span class="line">f82b57b</span><br></pre></td></tr></table></figure><p>测试后发现，这四种写法结果是一样的，都是指向 <code>HEAD</code> 的第一个父提交，这和我们前面说的观点一致。</p><h3 id="HEAD-、HEAD-、HEAD-2、HEAD-2"><a href="#HEAD-、HEAD-、HEAD-2、HEAD-2" class="headerlink" title="HEAD~~、HEAD^^、HEAD~2、HEAD^2"></a><code>HEAD~~</code>、<code>HEAD^^</code>、<code>HEAD~2</code>、<code>HEAD^2</code></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc MINGW64 /d/gitstart (dev1)</span><br><span class="line">$ git rev-parse --short HEAD~~</span><br><span class="line">dcdcb87</span><br><span class="line"></span><br><span class="line">albert@home-pc MINGW64 /d/gitstart (dev1)</span><br><span class="line">$ git rev-parse --short HEAD^^</span><br><span class="line">dcdcb87</span><br><span class="line"></span><br><span class="line">albert@home-pc MINGW64 /d/gitstart (dev1)</span><br><span class="line">$ git rev-parse --short HEAD~2</span><br><span class="line">dcdcb87</span><br><span class="line"></span><br><span class="line">albert@home-pc MINGW64 /d/gitstart (dev1)</span><br><span class="line">$ git rev-parse --short HEAD^2</span><br><span class="line">e330eac</span><br></pre></td></tr></table></figure><p>这次我们发现，前三个表示方法是一样的，指向同一个提交记录，但是最后一个与他们不同，这时根据前面提到定义来看就行了，<code>HEAD~~</code> 实际上是 <code>HEAD~1~1</code>的简写，而<code>~</code> 后的数字就是指的后退的步数，所以 <code>HEAD~~</code> 等价于 <code>HEAD~2</code>，属于一种合并计算。</p><p><code>HEAD^^</code> 是 <code>HEAD^1^1</code> 的简写，而 <code>^</code> 后面的数字表示后退一步到第几个父提交上，因为数字是1，所以 <code>HEAD^^</code> 表示退一步到第一个父提交上，在退一步到第一个父提交上，这时与 <code>HEAD~~</code> 的作用是相同的。</p><p><code>HEAD^2</code> 就有些不同了，它表示后退一步到第二个父提交上，所以对照树形图是第二排的第二个节点。</p><h3 id="和-混合使用"><a href="#和-混合使用" class="headerlink" title="~ 和 ^ 混合使用"></a>~ 和 ^ 混合使用</h3><p>看了上面的例子对于 <code>~</code> 和 <code>^</code> 的使用应该有些明白了，它俩其实可以组合使用的，比如想退到第5排、第2个节点上，也就是 <code>ca4db4a</code> 上，简单来看需要第一步到第一个父提交上，在退一步到第一个父提交上，然后退一步到第二个父提交上，最后退一步到第一个父提交上。</p><p>那么我们根据需求可以写成 <code>HEAD^1^1^2^1</code>，测试一下看看 hash 是否正确：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc MINGW64 /d/gitstart (dev1)</span><br><span class="line">$ git rev-parse --short HEAD^1^1^2^1</span><br><span class="line">ca4db4a</span><br></pre></td></tr></table></figure><p>测试发现没有问题，其实还可以合并啊，我们知道1是可以省略的，所以可以简写成 <code>HEAD^^^2^</code>，另外多个 <code>^</code> 还可以写成 <code>~n</code> 的形式，所以这个节点还可以表示成 <code>HEAD~2^2^</code>的样子，测试如下，结果是一样的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc MINGW64 /d/gitstart (dev1)</span><br><span class="line">$ git rev-parse --short HEAD^^^2^</span><br><span class="line">ca4db4a</span><br><span class="line"></span><br><span class="line">albert@home-pc MINGW64 /d/gitstart (dev1)</span><br><span class="line">$ git rev-parse --short HEAD~2^2^</span><br><span class="line">ca4db4a</span><br></pre></td></tr></table></figure><h3 id="关于-git-reset-的一点思考"><a href="#关于-git-reset-的一点思考" class="headerlink" title="关于 git reset 的一点思考"></a>关于 git reset 的一点思考</h3><p>刚学习 <code>git reset</code> 的命令时一直认为是一个回退命令，其实学习一段时间之后发现，这个命令其实很符合它的名字，就是一个重置(reset)命令，通过 <code>git reset</code> 命令可以修改 <code>HEAD</code> 指向不同的提交，这个提交甚至都不必是当前分支上的某次提交，测试后发现，只要是版本库中合法提交都可以使用这个命令进行设置，相应的版本库的内容也会发生对应的变化，从这一点来看，它真的太强大了，它可以使你正在开发的 <code>dev</code> 分支瞬间变成 <code>master</code> 分支。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li><code>HEAD~</code> 后面加数字表示后退的步数，每次后退都默认退到第一个父提交上，<code>HEAD~2</code> 表示连退两步。</li><li><code>HEAD^</code> 后面加数字表示只退一步，但是这一步后退到数字表示的父提交上，<code>HEAD^2</code> 表示退一步到第二个父提交上。</li><li><code>git</code> 在查看多分支提交记录时，日志的先后顺序不代表提交时间的先后顺序。</li><li><code>git reset</code> 命令是一个重置 <code>HEAD</code> 的命令，可以指挥版本库指向任何一个合法提交。</li></ul><hr><blockquote><p>俗话说：人不犯我，我不犯人；可俗话又说：先下手为强，后下手遭殃！<br>俗话说：宁为玉碎，不为瓦全；可俗话又说：留得青山在，不怕没柴烧！<br>…<br>其实只要你变成了那个成功的“俗话”，你说的就是金科玉律，警世哲理！</p><p>2020-5-31 14:51:49</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;今天总结一个小知识点，虽然不难，但是对新手有很强的迷惑性，了解一下也挺好。我们在使用 Git 回退到版本的时候，可能见过这种写法 &lt;code&gt;git reset --hard HEAD~&lt;/code&gt;，有时候也会遇到这种写法 &lt;code&gt;git reset --hard HEAD^&lt;/code&gt;，这两个语句都是将代码库还原到上一个版本，但是只差了一个符号，他们究竟有什么区别呢？这里先给出结论：&lt;code&gt;HEAD~&lt;/code&gt; 和 &lt;code&gt;HEAD^&lt;/code&gt; 含义不同，功能一样！&lt;/p&gt;
    
    </summary>
    
      <category term="Git" scheme="http://AlbertGithubHome.github.io/blog/categories/Git/"/>
    
    
      <category term="版本控制" scheme="http://AlbertGithubHome.github.io/blog/tags/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"/>
    
      <category term="Git" scheme="http://AlbertGithubHome.github.io/blog/tags/Git/"/>
    
      <category term="HEAD" scheme="http://AlbertGithubHome.github.io/blog/tags/HEAD/"/>
    
      <category term="reset" scheme="http://AlbertGithubHome.github.io/blog/tags/reset/"/>
    
  </entry>
  
  <entry>
    <title>配置Beyond Compare 4作为git mergetool来解决git merge命令导致的文件冲突</title>
    <link href="http://AlbertGithubHome.github.io/blog/2020/05/21/%E9%85%8D%E7%BD%AEBeyond-Compare-4%E4%BD%9C%E4%B8%BAgit-mergetool%E6%9D%A5%E8%A7%A3%E5%86%B3git-merge%E5%91%BD%E4%BB%A4%E5%AF%BC%E8%87%B4%E7%9A%84%E6%96%87%E4%BB%B6%E5%86%B2%E7%AA%81/"/>
    <id>http://AlbertGithubHome.github.io/blog/2020/05/21/配置Beyond-Compare-4作为git-mergetool来解决git-merge命令导致的文件冲突/</id>
    <published>2020-05-21T15:31:49.000Z</published>
    <updated>2020-05-22T16:48:27.315Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>使用 <code>git merge</code> 命令合并代码的时候可能会产生文件冲突，产生这种冲突的根本原因是文件的同一处同时被多次修改，这种同时修改常体现的不同分支上，当多个分支修改了同一处代码，再合并代码的时候就会产生冲突，因为 <code>git</code> 程序也不知道我们想要保留哪一份修改，这时就需要我们手动修改产生冲突的文件。</p><p>当冲突内容很少的时候我们可以打开文本编辑器，找到 <code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code>、<code>===========</code> 和 <code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code> 这三行字符包裹的内容就是需要解决冲突的部分，但是当冲突内容特别多时我们还是习惯于通过可视化的工具来处理，<code>Beyond Compare</code> 就是这样一款工具，可以用来比较不同的文本文件、表格文件，还可以比较文件夹内容，之前用着比较习惯，所以在处理 <code>git</code> 冲突的时候也想使用这个工具来做，通过查找技术文档发现了下面的方法。</p><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p>鉴于大家都比较急，查找问题时想要直接找到答案，所以我这里直接说明配置步骤，送给不求甚解的小伙伴，也方便今后我可以直接找到，不过配置之前还是要先看一下前提。</p><h2 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h2><ul><li>在 Windows 上安装了 <code>git</code> 客户端，可以执行 <code>git</code> 命令（废话！没装 <code>git</code> 怎么产生冲突的）</li><li>安装了 <code>Beyond Compare 4</code> 这个软件，下载链接很多，自己找一个吧，实在找不到，那就放弃吧（找我要）</li></ul><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>首先找到 <code>Beyond Compare</code> 的安装路径，比如我的软件安装路径是 <code>D:\mybc4\BComp.exe</code>，然后在 <code>git</code> 命令行客户端中执行下面命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git config --global merge.tool bc4</span><br><span class="line">git config --global mergetool.bc4.cmd <span class="string">"\"D:\\mybc4\\BComp.exe\" \"\$LOCAL\" \"\$REMOTE\" \"\$BASE\" \"\$MERGED\""</span></span><br><span class="line">git config --global mergetool.bc4.trustExitCode <span class="literal">true</span></span><br><span class="line">git config --global mergetool.keepBackup <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>至此，<code>git mergetool</code> 就配置完了，当下次冲突的时候，直接使用 <code>git mergetool</code> 命令就可以调用 <code>Beyond Compare</code> 解决冲突文件了，但是你不好奇，这些设置命令都是什么意思吗？为什么执行完这些命令就能调用 <code>Beyond Compare 4</code> 这个软件了，如果你感兴趣可以接下往下看一看。</p><h1 id="Beyond-Compare"><a href="#Beyond-Compare" class="headerlink" title="Beyond Compare"></a>Beyond Compare</h1><p>这是一款强大的比较工具，前面提到它可以比较文本、比较表格、比较文件夹，但是它的能力不仅限于此，它甚至可以比较MP3、比较图片、比较注册表，我们的目的是调用它的比较功能，但是前提是这款软件允许你调用，如果它不给你提供接口，你就是想调用也得绕上八百个圈才可以。</p><p>这一点我们可以查询文档确定，文档是安装软件时自带的，名字为 <code>BCompare.chm</code>，如果找不到，安利你一个叫做 <code>Everything</code> 的软件，装上它以后，电脑中的一切东西都能搜索找到。</p><p>这个文档应该很容易找到的，与软件的可执行文件在同一目录，其实我们使用的比较工具应该是 <code>BCompare.exe</code>，但是为什么在配置 <code>git mergetool</code> 的是后用的是 <code>BComp.exe</code> 呢？这一点文档中有写：</p><blockquote><p>BCompare.exe: This is the main application.  Only one copy will run at a time, regardless of how many windows you have open.  If you launch a second copy it will tell the existing copy to start a comparison and exit immediately.<br>BComp.exe: This is a Win32 GUI program.  If launched from a version control system, it should work just fine.  If launched from a console window, the console (or batch file) will not wait for it.</p></blockquote><p>文档是英文的，但是比较容易理解，总的来说 <code>BCompare.exe</code> 是主程序，<code>BComp.exe</code> 用在版本控制工具中更加优秀，至于文档中提到的主程序只能启动一个副本的说明，我试了一下并不是这样的，但是这不是重点，根据文档建议，我们应该调用 <code>BComp.exe</code> 程序。</p><p>关于调用参数，文档中对于每种形式的比较也给出了说明，我们这里只列举两个文件和四个文件这两种参数，两个文件作为参数时常用来对比，我直接使用主程序对比文件就是这种形式，参数格式为 <code>BCompare.exe &quot;C:\Left File.ext&quot; &quot;C:\Right File.ext&quot;</code>，但是使用时我常把文件直接拖拽到软件上进行比较。四个文件作为参数时常用来处理文件冲突，参数类型为 <code>BCompare.exe C:\Left.ext C:\Right.ext C:\Center.ext C:\Output.ext</code>，参数中文件的名字表明处理时的位置和作用，看下面这个图就明白了。</p><p><img src="https://cdn.jsdelivr.net/gh/albertgithubhome/cdn/img/card/bc4_cmp.png" alt="解决文件合并冲突1"></p><p>从红框圈定的位置就可以发现和文件的对应关系了，最下面是最终的输出文件，也是我们可以手动修改的文件。</p><h1 id="文件冲突及处理"><a href="#文件冲突及处理" class="headerlink" title="文件冲突及处理"></a>文件冲突及处理</h1><h2 id="产生冲突"><a href="#产生冲突" class="headerlink" title="产生冲突"></a>产生冲突</h2><p>先看一下 <code>git</code> 仓库的原始情况</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc MINGW64 /d/gitstart (dev)</span><br><span class="line">$ git status</span><br><span class="line">On branch dev</span><br><span class="line">Your branch is up to date with <span class="string">'origin/dev'</span>.</span><br><span class="line"></span><br><span class="line">nothing to commit, working tree clean</span><br><span class="line"></span><br><span class="line">albert@home-pc MINGW64 /d/gitstart (dev)</span><br><span class="line">$ ls</span><br><span class="line">README.md</span><br><span class="line"></span><br><span class="line">albert@home-pc MINGW64 /d/gitstart (dev)</span><br><span class="line">$ cat README.md</span><br><span class="line">learn git branch <span class="built_in">command</span></span><br><span class="line">m2</span><br><span class="line"><span class="built_in">test</span> checkout</span><br></pre></td></tr></table></figure><p>在此基础上新建两个分支 <code>dev1</code> 和 <code>dev2</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc MINGW64 /d/gitstart (dev)</span><br><span class="line">$ git checkout -b dev1</span><br><span class="line">Switched to a new branch <span class="string">'dev1'</span></span><br><span class="line"></span><br><span class="line">albert@home-pc MINGW64 /d/gitstart (dev1)</span><br><span class="line">$ git checkout -b dev2</span><br><span class="line">Switched to a new branch <span class="string">'dev2'</span></span><br><span class="line"></span><br><span class="line">albert@home-pc MINGW64 /d/gitstart (dev2)</span><br><span class="line">$ git branch | grep dev</span><br><span class="line">  dev</span><br><span class="line">  dev1</span><br><span class="line">* dev2</span><br></pre></td></tr></table></figure><p>在 <code>dev2</code> 分支上修改 <code>README.md</code> 文件后提交</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc MINGW64 /d/gitstart (dev2)</span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">"this is dev2 test"</span>&gt;&gt;README.md</span><br><span class="line"></span><br><span class="line">albert@home-pc MINGW64 /d/gitstart (dev2)</span><br><span class="line">$ git add README.md</span><br><span class="line">warning: LF will be replaced by CRLF <span class="keyword">in</span> README.md.</span><br><span class="line">The file will have its original line endings <span class="keyword">in</span> your working directory</span><br><span class="line"></span><br><span class="line">albert@home-pc MINGW64 /d/gitstart (dev2)</span><br><span class="line">$ git commit -m<span class="string">"update readme at dev2"</span></span><br><span class="line">[dev2 d8d80b7] update readme at dev2</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line"></span><br><span class="line">albert@home-pc MINGW64 /d/gitstart (dev2)</span><br><span class="line">$ cat README.md</span><br><span class="line">learn git branch <span class="built_in">command</span></span><br><span class="line">m2</span><br><span class="line"><span class="built_in">test</span> checkout</span><br><span class="line">this is dev2 <span class="built_in">test</span></span><br></pre></td></tr></table></figure><p>切换回 <code>dev1</code> 分支修改 <code>README.md</code> 文件后提交</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc MINGW64 /d/gitstart (dev2)</span><br><span class="line">$ git checkout dev1</span><br><span class="line">Switched to branch <span class="string">'dev1'</span></span><br><span class="line"></span><br><span class="line">albert@home-pc MINGW64 /d/gitstart (dev1)</span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">"this is dev1 test"</span>&gt;&gt;README.md</span><br><span class="line"></span><br><span class="line">albert@home-pc MINGW64 /d/gitstart (dev1)</span><br><span class="line">$ git add README.md</span><br><span class="line">warning: LF will be replaced by CRLF <span class="keyword">in</span> README.md.</span><br><span class="line">The file will have its original line endings <span class="keyword">in</span> your working directory</span><br><span class="line">git com -</span><br><span class="line">albert@home-pc MINGW64 /d/gitstart (dev1)</span><br><span class="line">$ git commit -m<span class="string">"update readme at dev1"</span></span><br><span class="line">[dev1 3136341] update readme at dev1</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line"></span><br><span class="line">albert@home-pc MINGW64 /d/gitstart (dev1)</span><br><span class="line">$ cat README.md</span><br><span class="line">learn git branch <span class="built_in">command</span></span><br><span class="line">m2</span><br><span class="line"><span class="built_in">test</span> checkout</span><br><span class="line">this is dev1 <span class="built_in">test</span></span><br></pre></td></tr></table></figure><p>这时在 <code>dev1</code> 分支上合并 <code>dev2</code> 分支上的修改就会产生冲突</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc MINGW64 /d/gitstart (dev1)</span><br><span class="line">$ git merge dev2</span><br><span class="line">Auto-merging README.md</span><br><span class="line">CONFLICT (content): Merge conflict <span class="keyword">in</span> README.md</span><br><span class="line">Automatic merge failed; fix conflicts and <span class="keyword">then</span> commit the result.</span><br><span class="line"></span><br><span class="line">albert@home-pc MINGW64 /d/gitstart (dev1|MERGING)</span><br><span class="line">$ cat README.md</span><br><span class="line">learn git branch <span class="built_in">command</span></span><br><span class="line">m2</span><br><span class="line"><span class="built_in">test</span> checkout</span><br><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span><br><span class="line">this is dev1 <span class="built_in">test</span></span><br><span class="line">=======</span><br><span class="line">this is dev2 <span class="built_in">test</span></span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; dev2</span><br><span class="line"></span><br><span class="line">albert@home-pc MINGW64 /d/gitstart (dev1|MERGING)</span><br><span class="line">$ ls</span><br><span class="line">README.md</span><br></pre></td></tr></table></figure><p>冲突产生了，文档中同一位置被两个分支修改后合并导致的，内容里出现了 <code>&lt;&lt;&lt;</code>、<code>===</code>、<code>&gt;&gt;&gt;</code>，包裹的内容被分成了两部分，上面一部分是当前分支修改的，下面一部分是从 <code>dev2</code> 分支合并过来的，还要注意虽然产生了产生了冲突，但是目录中并没有产生其他多余的文件。</p><h2 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h2><p>这样的冲突比较简单，我们只要使用文本工具删除不想要的内容，保存后 <code>git add README.md</code>，然后再 <code>git commit</code> 就完成了冲突的解决，但是因为配置了 <code>git mergetool</code>，我们可以用它来解决冲突，直接在命令行敲命令 <code>git mergetool</code> 就可以:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc MINGW64 /d/gitstart (dev1|MERGING)</span><br><span class="line">$ git mergetool</span><br><span class="line">Merging:</span><br><span class="line">README.md</span><br><span class="line"></span><br><span class="line">Normal merge conflict <span class="keyword">for</span> <span class="string">'README.md'</span>:</span><br><span class="line">  &#123;<span class="built_in">local</span>&#125;: modified file</span><br><span class="line">  &#123;remote&#125;: modified file</span><br></pre></td></tr></table></figure><p>这时光标不会退出，一闪一闪并且打开 <code>BComp.exe</code> 工具，截图如下：</p><p><img src="https://cdn.jsdelivr.net/gh/albertgithubhome/cdn/img/card/bc4_save.png" alt="解决文件合并冲突2"></p><p>这时如果你打开 <code>git</code> 库所在目录会发现除了 <code>README.md</code> 还多了下面4个文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">README.md</span><br><span class="line">README_BACKUP_584.md</span><br><span class="line">README_BASE_584.md</span><br><span class="line">README_LOCAL_584.md</span><br><span class="line">README_REMOTE_584.md</span><br></pre></td></tr></table></figure><p>按照自己的实际情况修改最下面的文件，然后点击箭头所指的保存按钮，关闭 <code>Beyond Compare</code>，查询一下仓库状态</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc MINGW64 /d/gitstart (dev1|MERGING)</span><br><span class="line">$ git status</span><br><span class="line">On branch dev1</span><br><span class="line">All conflicts fixed but you are still merging.</span><br><span class="line">  (use <span class="string">"git commit"</span> to conclude merge)</span><br><span class="line"></span><br><span class="line">Changes to be committed:</span><br><span class="line">        modified:   README.md</span><br><span class="line"></span><br><span class="line">albert@home-pc MINGW64 /d/gitstart (dev1|MERGING)</span><br><span class="line">$ ls</span><br><span class="line">README.md</span><br></pre></td></tr></table></figure><p>不但冲突文件没有了，还给我们自动执行 <code>git add README.md</code> 命令，我们只需要执行 <code>git commit</code> 就解决完了冲突。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc MINGW64 /d/gitstart (dev1|MERGING)</span><br><span class="line">$ git commit</span><br><span class="line">[dev1 b348ae6] Merge branch <span class="string">'dev2'</span> into dev1</span><br><span class="line"></span><br><span class="line">albert@home-pc MINGW64 /d/gitstart (dev1)</span><br><span class="line">$ git adog</span><br><span class="line">*   b348ae6 (HEAD -&gt; dev1) Merge branch <span class="string">'dev2'</span> into dev1</span><br><span class="line">|\</span><br><span class="line">| * d8d80b7 (dev2) update readme at dev2</span><br><span class="line">* | 3136341 update readme at dev1</span><br><span class="line">|/</span><br><span class="line">* 5f4181e (origin/dev, dev) add comments</span><br></pre></td></tr></table></figure><h1 id="工具配置的参数含义"><a href="#工具配置的参数含义" class="headerlink" title="工具配置的参数含义"></a>工具配置的参数含义</h1><p>回过头来再看看 <code>git mergetool</code> 的4句配置到底有什么用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git config --global merge.tool bc4</span><br><span class="line">git config --global mergetool.bc4.cmd <span class="string">"\"D:\\mybc4\\BComp.exe\" \"\$LOCAL\" \"\$REMOTE\" \"\$BASE\" \"\$MERGED\""</span></span><br><span class="line">git config --global mergetool.bc4.trustExitCode <span class="literal">true</span></span><br><span class="line">git config --global mergetool.keepBackup <span class="literal">false</span></span><br></pre></td></tr></table></figure><h2 id="git-config"><a href="#git-config" class="headerlink" title="git config"></a>git config</h2><p>首先你需要知道 <code>git config</code> 的作用，就是用来配置 <code>git</code> 的，加上了 <code>--global</code> 表示调整全局 <code>git</code> 配置，不加的话就是调整当前库的 <code>git</code> 配置。windows上的全局配置一般在 <code>C:\Users\用户名\.gitconfig</code>，如果你之前用过 <code>git</code>，一般会执行过 <code>git config --global user.name xxx</code> 对吧，这些命令都是来调整 <code>git</code> 配置的，打开这个 <code>.gitconfig</code> 你会看到</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[user]</span><br><span class="line">    name = albert</span><br><span class="line">    email = albert@163.com</span><br><span class="line">[core]</span><br><span class="line">    autocrlf = true</span><br><span class="line">[alias]</span><br><span class="line">    st = status</span><br><span class="line">    adog = &quot;log --all --decorate --oneline --graph&quot;</span><br><span class="line">[merge]</span><br><span class="line">    tool = bc4</span><br><span class="line">[mergetool &quot;bc4&quot;]</span><br><span class="line">    cmd = \&quot;D:\\mybc4\\BComp.exe\&quot; \&quot;$LOCAL\&quot; \&quot;$REMOTE\&quot; \&quot;$BASE\&quot; \&quot;$MERGED\&quot;</span><br><span class="line">    trustExitCode = true</span><br><span class="line">[mergetool]</span><br><span class="line">    keepBackup = false</span><br></pre></td></tr></table></figure><p>看看最后几行就是我们添加的4项配置，只不过到文件中变成了键值对的形式，经过测试后发现，这些属性最少两级，比如 <code>user.name</code> 、<code>core.autocrlf</code>，最多三级比如 <code>mergetool.bc4.cmd</code>、 <code>mergetool.bc4.trustExitCode</code>，如果级数再多会怎么办，你可以试试 <code>git config --global a.b.c.d.e test</code>，它最终也会被拆成三级如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[a &quot;b.c.d&quot;]</span><br><span class="line">    e = test</span><br></pre></td></tr></table></figure><h2 id="git-mergetool"><a href="#git-mergetool" class="headerlink" title="git mergetool"></a>git mergetool</h2><p>这个需要查一下官方文档了，<code>git mergetool --help</code> 就能打开<a href="https://git-scm.com/docs" target="_blank" rel="noopener">git官方文档</a>，文档写得真不错，排版格式看着就很舒服。</p><p>文档提到添加 <code>--tool-help</code> 选项可以列举可以的合并工具，展示如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc MINGW64 /d/gitstart (dev1)</span><br><span class="line">$ git mergetool --tool-help</span><br><span class="line"><span class="string">'git mergetool --tool=&lt;tool&gt;'</span> may be <span class="built_in">set</span> to one of the following:</span><br><span class="line">                vimdiff</span><br><span class="line">                vimdiff2</span><br><span class="line">                vimdiff3</span><br><span class="line"></span><br><span class="line">        user-defined:</span><br><span class="line">                bc4.cmd <span class="string">"D:\Program Files\Beyond Compare 4\BComp.exe"</span> <span class="string">"<span class="variable">$LOCAL</span>"</span> <span class="string">"<span class="variable">$REMOTE</span>"</span> <span class="string">"<span class="variable">$BASE</span>"</span> <span class="string">"<span class="variable">$MERGED</span>"</span></span><br><span class="line"></span><br><span class="line">The following tools are valid, but not currently available:</span><br><span class="line">                araxis</span><br><span class="line">                bc</span><br><span class="line">                bc3</span><br><span class="line">                codecompare</span><br><span class="line">                deltawalker</span><br><span class="line">                diffmerge</span><br><span class="line">                diffuse</span><br><span class="line">                ecmerge</span><br><span class="line">                emerge</span><br><span class="line">                examdiff</span><br><span class="line">                guiffy</span><br><span class="line">                gvimdiff</span><br><span class="line">                gvimdiff2</span><br><span class="line">                gvimdiff3</span><br><span class="line">                kdiff3</span><br><span class="line">                meld</span><br><span class="line">                opendiff</span><br><span class="line">                p4merge</span><br><span class="line">                smerge</span><br><span class="line">                tkdiff</span><br><span class="line">                tortoisemerge</span><br><span class="line">                winmerge</span><br><span class="line">                xxdiff</span><br><span class="line"></span><br><span class="line">Some of the tools listed above only work <span class="keyword">in</span> a windowed</span><br><span class="line">environment. If run <span class="keyword">in</span> a terminal-only session, they will fail.</span><br></pre></td></tr></table></figure><p>这一查才发现，原来 <code>git mergetool</code> 支持的工具有这么多，不过下面这些我都没安装，用一下上面列举的3个，试试 <code>git mergetool --tool=vimdiff</code>，果然打开了一个界面</p><p><img src="https://cdn.jsdelivr.net/gh/albertgithubhome/cdn/img/card/bc4_vimdiff.png" alt="解决文件合并冲突3"></p><p>幸亏不如 <code>Beyond Compare</code> 好用，不然我不是白配置了，不过这些工具确实方便，都不需要配置，只要安装了参数中指定一下就可以用了，比如这个 <code>bc3</code>，我猜它是 <code>Beyond Compare 3</code>，只不过我安装的是 <code>Beyond Compare 4</code> 这个版本。</p><p>这些内置工具使用的前提是已经安装了，并且安装软件的目录放在了环境变量 <code>Path</code> 中，如果没有放在这个变量中需要通过 <code>mergetool.&lt;tool&gt;.path</code> 参数来配置，比如我把 <code>Beyond Compare 3</code> 安装在了 <code>D</code> 盘根目录，就可以设置 <code>git config --global mergetool.bc3.path &quot;D:\\&quot;</code>。</p><p>我们在可用工具中没有找到 <code>Beyond Compare 4</code> 为什么我们可以用呢？因为 <code>git mergetool</code> 命令还支持自定义合并解决冲突的工具，只要指定 <code>mergetool.&lt;tool&gt;.cmd</code> 就可以调用了，就像 <code>git mergetool --tool-help</code> 查询结果中提到的 <code>user-defined: bc4.cmd &quot;D:\Program Files\Beyond Compare 4\BComp.exe&quot; &quot;$LOCAL&quot; &quot;$REMOTE&quot; &quot;$BASE&quot; &quot;$MERGED&quot;</code>，<code>git mergetool</code> 把 <code>bc4</code> 作为了一个等同于内置合并工具的软件。</p><p>再来看看这4句配置的含义：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git config --global merge.tool bc4</span><br><span class="line">git config --global mergetool.bc4.cmd <span class="string">"\"D:\\mybc4\\BComp.exe\" \"\$LOCAL\" \"\$REMOTE\" \"\$BASE\" \"\$MERGED\""</span></span><br><span class="line">git config --global mergetool.bc4.trustExitCode <span class="literal">true</span></span><br><span class="line">git config --global mergetool.keepBackup <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>第一句 <code>git config --global merge.tool bc4</code> 是说把 <code>git mergetool</code> 的默认工具配置成 <code>bc4</code>，如果不指定默认工具在使用时就需要写成 <code>git mergetool --tool=bc4</code> 或者 <code>git mergetool -t bc4</code> 了，可是 <code>bc4</code> 是我们自己起的名字，根本就没有这个名字啊，接着往下看。</p><p>第二句 <code>git config --global mergetool.bc4.cmd &quot;\&quot;D:\\mybc4\\BComp.exe\&quot; \&quot;\$LOCAL\&quot; \&quot;\$REMOTE\&quot; \&quot;\$BASE\&quot; \&quot;\$MERGED\&quot;&quot;</code> 指定了工具 <code>bc4</code> 的调用路径和参数，后面的这4个参数都是 <code>git mergetool</code> 命令提供的，依次代表本地修改，被合并分支修改，两端未修改前版本文件，最终合并导出的文本文件。</p><p>第三句 <code>git config --global mergetool.bc4.trustExitCode true</code>， 设置为 <code>true</code> 表示信任软件的返回码，并依据返回码确定合并是否成功，如果设置成 <code>false</code> 就会在合并完成后问你是否解决完冲突，设置成 <code>true</code> 会方便很多。</p><p>第四句 <code>git config --global mergetool.keepBackup false</code>， 是指定在合并完成后删除备份文件 <code>*.orig</code>，这个文件会在调用 <code>git mergetool</code> 是产生 <code>*.orig</code> 备份文件，成功合并后自动删除就可以了。</p><h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><p>至此终于弄明白这个 <code>git mergetool</code> 是怎么工作的了，但是想这样一个问题，这个 <code>&lt;tool&gt;.cmd</code> 一定得调用冲突解决工具吗？如果你从头看到这里应该会明白，这里只是给用户提供了一个调用自定义工具的方式，至于你调用什么它是不关心的，你完全可以在 <code>git mergetool</code> 的时候让电脑关机，这些都是可以的，在你明白了原理以后，一切都变得简单了。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li><code>Beyond Compare</code> 是一款强大的比较工具，合理的使用可以有效的提升工作效率</li><li><code>git mergetool</code> 内置了很多可以使用的合并工具，并且支持调用自定义的合并工具</li><li><code>git</code> 的官方文档写得真的挺详细，有时间可以多看一看，你会发现很多有意思的功能</li><li>急于解决问题时可以不求甚解，解决问题后最好可以明白其中的缘由，这其实就是一种进步</li></ul><hr><blockquote><p>尽管科技很发达，但有些人一旦分开可能真的就是一生不见了</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;使用 &lt;code&gt;git merge&lt;/code&gt; 命令合并代码的时候可能会产生文件冲突，产生这种冲突的根本原因是文件的同一处同时被多次修改
      
    
    </summary>
    
      <category term="Git" scheme="http://AlbertGithubHome.github.io/blog/categories/Git/"/>
    
    
      <category term="git" scheme="http://AlbertGithubHome.github.io/blog/tags/git/"/>
    
      <category term="工具" scheme="http://AlbertGithubHome.github.io/blog/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="mergetool" scheme="http://AlbertGithubHome.github.io/blog/tags/mergetool/"/>
    
      <category term="文件冲突" scheme="http://AlbertGithubHome.github.io/blog/tags/%E6%96%87%E4%BB%B6%E5%86%B2%E7%AA%81/"/>
    
      <category term="bc4" scheme="http://AlbertGithubHome.github.io/blog/tags/bc4/"/>
    
  </entry>
  
  <entry>
    <title>使用c++filt命令还原C++编译后的函数名</title>
    <link href="http://AlbertGithubHome.github.io/blog/2020/05/16/%E4%BD%BF%E7%94%A8c-filt%E5%91%BD%E4%BB%A4%E8%BF%98%E5%8E%9FC-%E7%BC%96%E8%AF%91%E5%90%8E%E7%9A%84%E5%87%BD%E6%95%B0%E5%90%8D/"/>
    <id>http://AlbertGithubHome.github.io/blog/2020/05/16/使用c-filt命令还原C-编译后的函数名/</id>
    <published>2020-05-16T13:22:43.000Z</published>
    <updated>2020-05-17T03:22:00.538Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这个命令功能单一，但是非常强大，可以用来还原C++编译后的函数名，为什么C++的函数名需要单独的命令来还原，因为他们看起来都是这样 <code>_ZNK4Json5ValueixEPKc</code>、这样 <code>_Z41__static_initialization_and_destruction_0ii</code> 或者这样的 <code>_ZN6apsara5pangu15ScopedChunkInfoINS0_12RafChunkInfoEED1Ev</code>，仅通过这一串字母很难知道原函数的名字是什么，参数类型就更难分析了，实际上C++在编译函数时有一套命名函数的规则，每种参数使用什么字母表示都是有约定的，但是通过学习这些约定来还原函数太麻烦了，还好有人编写了 <code>c++filt</code> 命令可以让我们直接得到编译前的函数名，真好……</p><h1 id="C-编译后的函数名"><a href="#C-编译后的函数名" class="headerlink" title="C++编译后的函数名"></a>C++编译后的函数名</h1><p><code>C++</code> 编译后的函数名字非常古怪，相比而言 <code>C</code> 语言编译后的函数看起来就正常许多了，<code>extern &quot;C&quot;</code>、函数重载、<code>name mangling</code> 这些知识点都与 <code>C++</code> 这个奇怪的函数名有些关系，<code>extern &quot;C&quot;</code> 的作用简而言之就是告诉编译器和链接器被“我”修饰的变量和函数需要按照 <code>C</code> 语言方式进行编译和链接，这样做是由于 <code>C++</code> 支持函数重载，而 <code>C</code> 语言不支持，结果导致函数被 <code>C++</code> 编译后在符号库中的名字和被 <code>C</code>语言编译后的名字是不一样的，程序编译和连接就会出现问题，此类问题一般出现在 <code>C++</code> 代码调用 <code>C</code> 语言写的库函数的时候。</p><p>而 <code>name mangling</code> 就是实现 <code>C++</code> 函数重载的一种技术或者叫做方式，要求同名的 <code>C++</code> 函数参数个数不同或参数类型不同，如果只有返回值类型不同，那么两个函数被认为是相同的函数，无法成功通过编译。接下来我们就来看几个例子，看看 <code>C++</code> 编译后的函数名有什么变化。</p><h2 id="C-和C语言编译后的函数名对比"><a href="#C-和C语言编译后的函数名对比" class="headerlink" title="C++和C语言编译后的函数名对比"></a>C++和C语言编译后的函数名对比</h2><p>我们来写一段相同的代码，分别使用 <code>gcc</code> 和 <code>g++</code> 进行编译，从代码到可执行文件需要经历“预处理、编译、汇编、链接”4个步骤，接下来为了看到编译后函数名的不同，我们只进行前两步，生成汇编代码，再来比较不同。</p><h3 id="gcc编译simple-c文件"><a href="#gcc编译simple-c文件" class="headerlink" title="gcc编译simple.c文件"></a>gcc编译simple.c文件</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// simple.c</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">myadd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">110</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">119</span>;</span><br><span class="line">    <span class="keyword">int</span> c = myadd(a, b);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>gcc simple.c -S</code> 生成汇编代码文件simple.s内容</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">    .file   <span class="string">"simple.c"</span></span><br><span class="line">    .text</span><br><span class="line">    .globl  myadd</span><br><span class="line">    .type   myadd, @function</span><br><span class="line">myadd:</span><br><span class="line">.LFB0:</span><br><span class="line">    .cfi_startproc</span><br><span class="line">    pushq   %rbp</span><br><span class="line">    .cfi_def_cfa_offset <span class="number">16</span></span><br><span class="line">    .cfi_offset <span class="number">6</span>, <span class="number">-16</span></span><br><span class="line">    movq    %rsp, %rbp</span><br><span class="line">    .cfi_def_cfa_register <span class="number">6</span></span><br><span class="line">    movl    %edi, <span class="number">-4</span>(%rbp)</span><br><span class="line">    movl    %esi, <span class="number">-8</span>(%rbp)</span><br><span class="line">    movl    <span class="number">-4</span>(%rbp), %edx</span><br><span class="line">    movl    <span class="number">-8</span>(%rbp), %eax</span><br><span class="line">    addl    %edx, %eax</span><br><span class="line">    popq    %rbp</span><br><span class="line">    .cfi_def_cfa <span class="number">7</span>, <span class="number">8</span></span><br><span class="line">    ret</span><br><span class="line">    .cfi_endproc</span><br><span class="line">.LFE0:</span><br><span class="line">    .size   myadd, .-myadd</span><br><span class="line">    .globl  main</span><br><span class="line">    .type   main, @function</span><br><span class="line">main:</span><br><span class="line">.LFB1:</span><br><span class="line">    .cfi_startproc</span><br><span class="line">    pushq   %rbp</span><br><span class="line">    .cfi_def_cfa_offset <span class="number">16</span></span><br><span class="line">    .cfi_offset <span class="number">6</span>, <span class="number">-16</span></span><br><span class="line">    movq    %rsp, %rbp</span><br><span class="line">    .cfi_def_cfa_register <span class="number">6</span></span><br><span class="line">    subq    $<span class="number">16</span>, %rsp</span><br><span class="line">    movl    $<span class="number">110</span>, <span class="number">-12</span>(%rbp)</span><br><span class="line">    movl    $<span class="number">119</span>, <span class="number">-8</span>(%rbp)</span><br><span class="line">    movl    <span class="number">-8</span>(%rbp), %edx</span><br><span class="line">    movl    <span class="number">-12</span>(%rbp), %eax</span><br><span class="line">    movl    %edx, %esi</span><br><span class="line">    movl    %eax, %edi</span><br><span class="line">    call    myadd</span><br><span class="line">    movl    %eax, <span class="number">-4</span>(%rbp)</span><br><span class="line">    movl    $<span class="number">0</span>, %eax</span><br><span class="line">    leave</span><br><span class="line">    .cfi_def_cfa <span class="number">7</span>, <span class="number">8</span></span><br><span class="line">    ret</span><br><span class="line">    .cfi_endproc</span><br><span class="line">.LFE1:</span><br><span class="line">    .size   main, .-main</span><br><span class="line">    .ident  <span class="string">"GCC: (Ubuntu 5.4.0-6ubuntu1~16.04.12) 5.4.0 20160609"</span></span><br><span class="line">    .section    .note.GNU-<span class="built_in">stack</span>,<span class="string">""</span>,@progbits</span><br></pre></td></tr></table></figure><h3 id="g-编译simple-cpp文件"><a href="#g-编译simple-cpp文件" class="headerlink" title="g++编译simple.cpp文件"></a>g++编译simple.cpp文件</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// simple.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">myadd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">110</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">119</span>;</span><br><span class="line">    <span class="keyword">int</span> c = myadd(a, b);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>g++ simple.cpp -S</code> 生成汇编代码文件simple.s内容</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">    .file   <span class="string">"simple.cpp"</span></span><br><span class="line">    .text</span><br><span class="line">    .globl  _Z5myaddii</span><br><span class="line">    .type   _Z5myaddii, @function</span><br><span class="line">_Z5myaddii:</span><br><span class="line">.LFB0:</span><br><span class="line">    .cfi_startproc</span><br><span class="line">    pushq   %rbp</span><br><span class="line">    .cfi_def_cfa_offset <span class="number">16</span></span><br><span class="line">    .cfi_offset <span class="number">6</span>, <span class="number">-16</span></span><br><span class="line">    movq    %rsp, %rbp</span><br><span class="line">    .cfi_def_cfa_register <span class="number">6</span></span><br><span class="line">    movl    %edi, <span class="number">-20</span>(%rbp)</span><br><span class="line">    movl    %esi, <span class="number">-24</span>(%rbp)</span><br><span class="line">    movl    $<span class="number">0</span>, <span class="number">-4</span>(%rbp)</span><br><span class="line">    movl    <span class="number">-20</span>(%rbp), %edx</span><br><span class="line">    movl    <span class="number">-24</span>(%rbp), %eax</span><br><span class="line">    addl    %edx, %eax</span><br><span class="line">    movl    %eax, <span class="number">-4</span>(%rbp)</span><br><span class="line">    movl    <span class="number">-4</span>(%rbp), %eax</span><br><span class="line">    popq    %rbp</span><br><span class="line">    .cfi_def_cfa <span class="number">7</span>, <span class="number">8</span></span><br><span class="line">    ret</span><br><span class="line">    .cfi_endproc</span><br><span class="line">.LFE0:</span><br><span class="line">    .size   _Z5myaddii, .-_Z5myaddii</span><br><span class="line">    .globl  main</span><br><span class="line">    .type   main, @function</span><br><span class="line">main:</span><br><span class="line">.LFB1:</span><br><span class="line">    .cfi_startproc</span><br><span class="line">    pushq   %rbp</span><br><span class="line">    .cfi_def_cfa_offset <span class="number">16</span></span><br><span class="line">    .cfi_offset <span class="number">6</span>, <span class="number">-16</span></span><br><span class="line">    movq    %rsp, %rbp</span><br><span class="line">    .cfi_def_cfa_register <span class="number">6</span></span><br><span class="line">    subq    $<span class="number">16</span>, %rsp</span><br><span class="line">    movl    $<span class="number">110</span>, <span class="number">-12</span>(%rbp)</span><br><span class="line">    movl    $<span class="number">119</span>, <span class="number">-8</span>(%rbp)</span><br><span class="line">    movl    $<span class="number">0</span>, <span class="number">-4</span>(%rbp)</span><br><span class="line">    movl    <span class="number">-8</span>(%rbp), %edx</span><br><span class="line">    movl    <span class="number">-12</span>(%rbp), %eax</span><br><span class="line">    movl    %edx, %esi</span><br><span class="line">    movl    %eax, %edi</span><br><span class="line">    call    _Z5myaddii</span><br><span class="line">    movl    %eax, <span class="number">-4</span>(%rbp)</span><br><span class="line">    movl    $<span class="number">0</span>, %eax</span><br><span class="line">    leave</span><br><span class="line">    .cfi_def_cfa <span class="number">7</span>, <span class="number">8</span></span><br><span class="line">    ret</span><br><span class="line">    .cfi_endproc</span><br><span class="line">.LFE1:</span><br><span class="line">    .size   main, .-main</span><br><span class="line">    .ident  <span class="string">"GCC: (Ubuntu 5.4.0-6ubuntu1~16.04.12) 5.4.0 20160609"</span></span><br><span class="line">    .section    .note.GNU-<span class="built_in">stack</span>,<span class="string">""</span>,@progbits</span><br></pre></td></tr></table></figure><p>虽然只有几行代码，可是生成汇编文件之后变成了50多行，我们只需要关注 <code>myadd()</code> 这个函数编译之后变成了什么就可以了，汇编代码虽然不好读，但是查找一个函数名应该没问题的，对照着上面的代码我们发现，<code>myadd()</code> 这个函数通过 <code>gcc</code> 编译之后的函数名还是 <code>myadd</code>，而通过 <code>g++</code> 编译之后的函数名变成了 <code>_Z5myaddii</code>，可以明显感觉到最后的两个字母 <code>i</code> 代表的是参数 <code>int</code>，使用 <code>c++filt</code> 命令还原如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ c++filt _Z5myaddii</span><br><span class="line">myadd(int, int)</span><br></pre></td></tr></table></figure><h2 id="C-函数重载编译后的函数名对比"><a href="#C-函数重载编译后的函数名对比" class="headerlink" title="C++函数重载编译后的函数名对比"></a>C++函数重载编译后的函数名对比</h2><p>我们还是在刚才的代码的基础上增加一个参数类型不同的 <code>myadd</code> 函数，修改后的代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">myadd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">myadd</span><span class="params">(<span class="keyword">float</span> a, <span class="keyword">float</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c = myadd(<span class="number">110</span>, <span class="number">119</span>);</span><br><span class="line">    <span class="keyword">float</span> d = myadd(<span class="number">52.0f</span>, <span class="number">13.14f</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>g++ simple.cpp -S</code> 生成汇编代码文件simple.s内容为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">    .file   <span class="string">"simple.cpp"</span></span><br><span class="line">    .text</span><br><span class="line">    .globl  _Z5myaddii</span><br><span class="line">    .type   _Z5myaddii, @function</span><br><span class="line">_Z5myaddii:</span><br><span class="line">.LFB0:</span><br><span class="line">    .cfi_startproc</span><br><span class="line">    pushq   %rbp</span><br><span class="line">    .cfi_def_cfa_offset <span class="number">16</span></span><br><span class="line">    .cfi_offset <span class="number">6</span>, <span class="number">-16</span></span><br><span class="line">    movq    %rsp, %rbp</span><br><span class="line">    .cfi_def_cfa_register <span class="number">6</span></span><br><span class="line">    movl    %edi, <span class="number">-4</span>(%rbp)</span><br><span class="line">    movl    %esi, <span class="number">-8</span>(%rbp)</span><br><span class="line">    movl    <span class="number">-4</span>(%rbp), %edx</span><br><span class="line">    movl    <span class="number">-8</span>(%rbp), %eax</span><br><span class="line">    addl    %edx, %eax</span><br><span class="line">    popq    %rbp</span><br><span class="line">    .cfi_def_cfa <span class="number">7</span>, <span class="number">8</span></span><br><span class="line">    ret</span><br><span class="line">    .cfi_endproc</span><br><span class="line">.LFE0:</span><br><span class="line">    .size   _Z5myaddii, .-_Z5myaddii</span><br><span class="line">    .globl  _Z5myaddff</span><br><span class="line">    .type   _Z5myaddff, @function</span><br><span class="line">_Z5myaddff:</span><br><span class="line">.LFB1:</span><br><span class="line">    .cfi_startproc</span><br><span class="line">    pushq   %rbp</span><br><span class="line">    .cfi_def_cfa_offset <span class="number">16</span></span><br><span class="line">    .cfi_offset <span class="number">6</span>, <span class="number">-16</span></span><br><span class="line">    movq    %rsp, %rbp</span><br><span class="line">    .cfi_def_cfa_register <span class="number">6</span></span><br><span class="line">    movss   %xmm0, <span class="number">-4</span>(%rbp)</span><br><span class="line">    movss   %xmm1, <span class="number">-8</span>(%rbp)</span><br><span class="line">    movss   <span class="number">-4</span>(%rbp), %xmm0</span><br><span class="line">    addss   <span class="number">-8</span>(%rbp), %xmm0</span><br><span class="line">    popq    %rbp</span><br><span class="line">    .cfi_def_cfa <span class="number">7</span>, <span class="number">8</span></span><br><span class="line">    ret</span><br><span class="line">    .cfi_endproc</span><br><span class="line">.LFE1:</span><br><span class="line">    .size   _Z5myaddff, .-_Z5myaddff</span><br><span class="line">    .globl  main</span><br><span class="line">    .type   main, @function</span><br><span class="line">main:</span><br><span class="line">.LFB2:</span><br><span class="line">    .cfi_startproc</span><br><span class="line">    pushq   %rbp</span><br><span class="line">    .cfi_def_cfa_offset <span class="number">16</span></span><br><span class="line">    .cfi_offset <span class="number">6</span>, <span class="number">-16</span></span><br><span class="line">    movq    %rsp, %rbp</span><br><span class="line">    .cfi_def_cfa_register <span class="number">6</span></span><br><span class="line">    subq    $<span class="number">16</span>, %rsp</span><br><span class="line">    movl    $<span class="number">119</span>, %esi</span><br><span class="line">    movl    $<span class="number">110</span>, %edi</span><br><span class="line">    call    _Z5myaddii</span><br><span class="line">    movl    %eax, <span class="number">-8</span>(%rbp)</span><br><span class="line">    movss   .LC0(%rip), %xmm1</span><br><span class="line">    movss   .LC1(%rip), %xmm0</span><br><span class="line">    call    _Z5myaddff</span><br><span class="line">    movd    %xmm0, %eax</span><br><span class="line">    movl    %eax, <span class="number">-4</span>(%rbp)</span><br><span class="line">    movl    $<span class="number">0</span>, %eax</span><br><span class="line">    leave</span><br><span class="line">    .cfi_def_cfa <span class="number">7</span>, <span class="number">8</span></span><br><span class="line">    ret</span><br><span class="line">    .cfi_endproc</span><br><span class="line">.LFE2:</span><br><span class="line">    .size   main, .-main</span><br><span class="line">    .section    .rodata</span><br><span class="line">    .align <span class="number">4</span></span><br><span class="line">.LC0:</span><br><span class="line">    .<span class="keyword">long</span>   <span class="number">1095908721</span></span><br><span class="line">    .align <span class="number">4</span></span><br><span class="line">.LC1:</span><br><span class="line">    .<span class="keyword">long</span>   <span class="number">1112539136</span></span><br><span class="line">    .ident  <span class="string">"GCC: (Ubuntu 5.4.0-6ubuntu1~16.04.12) 5.4.0 20160609"</span></span><br><span class="line">    .section    .note.GNU-<span class="built_in">stack</span>,<span class="string">""</span>,@progbits</span><br></pre></td></tr></table></figure><p>这次一共3个函数，生成的汇编代码更长，但是我们一眼就能看见汇编代码中包含 <code>_Z5myaddii</code> 和 <code>_Z5myaddff</code> 两个函数，这就是函数重载的产物，两个参数类型不同的同名函数编译之后生成了不同的名字，<code>_Z5myaddff</code> 函数末尾的两个 <code>f</code> 应该指的就是参数类型 <code>float</code>。</p><h1 id="使用c-filt定位问题示例"><a href="#使用c-filt定位问题示例" class="headerlink" title="使用c++filt定位问题示例"></a>使用c++filt定位问题示例</h1><p>c++filt的作用就是还原函数名字，它可以帮我们查找动态链接库中缺少的函数，还原崩溃堆栈中一大串的函数名字母等等，下面来看一个崩溃堆栈的例子，代码内容尽量简写，只为了说明问题，现实情况可能要复杂的多。</p><!-- ldd -r test.so --><p>首先定义一个打印函数堆栈的函数，参考之前的总结<a href="https://blog.csdn.net/albertsh/article/details/100594143" target="_blank" rel="noopener">《linux环境下C++代码打印函数堆栈调用情况》</a>，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;execinfo.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_stack</span><span class="params">(<span class="keyword">int</span> nSignal)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> MAX_STACK_FRAMES = <span class="number">12</span>;</span><br><span class="line">    <span class="keyword">void</span> *pStack[MAX_STACK_FRAMES];</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> szStackInfo[<span class="number">1024</span> * MAX_STACK_FRAMES];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> ** pStackList = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> frames = backtrace(pStack, MAX_STACK_FRAMES);</span><br><span class="line">    pStackList = backtrace_symbols(pStack, frames);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == pStackList)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">strcpy</span>(szStackInfo, <span class="string">"stack traceback:\n"</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; frames; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">NULL</span> == pStackList[i])</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">strncat</span>(szStackInfo, pStackList[i], <span class="number">1024</span>);</span><br><span class="line">        <span class="built_in">strcat</span>(szStackInfo, <span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; szStackInfo; <span class="comment">// 输出到控制台，也可以打印到日志文件中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再写一段隐藏着崩溃问题的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CTest</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span>&amp; <span class="title">get_string</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> s;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set_string</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; str)</span> </span>&#123;s = str;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> s;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">float</span> z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *p = <span class="literal">nullptr</span>;</span><br><span class="line">    *p = <span class="number">110</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; z;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CTest* pTest = <span class="keyword">new</span> CTest();</span><br><span class="line">    pTest-&gt;set_string(<span class="string">"20200517"</span>);</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; s = pTest-&gt;get_string();</span><br><span class="line">    <span class="keyword">delete</span> pTest;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="string">"20200517"</span>) foo(<span class="number">13.14</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> s = <span class="built_in">std</span>::to_string(a) + <span class="built_in">std</span>::to_string(b);</span><br><span class="line">    test(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    signal(SIGSEGV, show_stack);</span><br><span class="line">    func(<span class="number">250</span>, <span class="number">520</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译运行，果然崩溃了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ g++ simple.cpp --std=c++11</span><br><span class="line">$ ./a.out</span><br><span class="line">stack traceback:</span><br><span class="line">./a.out() [0x401aff]</span><br><span class="line">/lib/x86_64-linux-gnu/libc.so.6(+0x354b0) [0x7fd5f98b54b0]</span><br><span class="line">/lib/x86_64-linux-gnu/libc.so.6(+0x16eff6) [0x7fd5f99eeff6]</span><br><span class="line">/usr/lib/x86_64-linux-gnu/libstdc++.so.6(_ZNKSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE7compareEPKc+0x3a) [0x7fd5f9f9145a]</span><br><span class="line">./a.out() [0x4022b6]</span><br><span class="line">./a.out() [0x401d30]</span><br><span class="line">./a.out() [0x401e27]</span><br><span class="line">./a.out() [0x401ed8]</span><br><span class="line">/lib/x86_64-linux-gnu/libc.so.6(__libc_start_main+0xf0) [0x7fd5f98a0830]</span><br><span class="line">./a.out() [0x4019f9]</span><br></pre></td></tr></table></figure><p>这时崩溃的堆栈中发现了一个特别长的函数 <code>_ZNKSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE7compareEPKc</code>，使用 <code>c++filt</code> 命令来还原函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ c++filt _ZNKSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE7compareEPKc</span><br><span class="line"><span class="built_in">std</span>::__cxx11::basic_string&lt;<span class="keyword">char</span>, <span class="built_in">std</span>::char_traits&lt;<span class="keyword">char</span>&gt;, <span class="built_in">std</span>::allocator&lt;<span class="keyword">char</span>&gt; &gt;::compare(<span class="keyword">char</span> <span class="keyword">const</span>*) <span class="keyword">const</span></span><br></pre></td></tr></table></figure><p>从函数名来看是一个与字符串相关的 <code>compare</code> 函数，查看代码发现是 <code>s == &quot;20200517&quot;</code> 这一句的问题，所以说能确切的知道函数名对我们查找问题来说还是挺有帮助的。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li><code>c++filt</code> 命令可以还原 <code>C++</code> 为实现函数重载采用 <code>name mangling</code> 搞出来的奇奇怪怪的函数名</li><li>注册信号回调函数方式：<code>signal(SIGSEGV, show_stack);</code>，<code>SIGSEGV</code>代表无效的内存引用</li><li>注意 <code>C</code> 语言和 <code>C++</code> 在编译后函数命名方式的不同，<code>C</code> 语言不支持严格意义的重载，C++支持</li></ul><hr><blockquote><p>阳光、空气、水，这些真的是好东西，当你真的快要失去它们才意识的到的话就有些晚了…</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;这个命令功能单一，但是非常强大，可以用来还原C++编译后的函数名，为什么C++的函数名需要单独的命令来还原，因为他们看起来都是这样 &lt;cod
      
    
    </summary>
    
      <category term="C/C++" scheme="http://AlbertGithubHome.github.io/blog/categories/C-C/"/>
    
    
      <category term="C/C++" scheme="http://AlbertGithubHome.github.io/blog/tags/C-C/"/>
    
      <category term="linux" scheme="http://AlbertGithubHome.github.io/blog/tags/linux/"/>
    
      <category term="工具" scheme="http://AlbertGithubHome.github.io/blog/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="c++filt" scheme="http://AlbertGithubHome.github.io/blog/tags/c-filt/"/>
    
  </entry>
  
  <entry>
    <title>汇编指令入门级整理</title>
    <link href="http://AlbertGithubHome.github.io/blog/2020/05/09/%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4%E5%85%A5%E9%97%A8%E7%BA%A7%E6%95%B4%E7%90%86/"/>
    <id>http://AlbertGithubHome.github.io/blog/2020/05/09/汇编指令入门级整理/</id>
    <published>2020-05-08T16:00:11.000Z</published>
    <updated>2020-05-10T12:42:32.561Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我们大都是被高级语言惯坏了的一代，源源不断的新特性正在逐步添加到各类高级语言之中，汇编作为最接近机器指令的低级语言，已经很少被直接拿来写程序了，不过我还真的遇到了一个，那是之前的一个同事，因为在写代码时遇到了成员函数权限及可见性的问题，导致他无法正确调用想执行的函数，结果他就开始在 <code>C++</code> 代码里嵌入汇编了，绕过了种种限制终于如愿以偿，但是读代码的我们傻眼了…</p><a id="more"></a><p>因为项目是跨平台的，代码推送的 Linux 上编译的时候他才发现，汇编代码的语法在 Linux 和 Windows 上居然是不一样的，结果他又用一个判断平台的宏定义“完美”的解决了，最终这些代码肯定是重写了啊，因为可读性太差了，最近在学习左值、右值、左引用和右引用的时候，总是有人用程序编译生成的中间汇编代码来解释问题，看得我迷迷糊糊，所以决定熟悉一下简单的汇编指令，边学习边记录，方便今后忘记了可以直接拿来复习。</p><h1 id="什么是汇编语言"><a href="#什么是汇编语言" class="headerlink" title="什么是汇编语言"></a>什么是汇编语言</h1><p>汇编语言是最接近机器语言的编程语言，引用百科中的一段话解释为：</p><blockquote><p>汇编语言（assembly language）是一种用于电子计算机、微处理器、微控制器或其他可编程器件的低级语言，亦称为符号语言。在汇编语言中，用助记符代替机器指令的操作码，用地址符号或标号代替指令或操作数的地址。汇编语言又被称为第二代计算机语言。</p></blockquote><h2 id="汇编语言产生的原因"><a href="#汇编语言产生的原因" class="headerlink" title="汇编语言产生的原因"></a>汇编语言产生的原因</h2><p>对于绝大多数人来说，二进制程序是不可读的，当然有能人可以读，比如第一代程序员，但这类人快灭绝了，直接看二进制不容易看出来究竟做了什么事情，比如最简单的加法指令二进制表示为 <code>00000011</code>，如果它混在一大串01字符串中就很难把它找出来，所以汇编语言主要就是为了解决二进制编码的可读性问题。</p><h2 id="汇编与二进制的关系"><a href="#汇编与二进制的关系" class="headerlink" title="汇编与二进制的关系"></a>汇编与二进制的关系</h2><p>换句话来说，汇编语言就是把给机器看的二进制编码翻译成人话，汇编指令是机器指令的助记符，与机器指令是一一对应的关系，是一种便于阅读和记忆的书写格式。有效地解决了机器指令编写程序难度大的问题，并且使用编译器，可以很方便的把汇编程序转译成机器指令程序，比如之前提到的 <code>00000011</code> 加法指令，对应的汇编指令是 <code>ADD</code>，在调用汇编器时就会把 <code>ADD</code> 翻译成 <code>00000011</code>。</p><h1 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h1><p>说到汇编指令不得不提到寄存器，寄存器本身是用来存数据的，因为 <code>CPU</code> 本身只负责逻辑运算，数据需要单独储存在其他的地方，但是对于不熟悉寄存器的人来说会有疑惑，数据不是存在硬盘上吗？或者说数据不是存在内存中吗？这些想法都没错，那么寄存器是用来做什么的呢？</p><h2 id="寄存器作用"><a href="#寄存器作用" class="headerlink" title="寄存器作用"></a>寄存器作用</h2><p>其实硬盘、内存都是用来存储数据的，但是 <code>CPU</code> 的运算速度远高于内存的读写速度，更不用说从硬盘上取数据了，所以为了避免被拖慢速度影响效率，<code>CPU</code> 都自带一级缓存和二级缓存，一些 <code>CPU</code> 甚至增加了三级缓存，从这些缓存中读写数据要比内存快很多，但是还是无法使用飞速运转的 <code>CPU</code>，所以才会有寄存器的存在。</p><p>寄存器不是后来增加的，在最初的计算中就已经设计出来，相比而言，多级缓存出现的更晚一些，通常那些最频繁读写的数据都会被放在寄存器里面，<code>CPU</code> 优先读写寄存器，再通过寄存器、缓存跟内存来交换数据，达到缓冲的目的，因为可以通过名称访问寄存器，这样访问速度是最快的，因此也被称为零级缓存。</p><h2 id="存取速度比较"><a href="#存取速度比较" class="headerlink" title="存取速度比较"></a>存取速度比较</h2><p>通过上面的叙述我们可以知道存取速度从高到低分别是: <code>寄存器 &gt; 1级缓存 &gt; 2级缓存 &gt; 3级缓存 &gt; 内存 &gt; 硬盘</code>，关于它们的存取速度，举个例子很容易就能明白了，比如我们做菜（CPU工作）时，取手中（寄存器）正拿着的肉和蔬菜肯定是最快的，如果没有就需要把案板上（1级缓存）处理好的菜拿过来，如果案板上没有就在更远一点的洗菜池（2级缓存）中找一找，还没找到的话就要到冰箱（3级缓存）中看一看了，这时发现家里真没有，那去楼下的菜店（内存）去买点吧，转了一圈发现没有想要的，最后还是开车去农贸市场（硬盘）买吧。</p><p>通过上面这个例子应该能明白它们的速度关系了，既然缓存这么快，为什么不用缓存代替内存，或者将2、3级缓存都换成1级缓存呢？这里边有一个成本问题，速度越快对应着价格越高，如果你买过机械硬盘和固态硬盘应该很容易就理解了。</p><h2 id="寄存器分类"><a href="#寄存器分类" class="headerlink" title="寄存器分类"></a>寄存器分类</h2><p>常用的 <code>x86 CPU</code> 寄存器有8个：<code>EAX</code> 、<code>EBX</code>、<code>ECX</code>、<code>EDX</code>、<code>EDI</code>、<code>ESI</code>、<code>EBP</code>、<code>ESP</code>，据说现在寄存器总数已经超过100个了，等我找到相关资料再来补充，上面这几个寄存器是最常用的，这些名字也常常出现在汇编的代码中。</p><p>我们常说的32位、64位 <code>CPU</code> 是指数据总线的宽度或根数，而寄存器是暂存数据和中间结果的单元，因此寄存器的位数也就是处理数据的长度与数据总线的根数是相同的，所以32位 <code>CPU</code> 对应的寄存器也应该是32位的。</p><h2 id="常用寄存器用途"><a href="#常用寄存器用途" class="headerlink" title="常用寄存器用途"></a>常用寄存器用途</h2><p>上面提到大8个寄存器都有其特定的用途，我们以32位 <code>CPU</code> 为例简单说明下这些寄存器的作用，整理如下表：</p><table><thead><tr><th style="text-align:center">寄存器</th><th style="text-align:center">含义</th><th style="text-align:center">用途</th><th style="text-align:center">包含寄存器</th></tr></thead><tbody><tr><td style="text-align:center">EAX</td><td style="text-align:center">累加(Accumulator)寄存器</td><td style="text-align:center">常用于乘、除法和函数返回值</td><td style="text-align:center">AX(AH、AL)</td></tr><tr><td style="text-align:center">EBX</td><td style="text-align:center">基址(Base)寄存器</td><td style="text-align:center">常做内存数据的指针, 或者说常以它为基址来访问内存.</td><td style="text-align:center">BX(BH、BL)</td></tr><tr><td style="text-align:center">ECX</td><td style="text-align:center">计数器(Counter)寄存器</td><td style="text-align:center">常做字符串和循环操作中的计数器</td><td style="text-align:center">CX(CH、CL)</td></tr><tr><td style="text-align:center">EDX</td><td style="text-align:center">数据(Data)寄存器</td><td style="text-align:center">常用于乘、除法和 I/O 指针</td><td style="text-align:center">DX(DH、DL)</td></tr><tr><td style="text-align:center">ESI</td><td style="text-align:center">来源索引(Source Index)寄存器</td><td style="text-align:center">常做内存数据指针和源字符串指针</td><td style="text-align:center">SI</td></tr><tr><td style="text-align:center">EDI</td><td style="text-align:center">目的索引(Destination Index)寄存器</td><td style="text-align:center">常做内存数据指针和目的字符串指针</td><td style="text-align:center">DI</td></tr><tr><td style="text-align:center">ESP</td><td style="text-align:center">堆栈指针(Stack Point)寄存器</td><td style="text-align:center">只做堆栈的栈顶指针; 不能用于算术运算与数据传送</td><td style="text-align:center">SP</td></tr><tr><td style="text-align:center">EBP</td><td style="text-align:center">基址指针(Base Point)寄存器</td><td style="text-align:center">只做堆栈指针, 可以访问堆栈内任意地址, 经常用于中转 ESP 中的数据, 也常以它为基址来访问堆栈; 不能用于算术运算与数据传送</td><td style="text-align:center">BP</td></tr></tbody></table><h2 id="寄存器EAX、AX、AH、AL的关系"><a href="#寄存器EAX、AX、AH、AL的关系" class="headerlink" title="寄存器EAX、AX、AH、AL的关系"></a>寄存器EAX、AX、AH、AL的关系</h2><p>在上面的图标中每个常用寄存器后面还有其他的名字，它们是同一个寄存器不同用法下的不同名字，比如在32位 <code>CPU</code> 上，EAX是32位的寄存器，而AX是EAX的低16位，AH是AX的高8位，而AL是AX的低8位，它们的对照关系如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">00000000 00000000 00000000 00000000</span><br><span class="line">|===============EAX===============|---4个字节</span><br><span class="line">                  |======AX=======|---2个字节</span><br><span class="line">                  |==AH===|-----------1个字节</span><br><span class="line">                          |===AL==|---1个字节</span><br></pre></td></tr></table></figure><h1 id="汇编语言指令"><a href="#汇编语言指令" class="headerlink" title="汇编语言指令"></a>汇编语言指令</h1><p>终于说到汇编常用指令了，因为 <code>linux</code> 和 <code>windows</code> 下的汇编语法是有些不同的，所以下面我们先通过 <code>windows</code> 下的汇编指令来简单学习一下，后续再来比较两者的不同。</p><h2 id="数据传送指令"><a href="#数据传送指令" class="headerlink" title="数据传送指令"></a>数据传送指令</h2><table><thead><tr><th style="text-align:center">指令</th><th style="text-align:center">名称</th><th style="text-align:center">示例</th><th style="text-align:center">备注</th></tr></thead><tbody><tr><td style="text-align:center">MOV</td><td style="text-align:center">传送指令</td><td style="text-align:center">MOV dest, src</td><td style="text-align:center">将数据从src移动到dest</td></tr><tr><td style="text-align:center">PUSH</td><td style="text-align:center">进栈指令</td><td style="text-align:center">PUSH src</td><td style="text-align:center">把源操作数src压入堆栈</td></tr><tr><td style="text-align:center">POP</td><td style="text-align:center">出栈指令</td><td style="text-align:center">POP desc</td><td style="text-align:center">从栈顶弹出字数据到dest</td></tr></tbody></table><h2 id="算术运算指令"><a href="#算术运算指令" class="headerlink" title="算术运算指令"></a>算术运算指令</h2><table><thead><tr><th style="text-align:center">指令</th><th style="text-align:center">名称</th><th style="text-align:center">示例</th><th style="text-align:center">备注</th></tr></thead><tbody><tr><td style="text-align:center">ADD</td><td style="text-align:center">加法指令</td><td style="text-align:center">ADD dest, src</td><td style="text-align:center">在dest基础上加src</td></tr><tr><td style="text-align:center">SUB</td><td style="text-align:center">减法指令</td><td style="text-align:center">SUB dest, src</td><td style="text-align:center">在dest基础上减src</td></tr><tr><td style="text-align:center">INC</td><td style="text-align:center">加1指令</td><td style="text-align:center">INC dest</td><td style="text-align:center">在dest基础上加1</td></tr><tr><td style="text-align:center">DEC</td><td style="text-align:center">减1指令</td><td style="text-align:center">DEC dest</td><td style="text-align:center">在dest基础上减1</td></tr></tbody></table><h2 id="逻辑运算指令"><a href="#逻辑运算指令" class="headerlink" title="逻辑运算指令"></a>逻辑运算指令</h2><table><thead><tr><th style="text-align:center">指令</th><th style="text-align:center">名称</th><th style="text-align:center">示例</th><th style="text-align:center">备注</th></tr></thead><tbody><tr><td style="text-align:center">NOT</td><td style="text-align:center">取反运算指令</td><td style="text-align:center">NOT dest</td><td style="text-align:center">把操作数dest按位取反</td></tr><tr><td style="text-align:center">AND</td><td style="text-align:center">与运算指令</td><td style="text-align:center">AND dest, src</td><td style="text-align:center">把dest和src进行与运算之后送回dest</td></tr><tr><td style="text-align:center">OR</td><td style="text-align:center">或运算指令</td><td style="text-align:center">OR dest, src</td><td style="text-align:center">把dest和src进行或运算之后送回dest</td></tr><tr><td style="text-align:center">XOR</td><td style="text-align:center">异或运算</td><td style="text-align:center">XOR dest, src</td><td style="text-align:center">把dest和src进行异或运算之后送回dest</td></tr></tbody></table><h2 id="循环控制指令"><a href="#循环控制指令" class="headerlink" title="循环控制指令"></a>循环控制指令</h2><table><thead><tr><th style="text-align:center">指令</th><th style="text-align:center">名称</th><th style="text-align:center">示例</th><th style="text-align:center">备注</th></tr></thead><tbody><tr><td style="text-align:center">LOOP</td><td style="text-align:center">计数循环指令</td><td style="text-align:center">LOOP label</td><td style="text-align:center">使ECX的值减1，当ECX的值不为0的时候跳转至label，否则执行LOOP之后的语句</td></tr></tbody></table><h2 id="转移指令"><a href="#转移指令" class="headerlink" title="转移指令"></a>转移指令</h2><table><thead><tr><th style="text-align:center">指令</th><th style="text-align:center">名称</th><th style="text-align:center">示例</th><th style="text-align:center">备注</th></tr></thead><tbody><tr><td style="text-align:center">JMP</td><td style="text-align:center">无条件转移指令</td><td style="text-align:center">JMP lable</td><td style="text-align:center">无条件地转移到标号为label的位置</td></tr><tr><td style="text-align:center">CALL</td><td style="text-align:center">过程调用指令</td><td style="text-align:center">CALL labal</td><td style="text-align:center">直接调用label</td></tr><tr><td style="text-align:center">JE</td><td style="text-align:center">条件转移指令</td><td style="text-align:center">JE lable</td><td style="text-align:center">zf =1 时跳转到标号为label的位置</td></tr><tr><td style="text-align:center">JNE</td><td style="text-align:center">条件转移指令</td><td style="text-align:center">JNE lable</td><td style="text-align:center">zf=0 时跳转到标号为label的位置</td></tr></tbody></table><h1 id="linux-和-windows-下汇编的区别"><a href="#linux-和-windows-下汇编的区别" class="headerlink" title="linux 和 windows 下汇编的区别"></a>linux 和 windows 下汇编的区别</h1><p>前面说到 <code>linux</code> 和 <code>windows</code> 下的汇编语法是不同的，其实两种语法的不同和系统不同没有绝对的关系，一般在 <code>linux</code> 上会使用 <code>gcc/g++</code> 编译器，而在 <code>windows</code> 上会使用微软的 <code>cl</code> 也就是 <code>MSBUILD</code>，所以产生不同的代码是因为编译器不同，<code>gcc</code> 下采用的是AT&amp;T的汇编语法格式，<code>MSBUILD</code> 采用的是Intel汇编语法格式。</p><table><thead><tr><th style="text-align:center">差异</th><th style="text-align:center">Intel</th><th style="text-align:center">AT&amp;T</th></tr></thead><tbody><tr><td style="text-align:center">引用寄存器名字</td><td style="text-align:center">eax</td><td style="text-align:center">%eax</td></tr><tr><td style="text-align:center">赋值操作数顺序</td><td style="text-align:center">mov dest, src</td><td style="text-align:center">movl src, dest</td></tr><tr><td style="text-align:center">寄存器、立即数指令前缀</td><td style="text-align:center">mov  ebx, 0xd00d</td><td style="text-align:center">movl  $0xd00d, %ebx</td></tr><tr><td style="text-align:center">寄存器间接寻址</td><td style="text-align:center">[eax]</td><td style="text-align:center">(%eax)</td></tr><tr><td style="text-align:center">数据类型大小</td><td style="text-align:center">操作码后加后缀字母，“l” 32位，“w” 16位，“b” 8位（mov dx, word ptr [eax]）</td><td style="text-align:center">操作数前面加dword ptr， word ptr，byte ptr的格式 （movb %bl %al）</td></tr></tbody></table><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>汇编指令是机器指令的助记符，与机器指令是一一对应的</li><li>AT&amp;T的汇编语法格式和Intel汇编语法格式的是不同的</li><li>常用寄存器：<code>EAX</code> 、<code>EBX</code>、<code>ECX</code>、<code>EDX</code>、<code>EDI</code>、<code>ESI</code>、<code>EBP</code>、<code>ESP</code></li><li>存取速度从高到低分别是: <code>寄存器 &gt; 1级缓存 &gt; 2级缓存 &gt; 3级缓存 &gt; 内存 &gt; 硬盘</code></li><li>常用的汇编指令：<code>mov</code>、<code>je</code>、<code>jmp</code>、<code>call</code>、<code>add</code>、<code>sub</code>、<code>inc</code>、<code>dec</code>、<code>and</code>、<code>or</code></li></ul><hr><blockquote><p>如今的每分每秒都是人生，不要总想着将自然发生的事情拖到预定的时刻才进行~</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;我们大都是被高级语言惯坏了的一代，源源不断的新特性正在逐步添加到各类高级语言之中，汇编作为最接近机器指令的低级语言，已经很少被直接拿来写程序了，不过我还真的遇到了一个，那是之前的一个同事，因为在写代码时遇到了成员函数权限及可见性的问题，导致他无法正确调用想执行的函数，结果他就开始在 &lt;code&gt;C++&lt;/code&gt; 代码里嵌入汇编了，绕过了种种限制终于如愿以偿，但是读代码的我们傻眼了…&lt;/p&gt;
    
    </summary>
    
      <category term="ASM" scheme="http://AlbertGithubHome.github.io/blog/categories/ASM/"/>
    
    
      <category term="C/C++" scheme="http://AlbertGithubHome.github.io/blog/tags/C-C/"/>
    
      <category term="汇编" scheme="http://AlbertGithubHome.github.io/blog/tags/%E6%B1%87%E7%BC%96/"/>
    
      <category term="linux" scheme="http://AlbertGithubHome.github.io/blog/tags/linux/"/>
    
      <category term="windows" scheme="http://AlbertGithubHome.github.io/blog/tags/windows/"/>
    
      <category term="asm" scheme="http://AlbertGithubHome.github.io/blog/tags/asm/"/>
    
  </entry>
  
  <entry>
    <title>C++11在左值引用的基础上增加右值引用</title>
    <link href="http://AlbertGithubHome.github.io/blog/2020/05/05/C-11%E5%9C%A8%E5%B7%A6%E5%80%BC%E5%BC%95%E7%94%A8%E7%9A%84%E5%9F%BA%E7%A1%80%E4%B8%8A%E5%A2%9E%E5%8A%A0%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8/"/>
    <id>http://AlbertGithubHome.github.io/blog/2020/05/05/C-11在左值引用的基础上增加右值引用/</id>
    <published>2020-05-05T08:52:16.000Z</published>
    <updated>2020-05-05T15:23:10.588Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>右值引用这个词是最开始是学习 <code>easylogging++</code> 这个日志开源项目的时候遇到的，当时遇到 <code>&amp;&amp;</code> 这样的写法先是一愣，还有这种写法？难道是引用的地址？结果查询资料才明白这叫做右值引用。</p><a id="more"></a><h1 id="右值引用的出现"><a href="#右值引用的出现" class="headerlink" title="右值引用的出现"></a>右值引用的出现</h1><p>其实右值引用是在 <code>C++11</code> 时增加的新内容，在此之前，引用是没有左值和右值之分的，只存在一种引用，也就是后来 <code>C++11</code> 标准中的左值引用，而右值引用的提出主要是为了解决之前左值引用出现的一些尴尬的问题。</p><h1 id="左值和右值"><a href="#左值和右值" class="headerlink" title="左值和右值"></a>左值和右值</h1><p>说到右值引用需要先了解下左值和右值，这也是我自己学习的过程，之前在 <a href="https://blog.csdn.net/albertsh/article/details/105756674" target="_blank" rel="noopener">《简单聊聊C/C++中的左值和右值》</a> 这篇笔记中总结过，可以简单理解左值就是放在 <code>=</code> 左边，可以取到地址，可以被赋值的表达式，而右值通常是放在 <code>=</code> 右侧，不能取地址，只能被当成一个“值”的表达式。</p><h1 id="右值引用的作用"><a href="#右值引用的作用" class="headerlink" title="右值引用的作用"></a>右值引用的作用</h1><p>右值引用的出现并不是为了取代左值引用，也不是和左值引用形成对立，而是充分利用右值内容来减少对象构造和析构操作，以达到提高程序代码效率的目的。</p><p>也就是说增加右值引用这个特性是为了提高效率，之前的总结中也提到过，在 <code>C++11</code> 中还引入了 <code>std::move()</code> 函数，并用这个函数改写了 <code>std::remove_if()</code> 函数，这就是提高效率的例子。</p><p>使用 <code>std::move()</code> 函数意味着放弃所有权，对于一个左值，如果我们明确放弃对其资源的所有权，则可以通过 <code>std::move()</code> 来将其转为右值引用，放弃所有权的这个操作不一定都是方便的，比如 <code>std::auto_ptr</code> 这个第一代的智能指针，就是因为转移了所有权，使用起来不太方便，才在最新标准中被废弃的。但如果你明确要转移所有权，并且合理使用，有时可以有效的提高程序效率。</p><h1 id="引用类型的对比"><a href="#引用类型的对比" class="headerlink" title="引用类型的对比"></a>引用类型的对比</h1><p>在学习使用右值引用之前先复习一下左值引用，对比学习更有利于我们的记忆。</p><h2 id="左值引用"><a href="#左值引用" class="headerlink" title="左值引用"></a>左值引用</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">22</span>;</span><br><span class="line"><span class="keyword">int</span>&amp; j = i;</span><br><span class="line"></span><br><span class="line">j = <span class="number">11</span>;</span><br></pre></td></tr></table></figure><p>上面这几行代码就是最常见左值引用的例子，变量 <code>j</code> 引用了变量 <code>i</code> 的存储位置，修改变量 <code>j</code> 就修改了变量 <code>i</code> 的值，但是如果引用一个值会怎么样呢？比如下面这行代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>&amp; j = <span class="number">22</span>;</span><br></pre></td></tr></table></figure><p>编译这行代码会得到一个编译错误：</p><blockquote><p>error: invalid initialization of non-const reference of type ‘int&amp;’ from an rvalue of type ‘int’<br>   int&amp; j = 22;</p></blockquote><p>像上面这种问题，可以使用常量引用来解决。</p><h2 id="常量引用"><a href="#常量引用" class="headerlink" title="常量引用"></a>常量引用</h2><p>针对上面的编译错误，改成常量引用就可以通过编译了，就像这样：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>&amp; j = <span class="number">22</span>;</span><br></pre></td></tr></table></figure><p>使用常量引用来引用数字常量22，可以编译通过是因为内存上产生了临时变量保存了22这个数据，这个临时变量是可以进行取地址操作的，因此变量 <code>j</code> 引用的其实是这个临时变量，相当于下面的这两句：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> temp = <span class="number">22</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;j = temp;</span><br></pre></td></tr></table></figure><p>看到这里我们发现常量引用可以解决引用常量的问题，那么为什么非得新增一个右值引用呢？那是因为使用常引用后，我们只能通过引用来读取数据，无法去修改数据，这在很多情况下是很不方便的。</p><h2 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h2><p>常量引用可以使用右值引用来改写，改写之后可以正常编译，并且还可以进行修改：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>&amp;&amp; j = <span class="number">22</span>;</span><br></pre></td></tr></table></figure><p>这句代码有两个需要注意的点，第一是右值引用是 <code>C++11</code> 中才增加的，所以需要增加 <code>--std=c++11</code> 这个编译选项才能正常编译，第二是右值引用的两个地址符需要连着写成 <code>&amp;&amp;</code>, 如果中间有空格写成 <code>&amp; &amp;</code> 会被认为是引用的引用而导致编译错误，这是不符合语法的。</p><h1 id="右值引用的示例"><a href="#右值引用的示例" class="headerlink" title="右值引用的示例"></a>右值引用的示例</h1><p>前面对引用类型进行了对比，但是还没有发现右值引用的好处，接下来用一个例子来展示一下增加右值引用之前的写法，和使用右值引用的写法，通过对比来了解一下右值引用究竟有什么好处。</p><p>我们来实现一个自定义缓冲区，先使用最常见的方法来实现拷贝构造函数和拷贝赋值函数，简单实现如下，功能不太完整，但是可以说明右值引用的作用：</p><h2 id="常量引用实现"><a href="#常量引用实现" class="headerlink" title="常量引用实现"></a>常量引用实现</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CBuffer</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    CBuffer(<span class="keyword">int</span> size = <span class="number">1024</span>): m_size(size)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"CBuffer(int)"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        m_buffer = <span class="keyword">new</span> <span class="keyword">char</span>[size];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~CBuffer()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"~CBuffer()"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">delete</span>[] m_buffer;</span><br><span class="line">        m_buffer = <span class="literal">nullptr</span>;</span><br><span class="line">        m_size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拷贝构造</span></span><br><span class="line">    CBuffer(<span class="keyword">const</span> CBuffer &amp;origin): m_size(origin.m_size)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"CBuffer(const CBuffer&amp;)"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        m_buffer = <span class="keyword">new</span> <span class="keyword">char</span>[origin.m_size];</span><br><span class="line">        <span class="built_in">memcpy</span>(m_buffer, origin.m_buffer, m_size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 赋值重载</span></span><br><span class="line">    CBuffer&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> CBuffer &amp;origin)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"operator=(const CBuffer&amp;)"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;origin) <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">delete</span>[] m_buffer;</span><br><span class="line"></span><br><span class="line">        m_size = origin.m_size;</span><br><span class="line">        m_buffer = <span class="keyword">new</span> <span class="keyword">char</span>[origin.m_size];</span><br><span class="line">        <span class="built_in">memcpy</span>(m_buffer, origin.m_buffer, m_size);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get_size</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> CBuffer <span class="title">gen_buffer</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">CBuffer <span class="title">temp_buffer</span><span class="params">(size)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> temp_buffer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span> *m_buffer;</span><br><span class="line">    <span class="keyword">int</span> m_size;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CBuffer b1;</span><br><span class="line">    <span class="function">CBuffer <span class="title">b2</span><span class="params">(b1)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"b1.size = "</span> &lt;&lt; b1.get_size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"b2.size = "</span> &lt;&lt; b2.get_size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    b2 = CBuffer::gen_buffer(<span class="number">100</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果是：</p><blockquote><p>CBuffer(int)<br>CBuffer(const CBuffer&amp;)<br>b1.size = 1024<br>b2.size = 1024<br>CBuffer(int)<br>operator=(const CBuffer&amp;)<br>~CBuffer()<br>~CBuffer()<br>~CBuffer()</p></blockquote><p>这个例子不具有实用性，只为了说明问题，<code>CBuffer</code> 这个类定义为了拷贝构造函数并且重载了 <code>=</code> 运算符，两个函数参数均使用常量引用的类型，这就是一般的写法。</p><p>但是这样实现有一个问题，因为参数是常量引用，所以没办法修改原对象的值，我们看到拷贝构造和赋值重载两个函数中都有申请空间和拷贝的操作，这种操作在操作内存较大的对象是比较耗时，所以应该尽量避免，我们想到可以使用新对象的指针指向旧对象指针来解决，这样就不用拷贝了，可是这样修改会导致两个对象指向同一块内存，这个问题需要解决。</p><h2 id="改为左值引用实现报错"><a href="#改为左值引用实现报错" class="headerlink" title="改为左值引用实现报错"></a>改为左值引用实现报错</h2><p>如果两个对象指向同一块内存，那么对象在析构的时候就会将一块内存释放两次导致奔溃，这时考虑在拷贝构造或者赋值重载时，将原来对象的指针设置成空就可以了，但是参数是常量没有办法修改啊，那我们将 <code>const</code> 关键字去掉试试，将两个函数改成这样：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 拷贝构造</span></span><br><span class="line">CBuffer(CBuffer &amp;origin): m_size(origin.m_size)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"CBuffer(CBuffer&amp;)"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    m_buffer = origin.m_buffer;</span><br><span class="line"></span><br><span class="line">    origin.m_buffer = <span class="literal">nullptr</span>;</span><br><span class="line">    origin.m_size = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 赋值重载</span></span><br><span class="line">CBuffer&amp; <span class="keyword">operator</span>=(CBuffer &amp;origin)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"operator=(CBuffer&amp;)"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;origin) <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">    m_buffer = origin.m_buffer;</span><br><span class="line"></span><br><span class="line">    origin.m_buffer = <span class="literal">nullptr</span>;</span><br><span class="line">    origin.m_size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看起来没有什么问题，但是编译的时候会报错：</p><blockquote><p>error: invalid initialization of non-const reference of type ‘CBuffer&amp;’ from an rvalue of type ‘CBuffer’<br>    b2 = CBuffer::gen_buffer(100);<br>                            ^<br>note:   initializing argument 1 of ‘CBuffer&amp; CBuffer::operator=(CBuffer&amp;)’<br>    CBuffer&amp; operator=(CBuffer &amp;origin)</p></blockquote><p>这个错误是什么意思呢？其实说的就是在调用 <code>CBuffer::gen_buffer(100);</code> 函数时，会产生一个临时对象，这个临时对象在赋值给 <code>b2</code> 是会调用<br><code>CBuffer&amp; operator=(CBuffer &amp;origin)</code> 函数，但是这个函数的参数是一个左值引用类型，而临时对象是一个右值，无法绑定到左值引用上，所以报错了。</p><p>还有拷贝构造函数也是有相同的问题，当写出类似 <code>b2 = CBuffer(CBuffer(1000))</code> 类型会产生临时对象的语句时，同样会因为左值引用不能绑定到右值上而报错，这时候就要请出右值引用了。</p><h2 id="改为右值引用实现"><a href="#改为右值引用实现" class="headerlink" title="改为右值引用实现"></a>改为右值引用实现</h2><p>对于赋值重载函数，我们使用右值引用将其改写为:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 赋值重载</span></span><br><span class="line">CBuffer&amp; <span class="keyword">operator</span>=(CBuffer &amp;&amp;origin)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"operator=(CBuffer&amp;&amp;)"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;origin) <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">    m_buffer = origin.m_buffer;</span><br><span class="line"></span><br><span class="line">    origin.m_buffer = <span class="literal">nullptr</span>;</span><br><span class="line">    origin.m_size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时可以正常通过编译，并且只是修改了指针的指向，并没有申请和拷贝另外一份内存。</p><h2 id="std-move-函数"><a href="#std-move-函数" class="headerlink" title="std::move() 函数"></a>std::move() 函数</h2><p>如果我们将拷贝构造函数的参数也改成右值引用的形式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 拷贝构造</span></span><br><span class="line">CBuffer(CBuffer &amp;&amp;origin): m_size(origin.m_size)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"CBuffer(CBuffer&amp;)"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    m_buffer = origin.m_buffer;</span><br><span class="line"></span><br><span class="line">    origin.m_buffer = <span class="literal">nullptr</span>;</span><br><span class="line">    origin.m_size = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译时就会发现编译错误：</p><blockquote><p>error: use of deleted function ‘constexpr CBuffer::CBuffer(const CBuffer&amp;)’<br>    CBuffer b2(b1);<br>                  ^<br>note: ‘constexpr CBuffer::CBuffer(const CBuffer&amp;)’ is implicitly declared<br>   as deleted because ‘CBuffer’ declares a move constructor or move assignment operator<br>   class CBuffer</p></blockquote><p>其本质问题就是主函数中 <code>CBuffer b2(b1);</code> 这一句引起的，因为变量 <code>b1</code> 是一个左值，但是拷贝构造函数接受的是右值引用，所以类型不匹配导致了编译错误，这时可以使用 <code>std::move()</code> 函数改成这条语句为 <code>CBuffer b2(std::move(b1));</code> 就可以正常编译运行了，运行结果为：</p><blockquote><p>CBuffer(int)<br>CBuffer(CBuffer&amp;)<br>b1.size = 0<br>b2.size = 1024<br>CBuffer(int)<br>operator=(CBuffer&amp;&amp;)<br>~CBuffer()<br>~CBuffer()<br>~CBuffer()</p></blockquote><p>查看运行结果会发现 <code>b1.size = 0</code>，因为 <code>b1</code> 调用了 <code>std::move()</code> 函数，转移了资源的所有权，内部已经被“掏空”了，所以在明确所有权转移之后，不要再直接使用变量 <code>b1</code> 了。</p><h1 id="万能引用"><a href="#万能引用" class="headerlink" title="万能引用"></a>万能引用</h1><p>听到这个名字就感觉很厉害，什么是万能引用，其实就是可以同时接受左值和右值的引用类型，但是这种完能引用只能发生在推导的情况下，下面给出了一个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(T&amp;&amp; val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; val &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> year = <span class="number">2020</span>;</span><br><span class="line">    func(year);</span><br><span class="line">    func(<span class="number">2020</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码中 <code>T&amp;&amp; val</code> 就是万能引用，因为是在模板中，类型需要推导，如果是在普通函数中 <code>T&amp;&amp; val</code> 这个形式就是右值引用。</p><h1 id="左值引用和右值引用判定的函数"><a href="#左值引用和右值引用判定的函数" class="headerlink" title="左值引用和右值引用判定的函数"></a>左值引用和右值引用判定的函数</h1><p>文中多次提到左值和右值，可能刚学习这块内容的小伙伴会有些懵，其实 <code>C++</code> 中提供了判定左值引用和右值引用的函数，头文件为 <code>&lt;type_traits&gt;</code>，函数名为 <code>is_reference</code>、 <code>is_rvalue_reference</code>、 <code>is_lvalue_reference</code>，看名字就可以知道他们的用途，看下面的例子就更清楚了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;type_traits&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">22</span>;</span><br><span class="line">    <span class="keyword">int</span>&amp; j = i;</span><br><span class="line">    <span class="keyword">int</span>&amp;&amp; k = <span class="number">11</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"i is_reference: "</span> &lt;&lt; is_reference&lt;<span class="keyword">decltype</span>(i)&gt;::value &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"i is_lvalue_reference: "</span> &lt;&lt; is_lvalue_reference&lt;<span class="keyword">decltype</span>(i)&gt;::value &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"i is_rvalue_reference: "</span> &lt;&lt; is_rvalue_reference&lt;<span class="keyword">decltype</span>(i)&gt;::value &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"j is_reference: "</span> &lt;&lt; is_reference&lt;<span class="keyword">decltype</span>(j)&gt;::value &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"j is_lvalue_reference: "</span> &lt;&lt; is_lvalue_reference&lt;<span class="keyword">decltype</span>(j)&gt;::value &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"j is_rvalue_reference: "</span> &lt;&lt; is_rvalue_reference&lt;<span class="keyword">decltype</span>(j)&gt;::value &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"k is_reference: "</span> &lt;&lt; is_reference&lt;<span class="keyword">decltype</span>(k)&gt;::value &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"k is_lvalue_reference: "</span> &lt;&lt; is_lvalue_reference&lt;<span class="keyword">decltype</span>(k)&gt;::value &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"k is_rvalue_reference: "</span> &lt;&lt; is_rvalue_reference&lt;<span class="keyword">decltype</span>(k)&gt;::value &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下，满足返回1，否则返回0：</p><blockquote><p>i is_reference: 0<br>i is_lvalue_reference: 0<br>i is_rvalue_reference: 0<br>j is_reference: 1<br>j is_lvalue_reference: 1<br>j is_rvalue_reference: 0<br>k is_reference: 1<br>k is_lvalue_reference: 0<br>k is_rvalue_reference: 1</p></blockquote><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>右值引用的写法为 <code>T&amp;&amp; val</code>，两个地址符要挨在一起，在模板中被称为万能引用</li><li>注意左值引用和右值引用的使用区别，其实本质都是为了减少无效的拷贝</li><li><code>std::move()</code> 函数会转移对象的所有权，转移操作之后将左值转为右值引用，原对象不可再直接使用</li><li>可以使用 <code>is_reference</code>、 <code>is_rvalue_reference</code>、 <code>is_lvalue_reference</code> 来判断引用类型</li></ul><hr><blockquote><p>陪伴是最长情的告白，等待是最极致的思念<br>五一离家返工了，心里有些不是滋味，为了家出来奋斗却将“家”抛在了身后，珍惜眼前人吧~</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;右值引用这个词是最开始是学习 &lt;code&gt;easylogging++&lt;/code&gt; 这个日志开源项目的时候遇到的，当时遇到 &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; 这样的写法先是一愣，还有这种写法？难道是引用的地址？结果查询资料才明白这叫做右值引用。&lt;/p&gt;
    
    </summary>
    
      <category term="C/C++" scheme="http://AlbertGithubHome.github.io/blog/categories/C-C/"/>
    
    
      <category term="C/C++" scheme="http://AlbertGithubHome.github.io/blog/tags/C-C/"/>
    
      <category term="左值" scheme="http://AlbertGithubHome.github.io/blog/tags/%E5%B7%A6%E5%80%BC/"/>
    
      <category term="右值" scheme="http://AlbertGithubHome.github.io/blog/tags/%E5%8F%B3%E5%80%BC/"/>
    
      <category term="左值引用" scheme="http://AlbertGithubHome.github.io/blog/tags/%E5%B7%A6%E5%80%BC%E5%BC%95%E7%94%A8/"/>
    
      <category term="右值引用" scheme="http://AlbertGithubHome.github.io/blog/tags/%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>简单聊聊C/C++中的左值和右值</title>
    <link href="http://AlbertGithubHome.github.io/blog/2020/04/24/%E7%AE%80%E5%8D%95%E8%81%8A%E8%81%8AC-C-%E4%B8%AD%E7%9A%84%E5%B7%A6%E5%80%BC%E5%92%8C%E5%8F%B3%E5%80%BC/"/>
    <id>http://AlbertGithubHome.github.io/blog/2020/04/24/简单聊聊C-C-中的左值和右值/</id>
    <published>2020-04-24T15:26:23.000Z</published>
    <updated>2020-04-25T13:36:02.099Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>为什么标题要写成简单聊聊，而不是写成什么“C++中左值与右值详解”或者现在很流行的“惊了！看了这一篇左值与右值讲解，他吊打了面试官”，其实带有详解这个词是需要勇气的，最起码要融会贯通之后才敢这么说吧，本来是学习右值引用的，结果涉及到了左值和右值，然后去了解他们历史发现也是有些混乱，操作中又经常涉及到运算符优先级，真是越学越乱了。</p><a id="more"></a><!-- https://www.cnblogs.com/catch/p/3500678.html --><!-- https://www.cnblogs.com/catch/p/3251937.html --><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>索性也把右值引用放一边，从头来看看这个左值和右值，其实我跟这两个词一点都不熟，最多就是在编译报错的提示框中看到他们，当然有时候也会看到他们的英文名字 <code>lvalue</code> 和 <code>rvalue</code>，这时候一般就是编译器开始抱怨了，说我写了什么它不能理解的东西，其实嘛，我自己都没完全理解，从现在开始边学边总结了，先展示一个常见报错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error: lvalue required as increment operand</span><br></pre></td></tr></table></figure><p>这是什么意思，这么绕嘴，左值需要作为增长操作数，请说人话：自增操作需要一个可以赋值的变量作为操作数，需要变量就直说嘛，为什么要左值、右值的把人都绕蒙了。</p><h1 id="历史渊源"><a href="#历史渊源" class="headerlink" title="历史渊源"></a>历史渊源</h1><p>这个世界一直是在变化的，可能之前你一直引以为豪的经验大楼，转眼之间就会倾塌。关于左值和右值的历史，普遍的观点是最初来源于 <code>C</code> 语言，后来被引入到了 <code>C++</code>，但是关于左值和右值的含义和实现却在一直改变和完善，对于它的历史讲解发现一篇总结的比较好的文章 <a href="https://www.cnblogs.com/dejavu/archive/2012/09/02/2667640.html" target="_blank" rel="noopener">《C/C++ 左值和右值, L-value和R-value》</a>。</p><p>这是2012年的一篇文章，文中给出了历史说明依据，最后还举了一些例子来说明 <code>C</code> 和 <code>C++</code> 关于左值实现的不同，但是实际操作后你会发现，时间的车轮早已向前行进了一大截，文中提到的那些不同，在最新的 <code>gcc</code> 和 <code>g++</code> 编译器上早已变得相同，文中提到的反例现在看来几乎没有意义了。</p><p>简单梳理下，左值的定义最早出现在 《The C Programming Language 》一书中，指的是引用一个对象，放在赋值表达式 <code>=</code> 左边的值。</p><p>后来在新的 <code>C</code> 语言标准中提到左值是赋值表达式 <code>=</code> 左边的值或者需要被改变的值，而等号的右边的值被称为右值。左值更好的表达为可以定位的值，而右值是一种表达数据的值，基于这个表述 <code>L-value</code> 可以理解为 <code>locator value</code>，代表可寻址，而 <code>R-value</code> 可以理解为 <code>read value</code>，代表可读取。</p><p>不过以上的新解，完全是人们为了理解左值、右值赋予的新含义，从历史发展来看，一开始左值和右值完全就是通过等号的左边和右边来命名的，只不过随着标准的完善和语言的发展、更替，虽然两个名字保留了下来，但是它们的含义却在逐步发生改变，与最初诞生时的 <code>=</code> 左右两边的值这个含义相比，已经相差很多了。</p><h1 id="认识左值和右值"><a href="#认识左值和右值" class="headerlink" title="认识左值和右值"></a>认识左值和右值</h1><p>关于左值右值有几条规则和特点，先列举在这里，后面可以跟随例子慢慢体会：</p><ol><li>左值和右值都是指的表达式，比如 <code>int a = 1</code> 中的 <code>a</code> 是左值，<code>++a</code> 是左值, <code>func()</code> 也可能是左值，而 <code>a+1</code> 是右值， <code>110</code> 也是一个右值。</li><li>左值可以放在 <code>=</code> 的左边，右值只能放在 <code>=</code> 的右边，这其中隐含的意思就是左值也能放在 <code>=</code> 的右边，但是右值不能放在 <code>=</code> 的左边。</li><li>左值可以取地址，代表着内存中某个位置，可以存储数据，右值仅仅是一个值，不能取地址，或者它看起来是一个变量，但它是临时的无法取地址，例如一个函数的非引用的值返回。</li></ol><p>以上规则从定义来看一点也不严谨，比如一个常量定义是可以赋值，后面就不行了，它也可以取地址，但是不能赋值的它到底是左值还是右值，这点其实不用纠结，心里知道这个情况就可以了。</p><p>再比如一个普通变量，它原本是一个左值，当用它给其他变量赋值的时候，它又化身为一个右值，这时它也可以取地址，好像与上面的说法相违背了，但是仔细想想真的是这样吗？它只是临时化身为右值，其实是一个左值，所以才可以取地址的。</p><p>其实你如果不做学术研究、不斤斤计较，那么完全可以把能够赋值的表达式作为左值，然后把左值以外的表达式看成右值，如果你不熟悉解左值和右值可能根本不会影响你平时的工作和学习，但是了解它有助于我们深入理解一些内置运算符和程序执行过程，以及在出现编译错误的时候及时定位问题。</p><h1 id="具体的示例"><a href="#具体的示例" class="headerlink" title="具体的示例"></a>具体的示例</h1><h2 id="最简单的赋值语句"><a href="#最简单的赋值语句" class="headerlink" title="最简单的赋值语句"></a>最简单的赋值语句</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> age = <span class="number">18</span>;</span><br></pre></td></tr></table></figure><p>这个赋值语句很简单，<code>=</code> 作为分界线，左边的 <code>age</code> 是左值，可以被赋值，可以取地址，它其实就是一个表达式，代表一个可以存储整数的内存地址；右边的 <code>18</code> 也是一个表达式，明显只能作为右值，不能取地址。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">18</span> = age;</span><br></pre></td></tr></table></figure><p>这个语句在编译时会提示下面的错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error: lvalue required as left operand of assignment</span><br></pre></td></tr></table></figure><p>错误提示显示：赋值语句的左边需要一个左值，显然 <code>18</code> 不能作为左值，它不代表任何内存地址，不能被改变。</p><p>如果程序中的表达式都这么简单就不需要纠结了，接着我们往下看一些复杂点的例子。</p><h2 id="自增自减运算"><a href="#自增自减运算" class="headerlink" title="自增自减运算"></a>自增自减运算</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">++age++;</span><br></pre></td></tr></table></figure><p>第一眼看到这个表达式，你感觉它会怎样运算，编译一下，你会发现编译失败了，错误如下：</p><blockquote><p>error: lvalue required as increment operand</p></blockquote><p>加个括号试试：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">++(age++)</span><br></pre></td></tr></table></figure><p>编译之后会出现相同的错误：</p><blockquote><p>error: lvalue required as increment operand</p></blockquote><p>再换一种加括号的方式再编译一次：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(++age)++</span><br></pre></td></tr></table></figure><p>这次成功编译了，并且输出值之后发现 <code>age</code> 变量增加了两次。</p><p>先不考虑左值右值的问题，我们可以从这个例子中发现自增运算的优先级，后置自增 <code>age++</code> 的优先级要高于前置自增 <code>++age</code> 的优先级。</p><p>现在回过头来看看之前的编译错误，为什么我们加括号改变运算顺序之后就可以正常执行了呢？这其实和自增运算的实现有关。</p><h3 id="前置自增"><a href="#前置自增" class="headerlink" title="前置自增"></a>前置自增</h3><p>前置自增的一般实现，是直接修改原对象，在原对象上实现自增，然后将原对象以引用方式返回：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">UPInt&amp; UPInt::<span class="keyword">operator</span>++()</span><br><span class="line">&#123;</span><br><span class="line">　*<span class="keyword">this</span> += <span class="number">1</span>;    <span class="comment">// 原对象自增</span></span><br><span class="line">　<span class="keyword">return</span> *<span class="keyword">this</span>;  <span class="comment">// 返回原对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里一直操作的是原对象，返回的也是原对象的引用，所以前置自增表达式的结果是左值，它引用的是原对象之前所占用的内存。</p><h3 id="后置自增"><a href="#后置自增" class="headerlink" title="后置自增"></a>后置自增</h3><p>后置自增的一般实现，是先将原对象的数据存储到临时变量中，接着在原对象上实现自增，然后将临时变量以只读的方式返回：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> UPInt UPInt::<span class="keyword">operator</span>++(<span class="keyword">int</span>)</span><br><span class="line">&#123;</span><br><span class="line">　UPInt oldValue = *<span class="keyword">this</span>; <span class="comment">// 将原对象赋值给临时变量</span></span><br><span class="line">　++(*<span class="keyword">this</span>);              <span class="comment">// 原对象自增</span></span><br><span class="line">　<span class="keyword">return</span> oldValue;        <span class="comment">// 返回临时变量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里返回的是临时变量，在函数返回后就被销毁了，无法对其取地址，所以后置自增表达式的结果是右值，不能对其进行赋值。</p><p>所以表达式 <code>++age++;</code> 先进行后置自增，然后再进行前置自增就报出编译错误了，因为不能修改右值，也不能对右值进行自增操作。</p><h3 id="自增表达式赋值"><a href="#自增表达式赋值" class="headerlink" title="自增表达式赋值"></a>自增表达式赋值</h3><p>前面说到前置自增表达式是一个左值，那能不能对其赋值呢？当然可以！试试下面的语句：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">++age = <span class="number">20</span>;</span><br></pre></td></tr></table></figure><p>这条语句是可以正常通过编译的，并且执行之后 <code>age</code> 变量的值为 <code>20</code>。</p><h2 id="函数表达式"><a href="#函数表达式" class="headerlink" title="函数表达式"></a>函数表达式</h2><p>函数可以作为左值吗？带着这个疑问我们看一下这个赋值语句：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func() = <span class="number">6</span>;</span><br></pre></td></tr></table></figure><p>可能有些同学会有疑问，这是正常的语句吗？其实它是可以正常的，只要 <code>func()</code> 是一个左值就可以，怎么才能让他成为一个左值呢，想想刚才的前置自增运算可能会给你启发，要想让他成为左值，它必须代表一个内存地址，写成下面这样就可以了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> g;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>&amp; <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> g;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    func() = <span class="number">100</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数 <code>func()</code> 返回的是全局变量 <code>g</code> 的引用，变量 <code>g</code> 是一个可取地址的左值，所以 <code>func()</code> 表达式也是一个左值，对其赋值后就改变了全局变量 <code>g</code> 的值。</p><p>那么我们注意到这里 <code>func()</code> 函数返回的是全局变量的引用，如果是局部变量会怎么样呢？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>&amp; <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">101</span>;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    func() = <span class="number">100</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码编译没有错误，但是会产生一个警告，提示返回了局部变量的引用:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">warning: reference to local variable ‘i’ returned [-Wreturn-local-addr]</span><br></pre></td></tr></table></figure><p>运行之后可就惨了，直接显示段错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Segmentation fault (core dumped)</span><br></pre></td></tr></table></figure><p>改为局部变量之后，<code>func()</code> 函数虽然返回了一个值，但是这个值是一个临时值，函数返回之后该值被销毁，对应的内存空间也不属于它了，所以在最后赋值的时候才会出现段错误，就和我们访问非法内存是产生的错误时一样的。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>可以被赋值的表达式是左值，左值可以取地址。</li><li>右值应该是一个表示值的表达式，不是左值的表达式都可以看成是右值</li><li>后置自增操作符的优先级要高于前置自增操作符，它们是按照从右向左结合的</li><li>关于左值和右值的知识点还有很多，后续想到了再补充，我也是边学边总结，如果有错误也欢迎小伙伴们及时指出，我会及时改正的</li></ul><hr><blockquote><p>时刻静下来想想当初为什么出发，不要在现实的汪洋中偏离航向</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;为什么标题要写成简单聊聊，而不是写成什么“C++中左值与右值详解”或者现在很流行的“惊了！看了这一篇左值与右值讲解，他吊打了面试官”，其实带有详解这个词是需要勇气的，最起码要融会贯通之后才敢这么说吧，本来是学习右值引用的，结果涉及到了左值和右值，然后去了解他们历史发现也是有些混乱，操作中又经常涉及到运算符优先级，真是越学越乱了。&lt;/p&gt;
    
    </summary>
    
      <category term="C/C++" scheme="http://AlbertGithubHome.github.io/blog/categories/C-C/"/>
    
    
      <category term="C/C++" scheme="http://AlbertGithubHome.github.io/blog/tags/C-C/"/>
    
      <category term="左值" scheme="http://AlbertGithubHome.github.io/blog/tags/%E5%B7%A6%E5%80%BC/"/>
    
      <category term="右值" scheme="http://AlbertGithubHome.github.io/blog/tags/%E5%8F%B3%E5%80%BC/"/>
    
      <category term="lvalue" scheme="http://AlbertGithubHome.github.io/blog/tags/lvalue/"/>
    
      <category term="rvalue" scheme="http://AlbertGithubHome.github.io/blog/tags/rvalue/"/>
    
  </entry>
  
  <entry>
    <title>.bat批处理（九）：替换带有等号=的字符串的子串</title>
    <link href="http://AlbertGithubHome.github.io/blog/2020/04/18/bat%E6%89%B9%E5%A4%84%E7%90%86%EF%BC%88%E4%B9%9D%EF%BC%89%EF%BC%9A%E6%9B%BF%E6%8D%A2%E5%B8%A6%E6%9C%89%E7%AD%89%E5%8F%B7-%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%AD%90%E4%B8%B2/"/>
    <id>http://AlbertGithubHome.github.io/blog/2020/04/18/bat批处理（九）：替换带有等号-的字符串的子串/</id>
    <published>2020-04-18T10:01:16.000Z</published>
    <updated>2020-04-19T03:08:08.169Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>今天写这篇记录要解决的问题来源于最近一名读者的提问，之前写过一篇名为<a href="https://blog.csdn.net/albertsh/article/details/79919465" target="_blank" rel="noopener">《.bat批处理（六）：替换字符串中匹配的子串》</a>的总结文章，结果有读者在评论区提问说，如果想要替换的子串中包含等号 <code>=</code>，那么就无法替换了，问有没有什么办法可以解决。遇到这个问题的第一感觉应该挺好处理的吧，如果批处理程序在替换操作中认为等号 <code>=</code> 比较特殊，那就加个转义字符应该就可以了，但事实却证明这种想法有些天真了。</p><a id="more"></a><p>在尝试多次失败之后，我意识到事情远没有想象的那么简单，开始在网上寻找解决方案，结果有些让人意外，绝大多数人都说这是 <code>SET</code> 命令的执行规则决定的，无法实现这种需求。当要替换的子串中包含 <code>=</code> 时，第一个 <code>=</code> 就会被认为是替换语法中的 <code>=</code>，进而导致无法得到正确的结果，即使是使用转义字符都无法完成正确替换，加入的转义字符会影响匹配，导致替换失败。还有一些人建议用其他工具来完整这种需求，比如记事本的替换功能 <code>O(∩_∩)O</code>。</p><h1 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h1><p>看了上面的叙述，可能有些小伙伴对我所说的问题还没有太直观的认识，接下来我们举个例子来说一下这个问题究竟是怎样产生的。</p><h2 id="0x00-带有-的字符串"><a href="#0x00-带有-的字符串" class="headerlink" title="0x00 带有 = 的字符串"></a>0x00 带有 = 的字符串</h2><p>首先需要被替换的字符串中要包含等号，我们来定义一个这样的变量：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> STR=abcdo=ocar12a=ajdjko=ot</span><br></pre></td></tr></table></figure><p>变量的名字是 <code>STR</code>，变量的值是 <code>abcdo=ocar12a=ajdjko=ot</code>，其中包含了三个 <code>=</code>。</p><h2 id="0x01-带有-的想要被替换的子串"><a href="#0x01-带有-的想要被替换的子串" class="headerlink" title="0x01 带有 = 的想要被替换的子串"></a>0x01 带有 = 的想要被替换的子串</h2><p>确定一下我们想要替换的子串 <code>o=o</code>，假如我们想把它替换成字母 <code>A</code>，按照一般的替换规则<code>X:Y=Z</code>，在 <code>X</code> 串中寻找到 <code>Y</code> 串之后把它替换成 <code>Z</code> 串，实现的代码如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> STR=abcdo=ocar12a=ajdjko=ot</span><br><span class="line"><span class="built_in">set</span> RESULT=%STR:o=o=A%</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> %RESULT%</span><br><span class="line">pause &gt; nul</span><br></pre></td></tr></table></figure><p>运行之后的结果是：</p><blockquote><p>abcdo=A=o=Acar12a=ajdjko=A=o=At</p></blockquote><p>和我们想法不一样，我们本来想把 <code>o=o</code> 替换成 <code>A</code>，但是从结果来看应该是把 <code>o</code> 替换成了 <code>o=A</code>，原因就是我们选择的被替换中的子串 <code>o=o</code> 包含一个 <code>=</code>，而这个 <code>=</code> 被当成了替换语法 <code>X:Y=Z</code> 中的 <code>=</code>，所以就不对了。</p><h2 id="0x02-尝试用转义字符来处理"><a href="#0x02-尝试用转义字符来处理" class="headerlink" title="0x02 尝试用转义字符来处理"></a>0x02 尝试用转义字符来处理</h2><p>很多语言中都有转义字符，比如 Markdown 语法中的反斜杠 <code>\</code>，在 Markdown 语法中被星号 <code>*</code> 包裹的文字是倾斜的，但是如果想正常的输出一个 <code>*</code> 怎么办呢？就需要在 <code>*</code> 前面加一个反斜杠 <code>\</code>，变成 <code>\*</code>，这样 <code>*</code> 原本的倾斜文字的作用就被转义了，变成了一个普通的输出字符。</p><p>在批处理中也有转义字符的概念，它就是 <code>^</code>，我们知道在批处理中 <code>&gt;</code>、<code>|</code> 等符号都是有特殊用处的，所以不能简单的输出，比如 <code>echo &gt;</code> 是无法输出一个大于号的，要写成 <code>echo ^&gt;</code> 才能正常输出一个 <code>&gt;</code> 符号。</p><p>我们就利用这个转义字符来告诉替换命令，被替换的子串中的 <code>=</code> 是一个普通字符，不能作为替换规则的一部分，所以被替换的子串写成了 <code>o^=o</code>，我们实现下面的代码，看看能不能达到目的：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> STR=abcdo=ocar12a=ajdjko=ot</span><br><span class="line"><span class="built_in">set</span> RESULT=%STR:o^=o=A%</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> %RESULT%</span><br><span class="line">pause &gt; nul</span><br></pre></td></tr></table></figure><p>运行之后结果如下：</p><blockquote><p>abcdo=ocar12a=ajdjko=ot</p></blockquote><p>与替换前对比发现没有任何变化，看来转义字符的想法没能帮助我们解决问题，还是想想其他的办法吧。</p><h1 id="稳扎稳打的解决方案"><a href="#稳扎稳打的解决方案" class="headerlink" title="稳扎稳打的解决方案"></a>稳扎稳打的解决方案</h1><p>既然 <code>=</code> 这么特殊，我们就先想办法干掉等号，直接替换的方式不好使，我们可以一个字符一个字符的判断啊，虽然麻烦一点，但是解决问题才是最重要的。</p><p>既然要一个个的字符去判断，就需要遍历原字符串，最简单的可以使用字符串分割啊，语法为 <code>原串:~偏移,长度</code> 就可以了，如果不太清楚可以参考一下 <a href="https://blog.csdn.net/albertsh/article/details/52797519" target="_blank" rel="noopener">《.bat批处理（三）：变量声明、设置、拼接、截取》</a>，截取第一个字符的语法是 <code>原串:~0,1</code>， 截取第二个字符的语法是 <code>原串:~1,1</code>，以此类推。</p><p>具体的思路就是我们先判断第一个字符，如果是 <code>=</code> 就进行替换，如果不是 <code>=</code> 就放到结果字符串里，然后继续判断第二个字符进行操作，最后所有的字符处理一遍就完成了替换。</p><p>需要使用 <code>goto</code> 语句来写一个循环，代码逻辑比较简单，就是遍历所有字符，是 <code>=</code> 就替换，不是 <code>=</code> 就保留，假设我们先把 <code>=</code> 替换成 <code>#</code>，实现的代码如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> STR=abcdo=ocar12a=ajdjko=ot</span><br><span class="line"><span class="built_in">set</span> CURSTR=%STR%</span><br><span class="line"><span class="built_in">set</span> RESULT=</span><br><span class="line"></span><br><span class="line">:next</span><br><span class="line"><span class="keyword">if</span> <span class="string">"%CURSTR%"</span> equ <span class="string">""</span> goto end</span><br><span class="line"><span class="built_in">set</span> a=%CURSTR:~0,1%</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="string">"%a%"</span> equ <span class="string">"="</span> (<span class="built_in">set</span> RESULT=%RESULT%<span class="comment">#) else (set RESULT=%RESULT%%a%)</span></span><br><span class="line"><span class="built_in">set</span> CURSTR=%CURSTR:~1%</span><br><span class="line">goto next</span><br><span class="line"></span><br><span class="line">:end</span><br><span class="line"><span class="built_in">echo</span> <span class="built_in">source</span> string is %STR%</span><br><span class="line"><span class="built_in">echo</span> result string is %RESULT%</span><br><span class="line">pause &gt; nul</span><br></pre></td></tr></table></figure><p><code>:next</code> 是循环的入口，每次截取第一个字符，判断是 <code>=</code> 就在结果中拼接 <code>#</code> 字符，相当于完成了替换，如果字符不是 <code>=</code> ，就将字符直接拼接到结果中，操作之后将原串的第一个字符删除形成新的原串，然后再判断第一个字符，以此类推，直到原串为空，运行结果如下：</p><blockquote><p>source string is abcdo=ocar12a=ajdjko=ot<br>result string is abcdo#ocar12a#ajdjko#ot</p></blockquote><h1 id="最终方案"><a href="#最终方案" class="headerlink" title="最终方案"></a>最终方案</h1><p>事情到了这里好像还没完，在实际操作中有些情况不是替换一个 <code>=</code>，往往是替换的内容中包含 <code>=</code>，上面将 <code>=</code> 替换成 <code>#</code> 不具有通用型，如果是一开始的请求，将 <code>o=o</code>替换成 <code>A</code> 就不能这样写了，就应该是每次判断3个字符了，写起来有些麻烦，批处理中没有获得字符串长度的函数，需要自己实现一个，如果是100个字符的被替换串，那代码就很难写了。</p><p>既然 <code>=</code> 都能被我们替换掉，肯定有办法实现上面我们这种将 <code>o=o</code>替换成 <code>A</code> 的要求，下面我们就列举一种通用的处理方法。</p><h2 id="0x00-首先将-替换成一个原串中不可能出现的字符或者序列"><a href="#0x00-首先将-替换成一个原串中不可能出现的字符或者序列" class="headerlink" title="0x00 首先将 = 替换成一个原串中不可能出现的字符或者序列"></a>0x00 首先将 <code>=</code> 替换成一个原串中不可能出现的字符或者序列</h2><p>这步替换可能最后需要还原的，所以要求我们替换成的目标序列不能在原串中出现，比如我们上面把 <code>=</code> 替换成了 <code>#</code>， 如果原串中有 <code>#</code> 就会弄混了，不能确定是原来字符串中就存在的 <code>#</code>，还是由 <code>=</code> 变成的 <code>#</code>。</p><p>这个序列我们可以定义的变态一点，比如把 <code>=</code> 替换成 <code>###i#am#happy###</code>，我们把它记作 <code>α</code>。</p><h2 id="0x01-用这个不能出现序列替换我们之前要查找替换子串中的"><a href="#0x01-用这个不能出现序列替换我们之前要查找替换子串中的" class="headerlink" title="0x01 用这个不能出现序列替换我们之前要查找替换子串中的 ="></a>0x01 用这个不能出现序列替换我们之前要查找替换子串中的 <code>=</code></h2><p>我们之前要查找替换的子串是 <code>o=o</code>，那么替换之后形成 <code>o###i#am#happy###o</code>，我们把它记作 <code>β</code>。</p><h2 id="0x02-将第1步结束获得的替换结果作为原串，将其中的-β-替换成-A"><a href="#0x02-将第1步结束获得的替换结果作为原串，将其中的-β-替换成-A" class="headerlink" title="0x02 将第1步结束获得的替换结果作为原串，将其中的 β 替换成 A"></a>0x02 将第1步结束获得的替换结果作为原串，将其中的 <code>β</code> 替换成 <code>A</code></h2><p>其实就是把第1步替换完结果作为原串，把其中的 <code>o###i#am#happy###o</code> 也就是原来的 <code>o=o</code> 替换成 <code>A</code>。</p><h2 id="0x03-将第3步结果的子串作为原串，将其中的-α-替换为"><a href="#0x03-将第3步结果的子串作为原串，将其中的-α-替换为" class="headerlink" title="0x03 将第3步结果的子串作为原串，将其中的 α 替换为 ="></a>0x03 将第3步结果的子串作为原串，将其中的 <code>α</code> 替换为 <code>=</code></h2><p>这一步就是处理那些虽然是 <code>=</code>，但是这个 <code>=</code> 不是我要替换的结果子串中的，所以要还原</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><p>步骤梳理清楚了，下面来写代码，按照步骤一步步写就可以了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line"></span><br><span class="line">rem 第一步</span><br><span class="line"><span class="built_in">set</span> CORESTR=<span class="comment">###i#am#happy###</span></span><br><span class="line"><span class="built_in">set</span> STR=abcdo=ocar12a=ajdjko=ot</span><br><span class="line"><span class="built_in">set</span> CURSTR=%STR%</span><br><span class="line"><span class="built_in">set</span> RESULT1=</span><br><span class="line"></span><br><span class="line">:next1</span><br><span class="line"><span class="keyword">if</span> <span class="string">"%CURSTR%"</span> equ <span class="string">""</span> goto end1</span><br><span class="line"><span class="built_in">set</span> a=%CURSTR:~0,1%</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="string">"%a%"</span> equ <span class="string">"="</span> (<span class="built_in">set</span> RESULT1=%RESULT1%%CORESTR%) <span class="keyword">else</span> (<span class="built_in">set</span> RESULT1=%RESULT1%%a%)</span><br><span class="line"><span class="built_in">set</span> CURSTR=%CURSTR:~1%</span><br><span class="line">goto next1</span><br><span class="line"></span><br><span class="line">:end1</span><br><span class="line"><span class="built_in">echo</span> source1 string is %STR%</span><br><span class="line"><span class="built_in">echo</span> result1 string is %RESULT1%</span><br><span class="line">pause &gt; nul</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">rem 第 2 步</span><br><span class="line"><span class="built_in">set</span> CORESTR=<span class="comment">###i#am#happy###</span></span><br><span class="line"><span class="built_in">set</span> STR=o=o</span><br><span class="line"><span class="built_in">set</span> CURSTR=%STR%</span><br><span class="line"><span class="built_in">set</span> RESULT2=</span><br><span class="line"></span><br><span class="line">:next2</span><br><span class="line"><span class="keyword">if</span> <span class="string">"%CURSTR%"</span> equ <span class="string">""</span> goto end2</span><br><span class="line"><span class="built_in">set</span> a=%CURSTR:~0,1%</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="string">"%a%"</span> equ <span class="string">"="</span> (<span class="built_in">set</span> RESULT2=%RESULT2%%CORESTR%) <span class="keyword">else</span> (<span class="built_in">set</span> RESULT2=%RESULT2%%a%)</span><br><span class="line"><span class="built_in">set</span> CURSTR=%CURSTR:~1%</span><br><span class="line">goto next2</span><br><span class="line"></span><br><span class="line">:end2</span><br><span class="line"><span class="built_in">echo</span> source2 string is %STR%</span><br><span class="line"><span class="built_in">echo</span> result2 string is %RESULT2%</span><br><span class="line">pause &gt; nul</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">rem 第3步，需要开启延迟变量</span><br><span class="line">setlocal ENABLEDELAYEDEXPANSION</span><br><span class="line"><span class="built_in">set</span> RESULT3=!RESULT1:%RESULT2%=A!</span><br><span class="line"><span class="built_in">echo</span> result3 string is %RESULT3%</span><br><span class="line">pause &gt; nul</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">rem 第4步</span><br><span class="line"><span class="built_in">set</span> RESULT4=!RESULT3:%CORESTR%==!</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> finally result is %RESULT4%</span><br></pre></td></tr></table></figure><p>运行之后的结果为：</p><blockquote><p>source1 string is abcdo=ocar12a=ajdjko=ot<br>result1 string is abcdo###i#am#happy###ocar12a###i#am#happy###ajdjko###i#am#happy###ot<br>source2 string is o=o<br>result2 string is o###i#am#happy###o<br>result3 string is abcdAcar12a###i#am#happy###ajdjkAt<br>finally result is abcdAcar12a=ajdjkAt</p></blockquote><p>这次终于替换成功了，<code>o=o</code> 被成功替换成了字母 <code>A</code>，代码中用到了延迟变量，主要是为了实现被替换字符串是变量的情况，不清楚延迟变量的用法可以简单查询一下，至此文章开头提出的问题我们就成功解决了，虽然路途有些坎坷。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol><li>批处理程序中的 <code>=</code> 比较特殊，使用常规的 <code>X:Y=Z</code> 的语法不能替换包含 <code>=</code> 的子串</li><li>遇到上述情况可以将字符串切割，采用逐个字符比较的方式，将 <code>=</code> 替换成其他字符再进行后续操作</li><li>有时候也不必非得使用批处理来替换包含 <code>=</code> 的字符串，随便一个文本工具，比如记事本都可以文本进行替换</li><li>如果非得用命令解决，也可以使用从 linux 的 <code>sed</code> 命令移植到 windows 的 <code>sed.exe</code> 程序来很方便的进行替换</li><li>使用 sed 命令的语法是 <code>echo abcdo=ocar12a=ajdjko=ot | sed -e &quot;s/o=o/A/g&quot;</code>，一步就可以完成了文章开头的需求了</li><li>如果你暂时没有 <code>sed.exe</code> 程序，可以点击这个链接 <a href="https://download.csdn.net/download/shihengzhen101/12335608" target="_blank" rel="noopener">sed.exe程序</a> 下载，若不是在同一目录使用，记得将命令目录添加到环境变量中</li></ol><hr><blockquote><p>时间慢慢地磨去了年少轻狂，也渐渐地沉淀了冷暖自知。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;今天写这篇记录要解决的问题来源于最近一名读者的提问，之前写过一篇名为&lt;a href=&quot;https://blog.csdn.net/albertsh/article/details/79919465&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《.bat批处理（六）：替换字符串中匹配的子串》&lt;/a&gt;的总结文章，结果有读者在评论区提问说，如果想要替换的子串中包含等号 &lt;code&gt;=&lt;/code&gt;，那么就无法替换了，问有没有什么办法可以解决。遇到这个问题的第一感觉应该挺好处理的吧，如果批处理程序在替换操作中认为等号 &lt;code&gt;=&lt;/code&gt; 比较特殊，那就加个转义字符应该就可以了，但事实却证明这种想法有些天真了。&lt;/p&gt;
    
    </summary>
    
      <category term="bat" scheme="http://AlbertGithubHome.github.io/blog/categories/bat/"/>
    
    
      <category term="实用工具" scheme="http://AlbertGithubHome.github.io/blog/tags/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/"/>
    
      <category term="bat" scheme="http://AlbertGithubHome.github.io/blog/tags/bat/"/>
    
  </entry>
  
  <entry>
    <title>C++11中的时间库std::chrono（引发关于时间的思考）</title>
    <link href="http://AlbertGithubHome.github.io/blog/2020/04/08/C-11%E4%B8%AD%E7%9A%84%E6%97%B6%E9%97%B4%E5%BA%93std-chrono/"/>
    <id>http://AlbertGithubHome.github.io/blog/2020/04/08/C-11中的时间库std-chrono/</id>
    <published>2020-04-08T15:18:13.000Z</published>
    <updated>2020-04-12T12:54:33.281Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>时间都去哪了？还没好好感受年轻就…</p></blockquote><hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>时间是宝贵的，我们无时无刻不在和时间打交道，这个任务明天下班前截止，你点的外卖还有5分钟才能送到，那个程序已经运行了整整48个小时，既然时间和我们联系这么紧密，我们总要定义一些术语来描述它，像前面说到的明天下班前、5分钟、48个小时都是对时间的描述，程序代码构建的程序世界也需要定义一些术语来描述时间。</p><a id="more"></a><p>今天要总结学习的是 <code>std::chrono</code> 库，它是 <code>C++11</code> 标准时从 <code>boost</code> 库中引入的，其实在 C++ 中还有一种 <code>C</code> 语言风格的时间管理体系，像我们常见的函数 <code>time()</code>、<code>clock()</code>、<code>localtime()</code>、<code>mktime()</code> 和常见的类型 <code>tm</code>、<code>time_t</code>、<code>clock_t</code> 都是 <code>C</code> 语言风格的时间管理体系。</p><p><code>std::chrono</code> 这个库之前接触的不多，<code>C++20</code> 标准都出了，<code>C++11</code> 引入的这个库还没怎么用过，整天和 <code>time()</code>、 <code>localtime()</code>、 <code>tm</code> 打交道，最近工作中换了项目，代码中出现了 <code>std::chrono</code> 的使用，是时候好好学习总结一下了。</p><h1 id="chrono-的概况"><a href="#chrono-的概况" class="headerlink" title="chrono 的概况"></a>chrono 的概况</h1><ul><li>头文件 <code>#include &lt;chrono&gt;</code></li><li>命名空间 <code>std::chrono</code></li></ul><p>这个库从 <code>C++11</code> 引入标准之后，每个版本都有所修改，不过核心内容变化不是太大，他定义了三种主要类型，分别是 <code>durations</code>、<code>clocks</code> 和 <code>time points</code>，以及围绕这些类型的一些工具函数和衍生的定义。</p><h1 id="chrono-的核心内容"><a href="#chrono-的核心内容" class="headerlink" title="chrono 的核心内容"></a>chrono 的核心内容</h1><h2 id="duration"><a href="#duration" class="headerlink" title="duration"></a>duration</h2><p>这个模板类用来表示时间间隔，我们知道时间的基本单位是秒，这个类的对象所表示的时间间隔也是以秒为单位的，它的定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Rep</span>, <span class="title">class</span> <span class="title">Period</span> = <span class="title">std</span>:</span>:ratio&lt;<span class="number">1</span>&gt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">duration</span>;</span></span><br></pre></td></tr></table></figure><p><code>Rep</code> 表示一种数值类型，用来描述周期 <code>Period</code> 的数值类型，比如可以是 <code>int</code>、<code>float</code> 等，而 <code>Period</code> 的类型是 <code>std::ratio</code>，同样是一个模板类，实际表示的是一个有理数，像100、0、1/1000（千分之一）等等。</p><p>在 <code>std</code> 这个命名空间下有很多已经定义好的有理数，可以举几个常见的头文件 <code>&lt;ratio&gt;</code> 中的例子:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">nano    <span class="built_in">std</span>::ratio&lt;<span class="number">1</span>, <span class="number">1000000000</span>&gt;   <span class="comment">// 十亿分之一</span></span><br><span class="line">micro   <span class="built_in">std</span>::ratio&lt;<span class="number">1</span>, <span class="number">1000000</span>&gt;      <span class="comment">// 百万分之一</span></span><br><span class="line">milli   <span class="built_in">std</span>::ratio&lt;<span class="number">1</span>, <span class="number">1000</span>&gt;         <span class="comment">// 千分之一</span></span><br><span class="line">centi   <span class="built_in">std</span>::ratio&lt;<span class="number">1</span>, <span class="number">100</span>&gt;          <span class="comment">// 百分之一</span></span><br><span class="line">deci    <span class="built_in">std</span>::ratio&lt;<span class="number">1</span>, <span class="number">10</span>&gt;           <span class="comment">// 十分之一</span></span><br><span class="line">deca    <span class="built_in">std</span>::ratio&lt;<span class="number">10</span>, <span class="number">1</span>&gt;           <span class="comment">// 十</span></span><br><span class="line">hecto   <span class="built_in">std</span>::ratio&lt;<span class="number">100</span>, <span class="number">1</span>&gt;          <span class="comment">// 百</span></span><br><span class="line">kilo    <span class="built_in">std</span>::ratio&lt;<span class="number">1000</span>, <span class="number">1</span>&gt;         <span class="comment">// 千</span></span><br></pre></td></tr></table></figure><p>比如我们想定义一个整数类型的100秒的时间间隔类型可以使用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">std</span>::chrono::duration&lt;<span class="keyword">int</span>, <span class="built_in">std</span>::ratio&lt;<span class="number">100</span>,<span class="number">1</span>&gt;&gt; my_duration_type;</span><br></pre></td></tr></table></figure><p>当然也可以简写成：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">std</span>::chrono::duration&lt;<span class="keyword">int</span>, <span class="built_in">std</span>::hecto&gt; my_duration_type;</span><br></pre></td></tr></table></figure><p>如果我们想定义一个整数类型1分钟的时间间隔类型可以写成：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">std</span>::chrono::duration&lt;<span class="keyword">int</span>, <span class="built_in">std</span>::ratio&lt;<span class="number">60</span>,<span class="number">1</span>&gt;&gt; my_minute_type;</span><br></pre></td></tr></table></figure><p>因为这种时、分、秒的时间表示在代码逻辑中很常用，所有在 <code>std::chrono</code> 命名空间下已经定义好了一些时间间隔类型:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">std::chrono::nanoseconds    duration&lt;/*signed integer type of at least 64 bits*/, std::nano&gt;</span><br><span class="line">std::chrono::microseconds   duration&lt;/*signed integer type of at least 55 bits*/, std::micro&gt;</span><br><span class="line">std::chrono::milliseconds   duration&lt;/*signed integer type of at least 45 bits*/, std::milli&gt;</span><br><span class="line">std::chrono::seconds        duration&lt;/*signed integer type of at least 35 bits*/&gt;</span><br><span class="line">std::chrono::minutes        duration&lt;/*signed integer type of at least 29 bits*/, std::ratio&lt;60&gt;&gt;</span><br><span class="line">std::chrono::hours          duration&lt;/*signed integer type of at least 23 bits*/, std::ratio&lt;3600&gt;&gt;</span><br></pre></td></tr></table></figure><p>另外还有一个很重要的成员函数 <code>count()</code>，用来获得指定的时间间隔对象中包含多少个时间周期，接下来可以写个例子理解一下，我们用 <code>duration</code> 这个模板类来表示一下5分钟和12小时，看看他应该怎么使用，对于5分钟你可以看成是 5 个 1 分钟或者 1 个 5 分钟，或者更变态你可以看成 2.5 个 2 分钟，而 12 小时一般会看成是 12个 1 小时，你当成 0.5 个 1 天也是可以的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 以下为5分钟表达</span></span><br><span class="line">    <span class="built_in">std</span>::chrono::minutes minute1&#123;<span class="number">5</span>&#125;; <span class="comment">// 5个1分钟</span></span><br><span class="line">    <span class="built_in">std</span>::chrono::duration&lt;<span class="keyword">int</span>, <span class="built_in">std</span>::ratio&lt;<span class="number">5</span>*<span class="number">60</span>, <span class="number">1</span>&gt;&gt; minute2&#123;<span class="number">1</span>&#125;; <span class="comment">// 1个5分钟</span></span><br><span class="line">    <span class="built_in">std</span>::chrono::duration&lt;<span class="keyword">double</span>, <span class="built_in">std</span>::ratio&lt;<span class="number">2</span>*<span class="number">60</span>, <span class="number">1</span>&gt;&gt; minute3&#123;<span class="number">2.5</span>&#125;; <span class="comment">// 2.5个2分钟</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;  <span class="string">"minutes1 duration has "</span> &lt;&lt; minute1.count() &lt;&lt; <span class="string">" ticks\n"</span></span><br><span class="line">              &lt;&lt;  <span class="string">"minutes2 duration has "</span> &lt;&lt; minute2.count() &lt;&lt; <span class="string">" ticks\n"</span></span><br><span class="line">              &lt;&lt;  <span class="string">"minutes3 duration has "</span> &lt;&lt; minute3.count() &lt;&lt; <span class="string">" ticks\n"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一下为12小时表达</span></span><br><span class="line">    <span class="built_in">std</span>::chrono::hours hours1&#123;<span class="number">12</span>&#125;; <span class="comment">// 12个1小时</span></span><br><span class="line">    <span class="built_in">std</span>::chrono::duration&lt;<span class="keyword">double</span>, <span class="built_in">std</span>::ratio&lt;<span class="number">60</span>*<span class="number">60</span>*<span class="number">24</span>, <span class="number">1</span>&gt;&gt; hours2&#123;<span class="number">0.5</span>&#125;; <span class="comment">// 0.5个1天</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;  <span class="string">"hours1 duration has "</span> &lt;&lt; hours1.count() &lt;&lt; <span class="string">" ticks\n"</span></span><br><span class="line">              &lt;&lt;  <span class="string">"hours2 duration has "</span> &lt;&lt; hours2.count() &lt;&lt; <span class="string">" ticks\n"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 std::chrono::duration_cast&lt;T&gt; 将分钟间隔转化成标准秒间隔</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;  <span class="string">"minutes1 duration has "</span> &lt;&lt;</span><br><span class="line">        <span class="built_in">std</span>::chrono::duration_cast&lt;<span class="built_in">std</span>::chrono::seconds&gt;(minute1).count() &lt;&lt; <span class="string">" seconds\n"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中还使用了 <code>std::chrono::duration_cast&lt;T&gt;()</code> 函数，用于各种时间间隔的换算，运行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">minutes1 duration has 5 ticks</span><br><span class="line">minutes2 duration has 1 ticks</span><br><span class="line">minutes3 duration has 2.5 ticks</span><br><span class="line">hours1 duration has 12 ticks</span><br><span class="line">hours2 duration has 0.5 ticks</span><br><span class="line">minutes1 duration has 300 seconds</span><br></pre></td></tr></table></figure><h2 id="clock"><a href="#clock" class="headerlink" title="clock"></a>clock</h2><p>从名字可以看出这个类叫做时钟，时钟是用来看时间和计时的，常用的两个类是 <code>system_clock</code> 和 <code>steady_clock</code>，在 <code>C++20</code> 标准中又加入了多种内容，现在我们先来看看这两个常用类。</p><p>从这一部分开始类的定义让人有些迷糊，其实 clock 引用了 <code>std::chrono::duration</code> 和后面要说的 <code>std::chrono::time_point</code>， 而 <code>std::chrono::time_point</code> 又引用了 <code>std::chrono::duration</code> 和现在要讲的 <code>std::chrono::system_clock</code>、 <code>std::chrono::steady_clock</code>，如果只看定义很容易被绕晕，所以还是先做个练习实验一下。</p><h3 id="system-clock"><a href="#system-clock" class="headerlink" title="system_clock"></a>system_clock</h3><p>这个类被称为系统内时钟，当修改系统时钟时可能会改变其单调递增的性质，静态成员函数有 <code>now()</code>、<code>to_time_t()</code>、<code>from_time_t()</code> 三个，关于它的单调性被修改举个例子，一般认为时间一直是递增的，但是当你现在调用一次函数 <code>now()</code>，然后把时间往过去调1天，然后再调用 <code>now()</code> 函数，就会发现新得到的时间“变小”了。</p><p>也因为这样它会受到 NTP（Network Time Protocol，网络时间协议）的影响，但是不会受时区和夏令时的影响（其实很多国家早就废除夏令时了）。</p><p>下面写个例子练习一下，例子中使用了 <code>now()</code>、<code>to_time_t()</code>、<code>from_time_t()</code> 三个函数，不清楚的时候可以对照一下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::chrono::duration&lt;<span class="keyword">int</span>, <span class="built_in">std</span>::ratio&lt;<span class="number">60</span>*<span class="number">60</span>*<span class="number">24</span>&gt; &gt; one_day(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据时钟得到现在时间</span></span><br><span class="line">    <span class="built_in">std</span>::chrono::system_clock::time_point today = <span class="built_in">std</span>::chrono::system_clock::now();</span><br><span class="line">    <span class="built_in">std</span>::<span class="keyword">time_t</span> time_t_today = <span class="built_in">std</span>::chrono::system_clock::<span class="keyword">to_time_t</span>(today);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;  <span class="string">"now time stamp is "</span> &lt;&lt; time_t_today &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;  <span class="string">"now time is "</span> &lt;&lt; ctime(&amp;time_t_today) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 看看明天的时间</span></span><br><span class="line">    <span class="built_in">std</span>::chrono::system_clock::time_point tomorrow = today + one_day;</span><br><span class="line">    <span class="built_in">std</span>::<span class="keyword">time_t</span> time_t_tomorrow = <span class="built_in">std</span>::chrono::system_clock::<span class="keyword">to_time_t</span>(tomorrow);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;  <span class="string">"tomorrow time stamp is "</span> &lt;&lt; time_t_tomorrow &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;  <span class="string">"tomorrow time is "</span> &lt;&lt; ctime(&amp;time_t_tomorrow) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算下个小时时间</span></span><br><span class="line">    <span class="built_in">std</span>::chrono::system_clock::time_point next_hour = today + <span class="built_in">std</span>::chrono::hours(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="keyword">time_t</span> time_t_next_hour = <span class="built_in">std</span>::chrono::system_clock::<span class="keyword">to_time_t</span>(next_hour);</span><br><span class="line">    <span class="built_in">std</span>::chrono::system_clock::time_point next_hour2 = <span class="built_in">std</span>::chrono::system_clock::<span class="keyword">from_time_t</span>(time_t_next_hour);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="keyword">time_t</span> time_t_next_hour2 = <span class="built_in">std</span>::chrono::system_clock::<span class="keyword">to_time_t</span>(next_hour2);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;  <span class="string">"tomorrow time stamp is "</span> &lt;&lt; time_t_next_hour2 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;  <span class="string">"tomorrow time is "</span> &lt;&lt; ctime(&amp;time_t_next_hour2) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">now time stamp is <span class="number">1586662332</span></span><br><span class="line">now time is Sun Apr <span class="number">12</span> <span class="number">11</span>:<span class="number">32</span>:<span class="number">12</span> <span class="number">2020</span></span><br><span class="line"></span><br><span class="line">tomorrow time stamp is <span class="number">1586748732</span></span><br><span class="line">tomorrow time is Mon Apr <span class="number">13</span> <span class="number">11</span>:<span class="number">32</span>:<span class="number">12</span> <span class="number">2020</span></span><br><span class="line"></span><br><span class="line">tomorrow time stamp is <span class="number">1586665932</span></span><br><span class="line">tomorrow time is Sun Apr <span class="number">12</span> <span class="number">12</span>:<span class="number">32</span>:<span class="number">12</span> <span class="number">2020</span></span><br></pre></td></tr></table></figure><h3 id="steady-clock"><a href="#steady-clock" class="headerlink" title="steady_clock"></a>steady_clock</h3><p>这是一个单调时钟，一旦启动之后就与系统时间没有关系了，完全根据物理是时间向前移动，成员函数只有一个 <code>now()</code>，通常可以用来计时，使用方法与 <code>system_clock</code> 相比简单许多，下面写个小例子。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 先记录程序运行时间</span></span><br><span class="line">    <span class="built_in">std</span>::chrono::steady_clock::time_point start = <span class="built_in">std</span>::chrono::steady_clock::now();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> nDstVal, nSrcVal;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000000</span>; ++i)</span><br><span class="line">        nDstVal = nSrcVal;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 做差值计算耗时</span></span><br><span class="line">    <span class="built_in">std</span>::chrono::duration&lt;<span class="keyword">double</span>&gt; duration_cost = <span class="built_in">std</span>::chrono::duration_cast&lt;</span><br><span class="line">        <span class="built_in">std</span>::chrono::duration&lt;<span class="keyword">double</span>&gt; &gt;(<span class="built_in">std</span>::chrono::steady_clock::now() - start);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;  <span class="string">"total cost "</span> &lt;&lt; duration_cost.count() &lt;&lt; <span class="string">" seconds."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">total cost 1.9424 seconds.</span><br></pre></td></tr></table></figure></p><h2 id="time-point"><a href="#time-point" class="headerlink" title="time point"></a>time point</h2><p>这个类与 <code>duration</code> 类似，同样是模板类，表示具体的时间点，比如今天 18:00 开饭，明天上午 10:00 发版本，今年 5 月 1 日可能因为疫情不让出去玩了，像这些具体的时间点可以使用 <code>std::chrono::time_point</code> 来表达，它的定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Clock</span>, <span class="title">class</span> <span class="title">Duration</span> = <span class="title">typename</span> <span class="title">Clock</span>:</span>:duration&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">time_point</span>;</span></span><br></pre></td></tr></table></figure><p>首先这个类是在 <code>std::chrono</code> 这个命名空间下，但是你会经常看到以下这种写法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::chrono::system_clock::time_point today = <span class="built_in">std</span>::chrono::system_clock::now();</span><br><span class="line"><span class="built_in">std</span>::chrono::steady_clock::time_point start = <span class="built_in">std</span>::chrono::steady_clock::now();</span><br></pre></td></tr></table></figure><p>好像 <code>time_point</code> 又在 <code>std::chrono::system_clock</code> 和 <code>std::chrono::steady_clock</code> 范围内，实际上这两个范围内的 <code>time_point</code> 引用的是 <code>std::chrono::time point</code>，看看 <code>std::chrono::system_clock</code> 的定义能明白一些。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">system_clock</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">using</span> rep = <span class="comment">/*see description*/</span> ;</span><br><span class="line">  <span class="keyword">using</span> period = ratio&lt;<span class="comment">/*unspecified*/</span>, <span class="comment">/*unspecified*/</span> &gt;;</span><br><span class="line">  <span class="keyword">using</span> duration = chrono::duration&lt;rep, period&gt;;</span><br><span class="line">  <span class="keyword">using</span> time_point = chrono::time_point&lt;system_clock&gt;;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">bool</span> is_steady = <span class="comment">/*unspecified*/</span> ;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> time_point <span class="title">now</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line">  <span class="comment">// Map to C API</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> time_t <span class="title">to_time_t</span> <span class="params">(<span class="keyword">const</span> time_point&amp; t)</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> time_point <span class="title">from_time_t</span><span class="params">(<span class="keyword">time_t</span> t)</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>对照上面的定义可以知道，<code>std::chrono::system_clock::time_point</code> 实际上 <code>std::chrono::time_point&lt;system_clock&gt;</code>，这几个时间类的定义相互引用，看到这一部分的时候一定不要烦躁，一步步推导分析其中的关系。</p><p><code>time_point</code> 这个类有一个成员函数 <code>time_since_epoch()</code> 用来获得 <code>1970-01-01 00:00:00</code> 到 <code>time_point</code> 时间经过的 <code>duration</code>, 返回的 <code>duration</code> 的单位取决于 <code>timepoint</code> 定义时的 <code>duraion</code> 的单位，不过你也可以得到 <code>duration</code> 之后使用 <code>std::chrono::duration_cast&lt;T&gt;()</code> 函数来转化。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 获得epoch 和 now 的时间点</span></span><br><span class="line">    <span class="built_in">std</span>::chrono::time_point&lt;<span class="built_in">std</span>::chrono::system_clock&gt; epoch =</span><br><span class="line">        <span class="built_in">std</span>::chrono::time_point&lt;<span class="built_in">std</span>::chrono::system_clock&gt;&#123;&#125;;</span><br><span class="line">    <span class="built_in">std</span>::chrono::time_point&lt;<span class="built_in">std</span>::chrono::system_clock&gt; now =</span><br><span class="line">        <span class="built_in">std</span>::chrono::system_clock::now();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显示时间点对应的日期和时间</span></span><br><span class="line">    <span class="keyword">time_t</span> epoch_time = <span class="built_in">std</span>::chrono::system_clock::<span class="keyword">to_time_t</span>(epoch);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"epoch: "</span> &lt;&lt; <span class="built_in">std</span>::ctime(&amp;epoch_time);</span><br><span class="line">    <span class="keyword">time_t</span> today_time = <span class="built_in">std</span>::chrono::system_clock::<span class="keyword">to_time_t</span>(now);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"today: "</span> &lt;&lt; <span class="built_in">std</span>::ctime(&amp;today_time);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显示duration的值</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"seconds since epoch: "</span></span><br><span class="line">        &lt;&lt; <span class="built_in">std</span>::chrono::duration_cast&lt;<span class="built_in">std</span>::chrono::seconds&gt;(epoch.time_since_epoch()).count()</span><br><span class="line">        &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"today, ticks since epoch: "</span></span><br><span class="line">        &lt;&lt; now.time_since_epoch().count()</span><br><span class="line">        &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"today, hours since epoch: "</span></span><br><span class="line">        &lt;&lt; <span class="built_in">std</span>::chrono::duration_cast&lt;<span class="built_in">std</span>::chrono::hours&gt;(now.time_since_epoch()).count()</span><br><span class="line">        &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">epoch: Thu Jan  1 08:00:00 1970</span><br><span class="line">today: Sun Apr 12 12:30:04 2020</span><br><span class="line">seconds since epoch: 0</span><br><span class="line">today, ticks since epoch: 1586665804624992500</span><br><span class="line">today, hours since epoch: 440740</span><br></pre></td></tr></table></figure><p>从运行结果来看，epoch 的时间点是 <code>Thu Jan  1 08:00:00 1970</code>，为什么不是 <code>1970-01-01 00:00:00</code> 呢？那是因为我们在东8区，格林威治时间为<br><code>1970-01-01 00:00:00</code> 的时候，我们的时间就是 <code>Thu Jan  1 08:00:00 1970</code>，这样看来 <code>std::ctime()</code> 这个函数考虑了时区的影响，相同的代码如果在韩国同时运行得到的可能就是 <code>epoch: Thu Jan  1 09:00:00 1970</code>。</p><h1 id="关于时间的思考"><a href="#关于时间的思考" class="headerlink" title="关于时间的思考"></a>关于时间的思考</h1><p>思考一个问题，时间是不是一种不变的量，或者换一种说法，它是不是一种均匀的量。如果了解过《三体》中的部分章节，你就会发现时间总在被任意改变着。但是在现实生活中好像时间就是一个标准，我们认为它是一成不变的，总是感觉今天的1天和昨天的24小时在时间上是等同的，今年的这一年和去年的365天是等同的，但其实你了解一下闰年、闰秒、夏令时就会发现，前面提到的这些未必等同。</p><p>日常生活中对时间的描述只是为了理解和阐明一些事物，我们把太阳升到头顶叫做中午，把地球自转一圈叫做一天24小时，把地球围绕太阳公转一圈叫做1年365天，但是地球自转不是那么均匀的，也就是说每转一圈占用的绝对时间是不一样的，我们现在使用的时钟通常是滴答滴答一秒秒的走着，如果地球自转一圈的时间不是完全相同的，那么建立在这个滴答上的一切时间都是不准确的。</p><p>什么是建立在滴答滴答上的时间，我们以滴答一次作为1秒来计算，那么1分钟是60秒，也就是滴答60次，1小时是60分钟，滴答3600次，一天是24小时，滴答86400次，滴答的次数是均匀的，但是自转和公转是不均匀的，那么两个时间就对不上了，所以出现了闰秒、闰年等方法来调整时间，使得我们用来描述生活的时间和周围的环境现象可以一致，不然大约几千年以后就会出现中午12点天上出现月亮的奇观，那时的人们在史书中会发现我们这个时代中午12点挂在天上的是太阳，简直太玄幻。</p><p>有没有一种计时可以描述这种不均匀的自转呢？其实我们伟大的古人早已经发明出来了，你一定听说过日晷这种计时工具，它是观测日影记时的仪器，主要是根据日影的在日晷面上的位置，以指定当时的时辰或刻数，是我国古代较为普遍使用的计时仪器。为什么它没有时间不一致的问题？因为它本身就是不均匀的，它是根据自然现象来规定生活中每天的时间的，其实对照现在来说就是每个时辰的滴答数实际上是不一样的。</p><p>日晷这种不均匀的计时其实是为了适应天文现象，方便人们的生产生活，所以说现在地球自转一圈是一天，但不一定是86400秒，地球公转一圈是一年，但不一定是365天，后来人们使用电子设备计时，按道理来说应该非常准确，但是因为地球自转、公转的速率都不稳定，这种差距渐渐地会给生活带来困扰，于是又发明了一个折中的协调世界时，会在适当的时候闰秒、闰天，以弥补这种差距。假如你买了一个绝对精准的不联网的电子计时器，但是几年之后你就会发现你的计时器肯定和大家使用的标准时间不一致了。</p><p>其实还有一种基于特定铯原子的振荡周期来确定的国际原子时，主要是在时间精度要求较高的航天、通讯、电子等领域，为了保持系统的连续性而使用的，在日常生活中基本不会使用，但是这个时间是相对恒定的，不会去计较天文现象，每一秒都“准确”的流逝着。</p><h1 id="时间函数思考"><a href="#时间函数思考" class="headerlink" title="时间函数思考"></a>时间函数思考</h1><p>现在回过头来再来看这些时间函数，是不是感觉有点不一样了，比如 <code>time(NULL)</code> 这个函数，它返回的是从 <code>1970-01-01 00:00:00</code> 到现在时间的秒数，回忆一下上面关于时间的思考，这个秒数真的是准确的吗？其实你如果理解了上面的内容就能得出结论，它肯定和国际原子时是有出入的。</p><p>再考虑下闰秒的影响，假如你实现了一个函数，第一次执行是在0点执行，执行之后你设置了一个86400秒的倒计时，也就是1天的时间，到第二天0点的时候正好又执行，你又设置了一个86400秒的倒计时，但今天正好是闰秒的日子，也就是今天会比昨天多1秒，那么今天的时间到23:59:59的时候就经过了86400秒，也就是说在23:59:59的时候就会执行你写的函数，如果碰到秒杀就尴尬了…</p><p>一般的程序开发不用太考虑闰秒的影响，但是如果这一秒的误差出现的宇宙飞船的飞行中，可能会导致几十公里的误差，所以程序员们一定要理解闰秒的可能带来的问题，评估自己所写的代码需不需要处理这种情况。曾经的一次闰秒直接导致了芬兰航空系统的瘫痪，所以一些大型项目还是会提前很长时间就把即将到来的闰秒处理写入到自己的系统中，以应对它带来的危险。</p><p>当你认为时间不会倒流的时候，它确实就发生了。我们一般假定时间不会倒流，但是如果你过分依赖这个特性，可能就会导致一些问题，这种情况常常出现设定了自动校准时间的电脑上，电脑的时间走快了，然后到达一定的差距后会触发校准程序，这时就会出现“时间倒流”的现象，比如 <code>time(NULL)</code> 这种依赖于电脑时间的函数，在这种情况下函数返回值就会变小，出现不单调性。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>关于时间的操作真的太多了，我居然发现一种名为 <code>operator&quot;&quot;h</code> 的操作符，与数字连用表示小时，有兴趣的话可以自己扩展学习一下。</li><li><code>durations</code>、<code>clocks</code> 和 <code>time points</code> 三种有关时间操作的定义相互之间是有引用的，需要理清其中的关系。</li><li>需要了解闰秒、闰年、天文时、原子时、协调时产生的原因，这样就可以做到熟悉原理，心里不慌。</li><li>在测试的例子中出现了时区的概念，其实是人们为了生产生活主动创造出来以适应自然现象的。</li><li>这里抛出一个疑问，我之前刚接触时晕乎了很久，后来渐渐才明白，有些时间函数的说明中会提到与时区无关，比如 <code>time(NULL)</code>、还有今天学习的 <code>system_clock</code>，但是当我修改电脑时区的时候会发现，这些函数的返回值会发生突变，大家有探究过其中的原因吗？</li></ul><hr><blockquote><p>我们都是追逐时间奔跑的蝼蚁，改变世界的同时也被时间改变着。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;时间都去哪了？还没好好感受年轻就…&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;时间是宝贵的，我们无时无刻不在和时间打交道，这个任务明天下班前截止，你点的外卖还有5分钟才能送到，那个程序已经运行了整整48个小时，既然时间和我们联系这么紧密，我们总要定义一些术语来描述它，像前面说到的明天下班前、5分钟、48个小时都是对时间的描述，程序代码构建的程序世界也需要定义一些术语来描述时间。&lt;/p&gt;
    
    </summary>
    
      <category term="C/C++" scheme="http://AlbertGithubHome.github.io/blog/categories/C-C/"/>
    
    
      <category term="C++" scheme="http://AlbertGithubHome.github.io/blog/tags/C/"/>
    
      <category term="C++11" scheme="http://AlbertGithubHome.github.io/blog/tags/C-11/"/>
    
      <category term="chrono" scheme="http://AlbertGithubHome.github.io/blog/tags/chrono/"/>
    
      <category term="时间" scheme="http://AlbertGithubHome.github.io/blog/tags/%E6%97%B6%E9%97%B4/"/>
    
  </entry>
  
  <entry>
    <title>Win10通过带命令行的安全模式清除顽固的广告弹窗文件</title>
    <link href="http://AlbertGithubHome.github.io/blog/2020/04/02/Win10%E9%80%9A%E8%BF%87%E5%B8%A6%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%9A%84%E5%AE%89%E5%85%A8%E6%A8%A1%E5%BC%8F%E6%B8%85%E9%99%A4%E9%A1%BD%E5%9B%BA%E7%9A%84%E5%B9%BF%E5%91%8A%E5%BC%B9%E7%AA%97%E6%96%87%E4%BB%B6/"/>
    <id>http://AlbertGithubHome.github.io/blog/2020/04/02/Win10通过带命令行的安全模式清除顽固的广告弹窗文件/</id>
    <published>2020-04-02T14:57:53.000Z</published>
    <updated>2020-04-06T15:05:30.015Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近电脑开机后偶尔会出现一个弹窗，这种广告弹窗见的多了也就麻木了，本来也没放在心上，随手一关就准备去做其他事情了，但是点击关闭按钮后这个广告弹窗居然还弹出了二次确认框，想想也忍了，毕竟广告商做半天就是为了让你多看几眼，当我用鼠标的光标接近这个确认按钮时，确认框消失了，整个广告页面居然还在！</p><a id="more"></a><p>一开始我还以为自己手滑点错了，后来试了3、4次之后发现，这个二次确认框从出来到消失不到1秒钟，以我的手速试了这么多次就没点到，这次暴脾气上来了，再也不忍了，我必须找到你是哪个软件的广告页，然后把你干掉！</p><h1 id="战斗经历"><a href="#战斗经历" class="headerlink" title="战斗经历"></a>战斗经历</h1><p>本以为找到软件直接卸载就完事了，没想到碰上硬茬了，这个软件大有来头，真不是随随便便能搞定的。</p><h2 id="查找广告来源"><a href="#查找广告来源" class="headerlink" title="查找广告来源"></a>查找广告来源</h2><p>这一步比较简单，这个打开的广告页在任务栏上有个图标，鼠标光标放到图标上会显示缩略图，就像下面这样：</p><p><img src="https://cdn.jsdelivr.net/gh/albertgithubhome/cdn/img/cmddel1.png" alt="cmddel1"></p><p>在图标上单击右键，然后在弹出菜单中将光标移到最上面的选项继续单击右键，这时会在弹出一个菜单，如果一次不行就多试几次：</p><p><img src="https://cdn.jsdelivr.net/gh/albertgithubhome/cdn/img/cmddel2.png" alt="cmddel2"></p><p>这时点击菜单上的属性按钮会弹出这个广告页对应程序的属性页面：</p><p><img src="https://cdn.jsdelivr.net/gh/albertgithubhome/cdn/img/cmddel3.png" alt="cmddel3"></p><h2 id="开始删除程序"><a href="#开始删除程序" class="headerlink" title="开始删除程序"></a>开始删除程序</h2><p>让我找到你了吧，目录是 <code>D:\Program Files (x86)\MyDrivers\DriverGenius\ksoft</code>，看来是驱动精灵软件带来的广告页，直接进入目录删除：</p><p><img src="https://cdn.jsdelivr.net/gh/albertgithubhome/cdn/img/cmddel7.png" alt="cmddel4"></p><p>尴尬！提示“你需要提供管理员权限才能删除此文件”，点击“继续”按钮试试：</p><p><img src="https://cdn.jsdelivr.net/gh/albertgithubhome/cdn/img/cmddel8.png" alt="cmddel5"></p><p>依旧不行，提示“你需要权限执行此操作”、“你需要Administrators提供的权限才能对此文件进行更改”，真是有点诡异，一个普通软件居然还要管理员权限才能删。</p><h2 id="找管理员帮忙"><a href="#找管理员帮忙" class="headerlink" title="找管理员帮忙"></a>找管理员帮忙</h2><p>没办法了，提权吧！我把沉睡的管理员账号的都开启了，再试一次还是不行，我可是 Administrator 啊，在这个电脑中还有什么是我不能干的吗？</p><blockquote><p>微软：“你能干什么你说了不算，我说了算！”。</p></blockquote><p>右键单击软件查看属性是不是只读了呢？没有啊！这时我还没意识到它究竟有多难缠，以为简简单单设置几个属性就能把它删掉，于是一拍脑袋决定，这种情况下一般需要修改权限啊，然后在属性面板中点击了“安全”选项卡：</p><p><img src="https://cdn.jsdelivr.net/gh/albertgithubhome/cdn/img/cmddel4.png" alt="cmddel6"></p><p>然后点击“高级按钮”，弹出了很多教程中都给出的界面，长成下面这个样子：</p><p><img src="https://cdn.jsdelivr.net/gh/albertgithubhome/cdn/img/cmddel5.png" alt="cmddel7"></p><p>这时要点击“更改”开始修改权限了，接着神奇的一幕发生了，当前界面一闪没有弹出修改界面，而原来的“更改”两个字也变成灰色不能再使用了。</p><p><img src="https://cdn.jsdelivr.net/gh/albertgithubhome/cdn/img/cmddel6.png" alt="cmddel8"></p><p>有点慌了啊，试试命令行吧，一个 <code>del</code> 强制删除试试，丝毫未动，删除请求被拒绝了：</p><p><img src="https://cdn.jsdelivr.net/gh/albertgithubhome/cdn/img/cmddel9.png" alt="cmddel9"></p><p>再试试别的文件，删除一个失败，再试一个又失败，最后发现这个文件夹中，我连个日志文件都删不掉，不仅发出了灵魂拷问，我真的是管理员吗？我的 <code>Administrator</code> 不会是假的吧？打开文件夹左看看、右看看没有发现什么可疑的地方，忽然我发现文件夹外面一层有个齿轮，难道被当成系统配置了，这是什么骚操作？</p><p><img src="https://cdn.jsdelivr.net/gh/albertgithubhome/cdn/img/cmddel9_1.png" alt="cmddel9_1"></p><p>看来我的电脑已经被这个软件给控制住了，一个做驱动的，在操作系统启动时早早的被唤醒，牢牢的控制住了局面，设置了一道道钩子，将可能影响到的它生存的途径全部堵死，这可能就是我修改权限时，界面闪了一下就再也修改不了的原因吧。</p><p>之前还碰到过一个软件比较坑，也是不让删除，在任务管理器强行关闭时会提示拒绝访问，最后发现一个名称比较相似的服务一直在启动着，然后尝试关闭这个服务，结果有趣的事情发生了，只要我点禁用服务一刷新，它又会重启，不知道还有哪个匿名的进程在默默的帮助它。</p><h2 id="进入安全模式"><a href="#进入安全模式" class="headerlink" title="进入安全模式"></a>进入安全模式</h2><p>没办法了，本来想快速解决战斗，改改权限后直接删除了，哪里想到它这么顽强，既然是涉及到了驱动，谁知道你在系统启动时搞了什么鬼，我就在另一个世界把你搞掉吧，从安全模式启动，让你原来的小算盘只能在硬盘里乖乖的躺着了，说到这怎么有一种从四维空间看三维世界的感觉。</p><p>关于怎么进入安全模式的命令行，之前在XP和Win7上好像是开机就可以选，在Win10上开机没有看到，之前也没操作过，不过网络上有大量的教程，我发现其中有两个比较有意思的，一个是要我用U盘做系统盘，然后假装给电脑做系统，在配置界面打开命令行进行设置然后重启，这有点太麻烦了吧。</p><p>还有一种更好玩就是让你在电脑启动的时候直接按电源键关机，反复尝试2-3次等电脑感觉到自己异常了，就能看到安全模式的选项了，这就好比让你借梯子你借不到，就在家里放了把火，结果借来了消防队的云梯，有可能损失惨重啊。</p><p>这里说一个我感觉最简单的方法吧，使用 <code>Win+R</code> 组合键，调出 windows 运行窗口，然后输入 <code>shutdown /r /o</code>，回车等着电脑重启就可以了。</p><p><img src="https://cdn.jsdelivr.net/gh/albertgithubhome/cdn/img/cmddel10_1.png" alt="cmddel10"></p><p>接着电脑会出现下面这个画面，选择其中的“疑难解答”选项：</p><p><img src="https://cdn.jsdelivr.net/gh/albertgithubhome/cdn/img/cmddel11.png" alt="cmddel11"></p><p>然后界面变化进入下面展示的“高级选项”界面，选择其中的“启动设置”选项：</p><p><img src="https://cdn.jsdelivr.net/gh/albertgithubhome/cdn/img/cmddel12.png" alt="cmddel12"></p><p>最后在启动设置的详细界面上选择“重启”按钮，短暂运行之后，电脑上开始出现下面的选项：</p><p><img src="https://cdn.jsdelivr.net/gh/albertgithubhome/cdn/img/cmddel13.png" alt="cmddel13"></p><p>这时就可以选择进入系统的模式了，使用 <code>F1~F9</code> 来进行选择，<code>F4</code> 就是进入安全模式，不加载多余的驱动，<code>F6</code> 是带命令提示符的安全模式：</p><p><img src="https://cdn.jsdelivr.net/gh/albertgithubhome/cdn/img/cmddel14.png" alt="cmddel14"></p><p>我们可以按键盘上的 <code>F6</code> 选择带命令提示符的安全模式，然后界面上就出现了下面这个“黑框框”：</p><p><img src="https://cdn.jsdelivr.net/gh/albertgithubhome/cdn/img/cmddel15.png" alt="cmddel15"></p><h2 id="彻底删除文件"><a href="#彻底删除文件" class="headerlink" title="彻底删除文件"></a>彻底删除文件</h2><p>有了黑框框就可以删除文件，先通过 <code>cd</code> 命令进入待删除文件所在目录，然后使用 <code>del</code> 命令删除文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">C:\Windows\System32&gt;d:</span><br><span class="line"></span><br><span class="line">D:\&gt;<span class="built_in">cd</span> <span class="string">"Program Files (x86)\MyDrivers\DriverGenius\ksoft"</span></span><br><span class="line"></span><br><span class="line">D:\Program Files (x86)\MyDrivers\DriverGenius\ksoft&gt;del /f znb.exe</span><br></pre></td></tr></table></figure><p>没有任何报错，世界都安静了，输入 <code>shutdown /r /t 0</code> 重启电脑，正常进入操作系统，这时就会发现刚刚统治了我的电脑的可执行程序，已经被我干掉不存在了。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>这些顽固广告真是厉害，一般删除文件的办法还真删不掉它们。</li><li>不光普通方法删不掉，连一些“流氓卫士”的文件粉碎功能都拿它们没办法。</li><li>不过电脑毕竟在用户手中，总有一些非常规办法可以干掉这些不正常的文件。</li><li>修理电脑时没有什么是重启电脑不能解决的，如果真的有，那就请你重装系统。</li></ul><hr><blockquote><p>别放弃，坚持朝着目标一步一步的走就好了~</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;最近电脑开机后偶尔会出现一个弹窗，这种广告弹窗见的多了也就麻木了，本来也没放在心上，随手一关就准备去做其他事情了，但是点击关闭按钮后这个广告弹窗居然还弹出了二次确认框，想想也忍了，毕竟广告商做半天就是为了让你多看几眼，当我用鼠标的光标接近这个确认按钮时，确认框消失了，整个广告页面居然还在！&lt;/p&gt;
    
    </summary>
    
      <category term="windows" scheme="http://AlbertGithubHome.github.io/blog/categories/windows/"/>
    
    
      <category term="Win10" scheme="http://AlbertGithubHome.github.io/blog/tags/Win10/"/>
    
      <category term="del" scheme="http://AlbertGithubHome.github.io/blog/tags/del/"/>
    
      <category term="exe" scheme="http://AlbertGithubHome.github.io/blog/tags/exe/"/>
    
  </entry>
  
  <entry>
    <title>git stash帮你在切换分支前暂存不想提交的修改</title>
    <link href="http://AlbertGithubHome.github.io/blog/2020/03/25/git-stash%E5%B8%AE%E4%BD%A0%E5%9C%A8%E5%88%87%E6%8D%A2%E5%88%86%E6%94%AF%E5%89%8D%E6%9A%82%E5%AD%98%E4%B8%8D%E6%83%B3%E6%8F%90%E4%BA%A4%E7%9A%84%E4%BF%AE%E6%94%B9/"/>
    <id>http://AlbertGithubHome.github.io/blog/2020/03/25/git-stash帮你在切换分支前暂存不想提交的修改/</id>
    <published>2020-03-25T15:27:38.000Z</published>
    <updated>2020-03-29T06:36:50.512Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>偶然间发现这个命令，正好解决了最近遇到的问题，使用 <code>Git</code> 管理代码时有这样一种场景，你正在分支 <code>branch2</code> 上开发新功能，突然刚刚提交测试的 <code>branch1</code> 分支上报了严重的BUG，需要尽快修改，这时候就需要切换到 <code>branch1</code> 分支上去修复BUG，但是你刚刚在分支 <code>branch2</code> 修改的文件还没有提交，接下来该怎么办？</p><a id="more"></a><p>如果本地的修改正好到达一个比较完整的阶段，可以直接提交，然后切换分支改BUG，那再好不过了。可是发生这种情况的时候往往是函数写了一半，或者功能大致写完但是还没来得及测试，这样的代码你敢提交吗？我感觉最好还是不要提交吧，那么如果这时候切换分支会有什么后果呢？一般会遇到两种情况：第一种是你在 <code>branch2</code> 分支上所做的修改与 <code>branch1</code> 上做过的修改不冲突，这时切换分支会将本地修改带到 <code>branch1</code> 分支，如果冲突了就是第二种情况，<code>git checkout branch1</code> 命令会被拒绝，当然你可以添加 <code>-f</code> 参数强行切换分支是能成功切换的，代价就是你会丢掉本地的所有修改。</p><h1 id="git-stash"><a href="#git-stash" class="headerlink" title="git stash"></a>git stash</h1><p>上面提到的切换分支时遇到的两种情况一般都不是我们想要的，之前说过“在 <code>Git</code> 中没有真正的方法来做任何事情，这就是它的妙处！”，但是关于切换分支有这样一个建议，那就是在切换分支时尽量保证你的工作区和暂存区是干净的，而 <code>git stash</code> 命令就是用来做这件事的。</p><p>当我们遇到这种状况，本地的修改我不能提交，不想带到新切换的分支，更不想直接丢掉，只想把他们暂存到一个地方，等我切换完分支修改好BUG，再切换回来迎接他们。使用 <code>SVN</code> 想保存本地修改可以使用 <code>patch</code>，而使用 <code>Git</code> 想要解决这种情况更加方便，那就是利用 <code>git stash</code> 命令。</p><h1 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h1><p>这个命令的使用方法非常简单，最常用的 <code>git stash push</code> 和 <code>git stash pop</code> 就能应付大部分情况了，其中 <code>push</code> 这个单词还可以省略，使用起来可以说是相当方便了，接下来尝试一下具体用法。</p><h2 id="本地有修改时切换分支的两种情况"><a href="#本地有修改时切换分支的两种情况" class="headerlink" title="本地有修改时切换分支的两种情况"></a>本地有修改时切换分支的两种情况</h2><p>之前提到过这两种情况，一种是将当前分支修改带到要切换的分支，另一种是切换会导致冲突，本次切换操作被拒绝，下面具体操作一下。</p><h3 id="将当前分支修改带到要切换的分支"><a href="#将当前分支修改带到要切换的分支" class="headerlink" title="将当前分支修改带到要切换的分支"></a>将当前分支修改带到要切换的分支</h3><p>首先以 <code>dev</code> 分支为基础新建 <code>feature</code> 分支</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">albert@homepc MINGW64 /d/gitstart (dev)</span><br><span class="line">$ git status</span><br><span class="line">On branch dev</span><br><span class="line">Your branch is up to date with <span class="string">'origin/dev'</span>.</span><br><span class="line"></span><br><span class="line">nothing to commit, working tree clean</span><br><span class="line"></span><br><span class="line">albert@homepc MINGW64 /d/gitstart (dev)</span><br><span class="line">$ git checkout -b feature</span><br><span class="line">Switched to a new branch <span class="string">'feature'</span></span><br></pre></td></tr></table></figure><p>在 <code>feature</code> 分支上修改文件，再切换回 <code>dev</code> 分支，可以正常切换，<code>git status</code> 查看状态，发现修改的文件被带到了 <code>dev</code> 分支上</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">albert@homepc MINGW64 /d/gitstart (feature)</span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">"test checkout"</span>&gt;&gt;README.md</span><br><span class="line"></span><br><span class="line">albert@homepc MINGW64 /d/gitstart (feature)</span><br><span class="line">$ git status</span><br><span class="line">On branch feature</span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">"git restore &lt;file&gt;..."</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line">        modified:   README.md</span><br><span class="line"></span><br><span class="line">no changes added to commit (use <span class="string">"git add"</span> and/or <span class="string">"git commit -a"</span>)</span><br><span class="line"></span><br><span class="line">albert@homepc MINGW64 /d/gitstart (feature)</span><br><span class="line">$ git checkout dev</span><br><span class="line">Switched to branch <span class="string">'dev'</span></span><br><span class="line">M       README.md</span><br><span class="line">Your branch is up to date with <span class="string">'origin/dev'</span>.</span><br><span class="line"></span><br><span class="line">albert@homepc MINGW64 /d/gitstart (dev)</span><br><span class="line">$ git status</span><br><span class="line">On branch dev</span><br><span class="line">Your branch is up to date with <span class="string">'origin/dev'</span>.</span><br><span class="line"></span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">"git restore &lt;file&gt;..."</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line">        modified:   README.md</span><br><span class="line"></span><br><span class="line">no changes added to commit (use <span class="string">"git add"</span> and/or <span class="string">"git commit -a"</span>)</span><br></pre></td></tr></table></figure><p>这里要注意一点，在切换到 <code>dev</code> 分支的时候，有一行 <code>M       README.md</code>的内容，表示这个文件在切换过来的时候就是修改的。</p><p>如果你想要的效果就是这样，就可以直接提交了，比如修改了代码发现分支弄错了，可以这样带着修改的内容切换分支，假设就是这种情况，我们直接在 <code>dev</code> 分支提交修改。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">albert@homepc MINGW64 /d/gitstart (dev)</span><br><span class="line">$ git add README.md</span><br><span class="line"></span><br><span class="line">albert@homepc MINGW64 /d/gitstart (dev)</span><br><span class="line">$ git commit -m<span class="string">"add comments"</span></span><br><span class="line">[dev 5f4181e] add comments</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line">git</span><br><span class="line">albert@homepc MINGW64 /d/gitstart (dev)</span><br><span class="line">$ git status</span><br><span class="line">On branch dev</span><br><span class="line">Your branch is ahead of <span class="string">'origin/dev'</span> by 1 commit.</span><br><span class="line">  (use <span class="string">"git push"</span> to publish your <span class="built_in">local</span> commits)</span><br><span class="line"></span><br><span class="line">nothing to commit, working tree clean</span><br></pre></td></tr></table></figure><h3 id="切换分支操作被拒绝"><a href="#切换分支操作被拒绝" class="headerlink" title="切换分支操作被拒绝"></a>切换分支操作被拒绝</h3><p>上面一种情况，在 <code>feature</code> 分支的修改被带到 <code>dev</code> 分支提交，我们在此基础上切换回 <code>feature</code> 分支看一下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">albert@homepc MINGW64 /d/gitstart (dev)</span><br><span class="line">$ git checkout feature</span><br><span class="line">Switched to branch <span class="string">'feature'</span></span><br><span class="line"></span><br><span class="line">albert@homepc MINGW64 /d/gitstart (feature)</span><br><span class="line">$ git status</span><br><span class="line">On branch feature</span><br><span class="line">nothing to commit, working tree clean</span><br></pre></td></tr></table></figure><p>发现此时 <code>feature</code> 分支上没有任何修改了，我们再改一次，然后切换到 <code>dev</code> 分支上试试：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">albert@homepc MINGW64 /d/gitstart (feature)</span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">"second try"</span>&gt;&gt;README.md</span><br><span class="line"></span><br><span class="line">albert@homepc MINGW64 /d/gitstart (feature)</span><br><span class="line">$ git status</span><br><span class="line">On branch feature</span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">"git restore &lt;file&gt;..."</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line">        modified:   README.md</span><br><span class="line"></span><br><span class="line">no changes added to commit (use <span class="string">"git add"</span> and/or <span class="string">"git commit -a"</span>)</span><br><span class="line"></span><br><span class="line">albert@homepc MINGW64 /d/gitstart (feature)</span><br><span class="line">$ git checkout dev</span><br><span class="line">error: Your <span class="built_in">local</span> changes to the following files would be overwritten by checkout:</span><br><span class="line">        README.md</span><br><span class="line">Please commit your changes or stash them before you switch branches.</span><br><span class="line">Aborting</span><br></pre></td></tr></table></figure><p>看到了吧，切换分支的操作被拒绝了，原因是这次切换可能导致本地的修改被覆盖，你可以在切换分支前尝试 <code>commit</code> 你的修改或者 <code>stash</code> 你的修改，等等，这里出现了 <code>stash</code> 这个单词，其实之前我都没注意到，不是修改好提交了就是直接加 <code>-f</code> 参数放弃了所做的修改，没想到还有这样神奇 <code>stash</code> 命令帮我渡过难关。</p><h2 id="stash-一般操作"><a href="#stash-一般操作" class="headerlink" title="stash 一般操作"></a><code>stash</code> 一般操作</h2><p>接下来展示一下 <code>git stash</code> 最常用的操作，也就是标题中提到的——在切换分支前暂存不想提交的修改，继续在上面的环境下操作，现在 <code>feature</code><br> 分支上修改了 <code>README.md</code> 文件，切换到 <code>dev</code> 分支时因为可能产生冲突而被拒绝，我们先来看一下文件状态。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">albert@homepc MINGW64 /d/gitstart (feature)</span><br><span class="line">$ git status</span><br><span class="line">On branch feature</span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">"git restore &lt;file&gt;..."</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line">        modified:   README.md</span><br><span class="line"></span><br><span class="line">no changes added to commit (use <span class="string">"git add"</span> and/or <span class="string">"git commit -a"</span>)</span><br><span class="line"></span><br><span class="line">albert@homepc MINGW64 /d/gitstart (feature)</span><br><span class="line">$ git diff</span><br><span class="line">warning: LF will be replaced by CRLF <span class="keyword">in</span> README.md.</span><br><span class="line">The file will have its original line endings <span class="keyword">in</span> your working directory</span><br><span class="line">diff --git a/README.md b/README.md</span><br><span class="line">index 76a124a..4c2bfb8 100644</span><br><span class="line">--- a/README.md</span><br><span class="line">+++ b/README.md</span><br><span class="line">@@ -1,2 +1,3 @@</span><br><span class="line"> learn git branch <span class="built_in">command</span></span><br><span class="line"> m2</span><br><span class="line">+second try</span><br></pre></td></tr></table></figure><h3 id="存储临时修改"><a href="#存储临时修改" class="headerlink" title="存储临时修改"></a>存储临时修改</h3><p>对比显示我们增加了一行，然后执行 <code>git stash</code> 命令，再查看一下文件状态：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">albert@homepc MINGW64 /d/gitstart (feature)</span><br><span class="line">$ git stash</span><br><span class="line">warning: LF will be replaced by CRLF <span class="keyword">in</span> README.md.</span><br><span class="line">The file will have its original line endings <span class="keyword">in</span> your working directory</span><br><span class="line">Saved working directory and index state WIP on feature: 6ae97d0 Revert <span class="string">"modify README 1"</span></span><br><span class="line"></span><br><span class="line">albert@homepc MINGW64 /d/gitstart (feature)</span><br><span class="line">$ git status</span><br><span class="line">On branch feature</span><br><span class="line">nothing to commit, working tree clean</span><br></pre></td></tr></table></figure><p>执行完 <code>git stash</code> 之后我们发现，刚才的修改不见了，本地状态提示为 <code>nothing to commit, working tree clean</code>，这时我们再来切换分支：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">albert@homepc MINGW64 /d/gitstart (feature)</span><br><span class="line">$ git checkout dev</span><br><span class="line">Switched to branch <span class="string">'dev'</span></span><br><span class="line">Your branch is ahead of <span class="string">'origin/dev'</span> by 1 commit.</span><br><span class="line">  (use <span class="string">"git push"</span> to publish your <span class="built_in">local</span> commits)</span><br><span class="line"></span><br><span class="line">albert@homepc MINGW64 /d/gitstart (dev)</span><br><span class="line">$ git status</span><br><span class="line">On branch dev</span><br><span class="line">Your branch is ahead of <span class="string">'origin/dev'</span> by 1 commit.</span><br><span class="line">  (use <span class="string">"git push"</span> to publish your <span class="built_in">local</span> commits)</span><br><span class="line"></span><br><span class="line">nothing to commit, working tree clean</span><br></pre></td></tr></table></figure><p>这次切换就没有被拒绝，成功的切换到了 <code>dev</code> 分支，你可以在 <code>dev</code> 分支上进行想要的操作，全部操作完成后再切换回 <code>feature</code> 分支，我们这里就不操作了，直接切回 <code>feature</code> 分支查看一下状态：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">albert@homepc MINGW64 /d/gitstart (dev)</span><br><span class="line">$ git checkout feature</span><br><span class="line">Switched to branch <span class="string">'feature'</span></span><br><span class="line"></span><br><span class="line">albert@homepc MINGW64 /d/gitstart (feature)</span><br><span class="line">$ git status</span><br><span class="line">On branch feature</span><br><span class="line">nothing to commit, working tree clean</span><br></pre></td></tr></table></figure><h3 id="还原临时修改"><a href="#还原临时修改" class="headerlink" title="还原临时修改"></a>还原临时修改</h3><p>我们看到工作区很干净，这时如果想还原刚才在 <code>feature</code> 分支的修改，可以使用 <code>git stash pop</code> 命令，我们执行一下然后查看状态：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">albert@homepc MINGW64 /d/gitstart (feature)</span><br><span class="line">$ git stash pop</span><br><span class="line">On branch feature</span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">"git restore &lt;file&gt;..."</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line">        modified:   README.md</span><br><span class="line"></span><br><span class="line">no changes added to commit (use <span class="string">"git add"</span> and/or <span class="string">"git commit -a"</span>)</span><br><span class="line">Dropped refs/stash@&#123;0&#125; (bd500adb74d57a3d916a89ff2cd4536cf4eaf6ae)</span><br><span class="line"></span><br><span class="line">albert@homepc MINGW64 /d/gitstart (feature)</span><br><span class="line">$ git status</span><br><span class="line">On branch feature</span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">"git restore &lt;file&gt;..."</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line">        modified:   README.md</span><br><span class="line"></span><br><span class="line">no changes added to commit (use <span class="string">"git add"</span> and/or <span class="string">"git commit -a"</span>)</span><br></pre></td></tr></table></figure><p>刚刚被临时暂存的修改又恢复了，我们可以在 <code>feature</code> 分支上继续愉快地开发了。</p><h2 id="stash-进阶操作"><a href="#stash-进阶操作" class="headerlink" title="stash 进阶操作"></a><code>stash</code> 进阶操作</h2><p>作为这么神奇的命令，<code>stash</code> 肯定不止这么一点点用法，接下来再列举几个较为常用的参数组合：</p><h3 id="查看临时存储的所有条目-git-stash-list"><a href="#查看临时存储的所有条目-git-stash-list" class="headerlink" title="查看临时存储的所有条目 git stash list"></a>查看临时存储的所有条目 <code>git stash list</code></h3><p>当你使用几次 <code>git stash</code> 命令之后就会发现，这个命令有点像建立还原点，所以暂存命令不止可以用一次，当使用多次暂存命令之后就会形成一个暂存列表，这时可以使用 <code>git stash list</code> 命令查看所有的暂存操作，执行命令后大概就是下面的样子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">albert@homepc MINGW64 /d/gitstart (feature)</span><br><span class="line">$ git stash list</span><br><span class="line">stash@&#123;0&#125;: WIP on feature: 84dfd79 add <span class="built_in">test</span> file</span><br><span class="line">stash@&#123;1&#125;: WIP on feature: 6ae97d0 Revert <span class="string">"modify README 1"</span></span><br></pre></td></tr></table></figure><p>这个列表的构成很像一个栈，<code>stash@{0}</code> 是栈顶元素，<code>stash@{1}</code> 是栈顶下面的一个元素，当使用 <code>git stash</code> 命令时会把新的临时存储信息压入栈顶，原来的信息向栈底移动，当使用 <code>git stash pop</code> 命令的时候又会把栈顶的元素弹出，恢复到工作区和暂存区。</p><h3 id="临时存储未追踪的新文件-git-stash-u"><a href="#临时存储未追踪的新文件-git-stash-u" class="headerlink" title="临时存储未追踪的新文件 git stash -u"></a>临时存储未追踪的新文件 <code>git stash -u</code></h3><p>在开发过程中新添加的文件不属于任何一个分支，在不冲突的文件情况下也可以在切换分支的时候带到新的分支，默认在使用 <code>git stash</code> 命令的时候不会把这些文件临时存起来，如果想要存起来加上 <code>-u</code> 参数就可以了，执行之后你会发现这个新加的文件在工作区中消失了。</p><h3 id="临时存储被忽略的文件-git-stash-a"><a href="#临时存储被忽略的文件-git-stash-a" class="headerlink" title="临时存储被忽略的文件 git stash -a"></a>临时存储被忽略的文件 <code>git stash -a</code></h3><p>被忽略的文件在默认情况下也不会被 <code>git stash</code> 命令存储，想要临时存储这部分文件只要使用 <code>-a</code> 参数就可以了，这样不仅会把忽略的文件临时存储，连未追踪的文件也存储了起来。</p><h2 id="stash-操作的标号"><a href="#stash-操作的标号" class="headerlink" title="stash 操作的标号"></a><code>stash</code> 操作的标号</h2><p>前面的 <code>git stash list</code> 命令也提到了，使用 <code>git stash</code> 命令的结果会形成一个栈形式的列表，其中 <code>stash@{n}</code> 就是每次临时存储对应的标号，针对于这些标号的操作也有很多，如果不加这些标号默认使用 <code>stash@{0}</code> ，也就是栈顶元素。</p><h3 id="查看临时修改的具体内容-git-stash-show-stash-0"><a href="#查看临时修改的具体内容-git-stash-show-stash-0" class="headerlink" title="查看临时修改的具体内容 git stash show stash@{0}"></a>查看临时修改的具体内容 <code>git stash show stash@{0}</code></h3><p>这个查询过程和查询提交日志的形式有点像，主要展示了某次临时存储时改了哪些内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">albert@homepc MINGW64 /d/gitstart (feature)</span><br><span class="line">$ git stash show stash@&#123;0&#125;</span><br><span class="line"> test.txt | 1 +</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line"></span><br><span class="line">albert@homepc MINGW64 /d/gitstart (feature)</span><br><span class="line">$ git stash show stash@&#123;1&#125;</span><br><span class="line"> README.md | 1 +</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br></pre></td></tr></table></figure><h3 id="恢复指定标号的临时修改-git-stash-apply-stash-0"><a href="#恢复指定标号的临时修改-git-stash-apply-stash-0" class="headerlink" title="恢复指定标号的临时修改 git stash apply stash@{0}"></a>恢复指定标号的临时修改 <code>git stash apply stash@{0}</code></h3><p>在恢复临时存储的修改时不仅可以使用 <code>git stash pop</code> 命令来恢复栈顶那一次修改，也可以按照标号恢复指定的某次修改，测试如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">albert@homepc MINGW64 /d/gitstart (feature)</span><br><span class="line">$ git stash apply stash@&#123;1&#125;</span><br><span class="line">On branch feature</span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">"git restore &lt;file&gt;..."</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line">        modified:   README.md</span><br><span class="line"></span><br><span class="line">no changes added to commit (use <span class="string">"git add"</span> and/or <span class="string">"git commit -a"</span>)</span><br><span class="line"></span><br><span class="line">albert@homepc MINGW64 /d/gitstart (feature)</span><br><span class="line">$ git stash list</span><br><span class="line">stash@&#123;0&#125;: WIP on feature: 84dfd79 add <span class="built_in">test</span> file</span><br><span class="line">stash@&#123;1&#125;: WIP on feature: 6ae97d0 Revert <span class="string">"modify README 1"</span></span><br><span class="line"></span><br><span class="line">albert@homepc MINGW64 /d/gitstart (feature)</span><br><span class="line">$ git stash apply stash@&#123;1&#125;</span><br><span class="line">error: Your <span class="built_in">local</span> changes to the following files would be overwritten by merge:</span><br><span class="line">        README.md</span><br><span class="line">Please commit your changes or stash them before you merge.</span><br><span class="line">Aborting</span><br></pre></td></tr></table></figure><p>这个命令在执行后，指定标号的修改会被恢复到工作区和暂存区，但是临时存储的列表不会被删除，这时可以尝试再次恢复相同标号的修改到工作区，你会发现本次操作因为修改了相同的文件而被拒绝。</p><h3 id="刪除指定标号的临时存储的修改-git-stash-drop-stash-0"><a href="#刪除指定标号的临时存储的修改-git-stash-drop-stash-0" class="headerlink" title="刪除指定标号的临时存储的修改 git stash drop stash@{0}"></a>刪除指定标号的临时存储的修改 <code>git stash drop stash@{0}</code></h3><p>可以在临时存储列表中删除指定标号的一些修改，可以测试一下看看效果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">albert@homepc MINGW64 /d/gitstart (feature)</span><br><span class="line">$ git stash list</span><br><span class="line">stash@&#123;0&#125;: WIP on feature: 84dfd79 add <span class="built_in">test</span> file</span><br><span class="line">stash@&#123;1&#125;: WIP on feature: 6ae97d0 Revert <span class="string">"modify README 1"</span></span><br><span class="line"></span><br><span class="line">albert@homepc MINGW64 /d/gitstart (feature)</span><br><span class="line">$ git stash drop stash@&#123;1&#125;</span><br><span class="line">Dropped stash@&#123;1&#125; (8408e56305fabcd82c1d05db18e177c89c47c5ac)</span><br><span class="line"></span><br><span class="line">albert@homepc MINGW64 /d/gitstart (feature)</span><br><span class="line">$ git stash list</span><br><span class="line">stash@&#123;0&#125;: WIP on feature: 84dfd79 add <span class="built_in">test</span> file</span><br></pre></td></tr></table></figure><h3 id="利用临时存储的修改内容新建分支-git-stash-branch-lt-branchname-gt-lt-stash-gt"><a href="#利用临时存储的修改内容新建分支-git-stash-branch-lt-branchname-gt-lt-stash-gt" class="headerlink" title="利用临时存储的修改内容新建分支 git stash branch &lt;branchname&gt; [&lt;stash&gt;]"></a>利用临时存储的修改内容新建分支 <code>git stash branch &lt;branchname&gt; [&lt;stash&gt;]</code></h3><p>一般这种情况就是使用过多次 <code>git stash push</code> 命令，而本地分支还修改了其他内容，直接恢复之前的修改不太合适，所以利用这个命令新建一个分支，分支的内容以指定的存储标号 <code>&lt;stash&gt;</code> 对应的提交 <code>commit-id</code> 为基础，然后应用 <code>&lt;stash&gt;</code> 的修改，实际上就是新建了一个对应 <code>&lt;stash&gt;</code> 的分支，继续之前未完成的工作，<code>&lt;stash&gt;</code> 默认为 <code>stash@{0}</code>，测试如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">albert@homepc MINGW64 /d/gitstart (feature)</span><br><span class="line">$ git stash branch feature1</span><br><span class="line">Switched to a new branch <span class="string">'feature1'</span></span><br><span class="line">M       README.md</span><br><span class="line">On branch feature1</span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">"git restore &lt;file&gt;..."</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line">        modified:   README.md</span><br><span class="line">        modified:   test.txt</span><br><span class="line"></span><br><span class="line">no changes added to commit (use <span class="string">"git add"</span> and/or <span class="string">"git commit -a"</span>)</span><br><span class="line">Dropped refs/stash@&#123;0&#125; (2922b3eeeda44c98316453b93fcf07c1fcfffca4)</span><br><span class="line"></span><br><span class="line">albert@homepc MINGW64 /d/gitstart (feature1)</span><br><span class="line">$ git stash list</span><br></pre></td></tr></table></figure><p>这个操作会消耗掉对应 <code>&lt;stash&gt;</code> 标号的临时存储的内容，将这些内容从存储列表中移除。</p><h1 id="stash-的注意事项"><a href="#stash-的注意事项" class="headerlink" title="stash 的注意事项"></a><code>stash</code> 的注意事项</h1><p>这个命令不仅可以在同一分支上存储和还原，也可用于不同分支之间，这时就可以有一个应用，当我们发现在错误的分支上开发了代码，可以先 <code>git stash push</code> 将这些修改临时存储起来， 然后切换到正确的分支，再执行 <code>git stash pop</code> 命令将刚才的修改引用到现在的分支上。</p><p><code>git stash push</code> 命令默认是存储工作区和暂存区的修改内容的，但是 <code>git stash pop</code> 命令在还原是默认将所有的修改还原到工作区，如果想还原到对应的暂存区，需要加额外的参数，像这样 <code>git stash pop --index</code>。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>这个命令挺有用的，在合作开发的时候经常碰到临时问题需要处理，切换分支暂存一下很方便</li><li>感觉这个命令其实和 <code>commit</code> 也很像的，在操作过程中你会发现，它也有自己的 <code>hash-id</code>，但是不会放到 <code>commit</code> 列表中</li><li>这个命令参数也有好多个，不过记住常用的就可以面对大多数情况了，简单列举下</li><li><code>git stash push</code> 会将当前本地的修改临时保存起来，<code>push</code> 可以省略</li><li><code>git stash list</code> 查看当前<code>stash push</code>操作的记录</li><li><code>git stash pop</code> 取出最近一次修改，并应用到本地</li><li><code>git stash apply stash@{n}</code> 应用 <code>stash@{n}</code> 对应的修改，但是不删除这条记录</li><li><code>git stash show stash@{n}</code> 展示 <code>stash@{n}</code> 对应的修改的实际修改内容</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;偶然间发现这个命令，正好解决了最近遇到的问题，使用 &lt;code&gt;Git&lt;/code&gt; 管理代码时有这样一种场景，你正在分支 &lt;code&gt;branch2&lt;/code&gt; 上开发新功能，突然刚刚提交测试的 &lt;code&gt;branch1&lt;/code&gt; 分支上报了严重的BUG，需要尽快修改，这时候就需要切换到 &lt;code&gt;branch1&lt;/code&gt; 分支上去修复BUG，但是你刚刚在分支 &lt;code&gt;branch2&lt;/code&gt; 修改的文件还没有提交，接下来该怎么办？&lt;/p&gt;
    
    </summary>
    
      <category term="Git" scheme="http://AlbertGithubHome.github.io/blog/categories/Git/"/>
    
    
      <category term="git" scheme="http://AlbertGithubHome.github.io/blog/tags/git/"/>
    
      <category term="checkout" scheme="http://AlbertGithubHome.github.io/blog/tags/checkout/"/>
    
      <category term="stash" scheme="http://AlbertGithubHome.github.io/blog/tags/stash/"/>
    
      <category term="merge" scheme="http://AlbertGithubHome.github.io/blog/tags/merge/"/>
    
  </entry>
  
  <entry>
    <title>没想到C++中的std::remove_if()函数历史还挺悠久</title>
    <link href="http://AlbertGithubHome.github.io/blog/2020/03/19/%E6%B2%A1%E6%83%B3%E5%88%B0C-%E4%B8%AD%E7%9A%84std-remove-if-%E5%87%BD%E6%95%B0%E5%8E%86%E5%8F%B2%E8%BF%98%E6%8C%BA%E6%82%A0%E4%B9%85/"/>
    <id>http://AlbertGithubHome.github.io/blog/2020/03/19/没想到C-中的std-remove-if-函数历史还挺悠久/</id>
    <published>2020-03-19T15:30:46.000Z</published>
    <updated>2020-03-21T12:50:58.287Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>看到 remove 这个单词的第一反应是什么意思？我的第一感觉是删除、去掉的意思，就像一个程序员看到 string 就会说是字符串，而不会说它是线、或者细绳的意思，可是C++里居然有个函数叫 <code>std::remove()</code>，调用完这个函数什么也没删除，这我就奇怪了，打开有道词典查询一下：</p><a id="more"></a><p>不查不要紧，一查吓一跳，以下是词典给出的三个释义：</p><ul><li>vt. 移动，迁移；开除；调动</li><li>vi. 移动，迁移；搬家</li><li>n. 移动；距离；搬家</li></ul><p>及物动词、不及物动词、名词给出的含义都是移动，只有一个开除的意思和删除有点像，难道我穿越了？我之前一直以为它是删除的意思啊，很多函数还是用它命名的呢！</p><p>赶紧翻翻其他的字典，给高中的英语老师打个电话问问，最终还是在一些释义中找到了删除的意思，还有一些用作删除的例句，有趣的是在有道词典上，所有的单词解释都和移动有关，所有的例句都是和删除有关。</p><h1 id="remove-if的历史"><a href="#remove-if的历史" class="headerlink" title="remove_if的历史"></a><code>remove_if</code>的历史</h1><p>为什么要查单词的 remove 的意思，当然是被它坑过了，本来想从 <code>std::vector&lt;T&gt;</code> 中删除指定的元素，考虑到迭代器失效的问题，放弃了循环遍历的复杂处理，选择直接使用算法函数 <code>std::remove_if()</code>来进行删除，之前对于 <code>std::remove()</code> 和 <code>std::remove_if()</code> 有过简单的了解，不过记忆还是出现了偏差。</p><p>一直记得 <code>std::remove()</code> 函数调用之后需要再使用 <code>erase()</code> 函数处理下，忘记了 <code>std::remove_if()</code> 函数也要做相同的处理，于是在出现问题的时候一度怀疑这个函数的功能发生了变更，开始找这个函数历史迭代的版本，这里推荐一个网站 <a href="https://en.cppreference.com/w/cpp/algorithm/remove" target="_blank" rel="noopener">C++标准函数查询 - std::remove_if()</a>，用来查询函数的定义、所在头文件和使用方法非常方便。</p><p>文档中有这样两句：</p><blockquote><p>1) Removes all elements that are equal to value, using operator== to compare them.<br>3) Removes all elements for which predicate p returns true.</p></blockquote><p>解释函数作用时用到的单词都是 remove ，你说神不神奇，这里应该都是取的移动的意思。</p><p>这两句话对应的函数声明应该是：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt; <span class="class"><span class="keyword">class</span> <span class="title">ForwardIt</span>, <span class="title">class</span> <span class="title">T</span> &gt;</span></span><br><span class="line"><span class="class"><span class="title">ForwardIt</span> <span class="title">remove</span>( <span class="title">ForwardIt</span> <span class="title">first</span>, <span class="title">ForwardIt</span> <span class="title">last</span>, <span class="title">const</span> <span class="title">T</span>&amp; <span class="title">value</span> );</span>        <span class="comment">// (until C++20)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt; <span class="class"><span class="keyword">class</span> <span class="title">ForwardIt</span>, <span class="title">class</span> <span class="title">UnaryPredicate</span> &gt;</span></span><br><span class="line"><span class="class"><span class="title">ForwardIt</span> <span class="title">remove_if</span>( <span class="title">ForwardIt</span> <span class="title">first</span>, <span class="title">ForwardIt</span> <span class="title">last</span>, <span class="title">UnaryPredicate</span> <span class="title">p</span> );</span>   <span class="comment">// (until C++20)</span></span><br></pre></td></tr></table></figure><p>这两个函数后面都有相同的说明—— <code>(until C++20)</code> ，意思大概就是说这两个函数一直到 <code>C++20</code> 版本都存在，在我的印象中 <code>std::remove_if()</code> 函数比较新，最起码得比 <code>std::remove()</code> 函数年轻几岁，可是他们到底是哪个版本添加到c++标准的的呢？中途的功能有没有发生变更，继续回忆！</p><p>第一次看到这两个函数应该是在看《Effective STL》这本书的时候，大概是5年前了，正好这个本书就放在手边，赶紧翻目录查一下，打开对应章节发现其中确实提到了删除 <code>std::vector&lt;T&gt;</code> 中的元素时，在调用了这两个函数之后都需要再调用 <code>erase()</code> 函数对待删除的元素进行擦除。</p><p>看看书的出版时间是2013年，难道是 <code>C++11</code> 的标准加上的，不对，看一下翻译者写得序，落款时间2003年，不能是 <code>C++03</code> 的标准吧？不过这是一本翻译书籍，再看看原作者 <code>Scott Meyers</code> 写的前言，落款时间2001年，好吧，看来这两个函数肯定在 <code>C++98</code>的版本中就已经存在了，我有点惊呆了，这确实颠覆了我的记忆和认知。</p><p>造成这种认知错误主要有两方面原因，第一方面就是受到了开发环境的限制，从一开始学习的时候<code>Turob C 2.0</code>、<code>VC++ 6.0</code>、<code>VS2005</code>、<code>VS2008</code>、<code>VS2010</code>就很少接触 <code>C++11</code> 的知识，<code>Dev-C++</code> 和 <code>Code::Blocks</code> 也是在特定的情况下使用，没有过多的研究，结果在刚开始工作的时候开发工具居然是<code>VS2003</code>，这个版本我之前都没听说过，还好一步步升级到了08、13、17版本。</p><p>第二方面就是这两个函数常常与 <code>Lambda</code> 表达式，<code>auto</code> 关键字一起用，这都是 <code>C++11</code> 里才有的，让人感觉好像这个 <code>std::remove_if()</code> 函数也是 <code>C++11</code> 版本中的内容，造成了错觉。总来说还是用的少，不熟悉，以后多看多练就好了。</p><h1 id="remove-if的实现"><a href="#remove-if的实现" class="headerlink" title="remove_if的实现"></a><code>remove_if</code>的实现</h1><p>要想更深入的学习 <code>std::remove_if()</code> 函数， 那这个函数实现的细节有必要了解一下，这有助于我们理解函数的使用方法，下面给出两个版本可能的实现方式，也许下面的实现与你查到的不一样，但是思想是相通的，有些实现细节中使用了 <code>std::find_if()</code> 函数，这里没有列举这个版本，下面这两个版本的代码更容易让人明白，它究竟做了哪些事情。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++98 版本</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">ForwardIterator</span>, <span class="title">class</span> <span class="title">UnaryPredicate</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">ForwardIterator</span> <span class="title">remove_if</span> (<span class="title">ForwardIterator</span> <span class="title">first</span>, <span class="title">ForwardIterator</span> <span class="title">last</span>,</span></span><br><span class="line"><span class="class">                             <span class="title">UnaryPredicate</span> <span class="title">pred</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ForwardIterator result = first;</span><br><span class="line">    <span class="keyword">while</span> (first!=last) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!pred(*first)) &#123;</span><br><span class="line">            *result = *first;</span><br><span class="line">            ++result;</span><br><span class="line">        &#125;</span><br><span class="line">        ++first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++11     版本</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">ForwardIterator</span>, <span class="title">class</span> <span class="title">UnaryPredicate</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">ForwardIterator</span> <span class="title">remove_if</span> (<span class="title">ForwardIterator</span> <span class="title">first</span>, <span class="title">ForwardIterator</span> <span class="title">last</span>,</span></span><br><span class="line"><span class="class">                             <span class="title">UnaryPredicate</span> <span class="title">pred</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ForwardIterator result = first;</span><br><span class="line">    <span class="keyword">while</span> (first!=last) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!pred(*first)) &#123;</span><br><span class="line">            *result = <span class="built_in">std</span>::move(*first);</span><br><span class="line">            ++result;</span><br><span class="line">        &#125;</span><br><span class="line">        ++first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对比两段代码有没有发现区别——只改了半行代码，将赋值语句中的 <code>*first</code> 在 <code>C++11</code> 版本中替换成了 <code>std::move(*first)</code>，这只能发生在 <code>C++11</code> 之后，因为 <code>std::move()</code> 函数是 <code>C++11</code> 才加入的。</p><p>这代码乍一看挺唬人的，其实仔细分析一下还挺简单的，只是这些符号看起来有些生疏，其实可以把 <code>ForwardIterator</code> 看成一个指针类型，<code>UnaryPredicate</code> 是一个函数类型，我们改写一下:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">remove_if</span> <span class="params">(<span class="keyword">int</span>* first, <span class="keyword">int</span>* last, func_type func)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>* result = first;</span><br><span class="line">    <span class="keyword">for</span> (;first!=last;++first)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!func(*first))</span><br><span class="line">        &#123;</span><br><span class="line">            *result = *first;</span><br><span class="line">            ++result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这代码是不是就比较接地气了，想象一下，一个是包含10个元素的数组，让你删除其中的偶数怎么做？其实就是遍历一遍数组，从开始位置到结束位置逐个判断，如果不是偶数就不进行操作，如果是偶数就把当前的偶数向前移动到结果指针上就好了，结果指针向后移动准备接受下一个奇数，这个判断是不是偶数的函数就是上面代码中的 <code>func()</code>。</p><p>最后结果指针 <code>result</code> 停在有效元素后面一个位置上，这个位置到结尾指针 <code>last</code> 的位置上的元素都应该被删除，这就是为什么常常将 <code>std::remove_if()</code> 函数的返回值作为 <code>erase()</code> 函数的第一个参数，而将 <code>last</code> 指针作为 <code>erase()</code> 函数的第二个参数，实际作用就是将这些位置上的元素擦除，从头擦到尾，达到真正删除的目的。</p><h1 id="具体使用"><a href="#具体使用" class="headerlink" title="具体使用"></a>具体使用</h1><p>说了这么多，接下来看看具体怎么用，我们将 <code>std::remove_if()</code> 函数和 <code>erase()</code> 函数分开使用，主要看一下调用 <code>std::remove_if()</code> 函数之后的 <code>vector</code> 中元素的值是怎么变的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isEven</span><span class="params">(<span class="keyword">int</span> n)</span> <span class="comment">// 是否是偶数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n % <span class="number">2</span> == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vecTest;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">        vecTest.push_back(i);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vecTest.size(); ++i)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; vecTest[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移动元素</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator itor = <span class="built_in">std</span>::remove_if(vecTest.begin(), vecTest.end(), isEven);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查看移动后的变化</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vecTest.size(); ++i)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; vecTest[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除元素</span></span><br><span class="line">    vecTest.erase(itor, vecTest.end());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vecTest.size(); ++i)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; vecTest[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为：</p><blockquote><p>0 1 2 3 4 5 6 7 8 9<br>1 3 5 7 9 5 6 7 8 9<br>1 3 5 7 9</p></blockquote><p>从结果可以看出，第二步调用 <code>std::remove_if()</code> 函数之后，vector 中的元素个数并没有减少，只是将后面不需要删除的元素移动到了 vector 的前面，从第二行结果来看，调用 <code>std::remove_if()</code> 函数之后返回的结果 <code>itor</code> 指向5，所以擦除从5所在位置到结尾的元素就达到了我们的目的。</p><p>这段代码在 <code>C++98</code>、<code>C++11</code>、<code>C++14</code> 环境下都可以编译运行，在这里推荐一个在线编译器 <a href="http://cpp.sh/" target="_blank" rel="noopener">C++ Shell</a>，可以测试各个版本编译器下运行结果，界面简洁明了，方便测试。</p><p>上面的代码其实写得有些啰嗦，如果使用 <code>C++11</code> 语法之后，可以简写为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">，</span><br></pre></td></tr></table></figure><p>运行结果：</p><blockquote><p>0 1 2 3 4 5 6 7 8 9<br>1 3 5 7 9</p></blockquote><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol><li>对于模糊的知识要花时间复习，避免临时用到的时候手忙脚乱出问题</li><li>对于一些心存疑虑的函数可以看一下具体的实现，知道实现的细节可以让我们更加清楚程序都做了哪些事情</li><li>对于新的技术标准可以不精通，但是必须花一些时间进行了解，比如新的 <code>C++</code> 标准</li><li>对于违反常识的代码，先不要否定，即使在你的运行环境中报错，说不定人家是新语法呢？</li><li>曾经看到一段在类的定义时初始化非静态变量的代码，一度认为编译不过，但后来发现在 <code>C++11</code> 中运行的很好</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;看到 remove 这个单词的第一反应是什么意思？我的第一感觉是删除、去掉的意思，就像一个程序员看到 string 就会说是字符串，而不会说它是线、或者细绳的意思，可是C++里居然有个函数叫 &lt;code&gt;std::remove()&lt;/code&gt;，调用完这个函数什么也没删除，这我就奇怪了，打开有道词典查询一下：&lt;/p&gt;
    
    </summary>
    
      <category term="C/C++" scheme="http://AlbertGithubHome.github.io/blog/categories/C-C/"/>
    
    
      <category term="C/C++" scheme="http://AlbertGithubHome.github.io/blog/tags/C-C/"/>
    
      <category term="历史" scheme="http://AlbertGithubHome.github.io/blog/tags/%E5%8E%86%E5%8F%B2/"/>
    
      <category term="remove" scheme="http://AlbertGithubHome.github.io/blog/tags/remove/"/>
    
      <category term="remove_if" scheme="http://AlbertGithubHome.github.io/blog/tags/remove-if/"/>
    
      <category term="删除" scheme="http://AlbertGithubHome.github.io/blog/tags/%E5%88%A0%E9%99%A4/"/>
    
  </entry>
  
  <entry>
    <title>Python操作Excel工作簿(\*.xlsx)</title>
    <link href="http://AlbertGithubHome.github.io/blog/2020/03/14/Python%E6%93%8D%E4%BD%9CExcel%E5%B7%A5%E4%BD%9C%E7%B0%BF/"/>
    <id>http://AlbertGithubHome.github.io/blog/2020/03/14/Python操作Excel工作簿/</id>
    <published>2020-03-14T10:51:25.000Z</published>
    <updated>2020-03-15T09:28:33.963Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><code>Excel</code> 作为流行的个人计算机数据处理软件，混迹于各个领域，在程序员这里也是常常被处理的对象，可以处理 <code>Excel</code> 格式文件的 Python 库还是挺多的，比如 <code>xlrd</code>、<code>xlwt</code>、<code>xlutils</code>、<code>openpyxl</code>、<code>xlwings</code> 等等，但是每个库处理 <code>Excel</code> 的方式不同，有些库在处理时还会有一些局限性。</p><a id="more"></a><p>接下来对比一下几个库的不同，然后主要记录一下 <code>xlwings</code> 这个库的使用，目前这是个人感觉使用起来比较方便的一个库了，其他的几个库在使用过程中总是有这样或那样的问题，不过在特定情况下使用也是挺不错的。</p><h1 id="EXCEL文件"><a href="#EXCEL文件" class="headerlink" title="EXCEL文件"></a>EXCEL文件</h1><p><code>Excel</code> 被称为电子表格，其实际可以保存的格式分为很多种，但是“Excel 工作簿(*.xlsx)”和“Excel 97-2003 工作簿(*.xls)”是其中比较常用的两种，可以认为 <code>.xls</code> 格式的表格是 <code>03版Excel</code> 之前常用的格式，而 <code>.xlsx</code> 是 03版之后，一般指 <code>07版Excel</code> 之后常用的格式。</p><p>一般的 Excel 程序对于上述的两种格式都可以打开编辑，也可以相互转化存储，不过还是建议在没有特殊要求的情况下使用新版本的格式，一方面新的稳定版本可能会修复之前的一些BUG，同时也会带来进行一些优化。</p><p>我也是在写这篇总结之前才发现，一个空的 <code>.xlsx</code> 格式的文件大小有 7KB，而一个空的 <code>.xls</code> 格式的文件大小有 24KB，当我分别写入一个相同的汉字后，两个文件大小变成了 10KB 和 30KB，差距还是不小的，还有一个问题就是在将 <code>.xlsx</code> 格式的文件另存为 <code>.xls</code> 格式时还会有兼容性提示，提醒用户有些设置可能会丢失，所以能选新版本还是尽量用新版本吧。</p><h1 id="测试环境"><a href="#测试环境" class="headerlink" title="测试环境"></a>测试环境</h1><p>因为很多应用程序是不断迭代的，相对应的 Python 库也是不断迭代的，这里尽可能的给出版本号，不同的版本可能会有不同的问题：</p><ul><li>操作系统: Windows 10 随意版</li><li>Python: 3.75</li><li>xlrd: 1.2.0</li><li>xlwt: 1.3.0</li><li>xlutils: 2.0.0</li><li>openpyxl: 3.0.3</li><li>xlwings: 0.18.0</li></ul><p>以上各个程序库使用之前自行安装就行，安装方法就不赘述了，不过可以提供一个可以快速安装镜像源，使用 <code>pip install -i https://pypi.doubanio.com/simple 库名</code> 可以尽可能解决下载安装缓慢的问题。</p><h1 id="Excel具体操作"><a href="#Excel具体操作" class="headerlink" title="Excel具体操作"></a>Excel具体操作</h1><p>关于使用 Python 具体操作 <code>Excel</code> 的方法可以分为三组，配合使用 <code>xlrd</code>、<code>xlwt</code>、<code>xlutils</code> 操作作为第一组，使用库 <code>openpyxl</code> 作为第二组，而 <code>xlwings</code> 作为第三组，这篇总结重点总结 <code>xlwings</code> 的使用，其他两组简单了解。</p><h2 id="xlrd、xlwt、xlutils"><a href="#xlrd、xlwt、xlutils" class="headerlink" title="xlrd、xlwt、xlutils"></a><code>xlrd</code>、<code>xlwt</code>、<code>xlutils</code></h2><p>这一组操作 <code>Excel</code> 的库名字很形象，一个读、一个写、一个小工具，凑到一起就可以对 <code>Excel</code> 肆意妄为了，下面做个小练习，打开一个 <code>Excel</code> 文件然后修改第一个单元格的值，再另存为一个新文件，代码如下:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> xlrd</span><br><span class="line"><span class="keyword">import</span> xlwt</span><br><span class="line"><span class="keyword">import</span> xlutils.copy</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">save_as_new_file</span><span class="params">(file_name, new_file_name)</span>:</span></span><br><span class="line">    <span class="comment"># 打开Excel文件</span></span><br><span class="line">    rb = xlrd.open_workbook(file_name)</span><br><span class="line">    <span class="comment"># 创建一个可写入的副本</span></span><br><span class="line">    wb = xlutils.copy.copy(rb)</span><br><span class="line">    <span class="comment"># 获得第一个sheet页签</span></span><br><span class="line">    ws = wb.get_sheet(<span class="number">0</span>)</span><br><span class="line">    <span class="comment"># 第一个单元格写入测试值</span></span><br><span class="line">    ws.write(<span class="number">0</span>, <span class="number">0</span>, <span class="string">'test value'</span>)</span><br><span class="line">    <span class="comment"># 另存为一个新文件</span></span><br><span class="line">    wb.save(new_file_name)</span><br></pre></td></tr></table></figure><p>上述代码无论是操作 <code>.xlsx</code> 文件还是操作 <code>.xls</code> 文件都不会报错，但是另存为的 <code>.xlsx</code> 格式的文件会打不开，同时你会发现正常存储的 <code>.xls</code> 文件打开后格式全都没了，怎么办，改个参数试试，将打开文件的代码修改如下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rb = xlrd.open_workbook(file_name, formatting_info=<span class="keyword">True</span>)</span><br></pre></td></tr></table></figure><p>其中参数 <code>formatting_info=True</code> 就表示打开Excel时保留原有的格式，但是这是相对于 <code>.xls</code> 格式的文件，对于 <code>.xlsx</code> 格式的文件直接跑出异常 <code>raise NotImplementedError(&quot;formatting_info=True not yet implemented&quot;)</code>，就因为处理不了 <code>.xlsx</code> 格式的文件，我暂时没有使用这几个库操作 <code>Excel</code>。</p><p>还有一点，这几个库操作单元格时，行和列的索引是从0开始的。</p><h2 id="openpyxl"><a href="#openpyxl" class="headerlink" title="openpyxl"></a><code>openpyxl</code></h2><p>首先说这个库主要用来操作 <code>.xlsx</code> 格式的文件，对于 <code>.xls</code> 格式的文件无法打开，会报 <code>openpyxl does not support the old .xls file format</code> 这样的错误，但是可以存储成这样的格式，再次打开时会有格式不匹配的警告，但是基础的数据还在，所以还是优先用来操作 <code>.xls</code> 格式的文件吧。</p><p>写一个新文件的常见用法：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> openpyxl <span class="keyword">import</span> Workbook</span><br><span class="line"><span class="keyword">from</span> openpyxl <span class="keyword">import</span> load_workbook</span><br><span class="line"><span class="keyword">from</span> openpyxl.styles <span class="keyword">import</span> Font, Fill, Alignment, PatternFill</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">write_new_excel</span><span class="params">(file_name)</span>:</span></span><br><span class="line">    <span class="comment"># 创建一个excel文档</span></span><br><span class="line">    wb = Workbook()</span><br><span class="line">    <span class="comment"># 获得当前激活的sheet对象</span></span><br><span class="line">    ws = wb.active</span><br><span class="line">    <span class="comment"># 给A2单元格赋值</span></span><br><span class="line">    ws[<span class="string">'A2'</span>] = <span class="string">'This is A2 cell'</span></span><br><span class="line">    <span class="comment"># 一行添加多列数据</span></span><br><span class="line">    ws.append([<span class="number">1</span>, <span class="number">2</span>, <span class="string">'hello'</span>])</span><br><span class="line">    <span class="comment"># 添加新的sheet</span></span><br><span class="line">    ws = wb.create_sheet(title=<span class="string">'NewInfo'</span>,index=<span class="number">0</span>)</span><br><span class="line">    <span class="comment"># 设置单元格的值</span></span><br><span class="line">    ws[<span class="string">'A1'</span>] = <span class="string">'This is new sheet'</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 保存excel</span></span><br><span class="line">    wb.save(file_name)</span><br></pre></td></tr></table></figure><p>读取和改写一个原有文件的常见用法：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read_update_excel</span><span class="params">(file_name)</span>:</span></span><br><span class="line">    <span class="comment"># 加载Excel表</span></span><br><span class="line">    wb = load_workbook(file_name)</span><br><span class="line">    <span class="comment"># 打印sheet数量</span></span><br><span class="line">    print(<span class="string">'sheet count:'</span>, len(wb.sheetnames))</span><br><span class="line">    <span class="comment"># 打印所有sheet名字</span></span><br><span class="line">    print(<span class="string">'sheet name list:'</span>, wb.sheetnames)</span><br><span class="line">    <span class="comment"># 获取第一个sheet对象</span></span><br><span class="line">    ws = wb[wb.sheetnames[<span class="number">0</span>]]</span><br><span class="line">    <span class="comment"># 打印sheet表行数和列数</span></span><br><span class="line">    print(<span class="string">'rows count:'</span>, ws.max_row, <span class="string">'cols count:'</span>, ws.max_column)</span><br><span class="line">    <span class="comment"># 更新单元格A1的内容</span></span><br><span class="line">    ws[<span class="string">'A1'</span>] = <span class="string">'this is A1'</span></span><br><span class="line">    <span class="comment"># 在第二行位置插入一行</span></span><br><span class="line">    ws.insert_rows(<span class="number">2</span>)</span><br><span class="line">    <span class="comment"># 删除第五行</span></span><br><span class="line">    ws.delete_rows(<span class="number">5</span>)</span><br><span class="line">    <span class="comment"># 获取单元格对象，对应B2单元格</span></span><br><span class="line">    cell = ws.cell(<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line">    <span class="comment"># 设置单元格内容</span></span><br><span class="line">    cell.value = <span class="string">'this is B2'</span></span><br><span class="line">    <span class="comment"># 修改字体格式为粗体</span></span><br><span class="line">    cell.font = Font(bold=<span class="keyword">True</span>)</span><br><span class="line">    <span class="comment"># 修改单元格格式</span></span><br><span class="line">    cell.fill = PatternFill(<span class="string">"solid"</span>, fgColor=<span class="string">"F0CDCD"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 保存原文件或另存一个文件</span></span><br><span class="line">    wb.save(file_name)</span><br></pre></td></tr></table></figure><p>使用这个库遇到的情况，存储带有样式的数据没有发现问题，但是当加入一个计算公式后，另存为一个文件时明显文件尺寸变小了，但是数据和公式没有发现有问题。</p><p>有资料说处理速度真的很慢，因为我处理的文件比较小，但是没有发现这方面的问题，还有一个问题就是说Excel中的宏全部丢失，这个测试的时候确实是丢了，只不过这个好像和文件格式有关，要想保存宏需要存储为 <code>.xlsm</code> 格式，但是 <code>openpyxl</code> 使用来操作 <code>.xlsx</code> 文件的，存储时会导致宏丢失，强行存储为 <code>.xlsm</code> 格式会导致最终的文件打不开。</p><p>还有一点，这个库操作单元格时，行和列的索引是从1开始的。</p><h2 id="xlwings"><a href="#xlwings" class="headerlink" title="xlwings"></a><code>xlwings</code></h2><p>这个库在操作的首先要创建一个 <code>App</code>，通过这个创建出来的 <code>App</code> 对象来操作 <code>Excel</code>，非常像把 <code>Excel</code> 的各种操作 <code>api</code> 封装到一起，然后通过这个 <code>App</code> 对象来调用，如果在创建 <code>App</code> 的时候不设置隐藏参数，是会正常打开 <code>Excel</code> 程序的。</p><h3 id="使用-xlwings-的基本方式："><a href="#使用-xlwings-的基本方式：" class="headerlink" title="使用 xlwings 的基本方式："></a>使用 <code>xlwings</code> 的基本方式：</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> xlwings <span class="keyword">as</span> xw</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置Excel程序不可见</span></span><br><span class="line">app = xw.App(visible=<span class="keyword">False</span>, add_book=<span class="keyword">False</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过 app 操作 Excel文件</span></span><br><span class="line"><span class="comment"># app.bala bala bala .....</span></span><br><span class="line"><span class="comment"># app.bala bala bala .....</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 优雅的退出</span></span><br><span class="line">app.quit()</span><br></pre></td></tr></table></figure><h3 id="创建一个新的-Excel-文件并写入数据："><a href="#创建一个新的-Excel-文件并写入数据：" class="headerlink" title="创建一个新的 Excel 文件并写入数据："></a>创建一个新的 <code>Excel</code> 文件并写入数据：</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">write_new_excel</span><span class="params">(app, file_name)</span>:</span></span><br><span class="line">    <span class="comment"># 创建新的 Excel 表</span></span><br><span class="line">    wb = app.books.add()</span><br><span class="line">    <span class="comment"># 获取当前活动的sheet</span></span><br><span class="line">    ws = wb.sheets.active</span><br><span class="line">    <span class="comment"># 初始化二维区域的值</span></span><br><span class="line">    arr_data = [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>], [<span class="number">7</span>, <span class="number">8</span>, <span class="string">'end'</span>]]</span><br><span class="line">    <span class="comment"># 设置到新建的Excel中</span></span><br><span class="line">    ws.range(<span class="string">'A1:B3'</span>).value=arr_data</span><br><span class="line">    <span class="comment"># 设置单独一个单元格的值</span></span><br><span class="line">    ws.range(<span class="string">'A4'</span>).value=<span class="string">'this is A4'</span></span><br><span class="line">    <span class="comment"># 设置单独一个单元格的值</span></span><br><span class="line">    ws[<span class="number">3</span>,<span class="number">1</span>].value=<span class="string">'this is B4'</span></span><br><span class="line">    <span class="comment"># 保存Excel文件</span></span><br><span class="line">    wb.save(file_name)</span><br><span class="line">    wb.close()</span><br></pre></td></tr></table></figure><p>需要注意的是通过行索引和列索引修改单元格时，起始索引是0。</p><h3 id="读入已有-Excel-表格并修改"><a href="#读入已有-Excel-表格并修改" class="headerlink" title="读入已有 Excel 表格并修改"></a>读入已有 Excel 表格并修改</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read_update_excel</span><span class="params">(app, file_name)</span>:</span></span><br><span class="line">    <span class="comment"># 加载已有的表格</span></span><br><span class="line">    load_wb = app.books.open(file_name)</span><br><span class="line">    <span class="comment"># 获取Excel表中第一个sheet</span></span><br><span class="line">    load_ws = load_wb.sheets[<span class="number">0</span>]</span><br><span class="line">    <span class="comment"># 打印sheet的名字</span></span><br><span class="line">    print(load_ws.name)</span><br><span class="line">    <span class="comment"># 根据sheet名字获取sheet对象</span></span><br><span class="line">    load_ws = load_wb.sheets[load_ws.name]</span><br><span class="line">    <span class="comment"># 获取当前活动的sheet</span></span><br><span class="line">    load_ws = load_wb.sheets.active</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获取存在数据的行数和列数</span></span><br><span class="line">    rows = load_ws.api.UsedRange.Rows.count</span><br><span class="line">    cols = load_ws.api.UsedRange.Columns.count</span><br><span class="line">    print(<span class="string">'rows count:'</span>, rows, <span class="string">'cols count:'</span>, cols)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 修改指定单元格数据（A1单元格）</span></span><br><span class="line">    load_ws[<span class="number">0</span>,<span class="number">0</span>].value=<span class="string">'this is A1'</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 有空行或空列时获取准确的行列数量</span></span><br><span class="line">    print(load_ws.used_range.shape)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 从A1单元格开始扩展到非空行空列，最后的行数和列数</span></span><br><span class="line">    print((load_ws.range(<span class="string">'A1'</span>).expand().last_cell.row,</span><br><span class="line">        load_ws.range(<span class="string">'A1'</span>).expand().last_cell.column))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 从A1单元格开始扩展到非空行空列，最后的行数和列数</span></span><br><span class="line">    print((load_ws.range(<span class="string">'A1'</span>).expand().last_cell.row,</span><br><span class="line">        load_ws.range(<span class="string">'A1'</span>).expand().last_cell.column))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 从A1单元格开始扩展到非空行空列，最后形状</span></span><br><span class="line">    print(load_ws.range(<span class="number">1</span>,<span class="number">1</span>).expand().shape)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 从A1单元格开始扩展到非空行空列，最后的行数和列数</span></span><br><span class="line">    print((load_ws.range(<span class="string">'A1'</span>).expand(<span class="string">'table'</span>).rows.count,</span><br><span class="line">        load_ws.range(<span class="string">'A1'</span>).expand(<span class="string">'table'</span>).columns.count))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 保存修改后的Excel</span></span><br><span class="line">    load_wb.save(file_name)</span><br><span class="line">    load_wb.close()</span><br></pre></td></tr></table></figure><h3 id="Excel-增加删除行和列"><a href="#Excel-增加删除行和列" class="headerlink" title="Excel 增加删除行和列"></a>Excel 增加删除行和列</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insert_delete_rowscols</span><span class="params">(app, file_name)</span>:</span></span><br><span class="line">    <span class="comment"># 加载已有的表格</span></span><br><span class="line">    load_wb = app.books.open(file_name)</span><br><span class="line">    <span class="comment"># 获取当前活动的sheet</span></span><br><span class="line">    load_ws = load_wb.sheets.active</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 从第2行开始插入4行，也就是说2-5行变成新插入的空行</span></span><br><span class="line">    load_ws.api.rows(<span class="string">'2:5'</span>).insert</span><br><span class="line">    <span class="comment"># 删除第6行和第7行</span></span><br><span class="line">    load_ws.api.rows(<span class="string">'6:7'</span>).delete</span><br><span class="line">    <span class="comment"># 插入一个单元格，实际测试效果是B列从B2开始向下移动，B2为新添加的单元格</span></span><br><span class="line">    load_ws.range(<span class="string">'B2'</span>).api.insert</span><br><span class="line">    <span class="comment"># 插入新的一列</span></span><br><span class="line">    load_ws.api.columns(<span class="string">'B'</span>).insert</span><br><span class="line">    <span class="comment"># 删除一列</span></span><br><span class="line">    load_ws.api.columns(<span class="string">'C'</span>).delete</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 保存修改后的Excel</span></span><br><span class="line">    load_wb.save(file_name)</span><br><span class="line">    load_wb.close()</span><br></pre></td></tr></table></figure><h3 id="单元格宽高查询设置与合并"><a href="#单元格宽高查询设置与合并" class="headerlink" title="单元格宽高查询设置与合并"></a>单元格宽高查询设置与合并</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cell_operation</span><span class="params">(app, file_name)</span>:</span></span><br><span class="line">    <span class="comment"># 加载已有的表格</span></span><br><span class="line">    load_wb = app.books.open(FILE_PATH_ROOT + file_name)</span><br><span class="line">    <span class="comment"># 获取当前活动的sheet</span></span><br><span class="line">    load_ws = load_wb.sheets.active</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 合并单元格</span></span><br><span class="line">    load_ws.range(<span class="string">'A2:A3'</span>).api.merge</span><br><span class="line"></span><br><span class="line">    <span class="comment">#获取单元格</span></span><br><span class="line">    cell = xw.Range(<span class="string">'B2'</span>)</span><br><span class="line">    <span class="comment"># 打印单元格所在的行和列</span></span><br><span class="line">    print(<span class="string">"row is:"</span>, cell.row, <span class="string">"col is:"</span>, cell.column)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 打印当前格子的高度和宽度</span></span><br><span class="line">    print(<span class="string">"cell.width:"</span>, cell.width, <span class="string">"cell.height:"</span>, cell.height)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 设置当前格子的高度和宽度</span></span><br><span class="line">    cell.row_height = <span class="number">32</span></span><br><span class="line">    cell.column_width = <span class="number">64</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 指定单元格的高度和宽度自适应</span></span><br><span class="line">    cell.columns.autofit()</span><br><span class="line">    cell.rows.autofit()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 再次打印当前格子的高度和宽度</span></span><br><span class="line">    print(<span class="string">"cell.width:"</span>, cell.width, <span class="string">"cell.height:"</span>, cell.height)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 保存修改后的Excel</span></span><br><span class="line">    load_wb.save(file_name)</span><br><span class="line">    load_wb.close()</span><br></pre></td></tr></table></figure><h1 id="几个库支持情况对比"><a href="#几个库支持情况对比" class="headerlink" title="几个库支持情况对比"></a>几个库支持情况对比</h1><p>虽然前面写了这么多方法，但是遇到一个实际的问题时还是会犹豫，到底用哪种方式呢？下面做一个简单的对比，只是根据我做的实验来简单对比，如果有不准确甚至是错误的地方，欢迎大家指出来，我会尽快改正的。</p><table><thead><tr><th style="text-align:left">情景/库</th><th style="text-align:center"><code>xlrd</code>、<code>xlwt</code>、<code>xlutils</code></th><th style="text-align:center"><code>openpyxl</code></th><th style="text-align:center"><code>xlwings</code></th></tr></thead><tbody><tr><td style="text-align:left">读取<code>.xls</code></td><td style="text-align:center">可以带有样式读取</td><td style="text-align:center">不支持</td><td style="text-align:center">可以读取</td></tr><tr><td style="text-align:left">保存<code>.xls</code></td><td style="text-align:center">可以带有样式保存</td><td style="text-align:center">可以保存，但是提示文件扩展名不匹配，可以看到原始数据</td><td style="text-align:center">可以保存，但是提示文件扩展名不匹配，可以看到原始数据</td></tr><tr><td style="text-align:left">读取<code>.xlsx</code></td><td style="text-align:center">可以读取，但没有样式</td><td style="text-align:center">可以带有样式读取</td><td style="text-align:center">可以带有样式读取</td></tr><tr><td style="text-align:left">保存<code>.xlsx</code></td><td style="text-align:center">保存后打不开</td><td style="text-align:center">可以带有样式保存</td><td style="text-align:center">可以带有样式保存</td></tr><tr><td style="text-align:left">读取<code>.xlsm</code></td><td style="text-align:center">可以读取，但没有样式和宏</td><td style="text-align:center">可以读取，但没有宏</td><td style="text-align:center">可以读取包含宏的表格</td></tr><tr><td style="text-align:left">保存<code>.xlsm</code></td><td style="text-align:center">保存后打不开，存成 <code>.xls</code> 格式宏丢失</td><td style="text-align:center">保存后打不开，存成 <code>.xls想</code> 格式宏丢失</td><td style="text-align:center">存储后宏还在</td></tr><tr><td style="text-align:left">增删行和列</td><td style="text-align:center">没有直接方法</td><td style="text-align:center">支持</td><td style="text-align:center">支持</td></tr><tr><td style="text-align:left">另存后大小</td><td style="text-align:center"><code>.xls</code> 文件没有变化</td><td style="text-align:center"><code>.xlsx</code> 文件会变小</td><td style="text-align:center"><code>.xls</code>、<code>.xlsx</code> 文件没有变化</td></tr><tr><td style="text-align:left">使用建议</td><td style="text-align:center">只操作.xls文件可以考虑</td><td style="text-align:center">只操作.xlsx文件可以考虑，不能带有宏</td><td style="text-align:center">一个比较好的选择，使用时感觉速度稍微有点慢</td></tr></tbody></table><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol><li>Excel 表格程序经过版本的更替发生了很大的变化，出现了相同内容时 <code>.xls</code> 比 <code>.xlsx</code> 格式的文件大很多的情况</li><li>基于上一点考虑，如果能使用的新版的表格，那么就放弃旧的格式的吧</li><li>还有一个神奇的情况，一个带有少量数据的 <code>.xlsx</code> 格式的表格要比一个空表格还要小，这是什么情况，暂时没弄明白怎么回事，求知道的大神告知一二</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&lt;code&gt;Excel&lt;/code&gt; 作为流行的个人计算机数据处理软件，混迹于各个领域，在程序员这里也是常常被处理的对象，可以处理 &lt;code&gt;Excel&lt;/code&gt; 格式文件的 Python 库还是挺多的，比如 &lt;code&gt;xlrd&lt;/code&gt;、&lt;code&gt;xlwt&lt;/code&gt;、&lt;code&gt;xlutils&lt;/code&gt;、&lt;code&gt;openpyxl&lt;/code&gt;、&lt;code&gt;xlwings&lt;/code&gt; 等等，但是每个库处理 &lt;code&gt;Excel&lt;/code&gt; 的方式不同，有些库在处理时还会有一些局限性。&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="http://AlbertGithubHome.github.io/blog/categories/Python/"/>
    
    
      <category term="Python" scheme="http://AlbertGithubHome.github.io/blog/tags/Python/"/>
    
      <category term="Excel" scheme="http://AlbertGithubHome.github.io/blog/tags/Excel/"/>
    
      <category term="xlrd" scheme="http://AlbertGithubHome.github.io/blog/tags/xlrd/"/>
    
      <category term="xlutils" scheme="http://AlbertGithubHome.github.io/blog/tags/xlutils/"/>
    
      <category term="xlwings" scheme="http://AlbertGithubHome.github.io/blog/tags/xlwings/"/>
    
  </entry>
  
  <entry>
    <title>git checkout/git reset/git revert/git restore常用回退操作</title>
    <link href="http://AlbertGithubHome.github.io/blog/2020/03/03/git-checkout-git-reset-git-revert-git-restore%E5%B8%B8%E7%94%A8%E5%9B%9E%E9%80%80%E6%93%8D%E4%BD%9C/"/>
    <id>http://AlbertGithubHome.github.io/blog/2020/03/03/git-checkout-git-reset-git-revert-git-restore常用回退操作/</id>
    <published>2020-03-03T14:58:46.000Z</published>
    <updated>2020-03-07T10:46:24.885Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在 <code>Git</code> 中没有真正的方法来做任何事情，这就是它的妙处！</p></blockquote><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>经常会听到别人说，如果时光可以倒流，我将会如何如何，可是现阶段的科技还达不到时光倒流的目的，或许在《三体》世界的四维裂缝里可以试一下。现实的世界中找不到后悔药，但是在代码的世界里却可以轻松实现，错误的BUG修改、砍掉的做了一半的功能都可以轻松回退，不留一丝痕迹，回滚之后一切又可以重新开始了。</p><a id="more"></a><h1 id="代码回退"><a href="#代码回退" class="headerlink" title="代码回退"></a>代码回退</h1><p>大型编程项目的开发往往伴随着版本工具的使用，其实引入代码版本控制工具，有一部分原因也是为了方便回退，回退操作每天都发生的，只是有时是我们显式的操作，有时却自然而然的进行着，我们切换着分支很可能就是从开发版本回退到一个稳定版本，我们查询日志，实际上是在记忆上回退我们整个的开发过程，找寻其中的问题和修改的内容。</p><h1 id="Git管理下的各种文件状态"><a href="#Git管理下的各种文件状态" class="headerlink" title="Git管理下的各种文件状态"></a>Git管理下的各种文件状态</h1><p><code>Git</code>的使用中，由于一个文件存在好几种状态的变化，所以处理起回退要分情况进行，有些各式各样的命令最终分析起来其实作用是一样的。</p><p>说起<code>Git</code>常常会提到工作区、暂存区、版本库的概念，这是很通用的说法，其实工作区一般就是指我们能看到的文件、本地操作文件所在的目录，我们正常编写的代码文件、管理的资源文件都是在工作区里操作，这里的文件也不是全都平等的，又细分为受版本控制的文件和不受版本控制的文件。</p><p>提到暂存区就和index文件建立起了联系，工作区的新文件和已经修改的受版本控制的文件，使用 <code>git add file_name</code> 就可以加到暂存区，相当于登记报个名，以后提交到版本库的时候会把这些登记的文件都带上，实际上执行了 <code>git add</code> 命令的文件都生成了对应的 object 对象，放在.git/objects目录下，状态变成了 <code>staged</code>， 当提交到版本库时，分支会引用这些对象。</p><p>版本库就是文件修改的目的地了，最终的修改会提交到版本库，这时提交的文件状态变成 <code>committed</code>，其实也是一种 <code>unmodified</code> 状态，一路走来，版本库中记录了你的每一次提交，可以追溯你每一次修改的内容。</p><p>其实还有一个远程仓库的概念，一般确定本地仓库的修改没有问题了，或者要将本地代码远程备份时，可以将自己修改的分支推送到远程仓库，因为有时候我们也想回退已经推送到远程仓库的修改，所以这里先提一下远程仓库。</p><p>总结起来一个文件的状态通常可以分为：</p><ul><li>不受版本控制的 <code>untracked</code> 状态</li><li>受版本控制并且已修改的 <code>modified</code> 状态</li><li>受版本控制已修改并提交到暂存区的 <code>staged</code> 状态</li><li>从暂存区已经提交到本地仓库的 <code>committed</code> 状态</li><li>提交到本地仓库未修改或者从远程仓库克隆下来的 <code>unmodified</code> 状态</li></ul><h1 id="Git回退命令"><a href="#Git回退命令" class="headerlink" title="Git回退命令"></a>Git回退命令</h1><p>上面提到了在 <code>Git</code> 这个版本控制工具下文件的各种状态，其实回退操作就是通过命令实现这些文件状态的“倒退”，进而达到回退操作的目的，下面一起先来了解下这些可以实现回退的命令。</p><h2 id="git-checkout"><a href="#git-checkout" class="headerlink" title="git checkout"></a>git checkout</h2><p>这个命令又出现了，上次是总结 <code>git branch</code> 分支操作的时候，<code>git checkout</code> 可以用来新建或者切换分支，这次总结回退版本的命令，<code>git checkout</code> 也可以用来回退文件版本，很神奇吧。</p><p>其实这个命令的作用就是它单词的本义——检出，他的常用操作也取自这个意思，比如 <code>git checkout branch_name</code> 切换分支操作，实际上就是把指定分支在仓库中对应的所有文件检出来覆盖当前工作区，最终表现就是切换了分支。</p><p>而针对于文件的检出可以使用 <code>git checkout -- file_name</code>，当不指定 <code>commit id</code> 就是将暂存区的内容恢复到工作区，也就可以达到回退本地修改的作用。</p><p>不过，这个身兼数职的 <code>git checkout</code> 命令现在可以轻松一些了，从 <code>Git 2.23</code> 版本开始引入了两个新的命令： <code>git switch</code> 用来切换分支，<code>git restore</code>用来还原工作区的文件，这个后面还会提到。</p><h2 id="git-revert"><a href="#git-revert" class="headerlink" title="git revert"></a>git revert</h2><p>revert 这个词的意思是：归还，复原，回退，它和后面即将提到的 restore 在意思上简直无法区分，为了区别他们两个这里可以把 <code>git revert</code> 看成归还的意思，对某次提交执行 <code>git revert</code> 命令就是对这次修改执行一个归还操作，其实就是反向再修改一次。</p><p>要理解 <code>git revert</code> 就要从反向修改的含义来看，当我们再一个文件中添加一行内容，并提交到版本库后，产生一个提交id——<code>commit-id-a</code>，如果这时使用 <code>git revert commit-id-a</code> 命令，就相当于在工作区中的那个文件将刚在新加的一行内容删除掉，然后再进行一个提交。</p><p>注意，这个操作是会改变分支记录的，因为产生了新的提交。</p><h2 id="git-restore"><a href="#git-restore" class="headerlink" title="git restore"></a>git restore</h2><p>这个命令是 <code>Git 2.23</code> 版本之后新加的，用来分担之前 <code>git checkout</code> 命令的功能，作用就是用暂存区或者版本库中的文件覆盖本地文件的修改可以达到回退修改的目的，同时也可以使用版本库中的文件覆盖暂存区的文件，达到回退<code>git add</code> 命令的目的。</p><p>注意，这个操作是不会影响分支记录的，就是相当于之前的 <code>git checkout</code> 命令重新检出一份文件来覆盖本地的修改。</p><h2 id="git-reset"><a href="#git-reset" class="headerlink" title="git reset"></a>git reset</h2><p>reset 重新设置的意思，其实就是用来设置分支的头部指向，当进行了一系列的提交之后，忽然发现最近的几次提交有问题，想从提交记录中删除，这是就会用到 <code>git reset</code> 命令，这个命令后面跟 <code>commit id</code>，表示当前分支回退到这个 <code>commit id</code> 对应的状态，之后的日志记录被删除，工作区中的文件状态根据参数的不同会恢复到不同的状态。</p><ul><li><p><code>--soft</code>: 被回退的那些版本的修改会被放在暂存区，可以再次提交。</p></li><li><p><code>--mixed</code>: 默认选项，被回退的那些版本的修改会放在工作目录，可以先加到暂存区，然后再提交。</p></li><li><p><code>--hard</code>: 被回退的那些版本的修改会直接舍弃，好像它们没有来过一样。</p></li></ul><p>这样来看，<code>git set</code> 命令好像是用来回退版本的，但是如果使用 <code>git rest HEAD file_name</code> 命令就可以将一个文件回退到 <code>HEAD</code> 指向版本所对应的状态，其实就是当前版本库中的状态，也就相当于还原了本地的修改。</p><h2 id="git-rm"><a href="#git-rm" class="headerlink" title="git rm"></a>git rm</h2><p>临时插播的命令，本来删除不能算是回退，但是如果它和某些命令反着来就是一种回退，比如对一个新文件使用 <code>git add newfile_name</code> 命令，然后再使用 <code>git rm --cached newfile_name</code> 就可以将这个文件从暂存区移除掉，但是在工作区里没有消失，如果不加 <code>--cached</code> 参数，就会从工作区和版本库暂存区同时删除，相当于执行了 <code>rm newfile_name</code> 和 <code>git add new_file</code> 两条命令。</p><h1 id="具体回退操作"><a href="#具体回退操作" class="headerlink" title="具体回退操作"></a>具体回退操作</h1><p>说了这么多肯定有点懵，特别是一个相同的需求可以使用很多命令来实现的时候，接下来看一些具体需求，整个测试过程用上一篇总结<a href="https://blog.csdn.net/albertsh/article/details/104581541" target="_blank" rel="noopener">《git branch常用分支操作》</a>使用的 git 仓库来进行，远程地址是 <code>git@gitee.com:myname/gitstart.git</code>，下面测试开始，我们看一下这些情况怎么进行还原：</p><h2 id="初始状态"><a href="#初始状态" class="headerlink" title="初始状态"></a>初始状态</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">albert@homepc MINGW64 /d/gitstart (dev)</span><br><span class="line">$ ls</span><br><span class="line">README.md</span><br><span class="line"></span><br><span class="line">albert@homepc MINGW64 /d/gitstart (dev)</span><br><span class="line">$ git status</span><br><span class="line">On branch dev</span><br><span class="line">Your branch is up to date with <span class="string">'origin/dev'</span>.</span><br><span class="line"></span><br><span class="line">nothing to commit, working tree clean</span><br><span class="line"></span><br><span class="line">albert@homepc MINGW64 /d/gitstart (dev)</span><br><span class="line">$ git branch -a</span><br><span class="line">* dev</span><br><span class="line">  master</span><br><span class="line">  remotes/origin/dev</span><br><span class="line">  remotes/origin/master</span><br><span class="line"></span><br><span class="line">albert@homepc MINGW64 /d/gitstart (dev)</span><br><span class="line">$ git branch -vv</span><br><span class="line">* dev     3226b63 [origin/dev] add readme file</span><br><span class="line">  master  3226b63 [origin/master] add readme file</span><br></pre></td></tr></table></figure><h2 id="还原00：工作区中未加到暂存区和版本库的文件，还原今天所做的修改"><a href="#还原00：工作区中未加到暂存区和版本库的文件，还原今天所做的修改" class="headerlink" title="还原00：工作区中未加到暂存区和版本库的文件，还原今天所做的修改"></a>还原00：工作区中未加到暂存区和版本库的文件，还原今天所做的修改</h2><p>实话实说，办不到，没有加到过暂存区就没有被追踪，它的任何修改是没有办法回退的，可是使用 <code>Ctrl+Z</code> 碰碰运气，没准就退回到了你想要的状态。</p><h2 id="还原01：工作区中未加到暂存区和版本库的文件，执行了-git-add-操作"><a href="#还原01：工作区中未加到暂存区和版本库的文件，执行了-git-add-操作" class="headerlink" title="还原01：工作区中未加到暂存区和版本库的文件，执行了 git add 操作"></a>还原01：工作区中未加到暂存区和版本库的文件，执行了 <code>git add</code> 操作</h2><p>这种情况可以使用<code>git rm --cached newfile</code>、<code>git restore --staged newfile</code> 或者 <code>git reset HEAD newfile</code> 命令，使用后两个命令的时候不能是版本库的第一个文件。</p><h3 id="git-rm-1"><a href="#git-rm-1" class="headerlink" title="git rm"></a>git rm</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">albert@homepc MINGW64 /d/gitstart (dev)</span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">"test data"</span>&gt;new.txt</span><br><span class="line"></span><br><span class="line">albert@homepc MINGW64 /d/gitstart (dev)</span><br><span class="line">$ git add new.txt</span><br><span class="line">warning: LF will be replaced by CRLF <span class="keyword">in</span> new.txt.</span><br><span class="line">The file will have its original line endings <span class="keyword">in</span> your working directory</span><br><span class="line"></span><br><span class="line">albert@homepc MINGW64 /d/gitstart (dev)</span><br><span class="line">$ git status</span><br><span class="line">On branch dev</span><br><span class="line">Your branch is up to date with <span class="string">'origin/dev'</span>.</span><br><span class="line"></span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">"git restore --staged &lt;file&gt;..."</span> to unstage)</span><br><span class="line">        new file:   new.txt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">albert@homepc MINGW64 /d/gitstart (dev)</span><br><span class="line">$ git rm --cached new.txt</span><br><span class="line">rm <span class="string">'new.txt'</span></span><br><span class="line"></span><br><span class="line">albert@homepc MINGW64 /d/gitstart (dev)</span><br><span class="line">$ git status</span><br><span class="line">On branch dev</span><br><span class="line">Your branch is up to date with <span class="string">'origin/dev'</span>.</span><br><span class="line"></span><br><span class="line">Untracked files:</span><br><span class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> to include <span class="keyword">in</span> what will be committed)</span><br><span class="line">        new.txt</span><br><span class="line"></span><br><span class="line">nothing added to commit but untracked files present (use <span class="string">"git add"</span> to track)</span><br></pre></td></tr></table></figure><h3 id="git-restore-1"><a href="#git-restore-1" class="headerlink" title="git restore"></a>git restore</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">albert@homepc MINGW64 /d/gitstart (dev)</span><br><span class="line">$ git add new.txt</span><br><span class="line">warning: LF will be replaced by CRLF <span class="keyword">in</span> new.txt.</span><br><span class="line">The file will have its original line endings <span class="keyword">in</span> your working directory</span><br><span class="line"></span><br><span class="line">albert@homepc MINGW64 /d/gitstart (dev)</span><br><span class="line">$ git status</span><br><span class="line">On branch dev</span><br><span class="line">Your branch is up to date with <span class="string">'origin/dev'</span>.</span><br><span class="line"></span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">"git restore --staged &lt;file&gt;..."</span> to unstage)</span><br><span class="line">        new file:   new.txt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">albert@homepc MINGW64 /d/gitstart (dev)</span><br><span class="line">$ git restore --staged new.txt</span><br><span class="line"></span><br><span class="line">albert@homepc MINGW64 /d/gitstart (dev)</span><br><span class="line">$ git status</span><br><span class="line">On branch dev</span><br><span class="line">Your branch is up to date with <span class="string">'origin/dev'</span>.</span><br><span class="line"></span><br><span class="line">Untracked files:</span><br><span class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> to include <span class="keyword">in</span> what will be committed)</span><br><span class="line">        new.txt</span><br><span class="line"></span><br><span class="line">nothing added to commit but untracked files present (use <span class="string">"git add"</span> to track)</span><br></pre></td></tr></table></figure><h3 id="git-reset-1"><a href="#git-reset-1" class="headerlink" title="git reset"></a>git reset</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">albert@homepc MINGW64 /d/gitstart (dev)</span><br><span class="line">$ git add new.txt</span><br><span class="line">warning: LF will be replaced by CRLF <span class="keyword">in</span> new.txt.</span><br><span class="line">The file will have its original line endings <span class="keyword">in</span> your working directory</span><br><span class="line"></span><br><span class="line">albert@homepc MINGW64 /d/gitstart (dev)</span><br><span class="line">$ git status</span><br><span class="line">On branch dev</span><br><span class="line">Your branch is up to date with <span class="string">'origin/dev'</span>.</span><br><span class="line"></span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">"git restore --staged &lt;file&gt;..."</span> to unstage)</span><br><span class="line">        new file:   new.txt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">albert@homepc MINGW64 /d/gitstart (dev)</span><br><span class="line">$ git reset HEAD new.txt</span><br><span class="line"></span><br><span class="line">albert@homepc MINGW64 /d/gitstart (dev)</span><br><span class="line">$ git status</span><br><span class="line">On branch dev</span><br><span class="line">Your branch is up to date with <span class="string">'origin/dev'</span>.</span><br><span class="line"></span><br><span class="line">Untracked files:</span><br><span class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> to include <span class="keyword">in</span> what will be committed)</span><br><span class="line">        new.txt</span><br><span class="line"></span><br><span class="line">nothing added to commit but untracked files present (use <span class="string">"git add"</span> to track)</span><br></pre></td></tr></table></figure><h2 id="还原02：版本库中的文件，修改或删除后未执行-git-add-操作"><a href="#还原02：版本库中的文件，修改或删除后未执行-git-add-操作" class="headerlink" title="还原02：版本库中的文件，修改或删除后未执行 git add 操作"></a>还原02：版本库中的文件，修改或删除后未执行 <code>git add</code> 操作</h2><p>我们直接修改 README.md 文件吧，删除刚才添加的未受版本管理的 new.txt，在 README.md 文件中添加内容，然后试着还原，这种情况常常出现在修改一个功能还未提交，但是先不要求修改了，可以直接还原。</p><p>这种情况可以使用<code>git restore file_name</code>、<code>git checkout -- file_name</code> 或者 <code>git reset --hard HEAD</code> 命令，最后的<code>git reset</code> 命令带有 <code>--hard</code> 参数不能再加文件目录，只能将工作区全还原。</p><h3 id="git-restore-2"><a href="#git-restore-2" class="headerlink" title="git restore"></a>git restore</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">albert@homepc MINGW64 /d/gitstart (dev)</span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">"new line"</span>&gt;&gt;README.md</span><br><span class="line"></span><br><span class="line">albert@homepc MINGW64 /d/gitstart (dev)</span><br><span class="line">$ git status</span><br><span class="line">On branch dev</span><br><span class="line">Your branch is up to date with <span class="string">'origin/dev'</span>.</span><br><span class="line"></span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">"git restore &lt;file&gt;..."</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line">        modified:   README.md</span><br><span class="line"></span><br><span class="line">no changes added to commit (use <span class="string">"git add"</span> and/or <span class="string">"git commit -a"</span>)</span><br><span class="line"></span><br><span class="line">albert@homepc MINGW64 /d/gitstart (dev)</span><br><span class="line">$ git restore README.md</span><br><span class="line"></span><br><span class="line">albert@homepc MINGW64 /d/gitstart (dev)</span><br><span class="line">$ git status</span><br><span class="line">On branch dev</span><br><span class="line">Your branch is up to date with <span class="string">'origin/dev'</span>.</span><br><span class="line"></span><br><span class="line">nothing to commit, working tree clean</span><br></pre></td></tr></table></figure><h3 id="git-checkout-1"><a href="#git-checkout-1" class="headerlink" title="git checkout"></a>git checkout</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">albert@homepc MINGW64 /d/gitstart (dev)</span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">"new line"</span>&gt;&gt;README.md</span><br><span class="line"></span><br><span class="line">albert@homepc MINGW64 /d/gitstart (dev)</span><br><span class="line">$ git status</span><br><span class="line">On branch dev</span><br><span class="line">Your branch is up to date with <span class="string">'origin/dev'</span>.</span><br><span class="line"></span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">"git restore &lt;file&gt;..."</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line">        modified:   README.md</span><br><span class="line"></span><br><span class="line">no changes added to commit (use <span class="string">"git add"</span> and/or <span class="string">"git commit -a"</span>)</span><br><span class="line"></span><br><span class="line">albert@homepc MINGW64 /d/gitstart (dev)</span><br><span class="line">$ git checkout -- README.md</span><br><span class="line"></span><br><span class="line">albert@homepc MINGW64 /d/gitstart (dev)</span><br><span class="line">$ git status</span><br><span class="line">On branch dev</span><br><span class="line">Your branch is up to date with <span class="string">'origin/dev'</span>.</span><br><span class="line"></span><br><span class="line">nothing to commit, working tree clean</span><br></pre></td></tr></table></figure><h3 id="git-reset-2"><a href="#git-reset-2" class="headerlink" title="git reset"></a>git reset</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">albert@homepc MINGW64 /d/gitstart (dev)</span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">"new line"</span>&gt;&gt;README.md</span><br><span class="line"></span><br><span class="line">albert@homepc MINGW64 /d/gitstart (dev)</span><br><span class="line">$ git status</span><br><span class="line">On branch dev</span><br><span class="line">Your branch is up to date with <span class="string">'origin/dev'</span>.</span><br><span class="line"></span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">"git restore &lt;file&gt;..."</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line">        modified:   README.md</span><br><span class="line"></span><br><span class="line">no changes added to commit (use <span class="string">"git add"</span> and/or <span class="string">"git commit -a"</span>)</span><br><span class="line"></span><br><span class="line">albert@homepc MINGW64 /d/gitstart (dev)</span><br><span class="line">$ git reset --hard HEAD README.md</span><br><span class="line">fatal: Cannot <span class="keyword">do</span> hard reset with paths.</span><br><span class="line"></span><br><span class="line">albert@homepc MINGW64 /d/gitstart (dev)</span><br><span class="line">$ git reset --hard HEAD</span><br><span class="line">HEAD is now at 3226b63 add readme file</span><br><span class="line"></span><br><span class="line">albert@homepc MINGW64 /d/gitstart (dev)</span><br><span class="line">$ git status</span><br><span class="line">On branch dev</span><br><span class="line">Your branch is up to date with <span class="string">'origin/dev'</span>.</span><br><span class="line"></span><br><span class="line">nothing to commit, working tree clean</span><br></pre></td></tr></table></figure><h2 id="还原03：版本库中的文件，修改或删除后执行了-git-add-操作"><a href="#还原03：版本库中的文件，修改或删除后执行了-git-add-操作" class="headerlink" title="还原03：版本库中的文件，修改或删除后执行了 git add 操作"></a>还原03：版本库中的文件，修改或删除后执行了 <code>git add</code> 操作</h2><p>使用了 <code>git add</code> 命令之后，文件的改变就放到了暂存区，这种情况可以使用<code>git restore --staged file_name</code> 或者 <code>git reset HEAD file_name</code> 命令。</p><h3 id="git-restore-3"><a href="#git-restore-3" class="headerlink" title="git restore"></a>git restore</h3><p>执行 <code>git restore --staged file_name</code> 实际上是使用版本库中的文件覆盖暂存区中的数据，执行结束后文件状态变成了 <code>&lt;还原02&gt;</code> 中的情况。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">albert@homepc MINGW64 /d/gitstart (dev)</span><br><span class="line">$ git status</span><br><span class="line">On branch dev</span><br><span class="line">Your branch is up to date with <span class="string">'origin/dev'</span>.</span><br><span class="line"></span><br><span class="line">nothing to commit, working tree clean</span><br><span class="line"></span><br><span class="line">albert@homepc MINGW64 /d/gitstart (dev)</span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">"test add"</span>&gt;&gt;README.md</span><br><span class="line"></span><br><span class="line">albert@homepc MINGW64 /d/gitstart (dev)</span><br><span class="line">$ git status</span><br><span class="line">On branch dev</span><br><span class="line">Your branch is up to date with <span class="string">'origin/dev'</span>.</span><br><span class="line"></span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">"git restore &lt;file&gt;..."</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line">        modified:   README.md</span><br><span class="line"></span><br><span class="line">no changes added to commit (use <span class="string">"git add"</span> and/or <span class="string">"git commit -a"</span>)</span><br><span class="line"></span><br><span class="line">albert@homepc MINGW64 /d/gitstart (dev)</span><br><span class="line">$ git add README.md</span><br><span class="line">warning: LF will be replaced by CRLF <span class="keyword">in</span> README.md.</span><br><span class="line">The file will have its original line endings <span class="keyword">in</span> your working directory</span><br><span class="line"></span><br><span class="line">albert@homepc MINGW64 /d/gitstart (dev)</span><br><span class="line">$ git status</span><br><span class="line">On branch dev</span><br><span class="line">Your branch is up to date with <span class="string">'origin/dev'</span>.</span><br><span class="line"></span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">"git restore --staged &lt;file&gt;..."</span> to unstage)</span><br><span class="line">        modified:   README.md</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">albert@homepc MINGW64 /d/gitstart (dev)</span><br><span class="line">$ git restore --staged README.md</span><br><span class="line"></span><br><span class="line">albert@homepc MINGW64 /d/gitstart (dev)</span><br><span class="line">$ git status</span><br><span class="line">On branch dev</span><br><span class="line">Your branch is up to date with <span class="string">'origin/dev'</span>.</span><br><span class="line"></span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">"git restore &lt;file&gt;..."</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line">        modified:   README.md</span><br><span class="line"></span><br><span class="line">no changes added to commit (use <span class="string">"git add"</span> and/or <span class="string">"git commit -a"</span>)</span><br></pre></td></tr></table></figure><h3 id="git-reset-3"><a href="#git-reset-3" class="headerlink" title="git reset"></a>git reset</h3><p><code>git reset</code> 命令如果加上 <code>--hard</code> 参数不能再加文件目录，只能将工作区全还原，如果不加默认参数为 <code>--mixed</code>，执行之后修改的文件状态变成了 <code>&lt;还原02&gt;</code> 中的情况。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">albert@homepc MINGW64 /d/gitstart (dev)</span><br><span class="line">$ git status</span><br><span class="line">On branch dev</span><br><span class="line">Your branch is up to date with <span class="string">'origin/dev'</span>.</span><br><span class="line"></span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">"git restore &lt;file&gt;..."</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line">        modified:   README.md</span><br><span class="line"></span><br><span class="line">no changes added to commit (use <span class="string">"git add"</span> and/or <span class="string">"git commit -a"</span>)</span><br><span class="line"></span><br><span class="line">albert@homepc MINGW64 /d/gitstart (dev)</span><br><span class="line">$ git add README.md</span><br><span class="line">warning: LF will be replaced by CRLF <span class="keyword">in</span> README.md.</span><br><span class="line">The file will have its original line endings <span class="keyword">in</span> your working directory</span><br><span class="line"></span><br><span class="line">albert@homepc MINGW64 /d/gitstart (dev)</span><br><span class="line">$ git status</span><br><span class="line">On branch dev</span><br><span class="line">Your branch is up to date with <span class="string">'origin/dev'</span>.</span><br><span class="line"></span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">"git restore --staged &lt;file&gt;..."</span> to unstage)</span><br><span class="line">        modified:   README.md</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">albert@homepc MINGW64 /d/gitstart (dev)</span><br><span class="line">$ git reset HEAD README.md</span><br><span class="line">Unstaged changes after reset:</span><br><span class="line">M       README.md</span><br><span class="line"></span><br><span class="line">albert@homepc MINGW64 /d/gitstart (dev)</span><br><span class="line">$ git status</span><br><span class="line">On branch dev</span><br><span class="line">Your branch is up to date with <span class="string">'origin/dev'</span>.</span><br><span class="line"></span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">"git restore &lt;file&gt;..."</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line">        modified:   README.md</span><br><span class="line"></span><br><span class="line">no changes added to commit (use <span class="string">"git add"</span> and/or <span class="string">"git commit -a"</span>)</span><br></pre></td></tr></table></figure><h2 id="还原04：版本库中的文件，修改或删除后执行了-git-add、git-commit-操作"><a href="#还原04：版本库中的文件，修改或删除后执行了-git-add、git-commit-操作" class="headerlink" title="还原04：版本库中的文件，修改或删除后执行了 git add、git commit 操作"></a>还原04：版本库中的文件，修改或删除后执行了 <code>git add</code>、<code>git commit</code> 操作</h2><p><code>git commit</code> 命令一旦执行了之后就形成了“历史”，我们叫做提交日志，要想回退就得有篡改历史的能力，很幸运 <code>Git</code> 给了我们这种能力，其实提交之后我们可以把本地文件反向修改，然后再提交一次，但是我们说的还原，一般都是只倒退，既然是错误的提交，我们就像把这段“历史”抹去，这时就要用到 <code>git reset HEAD^</code> 命令。</p><p>执行这个命令之后，刚刚的提交记录就被抹掉了，文件状态就回到了 <code>&lt;还原02&gt;</code> 的情况，如果加上参数 <code>--soft</code> 就会回到 <code>&lt;还原03&gt;</code> 的情况，如果加上参数 <code>--hard</code> ，就不能添加 <code>file_name</code> 这个文件名，然后整个工作区倒退到上一次修改之前，其他两种参数 <code>--mixed</code> 和 <code>--soft</code> 就可以指定添加名字。</p><p>这里的 <code>HEAD^</code> 表示最新版本的前一版，也就是倒数第二版本，可以类推，<code>HEAD^^</code> 表示倒数第三版本，<code>HEAD^^^</code> 表示倒数第四版本。</p><p>另外还有另一种写法 <code>HEAD~1</code> 表示最新版本的前一版，也就是倒数第二版本，<code>HEAD~2</code> 表示倒数第三版本，<code>HEAD~3</code> 表示倒数第四版本。</p><p>其中 <code>^</code> 和 <code>~</code> 的含义并不相同，涉及到合并分支的概念，有兴趣的话可以多了解下，这里就不展开了，继续还原当前这种情况，我们选择 <code>git reset HEAD^</code> 命令，先提交看下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">albert@homepc MINGW64 /d/gitstart (dev)</span><br><span class="line">$ git status</span><br><span class="line">On branch dev</span><br><span class="line">Your branch is up to date with <span class="string">'origin/dev'</span>.</span><br><span class="line"></span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">"git restore &lt;file&gt;..."</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line">        modified:   README.md</span><br><span class="line"></span><br><span class="line">no changes added to commit (use <span class="string">"git add"</span> and/or <span class="string">"git commit -a"</span>)</span><br><span class="line"></span><br><span class="line">albert@homepc MINGW64 /d/gitstart (dev)</span><br><span class="line">$ git add README.md</span><br><span class="line">warning: LF will be replaced by CRLF <span class="keyword">in</span> README.md.</span><br><span class="line">The file will have its original line endings <span class="keyword">in</span> your working directory</span><br><span class="line"></span><br><span class="line">albert@homepc MINGW64 /d/gitstart (dev)</span><br><span class="line">$ git commit -m<span class="string">"modify readme 1"</span></span><br><span class="line">[dev 8a40f22] modify readme 1</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line"></span><br><span class="line">albert@homepc MINGW64 /d/gitstart (dev)</span><br><span class="line">$ git status</span><br><span class="line">On branch dev</span><br><span class="line">Your branch is ahead of <span class="string">'origin/dev'</span> by 1 commit.</span><br><span class="line">  (use <span class="string">"git push"</span> to publish your <span class="built_in">local</span> commits)</span><br><span class="line"></span><br><span class="line">nothing to commit, working tree clean</span><br><span class="line"></span><br><span class="line">albert@homepc MINGW64 /d/gitstart (dev)</span><br><span class="line">$ git <span class="built_in">log</span> -2</span><br><span class="line">commit 8a40f229881da037ff99070fa205d7819ba9f51b (HEAD -&gt; dev)</span><br><span class="line">Author: albert &lt;qianxuan101@163.com&gt;</span><br><span class="line">Date:   Sat Mar 7 15:46:32 2020 +0800</span><br><span class="line"></span><br><span class="line">    modify readme 1</span><br><span class="line"></span><br><span class="line">commit 3226b63185a16398a02d5eaea47c95309ba49588 (origin/master, origin/dev, release, master)</span><br><span class="line">Author: albert &lt;qianxuan101@163.com&gt;</span><br><span class="line">Date:   Wed Feb 26 00:36:35 2020 +0800</span><br><span class="line"></span><br><span class="line">    add readme file</span><br></pre></td></tr></table></figure><p>然后再还原试试：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">albert@homepc MINGW64 /d/gitstart (dev)</span><br><span class="line">$ git reset HEAD^</span><br><span class="line">Unstaged changes after reset:</span><br><span class="line">M       README.md</span><br><span class="line"></span><br><span class="line">albert@homepc MINGW64 /d/gitstart (dev)</span><br><span class="line">$ git status</span><br><span class="line">On branch dev</span><br><span class="line">Your branch is up to date with <span class="string">'origin/dev'</span>.</span><br><span class="line"></span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">"git restore &lt;file&gt;..."</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line">        modified:   README.md</span><br><span class="line"></span><br><span class="line">no changes added to commit (use <span class="string">"git add"</span> and/or <span class="string">"git commit -a"</span>)</span><br><span class="line"></span><br><span class="line">albert@homepc MINGW64 /d/gitstart (dev)</span><br><span class="line">$ git <span class="built_in">log</span> -2</span><br><span class="line">commit 3226b63185a16398a02d5eaea47c95309ba49588 (HEAD -&gt; dev, origin/master, origin/dev, release, master)</span><br><span class="line">Author: albert &lt;qianxuan101@163.com&gt;</span><br><span class="line">Date:   Wed Feb 26 00:36:35 2020 +0800</span><br><span class="line"></span><br><span class="line">    add readme file</span><br></pre></td></tr></table></figure><p>怎么样，历史被我们抹除了，需要注意的是，如果想还原“历史”，那么 <code>git set</code> 命令后面不能跟文件名，也就是说必须整个还原到上一版本，否则就相当于将单个文件简单反向修改添加到暂存区，而之前对文件的修改保留在本地，文件的日志并没有回退，具体的文件状态还得你自己操作感受一下。</p><h2 id="还原05：版本库中的文件，修改或删除后执行了-git-add、git-commit、git-push-操作"><a href="#还原05：版本库中的文件，修改或删除后执行了-git-add、git-commit、git-push-操作" class="headerlink" title="还原05：版本库中的文件，修改或删除后执行了 git add、git commit、git push 操作"></a>还原05：版本库中的文件，修改或删除后执行了 <code>git add</code>、<code>git commit</code>、<code>git push</code> 操作</h2><p>这种情况就是还原远程仓库的日志记录了，实际上操作步骤先按照 <code>&lt;还原04&gt;</code> 来处理，然后将本地分支情况推送到远程分支即可。</p><p>我们先把刚才的修改提交，然后推送到远程分支，使用 <code>git status</code> 可以看到本地分支已经领先远程分支了(Your branch is ahead of ‘origin/dev’ by 1 commit.)， <code>git push</code> 操作之后两个分支同步了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">albert@homepc MINGW64 /d/gitstart (dev)</span><br><span class="line">$ git status</span><br><span class="line">On branch dev</span><br><span class="line">Your branch is ahead of <span class="string">'origin/dev'</span> by 1 commit.</span><br><span class="line">  (use <span class="string">"git push"</span> to publish your <span class="built_in">local</span> commits)</span><br><span class="line"></span><br><span class="line">nothing to commit, working tree clean</span><br><span class="line"></span><br><span class="line">albert@homepc MINGW64 /d/gitstart (dev)</span><br><span class="line">$ git <span class="built_in">log</span></span><br><span class="line">commit a5b6c18db71a0487f6316f5db4304a99984f2ab3 (HEAD -&gt; dev)</span><br><span class="line">Author: albert &lt;qianxuan101@163.com&gt;</span><br><span class="line">Date:   Sat Mar 7 15:51:56 2020 +0800</span><br><span class="line"></span><br><span class="line">    modify readme 1</span><br><span class="line"></span><br><span class="line">commit 3226b63185a16398a02d5eaea47c95309ba49588 (origin/master, origin/dev, release, master)</span><br><span class="line">Author: albert &lt;qianxuan101@163.com&gt;</span><br><span class="line">Date:   Wed Feb 26 00:36:35 2020 +0800</span><br><span class="line"></span><br><span class="line">    add readme file</span><br><span class="line"></span><br><span class="line">albert@homepc MINGW64 /d/gitstart (dev)</span><br><span class="line">$ git push</span><br><span class="line">Warning: Permanently added the ECDSA host key <span class="keyword">for</span> IP address <span class="string">'180.97.125.228'</span> to the list of known hosts.</span><br><span class="line">Enumerating objects: 5, <span class="keyword">done</span>.</span><br><span class="line">Counting objects: 100% (5/5), <span class="keyword">done</span>.</span><br><span class="line">Writing objects: 100% (3/3), 286 bytes | 286.00 KiB/s, <span class="keyword">done</span>.</span><br><span class="line">Total 3 (delta 0), reused 0 (delta 0)</span><br><span class="line">remote: Powered by GITEE.COM [GNK-3.8]</span><br><span class="line">To gitee.com:myname/gitstart.git</span><br><span class="line">   3226b63..a5b6c18  dev -&gt; dev</span><br></pre></td></tr></table></figure><p>这时通过远程仓库的管理软件，你可以看到远程分支已经有了最新的提交，然后我们可以参考 <code>&lt;还原04&gt;</code> 的情况，先将本地日志还原，再推送到远程仓库。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">albert@homepc MINGW64 /d/gitstart (dev)</span><br><span class="line">$ git reset HEAD^</span><br><span class="line">Unstaged changes after reset:</span><br><span class="line">M       README.md</span><br><span class="line"></span><br><span class="line">albert@homepc MINGW64 /d/gitstart (dev)</span><br><span class="line">$ git status</span><br><span class="line">On branch dev</span><br><span class="line">Your branch is behind <span class="string">'origin/dev'</span> by 1 commit, and can be fast-forwarded.</span><br><span class="line">  (use <span class="string">"git pull"</span> to update your <span class="built_in">local</span> branch)</span><br><span class="line"></span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">"git restore &lt;file&gt;..."</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line">        modified:   README.md</span><br><span class="line"></span><br><span class="line">no changes added to commit (use <span class="string">"git add"</span> and/or <span class="string">"git commit -a"</span>)</span><br><span class="line"></span><br><span class="line">albert@homepc MINGW64 /d/gitstart (dev)</span><br><span class="line">$ git <span class="built_in">log</span></span><br><span class="line">commit 3226b63185a16398a02d5eaea47c95309ba49588 (HEAD -&gt; dev, origin/master, release, master)</span><br><span class="line">Author: albert &lt;qianxuan101@163.com&gt;</span><br><span class="line">Date:   Wed Feb 26 00:36:35 2020 +0800</span><br><span class="line"></span><br><span class="line">    add readme file</span><br><span class="line"></span><br><span class="line">albert@homepc MINGW64 /d/gitstart (dev)</span><br><span class="line">$ git push</span><br><span class="line">To gitee.com:myname/gitstart.git</span><br><span class="line"> ! [rejected]        dev -&gt; dev (non-fast-forward)</span><br><span class="line">error: failed to push some refs to <span class="string">'git@gitee.com:myname/gitstart.git'</span></span><br><span class="line">hint: Updates were rejected because the tip of your current branch is behind</span><br><span class="line">hint: its remote counterpart. Integrate the remote changes (e.g.</span><br><span class="line">hint: <span class="string">'git pull ...'</span>) before pushing again.</span><br><span class="line">hint: See the <span class="string">'Note about fast-forwards'</span> <span class="keyword">in</span> <span class="string">'git push --help'</span> <span class="keyword">for</span> details.</span><br></pre></td></tr></table></figure><p>和想象的不太一样的，这种情况是远程仓库的记录领先，无法直接推送，此时可以添加 <code>-f</code> 参数，用本地提交记录覆盖远程分支记录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">albert@homepc MINGW64 /d/gitstart (dev)</span><br><span class="line">$ git push -f</span><br><span class="line">Total 0 (delta 0), reused 0 (delta 0)</span><br><span class="line">remote: Powered by GITEE.COM [GNK-3.8]</span><br><span class="line">To gitee.com:myname/gitstart.git</span><br><span class="line"> + a5b6c18...3226b63 dev -&gt; dev (forced update)</span><br></pre></td></tr></table></figure><p>这次再查询远程分支记录，发现也被回退了，目的达成。</p><h2 id="还原06：两次git-commit-之后产生两条日志，只还原第一次提交"><a href="#还原06：两次git-commit-之后产生两条日志，只还原第一次提交" class="headerlink" title="还原06：两次git commit 之后产生两条日志，只还原第一次提交"></a>还原06：两次<code>git commit</code> 之后产生两条日志，只还原第一次提交</h2><p>这种情况其实发生了两次修改和两次提交，和 <code>&lt;还原05&gt;</code> 情况不同的是要还原的提交不是最后一次，如果使用 <code>git reset</code> 命令必然将最后一次修改也还原了，虽然不能直接完成，但是给我们提供了解决问题的思路：</p><p>第一种方法：直接使用 <code>git reset HEAD^^</code> 命令还原两次提交，然后在工作区将文件按第二次修改再改一次进行提交，这种方法适用于想要抹除第一次提交历史的情况。</p><p>第二种方法：如果你不在意提交历史，只是想还原第一次修改，那么可以使用 <code>git revert HEAD^</code> 命令来反向修改那一次变化，修改之后会自动添加到暂存区，等待提交。</p><p>先来修改提交两次，产生两次记录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">albert@homepc MINGW64 /d/gitstart (dev)</span><br><span class="line">$ git status</span><br><span class="line">On branch dev</span><br><span class="line">Your branch is up to date with <span class="string">'origin/dev'</span>.</span><br><span class="line"></span><br><span class="line">nothing to commit, working tree clean</span><br><span class="line"></span><br><span class="line">albert@homepc MINGW64 /d/gitstart (dev)</span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">"m1"</span>&gt;&gt;README.md</span><br><span class="line"></span><br><span class="line">albert@homepc MINGW64 /d/gitstart (dev)</span><br><span class="line">$ git add README.md</span><br><span class="line">warning: LF will be replaced by CRLF <span class="keyword">in</span> README.md.</span><br><span class="line">The file will have its original line endings <span class="keyword">in</span> your working directory</span><br><span class="line"></span><br><span class="line">albert@homepc MINGW64 /d/gitstart (dev)</span><br><span class="line">$ git commit -m<span class="string">"modify README 1"</span></span><br><span class="line">[dev e570df1] modify README 1</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line"></span><br><span class="line">albert@homepc MINGW64 /d/gitstart (dev)</span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">"m2"</span>&gt;&gt;README.md</span><br><span class="line"></span><br><span class="line">albert@homepc MINGW64 /d/gitstart (dev)</span><br><span class="line">$ git add README.md</span><br><span class="line">warning: LF will be replaced by CRLF <span class="keyword">in</span> README.md.</span><br><span class="line">The file will have its original line endings <span class="keyword">in</span> your working directory</span><br><span class="line"></span><br><span class="line">albert@homepc MINGW64 /d/gitstart (dev)</span><br><span class="line">$ git commit -m<span class="string">"modify README 2"</span></span><br><span class="line">[dev 140547f] modify README 2</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line">gi</span><br><span class="line">albert@homepc MINGW64 /d/gitstart (dev)</span><br><span class="line">$ git <span class="built_in">log</span></span><br><span class="line">commit 140547f8d0b10d9a388beaf2ce522c38c878a839 (HEAD -&gt; dev)</span><br><span class="line">Author: albert &lt;qianxuan101@163.com&gt;</span><br><span class="line">Date:   Sat Mar 7 16:26:17 2020 +0800</span><br><span class="line"></span><br><span class="line">    modify README 2</span><br><span class="line"></span><br><span class="line">commit e570df134b39ee7424bc8c48c1067e72c3fb9637</span><br><span class="line">Author: albert &lt;qianxuan101@163.com&gt;</span><br><span class="line">Date:   Sat Mar 7 16:26:07 2020 +0800</span><br><span class="line"></span><br><span class="line">    modify README 1</span><br><span class="line"></span><br><span class="line">commit 3226b63185a16398a02d5eaea47c95309ba49588 (origin/master, origin/dev, release, master)</span><br><span class="line">Author: albert &lt;qianxuan101@163.com&gt;</span><br><span class="line">Date:   Wed Feb 26 00:36:35 2020 +0800</span><br><span class="line"></span><br><span class="line">    add readme file</span><br><span class="line"></span><br><span class="line">albert@homepc MINGW64 /d/gitstart (dev)</span><br><span class="line">$ cat README.md</span><br><span class="line">learn git branch <span class="built_in">command</span></span><br><span class="line">m1</span><br><span class="line">m2</span><br></pre></td></tr></table></figure><p>然后使用 <code>git revert HEAD^</code> 还原第一次修改记录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">albert@homepc MINGW64 /d/gitstart (dev)</span><br><span class="line">$ git revert HEAD^</span><br><span class="line">Auto-merging README.md</span><br><span class="line">CONFLICT (content): Merge conflict <span class="keyword">in</span> README.md</span><br><span class="line">error: could not revert e570df1... modify README 1</span><br><span class="line">hint: after resolving the conflicts, mark the corrected paths</span><br><span class="line">hint: with <span class="string">'git add &lt;paths&gt;'</span> or <span class="string">'git rm &lt;paths&gt;'</span></span><br><span class="line">hint: and commit the result with <span class="string">'git commit'</span></span><br><span class="line"></span><br><span class="line">albert@homepc MINGW64 /d/gitstart (dev|REVERTING)</span><br><span class="line">$ vi README.md</span><br><span class="line"></span><br><span class="line">albert@homepc MINGW64 /d/gitstart (dev|REVERTING)</span><br><span class="line">$ git add README.md</span><br><span class="line"></span><br><span class="line">albert@homepc MINGW64 /d/gitstart (dev|REVERTING)</span><br><span class="line">$ git commit</span><br><span class="line">[dev 6ae97d0] Revert <span class="string">"modify README 1"</span></span><br><span class="line"> 1 file changed, 1 deletion(-)</span><br><span class="line"></span><br><span class="line">albert@homepc MINGW64 /d/gitstart (dev)</span><br><span class="line">$ git <span class="built_in">log</span></span><br><span class="line">commit 6ae97d0e136abc1ed241854298037ca9d1c4460c (HEAD -&gt; dev)</span><br><span class="line">Author: albert &lt;qianxuan101@163.com&gt;</span><br><span class="line">Date:   Sat Mar 7 16:31:50 2020 +0800</span><br><span class="line"></span><br><span class="line">    Revert <span class="string">"modify README 1"</span></span><br><span class="line"></span><br><span class="line">    This reverts commit e570df134b39ee7424bc8c48c1067e72c3fb9637.</span><br><span class="line"></span><br><span class="line">commit 140547f8d0b10d9a388beaf2ce522c38c878a839</span><br><span class="line">Author: albert &lt;qianxuan101@163.com&gt;</span><br><span class="line">Date:   Sat Mar 7 16:26:17 2020 +0800</span><br><span class="line"></span><br><span class="line">    modify README 2</span><br><span class="line"></span><br><span class="line">commit e570df134b39ee7424bc8c48c1067e72c3fb9637</span><br><span class="line">Author: albert &lt;qianxuan101@163.com&gt;</span><br><span class="line">Date:   Sat Mar 7 16:26:07 2020 +0800</span><br><span class="line"></span><br><span class="line">    modify README 1</span><br><span class="line"></span><br><span class="line">commit 3226b63185a16398a02d5eaea47c95309ba49588 (origin/master, origin/dev, release, master)</span><br><span class="line">Author: albert &lt;qianxuan101@163.com&gt;</span><br><span class="line">Date:   Wed Feb 26 00:36:35 2020 +0800</span><br><span class="line"></span><br><span class="line">    add readme file</span><br></pre></td></tr></table></figure><p>因为修改了同一个文件，还原的时候还产生了冲突，解决冲突之后才提交，看日志发现这是一条新的记录，在实际操作的过程中可能会发生比这还要麻烦的场景，多练就好了。</p><h1 id="常用集合"><a href="#常用集合" class="headerlink" title="常用集合"></a>常用集合</h1><p>使用 <code>Git</code> 进行版本管理时，遇到的回退情况远不止这么多，这只是我目前常见的，之后遇到还会补充，每种情况我们其实不止有一种解决方式，接下来对于每种情况给一个我个人常用的处理方式，因为 <code>git checkout</code> 的作用被逐渐拆分成更具体的 <code>git switch</code> 和 <code>git restore</code>，我们尽量选择功能明确的命令：</p><ol><li>还原00：工作区中未加到暂存区和版本库的文件，还原今天所做的修改<ul><li>尝试下Ctrl+z吧，不行就找找自动保存的缓存文件，看看能不能找到之前版本</li></ul></li><li>还原01：工作区中未加到暂存区和版本库的文件，执行了 <code>git add</code> 操作<ul><li>直接使用 <code>git restore --staged file_name</code> 命令，如果版本不支持则使用 <code>git rm --cached file_name</code></li></ul></li><li>还原02：版本库中的文件，修改或删除后未执行 <code>git add</code> 操作<ul><li>直接使用 <code>git restore file_name</code> 命令，如果版本不支持则使用 <code>git checkout -- file_name</code></li></ul></li><li>还原03：版本库中的文件，修改或删除后执行了 <code>git add</code> 操作<ul><li>直接使用 <code>git restore --staged file_name</code> 命令，按 <code>&lt;还原02&gt;</code> 情况处理</li></ul></li><li>还原04：版本库中的文件，修改或删除后执行了 <code>git add</code>、<code>git commit</code> 操作<ul><li>直接使用 <code>git reset HEAD^</code> 命令，按 <code>&lt;还原02&gt;</code> 情况处理，或者使用 <code>git reset --soft HEAD^</code> 命令，按 <code>&lt;还原03&gt;</code> 情况处理</li></ul></li><li>还原05：版本库中的文件，修改或删除后执行了 <code>git add</code>、<code>git commit</code>、<code>git push</code> 操作<ul><li>先按照 <code>&lt;还原04&gt;</code> 情况处理，然后使用 <code>git push -f</code> 命令</li></ul></li><li>还原06：两次<code>git commit</code> 之后产生两条日志，只还原第一次提交<ul><li>使用 <code>git revert HEAD^</code> 命令，解决冲突后提交，revert 后面跟具体的 <code>commit id</code> 也可以。</li></ul></li></ol><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>参考这些具体的例子你会发现，很多操作选择在使用 <code>git status</code> 之后都有列举</li><li>所以说 <code>git status</code> 是一个可以提示你做选择的强大帮手，不知所措时可以试试它</li><li>Git 2.23版本之后学会用 <code>git switch</code> 和 <code>git restore</code> 命令，因为之前 <code>git checkout</code> 背负了太多了</li><li>最后放一幅图吧，只画了主要的，没有画出全部情况，否则会很乱，可以对照着练习一下</li></ul><p><img src="https://cdn.jsdelivr.net/gh/albertgithubhome/cdn/img/gitfilestate.png" alt="gitfilestate"></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;在 &lt;code&gt;Git&lt;/code&gt; 中没有真正的方法来做任何事情，这就是它的妙处！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;经常会听到别人说，如果时光可以倒流，我将会如何如何，可是现阶段的科技还达不到时光倒流的目的，或许在《三体》世界的四维裂缝里可以试一下。现实的世界中找不到后悔药，但是在代码的世界里却可以轻松实现，错误的BUG修改、砍掉的做了一半的功能都可以轻松回退，不留一丝痕迹，回滚之后一切又可以重新开始了。&lt;/p&gt;
    
    </summary>
    
      <category term="Git" scheme="http://AlbertGithubHome.github.io/blog/categories/Git/"/>
    
    
      <category term="git" scheme="http://AlbertGithubHome.github.io/blog/tags/git/"/>
    
      <category term="checkout" scheme="http://AlbertGithubHome.github.io/blog/tags/checkout/"/>
    
      <category term="reset" scheme="http://AlbertGithubHome.github.io/blog/tags/reset/"/>
    
      <category term="revert" scheme="http://AlbertGithubHome.github.io/blog/tags/revert/"/>
    
      <category term="restore" scheme="http://AlbertGithubHome.github.io/blog/tags/restore/"/>
    
  </entry>
  
  <entry>
    <title>git branch常用分支操作</title>
    <link href="http://AlbertGithubHome.github.io/blog/2020/02/25/git-branch%E5%B8%B8%E7%94%A8%E5%88%86%E6%94%AF%E6%93%8D%E4%BD%9C/"/>
    <id>http://AlbertGithubHome.github.io/blog/2020/02/25/git-branch常用分支操作/</id>
    <published>2020-02-25T15:20:55.000Z</published>
    <updated>2020-02-29T13:37:28.478Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近代码的版本控制工具由<code>SVN</code>换成了<code>Git</code>，只用管理个人项目常用的灵魂三步<code>git add</code>、<code>git commit</code>、<code>git push</code>看来是行不通了，之前虽然也一直在用 <code>git</code>，但是用法很有限，主要集中在前面提到的三步，所以为了更好的工作，我决定还是好好总结一下。</p><p>分支在<code>Git</code>的操作里有着很重要的地位，代表了不同的开发线路，创建一个分支，也就多了一个索引文件，相比于<code>SVN</code>分支拷贝全部文件来说来方便的多，所以<code>Git</code>使得按功能分支的开发模式变得非常简单，在开发过程中常常需要对分支进行操作。</p><a id="more"></a><h1 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h1><p>本来就几个分支，操作上也没有太麻烦，但是加入了远程仓库以后，事情变得复杂起来。有了远程仓库一般意味着代码开发需要多人合作了，这时候常常会产生冲突，分支合并时也变得不那么容易了。</p><p>远程仓库其实也很好理解，就是放在远处用来保存代码资源的一个仓库，其实和本地的代码库没有什么区别，这个远程仓库主要是为了把大家修改的代码都合并到一起，给大家提供一个统一的目标点。</p><p>远程仓库究竟有多远，常见的代码托管平台：<code>github</code>、<code>gitlab</code>、码云都可以提供远程仓库，如果你在月球上放置一台可以联网的代码仓库服务器，那么距离就是38.4万千米，但是远程仓库也可以很近，你也可以把本机电脑的D盘里的代码仓库作为E盘的代码仓库的远程仓库，或许远程仓库可能只和你隔了一个文件夹。</p><p>由于网络的原因，<code>github</code> 和 <code>gitlab</code> 访问常常很慢，所以为了做练习测试推送，我在码云创建了一个仓库 <code>gitstart</code>，它的地址大概是这个样子：<code>git@gitee.com:myname/gitstart.git</code>，创建的方法一搜一大把，上面提到的几个托管平台，在哪创建都可以，一定要记住地址，因为后面还要用到。</p><h1 id="建立联系"><a href="#建立联系" class="headerlink" title="建立联系"></a>建立联系</h1><h2 id="本地创建文件夹并进入"><a href="#本地创建文件夹并进入" class="headerlink" title="本地创建文件夹并进入"></a>本地创建文件夹并进入</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">albert@homepc MINGW64 /d</span><br><span class="line">$ mkdir gitstart</span><br><span class="line"></span><br><span class="line">albert@homepc MINGW64 /d</span><br><span class="line">$ <span class="built_in">cd</span> gitstart/</span><br><span class="line"></span><br><span class="line">albert@homepc MINGW64 /d/gitstart</span><br><span class="line">$</span><br></pre></td></tr></table></figure><p>这里的文件夹名字可以和远程仓库不同，但是为了看起来方便对应，还是取相同的名字好一点。</p><h2 id="初始化仓库"><a href="#初始化仓库" class="headerlink" title="初始化仓库"></a>初始化仓库</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">albert@homepc MINGW64 /d/gitstart</span><br><span class="line">$ git init</span><br><span class="line">Initialized empty Git repository <span class="keyword">in</span> D:/gitstart/.git/</span><br><span class="line"></span><br><span class="line">albert@homepc MINGW64 /d/gitstart (master)</span><br><span class="line">$</span><br></pre></td></tr></table></figure><h3 id="临时插播好奇心（不在流程中）"><a href="#临时插播好奇心（不在流程中）" class="headerlink" title="临时插播好奇心（不在流程中）"></a>临时插播好奇心（不在流程中）</h3><p>目前这个状态有点意思，初始化完之后，<code>(master)</code> 这个字符串表示当前是在 <code>master</code>分支，查一下日志看看：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">albert@homepc MINGW64 /d/gitstart (master)</span><br><span class="line">$ git <span class="built_in">log</span></span><br><span class="line">fatal: your current branch <span class="string">'master'</span> does not have any commits yet</span><br><span class="line"></span><br><span class="line">albert@homepc MINGW64 /d/gitstart (master)</span><br><span class="line">$</span><br></pre></td></tr></table></figure><p>提示也是正确的，说 <code>master</code>分支没有任何提交，但是我们查询一下分支看看：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">albert@homepc MINGW64 /d/gitstart (master)</span><br><span class="line">$ git branch -a</span><br><span class="line"></span><br><span class="line">albert@homepc MINGW64 /d/gitstart (master)</span><br><span class="line">$</span><br></pre></td></tr></table></figure><p>居然是空的，没有分支，查询 <code>.git\HEAD</code> 文件发现里面有一行 <code>ref: refs/heads/master</code>，说明当前分支时 <code>master</code>，但是为什么查询分支没有结果呢？</p><p>打开 <code>.git\refs\heads</code> 目录，发现这个文件夹下根本没有 <code>master</code>文件，其实想想也对，<code>Git</code> 中的分支其实对应着 <code>commit id</code>，现在什么都没有提交，master 也就找不到 <code>commit id</code>，所以就是有 <code>master</code> 文件，里面也不知道写什么。</p><h2 id="查询远程仓库"><a href="#查询远程仓库" class="headerlink" title="查询远程仓库"></a>查询远程仓库</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">albert@homepc MINGW64 /d/gitstart (master)</span><br><span class="line">$ git remote -v</span><br><span class="line"></span><br><span class="line">albert@homepc MINGW64 /d/gitstart (master)</span><br><span class="line">$</span><br></pre></td></tr></table></figure><p>依旧什么内容都没有，说明还没有和远程仓库建立联系。</p><h2 id="与远程仓库建立对应关系"><a href="#与远程仓库建立对应关系" class="headerlink" title="与远程仓库建立对应关系"></a>与远程仓库建立对应关系</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">albert@homepc MINGW64 /d/gitstart (master)</span><br><span class="line">$ git remote add origin git@gitee.com:myname/gitstart.git</span><br><span class="line"></span><br><span class="line">albert@homepc MINGW64 /d/gitstart (master)</span><br><span class="line">$ git remote -v</span><br><span class="line">origin  git@gitee.com:myname/gitstart.git (fetch)</span><br><span class="line">origin  git@gitee.com:myname/gitstart.git (push)</span><br><span class="line"></span><br><span class="line">albert@homepc MINGW64 /d/gitstart (master)</span><br><span class="line">$</span><br></pre></td></tr></table></figure><p>这一步需要注意，origin看起来就是一个远程仓库的别名，代表着 <code>git@gitee.com:myname/gitstart.git</code> 这个代码仓库，刚刚提到过，这个远程仓库也可以是本地的，所以你添加<code>git remote add origin d:/test</code> 也是可以的，就表明 <code>gitstart</code> 的远程仓库是本地的 <code>test</code> 仓库。</p><h1 id="第一个分支"><a href="#第一个分支" class="headerlink" title="第一个分支"></a>第一个分支</h1><p>刚刚说过，现在本地库的状态有些特殊，实际上刚刚在码云上创建的 <code>git@gitee.com:myname/gitstart.git</code> 库也很特殊，他们都没有真正的分支，这时只要我们成功提交一次，创建一个<code>commit id</code>，就相当于初始化了<code>master</code>分支。</p><h2 id="添加README文件"><a href="#添加README文件" class="headerlink" title="添加README文件"></a>添加README文件</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">albert@homepc MINGW64 /d/gitstart (master)</span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">"learn git branch command"</span>&gt;README.md</span><br><span class="line"></span><br><span class="line">albert@homepc MINGW64 /d/gitstart (master)</span><br><span class="line">$ git add README.md</span><br><span class="line">warning: LF will be replaced by CRLF <span class="keyword">in</span> README.md.</span><br><span class="line">The file will have its original line endings <span class="keyword">in</span> your working directory</span><br><span class="line"></span><br><span class="line">albert@homepc MINGW64 /d/gitstart (master)</span><br><span class="line">$ git commit -m<span class="string">"add readme file"</span></span><br><span class="line">[master (root-commit) 3226b63] add readme file</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line"> create mode 100644 README.md</span><br></pre></td></tr></table></figure><h2 id="查询当前分支"><a href="#查询当前分支" class="headerlink" title="查询当前分支"></a>查询当前分支</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">albert@homepc MINGW64 /d/gitstart (master)</span><br><span class="line">$ git branch -a</span><br><span class="line">* master</span><br></pre></td></tr></table></figure><p>这次可以是出现了，分支为 <code>master</code>，前面的 <code>*</code> 表示为当前分支。</p><h2 id="将分支推送到远程仓库"><a href="#将分支推送到远程仓库" class="headerlink" title="将分支推送到远程仓库"></a>将分支推送到远程仓库</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">albert@homepc MINGW64 /d/gitstart (master)</span><br><span class="line">$ git push -u origin master</span><br><span class="line">Enumerating objects: 3, <span class="keyword">done</span>.</span><br><span class="line">Counting objects: 100% (3/3), <span class="keyword">done</span>.</span><br><span class="line">Writing objects: 100% (3/3), 248 bytes | 248.00 KiB/s, <span class="keyword">done</span>.</span><br><span class="line">Total 3 (delta 0), reused 0 (delta 0)</span><br><span class="line">remote: Powered by GITEE.COM [GNK-3.8]</span><br><span class="line">To gitee.com:myname/gitstart.git</span><br><span class="line"> * [new branch]      master -&gt; master</span><br><span class="line">Branch <span class="string">'master'</span> <span class="built_in">set</span> up to track remote branch <span class="string">'master'</span> from <span class="string">'origin'</span>.</span><br></pre></td></tr></table></figure><p>至此，本地仓库和远程仓库就建立了联系，下面可以开始学习 <code>Git</code> 分支命令了。</p><h1 id="分支操作"><a href="#分支操作" class="headerlink" title="分支操作"></a>分支操作</h1><h2 id="新建分支"><a href="#新建分支" class="headerlink" title="新建分支"></a>新建分支</h2><p>新建分支可以使用 <code>git branch branch_name</code> 命令，以下就是一个创建名为 <code>release</code> 分支的命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">albert@homepc MINGW64 /d/gitstart (master)</span><br><span class="line">$ git branch release</span><br></pre></td></tr></table></figure><p>也可以使用 <code>git checkout -b branch_name</code> 来创建一个新分支，创建完会自动切换到新分支：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">albert@homepc MINGW64 /d/gitstart (master)</span><br><span class="line">$ git checkout -b dev</span><br><span class="line">Switched to a new branch <span class="string">'dev'</span></span><br><span class="line"></span><br><span class="line">albert@homepc MINGW64 /d/gitstart (dev)</span><br><span class="line">$</span><br></pre></td></tr></table></figure><h2 id="切换分支"><a href="#切换分支" class="headerlink" title="切换分支"></a>切换分支</h2><p>这是一个很奇怪的命令，命令格式为 <code>git checkout branch_name</code>，总感觉 <code>checkout</code> 子命令包揽了不属于自己的工作，如果在<code>git branch</code>的基础上加一个参数会更合理的一点，但这和切换分支的实际含义可能还有关系，切换分支其实就是修改HEAD文件中的 <code>commit id</code>，而没有真正的发生切换。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">albert@homepc MINGW64 /d/gitstart (dev)</span><br><span class="line">$ git checkout release</span><br><span class="line">Switched to branch <span class="string">'release'</span></span><br><span class="line"></span><br><span class="line">albert@homepc MINGW64 /d/gitstart (release)</span><br><span class="line">$ git checkout dev</span><br><span class="line">Switched to branch <span class="string">'dev'</span></span><br><span class="line"></span><br><span class="line">albert@homepc MINGW64 /d/gitstart (dev)</span><br><span class="line">$</span><br></pre></td></tr></table></figure><h2 id="查看本地分支"><a href="#查看本地分支" class="headerlink" title="查看本地分支"></a>查看本地分支</h2><p>像刚才我们创建的 <code>release</code> 分支和 <code>dev</code> 分支都是在本地创建的，这样的分支通过 <code>git branch</code> 命令就可以查看</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">albert@homepc MINGW64 /d/gitstart (dev)</span><br><span class="line">$ git branch</span><br><span class="line">* dev</span><br><span class="line">  master</span><br><span class="line">  release</span><br></pre></td></tr></table></figure><p>这样就列举了本地的所有分支，在当前分支名字 <code>dev</code> 前面哈还有一个 <code>*</code> 作为标记</p><h2 id="查看远程分支"><a href="#查看远程分支" class="headerlink" title="查看远程分支"></a>查看远程分支</h2><p>只要在上面的命令基础上加上 <code>-r</code> 参数就行了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">albert@homepc MINGW64 /d/gitstart (dev)</span><br><span class="line">$ git branch -r</span><br><span class="line">  origin/master</span><br></pre></td></tr></table></figure><p>查询到的分支只有 <code>origin/master</code> 一个，这个分支是一开始我们进行第一次提交产生 <code>master</code> 分支之后，通过 <code>git push -u origin master</code> 推送到远程仓库的，所以现在只有一个。</p><h2 id="查看所有分支"><a href="#查看所有分支" class="headerlink" title="查看所有分支"></a>查看所有分支</h2><p>所有分支包括本地分支和远程分支，将 <code>-r</code> 参数换成 <code>-a</code> 参数就可以了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">albert@homepc MINGW64 /d/gitstart (dev)</span><br><span class="line">$ git branch -a</span><br><span class="line">* dev</span><br><span class="line">  master</span><br><span class="line">  release</span><br><span class="line">  remotes/origin/master</span><br></pre></td></tr></table></figure><h2 id="将本地分支推送到远程仓库"><a href="#将本地分支推送到远程仓库" class="headerlink" title="将本地分支推送到远程仓库"></a>将本地分支推送到远程仓库</h2><p>其实之前已经操作过了，可以试着复习一下，<code>git push -u origin branch_name</code>，其实这是一个简写，<code>-u</code> 可以写成 <code>--set-upstream</code> 表示设置上游分支，其实就是和远程仓库的分支建立联系。</p><p><code>branch_name</code> 也是 <code>local_branch_name:remote_branch_name</code>的一种简写，冒号前表示本地分支，冒号后面表示远程分支，如果只写一个就表示两个分支名相同，远程仓库中如果没有这个分支就会新建一个。</p><p>也就是说 <code>git push -u origin dev</code> 和 <code>git push--set-upstream origin dev:dev</code> 是一样的，下面来试一下，然后查看一下分支：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">albert@homepc MINGW64 /d/gitstart (dev)</span><br><span class="line">$ git push -u origin dev</span><br><span class="line">Total 0 (delta 0), reused 0 (delta 0)</span><br><span class="line">remote: Powered by GITEE.COM [GNK-3.8]</span><br><span class="line">remote: Create a pull request <span class="keyword">for</span> <span class="string">'dev'</span> on Gitee by visiting:</span><br><span class="line">remote:     https://gitee.com/myname/gitstart/pull/new/myname:dev...myname:master</span><br><span class="line">To gitee.com:myname/gitstart.git</span><br><span class="line"> * [new branch]      dev -&gt; dev</span><br><span class="line">Branch <span class="string">'dev'</span> <span class="built_in">set</span> up to track remote branch <span class="string">'dev'</span> from <span class="string">'origin'</span>.</span><br><span class="line"></span><br><span class="line">albert@homepc MINGW64 /d/gitstart (dev)</span><br><span class="line">$ git branch -a</span><br><span class="line">* dev</span><br><span class="line">  master</span><br><span class="line">  release</span><br><span class="line">  remotes/origin/dev</span><br><span class="line">  remotes/origin/master</span><br></pre></td></tr></table></figure><p>冒号前后的米名字是不是一定相同呢？完全没有必要，我们可以让本地的 <code>release</code> 分支对应远程的 <code>master</code> 分支，只不过这样怪怪的，但是操作上完全可以的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">albert@homepc MINGW64 /d/gitstart (dev)</span><br><span class="line">$ git checkout release</span><br><span class="line">Switched to branch <span class="string">'release'</span></span><br><span class="line"></span><br><span class="line">albert@homepc MINGW64 /d/gitstart (release)</span><br><span class="line">$ git push -u origin release:master</span><br><span class="line">Everything up-to-date</span><br><span class="line">Branch <span class="string">'release'</span> <span class="built_in">set</span> up to track remote branch <span class="string">'master'</span> from <span class="string">'origin'</span>.</span><br></pre></td></tr></table></figure><h2 id="查看本地分支与远程分支对应关系"><a href="#查看本地分支与远程分支对应关系" class="headerlink" title="查看本地分支与远程分支对应关系"></a>查看本地分支与远程分支对应关系</h2><p>这个也是刚刚知道的，可以使用 <code>git branch -vv</code> 命令，注意是两个 <code>v</code>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">albert@homepc MINGW64 /d/gitstart (release)</span><br><span class="line">$ git branch -vv</span><br><span class="line">  dev     3226b63 [origin/dev] add readme file</span><br><span class="line">  master  3226b63 [origin/master] add readme file</span><br><span class="line">* release 3226b63 [origin/master] add readme file</span><br></pre></td></tr></table></figure><p>执行这个命令之后可以看出，本地的 <code>master</code> 和 <code>release</code> 分支都对应着远程的 <code>master</code> 分支</p><h2 id="删除本地分支"><a href="#删除本地分支" class="headerlink" title="删除本地分支"></a>删除本地分支</h2><p>我们先复习一下新建分支，然后把它推送到远程仓库，再使用 <code>git branch -d branch_name</code> 命令进行删除</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">albert@homepc MINGW64 /d/gitstart (release)</span><br><span class="line">$ git checkout -b feature_test</span><br><span class="line">Switched to a new branch <span class="string">'feature_test'</span></span><br><span class="line"></span><br><span class="line">albert@homepc MINGW64 /d/gitstart (feature_test)</span><br><span class="line">$ git push origin feature_test</span><br><span class="line">Total 0 (delta 0), reused 0 (delta 0)</span><br><span class="line"> remote: Powered by GITEE.COM [GNK-3.8]</span><br><span class="line">remote: Create a pull request <span class="keyword">for</span> <span class="string">'feature_test'</span> on Gitee by visiting:</span><br><span class="line">remote:     https://gitee.com/myname/gitstart/pull/new/myname:feature_test...myname:master</span><br><span class="line">To gitee.com:myname/gitstart.git</span><br><span class="line"> * [new branch]      feature_test -&gt; feature_test</span><br><span class="line"></span><br><span class="line">albert@homepc MINGW64 /d/gitstart (feature_test)</span><br><span class="line">$ git branch -a</span><br><span class="line">  dev</span><br><span class="line">* feature_test</span><br><span class="line">  master</span><br><span class="line">  release</span><br><span class="line">  remotes/origin/dev</span><br><span class="line">  remotes/origin/feature_test</span><br><span class="line">  remotes/origin/master</span><br></pre></td></tr></table></figure><p>开始删除分支，删除之前记得切换到别的分支，否则删除不成功</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">albert@homepc MINGW64 /d/gitstart (feature_test)</span><br><span class="line">$ git checkout dev</span><br><span class="line">Switched to branch <span class="string">'dev'</span></span><br><span class="line">Your branch is up to date with <span class="string">'origin/dev'</span>.</span><br><span class="line"></span><br><span class="line">albert@homepc MINGW64 /d/gitstart (dev)</span><br><span class="line">$ git branch -d feature_test</span><br><span class="line">Deleted branch feature_test (was 3226b63).</span><br><span class="line"></span><br><span class="line">albert@homepc MINGW64 /d/gitstart (dev)</span><br><span class="line">$ git branch -a</span><br><span class="line">* dev</span><br><span class="line">  master</span><br><span class="line">  release</span><br><span class="line">  remotes/origin/dev</span><br><span class="line">  remotes/origin/feature_test</span><br><span class="line">  remotes/origin/master</span><br></pre></td></tr></table></figure><h2 id="删除远程分支"><a href="#删除远程分支" class="headerlink" title="删除远程分支"></a>删除远程分支</h2><p>通过上面的操作我们发现只删除了本地的分支，远程的分支还在，要想删除远程分支，需要使用 <code>git push origin --delete branch_name</code> 命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">albert@homepc MINGW64 /d/gitstart (dev)</span><br><span class="line">$ git push origin --delete feature_test</span><br><span class="line">remote: Powered by GITEE.COM [GNK-3.8]</span><br><span class="line">To gitee.com:myname/gitstart.git</span><br><span class="line"> - [deleted]         feature_test</span><br><span class="line"></span><br><span class="line">albert@homepc MINGW64 /d/gitstart (dev)</span><br><span class="line">$ git branch -a</span><br><span class="line">* dev</span><br><span class="line">  master</span><br><span class="line">  release</span><br><span class="line">  remotes/origin/dev</span><br><span class="line">  remotes/origin/master</span><br></pre></td></tr></table></figure><p>这次再查看时发现远程分支也被删掉了。</p><h2 id="获取远程主分支到本地"><a href="#获取远程主分支到本地" class="headerlink" title="获取远程主分支到本地"></a>获取远程主分支到本地</h2><p>其实 <code>Git</code> 的克隆命令默认就是把远程仓库的主分支下载到本地，我们可以使用 <code>git clone 远程地址 本地文件夹</code> 命令来克隆一个仓库，如果本地文件夹省略，则默认新建一个与仓库名相同的文件夹：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">albert@homepc MINGW64 /d</span><br><span class="line">$ git <span class="built_in">clone</span> https://gitee.com/myname/gitstart.git gitstartcopy</span><br><span class="line">Cloning into <span class="string">'gitstartcopy'</span>...</span><br><span class="line">remote: Enumerating objects: 3, <span class="keyword">done</span>.</span><br><span class="line">remote: Counting objects: 100% (3/3), <span class="keyword">done</span>.</span><br><span class="line">remote: Total 3 (delta 0), reused 0 (delta 0)</span><br><span class="line">Unpacking objects: 100% (3/3), <span class="keyword">done</span>.</span><br><span class="line"></span><br><span class="line">albert@homepc MINGW64 /d</span><br><span class="line">$ <span class="built_in">cd</span> gitstartcopy/</span><br><span class="line"></span><br><span class="line">albert@homepc MINGW64 /d/gitstartcopy (master)</span><br><span class="line">$ git branch -a</span><br><span class="line">* master</span><br><span class="line">  remotes/origin/HEAD -&gt; origin/master</span><br><span class="line">  remotes/origin/dev</span><br><span class="line">  remotes/origin/master</span><br></pre></td></tr></table></figure><h2 id="获取远程其他分支到本地"><a href="#获取远程其他分支到本地" class="headerlink" title="获取远程其他分支到本地"></a>获取远程其他分支到本地</h2><p>从上面命令执行后的结果来看，当前本地仓库中只有 <code>master</code> 分支，其他的分支都是在远程仓库上，这时可以用 <code>git checkout branch_name</code> 命令来下载远程分支：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">albert@homepc MINGW64 /d/gitstartcopy (master)</span><br><span class="line">$ git checkout dev</span><br><span class="line">Switched to a new branch <span class="string">'dev'</span></span><br><span class="line">Branch <span class="string">'dev'</span> <span class="built_in">set</span> up to track remote branch <span class="string">'dev'</span> from <span class="string">'origin'</span>.</span><br><span class="line"></span><br><span class="line">albert@homepc MINGW64 /d/gitstartcopy (dev)</span><br><span class="line">$ git branch -a</span><br><span class="line">* dev</span><br><span class="line">  master</span><br><span class="line">  remotes/origin/HEAD -&gt; origin/master</span><br><span class="line">  remotes/origin/dev</span><br><span class="line">  remotes/origin/master</span><br><span class="line"></span><br><span class="line">albert@homepc MINGW64 /d/gitstartcopy (dev)</span><br><span class="line">$ git branch -vv</span><br><span class="line">* dev    3226b63 [origin/dev] add readme file</span><br><span class="line">  master 3226b63 [origin/master] add readme file</span><br></pre></td></tr></table></figure><p>看到这里可能会疑惑了，<code>git checkout branch_name</code> 不是切换分支的命令吗？实际上当 <code>branch_name</code> 分支在本地不存在而远程仓库存在时，这个命令与 <code>git checkout -b &lt;branch&gt; --track &lt;remote&gt;/&lt;branch&gt;</code> 含义相同，会在本地新建一个分支，并与远程分支建立联系。</p><h1 id="常用集合"><a href="#常用集合" class="headerlink" title="常用集合"></a>常用集合</h1><ul><li>新建分支：<code>git checkout -b branch_name</code></li><li>切换分支：<code>git checkout branch_name</code></li><li>查看分支：<code>git branch -a</code></li><li>删除分支：<code>git branch -d branch_name</code></li><li>推送分支到远程：<code>git push origin branch_name</code></li><li>删除远程的分支：<code>git push origin --delete branch_name</code></li><li>拉取远程分支到本地：<code>git checkout branch_name</code></li><li>查询分支的对应关系：<code>git branch -vv</code></li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>以上这些命令都是在本地测试过的，可能考虑的不太全面，不过没关系，以后的分支操作还会补充到这里。</li><li>这些命令在有些特殊的情况下使用可能会遇到问题，如果大家发现了问题请及时指出，我会尽快修改的。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;最近代码的版本控制工具由&lt;code&gt;SVN&lt;/code&gt;换成了&lt;code&gt;Git&lt;/code&gt;，只用管理个人项目常用的灵魂三步&lt;code&gt;git add&lt;/code&gt;、&lt;code&gt;git commit&lt;/code&gt;、&lt;code&gt;git push&lt;/code&gt;看来是行不通了，之前虽然也一直在用 &lt;code&gt;git&lt;/code&gt;，但是用法很有限，主要集中在前面提到的三步，所以为了更好的工作，我决定还是好好总结一下。&lt;/p&gt;
&lt;p&gt;分支在&lt;code&gt;Git&lt;/code&gt;的操作里有着很重要的地位，代表了不同的开发线路，创建一个分支，也就多了一个索引文件，相比于&lt;code&gt;SVN&lt;/code&gt;分支拷贝全部文件来说来方便的多，所以&lt;code&gt;Git&lt;/code&gt;使得按功能分支的开发模式变得非常简单，在开发过程中常常需要对分支进行操作。&lt;/p&gt;
    
    </summary>
    
      <category term="Git" scheme="http://AlbertGithubHome.github.io/blog/categories/Git/"/>
    
    
      <category term="git" scheme="http://AlbertGithubHome.github.io/blog/tags/git/"/>
    
      <category term="branch" scheme="http://AlbertGithubHome.github.io/blog/tags/branch/"/>
    
      <category term="checkout" scheme="http://AlbertGithubHome.github.io/blog/tags/checkout/"/>
    
      <category term="push" scheme="http://AlbertGithubHome.github.io/blog/tags/push/"/>
    
      <category term="remote" scheme="http://AlbertGithubHome.github.io/blog/tags/remote/"/>
    
  </entry>
  
</feed>
