<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Albert World</title>
  <icon>https://www.gravatar.com/avatar/8ccc6291d5bfd34e7aaf601c4ebec7e1</icon>
  
  <link href="/blog/atom.xml" rel="self"/>
  
  <link href="http://AlbertGithubHome.github.io/blog/"/>
  <updated>2020-11-15T15:59:20.861Z</updated>
  <id>http://AlbertGithubHome.github.io/blog/</id>
  
  <author>
    <name>Albert Shi</name>
    <email>347070901@qq.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>学习cmake从成功编译一个小程序开始</title>
    <link href="http://AlbertGithubHome.github.io/blog/2020/11/14/%E5%AD%A6%E4%B9%A0cmake%E4%BB%8E%E6%88%90%E5%8A%9F%E7%BC%96%E8%AF%91%E4%B8%80%E4%B8%AA%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%A7%8B/"/>
    <id>http://AlbertGithubHome.github.io/blog/2020/11/14/学习cmake从成功编译一个小程序开始/</id>
    <published>2020-11-14T15:59:17.000Z</published>
    <updated>2020-11-15T15:59:20.861Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在 Windows上开发我使用最多的IDE还是 Visual Studio，编写、编译一条龙服务，导致了不少编译流程知识的缺失，这种大型的IDE确实好用，诸多配置通过在界面上勾选一下就可以了，但是在编译细节的掌握上还是漏掉了一些知识。</p><p>在 linux 开发环境下通常会使用 gcc 或者 g++ 进行编译，可是编译选项有点多，当工程非常大的时候需要写的编译参数太多了，这时可以使用make命令来帮助我们编译 C++ 程序，编译时依赖一些规则，这些规则就写在一个叫 Makefile 的文件中。</p><p>后来发现写 Makefile 还是太麻烦了，这个文件也相当大。于是“懒惰”的程序员们又开发出了各种各样的工具用来生成 Makefile 文件，我使用过的目前就只有 <code>automake</code> 和 <code>cmake</code>。</p><h1 id="生成Makefile"><a href="#生成Makefile" class="headerlink" title="生成Makefile"></a>生成Makefile</h1><p>之前使用的生成 Makefile 文件的工具是 <code>automake</code>，被称为是“八股文”一样的操作，每次操作都是固定的几个步骤，比如每次都要运行 <code>autoscan</code>、<code>aclocal</code>、<code>autoconf</code>、<code>automake</code>、<code>./confiugre</code>等命令，需要个人发挥的地方并不多，之前使用的时候也不是完全从0开始一点点写的，往往是写一个项目模板之后，对照着在Makefile.am文件中修改几个参数就好了。</p><p>现在新的工作内容中使用 cmake 来生成 Makefile，这个 cmake 之前还确实接触过一些，大概是2012年的时候，那时在编译 OpenCV 库还有增强现实插件的时候用过几次，当时感觉安装起来太麻烦了，对那个红绿蓝的图标记忆犹新，感觉和当时的新闻联播的图标有些亲戚关系。</p><p>其实当时根本分不清什么是编译器，什么是 Makefile，对于各种库文件的编译完全是按照文档来操作，现在回过头来看看 cmake 生成 Makefile 还是比较简单的，最起码要比 automake 省了很多步骤，只要编写一个 CMakeLists.txt 文件就好了。</p><h1 id="编写CMakeLists-txt生成Makefile"><a href="#编写CMakeLists-txt生成Makefile" class="headerlink" title="编写CMakeLists.txt生成Makefile"></a>编写CMakeLists.txt生成Makefile</h1><p>为了练习使用编写CMakeLists.txt生成Makefile，进而编译C++项目，我们可以从头来实现一个小例子，目标是编写一个计算加法的静态库和一个计算减法静态库，然后实现一个测试工程来使用这两个函数库，整个工程使用 cmake 来生成 Makefile，然后使用 make 命令完成编译。</p><h2 id="实现简单的代码文件"><a href="#实现简单的代码文件" class="headerlink" title="实现简单的代码文件"></a>实现简单的代码文件</h2><p>加法和减法都是常用的简单计算，用来举例子很容易理解，接下来展示要用到的几个文件内容，每个文件只有几行，只为了说明问题，文件内容如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//myadd.h</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//myadd.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"myadd.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//mysub.h</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sub</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//mysub.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mysub.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sub</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a - b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//test.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"myadd.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mysub.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"happy birthday!"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"519 + 1 = "</span> &lt;&lt; add(<span class="number">519</span>, <span class="number">1</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"1320 - 6 = "</span> &lt;&lt; sub(<span class="number">1320</span>, <span class="number">6</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用常规方法编译"><a href="#使用常规方法编译" class="headerlink" title="使用常规方法编译"></a>使用常规方法编译</h2><p>首先使用最简单 g++ 命令来编译这个样例程序：</p><ol><li>查看目录下文件</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:testcmake$ ls</span><br><span class="line">myadd.cpp  myadd.h  mysub.cpp  mysub.h  test.cpp</span><br></pre></td></tr></table></figure><ol><li>将 <code>myadd.h</code> 和 <code>myadd.cpp</code> 编译成静态库 <code>libmyadd.a</code></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:testcmake$ g++ -c myadd.cpp</span><br><span class="line">albert@home-pc:testcmake$ ar crv libmyadd.a myadd.o</span><br><span class="line">a - myadd.o</span><br><span class="line">albert@home-pc:testcmake$ ls</span><br><span class="line">libmyadd.a  myadd.cpp  myadd.h  myadd.o  mysub.cpp  mysub.h  test.cpp</span><br></pre></td></tr></table></figure><ol><li>将 <code>mysub.h</code> 和 <code>mysub.cpp</code> 编译成静态库 <code>libmysub.so</code></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:testcmake$ g++ -c mysub.cpp</span><br><span class="line">albert@home-pc:testcmake$ g++ -shared -fPIC -o libmysub.so mysub.o</span><br><span class="line">albert@home-pc:testcmake$ ls</span><br><span class="line">libmyadd.a  libmysub.so  myadd.cpp  myadd.h  myadd.o  mysub.cpp  mysub.h  mysub.o  test.cpp</span><br></pre></td></tr></table></figure><ol><li>编译链接静态库 <code>libmyadd.a</code>、动态库 <code>libmysub.so</code> 和测试文件生成可执行程序 <code>test</code></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:testcmake$ g++ test.cpp libmyadd.a -L. -lmysub -o <span class="built_in">test</span> -Wl,-rpath=.</span><br><span class="line">albert@home-pc:testcmake$ ls</span><br><span class="line">libmyadd.a  libmysub.so  myadd.cpp  myadd.h  myadd.o  mysub.cpp  mysub.h  mysub.o  <span class="built_in">test</span>  test.cpp</span><br></pre></td></tr></table></figure><ol><li>运行查看结果，成功计算表达式的值</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:testcmake$ ./<span class="built_in">test</span></span><br><span class="line">happy birthday!</span><br><span class="line">519 + 1 = 520</span><br><span class="line">1320 - 6 = 1314</span><br></pre></td></tr></table></figure><h2 id="使用cmake方式"><a href="#使用cmake方式" class="headerlink" title="使用cmake方式"></a>使用cmake方式</h2><p>上面展示了最原始的编译方法，每次都要敲这些命令，接下来编写一个 CMakeLists 文件，使用 cmake 生成Makefile，以后只要运行 make 命令就可以完成编译了。</p><p>调整一下目录结构如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:testcmake$ tree</span><br><span class="line">.</span><br><span class="line">|-- myadd</span><br><span class="line">|   |-- myadd.cpp</span><br><span class="line">|   `-- myadd.h</span><br><span class="line">|-- mysub</span><br><span class="line">|   |-- mysub.cpp</span><br><span class="line">|   `-- mysub.h</span><br><span class="line">`-- test.cpp</span><br></pre></td></tr></table></figure><ol><li>进入 myadd 目录新建 CMakeLists.txt 编写内容如下：</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">aux_source_directory(. SRC_LIST)        <span class="comment">#将此目录的源文件集合设置为变量SRC_LIST</span></span><br><span class="line">add_library(myadd STATIC <span class="variable">$&#123;SRC_LIST&#125;</span>)   <span class="comment">#库的名称，库的类型，静态库的源文件列表</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span>(LIBRARY_OUTPUT_PATH <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/lib)  <span class="comment">#库的输出路径为根目录下的lib文件夹</span></span><br></pre></td></tr></table></figure><ol><li>进入 mysub 目录新建 CMakeLists.txt 编写内容如下：</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">aux_source_directory(. SRC_LIST)        <span class="comment">#将此目录的源文件集合设置为变量SRC_LIST</span></span><br><span class="line">add_library(mysub SHARED <span class="variable">$&#123;SRC_LIST&#125;</span>)   <span class="comment">#库的名称，库的类型，动态库的源文件列表</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span>(LIBRARY_OUTPUT_PATH <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/lib)  <span class="comment">#库的输出路径为根目录下的lib文件夹</span></span><br></pre></td></tr></table></figure><ol><li>在工程主目录下新建 CMakeLists.txt 编写内容如下：</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 指定cmake版本</span></span><br><span class="line">cmake_minimum_required(VERSION 3.5)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定项目的名称，一般和项目的文件夹名称对应</span></span><br><span class="line">project(testcmake)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定子目录</span></span><br><span class="line">add_subdirectory(myadd)</span><br><span class="line">add_subdirectory(mysub)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加c++ 11标准支持</span></span><br><span class="line"><span class="built_in">set</span>(CMAKE_CXX_FLAGS <span class="string">"-std=c++11"</span> )</span><br><span class="line"></span><br><span class="line"><span class="comment"># 特殊宏，之前编译mysqlcppconn8用到过</span></span><br><span class="line">add_definitions(-DGLIBCXX_USE_CXX11_ABI)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 头文件目录</span></span><br><span class="line">include_directories(myadd mysub)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 源文件目录</span></span><br><span class="line">aux_source_directory(. DIR_SRCS)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置环境变量，编译用到的源文件全部都要放到这</span></span><br><span class="line"><span class="built_in">set</span>(TEST_MATH <span class="variable">$&#123;DIR_SRCS&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 库文件目录</span></span><br><span class="line">link_directories(lib)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加要编译的可执行文件</span></span><br><span class="line">add_executable(<span class="variable">$&#123;PROJECT_NAME&#125;</span> <span class="variable">$&#123;TEST_MATH&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加可执行文件所需要的库</span></span><br><span class="line">target_link_libraries(<span class="variable">$&#123;PROJECT_NAME&#125;</span> myadd)</span><br><span class="line">target_link_libraries(<span class="variable">$&#123;PROJECT_NAME&#125;</span> mysub)</span><br></pre></td></tr></table></figure><ol><li>新建build目录和lib目录，整个工程目录关系如下：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:testcmake$ tree</span><br><span class="line">.</span><br><span class="line">|-- CMakeLists.txt</span><br><span class="line">|-- build</span><br><span class="line">|-- lib</span><br><span class="line">|-- myadd</span><br><span class="line">|   |-- CMakeLists.txt</span><br><span class="line">|   |-- myadd.cpp</span><br><span class="line">|   `-- myadd.h</span><br><span class="line">|-- mysub</span><br><span class="line">|   |-- CMakeLists.txt</span><br><span class="line">|   |-- mysub.cpp</span><br><span class="line">|   `-- mysub.h</span><br><span class="line">`-- test.cpp</span><br><span class="line"></span><br><span class="line">4 directories, 8 files</span><br></pre></td></tr></table></figure><ol><li>进入 build 目录下依次运行 <code>cmake ..</code> 和 <code>make</code> 命令</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:testcmake/build$ cmake ..</span><br><span class="line">-- The C compiler identification is GNU 5.4.0</span><br><span class="line">-- The CXX compiler identification is GNU 5.4.0</span><br><span class="line">-- Check <span class="keyword">for</span> working C compiler: /usr/bin/cc</span><br><span class="line">-- Check <span class="keyword">for</span> working C compiler: /usr/bin/cc -- works</span><br><span class="line">-- Detecting C compiler ABI info</span><br><span class="line">-- Detecting C compiler ABI info - <span class="keyword">done</span></span><br><span class="line">-- Detecting C compile features</span><br><span class="line">-- Detecting C compile features - <span class="keyword">done</span></span><br><span class="line">-- Check <span class="keyword">for</span> working CXX compiler: /usr/bin/c++</span><br><span class="line">-- Check <span class="keyword">for</span> working CXX compiler: /usr/bin/c++ -- works</span><br><span class="line">-- Detecting CXX compiler ABI info</span><br><span class="line">-- Detecting CXX compiler ABI info - <span class="keyword">done</span></span><br><span class="line">-- Detecting CXX compile features</span><br><span class="line">-- Detecting CXX compile features - <span class="keyword">done</span></span><br><span class="line">-- Configuring <span class="keyword">done</span></span><br><span class="line">-- Generating <span class="keyword">done</span></span><br><span class="line">-- Build files have been written to: testcmake/build</span><br><span class="line">albert@home-pc:testcmake/build$ make</span><br><span class="line">Scanning dependencies of target mysub</span><br><span class="line">[ 16%] Building CXX object mysub/CMakeFiles/mysub.dir/mysub.cpp.o</span><br><span class="line">[ 33%] Linking CXX shared library ../../lib/libmysub.so</span><br><span class="line">[ 33%] Built target mysub</span><br><span class="line">Scanning dependencies of target myadd</span><br><span class="line">[ 50%] Building CXX object myadd/CMakeFiles/myadd.dir/myadd.cpp.o</span><br><span class="line">[ 66%] Linking CXX static library ../../lib/libmyadd.a</span><br><span class="line">[ 66%] Built target myadd</span><br><span class="line">Scanning dependencies of target testcmake</span><br><span class="line">[ 83%] Building CXX object CMakeFiles/testcmake.dir/test.cpp.o</span><br><span class="line">[100%] Linking CXX executable testcmake</span><br><span class="line">[100%] Built target testcmake</span><br><span class="line">albert@home-pc:testcmake/build$ ./testcmake</span><br><span class="line">happy birthday!</span><br><span class="line">519 + 1 = 520</span><br><span class="line">1320 - 6 = 1314</span><br><span class="line">albert@home-pc:testcmake/build$</span><br></pre></td></tr></table></figure><p>至此，使用cmake方式编译工程的例子就写完了。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol><li><code>cmake</code> 和 <code>automake</code> 本身不提供编译功能，只是可以按照编写的 CMakeLists.txt 文件生成 Makefile</li><li><code>make</code> 可以根据 Makefile 文件调用 gcc/g++ 命令对源代码进行编译工作</li><li><code>-Wl,-rpath=.</code> 这个选项可以指定可执行文件查找动态库的路径，感觉比 <code>export LD_LIBRARY_PATH</code> 要方便一点</li><li><code>-DGLIBCXX_USE_CXX11_ABI</code> 这个宏可坑了我不少时间，编译使用libmysqlcppconn8的时候，如果不禁用会报编译错误</li></ol><hr><center><a href="https://blog.csdn.net/albertsh/article/details/109553923" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>有你，真好~</p><p>2020-11-15 23:55:35</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;在 Windows上开发我使用最多的IDE还是 Visual Studio，编写、编译一条龙服务，导致了不少编译流程知识的缺失，这种大型的I
      
    
    </summary>
    
      <category term="linux" scheme="http://AlbertGithubHome.github.io/blog/categories/linux/"/>
    
    
      <category term="C++" scheme="http://AlbertGithubHome.github.io/blog/tags/C/"/>
    
      <category term="编译" scheme="http://AlbertGithubHome.github.io/blog/tags/%E7%BC%96%E8%AF%91/"/>
    
      <category term="linux" scheme="http://AlbertGithubHome.github.io/blog/tags/linux/"/>
    
      <category term="cmake" scheme="http://AlbertGithubHome.github.io/blog/tags/cmake/"/>
    
  </entry>
  
  <entry>
    <title>linux环境下sed命令的基础用法</title>
    <link href="http://AlbertGithubHome.github.io/blog/2020/11/07/linux%E7%8E%AF%E5%A2%83%E4%B8%8Bsed%E5%91%BD%E4%BB%A4%E7%9A%84%E5%9F%BA%E7%A1%80%E7%94%A8%E6%B3%95/"/>
    <id>http://AlbertGithubHome.github.io/blog/2020/11/07/linux环境下sed命令的基础用法/</id>
    <published>2020-11-07T06:37:04.000Z</published>
    <updated>2020-11-07T15:11:06.471Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>每次看到sed这个词就想起“种子”，心里明知道是把它和seed弄混了，但是先入为主的思想怕是改不过来了，不过现在还好，虽然把第一印象的意思弄错了，但还是很快能反应过来这是一个很“厉害”的linux命令，也有一些网友评论到，每次看到这个命令就双腿发抖，我虽然没抖，但是谈到这个命令还是有些挠头，心里有些发怵。</p><p>一味地逃避困难是不可取的，虽然心里感觉这是个很难的命令，但是今天还是要硬着头皮学一下，边学边记录，易于下次复习，那些打败不了我的困难终将使我更加强大。</p><h1 id="sed功能"><a href="#sed功能" class="headerlink" title="sed功能"></a>sed功能</h1><p>其实sed并不是一个单词，而是 stream editor 的缩写，本意为面向字符流的编辑器，说白了sed就是用来编辑文件的命令，编辑文件是我们每天经常做的工作，但是如果每天的编辑工作都类似，我们就要考虑使用sed工具来提高工作效率了，比如说把今天新增的100个文件的第一行都加上版本信息，虽然手动编辑也能做，但是你想体验一下敲个命令瞬间搞定这件事情的快感吗，我们来学习sed命令吧？</p><h2 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed [OPTION]... &#123;script-only-if-no-other-script&#125; [input-file]</span><br></pre></td></tr></table></figure><p>sed 的选项不是太多，最常用的有下面两种形式：</p><ul><li><code>sed -e &#39;sed命令脚本&#39; input-file</code></li><li><code>sed -f &#39;sed命令脚本文件&#39; input-file</code></li></ul><h2 id="命令选项"><a href="#命令选项" class="headerlink" title="命令选项"></a>命令选项</h2><ul><li><strong>-e</strong> ：命令行模式，选项后直接跟sed编辑脚本，在只有一组脚本的情况下可以省略</li><li><strong>-f</strong> ：脚本文件模式，选项后跟写有sed编辑脚本的文件名，运行后会执行脚本文件内的编辑动作</li><li><strong>-i</strong> ：直接修改文件内容，如果不加这个选项是不修改源文件的，只将修改后的文件输出</li><li><strong>-n</strong> ：只打印模式匹配的行，便于查看所作修改</li></ul><p>以上列举只是一些常见选项，还有些比如 <code>-l</code> 指定每行长度，<code>-s</code> 指定换行的分隔符等等，用到了再来分析学习。</p><h2 id="寻找匹配"><a href="#寻找匹配" class="headerlink" title="寻找匹配"></a>寻找匹配</h2><p>既然是编辑文件，首先要找到需要编辑的位置，在sed命令中可以使用行号，或者字符查找等方式找到需要修改的位置，然后再执行编辑动作，常见的范围：</p><ul><li><strong>x</strong>：指定的行号，表示第x行</li><li><strong>x,y</strong>：指定的行号范围，表示第x行到y行</li><li><strong>/pattern</strong>：查询到包含指定模式的行</li><li><strong>x,y!</strong>：指定的行号范围，表示不包括第x行到y行</li></ul><h1 id="sed操作"><a href="#sed操作" class="headerlink" title="sed操作"></a>sed操作</h1><p>sed几乎可以实现文件的所有编辑工作，接下来尝试一些常见的用法：</p><h2 id="打印内容"><a href="#打印内容" class="headerlink" title="打印内容"></a>打印内容</h2><p>使用编辑命令 <code>p</code>，可以向匹配行后面插入内容。</p><ul><li>打印文件第2行和第3行的内容，命令为<code>sed -n &#39;2,3p&#39; data.txt</code></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">albert@DESKTOP-6746UC3:/mnt/d/data/shell$ cat data.txt</span><br><span class="line">1234</span><br><span class="line">abc</span><br><span class="line">xyz</span><br><span class="line">1==</span><br><span class="line">123</span><br><span class="line">albert@DESKTOP-6746UC3:/mnt/d/data/shell$ sed -n <span class="string">'2,3p'</span> data.txt</span><br><span class="line">abc</span><br><span class="line">xyz</span><br></pre></td></tr></table></figure><h2 id="追加内容"><a href="#追加内容" class="headerlink" title="追加内容"></a>追加内容</h2><p>使用编辑命令 <code>a</code>，可以向匹配行后面插入内容。</p><ul><li>在第2行后面添加文本<code>newline</code>，命令为<code>sed &#39;2anewline&#39; data.txt</code></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">albert@DESKTOP-6746UC3:/mnt/d/data/shell$ cat data.txt</span><br><span class="line">1234</span><br><span class="line">abc</span><br><span class="line">xyz</span><br><span class="line">1==</span><br><span class="line">123</span><br><span class="line">albert@DESKTOP-6746UC3:/mnt/d/data/shell$ sed <span class="string">'2anewline'</span> data.txt</span><br><span class="line">1234</span><br><span class="line">abc</span><br><span class="line">newline</span><br><span class="line">xyz</span><br><span class="line">1==</span><br><span class="line">123</span><br></pre></td></tr></table></figure><ul><li>在最后一行后面添加文本<code>endline</code>，命令为<code>sed &#39;$aendline&#39; data.txt</code></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">albert@DESKTOP-6746UC3:/mnt/d/data/shell$ cat data.txt</span><br><span class="line">1234</span><br><span class="line">abc</span><br><span class="line">xyz</span><br><span class="line">1==</span><br><span class="line">123</span><br><span class="line">albert@DESKTOP-6746UC3:/mnt/d/data/shell$ sed <span class="string">'$aendline'</span> data.txt</span><br><span class="line">1234</span><br><span class="line">abc</span><br><span class="line">xyz</span><br><span class="line">1==</span><br><span class="line">123</span><br><span class="line">endline</span><br><span class="line">albert@DESKTOP-6746UC3:/mnt/d/data/shell$</span><br></pre></td></tr></table></figure><h2 id="插入内容"><a href="#插入内容" class="headerlink" title="插入内容"></a>插入内容</h2><p>使用编辑命令 <code>i</code>，可以在匹配的那一行插入内容。</p><ul><li>在第1行插入文本<code>firstline</code>，命令为<code>sed &#39;1ifirstline&#39; data.txt</code></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">albert@DESKTOP-6746UC3:/mnt/d/data/shell$ cat data.txt</span><br><span class="line">1234</span><br><span class="line">abc</span><br><span class="line">xyz</span><br><span class="line">1==</span><br><span class="line">123</span><br><span class="line">albert@DESKTOP-6746UC3:/mnt/d/data/shell$ sed <span class="string">'1ifirstline'</span> data.txt</span><br><span class="line">firstline</span><br><span class="line">1234</span><br><span class="line">abc</span><br><span class="line">xyz</span><br><span class="line">1==</span><br><span class="line">123</span><br></pre></td></tr></table></figure><ul><li>在包含文本 “123” 的行插入文本<code>insertline</code>，命令为<code>sed &#39;/123/iinsertline&#39; data.txt</code></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">albert@DESKTOP-6746UC3:/mnt/d/data/shell$ cat data.txt</span><br><span class="line">1234</span><br><span class="line">abc</span><br><span class="line">xyz</span><br><span class="line">1==</span><br><span class="line">123</span><br><span class="line">albert@DESKTOP-6746UC3:/mnt/d/data/shell$ sed <span class="string">'/123/iinsertline'</span> data.txt</span><br><span class="line">insertline</span><br><span class="line">1234</span><br><span class="line">abc</span><br><span class="line">xyz</span><br><span class="line">1==</span><br><span class="line">insertline</span><br><span class="line">123</span><br></pre></td></tr></table></figure><h2 id="更改行内容"><a href="#更改行内容" class="headerlink" title="更改行内容"></a>更改行内容</h2><p>使用编辑命令 <code>c</code>，可以修改匹配行的内容。</p><ul><li>将包含文本 “123” 的行替换为 “456”，命令为<code>sed &#39;/123/c456&#39; data.txt</code></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">albert@DESKTOP-6746UC3:/mnt/d/data/shell$ cat data.txt</span><br><span class="line">1234</span><br><span class="line">abc</span><br><span class="line">xyz</span><br><span class="line">1==</span><br><span class="line">123</span><br><span class="line">albert@DESKTOP-6746UC3:/mnt/d/data/shell$ sed <span class="string">'/123/c456'</span> data.txt</span><br><span class="line">456</span><br><span class="line">abc</span><br><span class="line">xyz</span><br><span class="line">1==</span><br><span class="line">456</span><br></pre></td></tr></table></figure><ul><li>将3、4、5行内容更改为newworld，命令为<code>sed &#39;3,5cneworld&#39; data.txt</code></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">albert@DESKTOP-6746UC3:/mnt/d/data/shell$ cat data.txt</span><br><span class="line">1234</span><br><span class="line">abc</span><br><span class="line">xyz</span><br><span class="line">1==</span><br><span class="line">123</span><br><span class="line">albert@DESKTOP-6746UC3:/mnt/d/data/shell$ sed <span class="string">'3,5cneworld'</span> data.txt</span><br><span class="line">1234</span><br><span class="line">abc</span><br><span class="line">neworld</span><br></pre></td></tr></table></figure><h2 id="替换行内容"><a href="#替换行内容" class="headerlink" title="替换行内容"></a>替换行内容</h2><p>使用编辑命令 <code>s</code>，可以替换匹配行的内容，需要注意和 <code>c</code> 的区别，<code>c</code> 是整行的内容都改变，而 <code>s</code> 是只替换命令中指定的部分。</p><ul><li>将文件中的文本 “123” 替换为 “456”，命令为<code>sed &#39;s/123/456/g&#39; data.txt</code></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">albert@DESKTOP-6746UC3:/mnt/d/data/shell$ cat data.txt</span><br><span class="line">1234</span><br><span class="line">abc</span><br><span class="line">xyz</span><br><span class="line">1==</span><br><span class="line">123</span><br><span class="line">albert@DESKTOP-6746UC3:/mnt/d/data/shell$ sed <span class="string">'s/123/456/g'</span> data.txt</span><br><span class="line">4564</span><br><span class="line">abc</span><br><span class="line">xyz</span><br><span class="line">1==</span><br><span class="line">456</span><br></pre></td></tr></table></figure><h1 id="综合运用"><a href="#综合运用" class="headerlink" title="综合运用"></a>综合运用</h1><ul><li>删除空行并给所有内容是 “123” 的文本加上小括号</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">albert@DESKTOP-6746UC3:/mnt/d/data/shell$ cat data.txt</span><br><span class="line">1234</span><br><span class="line">abc</span><br><span class="line">xyz</span><br><span class="line"></span><br><span class="line">1==</span><br><span class="line">123</span><br><span class="line">albert@DESKTOP-6746UC3:/mnt/d/data/shell$ sed -e <span class="string">'s/123/(&amp;)/g'</span> -e <span class="string">'/^$/d'</span> data.txt</span><br><span class="line">(123)4</span><br><span class="line">abc</span><br><span class="line">xyz</span><br><span class="line">1==</span><br><span class="line">(123)</span><br></pre></td></tr></table></figure><h2 id="删除内容"><a href="#删除内容" class="headerlink" title="删除内容"></a>删除内容</h2><p>使用编辑命令 <code>c</code>，可以删除匹配行。</p><ul><li>删除空行，命令为<code>sed &#39;/^$/d&#39; data.txt</code></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">albert@DESKTOP-6746UC3:/mnt/d/data/shell$ cat data.txt</span><br><span class="line">1234</span><br><span class="line"></span><br><span class="line">abc</span><br><span class="line">xyz</span><br><span class="line">1==</span><br><span class="line">123</span><br><span class="line">albert@DESKTOP-6746UC3:/mnt/d/data/shell$ sed <span class="string">'/^$/d'</span> data.txt</span><br><span class="line">1234</span><br><span class="line">abc</span><br><span class="line">xyz</span><br><span class="line">1==</span><br><span class="line">123</span><br></pre></td></tr></table></figure><ul><li>从第一行开始，每两行删除掉一行，命令为<code>sed &#39;1~2d&#39; data.txt</code></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">albert@DESKTOP-6746UC3:/mnt/d/data/shell$ cat data.txt</span><br><span class="line">1234</span><br><span class="line">abc</span><br><span class="line">xyz</span><br><span class="line">1==</span><br><span class="line">123</span><br><span class="line">albert@DESKTOP-6746UC3:/mnt/d/data/shell$ sed <span class="string">'1~2d'</span> data.txt</span><br><span class="line">abc</span><br><span class="line">1==</span><br></pre></td></tr></table></figure><ul><li>删除2行和3行以外的行，命令为<code>sed &#39;2,3!d&#39; data.txt</code></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">albert@DESKTOP-6746UC3:/mnt/d/data/shell$ cat data.txt</span><br><span class="line">1234</span><br><span class="line">abc</span><br><span class="line">xyz</span><br><span class="line">1==</span><br><span class="line">123</span><br><span class="line">albert@DESKTOP-6746UC3:/mnt/d/data/shell$ sed <span class="string">'2,3!d'</span> data.txt</span><br><span class="line">abc</span><br><span class="line">xyz</span><br></pre></td></tr></table></figure><ul><li>删除指定行数范围内的匹配行，命令为<code>sed &#39;1,3{/123/d}&#39; data.txt</code></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">albert@DESKTOP-6746UC3:/mnt/d/data/shell$ cat data.txt</span><br><span class="line">1234</span><br><span class="line">abc</span><br><span class="line">xyz</span><br><span class="line">1==</span><br><span class="line">123</span><br><span class="line">albert@DESKTOP-6746UC3:/mnt/d/data/shell$ sed <span class="string">'1,3&#123;/123/d&#125;'</span> data.txt</span><br><span class="line">abc</span><br><span class="line">xyz</span><br><span class="line">1==</span><br><span class="line">123</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li><code>sed</code> 是 stream editor 的缩写，表示为面向字符流的编辑器</li><li><code>sed</code> 命令常用的几个选项，<code>-e</code>、<code>-f</code>、<code>-i</code>、<code>-n</code></li><li><code>sed</code> 命令常用的几个编辑动作，也就是选项后的常用命令有 <code>p（打印）</code>、<code>a（追加）</code>、<code>i（插入）</code>、<code>c（改变）</code>、<code>s（替换）</code>、<code>d（删除）</code></li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/109267664" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>不能打败我的困难终将使我更加强大，绊不倒我的石头最后只会被拿来踩踏，拥抱一个个困难，生活本来就是一条打怪升级之路，那有什么一帆风顺~</p><p>2020-11-7 22:47:01</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;每次看到sed这个词就想起“种子”，心里明知道是把它和seed弄混了，但是先入为主的思想怕是改不过来了，不过现在还好，虽然把第一印象的意思弄
      
    
    </summary>
    
      <category term="linux" scheme="http://AlbertGithubHome.github.io/blog/categories/linux/"/>
    
    
      <category term="linux" scheme="http://AlbertGithubHome.github.io/blog/tags/linux/"/>
    
      <category term="sed" scheme="http://AlbertGithubHome.github.io/blog/tags/sed/"/>
    
      <category term="文件" scheme="http://AlbertGithubHome.github.io/blog/tags/%E6%96%87%E4%BB%B6/"/>
    
      <category term="编辑" scheme="http://AlbertGithubHome.github.io/blog/tags/%E7%BC%96%E8%BE%91/"/>
    
  </entry>
  
  <entry>
    <title>关于数据一致性的思考</title>
    <link href="http://AlbertGithubHome.github.io/blog/2020/10/24/%E5%85%B3%E4%BA%8E%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7%E7%9A%84%E6%80%9D%E8%80%83/"/>
    <id>http://AlbertGithubHome.github.io/blog/2020/10/24/关于数据一致性的思考/</id>
    <published>2020-10-24T14:11:21.000Z</published>
    <updated>2020-10-25T16:28:58.522Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>也不知道是谁这么有才，居然发明了1024这个程序员的节日，其他的节日都是买买买，唯独这个节日促销活动少的可怜，连早上买菜都是占了第二天重阳节的便宜，除了程序员们自嗨，也没人来给码农们庆祝了。</p><a id="more"></a><p>今天也嗨了一把，程序员的节日必须在工位上，飞速的敲着代码才是对1024最大的尊重，在这一天的结尾之际还是聊聊最近开发中的一些问题，其中数据一致性的问题确实需要梳理一下。</p><h1 id="什么是一致性"><a href="#什么是一致性" class="headerlink" title="什么是一致性"></a>什么是一致性</h1><p>关于一致性常常在两个地方听到，一个是数据库，另一个是分布式，两者都叫一致性，但是含义却不同。</p><h2 id="数据库一致性"><a href="#数据库一致性" class="headerlink" title="数据库一致性"></a>数据库一致性</h2><p>数据库中的一致性其实代表不破坏完整性，所有的数据从一个状态转化到另一个状态时不发生逻辑问题，比如说A通过手机银行给B转了100万，这件事情发生后A账户少了100万，B账户多了100万，这样就保证了数据的一致，如果转账结束A账户的钱少了100万，B账户却只多了100块，那完蛋了，A和B肯定一起去找银行打架去了。</p><h2 id="分布式一致性"><a href="#分布式一致性" class="headerlink" title="分布式一致性"></a>分布式一致性</h2><p>很多资料对于分布式一致性理解的都是数据冗余副本，当所有副本的数据一样时，那么此时的状态就是一致的。按照我自己的理解，这里的冗余副本不一定指的是数据形式完全一样，比如玩家在游戏服拥有金币资产200万，然后全服排行榜上的展示面板上显示资产也是200万，可能具体数据的形式不同，但这应该也是一种数据一致性的表现。</p><p>两个概念容易混淆，因为经常在分布式的架构下更新数据库，两种一致性也常常在同一个操作中有所体现。其实我也经常混着用，反正知道这个意思就好了，最近遇到的问题也是两个概念的集合，不过还是先来理解一下分布式的一致性吧</p><h1 id="分布式一致性分类"><a href="#分布式一致性分类" class="headerlink" title="分布式一致性分类"></a>分布式一致性分类</h1><ul><li><strong>强一致性：</strong> 要求无论更新操作是在哪一个节点副本上执行，之后获取的数据都是最新的。</li><li><strong>弱一致性：</strong> 能容忍部分或全部节点都看不到最新数据，数据改变时尽量通知可能多的节点。</li><li><strong>最终一致性：</strong> 是弱一致性的一种特例表现，需要保证用户最终能够读取到最新的数据。</li></ul><p>我们当然希望能实现强一致性，但这样需要付出相当大的代价，往往要通过牺牲可用性才能达到。</p><h1 id="一致性的保证"><a href="#一致性的保证" class="headerlink" title="一致性的保证"></a>一致性的保证</h1><p>如果要想达到强一致性，那么就得保证任何数据在改变之后必须通知所有节点，等待所有节点更新完毕后才能给用户提供服，这就要在开始更新时加一把大锁，先锁住数据，等待所有节点完成更新时释放锁，这样才能提供数据的强一致性保证。</p><p>如果节点太多的话，这个锁的机制将会消耗大量的时间来等待，可能导致应用长时间不能提供正常服务，在一些应用上显然是不合适的，所以是否要保证强一致性需要根据具体的业务逻辑来选择。</p><p>还有一个经常听到的观点就是在分布式系统中一致性和可用性我们只能选择一个，这一般是从CAP理论中得到的结论，但是这样说是不准确的，关于CAP理论最初版的大意为：“对于一个分布式计算系统，不可能同时满足一致性（Consistence）、可用性（Availability）、分区容错性（Partition Tolerance ）三个设计约束”。</p><p>通过CAP理论告诉我们分布式系统只能选择CP或者AP，但其实这里的前提是分布式系统发生了“分区”现象。如果当前系统没有发生分区现象，我们没有必要放弃C或者A，应该C和A都可以保证。</p><p>还有一点个人的理解，由于数据传输是需要时间的，那么当一个节点修改了数据同步到另一个节点时不可能瞬间完成，所以数据不一致总是时刻存在，而我们前面提到的数据一致总是指对用户而言的，虽然数据在传输过程中是不一致的，但是我们可以规定在数据完成同步前，用户看到的都是旧数据，这样就对用户而言数据就是一致的。</p><p>而数据同步过程中的不一致，如果在不一致期间还发生了中断、崩溃等问题，就必须通过日志来恢复了，个人觉得，总是有那么一种极限情况，连日志都救不了你，毕竟记录日志的也是一种程序，但是这类事情发生的概率也比较小了。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>程序世界的一致性常常指数据库中的一致性和分布式中的一致性</li><li>CAP理论告诉我们分布式系统在发生了分区现象时，才需要选择CP或者AP，否则应该可以保证CA</li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/109145949" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>欲穷千里目，更上一层楼。最近越来越发现古诗的精妙之处了，随着阅历的增加，之前背诵的古诗有些突然就明白了，不知道应该开心还是难过~</p><p>2020-10-26 00:27:02</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;也不知道是谁这么有才，居然发明了1024这个程序员的节日，其他的节日都是买买买，唯独这个节日促销活动少的可怜，连早上买菜都是占了第二天重阳节的便宜，除了程序员们自嗨，也没人来给码农们庆祝了。&lt;/p&gt;
    
    </summary>
    
      <category term="Thinking" scheme="http://AlbertGithubHome.github.io/blog/categories/Thinking/"/>
    
    
      <category term="游戏" scheme="http://AlbertGithubHome.github.io/blog/tags/%E6%B8%B8%E6%88%8F/"/>
    
      <category term="架构设计" scheme="http://AlbertGithubHome.github.io/blog/tags/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    
      <category term="一致性" scheme="http://AlbertGithubHome.github.io/blog/tags/%E4%B8%80%E8%87%B4%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>linux环境下使用sort命令完成常见排序操作</title>
    <link href="http://AlbertGithubHome.github.io/blog/2020/10/14/linux%E7%8E%AF%E5%A2%83%E4%B8%8B%E4%BD%BF%E7%94%A8sort%E5%91%BD%E4%BB%A4%E5%AE%8C%E6%88%90%E5%B8%B8%E8%A7%81%E6%8E%92%E5%BA%8F%E6%93%8D%E4%BD%9C/"/>
    <id>http://AlbertGithubHome.github.io/blog/2020/10/14/linux环境下使用sort命令完成常见排序操作/</id>
    <published>2020-10-14T15:46:28.000Z</published>
    <updated>2020-10-18T07:58:34.656Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>linux 系统下的命令常常给人一种短小精悍的感觉，使用起来就像一把把锋利的小刀，在自己专注的领域做到极致，今天要聊的就是 linux 环境下的排序命令 <code>sort</code>，处理文本按列排序非常方便，最近使用 <code>sort</code>命令来排序日志查找问题，为了防止一段时间不用又会忘记，所以记录下来便于下次查找。</p><h1 id="命令作用"><a href="#命令作用" class="headerlink" title="命令作用"></a>命令作用</h1><p><code>sort</code> 命令默认会将待排序内容以空格划分为多个列，然后对内容进行按列排序，命令本身不会修改待排序内容，而是将排序结果重新输出，如果想修改待排序源文件的内容，可以通过重定向命令来实现。</p><p>命令格式为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sort [选项] 文件名</span><br></pre></td></tr></table></figure><h1 id="常见选项"><a href="#常见选项" class="headerlink" title="常见选项"></a>常见选项</h1><p><code>sort</code> 作为一个强大的命令，参数选项还挺多的，不过我只列举一些常见的参数，方便日常使用即可。</p><ul><li><strong>-k：</strong> 指定排序依据的列数，可以分多次指定</li><li><strong>-o：</strong> 将排序后的结果存入指定文件</li><li><strong>-c：</strong> 检查指定文件是否已经排好序</li><li><strong>-u：</strong> 删除所有重复行</li><li><strong>-b：</strong> 忽略每行或字段前面开始出的空格字符</li><li><strong>-f：</strong> 排序比较时忽略大小写</li><li><strong>-n：</strong> 转化为数字，按照数值的大小排序</li><li><strong>-r：</strong> 反向排序，从大到小</li><li><strong>-t：</strong> 指定排序时划分列数的分隔字符</li></ul><h1 id="数据文件"><a href="#数据文件" class="headerlink" title="数据文件"></a>数据文件</h1><p>为了展示 <code>sort</code> 命令的作用，专门利用 <code>ls</code> 命令产生了一段数据，并保存在了 data.txt 文件中，之后会利用这个文件来展示 <code>sort</code> 的用法，文件内容展示如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:~$ cat data.txt</span><br><span class="line">-rwxrwxr-x 1 albert albert  9272 Jul 18 22:27 a.out*</span><br><span class="line">-rw------- 1 albert albert  7064 Oct 17 22:14 .bash_history</span><br><span class="line">-rw-r--r-- 1 albert albert   220 Jul 16 00:52 .bash_logout</span><br><span class="line">-rw-r--r-- 1 albert albert  3771 Jul 16 00:52 .bashrc</span><br><span class="line">drwxrwxrwx 1 albert albert  4096 Jul 16 01:10 .cache/</span><br><span class="line">drwx------ 1 albert albert  4096 Jul 16 00:52 .config/</span><br><span class="line">-rw------- 1 albert albert    35 Jul 19 14:14 .lesshst</span><br><span class="line">-rwxrwxr-x 1 albert albert 20328 Jul 18 19:49 mainpro*</span><br><span class="line">-rw-rw-r-- 1 albert albert   195 Jul 18 22:27 mainpro.cpp</span><br><span class="line">-rw-r--r-- 1 albert albert   655 Jul 16 00:52 .profile</span><br><span class="line">-rw-r--r-- 1 albert albert     0 Jul 16 00:52 .sudo_as_admin_successful</span><br><span class="line">-rw------- 1 root   root    2257 Jul 16 01:10 .viminfo</span><br><span class="line">drwxrwxrwx 1 albert albert  4096 Jul 19 21:19 .vscode-server/</span><br><span class="line">-rw------- 1 albert albert    61 Sep 20 09:42 .Xauthority</span><br></pre></td></tr></table></figure><p>这个文件中的内容在使用 <code>sort</code> 命令排序时默认以空格分割，所以共有9列，在指定列数时从1开始，接下来我们用这些数据来测试一下排序命令的用法。</p><h1 id="核心参数"><a href="#核心参数" class="headerlink" title="核心参数"></a>核心参数</h1><p>对于我来说 <code>sort</code> 命令的核心参数是 <code>-k</code>，其完整的参数列表为 <code>-k START_F[.START_C][OPTIONS][,END_F[.END_C][OPTIONS]]</code>，参数列表很长，但是不要恐惧，逐步分析就可以了。</p><p><code>-k</code> 后面这已打算都是用来指定排序依据的范围的，其中 <code>START_F</code> 和 <code>END_F</code> 表示开始和结束的字段，也就是列数，<code>.START_C</code> 和 <code>.END_C</code> 表示指定字段开始和结束的字符数，<code>OPTIONS</code> 是由一个或多个单个字母排序的选项[bdfgiMhnRrV]，这些选项中常用的已经列举在前面了，写在此处的选项会覆盖全局排序选项。</p><p>这样文字叙述有些枯燥，可以看下这个参数 <code>-k 6.2b,6.3b</code>，这个排序选项的含义是把内容按照第6列的第2个字符到第6列的第3个字符排序，查找字符位置的时候要去掉前面的空白。</p><h1 id="用法展示"><a href="#用法展示" class="headerlink" title="用法展示"></a>用法展示</h1><p>看了以上的参数可能还是不太清楚具体怎样用，所以举了下面这些例子，可以方便的处理常用的排序工作。</p><h2 id="按照指定列排序"><a href="#按照指定列排序" class="headerlink" title="按照指定列排序"></a>按照指定列排序</h2><p>这是最普通的排序要求了，也是我用的最多的情况，需要使用-k参数</p><ul><li>按照第3列排序</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:~$ sort -k3,3 data.txt</span><br><span class="line">drwx------ 1 albert albert  4096 Jul 16 00:52 .config/</span><br><span class="line">drwxrwxrwx 1 albert albert  4096 Jul 16 01:10 .cache/</span><br><span class="line">drwxrwxrwx 1 albert albert  4096 Jul 19 21:19 .vscode-server/</span><br><span class="line">-rw------- 1 albert albert    35 Jul 19 14:14 .lesshst</span><br><span class="line">-rw------- 1 albert albert    61 Sep 20 09:42 .Xauthority</span><br><span class="line">-rw------- 1 albert albert  7064 Oct 17 22:14 .bash_history</span><br><span class="line">-rw-r--r-- 1 albert albert     0 Jul 16 00:52 .sudo_as_admin_successful</span><br><span class="line">-rw-r--r-- 1 albert albert   220 Jul 16 00:52 .bash_logout</span><br><span class="line">-rw-r--r-- 1 albert albert  3771 Jul 16 00:52 .bashrc</span><br><span class="line">-rw-r--r-- 1 albert albert   655 Jul 16 00:52 .profile</span><br><span class="line">-rw-rw-r-- 1 albert albert   195 Jul 18 22:27 mainpro.cpp</span><br><span class="line">-rwxrwxr-x 1 albert albert 20328 Jul 18 19:49 mainpro*</span><br><span class="line">-rwxrwxr-x 1 albert albert  9272 Jul 18 22:27 a.out*</span><br><span class="line">-rw------- 1 root   root    2257 Jul 16 01:10 .viminfo</span><br></pre></td></tr></table></figure><blockquote><p>root 已经被排到了所有albert的后面</p></blockquote><h2 id="将排序结果存入指定文件"><a href="#将排序结果存入指定文件" class="headerlink" title="将排序结果存入指定文件"></a>将排序结果存入指定文件</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:~$ sort -k3,3 data.txt -o dst.txt</span><br><span class="line">albert@home-pc:~$ cat dst.txt</span><br><span class="line">drwx------ 1 albert albert  4096 Jul 16 00:52 .config/</span><br><span class="line">drwxrwxrwx 1 albert albert  4096 Jul 16 01:10 .cache/</span><br><span class="line">drwxrwxrwx 1 albert albert  4096 Jul 19 21:19 .vscode-server/</span><br><span class="line">-rw------- 1 albert albert    35 Jul 19 14:14 .lesshst</span><br><span class="line">-rw------- 1 albert albert    61 Sep 20 09:42 .Xauthority</span><br><span class="line">-rw------- 1 albert albert  7064 Oct 17 22:14 .bash_history</span><br><span class="line">-rw-r--r-- 1 albert albert     0 Jul 16 00:52 .sudo_as_admin_successful</span><br><span class="line">-rw-r--r-- 1 albert albert   220 Jul 16 00:52 .bash_logout</span><br><span class="line">-rw-r--r-- 1 albert albert  3771 Jul 16 00:52 .bashrc</span><br><span class="line">-rw-r--r-- 1 albert albert   655 Jul 16 00:52 .profile</span><br><span class="line">-rw-rw-r-- 1 albert albert   195 Jul 18 22:27 mainpro.cpp</span><br><span class="line">-rwxrwxr-x 1 albert albert 20328 Jul 18 19:49 mainpro*</span><br><span class="line">-rwxrwxr-x 1 albert albert  9272 Jul 18 22:27 a.out*</span><br><span class="line">-rw------- 1 root   root    2257 Jul 16 01:10 .viminfo</span><br></pre></td></tr></table></figure><blockquote><p>排序结果已经被存储到了文件 dst.txt 中，其实这个命令还可以改写成 <code>sort data.txt &gt; dst.txt</code></p></blockquote><h2 id="查看文件是否已经排序好"><a href="#查看文件是否已经排序好" class="headerlink" title="查看文件是否已经排序好"></a>查看文件是否已经排序好</h2><ul><li>测试没排好序的文件</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:~$ sort -k3,3 data.txt -c</span><br><span class="line">sort: data.txt:2: disorder: -rw------- 1 albert albert  7064 Oct 17 22:14 .bash_history</span><br></pre></td></tr></table></figure><ul><li>测试已经排序的文件</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:~$ sort -k3,3 dst.txt -c</span><br><span class="line">albert@home-pc:~$</span><br></pre></td></tr></table></figure><blockquote><p>对于已经拍好序的文件使用 -c 参数没有任何输出，如果是未排序的文件则会给出提示</p></blockquote><h2 id="去掉排序结果中的重复行"><a href="#去掉排序结果中的重复行" class="headerlink" title="去掉排序结果中的重复行"></a>去掉排序结果中的重复行</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:~$ sort -k3,3 data.txt -u</span><br><span class="line">-rwxrwxr-x 1 albert albert  9272 Jul 18 22:27 a.out*</span><br><span class="line">-rw------- 1 root   root    2257 Jul 16 01:10 .viminfo</span><br></pre></td></tr></table></figure><blockquote><p>这里的重复行参考是你指定排序依据的列数，也就是第3列如果重复就会认为是重复行，结果中只能出现一次</p></blockquote><h2 id="按照数值结果进行排序"><a href="#按照数值结果进行排序" class="headerlink" title="按照数值结果进行排序"></a>按照数值结果进行排序</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:~$ sort -k5n,5 data.txt</span><br><span class="line">-rw-r--r-- 1 albert albert     0 Jul 16 00:52 .sudo_as_admin_successful</span><br><span class="line">-rw------- 1 albert albert    35 Jul 19 14:14 .lesshst</span><br><span class="line">-rw------- 1 albert albert    61 Sep 20 09:42 .Xauthority</span><br><span class="line">-rw-rw-r-- 1 albert albert   195 Jul 18 22:27 mainpro.cpp</span><br><span class="line">-rw-r--r-- 1 albert albert   220 Jul 16 00:52 .bash_logout</span><br><span class="line">-rw-r--r-- 1 albert albert   655 Jul 16 00:52 .profile</span><br><span class="line">-rw------- 1 root   root    2257 Jul 16 01:10 .viminfo</span><br><span class="line">-rw-r--r-- 1 albert albert  3771 Jul 16 00:52 .bashrc</span><br><span class="line">drwx------ 1 albert albert  4096 Jul 16 00:52 .config/</span><br><span class="line">drwxrwxrwx 1 albert albert  4096 Jul 16 01:10 .cache/</span><br><span class="line">drwxrwxrwx 1 albert albert  4096 Jul 19 21:19 .vscode-server/</span><br><span class="line">-rw------- 1 albert albert  7064 Oct 17 22:14 .bash_history</span><br><span class="line">-rwxrwxr-x 1 albert albert  9272 Jul 18 22:27 a.out*</span><br><span class="line">-rwxrwxr-x 1 albert albert 20328 Jul 18 19:49 mainpro*</span><br></pre></td></tr></table></figure><blockquote><p>这里使用了 -k5n,5 作为排序选项，其中的 n 表示以数值方式排序，如果不加 n 的排序结果如下：</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:~$ sort -k5,5 data.txt</span><br><span class="line">-rw-r--r-- 1 albert albert     0 Jul 16 00:52 .sudo_as_admin_successful</span><br><span class="line">-rw-rw-r-- 1 albert albert   195 Jul 18 22:27 mainpro.cpp</span><br><span class="line">-rwxrwxr-x 1 albert albert 20328 Jul 18 19:49 mainpro*</span><br><span class="line">-rw-r--r-- 1 albert albert   220 Jul 16 00:52 .bash_logout</span><br><span class="line">-rw------- 1 root   root    2257 Jul 16 01:10 .viminfo</span><br><span class="line">-rw------- 1 albert albert    35 Jul 19 14:14 .lesshst</span><br><span class="line">-rw-r--r-- 1 albert albert  3771 Jul 16 00:52 .bashrc</span><br><span class="line">drwx------ 1 albert albert  4096 Jul 16 00:52 .config/</span><br><span class="line">drwxrwxrwx 1 albert albert  4096 Jul 16 01:10 .cache/</span><br><span class="line">drwxrwxrwx 1 albert albert  4096 Jul 19 21:19 .vscode-server/</span><br><span class="line">-rw------- 1 albert albert    61 Sep 20 09:42 .Xauthority</span><br><span class="line">-rw-r--r-- 1 albert albert   655 Jul 16 00:52 .profile</span><br><span class="line">-rw------- 1 albert albert  7064 Oct 17 22:14 .bash_history</span><br><span class="line">-rwxrwxr-x 1 albert albert  9272 Jul 18 22:27 a.out*</span><br></pre></td></tr></table></figure><blockquote><p>数据看起来很乱，其实也是按照第5列排好序的，仔细分析你会发现是把这些数字当成字符串排的序</p></blockquote><h2 id="反向排序"><a href="#反向排序" class="headerlink" title="反向排序"></a>反向排序</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:~$ sort -k3,3 data.txt -r</span><br><span class="line">-rw------- 1 root   root    2257 Jul 16 01:10 .viminfo</span><br><span class="line">-rwxrwxr-x 1 albert albert  9272 Jul 18 22:27 a.out*</span><br><span class="line">-rwxrwxr-x 1 albert albert 20328 Jul 18 19:49 mainpro*</span><br><span class="line">-rw-rw-r-- 1 albert albert   195 Jul 18 22:27 mainpro.cpp</span><br><span class="line">-rw-r--r-- 1 albert albert   655 Jul 16 00:52 .profile</span><br><span class="line">-rw-r--r-- 1 albert albert  3771 Jul 16 00:52 .bashrc</span><br><span class="line">-rw-r--r-- 1 albert albert   220 Jul 16 00:52 .bash_logout</span><br><span class="line">-rw-r--r-- 1 albert albert     0 Jul 16 00:52 .sudo_as_admin_successful</span><br><span class="line">-rw------- 1 albert albert  7064 Oct 17 22:14 .bash_history</span><br><span class="line">-rw------- 1 albert albert    61 Sep 20 09:42 .Xauthority</span><br><span class="line">-rw------- 1 albert albert    35 Jul 19 14:14 .lesshst</span><br><span class="line">drwxrwxrwx 1 albert albert  4096 Jul 19 21:19 .vscode-server/</span><br><span class="line">drwxrwxrwx 1 albert albert  4096 Jul 16 01:10 .cache/</span><br><span class="line">drwx------ 1 albert albert  4096 Jul 16 00:52 .config/</span><br></pre></td></tr></table></figure><blockquote><p>按照第3列反向排序，root就排到了所有albert的前面</p></blockquote><h2 id="自定义分割字符"><a href="#自定义分割字符" class="headerlink" title="自定义分割字符"></a>自定义分割字符</h2><p><code>sort</code> 命令默认是以空格作为列的分割符号的，可以使用 <code>-t</code> 选项自定义分割符，比如我们使用 <code>:</code> 作为分隔符，然后以第二列进行排序</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:~$ sort -t <span class="string">":"</span> -k2,2 data.txt</span><br><span class="line">drwxrwxrwx 1 albert albert  4096 Jul 16 01:10 .cache/</span><br><span class="line">-rw------- 1 root   root    2257 Jul 16 01:10 .viminfo</span><br><span class="line">-rw------- 1 albert albert  7064 Oct 17 22:14 .bash_history</span><br><span class="line">-rw------- 1 albert albert    35 Jul 19 14:14 .lesshst</span><br><span class="line">drwxrwxrwx 1 albert albert  4096 Jul 19 21:19 .vscode-server/</span><br><span class="line">-rwxrwxr-x 1 albert albert  9272 Jul 18 22:27 a.out*</span><br><span class="line">-rw-rw-r-- 1 albert albert   195 Jul 18 22:27 mainpro.cpp</span><br><span class="line">-rw------- 1 albert albert    61 Sep 20 09:42 .Xauthority</span><br><span class="line">-rwxrwxr-x 1 albert albert 20328 Jul 18 19:49 mainpro*</span><br><span class="line">-rw-r--r-- 1 albert albert   220 Jul 16 00:52 .bash_logout</span><br><span class="line">-rw-r--r-- 1 albert albert  3771 Jul 16 00:52 .bashrc</span><br><span class="line">drwx------ 1 albert albert  4096 Jul 16 00:52 .config/</span><br><span class="line">-rw-r--r-- 1 albert albert   655 Jul 16 00:52 .profile</span><br><span class="line">-rw-r--r-- 1 albert albert     0 Jul 16 00:52 .sudo_as_admin_successful</span><br></pre></td></tr></table></figure><blockquote><p>结果是以分钟数进行的排序</p></blockquote><h1 id="综合排序"><a href="#综合排序" class="headerlink" title="综合排序"></a>综合排序</h1><p>学习了上面这么多参数，可以做一个综合的例子，以第6列的月份从小到大排序，以第5列文件大小逆序排列，通过组合上面的参数，可以使用下面的命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:~$ sort -k6,6 -k5rn,5 data.txt</span><br><span class="line">-rwxrwxr-x 1 albert albert 20328 Jul 18 19:49 mainpro*</span><br><span class="line">-rwxrwxr-x 1 albert albert  9272 Jul 18 22:27 a.out*</span><br><span class="line">drwx------ 1 albert albert  4096 Jul 16 00:52 .config/</span><br><span class="line">drwxrwxrwx 1 albert albert  4096 Jul 16 01:10 .cache/</span><br><span class="line">drwxrwxrwx 1 albert albert  4096 Jul 19 21:19 .vscode-server/</span><br><span class="line">-rw-r--r-- 1 albert albert  3771 Jul 16 00:52 .bashrc</span><br><span class="line">-rw------- 1 root   root    2257 Jul 16 01:10 .viminfo</span><br><span class="line">-rw-r--r-- 1 albert albert   655 Jul 16 00:52 .profile</span><br><span class="line">-rw-r--r-- 1 albert albert   220 Jul 16 00:52 .bash_logout</span><br><span class="line">-rw-rw-r-- 1 albert albert   195 Jul 18 22:27 mainpro.cpp</span><br><span class="line">-rw------- 1 albert albert    35 Jul 19 14:14 .lesshst</span><br><span class="line">-rw-r--r-- 1 albert albert     0 Jul 16 00:52 .sudo_as_admin_successful</span><br><span class="line">-rw------- 1 albert albert  7064 Oct 17 22:14 .bash_history</span><br><span class="line">-rw------- 1 albert albert    61 Sep 20 09:42 .Xauthority</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li><code>sort</code> 命令中的 <code>-k</code> 选项是最重要的参数，可以指定排序依据的列数</li><li><code>sort</code> 命令中的 <code>-n</code> 选项也是常用的参数，可以进行数值比较</li><li>在实际问题中常常需要综合运用这些参数，参考综合例子中的方式逐步确定参数选项就可以了。</li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/109020024" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>业精于勤，荒于嬉；行成于思，毁于随。没有人能随随便便成功~</p><p>2020-10-18 15:43:51</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;linux 系统下的命令常常给人一种短小精悍的感觉，使用起来就像一把把锋利的小刀，在自己专注的领域做到极致，今天要聊的就是 linux 环境
      
    
    </summary>
    
      <category term="linux" scheme="http://AlbertGithubHome.github.io/blog/categories/linux/"/>
    
    
      <category term="排序" scheme="http://AlbertGithubHome.github.io/blog/tags/%E6%8E%92%E5%BA%8F/"/>
    
      <category term="linux" scheme="http://AlbertGithubHome.github.io/blog/tags/linux/"/>
    
      <category term="sort" scheme="http://AlbertGithubHome.github.io/blog/tags/sort/"/>
    
  </entry>
  
  <entry>
    <title>Go语言在解决实际问题时的优点与不便</title>
    <link href="http://AlbertGithubHome.github.io/blog/2020/10/14/Go%E8%AF%AD%E8%A8%80%E5%9C%A8%E8%A7%A3%E5%86%B3%E5%AE%9E%E9%99%85%E9%97%AE%E9%A2%98%E6%97%B6%E7%9A%84%E4%BC%98%E7%82%B9%E4%B8%8E%E4%B8%8D%E4%BE%BF/"/>
    <id>http://AlbertGithubHome.github.io/blog/2020/10/14/Go语言在解决实际问题时的优点与不便/</id>
    <published>2020-10-14T15:19:16.000Z</published>
    <updated>2020-10-14T15:20:52.573Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><code>Go</code>语言，全称<code>golang</code>，是Google开发的一种静态强类型、编译型、并发型并具有垃圾回收功能的编程语言。 从2007年末由 Robert Griesemer、Rob Pike、Ken Thompson 主持开发，其中的 Ken Thompson 可是和 Dennis Ritchie 一起发明了C语言的大佬。Go 语言于2009年11月正式宣布成为开放源代码项目， 并在2012年初，发布了Go 1.0稳定版本，此后便开启了稳步发展的道路。</p><a id="more"></a><h1 id="Go-语言"><a href="#Go-语言" class="headerlink" title="Go 语言"></a>Go 语言</h1><p>作为一个从2007年开始诞生的语言，在庞大的语言家族中算是一个晚辈，和C++、Python这种老牌语言相比查了将近20年，和 C 语言相比资历就更低了，但是这个新晋的语言在 Google 光环的强大加持下也在飞速发展着，由于前辈们在发展的途中趟了很多坑，所以 Go 在发明之初就避免了其他语言的很多不便，可以说是站在巨人的肩膀上发展起来的。</p><p>但是即便这样，Go 语言的特点也不能被所有人喜欢，和许多人一样，我在学习这门语言的过程中也发现一些很方便特性和一些不太方便的特点，下面简单说几个点，有不对的地方希望小伙伴能及时指出，防止我在错误的思想上越走越远（怎么有种新闻发言稿的感觉~）。</p><h1 id="不便之处"><a href="#不便之处" class="headerlink" title="不便之处"></a>不便之处</h1><p>这里的不便之处只是我在使用过程中感觉不太方便，可能很多人并没有这个感觉，或许还有很多其他的解决方法和替代方案，烦请小伙伴能指点一下。</p><h2 id="三目运算符"><a href="#三目运算符" class="headerlink" title="三目运算符"></a>三目运算符</h2><p>这个三目运算符是个很常用的逻辑处理部件，也是我在逻辑中经常使用到的，在Python、Lua等语言中也不存在，但是我都找到了简单的替代方式，但是在Go 中不得不写成中规中矩的 <code>if</code> 条件判断，这让很多算法的解题代码看起来并不那么优雅，比如一个简单的约瑟夫环问题：</p><blockquote><p>N个人围成一圈，从第一个人从开始报数，报到m的人出圈，剩下的人继续从1开始报数，报到m的人出圈；如此往复，直到所有人出圈，输出最后一个出圈人最初始的编号。</p></blockquote><p>这个问题的解法最简单的是模拟法，使用数组模拟一个环来按照规则运行，最后一个出圈的人的编号就可以输出到结果，还有一种思路就是找规律，可以找到出圈前后的序号对应关系，进而写出一行代码的解决方案。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 索引从0开始，只要对结果加1就好了</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">joseph_ring</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n == <span class="number">1</span> ? <span class="number">0</span> : (joseph_ring(n - <span class="number">1</span>, m) + m) % n</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是在没有三目运算符的 Go 中要实现这个算法，就不得不多写几行了，和 C 语言相比就没有那么简洁了。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">joseph_ring</span><span class="params">(n <span class="keyword">int</span>, m <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (joseph_ring(n - <span class="number">1</span>, m) + m) % n</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="if-单行语句也要加大括号"><a href="#if-单行语句也要加大括号" class="headerlink" title="if 单行语句也要加大括号"></a>if 单行语句也要加大括号</h2><p>Go 语言本身带有自己的格式化命令，可以保证编写时不同的缩进样式格式化之后得到相同的代码，<code>if</code> 后面的条件语句可以不加小括号，但是后面的语句块必须加大括号，这样的规定对于我经常写的代码有点不太友好，比如下面这些C++代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (a &gt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (b &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span>;</span><br></pre></td></tr></table></figure><p>有时候为了看起来紧凑，可能会写成这样：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (a &gt; <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">if</span> (b &lt; <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span> (c == <span class="number">0</span>) <span class="keyword">return</span>;</span><br></pre></td></tr></table></figure><p>但是放到 Go 语言中，就不得不写成好几行了，并且还要加大括号，看起来代码有些松散。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> a &gt; <span class="number">0</span> &#123;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> b &lt; <span class="number">0</span> &#123;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> c == <span class="number">0</span> &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="优秀特性"><a href="#优秀特性" class="headerlink" title="优秀特性"></a>优秀特性</h1><p>上面提到了 Go 语言中不方便的地方，现在可以来说说 Go 语言相对于 C、C++ 更优越的特性：</p><h2 id="多个变量同时赋值"><a href="#多个变量同时赋值" class="headerlink" title="多个变量同时赋值"></a>多个变量同时赋值</h2><p>在 C++ 中交换两个变量的通常使用中间变量来完成，比如交换 <code>a</code>、<code>b</code> 两个变量的值：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> tmp = a;</span><br><span class="line">a = b;</span><br><span class="line">b = tmp;</span><br></pre></td></tr></table></figure><p>针对于这种整形的变量，一些大牛们发明了特殊的算法来处理，避免使用中间变量：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>,;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">a = a ^ b</span><br><span class="line">b = b ^ a</span><br><span class="line">a = a ^ b</span><br></pre></td></tr></table></figure><p>但是在 Go语言中这种情况非常好处理，直接从左到右依次赋值就好了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var a <span class="keyword">int</span> = <span class="number">1</span></span><br><span class="line">var b <span class="keyword">int</span> = <span class="number">6</span></span><br><span class="line"></span><br><span class="line">b, a = a, b</span><br></pre></td></tr></table></figure><h2 id="defer-声明"><a href="#defer-声明" class="headerlink" title="defer 声明"></a>defer 声明</h2><p><code>defer</code> 可以用于在当前函数返回前执行一些清理代码，而不管此函数如何退出。defer 在函数中可以随时出现，这使得清理代码可以尽可能在需要清理的地方运行，比如我们常常要释放申请的资源，常见的需要释放的资源有文件描述符：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">file, err := os.Open(fileName)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> file.Close()</span><br></pre></td></tr></table></figure><p>有了 defer 终于不再在担心，资源没回收的问题，也不用在各个提前返回的条件分支中添加释放资源的重复代码了。</p><h2 id="goroutine-并发"><a href="#goroutine-并发" class="headerlink" title="goroutine 并发"></a>goroutine 并发</h2><p><code>goroutine</code> 是Go并行设计的核心，说到底其实就是协程，但是它比线程更小并且在Go语言内部帮你实现了这些 goroutine 之间的内存共享。执行 goroutine 只需要极少的栈内存，可同时运行成千上万个并发任务。goroutine 一定程度上比 thread 更易用、更高效、更轻便。</p><p>使用起来也非常方便，创建 goroutine 只需在函数调用语句前添加 go 关键字，就可以创建并发执行单元。开发人员无需了解任何执行细节，调度器会自动将其安排到合适的系统线程上执行，这是解放生产力的又一创举，简单示例代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">new_task</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        fmt.Println(<span class="string">"this is a newTask"</span>)</span><br><span class="line">        time.Sleep(time.Second) <span class="comment">//延时1s</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> new_task() <span class="comment">//新建一个协程， 新建一个任务</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    time.Sleep(time.Second * <span class="number">15</span>) <span class="comment">//延时15s</span></span><br><span class="line">    fmt.Println(<span class="string">"this is a main goroutine"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>Go 语言作为编程语言中的新晋小弟，吸收了前人的经验，现阶段发展迅猛</li><li>虽然 Go 出于一些目的规定了语言的标准，但是类似于没有三目运算符这种特点还是有些不方便</li><li>Go 这门语言还很年轻，相信随着不断发展它会越来越优秀，但没有任何语言是完美无缺的</li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/108819869" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>陪伴是最长情的告白，而守护是最沉默的陪伴。国庆中秋双节合并，放假了，陪家人待在一起真的很开心，什么都不用做，就静静的待在一起很满足，聊聊天、抬抬杠，假期嗖嗖嗖地溜掉了~</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&lt;code&gt;Go&lt;/code&gt;语言，全称&lt;code&gt;golang&lt;/code&gt;，是Google开发的一种静态强类型、编译型、并发型并具有垃圾回收功能的编程语言。 从2007年末由 Robert Griesemer、Rob Pike、Ken Thompson 主持开发，其中的 Ken Thompson 可是和 Dennis Ritchie 一起发明了C语言的大佬。Go 语言于2009年11月正式宣布成为开放源代码项目， 并在2012年初，发布了Go 1.0稳定版本，此后便开启了稳步发展的道路。&lt;/p&gt;
    
    </summary>
    
      <category term="Go" scheme="http://AlbertGithubHome.github.io/blog/categories/Go/"/>
    
    
      <category term="C++" scheme="http://AlbertGithubHome.github.io/blog/tags/C/"/>
    
      <category term="Go" scheme="http://AlbertGithubHome.github.io/blog/tags/Go/"/>
    
      <category term="优点" scheme="http://AlbertGithubHome.github.io/blog/tags/%E4%BC%98%E7%82%B9/"/>
    
      <category term="缺点" scheme="http://AlbertGithubHome.github.io/blog/tags/%E7%BC%BA%E7%82%B9/"/>
    
  </entry>
  
  <entry>
    <title>使用Spreadsheet Compare工具对比Excel文件差异</title>
    <link href="http://AlbertGithubHome.github.io/blog/2020/10/04/%E4%BD%BF%E7%94%A8Spreadsheet-Compare%E5%B7%A5%E5%85%B7%E5%AF%B9%E6%AF%94Excel%E6%96%87%E4%BB%B6%E5%B7%AE%E5%BC%82/"/>
    <id>http://AlbertGithubHome.github.io/blog/2020/10/04/使用Spreadsheet-Compare工具对比Excel文件差异/</id>
    <published>2020-10-04T15:09:33.000Z</published>
    <updated>2020-10-14T15:22:01.216Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>与 <code>Spreadsheet Compare</code> 这个工具的相遇是通过 TortoiseSVN 来牵线的，在使用 SVN 管理 Excel 表格时发现，TortoiseSVN自带的比较工具不能对比Excel文件的版本差异，这对于通过日志查找问题来说非常不方便，通过搜索发现了 <code>Spreadsheet Compare</code> 这款优秀的工具，特此记录一下，方便日后查找并快速配置。</p><a id="more"></a><h1 id="Spreadsheet-Compare"><a href="#Spreadsheet-Compare" class="headerlink" title="Spreadsheet Compare"></a>Spreadsheet Compare</h1><p><code>Spreadsheet Compare</code> 是 Microsoft Office 自带的一款工具软件（2013版本以后），可以用来比较不同 Excel 表格的差异，既能显示数据的不同，也可以显示出表结构的不同。这是一款带界面的工具软件，布局分为左右两部分，与 Beyond Compare 这个工具界面类似，但是功能更加强大。</p><p>Beyond Compare 也可以用来对比表格差异，但是只能比较两个Excel的当前工作表，如果每个 Excel 文件中包含多个工作表时就会对比错误的情况，而 <code>Spreadsheet Compare</code> 在这一点上更加优秀，可以对比多个表格数据。</p><p><code>Spreadsheet Compare</code> 使用起来也非常简单，可以操作的按钮很少，界面简洁， 启动软件后单击左上角的 <code>Compare Files</code> 按钮，选择要对比的文件即可，非常方便，数据差异、结构差异等都会用不同的颜色标记出来，还可以导出对比结果。</p><h1 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h1><p>这种模式对于是提供给 TortoiseSVN 使用的前提，因为 TortoiseSVN 无法像人一样一步步操作选择待比较的 Excel 表格，而是需要一个命令脚本，将要比较的参数传给 <code>Spreadsheet Compare</code> 工具进而完成比较工作。</p><h2 id="找到工具"><a href="#找到工具" class="headerlink" title="找到工具"></a>找到工具</h2><p>想要编写命令脚本，首先要找到这个比较的工具，我找到的路径是在 <code>&quot;C:\Program Files (x86)\Microsoft Office\Root\Office16\DCF\SPREADSHEETCOMPARE.EXE&quot;</code>，相信大家的路径都差不多，在 Office 工具目录下应该就能找到了，可以在开始菜单中找到工具，然后通过属性找到可执行程序所在目录，工具的可执行文件名字叫做 <code>SPREADSHEETCOMPARE.EXE</code>。</p><h2 id="编写脚本"><a href="#编写脚本" class="headerlink" title="编写脚本"></a>编写脚本</h2><p>编写脚本之前有一点需要强调一下，<code>SPREADSHEETCOMPARE.EXE</code> 有点奇怪，大多数软件在比较差异的时候会将两个文件作为参数使用，但是 <code>SPREADSHEETCOMPARE.EXE</code> 在比较之前，需要将两个待比较的文件名分成两行写入一个文件，再将这个文件作为参数传给工具使用，比如要比较 ExcelA.xlsx 和 ExcelB.xlsx 两个文件，需要将两个文件写入一个临时文件 ExcelCompare.txt 中:</p><blockquote><p>ExcelA.xlsx<br>ExcelB.xlsx</p></blockquote><p>然后再把这个文件作为参数传给工具：</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SPREADSHEETCOMPARE.EXE ExcelCompare.txt</span><br></pre></td></tr></table></figure><h2 id="脚本内容"><a href="#脚本内容" class="headerlink" title="脚本内容"></a>脚本内容</h2><p>有了上面的说明，我们就可以写出一个较为通用的版本，比如我的脚本名字是 SC.bat，内容如下：</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line"><span class="built_in">chcp</span> <span class="number">65001</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> batpath=%~dp0</span><br><span class="line"><span class="built_in">echo</span> %~<span class="number">1</span>&gt; "<span class="variable">%batpath%</span>ExcelCompare.txt"</span><br><span class="line"><span class="built_in">echo</span> %~<span class="number">2</span>&gt;&gt; "<span class="variable">%batpath%</span>ExcelCompare.txt"</span><br><span class="line">"C:\\Program Files (x86)\\Microsoft Office\\Root\\Office16\\DCF\\SPREADSHEETCOMPARE.EXE" "<span class="variable">%batpath%</span>ExcelCompare.txt"</span><br></pre></td></tr></table></figure><h2 id="脚本执行"><a href="#脚本执行" class="headerlink" title="脚本执行"></a>脚本执行</h2><p>直接在 cmd 命令行中输入以下命令就可以对比 ExcelA.xlsx 和 ExcelB.xlsx 两个文件了：</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">D:\<span class="title">data</span>\<span class="title">bat</span>&gt;</span></span><br><span class="line"><span class="function"><span class="title">D</span>:\<span class="title">data</span>\<span class="title">bat</span>&gt;<span class="title">SC.bat</span> <span class="title">ExcelA.xlsx</span> <span class="title">ExcelB.xlsx</span></span></span><br></pre></td></tr></table></figure><h2 id="供给SVN调用"><a href="#供给SVN调用" class="headerlink" title="供给SVN调用"></a>供给SVN调用</h2><p>个人比较懒，不喜欢截图，在 TortoiseSVN 工具的设置中找到“差异查看器”选项，选择该选项然后点击界面上的高级设置，点击增加按钮，增加根据扩展名指定差异比较程序，填写 <code>.xlsx</code> 和所需命令 <code>D:\data\bat&gt;SC.bat %base %mine</code></p><p>命令中的 <code>%base</code> 和 <code>%mine</code> 参数是 TortoiseSVN 提供的，代表原始文件和自己修改的文件，这次再通过 SVN 查看表格差异就可以启动 <code>Spreadsheet Compare</code> 程序方便地查看两个表格的差异啦。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li><code>Spreadsheet Compare</code> 是一款强大的表格比较工具，在表格比较时比 Beyond Compare 还要优秀</li><li>脚本调用 <code>SPREADSHEETCOMPARE.EXE</code> 程序时参数是一个包含了待比较文件名的临时文件，这一点和其他的比较工具有些不同</li><li>脚本中我们生成的临时文件无需手动处理，再打开待比较文件后会自动删除</li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/108920923" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>急需找到一个看得见摸得着的目标为之努力，不然真的有点止步不前了，至今还未找到可以废寝忘食之事，长此以往终将碌碌无为，继续找寻，此事可以不伟大，但应该有趣~</p><p>2020-10-12 00:16:52</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;与 &lt;code&gt;Spreadsheet Compare&lt;/code&gt; 这个工具的相遇是通过 TortoiseSVN 来牵线的，在使用 SVN 管理 Excel 表格时发现，TortoiseSVN自带的比较工具不能对比Excel文件的版本差异，这对于通过日志查找问题来说非常不方便，通过搜索发现了 &lt;code&gt;Spreadsheet Compare&lt;/code&gt; 这款优秀的工具，特此记录一下，方便日后查找并快速配置。&lt;/p&gt;
    
    </summary>
    
      <category term="Tools" scheme="http://AlbertGithubHome.github.io/blog/categories/Tools/"/>
    
    
      <category term="Excel" scheme="http://AlbertGithubHome.github.io/blog/tags/Excel/"/>
    
      <category term="Spreadsheet-Compare" scheme="http://AlbertGithubHome.github.io/blog/tags/Spreadsheet-Compare/"/>
    
      <category term="SVN" scheme="http://AlbertGithubHome.github.io/blog/tags/SVN/"/>
    
  </entry>
  
  <entry>
    <title>东拉西扯01世界的沧海桑田</title>
    <link href="http://AlbertGithubHome.github.io/blog/2020/09/26/%E4%B8%9C%E6%8B%89%E8%A5%BF%E6%89%AF01%E4%B8%96%E7%95%8C%E7%9A%84%E6%B2%A7%E6%B5%B7%E6%A1%91%E7%94%B0/"/>
    <id>http://AlbertGithubHome.github.io/blog/2020/09/26/东拉西扯01世界的沧海桑田/</id>
    <published>2020-09-26T14:47:01.000Z</published>
    <updated>2020-10-14T15:21:05.336Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>此篇非技术总结，但却与技术相关，写这篇总结的起因是前两天看了一节关于虚幻四的公开课，这节课也不是讲开发技术，更多的是讲创作艺术，课程开始前看到虚幻编辑器的画面，还是有一种很熟悉的感觉，毕竟使用了3年多的时间，外观几乎没有变化，使用方式依旧是原来的步骤，但随着课程的进行，我发现它变了。</p><a id="more"></a><p>其中有一段内容提到，虚幻四已经不再将自己作为一款游戏开发引擎，而是定位成一个艺术创作和开发的平台，也就是说它不仅仅可以做游戏，同时可以用来出影视剧、国漫、特定素材等等，它已经将自己的势力范围扩张，变得丰富而强大，后来又提到虚幻五带来的种种提升。</p><p>什么？虚幻五已经出了，这是我之前不知道的，我知道今年 Redis 出了最新的 6.0 版本，MySQL 一跃发行了 8.0 版本，IOS 也更新到的 14.0.1 版本，似乎各种技术都在飞速的发展着，但是人的精力毕竟有限，很难把它们成长历程尽收眼底，一不留神就发现某种技术已经悄悄从你身边跨了过去。</p><h1 id="技术的发展"><a href="#技术的发展" class="headerlink" title="技术的发展"></a>技术的发展</h1><p>记得我第一篇博客记录的是处理 Ubuntu 黑屏的解决方案，我去翻了翻当时记录的版本是 12.04，时间已经过去了7年，Ubuntu 20.04 已经发行，当年解决黑屏的经验或许已经毫无用处。</p><p>10年接触的第一种计算机编程语言是 C 语言，当时开发环境是 Turbe C 2.0，后来使用 VC++6.0，接着就是VS系列，期间用过 Dev-C++、CodeBlocks等编辑器，但是 VS 还是用的最多的，直到目前使用的 VS2017，可是刚刚一个好学的小朋友问我 VS2019 相关的问题，我发现这款用了这么久的工具，之前一直无变化的菜单布局在 VS2019 版本上发生了改变。</p><p>之前一直号称单线程内存数据库 Redis 在今年5月份发布的 6.0 版本中，加入了网络多线程，使得整体性能提升近一倍，这被认为是 Redis 最大的一次改版。</p><p>MySQL 直接从 5.7 版本跳到了 8.0 版本，因为之前一直是 5.6 、5.7 这样的小版本提升，一跃跳到 8.0 一时让人好奇到底改了什么？其实 6.0 是一个过渡版本，而 7.0 是作为集群的保留版本，所以这次直接到了 8.0。其中一个亮点增加了 MySQL 文档存储，可以存储 json 格式，开始支持向 NoSQL 格式转化。</p><p>差点忘了C++，这个庞然大物目前已经从最开始的 C++98，发展到现在的 C++20，我在想它如果真的存活到 2098 年，应该怎么命名它呢？新标准的内容很长，需要慢慢来消化，可以发现一些很好玩的东西，比如三向比较运算符 <code>&lt;=&gt;</code>，也叫飞船运算符，感兴趣的可以去了解下。</p><p>经历的和未经历的变化还有很多，想好了再来补充。。。</p><h1 id="技术公司的发展"><a href="#技术公司的发展" class="headerlink" title="技术公司的发展"></a>技术公司的发展</h1><p>当年找工作的听说过的巨头就是 BAT，而今天晚上问一个即将毕业进入工作岗位的同学，哪些是他心目中的大厂，他给出了四个名字，“阿里、腾讯、字节、美团”，很明显百度已经掉队，但是瘦死的骆驼比马大，短时间内百度的技术底蕴不会消失殆尽，这些手握资源和技术的大厂很早就给自己挖好了护城河，一般企业很难追赶的上。</p><p>相比早期的 BAT，我感觉后来的字节、美团能够赶上他们实属不易，记得当年开玩笑说 TX 除了发明了一套钻石收费系统，其他的都是抄的，任何公司有了好点子，不是被他合并了就是被他抄走了，所以说能在某个它无法掌控的赛道上超越它也是非常厉害了。</p><p>有些东西是其他公司无法做到的，比如疫情期间的健康宝，每天上班、去商场、去公园都要看，都要打开微信和支付宝的APP，这个日活的数据放到其他任意一款软件上都是庞大的数字，可是他们就在这两大巨头这自然的发生着。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>技术每时每刻都在发展，有时你发现它陌生了，其实只是你关注的少了</li><li>好的赛道大多数已被别人占领，从夹缝中寻找到机会还需好好把握，才能做出一定的成绩</li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/108691877" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>年年岁岁花相似，岁岁年年人不同</p><p>2020-9-27 00:20:42</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;此篇非技术总结，但却与技术相关，写这篇总结的起因是前两天看了一节关于虚幻四的公开课，这节课也不是讲开发技术，更多的是讲创作艺术，课程开始前看到虚幻编辑器的画面，还是有一种很熟悉的感觉，毕竟使用了3年多的时间，外观几乎没有变化，使用方式依旧是原来的步骤，但随着课程的进行，我发现它变了。&lt;/p&gt;
    
    </summary>
    
      <category term="Thinking" scheme="http://AlbertGithubHome.github.io/blog/categories/Thinking/"/>
    
    
      <category term="技术" scheme="http://AlbertGithubHome.github.io/blog/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="计算机" scheme="http://AlbertGithubHome.github.io/blog/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>C++求解组合数的具体实现</title>
    <link href="http://AlbertGithubHome.github.io/blog/2020/09/19/C-%E6%B1%82%E8%A7%A3%E7%BB%84%E5%90%88%E6%95%B0%E7%9A%84%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0/"/>
    <id>http://AlbertGithubHome.github.io/blog/2020/09/19/C-求解组合数的具体实现/</id>
    <published>2020-09-19T12:22:34.000Z</published>
    <updated>2020-09-22T14:38:19.264Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>很少写关于具体算法的总结笔记，因为很难把一个算法从头到尾的叙述清晰并且完整，容易造成误解。这次想总结一下组合数的具体实现，原因是最近总是碰见组合数，所以决定来写写，免得每次从头推导公式耽误时间。排列组合经常会作为一个问题解决方案中一部分，通常是求某个问题有多少个解，达到某种状态有多少种操作方式等等。</p><a id="more"></a><h1 id="问题起因"><a href="#问题起因" class="headerlink" title="问题起因"></a>问题起因</h1><p>今天下午解一道简单题，难度简直刷新了我的认知，其中需要用到组合数，但这仅仅是解题的一小部分，没办法，从头推导的，简单优化下，写出了如下代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">C</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = a; i &gt; a - b; i--) ans *= i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = b; i &gt; <span class="number">1</span>; i--) ans /= i;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为时间紧迫，范围也比较小，同时可以控制 <code>a</code> 和 <code>b</code> 的大小，所以临时写下的这段代码可以运行，不然这段代码会出现各种错误的。</p><h1 id="组合公式"><a href="#组合公式" class="headerlink" title="组合公式"></a>组合公式</h1><p>既然是想做总结，还是从头来看看组合公式，根据原始公式实现算法，并尝试优化它，当熟悉这个套路之后，就可以直接拿来用了，可以节省不少时间，组合公式的常见表示方式如下：</p><p>$$<br>C^m_n = \frac{n!}{m!(n-m)!} = C^{n-m}_n,(n \geq m \geq 0)<br>$$</p><p>这个公式写出来清晰多了，<code>n!</code>表示n的阶乘，计算方式为 n*(n-1)*(n-2)*(n-3)*…*3*2*1， 相信很多人都清楚，我们只要把这个数据公式翻译成代码就可以了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">C2</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">1</span>, c = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; --i) a *= i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = m; i &gt;= <span class="number">1</span>; --i) b *= i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n-m; i &gt;= <span class="number">1</span>; --i) c *= i;</span><br><span class="line">    <span class="keyword">return</span> a/(b*c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码比较简单，依次计算公式中三个数的阶乘，然后再做乘除法就可以了，但是你有没有思考过一个问题，<code>int</code> 类型的整数最大能表示的阶乘是多少？是<code>12!</code>，它的值是 479,001,600，它是 <code>int</code> 表示范围内最大的阶乘数，看来这种实现方式局限性很大，如果 n 大于12就没有办法计算了。</p><h1 id="公式变形"><a href="#公式变形" class="headerlink" title="公式变形"></a>公式变形</h1><p>实际上根据阶乘的定义，n! 和 (n-m)! 是可以约分的，将这两个式子约分后，公式可以化简为：</p><p>$$<br>C^m_n = \frac{n!}{m!(n-m)!} = \frac{n(n-1)(n-2)…(n-m+1))}{m!},(n \geq m \geq 0)<br>$$</p><p>公式写成这样之后可以少计算一个阶乘，并且计算的范围也会缩小，代码实现和一开始展示的代码思想是一样的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">C3</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt; n - m; --i) a *= i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = m; i &gt;= <span class="number">1</span>; i--) b *= i;</span><br><span class="line">    <span class="keyword">return</span> a/b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码虽然经过了化简，但是当 n 和 m 非常接近的时候，分子还是接近于 n!，所以表示的范围还是比较小。</p><h1 id="递推公式"><a href="#递推公式" class="headerlink" title="递推公式"></a>递推公式</h1><p>直接给出的公式经过化简后还是受制于计算阶乘的范围，得想个办法看看能不能绕过阶乘计算，方法总是有的，并且前辈们已经给我们整理好了，我们总是站在巨人的肩膀上，下面就是递推公式：</p><p>$$<br>\begin{cases} {C^m_n} = 1,\qquad\qquad\qquad (m=0 或 m=n) \ {C^m<em>n} = {C^m</em>{n-1}} + {C^{m-1}_{n-1}},\qquad(n &gt; m &gt; 0) \end{cases}<br>$$</p><h2 id="递归实现"><a href="#递归实现" class="headerlink" title="递归实现"></a>递归实现</h2><p>有了上面的分段函数表示，就满足了递归的条件，既有递归调用缩小规模，也有递归出口，这样实现起来很简单，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">C4</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == m || m == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> C4(n<span class="number">-1</span>, m) + C4(n<span class="number">-1</span>, m<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这两行代码是不是很秀？不过使用递归常常会出现一问题，那就是相同子问题多次计算，导致效率低下，这个计算组合数的方式同样存在重复计算子问题的缺点，我们以调用C4(5, 3)为例，看看下面的调用关系图：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">graph TB</span><br><span class="line">A(5,3)--&gt;B(4,3)</span><br><span class="line">    B(4,3)--&gt;C(3,3);</span><br><span class="line">    B(4,3)--&gt;D(3,2);</span><br><span class="line">    D(3,2)--&gt;E(2,2);</span><br><span class="line">    D(3,2)--&gt;F(2,1);</span><br><span class="line">    F(2,1)--&gt;G(1,1);</span><br><span class="line">    F(2,1)--&gt;H(1,0);</span><br><span class="line"></span><br><span class="line">    A(5,3)--&gt;O(4,2)</span><br><span class="line">O(4,2)--&gt;P(3,2)</span><br><span class="line">O(4,2)--&gt;Q(3,1)</span><br><span class="line">P(3,2)--&gt;R(2,2)</span><br><span class="line">P(3,2)--&gt;S(2,1)</span><br><span class="line">Q(3,1)--&gt;T(2,1)</span><br><span class="line">Q(3,1)--&gt;U(2,0)</span><br><span class="line">S(2,1)--&gt;V(1,1)</span><br><span class="line">S(2,1)--&gt;W(1,0)</span><br><span class="line">T(2,1)--&gt;X(1,1)</span><br><span class="line">T(2,1)--&gt;Y(1,0)</span><br></pre></td></tr></table></figure><p>从这个图可以清晰看出<code>C4(3, 2)</code> 和 <code>C4(2, 1)</code> 都被计算了多次，当 m 和 n 的数字比较大的时候，会进行更多次的重复计算，严重影响计算的效率，有没有什么办法解决重复计算的问题呢？</p><h2 id="备忘递归"><a href="#备忘递归" class="headerlink" title="备忘递归"></a>备忘递归</h2><p>解决重复计算的常用方法是利用一个备忘录，将已经计算式子结果存储起来，下次再遇到重复的计算时直接取上次的结果就可以了，我们可以将中间结果简单存储到map中。</p><p>假设 n 不超过10000，这比12已经大太多了，我们可以使用 <code>n * 10000 + m</code> 作为map的键，然后将结果存储到map中，每次计算一个式子前先看查询备忘录，看之前有没有计算过，如果计算过直接取结果就可以了，代码简单实现如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">C5</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m, <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&amp; memo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == m || m == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> itora = memo.find((n<span class="number">-1</span>)*<span class="number">10000</span>+m);</span><br><span class="line">    <span class="keyword">int</span> a = itora != memo.end() ? itora-&gt;second : C4(n<span class="number">-1</span>, m);</span><br><span class="line">    <span class="keyword">if</span> (itora == memo.end()) memo[(n<span class="number">-1</span>)*<span class="number">10000</span>+m] = a;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> itorb = memo.find((n<span class="number">-1</span>)*<span class="number">10000</span>+m<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">int</span> b = itorb != memo.end() ? itorb-&gt;second : C4(n<span class="number">-1</span>, m<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">if</span> (itorb == memo.end()) memo[(n<span class="number">-1</span>)*<span class="number">10000</span>+m<span class="number">-1</span>] = b;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 map 作为备忘录可以避免重复计算，这是解决递归效率低下的常用方法，那么有了递推公式不使用递归实现可不可以呢？当然可以了，针对于这个问题，有了递推公式我们还可以使用动态规划（dp）的方式来实现。</p><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>动态规划常常适用于有重叠子问题和最优子结构性质的问题，试图只解决每个子问题一次，具有天然剪枝的功能。基本思想非常简单，若要解一个给定问题，我们需要解其不同子问题，再根据子问题的解以得出原问题的解。</p><p>再回顾一下递推公式：</p><p>$$<br>\begin{cases} {C^m_n} = 1,\qquad\qquad\qquad (m=0 或 m=n) \ {C^m<em>n} = {C^m</em>{n-1}} + {C^{m-1}_{n-1}},\qquad(n &gt; m &gt; 0) \end{cases}<br>$$</p><p>翻译成人话就是，当m等于0或者等于n的时候，组合数结果为1，否则组合数结果等于另外两个组合数的和，我们可以采用正向推导的方式，将 n 和 m 逐步扩大，最终得到我们想要的结果，定义dp表格如下：</p><table><thead><tr><th style="text-align:center">n\m</th><th style="text-align:center">(0)</th><th style="text-align:center">(1)</th><th style="text-align:center">(2)</th><th style="text-align:center">(3)</th><th style="text-align:center">(4)</th><th style="text-align:center">(5)</th></tr></thead><tbody><tr><td style="text-align:center">(0)</td><td style="text-align:center">1</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">(1)</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">(2)</td><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">1</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">(3)</td><td style="text-align:center">1</td><td style="text-align:center">3</td><td style="text-align:center">3</td><td style="text-align:center">1</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">(4)</td><td style="text-align:center">1</td><td style="text-align:center">4</td><td style="text-align:center">6</td><td style="text-align:center">4</td><td style="text-align:center"><em><1></1></em></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">(5)</td><td style="text-align:center">1</td><td style="text-align:center">5</td><td style="text-align:center">10</td><td style="text-align:center"><strong>==&gt;10</strong></td><td style="text-align:center"><em><5></5></em></td><td style="text-align:center"><em><1></1></em></td></tr></tbody></table><p>从表格可以清晰的看出求解 <code>C(5,3)</code> 只需要计算5行3列（从0开始）的数据，其余的值可以不用计算，这样我们就可以对照着表格写代码啦，定义一个dp数组，然后双重for循环就搞定了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">C6</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == m || m == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(n+<span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(m+<span class="number">1</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i &amp;&amp; j &lt;= m; j++)</span><br><span class="line">            <span class="keyword">if</span> (i == j || j == <span class="number">0</span>) dp[i][j] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> dp[i][j] = dp[i<span class="number">-1</span>][j] + dp[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[n][m];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，我们就采用了非递归的方式求解出了组合数的结果，但是这里的空间有点浪费，每次都要花费<code>O(mn)</code>的空间复杂度，有没有办法降低一点呢？我们可以找找规律进行压缩。</p><h2 id="压缩DP"><a href="#压缩DP" class="headerlink" title="压缩DP"></a>压缩DP</h2><p>观察之前的动态规划实现的代码，我们发现求解第 <code>i</code>行的数据时只与第 <code>i-1</code> 行有关，所以我们可以考虑将二维数据压缩成一维，还是逐行求解，只不过可以用一维数组来记录求解的结果，优化代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">C7</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == m || m == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(m+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = min(i, m); j &gt;= <span class="number">0</span>; j--)</span><br><span class="line">            <span class="keyword">if</span> (i == j || j == <span class="number">0</span>) dp[j] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> dp[j] = dp[j] + dp[j<span class="number">-1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[m];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们就将空间复杂度降低到了<code>O(m)</code>，需要注意的是在计算dp时，因为采用了压缩结构，为防止前面的修改影响后续结果，所以采用里倒序遍历，这是一个易错的点。</p><h2 id="其他优化"><a href="#其他优化" class="headerlink" title="其他优化"></a>其他优化</h2><p>代码实现到这里，我们的时间复杂度是<code>O(nm)</code>，空间复杂是<code>O(m)</code>，其实还有进一步的优化空间：</p><ul><li><p><strong>减小m：</strong> 因为题目是求解C(n, m)，但是我们知道组合公式中，C(n, m) 和 C(n, n-m) 相等，所以当 n-m 小于 m 的时候求解C(n, n-m)可以降低时间复杂度和空间复杂度。</p></li><li><p><strong>部分剪枝：</strong> 观察函数<code>int C7(int n, int m)</code>，实际上当i为n时，j没必要遍历到0，只需要计算j等于m的情况就可以了，可以提前计算出结果。</p></li><li><p><strong>缩小计算范围：</strong> 从上面的剪枝操作得到启示，其实每一行没必要全部计算出来，以 <code>C(5,3)</code> 为例，我们只需要计算出表格中有数字的位置的结果就可以了：</p></li></ul><table><thead><tr><th style="text-align:center">n\m</th><th style="text-align:center">(0)</th><th style="text-align:center">(1)</th><th style="text-align:center">(2)</th><th style="text-align:center">(3)</th><th style="text-align:center">(4)</th><th style="text-align:center">(5)</th></tr></thead><tbody><tr><td style="text-align:center">(0)</td><td style="text-align:center">1</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">(1)</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">(2)</td><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">1</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">(3)</td><td style="text-align:center"></td><td style="text-align:center">3</td><td style="text-align:center">3</td><td style="text-align:center">1</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">(4)</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">6</td><td style="text-align:center">4</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">(5)</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"><strong>==&gt;10</strong></td><td style="text-align:center"></td></tr></tbody></table><p>这样来看每行最多需要计算3个值，那么时间复杂度可以降低到 <code>O(3n)</code>，去掉常数，时间复杂度降为 <code>O(n)</code>。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>计算组合数可以采用逆向递归和正向递推两种方式，递归时注意写好递归出口</li><li>采用正向递推方法时利用动态规划思想，使用子问题的解拼凑出最终问题的解</li><li>计算组合数若使用了计算阶乘应注意范围，避免在计算时产生溢出，<code>int</code>最多能表示 <code>12!</code></li><li>使用动态规划方法时可以逐步优化空间和时间，这其实就是优化算法的过程，也是提升的过程</li><li>关于组合数的求解方式，我们可以找到时间复杂度<code>O(n)</code>、空间复杂度<code>O(m)</code>的非递归解法</li></ul><h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><p>感谢 @小胡同的诗 同学的补充和提醒，让我再次感受到数学力量的深不可测，原来求解组合数还有这样一个递推公式：</p><p>$$<br>\begin{cases} {C^m_n} = 1,\qquad\qquad\qquad (m=0 或 m=n) \ C_n^m=\frac{n-m+1}{m}C_n^{m-1},\qquad(n &gt; m &gt; 0) \end{cases}<br>$$</p><p>这个公式厉害就厉害在它是一个线性的，不存在分叉的情况，也就是说即使递归也不会出现重复的计算，我们简单实现一下。</p><h2 id="反向递归"><a href="#反向递归" class="headerlink" title="反向递归"></a>反向递归</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">C8</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == m || m == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> C8(n, m<span class="number">-1</span>) * (n-m+<span class="number">1</span>) / m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码非常紧凑，也不存在重复计算的情况，当然我们也可以使用正向计算的方式来实现。</p><h2 id="正向递推"><a href="#正向递推" class="headerlink" title="正向递推"></a>正向递推</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">C9</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == m || m == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">    m = min(m, n-m);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) ans = ans * (n-i+<span class="number">1</span>) / i;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码将时间复杂度降到了O(m)，空间复杂度降到了O(1)，不过特定的场景还是要选择特定的实现，虽然<code>C9</code>函数在时间复杂度和空间复杂度上都优于 <code>C5</code> 函数，但是如果一个实际问题中需要用到多个组合数的时候，<code>C5</code> 这种采用缓存的方式可能会是更好的选择。</p><hr><center><a href="https://blog.csdn.net/albertsh/article/details/108552268" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>想讲故事？没人倾听？那是因为你还未到达一个指定的高度，当你在某个领域站稳了脚跟，做出了成绩，自然有的是时间去讲故事或者“编”故事，到时候随便一句话都会被很多人奉为圭臬，甚至会出现一些鸡汤莫名其妙的从你嘴里“说”出来。在你拥有了讲故事权利的同时，批判的声音也将随之而来~</p><p>2020-9-20 12:32:37</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;很少写关于具体算法的总结笔记，因为很难把一个算法从头到尾的叙述清晰并且完整，容易造成误解。这次想总结一下组合数的具体实现，原因是最近总是碰见组合数，所以决定来写写，免得每次从头推导公式耽误时间。排列组合经常会作为一个问题解决方案中一部分，通常是求某个问题有多少个解，达到某种状态有多少种操作方式等等。&lt;/p&gt;
    
    </summary>
    
      <category term="C/C++" scheme="http://AlbertGithubHome.github.io/blog/categories/C-C/"/>
    
    
      <category term="C/C++" scheme="http://AlbertGithubHome.github.io/blog/tags/C-C/"/>
    
      <category term="combination" scheme="http://AlbertGithubHome.github.io/blog/tags/combination/"/>
    
      <category term="dp" scheme="http://AlbertGithubHome.github.io/blog/tags/dp/"/>
    
      <category term="recursion" scheme="http://AlbertGithubHome.github.io/blog/tags/recursion/"/>
    
  </entry>
  
  <entry>
    <title>C++中优先队列priority_queue的基础用法</title>
    <link href="http://AlbertGithubHome.github.io/blog/2020/09/11/C-%E4%B8%AD%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97priority-queue%E7%9A%84%E5%9F%BA%E7%A1%80%E7%94%A8%E6%B3%95/"/>
    <id>http://AlbertGithubHome.github.io/blog/2020/09/11/C-中优先队列priority-queue的基础用法/</id>
    <published>2020-09-11T15:10:11.000Z</published>
    <updated>2020-09-12T09:26:02.012Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>学习优先队列之前先看个单词队列 queue， 这个单词的读法很多人都能读对吧，音标是 <code>/kjuː/</code> ，再看一个双端队列 deque，它的音标是 <code>/dek/</code>，应该有人读错了吧，反正我是没读对，刚开始看见一次错一次，现在还好了，基本能记住怎么读了，可是这些队列怎么用呢？</p><a id="more"></a><p>队列就不用多说了，一个先进先出的经典数据结构，那么优先队列是个什么鬼，其实它就是在队列的基础上加上优先两个字，想想怎样才能优先呢？没错——排队！只有排好了队伍才会有落后和优先之分，否则一团乱糟糟的，怎么才能分出优先的，所以优先队列一定应用了排序。</p><p>可是排序要怎样实现呢？其实排序这个底层逻辑你是不用管的，你只要把想要的数据放到优先队列里，然后取出的必定是当前状态下最优的，当然，究竟什么是最优的条件是需要你来设定的，也就是说我们需要定义排序的规则。</p><h1 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h1><p>优先队列 priority_queue 是队列 queue 的一个变种，头文件是<code>#include &lt;queue&gt;</code>，使用优先队列必须要包含这个头文件。</p><h1 id="结构定义"><a href="#结构定义" class="headerlink" title="结构定义"></a>结构定义</h1><p>优先队列的结构定义是一个模板类，需要提供三个类型参数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">T</span>,</span></span><br><span class="line"><span class="class">    <span class="title">class</span> <span class="title">Container</span> = <span class="title">std</span>:</span>:<span class="built_in">vector</span>&lt;T&gt;,</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Compare</span> = <span class="title">std</span>:</span>:less&lt;<span class="keyword">typename</span> Container::value_type&gt;</span><br><span class="line">&gt; <span class="class"><span class="keyword">class</span> <span class="title">priority_queue</span>;</span></span><br></pre></td></tr></table></figure><p>从定义可以看出，虽然要结构是三个参数，但是后两个参数带了默认值，所以针对于普通的数据类型，一般情况下指提供第1个参数就可以了，比如 <code>priority_queue&lt;int&gt;</code> 实际上等价于 <code>priority_queue&lt;int, vector&lt;int&gt;, less&lt;int&gt;&gt;</code>。</p><p>这三个参数的含义分别为：数据类型，容器类型和比较函数，实际上优先队列就是维护了一个装有 <code>T</code> 类型元素的容器 <code>Container</code>，并在入队和出队时对容器内元素使用 <code>Compare</code> 比较函数进行了排序。</p><p>这3个参数还要满足一定的要求，并且在使用过程中有些注意事项：</p><ul><li>如果类型 <code>T</code> 和 <code>Container</code> 容器中元素类型不一致，那么行为未定义，所以要避免这种情况。</li><li><code>Container</code> 必须是序列容器，其实C++中序列容器很多的，比如<code>std::array</code>、<code>std::vector</code>、<code>std::deque</code>、<code>std::list</code>等</li><li><code>Container</code> 还必须要支持随机访问，并且有 <code>front()</code>、<code>push_back()</code>、<code>pop_back()</code> 等函数</li></ul><p>这样来看只有 <code>std::vector</code>、<code>std::deque</code> 满足容器条件了，而优先队列中使用的默认参数也是 <code>std::vector</code>。</p><h1 id="队列排序"><a href="#队列排序" class="headerlink" title="队列排序"></a>队列排序</h1><p>一直在说优先队列里使用了排序，而常用的容器是 <code>std::verctor</code>，那么究竟用的是什么排序，又是在什么时候进行的排序呢？实际上这里的排序并不是我们通常拿到数据后使用的冒泡排序、快速排序等，优先队列中的排序本质上是堆排序，但是它不是每次都进行完整的堆排序，而是通过 <code>Container</code> 维护了一个堆结构，每次入队和出队时都进行一次堆调整，所花时间为 <code>log(n)</code>，所以用在数据量大的地方，速度比较快。</p><h1 id="优先队列使用"><a href="#优先队列使用" class="headerlink" title="优先队列使用"></a>优先队列使用</h1><p>当我们大概了解了优先队列的原理后，可以通过使用来进一步熟悉这个结构，下面来看几个例子。</p><h2 id="实现排序"><a href="#实现排序" class="headerlink" title="实现排序"></a>实现排序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">common_sort</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> source_data[<span class="number">10</span>] = &#123;<span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">10</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">15</span>, <span class="number">13</span>, <span class="number">16</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认大根堆，实现由大到小排序</span></span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> n : source_data) q.push(n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; q.top() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        q.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>priority_queue&lt;int&gt;</code> 默认构建的是一个大根堆，所以每次从头取数据得到的是一个从大到小的队列排序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:/mnt/c++/datastruct$ g++ priorityqueue.cpp -o commonsort -std=c++11</span><br><span class="line">albert@home-pc:/mnt/c++/datastruct$ ./commonsort</span><br><span class="line">16</span><br><span class="line">15</span><br><span class="line">13</span><br><span class="line">10</span><br><span class="line">9</span><br><span class="line">8</span><br><span class="line">5</span><br><span class="line">3</span><br><span class="line">2</span><br><span class="line">1</span><br></pre></td></tr></table></figure><p>如果是完整排序使用优先队列就有些麻烦了，还不如直接调用 <code>std::sort</code> 函数，但是如果只取部分数据的话，优先队列还是非常方便快速的，比如下面这个问题。</p><h2 id="取出数组中最大的k个数"><a href="#取出数组中最大的k个数" class="headerlink" title="取出数组中最大的k个数"></a>取出数组中最大的k个数</h2><p>这是一个经典的算法题，最容易想到的办法就是遍历，先找到最大的，然后排出这个数再找到最大的，这样找k次就好了，所需时间大概表示为 <code>O(kN)</code>。</p><p>还有一个方法是排序，使用 <code>std::sort</code> 排序后，然后依次取出前 k 个数就行了，排序使用快速排序的话可以达到所需时间为 <code>O(Nlog(N))</code>，其实这样已经很优秀了，但是还可以通过优先队列来加速，下面来写一下代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">max_k_num</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> source_data[<span class="number">10</span>] = &#123;<span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">10</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">15</span>, <span class="number">13</span>, <span class="number">16</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 小根堆</span></span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> n : source_data) &#123;</span><br><span class="line">        <span class="keyword">if</span> (q.size() == k) &#123;</span><br><span class="line">            <span class="keyword">if</span> (n &gt; q.top()) &#123;</span><br><span class="line">                q.pop();</span><br><span class="line">                q.push(n);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> q.push(n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; q.top() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        q.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里是定义了一个小根堆，堆顶是最小值，当有新元素大于堆顶元素时，并且队列中元素等于k个，需要移除堆顶元素，然后插入新的元素，这样就能保证优先队列中始终拥有最大的k个数，运行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:/mnt/c++/datastruct$ g++ priorityqueue.cpp -o max_k_num -std=c++11</span><br><span class="line">albert@home-pc:/mnt/c++/datastruct$ ./max_k_num</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">13</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td></tr></table></figure><p>因为这里控制堆的规模最大为k，所以这个算法的执行时间大概是<code>O(Nlog(k))</code>，绝大多数情况是由于快速排序的。</p><h2 id="自定义结构"><a href="#自定义结构" class="headerlink" title="自定义结构"></a>自定义结构</h2><p>使用优先队列时常常要用到自定义结构，这时候就需要自己来写比较函数了，比如输出成绩最好的三个人的信息：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span> &#123;</span></span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">int</span> score;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmp_custom</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(student&amp; x, student&amp; y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x.score &gt; y.score;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">max_k_score</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;student&gt; stu_list = &#123;&#123;<span class="string">"Andy"</span>, <span class="number">89</span>&#125;, &#123;<span class="string">"Bella"</span>, <span class="number">79</span>&#125;, &#123;<span class="string">"Cary"</span>, <span class="number">92</span>&#125;, &#123;<span class="string">"Dick"</span>, <span class="number">60</span>&#125;, &#123;<span class="string">"Ray"</span>, <span class="number">70</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 小根堆</span></span><br><span class="line">    priority_queue&lt;student, <span class="built_in">vector</span>&lt;student&gt;, cmp_custom&gt; q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> stu : stu_list) &#123;</span><br><span class="line">        <span class="keyword">if</span> (q.size() == k) &#123;</span><br><span class="line">            <span class="keyword">if</span> (stu.score &gt; q.top().score) &#123;</span><br><span class="line">                q.pop();</span><br><span class="line">                q.push(stu);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> q.push(stu);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; q.top().name &lt;&lt; <span class="string">":"</span> &lt;&lt; q.top().score &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        q.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下，每个人的名字后面跟着分数，结果是分数最大的3个人的信息：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:/mnt/c++/datastruct$ g++ priorityqueue.cpp -o max_k_score -<span class="built_in">std</span>=c++<span class="number">11</span></span><br><span class="line">albert@home-pc:/mnt/c++/datastruct$ ./max_k_score</span><br><span class="line">Bella:<span class="number">79</span></span><br><span class="line">Andy:<span class="number">89</span></span><br><span class="line">Cary:<span class="number">92</span></span><br></pre></td></tr></table></figure><h2 id="自定义比较函数的另一种写法"><a href="#自定义比较函数的另一种写法" class="headerlink" title="自定义比较函数的另一种写法"></a>自定义比较函数的另一种写法</h2><p>看到上个例子中自定义比较函数的写法比较怪，一般我们在排序时定义的比较函数使用lambda表达式就可以，而这里是不能直接这样写的，需要多转化一步，写成下面这种形式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> cmp = [](student&amp; x, student&amp; y) &#123; <span class="keyword">return</span> x.score &gt; y.score; &#125;;</span><br><span class="line">priority_queue&lt;student, <span class="built_in">vector</span>&lt;student&gt;, <span class="keyword">decltype</span>(cmp)&gt; q(cmp);</span><br></pre></td></tr></table></figure><p>虽然看起来还是有点怪，但总比下面这样要好看的多：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmp_custom</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(student&amp; x, student&amp; y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x.score &gt; y.score;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">priority_queue&lt;student, <span class="built_in">vector</span>&lt;student&gt;, cmp_custom&gt; q;</span><br></pre></td></tr></table></figure><h1 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h1><p>优先队列的常用函数与队列类似，常用的有以下这些，如果想了解详细的用法，请戳<a href="https://en.cppreference.com/w/cpp/container/priority_queue" target="_blank" rel="noopener">在线文档</a></p><table><thead><tr><th style="text-align:center">函数名</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center"><a href="https://en.cppreference.com/w/cpp/container/priority_queue/top" target="_blank" rel="noopener">top</a></td><td style="text-align:center">访问队列的头部元素</td></tr><tr><td style="text-align:center"><a href="https://en.cppreference.com/w/cpp/container/priority_queue/empty" target="_blank" rel="noopener">empty</a></td><td style="text-align:center">判断优先队列内是否有元素</td></tr><tr><td style="text-align:center"><a href="https://en.cppreference.com/w/cpp/container/priority_queue/size" target="_blank" rel="noopener">size</a></td><td style="text-align:center">返回优先队列内元素个数</td></tr><tr><td style="text-align:center"><a href="https://en.cppreference.com/w/cpp/container/priority_queue/push" target="_blank" rel="noopener">push</a></td><td style="text-align:center">向优先队列中插入元素</td></tr><tr><td style="text-align:center"><a href="https://en.cppreference.com/w/cpp/container/priority_queue/emplace" target="_blank" rel="noopener">emplace</a></td><td style="text-align:center">在优先队列中构造元素</td></tr><tr><td style="text-align:center"><a href="https://en.cppreference.com/w/cpp/container/priority_queue/pop" target="_blank" rel="noopener">pop</a></td><td style="text-align:center">从优先队列头部弹出元素</td></tr><tr><td style="text-align:center"><a href="https://en.cppreference.com/w/cpp/container/priority_queue/swap" target="_blank" rel="noopener">swap</a></td><td style="text-align:center">与其他容器交换元素</td></tr></tbody></table><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>优先队列在一些需要部分排序的场景可以加快访问速度，降低时间复杂度</li><li>优先队列加速所付出的代价就是构建堆结构所需的内存，时间和空间总是一对矛盾共同体</li><li>以自定义结构作为元素的优先队列需要单独编写比较函数，可以使用lambda表达式，并用 <code>decltype(cmp)</code> 推导类型</li><li>需要注意的是这里的优先队列定义，第三个参数的需要的是比较函数的参数类型，而不是比较函数，区分与 <code>std::sort</code> 的不同</li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/108439423" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>人在比较中奋进，同在比较中消亡，起初面临差距时会奋起直追，但是当努力过后发现距离反而越来越远时，便会麻木懈怠，曾经的努力没有用吗？我觉得不是，努力过不一定会成功，但是努力的过程已经印在了骨子里，这本身就是生活的一部分。你可以选择这条艰苦的路，同样也可以选择跳过，至于跳过时错失了什么，谁又知道呢？毕竟人生无法再来过，重新读档只发生在游戏世界中~</p><p>2020-9-12 17:06:10</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;学习优先队列之前先看个单词队列 queue， 这个单词的读法很多人都能读对吧，音标是 &lt;code&gt;/kjuː/&lt;/code&gt; ，再看一个双端队列 deque，它的音标是 &lt;code&gt;/dek/&lt;/code&gt;，应该有人读错了吧，反正我是没读对，刚开始看见一次错一次，现在还好了，基本能记住怎么读了，可是这些队列怎么用呢？&lt;/p&gt;
    
    </summary>
    
      <category term="C/C++" scheme="http://AlbertGithubHome.github.io/blog/categories/C-C/"/>
    
    
      <category term="C/C++" scheme="http://AlbertGithubHome.github.io/blog/tags/C-C/"/>
    
      <category term="queue" scheme="http://AlbertGithubHome.github.io/blog/tags/queue/"/>
    
      <category term="priority_queue" scheme="http://AlbertGithubHome.github.io/blog/tags/priority-queue/"/>
    
      <category term="heap" scheme="http://AlbertGithubHome.github.io/blog/tags/heap/"/>
    
  </entry>
  
  <entry>
    <title>git log根据特定条件查询日志并统计修改的代码行数</title>
    <link href="http://AlbertGithubHome.github.io/blog/2020/09/05/git-log%E6%A0%B9%E6%8D%AE%E7%89%B9%E5%AE%9A%E6%9D%A1%E4%BB%B6%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97%E5%B9%B6%E7%BB%9F%E8%AE%A1%E4%BF%AE%E6%94%B9%E7%9A%84%E4%BB%A3%E7%A0%81%E8%A1%8C%E6%95%B0/"/>
    <id>http://AlbertGithubHome.github.io/blog/2020/09/05/git-log根据特定条件查询日志并统计修改的代码行数/</id>
    <published>2020-09-04T16:01:27.000Z</published>
    <updated>2020-09-06T16:29:49.470Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://img-blog.csdnimg.cn/20200907002654523.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9hbGJlcnRnaXRodWJob21lLmdpdGh1Yi5pby9ibG9nL2Fib3V0,size_10,color_FFFFFF,t_70#pic_center" alt="gitlog"></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>随着年龄的增长和知识的积累，最近常常有种豁然开朗的感觉，或者对一个已经存在的事物突然有了新的认识，比如统计这个词很早就接触了，从没考虑过它是什么意思，而这篇总结的题目中用了统计一词，第一感觉应该是汇总、记录的意思，后来去查了词条定义，也确实就是类似的解释，从没有刻意去学这个词的含义，但是在每天的生活中已经潜移默化地归纳、总结出来了。</p><a id="more"></a><p>想要统计就得有数据源，而 <code>git log</code> 命令恰恰就能提供这个数据源，<code>git log</code> 本身就是一个显示日志的命令，日志记录的是代码库变化的数据，类似于描述代码库变化的 “史书”，想要描述历史就需要大量的数据支撑，想要统计修改的代码行数，只要我们从历史记录中找到需要计算的部分就可以了。</p><h1 id="git-log"><a href="#git-log" class="headerlink" title="git log"></a>git log</h1><p>在统计之前我们需要先整理数据，杂乱无章的数据不是不能统计，只是计算起来更加的麻烦，所以在统计前需要先将数据规范化，所以我们需要先学习一下 <code>git log</code> 的相关操作。</p><p>我们以 <code>redis</code> 开源库为例，切换到 <code>6.0</code> 分支，提交记录定位到 <code>7bf665f125a4771db095c83a7ad6ed46692cd314</code>，以此为数据源，学习一下<code>git log</code> 的常用的查询方法，其实使用不同的条件查询就是整理、归类数据的过程。</p><p><code>git log</code> 的用法多种多样，我们主要关心两个大类，分别是条件筛选和显示格式。</p><h2 id="条件筛选"><a href="#条件筛选" class="headerlink" title="条件筛选"></a>条件筛选</h2><p><code>git log</code> 条件筛选的选项非常多，使用条件筛选的选项会影响显示的提交记录的范围，查找到想要显示的提交记录。</p><h3 id="查询最近几条log"><a href="#查询最近几条log" class="headerlink" title="查询最近几条log"></a>查询最近几条log</h3><p>使用 <code>-number</code> 参数可以查询最近几条提交提交记录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> -3</span><br><span class="line">commit 7bf665f125a4771db095c83a7ad6ed46692cd314 (HEAD -&gt; 6.0, tag: 6.0.6, origin/6.0)</span><br><span class="line">Author: Oran Agra &lt;oran@redislabs.com&gt;</span><br><span class="line">Date:   Sun Jul 19 14:00:20 2020 +0300</span><br><span class="line"></span><br><span class="line">    Redis 6.0.6.</span><br><span class="line"></span><br><span class="line">commit a5696bdf4f2687ab45f633ccb7cdc4ee9c2f957d</span><br><span class="line">Author: Oran Agra &lt;oran@redislabs.com&gt;</span><br><span class="line">Date:   Sun Jul 19 15:33:21 2020 +0300</span><br><span class="line"></span><br><span class="line">    Run daily CI on PRs to release a branch</span><br><span class="line"></span><br><span class="line">commit e15528bf1da1f1232fd08801ad382c915be94662</span><br><span class="line">Author: Itamar Haber &lt;itamar@redislabs.com&gt;</span><br><span class="line">Date:   Thu Jul 16 21:31:36 2020 +0300</span><br><span class="line"></span><br><span class="line">    Adds SHA256SUM to redis-stable tarball upload</span><br><span class="line"></span><br><span class="line">    (cherry picked from commit 5df0a64d30e7815c0a4a75a80f165fdee0bd1db6)</span><br></pre></td></tr></table></figure><h3 id="查询指定作者提交"><a href="#查询指定作者提交" class="headerlink" title="查询指定作者提交"></a>查询指定作者提交</h3><p>使用 <code>--author</code> 参数可以查询指定作者的提交记录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Albert@DESKTOP-6746UC3 MINGW64 /d/data/maingit/redis (6.0)</span><br><span class="line">$ git <span class="built_in">log</span> -2 --author=<span class="string">'Oran Agra'</span></span><br><span class="line">commit 7bf665f125a4771db095c83a7ad6ed46692cd314 (HEAD -&gt; 6.0, tag: 6.0.6, origin/6.0)</span><br><span class="line">Author: Oran Agra &lt;oran@redislabs.com&gt;</span><br><span class="line">Date:   Sun Jul 19 14:00:20 2020 +0300</span><br><span class="line"></span><br><span class="line">    Redis 6.0.6.</span><br><span class="line"></span><br><span class="line">commit a5696bdf4f2687ab45f633ccb7cdc4ee9c2f957d</span><br><span class="line">Author: Oran Agra &lt;oran@redislabs.com&gt;</span><br><span class="line">Date:   Sun Jul 19 15:33:21 2020 +0300</span><br><span class="line"></span><br><span class="line">    Run daily CI on PRs to release a branch</span><br></pre></td></tr></table></figure><h3 id="查询指定时间段的日志"><a href="#查询指定时间段的日志" class="headerlink" title="查询指定时间段的日志"></a>查询指定时间段的日志</h3><p>这个可选参数比较多，比如 <code>--since</code>、<code>--until</code>、<code>--before</code>、<code>--after</code> 等等，从意思很容易分辨怎么使用：</p><p><strong>查询2020-01-01到2020-04-01的提交记录</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> -2 --after=2020-01-01 --before=2020-04-01</span><br><span class="line">commit 957e917a84ac9979f18145a4d0b53386f5ce4fd9 (tag: 6.0-rc3)</span><br><span class="line">Author: antirez &lt;antirez@gmail.com&gt;</span><br><span class="line">Date:   Tue Mar 31 17:56:04 2020 +0200</span><br><span class="line"></span><br><span class="line">    Redis 6.0-RC3.</span><br><span class="line"></span><br><span class="line">commit ef1b1f01a84e969ea368e7fdbaf0d10615743269</span><br><span class="line">Author: antirez &lt;antirez@gmail.com&gt;</span><br><span class="line">Date:   Tue Mar 31 17:41:23 2020 +0200</span><br><span class="line"></span><br><span class="line">    cast raxSize() to avoid warning with format spec.</span><br></pre></td></tr></table></figure><p><em>恰好逮到了原作者的提交~</em></p><p><strong>查询1年前的提交记录</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> -2 --until=1.year.ago</span><br><span class="line">commit 86aade9a024c3582665903d0cc0c5692c6677cfd</span><br><span class="line">Merge: 89ad0ca56 3bfcae247</span><br><span class="line">Author: Salvatore Sanfilippo &lt;antirez@gmail.com&gt;</span><br><span class="line">Date:   Thu Sep 5 13:30:26 2019 +0200</span><br><span class="line"></span><br><span class="line">    Merge pull request <span class="comment">#6364 from oranagra/fix_module_aux_when</span></span><br><span class="line"></span><br><span class="line">    Fix to module aux data rdb format <span class="keyword">for</span> backwards compatibility with old check-rdb</span><br><span class="line"></span><br><span class="line">commit 3bfcae247a1c51788940bd4d2f32751ead451e42</span><br><span class="line">Author: Oran Agra &lt;oran@redislabs.com&gt;</span><br><span class="line">Date:   Thu Sep 5 14:11:37 2019 +0300</span><br><span class="line"></span><br><span class="line">    Fix to module aux data rdb format <span class="keyword">for</span> backwards compatibility with old check-rdb</span><br><span class="line"></span><br><span class="line">    When implementing the code that saves and loads these aux fields we used rdb</span><br><span class="line">    format that was added <span class="keyword">for</span> that <span class="keyword">in</span> redis 5.0, but <span class="keyword">then</span> we added the <span class="string">'when'</span> field</span><br><span class="line">    <span class="built_in">which</span> meant that the old redis-check-rdb won<span class="string">'t be able to skip these.</span></span><br><span class="line"><span class="string">    this fix adds an opcode as if that '</span>when<span class="string">' is part of the module data.</span></span><br></pre></td></tr></table></figure><h3 id="查询包含指定描述内容的提交记录"><a href="#查询包含指定描述内容的提交记录" class="headerlink" title="查询包含指定描述内容的提交记录"></a>查询包含指定描述内容的提交记录</h3><p>这里用可以使用 <code>--grep</code> 参数，可以过滤出包含指定内容的提交记录，这里指的是在 commit 描述中筛选符合条件的提交，比如查找提交描述中包含 client 的提交记录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> -2 --grep=<span class="string">'client'</span></span><br><span class="line">commit 0f75036c07db48dfcf605e090216a4447edc38fc</span><br><span class="line">Author: Wen Hui &lt;wen.hui.ware@gmail.com&gt;</span><br><span class="line">Date:   Wed Jul 15 05:38:47 2020 -0400</span><br><span class="line"></span><br><span class="line">    correct error msg <span class="keyword">for</span> num connections reaching maxclients <span class="keyword">in</span> cluster mode (<span class="comment">#7444)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    (cherry picked from commit d85af4d6f5fbe9cb9787b81583627cd74b47f838)</span><br><span class="line"></span><br><span class="line">commit f89f50dbd06247677b8cb3927cbb88c1b5384061</span><br><span class="line">Author: Oran Agra &lt;oran@redislabs.com&gt;</span><br><span class="line">Date:   Tue Jul 14 20:21:59 2020 +0300</span><br><span class="line"></span><br><span class="line">    diskless master disconnect replicas when rdb child failed (<span class="comment">#7518)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">in</span> <span class="keyword">case</span> the rdb child failed, crashed or terminated unexpectedly redis</span><br><span class="line">    would have marked the replica clients with repl_put_online_on_ack and</span><br><span class="line">    <span class="keyword">then</span> <span class="built_in">kill</span> them only after a minute when no ack was received.</span><br><span class="line"></span><br><span class="line">    it would not stream anything to these connections, so the only effect of</span><br><span class="line">    this bug is a delay of 1 minute <span class="keyword">in</span> the replicas attempt to re-connect.</span><br><span class="line"></span><br><span class="line">    (cherry picked from commit a176cb56a3c0235adddde33fcbaee2369a5af73e)</span><br></pre></td></tr></table></figure><h3 id="查找指定分支的提交记录"><a href="#查找指定分支的提交记录" class="headerlink" title="查找指定分支的提交记录"></a>查找指定分支的提交记录</h3><p>使用 <code>git log</code> 默认查找的是当前分支的提交记录，如果想查询其他分支的记录直接在命令后面加上分支名字就行，比如查询 <code>arm</code> 分支上的提交记录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> -2 arm</span><br><span class="line">commit 7329cc39818a05c168e7d1e791afb03c089f1933 (origin/arm, arm)</span><br><span class="line">Author: Salvatore Sanfilippo &lt;antirez@gmail.com&gt;</span><br><span class="line">Date:   Sun Feb 19 15:07:08 2017 +0000</span><br><span class="line"></span><br><span class="line">    ARM: Avoid fast path <span class="keyword">for</span> BITOP.</span><br><span class="line"></span><br><span class="line">    GCC will produce certain unaligned multi load-store instructions</span><br><span class="line">    that will be trapped by the Linux kernel since ARM v6 cannot</span><br><span class="line">    handle them with unaligned addresses. Better to use the slower</span><br><span class="line">    but safer implementation instead of generating the exception <span class="built_in">which</span></span><br><span class="line">    should be anyway very slow.</span><br><span class="line"></span><br><span class="line">commit 4e9cf4cc7ed4b732fc4bb592f19ceb41d132954e</span><br><span class="line">Author: Salvatore Sanfilippo &lt;antirez@gmail.com&gt;</span><br><span class="line">Date:   Sun Feb 19 15:02:37 2017 +0000</span><br><span class="line"></span><br><span class="line">    ARM: Use libc malloc by default.</span><br><span class="line"></span><br><span class="line">    I<span class="string">'m not sure how much test Jemalloc gets on ARM, moreover</span></span><br><span class="line"><span class="string">    compiling Redis with Jemalloc support in not very powerful</span></span><br><span class="line"><span class="string">    devices, like most ARMs people will build Redis on, is extremely</span></span><br><span class="line"><span class="string">    slow. It is possible to enable Jemalloc build anyway if needed</span></span><br><span class="line"><span class="string">    by using "make MALLOC=jemalloc".</span></span><br></pre></td></tr></table></figure><p>其实在 git 体系中，分支名、commit、标签等拥有几乎相同的含义，所以在很多场景下可以扩展互换，比如 <code>git log</code> 后面加上分支名就可以查询指定分支的提交记录，如果加上 commit 就会查询这个 commit 之前的提交记录，如果加上标签，就可以查询这个标签之前的提交记录，比如我们加一个 commit 试试：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> -2 7329cc39818a05c168e7d1e791afb03c089f1933</span><br><span class="line">commit 7329cc39818a05c168e7d1e791afb03c089f1933 (origin/arm, arm)</span><br><span class="line">Author: Salvatore Sanfilippo &lt;antirez@gmail.com&gt;</span><br><span class="line">Date:   Sun Feb 19 15:07:08 2017 +0000</span><br><span class="line"></span><br><span class="line">    ARM: Avoid fast path <span class="keyword">for</span> BITOP.</span><br><span class="line"></span><br><span class="line">    GCC will produce certain unaligned multi load-store instructions</span><br><span class="line">    that will be trapped by the Linux kernel since ARM v6 cannot</span><br><span class="line">    handle them with unaligned addresses. Better to use the slower</span><br><span class="line">    but safer implementation instead of generating the exception <span class="built_in">which</span></span><br><span class="line">    should be anyway very slow.</span><br><span class="line"></span><br><span class="line">commit 4e9cf4cc7ed4b732fc4bb592f19ceb41d132954e</span><br><span class="line">Author: Salvatore Sanfilippo &lt;antirez@gmail.com&gt;</span><br><span class="line">Date:   Sun Feb 19 15:02:37 2017 +0000</span><br><span class="line"></span><br><span class="line">    ARM: Use libc malloc by default.</span><br><span class="line"></span><br><span class="line">    I<span class="string">'m not sure how much test Jemalloc gets on ARM, moreover</span></span><br><span class="line"><span class="string">    compiling Redis with Jemalloc support in not very powerful</span></span><br><span class="line"><span class="string">    devices, like most ARMs people will build Redis on, is extremely</span></span><br><span class="line"><span class="string">    slow. It is possible to enable Jemalloc build anyway if needed</span></span><br><span class="line"><span class="string">    by using "make MALLOC=jemalloc".</span></span><br></pre></td></tr></table></figure><p>因为 commit id 就是之前的 arm 分支最新的记录，所以这个命令等价于 <code>git log -2 arm</code></p><h3 id="查询指定-commit-之间的提交记录"><a href="#查询指定-commit-之间的提交记录" class="headerlink" title="查询指定 commit 之间的提交记录"></a>查询指定 commit 之间的提交记录</h3><p>如果想查询两个 commit 之前的提交记录，可以将两个 commit id 依次放在命令后面并用 <code>..</code> 连接就可以了，格式为 <code>git log commit1..commit2</code>，需要注意的是这样查询出来的提交记录列表中不包含 commit1，其实列举出的就是 commit1 之后又做了哪些修改提交。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> e15528bf1da1f1232fd08801ad382c915be94662..7bf665f125a4771db095c83a7ad6ed46692cd314</span><br><span class="line">commit 7bf665f125a4771db095c83a7ad6ed46692cd314 (HEAD -&gt; 6.0, tag: 6.0.6, origin/6.0)</span><br><span class="line">Author: Oran Agra &lt;oran@redislabs.com&gt;</span><br><span class="line">Date:   Sun Jul 19 14:00:20 2020 +0300</span><br><span class="line"></span><br><span class="line">    Redis 6.0.6.</span><br><span class="line"></span><br><span class="line">commit a5696bdf4f2687ab45f633ccb7cdc4ee9c2f957d</span><br><span class="line">Author: Oran Agra &lt;oran@redislabs.com&gt;</span><br><span class="line">Date:   Sun Jul 19 15:33:21 2020 +0300</span><br><span class="line"></span><br><span class="line">    Run daily CI on PRs to release a branch</span><br></pre></td></tr></table></figure><p>这个特性有一个应用就是在 merge 分支之前可以查询究竟会 merge 哪些记录，常见的用法比如 <code>git log feature..dev</code> 就是列举出 feature 分支合并到 dev 分支将要合并的提交记录有哪些。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> 6.0..unstable</span><br><span class="line">commit 324e22accf457edc996971bc97f5474349cd7c4c (unstable)</span><br><span class="line">Author: antirez &lt;antirez@gmail.com&gt;</span><br><span class="line">Date:   Fri Dec 20 12:29:02 2019 +0100</span><br><span class="line"></span><br><span class="line">    Fix ip and missing mode <span class="keyword">in</span> RM_GetClusterNodeInfo().</span><br></pre></td></tr></table></figure><h3 id="查询指定文件的提交记录"><a href="#查询指定文件的提交记录" class="headerlink" title="查询指定文件的提交记录"></a>查询指定文件的提交记录</h3><p>查询指定文件的提交记录一般直接在 <code>git log</code> 命令后面跟上文件名就可以，但是为了避免和分支名产生分歧，所以通常在文件名前面加上 <code>--</code> 用来区分，<code>--</code> 这个标识符就是用来防止混淆的，放在 <code>--</code> 前面的是分支名，放在后面的是文件名，相同的作用不仅仅在 <code>git log</code> 命令中，在其他命令比如 <code>git checkout</code> 中也有相同的用法。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> -2 -- redis.conf</span><br><span class="line">commit 7a536c2912be1fd9f62b26b7022a00644c88ef8b</span><br><span class="line">Author: Yossi Gottlieb &lt;yossigo@users.noreply.github.com&gt;</span><br><span class="line">Date:   Fri Jul 10 11:33:47 2020 +0300</span><br><span class="line"></span><br><span class="line">    TLS: Session caching configuration support. (<span class="comment">#7420)</span></span><br><span class="line"></span><br><span class="line">    * TLS: Session caching configuration support.</span><br><span class="line">    * TLS: Remove redundant config initialization.</span><br><span class="line"></span><br><span class="line">    (cherry picked from commit 3e6f2b1a45176ac3d81b95cb6025f30d7aaa1393)</span><br><span class="line"></span><br><span class="line">commit 8312aa27d47c0befcf69eb74d0a5dc19745ffd32</span><br><span class="line">Author: antirez &lt;antirez@gmail.com&gt;</span><br><span class="line">Date:   Mon Jun 22 11:21:21 2020 +0200</span><br><span class="line"></span><br><span class="line">    Clarify maxclients and cluster <span class="keyword">in</span> conf. Remove myself too.</span><br><span class="line"></span><br><span class="line">    (cherry picked from commit 59fd178014c7cca1b0c668b30ab0d991dd3030f3)</span><br></pre></td></tr></table></figure><h2 id="显示格式"><a href="#显示格式" class="headerlink" title="显示格式"></a>显示格式</h2><p><code>git log</code> 除了可以筛选提交记录，还可以控制显示格式，普通不加参数，会显示作者、邮件、提交描述信息、日期等信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> -1</span><br><span class="line">commit 7bf665f125a4771db095c83a7ad6ed46692cd314 (HEAD -&gt; 6.0, tag: 6.0.6, origin/6.0)</span><br><span class="line">Author: Oran Agra &lt;oran@redislabs.com&gt;</span><br><span class="line">Date:   Sun Jul 19 14:00:20 2020 +0300</span><br><span class="line"></span><br><span class="line">    Redis 6.0.6.</span><br></pre></td></tr></table></figure><p>通过添加参数可以控制和改变显示格式，下面来看几条常见的</p><h3 id="显示单行信息"><a href="#显示单行信息" class="headerlink" title="显示单行信息"></a>显示单行信息</h3><p><code>git log</code> 默认会显示多行信息，使用 <code>--oneline</code> 后每条提交记录只显示一行信息，可以在一屏幕中查看到更多的信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> -10 --oneline</span><br><span class="line">7bf665f12 (HEAD -&gt; 6.0, tag: 6.0.6, origin/6.0) Redis 6.0.6.</span><br><span class="line">a5696bdf4 Run daily CI on PRs to release a branch</span><br><span class="line">e15528bf1 Adds SHA256SUM to redis-stable tarball upload</span><br><span class="line">e28aa99af Support passing stack allocated module strings to moduleCreateArgvFromUserFormat (<span class="comment">#7528)</span></span><br><span class="line">305143004 Send null <span class="keyword">for</span> invalidate on flush (<span class="comment">#7469)</span></span><br><span class="line">29b20fd52 Notify systemd on sentinel startup (<span class="comment">#7168)</span></span><br><span class="line">5b3668121 Add registers dump support <span class="keyword">for</span> Apple silicon (<span class="comment">#7453)</span></span><br><span class="line">0f75036c0 correct error msg <span class="keyword">for</span> num connections reaching maxclients <span class="keyword">in</span> cluster mode (<span class="comment">#7444)</span></span><br><span class="line">b1a01fda9 Fix <span class="built_in">command</span> <span class="built_in">help</span> <span class="keyword">for</span> unexpected options (<span class="comment">#7476)</span></span><br><span class="line">83f55f61a Refactor RM_KeyType() by using macro. (<span class="comment">#7486)</span></span><br></pre></td></tr></table></figure><h3 id="显示每条记录中文件修改的具体行数和行体统计"><a href="#显示每条记录中文件修改的具体行数和行体统计" class="headerlink" title="显示每条记录中文件修改的具体行数和行体统计"></a>显示每条记录中文件修改的具体行数和行体统计</h3><p>使用 <code>--stat</code> 参数就可以显示每条记录的中修改文件的具体行数和行数统计</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> -2 --<span class="built_in">stat</span></span><br><span class="line">commit 7bf665f125a4771db095c83a7ad6ed46692cd314 (HEAD -&gt; 6.0, tag: 6.0.6, origin/6.0)</span><br><span class="line">Author: Oran Agra &lt;oran@redislabs.com&gt;</span><br><span class="line">Date:   Sun Jul 19 14:00:20 2020 +0300</span><br><span class="line"></span><br><span class="line">    Redis 6.0.6.</span><br><span class="line"></span><br><span class="line"> 00-RELEASENOTES | 245 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span><br><span class="line"> src/help.h      |   4 +-</span><br><span class="line"> src/version.h   |   2 +-</span><br><span class="line"> 3 files changed, 248 insertions(+), 3 deletions(-)</span><br><span class="line"></span><br><span class="line">commit a5696bdf4f2687ab45f633ccb7cdc4ee9c2f957d</span><br><span class="line">Author: Oran Agra &lt;oran@redislabs.com&gt;</span><br><span class="line">Date:   Sun Jul 19 15:33:21 2020 +0300</span><br><span class="line"></span><br><span class="line">    Run daily CI on PRs to release a branch</span><br><span class="line"></span><br><span class="line"> .github/workflows/daily.yml | 6 ++++--</span><br><span class="line"> 1 file changed, 4 insertions(+), 2 deletions(-)</span><br></pre></td></tr></table></figure><h3 id="显示每条提交记录中文件的增加行数和删除行数"><a href="#显示每条提交记录中文件的增加行数和删除行数" class="headerlink" title="显示每条提交记录中文件的增加行数和删除行数"></a>显示每条提交记录中文件的增加行数和删除行数</h3><p>使用 <code>--numstat</code> 参数会把 <code>--stat</code> 参数中合并显示的修改行数拆分成增加行数和删除行数</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> -2 --numstat</span><br><span class="line">commit 7bf665f125a4771db095c83a7ad6ed46692cd314 (HEAD -&gt; 6.0, tag: 6.0.6, origin/6.0)</span><br><span class="line">Author: Oran Agra &lt;oran@redislabs.com&gt;</span><br><span class="line">Date:   Sun Jul 19 14:00:20 2020 +0300</span><br><span class="line"></span><br><span class="line">    Redis 6.0.6.</span><br><span class="line"></span><br><span class="line">245     0       00-RELEASENOTES</span><br><span class="line">2       2       src/help.h</span><br><span class="line">1       1       src/version.h</span><br><span class="line"></span><br><span class="line">commit a5696bdf4f2687ab45f633ccb7cdc4ee9c2f957d</span><br><span class="line">Author: Oran Agra &lt;oran@redislabs.com&gt;</span><br><span class="line">Date:   Sun Jul 19 15:33:21 2020 +0300</span><br><span class="line"></span><br><span class="line">    Run daily CI on PRs to release a branch</span><br><span class="line"></span><br><span class="line">4       2       .github/workflows/daily.yml</span><br></pre></td></tr></table></figure><h3 id="依次罗列各提交记录中每个文件中增加的行数和删除的行数"><a href="#依次罗列各提交记录中每个文件中增加的行数和删除的行数" class="headerlink" title="依次罗列各提交记录中每个文件中增加的行数和删除的行数"></a>依次罗列各提交记录中每个文件中增加的行数和删除的行数</h3><p>要想达到这个目的需要用到 <code>--prety=tformat: --numstat</code> 参数，这样的显示格式便于统计</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> -2 --pretty=tformat: --numstat</span><br><span class="line">245     0       00-RELEASENOTES</span><br><span class="line">2       2       src/help.h</span><br><span class="line">1       1       src/version.h</span><br><span class="line">4       2       .github/workflows/daily.yml</span><br></pre></td></tr></table></figure><h1 id="统计修改的代码行数"><a href="#统计修改的代码行数" class="headerlink" title="统计修改的代码行数"></a>统计修改的代码行数</h1><p>有了前面的铺垫，想要统一修改的行数就容易了，只要配合 <code>awk</code> 工具就可以完成统计了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ $ git <span class="built_in">log</span> -2 --pretty=tformat: --numstat  | awk <span class="string">'&#123;adds += $1; subs += $2; diffs += $1 - $2&#125; END &#123;printf "added lines: %s removed lines: %s, diff lines: %s\n", adds, subs, diffs&#125;'</span></span><br><span class="line">added lines: 252 removed lines: 5, diff lines: 247</span><br></pre></td></tr></table></figure><p>还可以统计两个分支相差的代码行数</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> 6.0..unstable --pretty=tformat: --numstat  | awk <span class="string">'&#123;adds += $1; subs += $2; diffs += $1 - $2&#125; END &#123;printf "added lines: %s removed lines: %s, diff lines: %s\n", adds, subs, diffs&#125;'</span></span><br><span class="line">added lines: 5 removed lines: 2, diff lines: 3</span><br></pre></td></tr></table></figure><p>到这里可以发现前面的知识都可以用上，前面筛选的参数变了，得到的结果就变了，我们可以根据需求来调整不同的参数</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li><code>git log</code> 就是一部代码库记录的“史书”，对于曾经所做的修改可以做到有史可查</li><li><code>git log</code> 的选项参数可以分为筛选参数和格式参数，筛选参数可以选择记录范围，格式参数可以控制显示样式</li><li>统计就是按照一定规律来将数据进行汇总，在进行汇总前需要将数据进行整理，这样汇总的工作才会更加顺利</li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/108311845" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>慌慌张张，匆匆忙忙，原来生活就是这样~</p><p>2020-9-7 00:05:18</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200907002654523.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9hbGJlcnRnaXRodWJob21lLmdpdGh1Yi5pby9ibG9nL2Fib3V0,size_10,color_FFFFFF,t_70#pic_center&quot; alt=&quot;gitlog&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;随着年龄的增长和知识的积累，最近常常有种豁然开朗的感觉，或者对一个已经存在的事物突然有了新的认识，比如统计这个词很早就接触了，从没考虑过它是什么意思，而这篇总结的题目中用了统计一词，第一感觉应该是汇总、记录的意思，后来去查了词条定义，也确实就是类似的解释，从没有刻意去学这个词的含义，但是在每天的生活中已经潜移默化地归纳、总结出来了。&lt;/p&gt;
    
    </summary>
    
      <category term="Git" scheme="http://AlbertGithubHome.github.io/blog/categories/Git/"/>
    
    
      <category term="git" scheme="http://AlbertGithubHome.github.io/blog/tags/git/"/>
    
      <category term="log" scheme="http://AlbertGithubHome.github.io/blog/tags/log/"/>
    
      <category term="awk" scheme="http://AlbertGithubHome.github.io/blog/tags/awk/"/>
    
      <category term="统计" scheme="http://AlbertGithubHome.github.io/blog/tags/%E7%BB%9F%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>Python中时间戳、时间字符串、时间结构对象之间的相互转化</title>
    <link href="http://AlbertGithubHome.github.io/blog/2020/08/27/Python%E4%B8%AD%E6%97%B6%E9%97%B4%E6%88%B3%E3%80%81%E6%97%B6%E9%97%B4%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%81%E6%97%B6%E9%97%B4%E7%BB%93%E6%9E%84%E5%AF%B9%E8%B1%A1%E4%B9%8B%E9%97%B4%E7%9A%84%E7%9B%B8%E4%BA%92%E8%BD%AC%E5%8C%96/"/>
    <id>http://AlbertGithubHome.github.io/blog/2020/08/27/Python中时间戳、时间字符串、时间结构对象之间的相互转化/</id>
    <published>2020-08-27T15:32:21.000Z</published>
    <updated>2020-09-02T15:49:01.373Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>使用 Python 写程序的时候常常要查看中间结果，需要把一些内容记录到日志中，为了不让新产生的日志覆盖之前的日志文件，所以通常使用时间字符串来作为文件名，类似于 <code>2020827_233842.log</code> 这种格式，就是表示程序在 2020-8-27 23:38:42 启动时产生的日志文件。</p><a id="more"></a><p>日志文件名需要一个字符串，但是这个时间字符串不能直接得到，需要将时间戳经过转化才可以，每次用到都要查一次有些浪费时间，总结到一起方便自己今后快速查找。</p><p>通过学习总结发现，操作时间和日期常用的模块有 <code>time</code> 和 <code>datetime</code> 这两个，并且 <code>time</code> 模块与 C 语言中的时间处理函数颇为相似，下面来一起看一下吧。</p><h1 id="时间的表示形式"><a href="#时间的表示形式" class="headerlink" title="时间的表示形式"></a>时间的表示形式</h1><p>显示生活中的时间表示形式多种多样，比如15分钟可以说成是1刻钟，半夜12点可以叫做子时，在程序中也有几种常用的表示形式，比如 python 中的时间戳、时间结构对象和时间字符串，分别对应 <code>C</code> 语言中的<code>time_t</code>、<code>struct tm</code> 和 <code>char[]</code>，处理函数的名字也很相近，自己可以扩展学习下，本文只列举 <code>Python</code> 的用法了</p><h2 id="时间戳"><a href="#时间戳" class="headerlink" title="时间戳"></a>时间戳</h2><p>在Python中被实现成一个浮点数，表示从1970年1月1日00:00:00到当前时间所经历的秒数，因为是浮点数所以可以表示不足1秒的时间，而在有些语言中，比如<code>C</code> 语言中使用整数来表示这个值，在 python 中使用 <code>time.time()</code> 函数来获取时间戳：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">val = time.time()</span><br><span class="line">print(val, type(val))</span><br><span class="line"></span><br><span class="line"><span class="string">'''输出结果</span></span><br><span class="line"><span class="string">1598769108.8337526 &lt;class 'float'&gt;</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><h2 id="时间结构对象"><a href="#时间结构对象" class="headerlink" title="时间结构对象"></a>时间结构对象</h2><p>在 python 中使用 <code>time.struct_time</code> 这个类用来表示时间结构，其实是一个九元组，可以参考C语言中的 <code>struct tm</code>结构，表现形式相同，在 python 中这个九元组中元素依次表达的含义是：4位数年份、1-12月、1-31日、0-23小时、0-59分钟，0-59秒，0-6一周第几日，1-366一年第几日，{-1, 0, 1}夏令时标志。</p><p>通过代码我们可以尝试构造如下，不够时间使用时通常是通过函数转化，很少直接构造 <code>time.struct_time</code> 对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">val = time.struct_time([<span class="number">2020</span>, <span class="number">8</span>, <span class="number">30</span>, <span class="number">14</span>, <span class="number">45</span>, <span class="number">30</span>, <span class="number">6</span>, <span class="number">243</span>, <span class="number">0</span>])</span><br><span class="line">print(val, type(val))</span><br><span class="line"></span><br><span class="line"><span class="string">'''输出结果</span></span><br><span class="line"><span class="string">time.struct_time(tm_year=2020, tm_mon=8, tm_mday=30, tm_hour=14,</span></span><br><span class="line"><span class="string">    tm_min=45, tm_sec=30, tm_wday=6, tm_yday=243, tm_isdst=0) &lt;class 'time.struct_time'&gt;</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><h2 id="时间字符串"><a href="#时间字符串" class="headerlink" title="时间字符串"></a>时间字符串</h2><p>时间字符串是本质上是一种普通的字符串，因为用来表示时间所以感觉上有些不同，实际使用过程时会通过转化函数来生成时间字符串，然后就可以当场普通字符串来使用了，比如记录日志时间，作为文件名等都是常见用法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">val = <span class="string">'2019-08-30 15:04:00'</span></span><br><span class="line">print(val, type(val))</span><br><span class="line"></span><br><span class="line"><span class="string">'''输出结果</span></span><br><span class="line"><span class="string">2019-08-30 15:04:00 &lt;class 'str'&gt;</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><h1 id="举例说明"><a href="#举例说明" class="headerlink" title="举例说明"></a>举例说明</h1><p>仅仅认识了这三种类型还是不够的，还要学习经常使用的转化函数才可以，上面提到的这三种类型一般不会从时间戳到字符串或者从字符戳到时间戳，都是通过时间结构对象来转化的，所以常见的转化是时间戳和时间结构对象的转化、时间结构对象和时间字符串的转化，需要用到的函数展示如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/albertgithubhome/cdn/img/python_time.png" alt="python_time"></p><h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成时间戳</span></span><br><span class="line">t = time.time()</span><br><span class="line">print(t, type(t))</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">1598775821.840567 &lt;class 'float'&gt;</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成时间结构对象(本地时间)</span></span><br><span class="line">l = time.localtime()</span><br><span class="line">print(l, type(l))</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">time.struct_time(tm_year=2020, tm_mon=8, tm_mday=30, tm_hour=16, tm_min=23,</span></span><br><span class="line"><span class="string"> tm_sec=41, tm_wday=6, tm_yday=243, tm_isdst=0) &lt;class 'time.struct_time'&gt;</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 时间戳 -&gt; 时间结构对象(本地时间)</span></span><br><span class="line">l = time.localtime(t)</span><br><span class="line">print(l, type(l))</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">time.struct_time(tm_year=2020, tm_mon=8, tm_mday=30, tm_hour=16, tm_min=23,</span></span><br><span class="line"><span class="string"> tm_sec=41, tm_wday=6, tm_yday=243, tm_isdst=0) &lt;class 'time.struct_time'&gt;</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成时间结构对象(格林威治时间)</span></span><br><span class="line">g = time.gmtime()</span><br><span class="line">print(g, type(g))</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">time.struct_time(tm_year=2020, tm_mon=8, tm_mday=30, tm_hour=8, tm_min=23,</span></span><br><span class="line"><span class="string"> tm_sec=41, tm_wday=6, tm_yday=243, tm_isdst=0) &lt;class 'time.struct_time'&gt;</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 时间戳 -&gt; 时间结构对象(格林威治时间)</span></span><br><span class="line">g = time.gmtime(t)</span><br><span class="line">print(g, type(g))</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">time.struct_time(tm_year=2020, tm_mon=8, tm_mday=30, tm_hour=8, tm_min=23,</span></span><br><span class="line"><span class="string"> tm_sec=41, tm_wday=6, tm_yday=243, tm_isdst=0) &lt;class 'time.struct_time'&gt;</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成时间字符串</span></span><br><span class="line">s = time.strftime(<span class="string">"%Y-%m-%d %X"</span>)</span><br><span class="line">print(s, type(s))</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">2020-08-30 16:23:41 &lt;class 'str'&gt;</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 时间结构对象 -&gt; 时间字符串</span></span><br><span class="line">s = time.strftime(<span class="string">"%Y-%m-%d %X"</span>,time.localtime())</span><br><span class="line">print(s, type(s))</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">2020-08-30 16:23:41 &lt;class 'str'&gt;</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"><span class="string">'================================================================='</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义时间字符串</span></span><br><span class="line">s = <span class="string">'2022-02-18 09:30:00'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 时间字符串 -&gt; 时间结构对象</span></span><br><span class="line">l = time.strptime(s, <span class="string">'%Y-%m-%d %X'</span>)</span><br><span class="line">print(l, type(l))</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">time.struct_time(tm_year=2022, tm_mon=2, tm_mday=18, tm_hour=9, tm_min=30,</span></span><br><span class="line"><span class="string"> tm_sec=0, tm_wday=4, tm_yday=49, tm_isdst=-1) &lt;class 'time.struct_time'&gt;</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 时间结构对象 -&gt; 时间戳</span></span><br><span class="line">t = time.mktime(l)</span><br><span class="line">print(t, type(t))</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">1645147800.0 &lt;class 'float'&gt;</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"><span class="string">'================================================================='</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成固定格式(%a %b %d %H:%M:%S %Y)时间字符串</span></span><br><span class="line">s = time.asctime(time.localtime())</span><br><span class="line">print(s, type(s))</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">Sun Aug 30 16:23:41 2020 &lt;class 'str'&gt;</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line">s = time.ctime(time.time())</span><br><span class="line">print(s, type(s))</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">Sun Aug 30 16:23:41 2020 &lt;class 'str'&gt;</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><h2 id="格式化符号"><a href="#格式化符号" class="headerlink" title="格式化符号"></a>格式化符号</h2><p>将时间转化成字符串表示形式的时候，需要使用格式化符号，为了查找方便整理如下：</p><table><thead><tr><th><strong>格式</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>%a</td><td>本地（locale）简化星期名称</td></tr><tr><td>%A</td><td>本地完整星期名称</td></tr><tr><td>%b</td><td>本地简化月份名称</td></tr><tr><td>%B</td><td>本地完整月份名称</td></tr><tr><td>%c</td><td>本地相应的日期和时间表示</td></tr><tr><td>%d</td><td>一个月中的第几天（01 - 31）</td></tr><tr><td>%H</td><td>一天中的第几个小时（24小时制，00 - 23）</td></tr><tr><td>%I</td><td>第几个小时（12小时制，01 - 12）</td></tr><tr><td>%j</td><td>一年中的第几天（001 - 366）</td></tr><tr><td>%m</td><td>月份（01 - 12）</td></tr><tr><td>%M</td><td>分钟数（00 - 59）</td></tr><tr><td>%p</td><td>本地am或者pm的相应符</td></tr><tr><td>%S</td><td>秒（00 - 59）</td></tr><tr><td>%U</td><td>一年中的星期数。（00 - 53星期天是一个星期的开始。）</td></tr><tr><td>%w</td><td>一个星期中的第几天（0 - 6，0是星期天）</td></tr><tr><td>%W</td><td>和%U基本相同，不同的是%W以星期一为一个星期的开始。</td></tr><tr><td>%x</td><td>本地相应日期</td></tr><tr><td>%X</td><td>本地相应时间</td></tr><tr><td>%y</td><td>去掉世纪的年份（00 - 99）</td></tr><tr><td>%Y</td><td>完整的年份</td></tr><tr><td>%Z</td><td>时区的名字（如果不存在为空字符）</td></tr></tbody></table><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>时间戳和时间字符串的转化，通常要经过时间结构对象作为中间结果。</li><li>时间戳也可以通过 <code>time.ctime()</code> 函数直接转化为时间字符串，但格式固定。</li><li>常用来表示文件名的时间字符串写法：<code>time.strftime(&quot;%Y%m%d_%H%M%S&quot;, time.localtime())</code></li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/108212001" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>有时选择的意义确实高于努力的结果，认清这一点，学会适当的放下，会让焦躁的生活更美好一点，毕竟全部都坚持真的太累了，有时收益真的不高~</p><p>2020-8-30 21:50:19</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;使用 Python 写程序的时候常常要查看中间结果，需要把一些内容记录到日志中，为了不让新产生的日志覆盖之前的日志文件，所以通常使用时间字符串来作为文件名，类似于 &lt;code&gt;2020827_233842.log&lt;/code&gt; 这种格式，就是表示程序在 2020-8-27 23:38:42 启动时产生的日志文件。&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="http://AlbertGithubHome.github.io/blog/categories/Python/"/>
    
    
      <category term="Python" scheme="http://AlbertGithubHome.github.io/blog/tags/Python/"/>
    
      <category term="time" scheme="http://AlbertGithubHome.github.io/blog/tags/time/"/>
    
      <category term="datetime" scheme="http://AlbertGithubHome.github.io/blog/tags/datetime/"/>
    
      <category term="转化" scheme="http://AlbertGithubHome.github.io/blog/tags/%E8%BD%AC%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>GDB调试指北-启动调试或者附加到进程</title>
    <link href="http://AlbertGithubHome.github.io/blog/2020/08/17/GDB%E8%B0%83%E8%AF%95%E6%8C%87%E5%8C%97-%E5%90%AF%E5%8A%A8%E8%B0%83%E8%AF%95%E6%88%96%E8%80%85%E9%99%84%E5%8A%A0%E5%88%B0%E8%BF%9B%E7%A8%8B/"/>
    <id>http://AlbertGithubHome.github.io/blog/2020/08/17/GDB调试指北-启动调试或者附加到进程/</id>
    <published>2020-08-17T15:45:15.000Z</published>
    <updated>2020-09-02T16:23:47.618Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>要想使用 <code>gdb</code> 调试程序，必须让 <code>gdb</code> 程序和被调试程序建立联系，这种联系可以通过程序的可执行文件、core文件或者正在运行的进程来建立，具体调试的时候使用的选项不同，涉及到参数的传递，选项的顺序，多进程启动前的设置等等，接下来可以看一些常见用法。</p><a id="more"></a><h1 id="测试样例"><a href="#测试样例" class="headerlink" title="测试样例"></a>测试样例</h1><p>首先来写一段简单的但是会自动崩溃的代码，主要是为了展示core文件的调试方法，通过调试崩溃产生的core文件是一种很直接的查找问题的方法，可以帮助我们快速定位到问题的栈帧，进而找到具体的逻辑代码。</p><h2 id="代码内容"><a href="#代码内容" class="headerlink" title="代码内容"></a>代码内容</h2><p>新建文件 examplepro.cpp，编写代码内容如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc &gt; <span class="number">1</span>)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"argv[1] = "</span> &lt;&lt; argv[<span class="number">1</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">3</span>, b = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">int</span> c = a + b;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"c = "</span> &lt;&lt; c &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> *p = <span class="literal">NULL</span>;</span><br><span class="line">    *p = c;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="代码编译"><a href="#代码编译" class="headerlink" title="代码编译"></a>代码编译</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ examplepro.cpp -o examplepro -g</span><br></pre></td></tr></table></figure><h2 id="运行程序"><a href="#运行程序" class="headerlink" title="运行程序"></a>运行程序</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:~/WorkSpace/cpp$ ./examplepro</span><br><span class="line">c = 7</span><br><span class="line">Segmentation fault (core dumped)</span><br></pre></td></tr></table></figure><p>我们发现程序在运行之后发生了段错误，这是一种比较常见的BUG，通常由访问无效内存导致，查看程序目录下内容，多了一个叫 <code>core</code> 的文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:~/WorkSpace/cpp$ ls</span><br><span class="line">core  examplepro  examplepro.cpp</span><br></pre></td></tr></table></figure><p>通过这一步你可能看不到这个 <code>core</code> 文件，需要检查两点，第一是编译的时候需要加 <code>-g</code> 选项，第二是使用 <code>ulimit -c unlimited</code> 命令设置core文件占用空间的最小限制，默认大小为0，也就是不产生 <code>core</code> 文件，需要改为 <code>unlimited</code> 才可以，如果你确定产生的 <code>core</code> 文件不会太大，也可以设置一个具体的数值。</p><h1 id="使用gdb调试"><a href="#使用gdb调试" class="headerlink" title="使用gdb调试"></a>使用gdb调试</h1><p>有了上面的程序我们就可以进行调试了，因为已经产生了 core 文件，所以先来调试一下 core 文件，看下程序崩溃的原因。</p><h2 id="使用gdb调试core文件"><a href="#使用gdb调试core文件" class="headerlink" title="使用gdb调试core文件"></a>使用gdb调试core文件</h2><p>启动程序的语法如下，<code>gdb</code> 命令之后跟程序名，然后后面跟着 core 文件的名字：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gdb examplepro core</span><br></pre></td></tr></table></figure><p>具体调试的时候需要换成自己的崩溃的程序名，而core文件大多数是 <code>core.进程id</code> 的形式。</p><h3 id="调试过程"><a href="#调试过程" class="headerlink" title="调试过程"></a>调试过程</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:~/WorkSpace/cpp$ gdb examplepro core</span><br><span class="line">GNU gdb (Ubuntu 7.11.1-0ubuntu1~16.5) 7.11.1</span><br><span class="line">Copyright (C) 2016 Free Software Foundation, Inc.</span><br><span class="line">License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;</span><br><span class="line">This is free software: you are free to change and redistribute it.</span><br><span class="line">There is NO WARRANTY, to the extent permitted by law.  Type <span class="string">"show copying"</span></span><br><span class="line">and <span class="string">"show warranty"</span> <span class="keyword">for</span> details.</span><br><span class="line">This GDB was configured as <span class="string">"x86_64-linux-gnu"</span>.</span><br><span class="line">Type <span class="string">"show configuration"</span> <span class="keyword">for</span> configuration details.</span><br><span class="line">For bug reporting instructions, please see:</span><br><span class="line">&lt;http://www.gnu.org/software/gdb/bugs/&gt;.</span><br><span class="line">Find the GDB manual and other documentation resources online at:</span><br><span class="line">&lt;http://www.gnu.org/software/gdb/documentation/&gt;.</span><br><span class="line">For <span class="built_in">help</span>, <span class="built_in">type</span> <span class="string">"help"</span>.</span><br><span class="line">Type <span class="string">"apropos word"</span> to search <span class="keyword">for</span> commands related to <span class="string">"word"</span>...</span><br><span class="line">Reading symbols from examplepro...done.</span><br><span class="line">[New LWP 19786]</span><br><span class="line">Core was generated by `./examplepro<span class="string">'.</span></span><br><span class="line"><span class="string">Program terminated with signal SIGSEGV, Segmentation fault.</span></span><br><span class="line"><span class="string">#0  0x0000000000400932 in main (argc=1, argv=0x7ffd23cc3a18) at examplepro.cpp:15</span></span><br><span class="line"><span class="string">15      *p = c;</span></span><br><span class="line"><span class="string">(gdb)</span></span><br></pre></td></tr></table></figure><p>从调试信息来看一下就定位到了问题，在代码的第15行发生了段错误，也就是我们刚刚给野指针赋值的代码。</p><h2 id="使用gdb直接启动程序"><a href="#使用gdb直接启动程序" class="headerlink" title="使用gdb直接启动程序"></a>使用gdb直接启动程序</h2><p>这种情况就是调试运行，相当于在 <code>gdb</code> 的监控下启动程序，一旦发生错误，<code>gdb</code> 会给出响应的提示，启动方式很简单，<code>gdb</code> 命令之后直接跟着程序名字就可以了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gdb examplepro</span><br></pre></td></tr></table></figure><h3 id="调试过程-1"><a href="#调试过程-1" class="headerlink" title="调试过程"></a>调试过程</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:~/WorkSpace/cpp$ gdb examplepro</span><br><span class="line">GNU gdb (Ubuntu 7.11.1-0ubuntu1~16.5) 7.11.1</span><br><span class="line">Copyright (C) 2016 Free Software Foundation, Inc.</span><br><span class="line">License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;</span><br><span class="line">This is free software: you are free to change and redistribute it.</span><br><span class="line">There is NO WARRANTY, to the extent permitted by law.  Type <span class="string">"show copying"</span></span><br><span class="line">and <span class="string">"show warranty"</span> <span class="keyword">for</span> details.</span><br><span class="line">This GDB was configured as <span class="string">"x86_64-linux-gnu"</span>.</span><br><span class="line">Type <span class="string">"show configuration"</span> <span class="keyword">for</span> configuration details.</span><br><span class="line">For bug reporting instructions, please see:</span><br><span class="line">&lt;http://www.gnu.org/software/gdb/bugs/&gt;.</span><br><span class="line">Find the GDB manual and other documentation resources online at:</span><br><span class="line">&lt;http://www.gnu.org/software/gdb/documentation/&gt;.</span><br><span class="line">For <span class="built_in">help</span>, <span class="built_in">type</span> <span class="string">"help"</span>.</span><br><span class="line">Type <span class="string">"apropos word"</span> to search <span class="keyword">for</span> commands related to <span class="string">"word"</span>...</span><br><span class="line">Reading symbols from examplepro...done.</span><br><span class="line">(gdb) run</span><br><span class="line">Starting program: /home/albert/WorkSpace/cpp/examplepro</span><br><span class="line">c = 7</span><br><span class="line"></span><br><span class="line">Program received signal SIGSEGV, Segmentation fault.</span><br><span class="line">0x0000000000400932 <span class="keyword">in</span> main (argc=1, argv=0x7fffffffdd18) at examplepro.cpp:15</span><br><span class="line">15      *p = c;</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure><p>这种情况下，启动之后需要输入 <code>run</code> 命令才可以运行程序，这时发现程序又崩溃了。</p><p>如果被调试的程序有参数的话，需要将启动的命令进行修改，写成 <code>gdb --args examplepro testparam1</code>，加上 <code>--args</code> 选项，然后将参数罗列在后面就好了，因为看这些声明很麻烦，我们利用之前学过的 <code>-q</code> 选项来屏蔽启动说明，测试如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:~/WorkSpace/cpp$ gdb -q --args examplepro NB</span><br><span class="line">Reading symbols from examplepro...done.</span><br><span class="line">(gdb) run</span><br><span class="line">Starting program: /home/albert/WorkSpace/cpp/examplepro NB</span><br><span class="line">argv[1] = NB</span><br><span class="line">c = 7</span><br><span class="line"></span><br><span class="line">Program received signal SIGSEGV, Segmentation fault.</span><br><span class="line">0x0000000000400932 <span class="keyword">in</span> main (argc=2, argv=0x7fffffffdd08) at examplepro.cpp:15</span><br><span class="line">15      *p = c;</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure><p>还有一种写法就是启动 gdb 之后再传参数，具体操作方法如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:~/WorkSpace/cpp$ gdb -q examplepro</span><br><span class="line">Reading symbols from examplepro...done.</span><br><span class="line">(gdb) run NB</span><br><span class="line">Starting program: /home/albert/WorkSpace/cpp/examplepro NB</span><br><span class="line">argv[1] = NB</span><br><span class="line">c = 7</span><br><span class="line"></span><br><span class="line">Program received signal SIGSEGV, Segmentation fault.</span><br><span class="line">0x0000000000400932 <span class="keyword">in</span> main (argc=2, argv=0x7fffffffdd08) at examplepro.cpp:15</span><br><span class="line">15      *p = c;</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure><p>这种情况是先启动 gdb，然后在执行 <code>run</code> 命令的时候传递参数。</p><h2 id="使用gdb调试正在运行的文件"><a href="#使用gdb调试正在运行的文件" class="headerlink" title="使用gdb调试正在运行的文件"></a>使用gdb调试正在运行的文件</h2><p>这时需要获得被套是程序的进程id，可以使用 <code>ps</code>、<code>top</code> 或者 <code>pidof</code> 命令来获取进程id，然后通过 <code>attch</code> 的方式附加到进程。</p><p>比如查到需要调试的 examplepro 程序进程号是 3598，那么可以直接启动 <code>gdb</code> 附加到这个进程：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gdb examplepro 3598</span><br></pre></td></tr></table></figure><p>也可以先启动 <code>gdb</code>，然后使用 <code>attach</code> 命令附加到进程：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:~/WorkSpace/cpp$ gdb -q examplepro</span><br><span class="line">Reading symbols from examplepro...done.</span><br><span class="line">(gdb) attach 3598</span><br></pre></td></tr></table></figure><p>如果此时提示进程拒绝被附加通常是权限问题，可以使用所属账号调试，或者可以尝试 <code>sudo</code> 命令。</p><h1 id="语法对比"><a href="#语法对比" class="headerlink" title="语法对比"></a>语法对比</h1><p>常见的调试方式就文中提到的这几种，特整理成表格方便对比和查找：</p><table><thead><tr><th>语法</th><th>解释</th></tr></thead><tbody><tr><td><code>gdb examlepro</code></td><td>直接 gdb 调试启动</td></tr><tr><td><code>gdb examlepro core.3598</code></td><td>调试崩溃的 core 文件</td></tr><tr><td><code>gdb examlepro 3598</code><br><code>gdb -p 3598</code></td><td>附加到正在运行的程序进程上</td></tr><tr><td><code>gdb</code><br> <code>attach 3598</code></td><td>先启动gdb，后附加到程序上</td></tr></tbody></table><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>gdb 不但可以调试 core 文件，还可以调试正在运行的程序，这对于难重现的 bug 来说非常有帮助</li><li>在调试正在运行的程序时可以使用 <code>pidof</code> 命令来直接获取被调试程序的进程号</li><li>gdb 调试附加的进程的时候要注意权限问题，如果不成功可以尝试 sudo 命令</li></ul><hr><h2 id="gt-gt-反爬链接，请勿点击，原地爆炸，概不负责！-lt-lt"><a href="#gt-gt-反爬链接，请勿点击，原地爆炸，概不负责！-lt-lt" class="headerlink" title=" ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== "></a><center><a href="https://blog.csdn.net/albertsh/article/details/108030540" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center></h2><blockquote><p>兜兜转转又换了一个住所，匆匆忙忙如蝼蚁般迁徙，路程短了，可选的路却少了。回头看看，一个窝、一段事、一群人而已~</p><p>2020-8-25 00:24:01</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;要想使用 &lt;code&gt;gdb&lt;/code&gt; 调试程序，必须让 &lt;code&gt;gdb&lt;/code&gt; 程序和被调试程序建立联系，这种联系可以通过程序的可执行文件、core文件或者正在运行的进程来建立，具体调试的时候使用的选项不同，涉及到参数的传递，选项的顺序，多进程启动前的设置等等，接下来可以看一些常见用法。&lt;/p&gt;
    
    </summary>
    
      <category term="GDB" scheme="http://AlbertGithubHome.github.io/blog/categories/GDB/"/>
    
    
      <category term="GDB" scheme="http://AlbertGithubHome.github.io/blog/tags/GDB/"/>
    
      <category term="manual" scheme="http://AlbertGithubHome.github.io/blog/tags/manual/"/>
    
      <category term="调试" scheme="http://AlbertGithubHome.github.io/blog/tags/%E8%B0%83%E8%AF%95/"/>
    
      <category term="启动" scheme="http://AlbertGithubHome.github.io/blog/tags/%E5%90%AF%E5%8A%A8/"/>
    
  </entry>
  
  <entry>
    <title>Redis源码-BFS方式浏览main函数</title>
    <link href="http://AlbertGithubHome.github.io/blog/2020/08/05/Redis%E6%BA%90%E7%A0%81-BFS%E6%96%B9%E5%BC%8F%E6%B5%8F%E8%A7%88main%E5%87%BD%E6%95%B0/"/>
    <id>http://AlbertGithubHome.github.io/blog/2020/08/05/Redis源码-BFS方式浏览main函数/</id>
    <published>2020-08-05T15:35:19.000Z</published>
    <updated>2020-08-15T16:06:34.730Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>欠下的技术债慢慢还，继续为去年吹过的牛而努力。去年年末的时候意识到自己掌握的知识还不够深入，决定开始看一些开源项目的源码，因为当时 <code>Redis</code> 的兴起，所以瞄准了准备从它下手，之后确实看了一部分内容，比如跳表、网络事件库等等，后来过年就鸽了。今年开始一直熟悉新的业务，比较懒没跟进，最近间歇性踌躇满志又发作了，准备抽时间再捋顺一遍，老规矩，还是从 <code>main()</code> 函数下手。</p><a id="more"></a><p>对于 <code>C/C++</code> 程序一定是从 <code>main()</code> 函数开头的，这是我们切入的一个点，至于怎么找到 <code>main</code> 函数，每个人有不同的方法，最暴力的方法当然就是全文搜索了，不过较为成熟的项目一般搜索出来都不止一个 <code>main</code> 函数，因为整个项目完整构建下来不止一个程序。</p><p>像 <code>redis</code> 这个项目最起码有服务器和客户端两个程序，源码中至少包含了两个 <code>main</code> 函数，再加上一些测试程序，<code>main</code> 函数在源码中会有很多。再比如 <code>Lua</code> 的源代码中包含和解释器和编译器，如果直接搜索至少会找到两个 <code>main</code> 函数。</p><p><code>redis</code> 服务器程序的 <code>main</code> 函数在文件 <code>src/server.c</code> 中，之前好像是在 <code>redis.c</code> 文件中后来改名了，这都不重要，反正你需要从搜索出来的 <code>main</code> 函数中找到一个开始的地方，这个花不了多少时间。</p><h1 id="看代码的方式"><a href="#看代码的方式" class="headerlink" title="看代码的方式"></a>看代码的方式</h1><p>标题中提到了 <code>BFS</code> 方式看代码，而 <code>BFS</code> 指的是广度优先搜索，与之相对应的是 <code>DFS</code> 深度优先搜索，对于不含异步调用的单线程程序来说，执行代码是以深度优先搜索的方式，遇到一个函数就调用进去，在函数中又遇到另一个函数再调用进去，当函数执行完成返回到上一层。</p><p>为什么选择 <code>BFS</code> 方式看代码呢？因为这样可以在短时间内更全面的了解代码结构，我们先看第一层，当第一层浏览完成之后再进入到第二层，比如我们先看 <code>main</code> 函数，即使 <code>main</code> 函数调用了很多不认识的函数也不要去管，从名字大概判断一些作用就可以了，不用纠结具体的实现内容，当 <code>main</code> 函数全部看完了再进入到第二层去了解它调用的那些函数。</p><p>总之使用 <code>BFS</code> 方式看代码就要有一种“不懂装懂”的态度，不然容易陷入细节，无法整体把握。</p><h1 id="Redis-服务器的-main-函数"><a href="#Redis-服务器的-main-函数" class="headerlink" title="Redis 服务器的 main 函数"></a>Redis 服务器的 main 函数</h1><p><code>redis</code> 服务器的 <code>main</code> 函数代码量不是很大，总共 200 行左右，我选择了 <code>6.0.6</code> 这个版本 <code>7bf665f125a4771db095c83a7ad6ed46692cd314</code>，因为只是学习源码，没有特殊情况就不更新版本了，保证环境的统一，我先把代码贴一份在这，后面再来慢慢看。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>;</span></span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> REDIS_TEST</span></span><br><span class="line">    <span class="keyword">if</span> (argc == <span class="number">3</span> &amp;&amp; !strcasecmp(argv[<span class="number">1</span>], <span class="string">"test"</span>)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!strcasecmp(argv[<span class="number">2</span>], <span class="string">"ziplist"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> ziplistTest(argc, argv);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(argv[<span class="number">2</span>], <span class="string">"quicklist"</span>)) &#123;</span><br><span class="line">            quicklistTest(argc, argv);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(argv[<span class="number">2</span>], <span class="string">"intset"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> intsetTest(argc, argv);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(argv[<span class="number">2</span>], <span class="string">"zipmap"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> zipmapTest(argc, argv);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(argv[<span class="number">2</span>], <span class="string">"sha1test"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> sha1Test(argc, argv);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(argv[<span class="number">2</span>], <span class="string">"util"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> utilTest(argc, argv);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(argv[<span class="number">2</span>], <span class="string">"endianconv"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> endianconvTest(argc, argv);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(argv[<span class="number">2</span>], <span class="string">"crc64"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> crc64Test(argc, argv);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(argv[<span class="number">2</span>], <span class="string">"zmalloc"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> zmalloc_test(argc, argv);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">/* test not found */</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* We need to initialize our libraries, and the server configuration. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> INIT_SETPROCTITLE_REPLACEMENT</span></span><br><span class="line">    spt_init(argc, argv);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    setlocale(LC_COLLATE,<span class="string">""</span>);</span><br><span class="line">    tzset(); <span class="comment">/* Populates 'timezone' global. */</span></span><br><span class="line">    zmalloc_set_oom_handler(redisOutOfMemoryHandler);</span><br><span class="line">    srand(time(<span class="literal">NULL</span>)^getpid());</span><br><span class="line">    gettimeofday(&amp;tv,<span class="literal">NULL</span>);</span><br><span class="line">    crc64_init();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint8_t</span> hashseed[<span class="number">16</span>];</span><br><span class="line">    getRandomBytes(hashseed,<span class="keyword">sizeof</span>(hashseed));</span><br><span class="line">    dictSetHashFunctionSeed(hashseed);</span><br><span class="line">    server.sentinel_mode = checkForSentinelMode(argc,argv);</span><br><span class="line">    initServerConfig();</span><br><span class="line">    ACLInit(); <span class="comment">/* The ACL subsystem must be initialized ASAP because the</span></span><br><span class="line"><span class="comment">                  basic networking code and client creation depends on it. */</span></span><br><span class="line">    moduleInitModulesSystem();</span><br><span class="line">    tlsInit();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Store the executable path and arguments in a safe place in order</span></span><br><span class="line"><span class="comment">     * to be able to restart the server later. */</span></span><br><span class="line">    server.executable = getAbsolutePath(argv[<span class="number">0</span>]);</span><br><span class="line">    server.exec_argv = zmalloc(<span class="keyword">sizeof</span>(<span class="keyword">char</span>*)*(argc+<span class="number">1</span>));</span><br><span class="line">    server.exec_argv[argc] = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; argc; j++) server.exec_argv[j] = zstrdup(argv[j]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* We need to init sentinel right now as parsing the configuration file</span></span><br><span class="line"><span class="comment">     * in sentinel mode will have the effect of populating the sentinel</span></span><br><span class="line"><span class="comment">     * data structures with master nodes to monitor. */</span></span><br><span class="line">    <span class="keyword">if</span> (server.sentinel_mode) &#123;</span><br><span class="line">        initSentinelConfig();</span><br><span class="line">        initSentinel();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check if we need to start in redis-check-rdb/aof mode. We just execute</span></span><br><span class="line"><span class="comment">     * the program main. However the program is part of the Redis executable</span></span><br><span class="line"><span class="comment">     * so that we can easily execute an RDB check on loading errors. */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strstr</span>(argv[<span class="number">0</span>],<span class="string">"redis-check-rdb"</span>) != <span class="literal">NULL</span>)</span><br><span class="line">        redis_check_rdb_main(argc,argv,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strstr</span>(argv[<span class="number">0</span>],<span class="string">"redis-check-aof"</span>) != <span class="literal">NULL</span>)</span><br><span class="line">        redis_check_aof_main(argc,argv);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">        j = <span class="number">1</span>; <span class="comment">/* First option to parse in argv[] */</span></span><br><span class="line">        sds options = sdsempty();</span><br><span class="line">        <span class="keyword">char</span> *configfile = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Handle special options --help and --version */</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">"-v"</span>) == <span class="number">0</span> ||</span><br><span class="line">            <span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">"--version"</span>) == <span class="number">0</span>) version();</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">"--help"</span>) == <span class="number">0</span> ||</span><br><span class="line">            <span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">"-h"</span>) == <span class="number">0</span>) usage();</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">"--test-memory"</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (argc == <span class="number">3</span>) &#123;</span><br><span class="line">                memtest(atoi(argv[<span class="number">2</span>]),<span class="number">50</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"Please specify the amount of memory to test in megabytes.\n"</span>);</span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"Example: ./redis-server --test-memory 4096\n\n"</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* First argument is the config file name? */</span></span><br><span class="line">        <span class="keyword">if</span> (argv[j][<span class="number">0</span>] != <span class="string">'-'</span> || argv[j][<span class="number">1</span>] != <span class="string">'-'</span>) &#123;</span><br><span class="line">            configfile = argv[j];</span><br><span class="line">            server.configfile = getAbsolutePath(configfile);</span><br><span class="line">            <span class="comment">/* Replace the config file in server.exec_argv with</span></span><br><span class="line"><span class="comment">             * its absolute path. */</span></span><br><span class="line">            zfree(server.exec_argv[j]);</span><br><span class="line">            server.exec_argv[j] = zstrdup(server.configfile);</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* All the other options are parsed and conceptually appended to the</span></span><br><span class="line"><span class="comment">         * configuration file. For instance --port 6380 will generate the</span></span><br><span class="line"><span class="comment">         * string "port 6380\n" to be parsed after the actual file name</span></span><br><span class="line"><span class="comment">         * is parsed, if any. */</span></span><br><span class="line">        <span class="keyword">while</span>(j != argc) &#123;</span><br><span class="line">            <span class="keyword">if</span> (argv[j][<span class="number">0</span>] == <span class="string">'-'</span> &amp;&amp; argv[j][<span class="number">1</span>] == <span class="string">'-'</span>) &#123;</span><br><span class="line">                <span class="comment">/* Option name */</span></span><br><span class="line">                <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[j], <span class="string">"--check-rdb"</span>)) &#123;</span><br><span class="line">                    <span class="comment">/* Argument has no options, need to skip for parsing. */</span></span><br><span class="line">                    j++;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (sdslen(options)) options = sdscat(options,<span class="string">"\n"</span>);</span><br><span class="line">                options = sdscat(options,argv[j]+<span class="number">2</span>);</span><br><span class="line">                options = sdscat(options,<span class="string">" "</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">/* Option argument */</span></span><br><span class="line">                options = sdscatrepr(options,argv[j],<span class="built_in">strlen</span>(argv[j]));</span><br><span class="line">                options = sdscat(options,<span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (server.sentinel_mode &amp;&amp; configfile &amp;&amp; *configfile == <span class="string">'-'</span>) &#123;</span><br><span class="line">            serverLog(LL_WARNING,</span><br><span class="line">                <span class="string">"Sentinel config from STDIN not allowed."</span>);</span><br><span class="line">            serverLog(LL_WARNING,</span><br><span class="line">                <span class="string">"Sentinel needs config file on disk to save state.  Exiting..."</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        resetServerSaveParams();</span><br><span class="line">        loadServerConfig(configfile,options);</span><br><span class="line">        sdsfree(options);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    serverLog(LL_WARNING, <span class="string">"oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo"</span>);</span><br><span class="line">    serverLog(LL_WARNING,</span><br><span class="line">        <span class="string">"Redis version=%s, bits=%d, commit=%s, modified=%d, pid=%d, just started"</span>,</span><br><span class="line">            REDIS_VERSION,</span><br><span class="line">            (<span class="keyword">sizeof</span>(<span class="keyword">long</span>) == <span class="number">8</span>) ? <span class="number">64</span> : <span class="number">32</span>,</span><br><span class="line">            redisGitSHA1(),</span><br><span class="line">            strtol(redisGitDirty(),<span class="literal">NULL</span>,<span class="number">10</span>) &gt; <span class="number">0</span>,</span><br><span class="line">            (<span class="keyword">int</span>)getpid());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc == <span class="number">1</span>) &#123;</span><br><span class="line">        serverLog(LL_WARNING, <span class="string">"Warning: no config file specified, using the default config. In order to specify a config file use %s /path/to/%s.conf"</span>, argv[<span class="number">0</span>], server.sentinel_mode ? <span class="string">"sentinel"</span> : <span class="string">"redis"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        serverLog(LL_WARNING, <span class="string">"Configuration loaded"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    server.supervised = redisIsSupervised(server.supervised_mode);</span><br><span class="line">    <span class="keyword">int</span> background = server.daemonize &amp;&amp; !server.supervised;</span><br><span class="line">    <span class="keyword">if</span> (background) daemonize();</span><br><span class="line"></span><br><span class="line">    initServer();</span><br><span class="line">    <span class="keyword">if</span> (background || server.pidfile) createPidFile();</span><br><span class="line">    redisSetProcTitle(argv[<span class="number">0</span>]);</span><br><span class="line">    redisAsciiArt();</span><br><span class="line">    checkTcpBacklogSettings();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!server.sentinel_mode) &#123;</span><br><span class="line">        <span class="comment">/* Things not needed when running in Sentinel mode. */</span></span><br><span class="line">        serverLog(LL_WARNING,<span class="string">"Server initialized"</span>);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> __linux__</span></span><br><span class="line">        linuxMemoryWarnings();</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        moduleLoadFromQueue();</span><br><span class="line">        ACLLoadUsersAtStartup();</span><br><span class="line">        InitServerLast();</span><br><span class="line">        loadDataFromDisk();</span><br><span class="line">        <span class="keyword">if</span> (server.cluster_enabled) &#123;</span><br><span class="line">            <span class="keyword">if</span> (verifyClusterConfigWithData() == C_ERR) &#123;</span><br><span class="line">                serverLog(LL_WARNING,</span><br><span class="line">                    <span class="string">"You can't have keys in a DB different than DB 0 when in "</span></span><br><span class="line">                    <span class="string">"Cluster mode. Exiting."</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (server.ipfd_count &gt; <span class="number">0</span> || server.tlsfd_count &gt; <span class="number">0</span>)</span><br><span class="line">            serverLog(LL_NOTICE,<span class="string">"Ready to accept connections"</span>);</span><br><span class="line">        <span class="keyword">if</span> (server.sofd &gt; <span class="number">0</span>)</span><br><span class="line">            serverLog(LL_NOTICE,<span class="string">"The server is now ready to accept connections at %s"</span>, server.unixsocket);</span><br><span class="line">        <span class="keyword">if</span> (server.supervised_mode == SUPERVISED_SYSTEMD) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!server.masterhost) &#123;</span><br><span class="line">                redisCommunicateSystemd(<span class="string">"STATUS=Ready to accept connections\n"</span>);</span><br><span class="line">                redisCommunicateSystemd(<span class="string">"READY=1\n"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                redisCommunicateSystemd(<span class="string">"STATUS=Waiting for MASTER &lt;-&gt; REPLICA sync\n"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        InitServerLast();</span><br><span class="line">        sentinelIsRunning();</span><br><span class="line">        <span class="keyword">if</span> (server.supervised_mode == SUPERVISED_SYSTEMD) &#123;</span><br><span class="line">            redisCommunicateSystemd(<span class="string">"STATUS=Ready to accept connections\n"</span>);</span><br><span class="line">            redisCommunicateSystemd(<span class="string">"READY=1\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Warning the user about suspicious maxmemory setting. */</span></span><br><span class="line">    <span class="keyword">if</span> (server.maxmemory &gt; <span class="number">0</span> &amp;&amp; server.maxmemory &lt; <span class="number">1024</span>*<span class="number">1024</span>) &#123;</span><br><span class="line">        serverLog(LL_WARNING,<span class="string">"WARNING: You specified a maxmemory value that is less than 1MB (current value is %llu bytes). Are you sure this is what you really want?"</span>, server.maxmemory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    redisSetCpuAffinity(server.server_cpulist);</span><br><span class="line">    aeMain(server.el);</span><br><span class="line">    aeDeleteEventLoop(server.el);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="main-函数分段解释"><a href="#main-函数分段解释" class="headerlink" title="main 函数分段解释"></a>main 函数分段解释</h1><h2 id="函数名及参数"><a href="#函数名及参数" class="headerlink" title="函数名及参数"></a>函数名及参数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>;</span></span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就是一个标准的 <code>main</code> 函数，参数 <code>argc</code> 和 <code>argv</code> 对于一个命令行程序来说可以是重头戏，肯定会拿来做重度解析的，函数开头还定义了 <code>tv</code> 和 <code>j</code> 两个变量，不知道干嘛的，接着往下看吧。</p><h2 id="启动测试程序"><a href="#启动测试程序" class="headerlink" title="启动测试程序"></a>启动测试程序</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> REDIS_TEST</span></span><br><span class="line">    <span class="keyword">if</span> (argc == <span class="number">3</span> &amp;&amp; !strcasecmp(argv[<span class="number">1</span>], <span class="string">"test"</span>)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!strcasecmp(argv[<span class="number">2</span>], <span class="string">"ziplist"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> ziplistTest(argc, argv);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(argv[<span class="number">2</span>], <span class="string">"quicklist"</span>)) &#123;</span><br><span class="line">            quicklistTest(argc, argv);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(argv[<span class="number">2</span>], <span class="string">"intset"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> intsetTest(argc, argv);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(argv[<span class="number">2</span>], <span class="string">"zipmap"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> zipmapTest(argc, argv);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(argv[<span class="number">2</span>], <span class="string">"sha1test"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> sha1Test(argc, argv);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(argv[<span class="number">2</span>], <span class="string">"util"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> utilTest(argc, argv);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(argv[<span class="number">2</span>], <span class="string">"endianconv"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> endianconvTest(argc, argv);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(argv[<span class="number">2</span>], <span class="string">"crc64"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> crc64Test(argc, argv);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(argv[<span class="number">2</span>], <span class="string">"zmalloc"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> zmalloc_test(argc, argv);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">/* test not found */</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>当宏定义 <code>REDIS_TEST</code> 存在，并且参数合适的情况下启动测试程序，<code>argv[0]</code> 肯定是指 <code>redis</code> 服务器喽，那 <code>argv[1]</code> 的值如果是 <code>test</code>，而 <code>argv[2]</code> 的值是 <code>ziplist</code>，那么会调用 <code>ziplist</code> 的测试函数 <code>ziplistTest</code>，如果 <code>argv[2]</code> 的值是 <code>zmalloc</code>，那么会调用测试函数 <code>zmalloc_test</code>，为啥这里函数名命名规范不统一呢？挠头。</p><h2 id="程序环境初始化"><a href="#程序环境初始化" class="headerlink" title="程序环境初始化"></a>程序环境初始化</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/* We need to initialize our libraries, and the server configuration. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> INIT_SETPROCTITLE_REPLACEMENT</span></span><br><span class="line">    spt_init(argc, argv);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    setlocale(LC_COLLATE,<span class="string">""</span>);</span><br><span class="line">    tzset(); <span class="comment">/* Populates 'timezone' global. */</span></span><br><span class="line">    zmalloc_set_oom_handler(redisOutOfMemoryHandler);</span><br><span class="line">    srand(time(<span class="literal">NULL</span>)^getpid());</span><br><span class="line">    gettimeofday(&amp;tv,<span class="literal">NULL</span>);</span><br><span class="line">    crc64_init();</span><br></pre></td></tr></table></figure><ol><li>当 <code>INIT_SETPROCTITLE_REPLACEMENT</code> 这个宏存在的时候，调用 <code>spt_init</code> 函数来为设置程序标题做准备</li><li><code>setlocale()</code> 用来设置地点信息，这一句应该是设置成依赖操作系统的地点信息，比如中国，韩国等等</li><li><code>tzset()</code> 设置时区，这里可能影响到程序运行后，调整时区是否对程序产生影响</li><li><code>srand(time(NULL)^getpid());</code> 初始化随机种子</li><li><code>gettimeofday(&amp;tv,NULL);</code> 这里用到了函数开头定义的一个变量 <code>tv</code>，用来获取当前时间</li><li><code>crc64_init();</code> 循环冗余校验初始化，<code>crc</code> 神奇的存在</li></ol><h2 id="初始化配置信息"><a href="#初始化配置信息" class="headerlink" title="初始化配置信息"></a>初始化配置信息</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uint8_t</span> hashseed[<span class="number">16</span>];</span><br><span class="line">getRandomBytes(hashseed,<span class="keyword">sizeof</span>(hashseed));</span><br><span class="line">dictSetHashFunctionSeed(hashseed);</span><br><span class="line">server.sentinel_mode = checkForSentinelMode(argc,argv);</span><br><span class="line">initServerConfig();</span><br><span class="line">ACLInit(); <span class="comment">/* The ACL subsystem must be initialized ASAP because the</span></span><br><span class="line"><span class="comment">              basic networking code and client creation depends on it. */</span></span><br><span class="line">moduleInitModulesSystem();</span><br><span class="line">tlsInit();</span><br></pre></td></tr></table></figure><ol><li>定一个16字节的空间用来存放哈希种子</li><li>随机获取一段16字节数据作为种子</li><li>将刚刚获取的种子数据设置到hash函数中</li><li>分析命令行参数，判断是否是哨兵模式</li><li>初始化服务器配置</li><li><code>ACL</code> 初始化，不用管它具体是什么，进入下一层时自然会看到</li><li>初始化模块系统</li><li><code>tls</code> 初始化，存疑，好奇的话进去看看也可以，好吧，原来是 <code>ssl</code> 那一套，够喝一壶的</li></ol><h2 id="存储参数信息"><a href="#存储参数信息" class="headerlink" title="存储参数信息"></a>存储参数信息</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Store the executable path and arguments in a safe place in order</span></span><br><span class="line"><span class="comment"> * to be able to restart the server later. */</span></span><br><span class="line">server.executable = getAbsolutePath(argv[<span class="number">0</span>]);</span><br><span class="line">server.exec_argv = zmalloc(<span class="keyword">sizeof</span>(<span class="keyword">char</span>*)*(argc+<span class="number">1</span>));</span><br><span class="line">server.exec_argv[argc] = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; argc; j++) server.exec_argv[j] = zstrdup(argv[j]);</span><br></pre></td></tr></table></figure><p>这一小节比较简单，注释写的也很清楚，就是将命令行参数存储起来，方便重启 <code>redis</code> 服务</p><h2 id="根据参数确定启动方式"><a href="#根据参数确定启动方式" class="headerlink" title="根据参数确定启动方式"></a>根据参数确定启动方式</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* We need to init sentinel right now as parsing the configuration file</span></span><br><span class="line"><span class="comment"> * in sentinel mode will have the effect of populating the sentinel</span></span><br><span class="line"><span class="comment"> * data structures with master nodes to monitor. */</span></span><br><span class="line"><span class="keyword">if</span> (server.sentinel_mode) &#123;</span><br><span class="line">    initSentinelConfig();</span><br><span class="line">    initSentinel();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Check if we need to start in redis-check-rdb/aof mode. We just execute</span></span><br><span class="line"><span class="comment"> * the program main. However the program is part of the Redis executable</span></span><br><span class="line"><span class="comment"> * so that we can easily execute an RDB check on loading errors. */</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strstr</span>(argv[<span class="number">0</span>],<span class="string">"redis-check-rdb"</span>) != <span class="literal">NULL</span>)</span><br><span class="line">    redis_check_rdb_main(argc,argv,<span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strstr</span>(argv[<span class="number">0</span>],<span class="string">"redis-check-aof"</span>) != <span class="literal">NULL</span>)</span><br><span class="line">    redis_check_aof_main(argc,argv);</span><br></pre></td></tr></table></figure><p>当启用哨兵模式的时候初始化额外的配置，啥是哨兵，现在还不用知道啊，从字面上来看就好了，反正知道命令行里如果指定了哨兵模式就要额外初始化一点东西。</p><p>下面这两个参数有点意思，简单扩展下，<code>rdb</code> 和 <code>aof</code> 是 <code>redis</code> 的两种数据落地的持久化方式，这里有意思的地方是判断了 <code>argv[0]</code> 这个参数，一般 <code>argv[0]</code> 是程序的名字，这个是固定不变的，而 <code>redis</code> 这里将程序名字作为参数来判断，也就是说你把可执行程序换个名字运行，它的行为就会发生变化。</p><h2 id="处理并加载命令行参数"><a href="#处理并加载命令行参数" class="headerlink" title="处理并加载命令行参数"></a>处理并加载命令行参数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (argc &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">    j = <span class="number">1</span>; <span class="comment">/* First option to parse in argv[] */</span></span><br><span class="line">    sds options = sdsempty();</span><br><span class="line">    <span class="keyword">char</span> *configfile = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Handle special options --help and --version */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">"-v"</span>) == <span class="number">0</span> ||</span><br><span class="line">        <span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">"--version"</span>) == <span class="number">0</span>) version();</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">"--help"</span>) == <span class="number">0</span> ||</span><br><span class="line">        <span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">"-h"</span>) == <span class="number">0</span>) usage();</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">"--test-memory"</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (argc == <span class="number">3</span>) &#123;</span><br><span class="line">            memtest(atoi(argv[<span class="number">2</span>]),<span class="number">50</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"Please specify the amount of memory to test in megabytes.\n"</span>);</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"Example: ./redis-server --test-memory 4096\n\n"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* First argument is the config file name? */</span></span><br><span class="line">    <span class="keyword">if</span> (argv[j][<span class="number">0</span>] != <span class="string">'-'</span> || argv[j][<span class="number">1</span>] != <span class="string">'-'</span>) &#123;</span><br><span class="line">        configfile = argv[j];</span><br><span class="line">        server.configfile = getAbsolutePath(configfile);</span><br><span class="line">        <span class="comment">/* Replace the config file in server.exec_argv with</span></span><br><span class="line"><span class="comment">         * its absolute path. */</span></span><br><span class="line">        zfree(server.exec_argv[j]);</span><br><span class="line">        server.exec_argv[j] = zstrdup(server.configfile);</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* All the other options are parsed and conceptually appended to the</span></span><br><span class="line"><span class="comment">     * configuration file. For instance --port 6380 will generate the</span></span><br><span class="line"><span class="comment">     * string "port 6380\n" to be parsed after the actual file name</span></span><br><span class="line"><span class="comment">     * is parsed, if any. */</span></span><br><span class="line">    <span class="keyword">while</span>(j != argc) &#123;</span><br><span class="line">        <span class="keyword">if</span> (argv[j][<span class="number">0</span>] == <span class="string">'-'</span> &amp;&amp; argv[j][<span class="number">1</span>] == <span class="string">'-'</span>) &#123;</span><br><span class="line">            <span class="comment">/* Option name */</span></span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[j], <span class="string">"--check-rdb"</span>)) &#123;</span><br><span class="line">                <span class="comment">/* Argument has no options, need to skip for parsing. */</span></span><br><span class="line">                j++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (sdslen(options)) options = sdscat(options,<span class="string">"\n"</span>);</span><br><span class="line">            options = sdscat(options,argv[j]+<span class="number">2</span>);</span><br><span class="line">            options = sdscat(options,<span class="string">" "</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* Option argument */</span></span><br><span class="line">            options = sdscatrepr(options,argv[j],<span class="built_in">strlen</span>(argv[j]));</span><br><span class="line">            options = sdscat(options,<span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (server.sentinel_mode &amp;&amp; configfile &amp;&amp; *configfile == <span class="string">'-'</span>) &#123;</span><br><span class="line">        serverLog(LL_WARNING,</span><br><span class="line">            <span class="string">"Sentinel config from STDIN not allowed."</span>);</span><br><span class="line">        serverLog(LL_WARNING,</span><br><span class="line">            <span class="string">"Sentinel needs config file on disk to save state.  Exiting..."</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    resetServerSaveParams();</span><br><span class="line">    loadServerConfig(configfile,options);</span><br><span class="line">    sdsfree(options);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段内容很长，但是核心的内容不多，前一部分是判断特殊参数，用来显示程序使用方法，启动内存测试等等，中间部分是分析命令行参数保存到字符串中，最后几行是读取服务器配置文件，并使用字符串中的参数选项覆盖文件中的部分配置。</p><h2 id="打印启动和警告信息"><a href="#打印启动和警告信息" class="headerlink" title="打印启动和警告信息"></a>打印启动和警告信息</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">serverLog(LL_WARNING, <span class="string">"oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo"</span>);</span><br><span class="line">serverLog(LL_WARNING,</span><br><span class="line">    <span class="string">"Redis version=%s, bits=%d, commit=%s, modified=%d, pid=%d, just started"</span>,</span><br><span class="line">        REDIS_VERSION,</span><br><span class="line">        (<span class="keyword">sizeof</span>(<span class="keyword">long</span>) == <span class="number">8</span>) ? <span class="number">64</span> : <span class="number">32</span>,</span><br><span class="line">        redisGitSHA1(),</span><br><span class="line">        strtol(redisGitDirty(),<span class="literal">NULL</span>,<span class="number">10</span>) &gt; <span class="number">0</span>,</span><br><span class="line">        (<span class="keyword">int</span>)getpid());</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (argc == <span class="number">1</span>) &#123;</span><br><span class="line">    serverLog(LL_WARNING, <span class="string">"Warning: no config file specified, using the default config. In order to specify a config file use %s /path/to/%s.conf"</span>, argv[<span class="number">0</span>], server.sentinel_mode ? <span class="string">"sentinel"</span> : <span class="string">"redis"</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    serverLog(LL_WARNING, <span class="string">"Configuration loaded"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印 <code>redis</code> 服务器启动信息，比如版本号，pid，警告信息等等，没有实际修改数据。</p><h2 id="守护模式和初始化"><a href="#守护模式和初始化" class="headerlink" title="守护模式和初始化"></a>守护模式和初始化</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">server.supervised = redisIsSupervised(server.supervised_mode);</span><br><span class="line"><span class="keyword">int</span> background = server.daemonize &amp;&amp; !server.supervised;</span><br><span class="line"><span class="keyword">if</span> (background) daemonize();</span><br><span class="line"></span><br><span class="line">initServer();</span><br><span class="line"><span class="keyword">if</span> (background || server.pidfile) createPidFile();</span><br><span class="line">redisSetProcTitle(argv[<span class="number">0</span>]);</span><br><span class="line">redisAsciiArt();</span><br><span class="line">checkTcpBacklogSettings();</span><br></pre></td></tr></table></figure><p>根据守护进程配置和是否受监督来决定是否作为守护进程，什么是受监督，到现在还不知道，但是本着不懂装懂的方式看代码，可以认为我们懂了，后面自然还会有解释的地方。</p><p>接着就调用了 <code>initServer();</code> 函数，这个初始化函数内容是比较长的，之前版本中很多 <code>mian</code> 函数中的内容都移到了这里面，初始化完成后创建 <code>Pid</code> 文件，设置进程名字，显示 <code>redis</code> 的Logo，检查一些配置，这个 <code>backlog</code> 参数之前面试的时候还被问到过，好奇的话可以提前了解一下。</p><h2 id="哨兵模式判断启动并加载持久化数据"><a href="#哨兵模式判断启动并加载持久化数据" class="headerlink" title="哨兵模式判断启动并加载持久化数据"></a>哨兵模式判断启动并加载持久化数据</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">if</span> (!server.sentinel_mode) &#123;</span><br><span class="line">    <span class="comment">/* Things not needed when running in Sentinel mode. */</span></span><br><span class="line">    serverLog(LL_WARNING,<span class="string">"Server initialized"</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __linux__</span></span><br><span class="line">    linuxMemoryWarnings();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    moduleLoadFromQueue();</span><br><span class="line">    ACLLoadUsersAtStartup();</span><br><span class="line">    InitServerLast();</span><br><span class="line">    loadDataFromDisk();</span><br><span class="line">    <span class="keyword">if</span> (server.cluster_enabled) &#123;</span><br><span class="line">        <span class="keyword">if</span> (verifyClusterConfigWithData() == C_ERR) &#123;</span><br><span class="line">            serverLog(LL_WARNING,</span><br><span class="line">                <span class="string">"You can't have keys in a DB different than DB 0 when in "</span></span><br><span class="line">                <span class="string">"Cluster mode. Exiting."</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (server.ipfd_count &gt; <span class="number">0</span> || server.tlsfd_count &gt; <span class="number">0</span>)</span><br><span class="line">        serverLog(LL_NOTICE,<span class="string">"Ready to accept connections"</span>);</span><br><span class="line">    <span class="keyword">if</span> (server.sofd &gt; <span class="number">0</span>)</span><br><span class="line">        serverLog(LL_NOTICE,<span class="string">"The server is now ready to accept connections at %s"</span>, server.unixsocket);</span><br><span class="line">    <span class="keyword">if</span> (server.supervised_mode == SUPERVISED_SYSTEMD) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!server.masterhost) &#123;</span><br><span class="line">            redisCommunicateSystemd(<span class="string">"STATUS=Ready to accept connections\n"</span>);</span><br><span class="line">            redisCommunicateSystemd(<span class="string">"READY=1\n"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            redisCommunicateSystemd(<span class="string">"STATUS=Waiting for MASTER &lt;-&gt; REPLICA sync\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    InitServerLast();</span><br><span class="line">    sentinelIsRunning();</span><br><span class="line">    <span class="keyword">if</span> (server.supervised_mode == SUPERVISED_SYSTEMD) &#123;</span><br><span class="line">        redisCommunicateSystemd(<span class="string">"STATUS=Ready to accept connections\n"</span>);</span><br><span class="line">        redisCommunicateSystemd(<span class="string">"READY=1\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码看起来像是再做一些通知提醒，其中比较重要的几个函数是<code>moduleLoadFromQueue()</code>、 <code>InitServerLast()</code> 和 <code>loadDataFromDisk()</code> ，第一个函数是加载模块的，第二个函数是在模块加载完成之后才能初始化的部分内容，最后一个是从磁盘加载数据到内存，这也是 <code>redis</code> 支持持久化的必要保证。</p><h2 id="打印内存警告并启动事件监听"><a href="#打印内存警告并启动事件监听" class="headerlink" title="打印内存警告并启动事件监听"></a>打印内存警告并启动事件监听</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Warning the user about suspicious maxmemory setting. */</span></span><br><span class="line"><span class="keyword">if</span> (server.maxmemory &gt; <span class="number">0</span> &amp;&amp; server.maxmemory &lt; <span class="number">1024</span>*<span class="number">1024</span>) &#123;</span><br><span class="line">    serverLog(LL_WARNING,<span class="string">"WARNING: You specified a maxmemory value that is less than 1MB (current value is %llu bytes). Are you sure this is what you really want?"</span>, server.maxmemory);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">redisSetCpuAffinity(server.server_cpulist);</span><br><span class="line">aeMain(server.el);</span><br><span class="line">aeDeleteEventLoop(server.el);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>看到这段代码我们就来到了 <code>main</code> 函数结尾的部分，<code>redisSetCpuAffinity()</code> 是要做些和 <code>CPU</code> 相关的设置或配置，<code>aeMain()</code> 是主逻辑，对于提供服务的程序来说里面大概率是一个死循环，再满足指定的条件下才会打断退出，而 <code>aeDeleteEventLoop()</code> 就是循环结束时清理事件的操作，到此为止 <code>main</code> 函数就执行完啦。</p><h1 id="彩蛋"><a href="#彩蛋" class="headerlink" title="彩蛋"></a>彩蛋</h1><p>这个 <code>main</code> 函数的代码中有一个神奇的用法不知道大家有没有发现，就是下面这句话：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">serverLog(LL_WARNING,</span><br><span class="line">    <span class="string">"You can't have keys in a DB different than DB 0 when in "</span></span><br><span class="line">    <span class="string">"Cluster mode. Exiting."</span>);</span><br></pre></td></tr></table></figure><p>是不是看起来有些奇怪，不用管这个函数的定义是怎样的，可以告诉大家这个函数的定义类似于 <code>printf</code> 函数，只不过在最前面加了一个整型参数，那么调用这个函数时传了几个参数呢？3个？2个？，这个地方很神奇的会把两个字符串拼接到一起，类似于下面的写法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">serverLog(LL_WARNING,</span><br><span class="line">        <span class="string">"You can't have keys in a DB different than DB 0 when in Cluster mode. Exiting."</span>);</span><br></pre></td></tr></table></figure><p>这样的字符串不仅可以分成两行，实际上可以分成任意行，最后都会拼接在一起，是不是很神奇。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li><code>j</code> 这个变量在 <code>redis</code> 的源码中经常出现，应该是作者的行为习惯吧，有些人爱用 <code>i</code>，而这个作者 <code>antirez</code> 爱用 <code>j</code>。</li><li>不能一口吃个胖子，看代码也是一样，不能期望一次性把所有的内容都看懂，一段时间后自己的代码都看不懂了，跟别说别人写的了。</li><li><code>redis</code> 代码中频繁使用 <code>server</code> 这个变量，从 <code>main</code> 函数分析中也能看到，这个是个全局变量，代表了整个 <code>redis</code> 服务器程序数据。</li><li>不懂装懂或者说不求甚解是熟悉代码整体结构的一项优秀品质，这时候只要看个大概就可以了，真到熟悉细节的时候才是需要钻研的时候。</li><li>代码风格完全统一还是比较难实现的，从一个 <code>main</code> 函数中也可以看到，大部分函数是驼峰命名法，还要少量的下划线命名和帕斯卡命名。</li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/107873029" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>你微笑的模样，提醒着我不要躲藏，坚持原来的方向，哪怕最后遍体鳞伤，困难只会让坚持的人越来越强，共勉~</p><p>2020-8-15 23:48:53</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;欠下的技术债慢慢还，继续为去年吹过的牛而努力。去年年末的时候意识到自己掌握的知识还不够深入，决定开始看一些开源项目的源码，因为当时 &lt;code&gt;Redis&lt;/code&gt; 的兴起，所以瞄准了准备从它下手，之后确实看了一部分内容，比如跳表、网络事件库等等，后来过年就鸽了。今年开始一直熟悉新的业务，比较懒没跟进，最近间歇性踌躇满志又发作了，准备抽时间再捋顺一遍，老规矩，还是从 &lt;code&gt;main()&lt;/code&gt; 函数下手。&lt;/p&gt;
    
    </summary>
    
      <category term="Redis" scheme="http://AlbertGithubHome.github.io/blog/categories/Redis/"/>
    
    
      <category term="Redis" scheme="http://AlbertGithubHome.github.io/blog/tags/Redis/"/>
    
      <category term="源码" scheme="http://AlbertGithubHome.github.io/blog/tags/%E6%BA%90%E7%A0%81/"/>
    
      <category term="C" scheme="http://AlbertGithubHome.github.io/blog/tags/C/"/>
    
      <category term="BFS" scheme="http://AlbertGithubHome.github.io/blog/tags/BFS/"/>
    
  </entry>
  
  <entry>
    <title>GDB调试指北-启动GDB并查看说明信息</title>
    <link href="http://AlbertGithubHome.github.io/blog/2020/08/01/GDB%E8%B0%83%E8%AF%95%E6%8C%87%E5%8C%97-%E5%90%AF%E5%8A%A8GDB%E5%B9%B6%E6%9F%A5%E7%9C%8B%E8%AF%B4%E6%98%8E%E4%BF%A1%E6%81%AF/"/>
    <id>http://AlbertGithubHome.github.io/blog/2020/08/01/GDB调试指北-启动GDB并查看说明信息/</id>
    <published>2020-08-01T15:08:16.000Z</published>
    <updated>2020-08-07T16:16:09.954Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>学习 <code>gdb</code> 使用是一个漫长的过程，先了解一下 <code>gdb</code> 的启动方式和基础信息的查看方法，能够帮助我们更全面的认知这个工具。<code>gdb</code> 是一个交互式命令行程序，在使用 <code>gdb</code> 调试的时候不断的在命令行内输入命令，然后 <code>gdb</code> 程序就会给出反馈信息，这在很大程序上可以帮助我们调试程序问题。</p><a id="more"></a><h1 id="gdb-版本查看"><a href="#gdb-版本查看" class="headerlink" title="gdb 版本查看"></a>gdb 版本查看</h1><p><code>gdb</code> 的安装教程网络上有很多，这里就不提供安装步骤了，可以直接通过命令行，也可以从源码安装，找个教程一步步操作就行了，安装完之后使用 <code>which</code> 命令查看一下程序安装的位置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:~$ <span class="built_in">which</span> gdb</span><br><span class="line">/usr/bin/gdb</span><br></pre></td></tr></table></figure><p>确认 <code>gdb</code> 已经安装后我们再看一下程序版本，我用的是 <code>Ubuntu 16.04</code> 版本中匹配的 <code>gdb</code> 程序，版本稍微有些低，据说 <code>9.x</code> 版本中对 <code>Python</code> 支持的非常好，调试的时候查看变量更加方便了，这些神奇的特性我们暂时还用不到，先简单了解下就好：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:~$ gdb --version</span><br><span class="line">GNU gdb (Ubuntu 7.11.1-0ubuntu1~16.5) 7.11.1</span><br><span class="line">Copyright (C) 2016 Free Software Foundation, Inc.</span><br><span class="line">License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;</span><br><span class="line">This is free software: you are free to change and redistribute it.</span><br><span class="line">There is NO WARRANTY, to the extent permitted by law.  Type <span class="string">"show copying"</span></span><br><span class="line">and <span class="string">"show warranty"</span> <span class="keyword">for</span> details.</span><br><span class="line">This GDB was configured as <span class="string">"x86_64-linux-gnu"</span>.</span><br><span class="line">Type <span class="string">"show configuration"</span> <span class="keyword">for</span> configuration details.</span><br><span class="line">For bug reporting instructions, please see:</span><br><span class="line">&lt;http://www.gnu.org/software/gdb/bugs/&gt;.</span><br><span class="line">Find the GDB manual and other documentation resources online at:</span><br><span class="line">&lt;http://www.gnu.org/software/gdb/documentation/&gt;.</span><br><span class="line">For <span class="built_in">help</span>, <span class="built_in">type</span> <span class="string">"help"</span>.</span><br><span class="line">Type <span class="string">"apropos word"</span> to search <span class="keyword">for</span> commands related to <span class="string">"word"</span>.</span><br><span class="line">albert@home-pc:~$</span><br></pre></td></tr></table></figure><h1 id="gdb-启动"><a href="#gdb-启动" class="headerlink" title="gdb 启动"></a>gdb 启动</h1><h2 id="直接启动"><a href="#直接启动" class="headerlink" title="直接启动"></a>直接启动</h2><p><code>gdb</code> 作为一个程序和其他的程序启动方式是一样的，直接敲入 <code>gdb</code> 命令回车就可以了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:~$ gdb</span><br><span class="line">GNU gdb (Ubuntu 7.11.1-0ubuntu1~16.5) 7.11.1</span><br><span class="line">Copyright (C) 2016 Free Software Foundation, Inc.</span><br><span class="line">License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;</span><br><span class="line">This is free software: you are free to change and redistribute it.</span><br><span class="line">There is NO WARRANTY, to the extent permitted by law.  Type <span class="string">"show copying"</span></span><br><span class="line">and <span class="string">"show warranty"</span> <span class="keyword">for</span> details.</span><br><span class="line">This GDB was configured as <span class="string">"x86_64-linux-gnu"</span>.</span><br><span class="line">Type <span class="string">"show configuration"</span> <span class="keyword">for</span> configuration details.</span><br><span class="line">For bug reporting instructions, please see:</span><br><span class="line">&lt;http://www.gnu.org/software/gdb/bugs/&gt;.</span><br><span class="line">Find the GDB manual and other documentation resources online at:</span><br><span class="line">&lt;http://www.gnu.org/software/gdb/documentation/&gt;.</span><br><span class="line">For <span class="built_in">help</span>, <span class="built_in">type</span> <span class="string">"help"</span>.</span><br><span class="line">Type <span class="string">"apropos word"</span> to search <span class="keyword">for</span> commands related to <span class="string">"word"</span>.</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure><p>看着是不是有些眼熟，这就是刚刚查 <code>gdb</code> 版本时看到的那段文字，只不过这段文字结束时不是返回到命令行，而是显现出了 <code>(gdb)</code> 的字样，我们暂时把它叫做 <code>gdb 命令行</code>，这就是我们与 <code>gdb</code> 程序进行交互的主要途径了。</p><h2 id="去掉版本信息启动"><a href="#去掉版本信息启动" class="headerlink" title="去掉版本信息启动"></a>去掉版本信息启动</h2><p>上面启动 <code>gdb</code> 时出现的这段文字很长，有时候反复调试程序时看到这段文字有点烦，想把它去掉怎么办？非常简单，在启动时加上 <code>-q</code> 参数就可以了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:~$ gdb -q</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure><p>怎么样，这次上面那段文字不见了，直接就进入 <code>gdb</code> 命令行了吧。</p><h1 id="gdb-信息查看"><a href="#gdb-信息查看" class="headerlink" title="gdb 信息查看"></a>gdb 信息查看</h1><p>其实刚刚被我们嫌弃的那段文字，里面记录了不少信息，其中还展示了 <code>show copying</code>、<code>show warranty</code>、<code>show configuration</code> 等多个命令，我们可以简单尝试下这些命令有什么作用。</p><h2 id="show-copying"><a href="#show-copying" class="headerlink" title="show copying"></a>show copying</h2><p>输入 <code>show copying</code> 命令展示的是一份比较长的版本许可证说明，我省略了中间的部分，如果想看的话可以自己输入命令试一下，<code>GPL v3</code> 的许可证看起来很熟悉吧。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:~$ gdb -q</span><br><span class="line">(gdb) show copying</span><br><span class="line">                    GNU GENERAL PUBLIC LICENSE</span><br><span class="line">                       Version 3, 29 June 2007</span><br><span class="line"></span><br><span class="line"> Copyright (C) 2007 Free Software Foundation, Inc. &lt;http://fsf.org/&gt;</span><br><span class="line"> Everyone is permitted to copy and distribute verbatim copies</span><br><span class="line"> of this license document, but changing it is not allowed.</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">  Later license versions may give you additional or different</span><br><span class="line">permissions.  However, no additional obligations are imposed on any</span><br><span class="line">author or copyright holder as a result of your choosing to follow a</span><br><span class="line">later version.</span><br></pre></td></tr></table></figure><h2 id="show-warranty"><a href="#show-warranty" class="headerlink" title="show warranty"></a>show warranty</h2><p>命令 <code>show warranty</code> 输出的内容相比之前的命令就短很多了，是一份免责声明，序号从15开始，接着版本许可证的序号往下写的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">(gdb) show warranty</span><br><span class="line">  15. Disclaimer of Warranty.</span><br><span class="line"></span><br><span class="line">  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY</span><br><span class="line">APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT</span><br><span class="line">HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM <span class="string">"AS IS"</span> WITHOUT WARRANTY</span><br><span class="line">OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,</span><br><span class="line">THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR</span><br><span class="line">PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM</span><br><span class="line">IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF</span><br><span class="line">ALL NECESSARY SERVICING, REPAIR OR CORRECTION.</span><br><span class="line"></span><br><span class="line">  16. Limitation of Liability.</span><br><span class="line"></span><br><span class="line">  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING</span><br><span class="line">WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS</span><br><span class="line">THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY</span><br><span class="line">GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE</span><br><span class="line">USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF</span><br><span class="line">DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD</span><br><span class="line">PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),</span><br><span class="line">EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF</span><br><span class="line">SUCH DAMAGES.</span><br><span class="line"></span><br><span class="line">  17. Interpretation of Sections 15 and 16.</span><br><span class="line"></span><br><span class="line">  If the disclaimer of warranty and limitation of liability provided</span><br><span class="line">above cannot be given <span class="built_in">local</span> legal effect according to their terms,</span><br><span class="line">reviewing courts shall apply <span class="built_in">local</span> law that most closely approximates</span><br><span class="line">an absolute waiver of all civil liability <span class="keyword">in</span> connection with the</span><br><span class="line">Program, unless a warranty or assumption of liability accompanies a</span><br><span class="line">copy of the Program <span class="keyword">in</span> <span class="built_in">return</span> <span class="keyword">for</span> a fee.</span><br></pre></td></tr></table></figure><h2 id="show-configuration"><a href="#show-configuration" class="headerlink" title="show configuration"></a>show configuration</h2><p>最后一个 <code>show configuration</code> 展示的 <code>gdb</code> 的一下配置信息，比如 <code>--with-system-gdbinit=/etc/gdb/gdbinit</code> 在进阶版的 <code>gdb</code> 调试技巧中应该经常用到，先有个印象就行。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">(gdb) show configuration</span><br><span class="line">This GDB was configured as follows:</span><br><span class="line">   configure --host=x86_64-linux-gnu --target=x86_64-linux-gnu</span><br><span class="line">             --with-auto-load-dir=<span class="variable">$debugdir</span>:<span class="variable">$datadir</span>/auto-load</span><br><span class="line">             --with-auto-load-safe-path=<span class="variable">$debugdir</span>:<span class="variable">$datadir</span>/auto-load</span><br><span class="line">             --with-expat</span><br><span class="line">             --with-gdb-datadir=/usr/share/gdb (relocatable)</span><br><span class="line">             --with-jit-reader-dir=/usr/lib/gdb (relocatable)</span><br><span class="line">             --without-libunwind-ia64</span><br><span class="line">             --with-lzma</span><br><span class="line">             --with-python=/usr (relocatable)</span><br><span class="line">             --without-guile</span><br><span class="line">             --with-separate-debug-dir=/usr/lib/debug (relocatable)</span><br><span class="line">             --with-system-gdbinit=/etc/gdb/gdbinit</span><br><span class="line">             --with-babeltrace</span><br><span class="line"></span><br><span class="line">(<span class="string">"Relocatable"</span> means the directory can be moved with the GDB installation</span><br><span class="line">tree, and GDB will still find it.)</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure><h2 id="apropos"><a href="#apropos" class="headerlink" title="apropos"></a>apropos</h2><p>其实在 <code>gdb</code> 启动说明中还展示了 <code>apropos</code> 这个命令，可以用这个命令来显示与指定词语相关的命令，比如 <code>apropos print</code> 就是查询所有描述中带有 <code>print</code> 的命令，可以执行测试一下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">(gdb) apropos <span class="built_in">print</span></span><br><span class="line">agent-printf -- Agent-printf <span class="string">"printf format string"</span></span><br><span class="line"><span class="built_in">alias</span> -- Define a new <span class="built_in">command</span> that is an <span class="built_in">alias</span> of an existing <span class="built_in">command</span></span><br><span class="line">backtrace -- Print backtrace of all stack frames</span><br><span class="line">bt -- Print backtrace of all stack frames</span><br><span class="line">call -- Call a <span class="keyword">function</span> <span class="keyword">in</span> the program</span><br><span class="line">commands -- Set commands to be executed when a breakpoint is hit</span><br><span class="line">compile code -- Compile</span><br><span class="line">compile <span class="built_in">print</span> -- Evaluate EXPR by using the compiler and <span class="built_in">print</span> result</span><br><span class="line"><span class="built_in">disable</span> pretty-printer -- GDB <span class="built_in">command</span> to <span class="built_in">disable</span> the specified pretty-printer</span><br><span class="line">...</span><br><span class="line">info <span class="built_in">type</span>-printers -- GDB <span class="built_in">command</span> to list all registered <span class="built_in">type</span>-printers</span><br><span class="line">info vector -- Print the status of the vector unit</span><br><span class="line">inspect -- Print value of expression EXP</span><br><span class="line">maintenance agent-printf -- Translate an expression into remote agent bytecode <span class="keyword">for</span> evaluation and display the bytecodes</span><br><span class="line">maintenance btrace packet-history -- Print the raw branch tracing data</span><br><span class="line">---Type &lt;<span class="built_in">return</span>&gt; to <span class="built_in">continue</span>, or q &lt;<span class="built_in">return</span>&gt; to quit---</span><br></pre></td></tr></table></figure><h2 id="help"><a href="#help" class="headerlink" title="help"></a>help</h2><p>查询具体的命令可以使用 <code>help</code> 子命令，比如查看 <code>bt</code> 这个查看调用栈帧的命令就可以使用 <code>help bt</code>，输入后回车可以得到这个命令的描述信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(gdb) <span class="built_in">help</span> bt</span><br><span class="line">Print backtrace of all stack frames, or innermost COUNT frames.</span><br><span class="line">With a negative argument, <span class="built_in">print</span> outermost -COUNT frames.</span><br><span class="line">Use of the <span class="string">'full'</span> qualifier also prints the values of the <span class="built_in">local</span> variables.</span><br><span class="line">Use of the <span class="string">'no-filters'</span> qualifier prohibits frame filters from executing</span><br><span class="line">on this backtrace.</span><br></pre></td></tr></table></figure><p><code>gdb</code>工作作为一款调试利器，可以使用的命令是在是太多了，除了这些还有很多命令等着我们去发现，今天的内容仅仅作为入门必备先简单了解一下。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li><code>gdb</code> 是一个交互式的命令行调试工具，通过不断执行命令，展示调试信息帮助我们调试程序</li><li>当启动 <code>gdb</code> 这个工具后，命令行会变成 <code>(gdb)</code>的形式，等着我们输入命令开始调试使用</li><li><code>gdb</code> 作为一个强大的 <code>GNU</code> 工具，文档比较全，如果觉的文档枯燥，也可以跟着我的总结来熟悉一下基础用法。</li><li>开源环境下软件的版权信息和免责声明写的都比较完整，其中有很多描述值得我们学习。</li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/107724714" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>而世之奇伟、瑰怪，非常之观，常在于险远，而人之所罕至焉，故非有志者不能至也~</p><p>2020-8-5 23:17:04</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;学习 &lt;code&gt;gdb&lt;/code&gt; 使用是一个漫长的过程，先了解一下 &lt;code&gt;gdb&lt;/code&gt; 的启动方式和基础信息的查看方法，能够帮助我们更全面的认知这个工具。&lt;code&gt;gdb&lt;/code&gt; 是一个交互式命令行程序，在使用 &lt;code&gt;gdb&lt;/code&gt; 调试的时候不断的在命令行内输入命令，然后 &lt;code&gt;gdb&lt;/code&gt; 程序就会给出反馈信息，这在很大程序上可以帮助我们调试程序问题。&lt;/p&gt;
    
    </summary>
    
      <category term="GDB" scheme="http://AlbertGithubHome.github.io/blog/categories/GDB/"/>
    
    
      <category term="GDB" scheme="http://AlbertGithubHome.github.io/blog/tags/GDB/"/>
    
      <category term="manual" scheme="http://AlbertGithubHome.github.io/blog/tags/manual/"/>
    
      <category term="调试" scheme="http://AlbertGithubHome.github.io/blog/tags/%E8%B0%83%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>小白眼中的docker究竟是个什么东西</title>
    <link href="http://AlbertGithubHome.github.io/blog/2020/07/28/%E5%B0%8F%E7%99%BD%E7%9C%BC%E4%B8%AD%E7%9A%84docker%E7%A9%B6%E7%AB%9F%E6%98%AF%E4%B8%AA%E4%BB%80%E4%B9%88%E4%B8%9C%E8%A5%BF/"/>
    <id>http://AlbertGithubHome.github.io/blog/2020/07/28/小白眼中的docker究竟是个什么东西/</id>
    <published>2020-07-28T15:44:10.000Z</published>
    <updated>2020-08-01T05:43:13.785Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><code>Docker</code>，中文名：容器引擎，别名：小鲸鱼，生于2013年3月20日，有一个法裔美籍的母亲 <code>Solumon Hykes</code>，父亲是谁，不得而知。虽然只有7岁，但是在 <code>Hello World</code> 平行宇宙中也算进入了青壮年吧，正在飞速的发展着。</p><a id="more"></a><p><code>Docker</code> 这个动物选的比较有意思，是一只蓝色的鲸鱼，作为地球上最大的动物，用它来代表容器再合适不过了。不过有谁知道为什么编程技术总是和动物挂钩啊？比如 <code>Linux</code> 的企鹅，<code>Python</code> 的大蛇，<code>Hadoop</code> 的大象等等，有知道的小伙伴还请告知一下。</p><p>俗话说的好，“程序不逛动物园，肯定技术有点悬”，经常看到网上有人推荐编程学习方法，先学学基础，然后再看几本儿动物书就可以了，看来这些封面上的动物已经深入人心了。</p><p>先把这些动物放到一边，来看看这个 <code>docker</code> 究竟是什么，之前我也不知道它是什么，甚至到了现在我也不能准确的说出它是什么，我只是以一个小白的身份来学习和使用，并且把一些弄懂的知识点总结起来，方便日后查找。</p><h1 id="关于docker的疑问"><a href="#关于docker的疑问" class="headerlink" title="关于docker的疑问"></a>关于docker的疑问</h1><p>如果你之前看到 <code>docker</code> 时会有下面这些疑问，可以跟着文章梳理了解一下，如果你对这些问题的答案早已烂熟于胸，那么可以简单浏览下，帮我挑挑毛病，也是帮助想学习的同学们：</p><ol><li><code>docker</code> 最近很火啊，它到底能用来做什么？</li><li><code>docker</code> 和虚拟机好像啊，难道就是轻量虚拟机吗？它们两者还有其他的区别吗？</li><li><code>docker</code> 教程里有 <code>ubuntu</code> 上安装 <code>docker</code>，还有 <code>docker</code> 上安装 <code>linux</code>，什么鬼，到底谁装谁啊？</li><li><code>docker</code> 真的这么牛吗？那开发项目必须得用上它啊，显得高端大气上档次！</li><li><code>docker</code> 宣称构建一次，处处运行，那它应该能跨平台吧？</li></ol><p>作为小白我也是带着这些疑问开始慢慢了解 <code>docker</code> 的，特别是那个 <code>ubuntu</code> 上装 <code>docker</code>，<code>docker</code> 上还能装 <code>ubuntu</code>，都给我整蒙圈了，通过不断学习才渐渐弄清了其中的原因。</p><h1 id="疑问探索解答"><a href="#疑问探索解答" class="headerlink" title="疑问探索解答"></a>疑问探索解答</h1><h2 id="docker-是什么"><a href="#docker-是什么" class="headerlink" title="docker 是什么"></a>docker 是什么</h2><p>关于 <code>docker</code> 我们来看下常见的介绍：</p><blockquote><p><code>Docker</code> 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的 <code>Linux</code> 机器或 <code>Windows</code> 机器上，也可以实现虚拟化，容器是完全使用沙箱机制，相互之间不会有任何接口。</p></blockquote><p>从这一段话中我们可以得到以下几个知识点：</p><ol><li>它是一个容器引擎</li><li>可以用来打包应用</li><li>可以发布到 <code>linux</code> 或者 <code>windows</code> 上</li><li>可以实现虚拟化</li><li>采用沙箱机制，相互隔离</li></ol><p>结合查到的资料来了解一下 <code>docker</code>，首先它是一个容器引擎，引擎这个词经常出现，什么游戏引擎，物理引擎，发动机引擎等等，每种引擎其实就是负责一种核心工作的模块或事物，通过封装来简化工作流程，降低工作难度，而 <code>docker</code> 作为容器引擎的作用当然就是生产容器了。</p><p>它的目的就是隔离应用，在隔离空间内部署自己独特的环境，需要了解的是它并不是一项新的技术，而是利用了 <code>Linux</code> 核心中的 <code>cgroups</code> 和 <code>namespace</code> 等资源分脱机制来进行隔离，这种被称为容器的进程独立于宿主和其它的隔离的进程，是很早就存在的技术，只不过经过 <code>docker</code> 封装之后使用起来更加方便了。</p><p>再说打包应用，这也是 <code>docker</code> 迅速火起来的一个原因，因为环境部署是在太费时费力了，之前在服务器配置一个应用的运行环境，要安装各种软件，<code>Java/Tomcat/MySQL</code>等等。安装和配置这些东西非常麻烦，并且还存在各种版本，而当我们换另一台同样操作系统的服务器还要再配置一遍，有没有办法这些配置直接拷贝过来呢？其实这就是 <code>docker</code> 要做的事情，将应用与运行环境打包到一起，直接在 <code>docker</code> 中运行一个容器就好了，你所依赖的环境直接就装好了。</p><p>前面提到 <code>docker</code> 是利用了 <code>linux</code> 内核的一些特性，那么 <code>windows</code> 可以运行吗？如果你查询早期一点的资料会得到不可以的答案，或者说即使在 <code>windows</code> 上运行 <code>docker</code>，也是在中间加了一层 <code>linux</code> 虚拟机。而如今已经 2020 年了，<code>windows</code> 上可以直接安装 <code>docker for windows</code> 来启动提供 <code>docker</code> 服务，而 <code>docker for mac</code> 也使得 <code>docker</code> 运行在 <code>mac</code> 上不再困难，<code>windows</code> 很早就和 <code>docker</code> 进行了合作，最新的 <code>win10</code> 上启动 <code>docker</code> 甚至可以切换内核为 <code>linux</code> 或者 <code>windows</code>，很神奇吧。</p><p>说到这里你应该对 <code>docker</code> 有了一个简单的了解，其中有一点很重要，它和宿主机是共享内核的，这是解答上面很多疑惑的钥匙，至于虚拟化，隔离这些都很容易理解了，而这些概念在虚拟机上常常出现，所以很容易把它俩弄混。</p><h2 id="容器与虚拟机"><a href="#容器与虚拟机" class="headerlink" title="容器与虚拟机"></a>容器与虚拟机</h2><p>自从 <code>docker</code> 出现，容器和虚拟机的对比就没有停过，这些对比常常从启动时间、资源占用、隔离性，操作便利性等方面来进行比较，可以用搜索引擎搜一下，大概就是下面这个样子：</p><table><thead><tr><th>特性</th><th>Docker容器</th><th>VM虚拟机</th></tr></thead><tbody><tr><td>启动速速</td><td>秒级</td><td>分钟级</td></tr><tr><td>性能</td><td>接近原生</td><td>明显弱于原生</td></tr><tr><td>硬盘使用</td><td>相对较小，可以自由分配</td><td>创建时分配，易造成浪费</td></tr><tr><td>系统支持量</td><td>支持上千个</td><td>一般几十个</td></tr></tbody></table><p>造成这种差异的原因是什么？还是前面说的 <code>docker</code> 和宿主机是共享内核，而虚拟机是自己创建了一整套系统，虽然隔离性更强，但是也造成了资源的浪费和效率的降低。</p><p>一直想找一个例子来形象地对比一下虚拟机和容器，我强行编一个吧，比如你是一个财富自由的人，准备回老家养养牛种种菜，包个鱼塘钓钓鱼，顺便再养一窝小白兔，但是小白兔会吃你种的蔬菜，牛偶尔也会踩到小白兔，这时怎么办，把它们隔开呗。</p><p>作为一个钱花不完的人，你准备造几个“小地球”，然后把饲养的动物和种植的植物都放到各自的“地球”中放养，每个小地球都是一个密封的环境，里面有自己的太阳、月亮、空气、河流、山川等等，这种方法当然可以，只是成本有些高，一旦建立了这个小地球，它所占有的资源就定下来了，基本上与大地球隔离，但是它还要依赖大地球，还要建立在地球上，可以类比下<strong>虚拟机</strong>。</p><p>因为建造小地球太费时费力了，所以你改了策略，这次不创建完全密闭的环境了，我直接造个篱笆就可以了，阳光、空气、河流我还是使用大地球的，只是在篱笆里我进行定制，做一些鱼塘、蔬菜大棚等等。由于建造篱笆非常省事，我可以批量生产，有需要了我可以直接拿来几个，放在地上就可以使用了，并且不同动物以及植物之间都有篱笆挡着，不会出现相互影响的问题了，这就有点像<strong>容器</strong>了。</p><p>虽然有些牵强，但是这个例子还是可以帮助我们了解容器和虚拟机的区别，实际上容器与虚拟机并不是对立的关系，有时为了防止容器无限制的占用物理机资源，还会现在物理机上运行虚拟机，然后在虚拟机里运行 <code>docker</code>，他们两者只是不同需求下的不同选择而已。</p><h2 id="操作系统和容器到底谁安装谁"><a href="#操作系统和容器到底谁安装谁" class="headerlink" title="操作系统和容器到底谁安装谁"></a>操作系统和容器到底谁安装谁</h2><p>前面说过 <code>ubuntu</code> 上装 <code>docker</code>，<code>docker</code> 上还能装 <code>ubuntu</code> 这个问题困扰了我好久，实际上 <code>windows</code> 可以装虚拟机，而虚拟机中有可以装 <code>windows</code> 这没什么好奇怪的，这里的 <code>dokcker</code> 指的就是 <code>docker</code> 引擎，或者认为是 <code>docker</code> 服务器。</p><p>它们确实可以相互安装，但情况是不同的，首先说 <code>ubuntu</code> 上装 <code>docker</code>，<code>docker</code> 说白了还是一种软件，本质上和你在电脑上装个QQ也没有多大差别，只不过这个软件有点特殊，通过它还能下载、安装别的环境，这么说它看起来有点像应用商店了，不过他虽然提供仓库，但是不仅仅是仓库，本质上它就是一种帮助你搭建环境的软件。</p><p>再来看看 <code>docker</code> 上装 <code>ubuntu</code>，还记得之前说过的一个重点吗？ <code>docker</code> 上安装的环境与宿主机共享内核，这就决定了他不能安装完整的系统，不管是 <code>ubuntu</code>、<code>CentOS</code> 还是 <code>RedHat</code>，它所安装的系统仅仅包含运行库和工具链，内核还是用宿主机的，相当于在 <code>docker</code> 中给内核套了一个新的壳子而已。</p><p>这下应该清楚了，<code>ubuntu</code> 上装 <code>docker</code> 就是在 <code>ubuntu</code> 上装了一个容器软件， <code>docker</code> 上装 <code>ubuntu</code> 就是在 <code>docker</code> 容器中给宿主内核套上了一个新系统的壳子，使其满足应用软件的环境，配备应用软件可使用的工具链。</p><h2 id="这么厉害的容器项目中一定要用吗"><a href="#这么厉害的容器项目中一定要用吗" class="headerlink" title="这么厉害的容器项目中一定要用吗"></a>这么厉害的容器项目中一定要用吗</h2><p>相信这种问题就是不了解容器也可以回答，肯定不是都要用啊，没有什么技术是只有优点没有缺点吧，凡是技术总有其适合的领域和场景，一味的追求最新的技术不一定符合所要开发的项目。</p><p><code>docker</code> 也没有传说的那么神，它也有着这样那样的问题，比如一直津津乐道的资源伸缩机制，不像虚拟机那样创建时便规定了资源大小，即使不使用也占用着，而 <code>docker</code> 可以直接使用宿主资源，避免了很多浪费。但是反过来想，虚拟机规定了资源的多少，如果不够用了只影响它自己，而 <code>docker</code> 如果一个环境出了问题，它可以把整个物理机的资源耗完，影响机器上的所有服务。</p><p>另外，<code>docker</code> 建议只部署无状态的服务，它们不应该承载任何交易数据，所有数据应该保存在数据库服务器中，器随时可以停止、或者删除。当容器被删除掉，容器里的数据将会丢失，即使你要把 <code>docker</code> 数据放在主机来存储，它依然不能保证不丢数据，具体的细节我也在学习，有这方面经验的朋友可以发表一下见解。</p><h2 id="docker的跨平台"><a href="#docker的跨平台" class="headerlink" title="docker的跨平台"></a>docker的跨平台</h2><p>先来看看跨平台的概念：</p><blockquote><p>跨平台概念是软件开发中一个重要的概念，即不依赖于操作系统，也不依赖硬件环境。一个操作系统下开发的应用，放到另一个操作系统下依然可以运行。</p></blockquote><p>首先要弄明白你说的跨平台指的是 <code>docker</code> 跨平台，还是它里边的应用使用 <code>docker</code> 就能跨平台了，从定义来说 <code>docker</code> 这个容器软件应该算是跨平台的，毕竟 <code>Linux</code>、 <code>Windows</code>、 <code>Mac</code> 都有了 <code>docker</code> 的安装包，那么他里面的镜像运行之后的容器能跨平台吗？这还要看具体的应用，<code>docker</code> 没有让一个非跨平台软件变成跨平台软件的能力。</p><p>关于这一点你还要牢记前面说的，<code>docker</code> 中的环境与宿主机共享内核，你创建了一个自己编写的exe程序的镜像，拿到安装了 <code>docker</code> 的 <code>ubuntu</code> 机器上显然是无法成功运行的。</p><h1 id="基础知识点"><a href="#基础知识点" class="headerlink" title="基础知识点"></a>基础知识点</h1><h2 id="docker的缺点"><a href="#docker的缺点" class="headerlink" title="docker的缺点"></a>docker的缺点</h2><p><code>docker</code> 的卖点是让你摆脱配置环境的困扰，但真实情况是你打包镜像的机器和系统版本，最好和你要运行的目标机器和系统版本一致，另外 <code>docker</code> 环境最好也一样，忽然感觉它没有那么神奇了，这不还是要求版本吗？</p><p>试想一下，你用一个高版本的 <code>docker</code> 服务打包，其中使用了一些新特性，然后放到低版本的 <code>docker</code> 服务下怎么能保证成功运行，机器配置也是一样，之前看到过一个问题 “尝试在具有 <code>4.19</code> 或更高内核的 <code>Linux</code> 系统上运行 <code>docker official centos:6</code> 或 <code>centos:5</code> 容器，当尝试启动它时，你会发现内核和程序不兼容”。</p><p>这样看来，<code>docker</code> 只适合在相同环境下批量复制，使得实现自动化测试和持续的集成很方便，但还是有些问题需要注意的：</p><ol><li><code>docker</code> 是基于64位系统环境的，32位环境下无法使用</li><li>隔离性相比 <code>KVM</code> 之类的虚拟化方案还是有些欠缺</li><li>容器随着用户进程的停止而销毁，其中的日志、打点等用户数据不便收集</li><li>网络管理相对简单，主要是基于 <code>namespace</code> 隔离</li><li>容器的 <code>root</code> 和宿主机 <code>root</code> 等同，这使得容器容易受到攻击</li><li>…</li></ol><h2 id="docker-的组成"><a href="#docker-的组成" class="headerlink" title="docker 的组成"></a>docker 的组成</h2><p>前面一直在说初学 <code>docker</code> 时的疑问，接下来看看 <code>docker</code> 究竟都包括哪些内容，<code>docker</code> 这个容器引擎实际上是一个客户端/服务器应用程序，客户端负责与守护的服务进程进行对话，而服务进程负责构建、运行和分发 <code>docker</code> 容器。<br><code>docker</code> 客户端和服务进程可以在同一系统上运行，也可以进行远程访问，通过网络接口使用 <code>RESTful API</code> 进行通信。</p><p>使用 <code>docker</code> 时常常要接触三个概念：镜像（Image）、容器（Container）和仓库（Repository）。简单来说镜像就是我们的想要打包的程序机加上程序运行环境，打包出来的一个文件，相当于程序安装包。当镜像运行起来我们就得到了容器，镜像与容器的关系就类似于类和对象的关系。仓库就是存放镜像的地方，与代码的仓库 <code>Github</code> 很像，<code>docker</code> 镜像也有一个常用的仓库叫 <code>Docker Hub</code>，方便人们直接下载镜像来运行。</p><h2 id="运行一个镜像"><a href="#运行一个镜像" class="headerlink" title="运行一个镜像"></a>运行一个镜像</h2><p><code>Hello world</code> 常常被拿来新知识的入门和开头，今天我们用这个例子来做一下收尾吧，首先你得有 <code>docker</code> 环境，说人话就是你得装了 <code>docker</code> 软件，之前不是一直说 <code>docker</code> 就是一个软件吗，你想用它当然得安装了，这类教程很多，假设你已经安装完了，</p><p>我们在一台 <code>CentOS</code> 上操作使用一下 <code>docker</code>，查询下系统版本和 <code>docker</code> 版本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@remote-os ~]<span class="comment"># lsb_release -a</span></span><br><span class="line">LSB Version:    :core-4.1-amd64:core-4.1-noarch</span><br><span class="line">Distributor ID: CentOS</span><br><span class="line">Description:    CentOS Linux release 7.7.1908 (Core)</span><br><span class="line">Release:    7.7.1908</span><br><span class="line">Codename:   Core</span><br><span class="line">[root@remote-os ~]<span class="comment"># docker --version</span></span><br><span class="line">Docker version 19.03.7, build 7141c199a2</span><br><span class="line">[root@remote-os ~]<span class="comment">#</span></span><br></pre></td></tr></table></figure><p>首先下载 <code>hello world</code> 镜像，使用 <code>docker image pull hello-world</code> 命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@remote-os ~]<span class="comment"># docker image pull hello-world</span></span><br><span class="line">Using default tag: latest</span><br><span class="line">latest: Pulling from library/hello-world</span><br><span class="line">Digest: sha256:49a1c8800c94df04e9658809b006fd8a686cab8028d33cfba2cc049724254202</span><br><span class="line">Status: Image is up to date <span class="keyword">for</span> hello-world:latest</span><br><span class="line">docker.io/library/hello-world:latest</span><br></pre></td></tr></table></figure><p>查看本地镜，使用 <code>docker image ls</code> 命令，发现 <code>hell-world</code> 镜像已经在本地了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@remote-os ~]<span class="comment"># docker image ls</span></span><br><span class="line">REPOSITORY                  TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">ubuntu                      latest              adafef2e596e        3 weeks ago         73.9MB</span><br><span class="line">registry                    latest              708bc6af7e5e        6 months ago        25.8MB</span><br><span class="line">hello-world                 latest              bf756fb1ae65        7 months ago        13.3kB</span><br><span class="line">wurstmeister/zookeeper      latest              3f43f72cb283        18 months ago       510MB</span><br><span class="line">hyper/docker-registry-web   latest              0db5683824d8        3 years ago         599MB</span><br><span class="line">[root@remote-os ~]<span class="comment">#</span></span><br></pre></td></tr></table></figure><p>下载完成之后直接使用 <code>docker container run hello-world</code> 命令运行就可以了，这个镜像运行打印完直接就退出了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[root@remote-os ~]<span class="comment"># docker container run hello-world</span></span><br><span class="line"></span><br><span class="line">Hello from Docker!</span><br><span class="line">This message shows that your installation appears to be working correctly.</span><br><span class="line"></span><br><span class="line">To generate this message, Docker took the following steps:</span><br><span class="line"> 1. The Docker client contacted the Docker daemon.</span><br><span class="line"> 2. The Docker daemon pulled the <span class="string">"hello-world"</span> image from the Docker Hub.</span><br><span class="line">    (amd64)</span><br><span class="line"> 3. The Docker daemon created a new container from that image <span class="built_in">which</span> runs the</span><br><span class="line">    executable that produces the output you are currently reading.</span><br><span class="line"> 4. The Docker daemon streamed that output to the Docker client, <span class="built_in">which</span> sent it</span><br><span class="line">    to your terminal.</span><br><span class="line"></span><br><span class="line">To try something more ambitious, you can run an Ubuntu container with:</span><br><span class="line"> $ docker run -it ubuntu bash</span><br><span class="line"></span><br><span class="line">Share images, automate workflows, and more with a free Docker ID:</span><br><span class="line"> https://hub.docker.com/</span><br><span class="line"></span><br><span class="line">For more examples and ideas, visit:</span><br><span class="line"> https://docs.docker.com/get-started/</span><br></pre></td></tr></table></figure><p>如果不想退出，运行的镜像应该是能提供某种服务的，比如前面一直说的 <code>ubuntu</code>，它可以在 <code>docker</code> 中运行起来，直接使用 <code>docker container run -it ubuntu bash</code> 命令就行，这里为什么我们不先下载呢？实际上如果你指定的镜像在本地没有的话会自动下载，不需要手动下载完再运行。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@remote-os ~]<span class="comment"># docker container run -it ubuntu bash</span></span><br><span class="line">root@0577050677ac:/<span class="comment"># cat /etc/issue</span></span><br><span class="line">Ubuntu 20.04 LTS \n \l</span><br><span class="line"></span><br><span class="line">root@0ecfed0920aa:/<span class="comment"># ls</span></span><br><span class="line">bin  boot  dev  etc  home  lib  lib32  lib64  libx32  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var</span><br><span class="line">root@0ecfed0920aa:/<span class="comment"># ll home/</span></span><br><span class="line">total 8</span><br><span class="line">drwxr-xr-x 2 root root 4096 Apr 15 11:09 ./</span><br><span class="line">drwxr-xr-x 1 root root 4096 Jul 31 16:23 ../</span><br><span class="line">root@0ecfed0920aa:/<span class="comment">#</span></span><br></pre></td></tr></table></figure><p>可以看到上面的操作，我们又进入了 <code>ubuntu</code> 系统，成功运行了镜像，现在得到了一个容器，可以通过 <code>docker container ls</code> 命令查看，还可以通过 <code>docker container rm [containerID]</code> 命令来删除容器。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li><code>docker</code> 软件可以运行在<code>windows</code>、<code>linux</code> 和 <code>mac</code> 上</li><li><code>docker</code> 容器与宿主机共享一个系统内核，如果依赖内核版本的应用最好保证物理机系统版本一致</li><li><code>docker</code> 容器与虚拟机并不是对立的，有时候会放在一起配合使用</li><li><code>docker</code> 有自己的镜像仓库，可以直接下载安装，使用起来相当方便，因为网络原因，如果想快速搭建最好提前准备好镜像文件</li></ul><hr><h2 id="gt-gt-反爬链接，请勿点击，原地爆炸，概不负责！-lt-lt"><a href="#gt-gt-反爬链接，请勿点击，原地爆炸，概不负责！-lt-lt" class="headerlink" title=" ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== "></a><center><a href="https://blog.csdn.net/albertsh/article/details/107587859" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center></h2><blockquote><p>海纳百川有容乃大，壁立千仞无欲则刚~</p><p>2020-8-1 00:31:35</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&lt;code&gt;Docker&lt;/code&gt;，中文名：容器引擎，别名：小鲸鱼，生于2013年3月20日，有一个法裔美籍的母亲 &lt;code&gt;Solumon Hykes&lt;/code&gt;，父亲是谁，不得而知。虽然只有7岁，但是在 &lt;code&gt;Hello World&lt;/code&gt; 平行宇宙中也算进入了青壮年吧，正在飞速的发展着。&lt;/p&gt;
    
    </summary>
    
      <category term="docker" scheme="http://AlbertGithubHome.github.io/blog/categories/docker/"/>
    
    
      <category term="docker" scheme="http://AlbertGithubHome.github.io/blog/tags/docker/"/>
    
      <category term="容器" scheme="http://AlbertGithubHome.github.io/blog/tags/%E5%AE%B9%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>GDB调试指北大全</title>
    <link href="http://AlbertGithubHome.github.io/blog/2020/07/18/GDB%E8%B0%83%E8%AF%95%E6%8C%87%E5%8C%97%E5%A4%A7%E5%85%A8/"/>
    <id>http://AlbertGithubHome.github.io/blog/2020/07/18/GDB调试指北大全/</id>
    <published>2020-07-18T08:34:29.000Z</published>
    <updated>2020-07-25T13:12:28.509Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><code>GDB</code> 作为程序调试利器，是一个受通用公共许可证（GPL）保护的自由软件，全称是 <code>GNU Debugger</code>，又常常被称为 <code>GNU symbolic debugger</code> 或者 <code>GNU project debugger</code>，能够帮助开发者调试程序，分析应用程序运行过程。目前支持调试 <code>C</code>、 <code>C++</code>、 <code>D</code>、 <code>Go</code>、 <code>Objective-C</code>、 <code>Fortran</code>、 <code>Java</code>、 <code>OpenCL C</code>、 <code>Pascal</code>、 <code>assembly</code>、 <code>Modula-2</code>、 <code>Ada</code> 等多种编程语言。</p><a id="more"></a><h1 id="GDB能做什么"><a href="#GDB能做什么" class="headerlink" title="GDB能做什么"></a>GDB能做什么</h1><p><code>GDB</code> 是调试程序的强大武器，能够帮助开发者找出程序出现BUG的原因，但是不要指望它能自己查问题，它仅仅是一个工具，可以帮助我们查找问题原因，常常被用来做以下事情：</p><ul><li>分析程序崩溃的原因</li><li>查找程序表现出错误行为的原因</li><li>找到一些从源码上难以发现的逻辑错误</li></ul><h1 id="GDB调试步骤"><a href="#GDB调试步骤" class="headerlink" title="GDB调试步骤"></a>GDB调试步骤</h1><ol><li>使用 <code>g++</code> 附加 <code>-g</code> 参数编译程序，<code>g++ -g mainpro.cpp -o mainpro</code></li><li>使用 <code>gdb</code> 程序来启动调试我们自己构建的程序，<code>gdb mainpro</code></li><li>使用 <code>run</code>、<code>break</code>、<code>print</code> 等命令调试程序</li><li>使用 <code>quit</code> 命令退出程序</li></ol><h1 id="GDB调试示例"><a href="#GDB调试示例" class="headerlink" title="GDB调试示例"></a>GDB调试示例</h1><ol><li>编写示例程序代码，保存到文件 <code>mainpro.cpp</code> 中</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">110</span>, b = <span class="number">119</span>, c;</span><br><span class="line"></span><br><span class="line">    c = a + b;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"c = "</span> &lt;&lt; c &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>使用 <code>g++</code> 附加 <code>-g</code> 参数编译程序</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:~$ g++ -g mainpro.cpp -o mainpro</span><br><span class="line">albert@home-pc:~$ ls</span><br><span class="line">mainpro  mainpro.cpp</span><br></pre></td></tr></table></figure><ol><li>使用 <code>gdb</code> 命令来启动调试</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:~$ gdb mainpro</span><br><span class="line">GNU gdb (Ubuntu 7.11.1-0ubuntu1~16.5) 7.11.1</span><br><span class="line">Copyright (C) 2016 Free Software Foundation, Inc.</span><br><span class="line">License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;</span><br><span class="line">This is free software: you are free to change and redistribute it.</span><br><span class="line">There is NO WARRANTY, to the extent permitted by law.  Type <span class="string">"show copying"</span></span><br><span class="line">and <span class="string">"show warranty"</span> <span class="keyword">for</span> details.</span><br><span class="line">This GDB was configured as <span class="string">"x86_64-linux-gnu"</span>.</span><br><span class="line">Type <span class="string">"show configuration"</span> <span class="keyword">for</span> configuration details.</span><br><span class="line">For bug reporting instructions, please see:</span><br><span class="line">&lt;http://www.gnu.org/software/gdb/bugs/&gt;.</span><br><span class="line">Find the GDB manual and other documentation resources online at:</span><br><span class="line">&lt;http://www.gnu.org/software/gdb/documentation/&gt;.</span><br><span class="line">For <span class="built_in">help</span>, <span class="built_in">type</span> <span class="string">"help"</span>.</span><br><span class="line">Type <span class="string">"apropos word"</span> to search <span class="keyword">for</span> commands related to <span class="string">"word"</span>...</span><br><span class="line">Reading symbols from mainpro...done.</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure><ol><li>使用 <code>break 8</code> 在第8行打断点，使用 <code>run</code> 命令启动程序，使用 <code>print c</code> 打印程序变量</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(gdb) <span class="built_in">break</span> 8</span><br><span class="line">Breakpoint 1 at 0x4008b7: file mainpro.cpp, line 8.</span><br><span class="line">(gdb) run</span><br><span class="line">Starting program: /home/albert/mainpro</span><br><span class="line"></span><br><span class="line">Breakpoint 1, main () at mainpro.cpp:8</span><br><span class="line">8       std::cout &lt;&lt; <span class="string">"c = "</span> &lt;&lt; c &lt;&lt; std::endl;</span><br><span class="line">(gdb) <span class="built_in">print</span> c</span><br><span class="line"><span class="variable">$1</span> = 239</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure><ol><li>使用 <code>quit</code> 命令退出程序</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(gdb) quit</span><br><span class="line">A debugging session is active.</span><br><span class="line"></span><br><span class="line">    Inferior 1 [process 227] will be killed.</span><br><span class="line"></span><br><span class="line">Quit anyway? (y or n) y</span><br><span class="line">albert@home-pc:~$</span><br></pre></td></tr></table></figure><h1 id="GDB启动参数与命令列表（持续更新）"><a href="#GDB启动参数与命令列表（持续更新）" class="headerlink" title="GDB启动参数与命令列表（持续更新）"></a>GDB启动参数与命令列表（持续更新）</h1><p><code>GDB</code> 众多的启动参数和命令提供了强大的调试功能，每一条都可以展开得到很多知识，这些知识的学习是一个持续的过程，短时间无法消化和吸收，所以准备总结一个系列，从最简单的命令开始总结，持续更新学习下去，文章链接不定期更新。</p><table><thead><tr><th style="text-align:center">GDB命令</th><th style="text-align:center">备注</th><th style="text-align:center">参考文章</th></tr></thead><tbody><tr><td style="text-align:center"><code>gdb</code>、<code>gdb -q</code></td><td style="text-align:center">GDB启动、查看说明</td><td style="text-align:center">[GDB调试指北-启动GDB与查看说明]</td></tr><tr><td style="text-align:center"><code>gdb pro</code>、<code>gdb pro 123</code></td><td style="text-align:center">启动调试程序、调试正在运行的程序</td><td style="text-align:center">[GDB调试指北-使用GDB启动调试]</td></tr><tr><td style="text-align:center"><code>directory new-path</code></td><td style="text-align:center">查看调试源码</td><td style="text-align:center"><a href="https://blog.csdn.net/shihengzhen101/article/details/107274490" target="_blank" rel="noopener">GDB调试指北-查找丢失源码文件</a></td></tr><tr><td style="text-align:center"><code>set substitute from-path to-path</code></td><td style="text-align:center">查看调试源码</td><td style="text-align:center"><a href="https://blog.csdn.net/shihengzhen101/article/details/107274490" target="_blank" rel="noopener">GDB调试指北-查找丢失源码文件</a></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td></tr></tbody></table><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li><code>GDB</code> 调试技巧更多的是工具本身的功能，所谓“重剑无锋，大巧不工”，熟练利用这个工具才能发挥最大的威力</li><li>知识的学习时一个持续的过程，只有不断的学习和总结才能不断进步，而不要被那些花里胡哨的外表所迷惑</li><li>有些知识学着学着就通了，前几天看到 <code>printf</code> 这个函数，很疑惑为什么末尾要加个 <code>f</code>，猜想它是格式化 <code>format</code> 的意思</li><li>经过查证果然如此，此时距离第一次在 C 语言中学习 <code>printf</code> 函数已经过去了10年</li></ul><hr><h2 id="gt-gt-反爬链接，请勿点击，原地爆炸，概不负责！-lt-lt"><a href="#gt-gt-反爬链接，请勿点击，原地爆炸，概不负责！-lt-lt" class="headerlink" title=" ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== "></a><center><a href="https://blog.csdn.net/albertsh/article/details/107274490" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center></h2><blockquote><p>大漠孤烟直，长河落日圆~</p><p>2020-7-18 20:09:58</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&lt;code&gt;GDB&lt;/code&gt; 作为程序调试利器，是一个受通用公共许可证（GPL）保护的自由软件，全称是 &lt;code&gt;GNU Debugger&lt;/code&gt;，又常常被称为 &lt;code&gt;GNU symbolic debugger&lt;/code&gt; 或者 &lt;code&gt;GNU project debugger&lt;/code&gt;，能够帮助开发者调试程序，分析应用程序运行过程。目前支持调试 &lt;code&gt;C&lt;/code&gt;、 &lt;code&gt;C++&lt;/code&gt;、 &lt;code&gt;D&lt;/code&gt;、 &lt;code&gt;Go&lt;/code&gt;、 &lt;code&gt;Objective-C&lt;/code&gt;、 &lt;code&gt;Fortran&lt;/code&gt;、 &lt;code&gt;Java&lt;/code&gt;、 &lt;code&gt;OpenCL C&lt;/code&gt;、 &lt;code&gt;Pascal&lt;/code&gt;、 &lt;code&gt;assembly&lt;/code&gt;、 &lt;code&gt;Modula-2&lt;/code&gt;、 &lt;code&gt;Ada&lt;/code&gt; 等多种编程语言。&lt;/p&gt;
    
    </summary>
    
      <category term="GDB" scheme="http://AlbertGithubHome.github.io/blog/categories/GDB/"/>
    
    
      <category term="GDB" scheme="http://AlbertGithubHome.github.io/blog/tags/GDB/"/>
    
      <category term="manual" scheme="http://AlbertGithubHome.github.io/blog/tags/manual/"/>
    
  </entry>
  
  <entry>
    <title>gdb调试解决找不到源代码的问题</title>
    <link href="http://AlbertGithubHome.github.io/blog/2020/07/13/gdb%E8%B0%83%E8%AF%95%E8%A7%A3%E5%86%B3%E6%89%BE%E4%B8%8D%E5%88%B0%E6%BA%90%E4%BB%A3%E7%A0%81%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://AlbertGithubHome.github.io/blog/2020/07/13/gdb调试解决找不到源代码的问题/</id>
    <published>2020-07-13T15:54:14.000Z</published>
    <updated>2020-07-18T15:14:52.795Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>通过 <code>gdb</code> 启动程序，打好断点运行，开始调试输入 <code>list</code> 命令，结果发现找不到源代码，是不是很糟心，让我们来看看怎么解决这种情况。</p><a id="more"></a><p>先來说明我们要处理的情况，调试程序找不到源代码首先你得有源代码，如果编译完程序你把源代码删了，或者单独把执行程序拷贝到一个没有源代码的机器上，那么拜拜吧您嘞，这种情况不是本文能解决的。</p><p>如果你确实有源代码，正常编译源代码并且加入了 <code>-g</code> 选项，编译完之后没有改变源代码位置，那么调试的时候基本都会找到源代码，所以这种情况也不在我们的讨论范围之内。</p><p>分析到现在就剩下一种情况，程序编译完成之后我移动了代码的位置。实际工作中可能不会这么无聊，故意改变目录位置让调试程序找不到，但是工作中常常会出现发布机编译完代码要在开发机调试的情况，两台机器上的代码时一样的，但是源代码的位置可能放置的不同，那么在个人开发机上调试这样的程序就会找不到源代码，这也就是我们要解决的问题。</p><h1 id="找到源代码的必要性"><a href="#找到源代码的必要性" class="headerlink" title="找到源代码的必要性"></a>找到源代码的必要性</h1><p>其实在我看来找不到源代码的问题没有那么严重，编译程序里记录了文件名，行号等信息，可以在调试的时候对照着本地的源代码进行“盲调”，这种“盲调”的操作之前可没少干，因为线上环境中没有源代码，我只能一边对照着 <code>gdb</code> 调试输出的行号，一边对照本地的源代码进行程序分析，通过这种方法也解决了不少问题。</p><p>虽然看着源代码调试没有那么必要，但是如果可以看见那肯定是更好了，所以本文还是列举出最常见的处理方法，解决一下本来有代码，但因为目录不匹配无法正常调试的问题。</p><h1 id="涉及到的命令"><a href="#涉及到的命令" class="headerlink" title="涉及到的命令"></a>涉及到的命令</h1><p>下面几个命令是 <code>gdb</code> 命令，注意要放到和 <code>gdb</code> 交互命令行输入才可以，别管会不会，先混个脸熟，以后要经常用的：</p><ul><li><code>show dir</code></li><li><code>dir 目录</code></li><li><code>set dir 目录1:目录2:目录3</code></li><li><code>dir</code></li><li><code>pwd</code></li><li><code>cd 目录</code></li><li><code>set substitute-path from-path to-path</code></li></ul><h1 id="gdb怎样找源代码"><a href="#gdb怎样找源代码" class="headerlink" title="gdb怎样找源代码"></a>gdb怎样找源代码</h1><p>有时候很奇怪，代码明明就在那里，<code>gdb</code> 你睁开眼睛行不行，为什么你就是找不到呢？其实 <code>gdb</code> 也很苦的好不好，一直帮你查问题还要忍受着你每天的埋怨，到底是什么原因导致 <code>gdb</code> 对眼前的代码视而不见呢？</p><p>其实 <code>gdb</code> 查找代码也要遵循一定的规则，不能每次都全盘扫描吧，那不是得给它累死。举个例子吧，我们在安装一些软件，特别是一些命令行工具的时候，总是有一步要求你把工具或软件所在目录添加到环境变量中，这个变量的名字叫做 <code>Path</code>。</p><p>这个 <code>Path</code> 其实就是电脑上众多软件所在目录的集合，当你直接使用软件的程序时，会优先从 <code>Path</code> 这个集合中的目录下去找，成功找到就会直接调用，否则提醒你软件不存在。</p><h2 id="源代码目录集合"><a href="#源代码目录集合" class="headerlink" title="源代码目录集合"></a>源代码目录集合</h2><p>而在 <code>gdb</code> 的调试过程中也有这样一个目录集合，我暂且称它为 <code>SourcePathSet</code>，后面就用这个名字了，因为还要涉及到多种查找目录，请注意区分。</p><p><code>gdb</code> 在查找源码的时候首先在 <code>SourcePathSet</code> 中所包含的目录下找，如果找不到就会提示查找失败了，也就是这篇文章所提到的问题。</p><h2 id="源代码文件"><a href="#源代码文件" class="headerlink" title="源代码文件"></a>源代码文件</h2><p>程序在编译的过程中会记录源文件的名字和路径，这个路径可能是绝对路径，比如 <code>/mnt/d/main.cpp</code>，也可能是相对路径 <code>../main.cpp</code> ，究竟是哪一种取决于编译时使用的参数。</p><p>我们以绝对路径为例，比如文件名为 <code>/mnt/d/main.cpp</code>，我们可以把它拆分成包含路径和不包含路径两种形式：<code>/mnt/d/main.cpp</code> 和 <code>main.cpp</code>，当 <code>SourcePathSet</code> 中包含一个路径叫 <code>/mnt/e</code>时， <code>gdb</code> 搜索的路径包括以下几种：</p><ul><li><code>/mnt/d/main.cpp</code></li><li><code>/mnt/e/mnt/d/main.cpp</code></li><li><code>/mnt/e/main.cpp</code></li></ul><p>当源文件是相对路径 <code>../main.cpp</code> 的时候，那么搜索的路径就变成了下面两个：</p><ul><li><code>/mnt/e/../main.cpp</code></li><li><code>/mnt/e/main.cpp</code></li></ul><p>说到这里你可能就明白了，当 <code>gdb</code> 找不到源文件的时候，修改 <code>SourcePathSet</code> 就可以了，把想让它搜索的路径添加到 <code>SourcePathSet</code>，如果符合它的搜索规则，那么就可以找到了。</p><h2 id="目录集合的默认值"><a href="#目录集合的默认值" class="headerlink" title="目录集合的默认值"></a>目录集合的默认值</h2><p><code>SourcePathSet</code> 在 <code>gdb</code> 启动后开始生效，默认值并不是空，而是 <code>$cdir:$cwd</code>，这又是什么鬼？其中的 <code>$cdir</code> 叫做编译目录，是代码在编译时记录到程序中的，<code>$cwd</code> 表示当前的调试目录，可以通过 <code>cd</code> 命令来修改，要注意这个 <code>cd</code> 修改的是 <code>gdb</code> 会话中的当前目录，不会影响启动 <code>gdb</code> 前文件系统中的目录位置。</p><p>假设 <code>$cdir</code> 的值是 <code>/usr</code>，<code>cwd</code> 的值是 <code>/home/albert</code>，我们又添加了 <code>/mnt/e</code> 到 <code>SourcePathSet</code> 中，那么此时 <code>SourcePathSet</code> 的值为 <code>/mnt/e:$cdir:$cwd</code>，如果源文件的是 <code>/mnt/d/main.cpp</code>，查找的目录就会出现以下几种：</p><ul><li><code>/mnt/d/main.cpp</code></li><li><code>/mnt/e/mnt/d/main.cpp</code></li><li><code>/usr/mnt/d/main.cpp</code></li><li><code>/home/albert/mnt/d/main.cpp</code></li><li><code>/mnt/e/main.cpp</code></li><li><code>/usr/main.cpp</code></li><li><code>/home/albert/main.cpp</code></li></ul><h2 id="查看各种目录"><a href="#查看各种目录" class="headerlink" title="查看各种目录"></a>查看各种目录</h2><p>先做一下准备工作，编写一段简单代码，另存文件名为 <code>main.cpp</code>，保存在目录 <code>/mnt/d/cpp</code> 下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> c = a + b;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"c = "</span> &lt;&lt; c &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>切换到目录 <code>/mnt/d</code>下， 查看 <code>cpp</code> 目录下文件并使用 <code>g++</code> 编译，编译完成后将文件 <code>mian.cpp</code> 移动到 <code>/mnt</code> 目录下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:/mnt/d$ ls cpp/</span><br><span class="line">main.cpp</span><br><span class="line">albert@home-pc:/mnt/d$ g++ /mnt/d/cpp/main.cpp -g -o main</span><br><span class="line">albert@home-pc:/mnt/d$ ls main</span><br><span class="line">main</span><br><span class="line">albert@home-pc:/mnt/d$ sudo mv cpp/main.cpp ../</span><br><span class="line">[sudo] password <span class="keyword">for</span> albert:</span><br><span class="line">albert@home-pc:/mnt/d$ ls ../</span><br><span class="line">c  d  e  f  main.cpp</span><br></pre></td></tr></table></figure><p>启动 <code>gdb</code> 调试程序并打好断点，输入 <code>run</code> 运行发现，断点被触发，但是显示出 <code>No such file or directory.</code>，说明没有找到源代码文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:/mnt/d$ gdb -q main</span><br><span class="line">Reading symbols from main...done.</span><br><span class="line">(gdb) b 8</span><br><span class="line">Breakpoint 1 at 0x4008ac: file /mnt/d/cpp/main.cpp, line 8.</span><br><span class="line">(gdb) run</span><br><span class="line">Starting program: /mnt/d/main</span><br><span class="line"></span><br><span class="line">Breakpoint 1, main () at /mnt/d/cpp/main.cpp:8</span><br><span class="line">8   /mnt/d/cpp/main.cpp: No such file or directory.</span><br></pre></td></tr></table></figure><h3 id="查看源代码文件名和编译目录"><a href="#查看源代码文件名和编译目录" class="headerlink" title="查看源代码文件名和编译目录"></a>查看源代码文件名和编译目录</h3><p>直接在 <code>gdb</code> 命令行中输入 <code>info source</code> 回车就可以了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(gdb) info <span class="built_in">source</span></span><br><span class="line">Current <span class="built_in">source</span> file is /mnt/d/cpp/main.cpp</span><br><span class="line">Compilation directory is /mnt/d</span><br><span class="line">Source language is c++.</span><br><span class="line">Producer is GNU C++ 5.4.0 20160609 -mtune=generic -march=x86-64 -g -fstack-protector-strong.</span><br><span class="line">Compiled with DWARF 2 debugging format.</span><br><span class="line">Does not include preprocessor macro info.</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure><p>通过这个命令发现，源代码文件是 <code>/mnt/d/cpp/main.cpp</code>，编译目录是 <code>/mnt/d</code></p><h3 id="查看源代码搜索目录"><a href="#查看源代码搜索目录" class="headerlink" title="查看源代码搜索目录"></a>查看源代码搜索目录</h3><p>在 <code>gdb</code> 环境下输入 <code>show dir</code> 命令就可以显示 <code>SourcePathSet</code> 这个集合中都有哪些目录，由于还没有设置过现在还是默认值 <code>$cdir:$cwd</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(gdb) show dir</span><br><span class="line">Source directories searched: <span class="variable">$cdir</span>:<span class="variable">$cwd</span></span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure><h3 id="查看当前目录"><a href="#查看当前目录" class="headerlink" title="查看当前目录"></a>查看当前目录</h3><p>查看当前目录就比较简单了，直接 <code>pwd</code> 就搞定了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(gdb) <span class="built_in">pwd</span></span><br><span class="line">Working directory /mnt/d.</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure><p>我们“如愿以偿”的让 <code>gdb</code> 找不到代码了，从现在的环境来看，<code>$cdir</code> 和 <code>$cwd</code> 相同都是 <code>/mnt/d</code>，所以此时搜索的目录只有：</p><ul><li><code>/mnt/d/cpp/main.cpp</code></li><li><code>/mnt/d/mnt/d/cpp/main.cpp</code></li><li><code>/mnt/d/main.cpp</code></li></ul><p>而代码被我们移动到了<code>/mnt/main.cpp</code>，<code>gdb</code> 自然就找不到了，后面来看看具体怎么处理这种情况。</p><h1 id="具体示例"><a href="#具体示例" class="headerlink" title="具体示例"></a>具体示例</h1><p>说了这么多原理的东西，如果弄明白了这些很容易找到解决问题的办法，下面写一个完整点的例子，来感受一些具体怎么修复这个问题，新建三个文件 <code>mainpro.cpp</code>、<code>mymath.h</code>、<code>mymath.cpp</code>，目录结构和内容如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:/mnt/d$ tree /mnt/d/mainpro/</span><br><span class="line">/mnt/d/mainpro/</span><br><span class="line">|-- core</span><br><span class="line">|   `-- mainpro.cpp</span><br><span class="line">`-- kit</span><br><span class="line">    |-- mymath.cpp</span><br><span class="line">    `-- mymath.h</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//mainpro.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"../kit/mymath.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">2</span>;</span><br><span class="line">    mymath* m = <span class="keyword">new</span> mymath();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> c = m-&gt;add(a, b);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"c = "</span> &lt;&lt; c &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//mymath.h</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">mymath</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//mymath.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mymath.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> mymath::add(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> c = a + b;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>/mnt/d/mainpro</code> 目录下编译代码，然后将代码文件所在目录 <code>core</code> 和 <code>kit</code> 拷贝到 <code>/mnt/e/newpro</code> 目录下，将可执行文件拷贝到 <code>/home/albert</code> 目录下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:/mnt/d/mainpro$ g++ /mnt/d/mainpro/core/mainpro.cpp /mnt/d/mainpro/kit/mymath.cpp -g -o mainpro</span><br><span class="line">albert@home-pc:/mnt/d/mainpro$ tree</span><br><span class="line">.</span><br><span class="line">|-- core</span><br><span class="line">|   `-- mainpro.cpp</span><br><span class="line">|-- kit</span><br><span class="line">|   |-- mymath.cpp</span><br><span class="line">|   `-- mymath.h</span><br><span class="line">`-- mainpro</span><br><span class="line"></span><br><span class="line">2 directories, 4 files</span><br><span class="line">albert@home-pc:/mnt/d/mainpro$ mkdir /mnt/e/newpro</span><br><span class="line">albert@home-pc:/mnt/d/mainpro$ sudo mv core/ /mnt/e/newpro/</span><br><span class="line">albert@home-pc:/mnt/d/mainpro$ sudo mv kit/ /mnt/e/newpro/</span><br><span class="line">albert@home-pc:/mnt/d/mainpro$ mv mainpro /home/albert/</span><br></pre></td></tr></table></figure><p>在 <code>/home/albert</code> 目录下启动 <code>gdb</code> 开始调试，先在 <code>main</code> 函数打断点，查询源文件路径和编译目录等信息；</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:~$ gdb -q mainpro</span><br><span class="line">Reading symbols from mainpro...done.</span><br><span class="line">(gdb) b main</span><br><span class="line">Breakpoint 1 at 0x4008de: file /mnt/d/mainpro/core/mainpro.cpp, line 7.</span><br><span class="line">(gdb) run</span><br><span class="line">Starting program: /home/albert/mainpro</span><br><span class="line"></span><br><span class="line">Breakpoint 1, main () at /mnt/d/mainpro/core/mainpro.cpp:7</span><br><span class="line">7   /mnt/d/mainpro/core/mainpro.cpp: No such file or directory.</span><br><span class="line">(gdb) info <span class="built_in">source</span></span><br><span class="line">Current <span class="built_in">source</span> file is /mnt/d/mainpro/core/mainpro.cpp</span><br><span class="line">Compilation directory is /mnt/d/mainpro</span><br><span class="line">Source language is c++.</span><br><span class="line">Producer is GNU C++ 5.4.0 20160609 -mtune=generic -march=x86-64 -g -fstack-protector-strong.</span><br><span class="line">Compiled with DWARF 2 debugging format.</span><br><span class="line">Does not include preprocessor macro info.</span><br><span class="line">(gdb) list</span><br><span class="line">2   <span class="keyword">in</span> /mnt/d/mainpro/core/mainpro.cpp</span><br><span class="line">(gdb) <span class="built_in">pwd</span></span><br><span class="line">Working directory /home/albert.</span><br><span class="line">(gdb) show dir</span><br><span class="line">Source directories searched: <span class="variable">$cdir</span>:<span class="variable">$cwd</span></span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure><p>果然找不到源代码了，从上面的调试信息来看，可以得到以下信息：</p><ul><li>源代码文件为 <code>/mnt/d/mainpro/core/mainpro.cpp</code></li><li>程序编译目录为 <code>/mnt/d/mainpro</code></li><li>当前目录为 <code>/home/albert</code></li></ul><p>而源代码查找列表中只有 <code>$cdir:$cwd</code>，说明只包含 <code>/mnt/d/mainpro</code> 和 <code>/home/albert</code>，那么查找的目录有：</p><ul><li><code>/mnt/d/mainpro/core/mainpro.cpp</code></li><li><code>/mnt/d/mainpro/mnt/d/mainpro/core/mainpro.cpp</code></li><li><code>/home/albert/mnt/d/mainpro/core/mainpro.cpp</code></li><li><code>/mnt/d/mainpro/mainpro.cpp</code></li><li><code>/home/albert/mainpro.cpp</code></li></ul><p>这些目录显然找不到源代码文件了，因为文件已经被我移动到 <code>/mnt/e/newpro/</code> 目录下了，也就是 <code>/mnt/e/newpro/core/mainpro.cpp</code>，下面来尝试一些解决方法。</p><h2 id="使用-dir-命令解决"><a href="#使用-dir-命令解决" class="headerlink" title="使用 dir 命令解决"></a>使用 dir 命令解决</h2><p>刚才说了源代码查找集合 <code>SourcePathSet</code> 中只有 <code>$cdir:$cwd</code>，我们可以自己加一个嘛，比如像下面这样：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">(gdb) dir /mnt/e/newpro/core/</span><br><span class="line">Source directories searched: /mnt/e/newpro/core:<span class="variable">$cdir</span>:<span class="variable">$cwd</span></span><br><span class="line">(gdb) list</span><br><span class="line">2   <span class="comment">#include &lt;iostream&gt;</span></span><br><span class="line">3   using namespace std;</span><br><span class="line">4</span><br><span class="line">5   int main()</span><br><span class="line">6   &#123;</span><br><span class="line">7       int a = 1, b = 2;</span><br><span class="line">8       mymath* m = new mymath();</span><br><span class="line">9</span><br><span class="line">10      int c = m-&gt;add(a, b);</span><br><span class="line">11      cout &lt;&lt; <span class="string">"c = "</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure><p>这样就可以找到了，我们接着在 <code>add</code> 函数上下个断点，继续执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">(gdb) b mymath::add</span><br><span class="line">Breakpoint 2 at 0x4009a6: file /mnt/d/mainpro/kit/mymath.cpp, line 6.</span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line"></span><br><span class="line">Breakpoint 2, mymath::add (this=0x613c20, a=1, b=2) at /mnt/d/mainpro/kit/mymath.cpp:6</span><br><span class="line">6   /mnt/d/mainpro/kit/mymath.cpp: No such file or directory.</span><br><span class="line">(gdb) list</span><br><span class="line">1   <span class="keyword">in</span> /mnt/d/mainpro/kit/mymath.cpp</span><br><span class="line">(gdb) info <span class="built_in">source</span></span><br><span class="line">Current <span class="built_in">source</span> file is /mnt/d/mainpro/kit/mymath.cpp</span><br><span class="line">Source language is c++.</span><br><span class="line">Producer is GNU C++ 5.4.0 20160609 -mtune=generic -march=x86-64 -g -fstack-protector-strong.</span><br><span class="line">Compiled with DWARF 2 debugging format.</span><br><span class="line">Does not include preprocessor macro info.</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure><p>结果发现又找不到文件 <code>/mnt/d/mainpro/kit/mymath.cpp</code> 了，因为和之前不是一个文件，这个文件在其他的目录下，所以还要使用 <code>dir</code> 命令，把新的目录加到源代码查找集合 <code>SourcePathSet</code> 中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">(gdb) dir /mnt/e/newpro/kit/</span><br><span class="line">Source directories searched: /mnt/e/newpro/kit:/mnt/e/newpro/core:<span class="variable">$cdir</span>:<span class="variable">$cwd</span></span><br><span class="line">(gdb) list</span><br><span class="line">1   <span class="comment">#include "../kit/mymath.h"</span></span><br><span class="line">2   <span class="comment">#include &lt;iostream&gt;</span></span><br><span class="line">3   using namespace std;</span><br><span class="line">4</span><br><span class="line">5   int main()</span><br><span class="line">6   &#123;</span><br><span class="line">7       int a = 1, b = 2;</span><br><span class="line">8       mymath* m = new mymath();</span><br><span class="line">9</span><br><span class="line">10      int c = m-&gt;add(a, b);</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure><p>这次又能成功找到了，可是如果有好多个文件要调试，难道要把所有的目录都加进去吗？其实可以有简便方法的，在启动 <code>gdb</code>的时候可以指定搜索的源代码路径，这些路径都会被加到到源代码查找集合 <code>SourcePathSet</code> 中，具体操作如下，先退出<code>gdb</code>，然后重新加参数启动如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:~$ gdb -q mainpro `find /mnt/e/newpro/ -<span class="built_in">type</span> d -<span class="built_in">printf</span> <span class="string">'-d %p '</span>`</span><br><span class="line">Reading symbols from mainpro...done.</span><br><span class="line">(gdb) show dir</span><br><span class="line">Source directories searched: /mnt/e/newpro/kit:/mnt/e/newpro/core:/mnt/e/newpro:<span class="variable">$cdir</span>:<span class="variable">$cwd</span></span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure><p>其实这条命令的本来面目是 <code>gdb -q mainpro -d xxxxx</code>，只不过这组合了 <code>find</code> 命令以后使用起来更加方便了，可以把指定目录下的子目录全都添加到参数中</p><h2 id="使用-cd-命令解决"><a href="#使用-cd-命令解决" class="headerlink" title="使用 cd 命令解决"></a>使用 cd 命令解决</h2><p>如果是临时调试倒是用不到上面设置启动参数那么麻烦，因为变量 <code>$cwd</code> 也在搜索集合中，既然在编译时记录的源文件被改变了位置，那么我们调整我们的当前位置，让代码出现搜索路径中，还是上面的这个例子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:~$ <span class="built_in">pwd</span></span><br><span class="line">/home/albert</span><br><span class="line">albert@home-pc:~$ gdb -q mainpro</span><br><span class="line">Reading symbols from mainpro...done.</span><br><span class="line">(gdb) b main</span><br><span class="line">Breakpoint 1 at 0x4008de: file /mnt/d/mainpro/core/mainpro.cpp, line 7.</span><br><span class="line">(gdb) r</span><br><span class="line">Starting program: /home/albert/mainpro</span><br><span class="line"></span><br><span class="line">Breakpoint 1, main () at /mnt/d/mainpro/core/mainpro.cpp:7</span><br><span class="line">7   /mnt/d/mainpro/core/mainpro.cpp: No such file or directory.</span><br><span class="line">(gdb) list</span><br><span class="line">2   <span class="keyword">in</span> /mnt/d/mainpro/core/mainpro.cpp</span><br><span class="line">(gdb) <span class="built_in">cd</span> /mnt/e/newpro/core/</span><br><span class="line">Working directory /mnt/e/newpro/core.</span><br><span class="line">(gdb) list</span><br><span class="line">2   <span class="comment">#include &lt;iostream&gt;</span></span><br><span class="line">3   using namespace std;</span><br><span class="line">4</span><br><span class="line">5   int main()</span><br><span class="line">6   &#123;</span><br><span class="line">7       int a = 1, b = 2;</span><br><span class="line">8       mymath* m = new mymath();</span><br><span class="line">9</span><br><span class="line">10      int c = m-&gt;add(a, b);</span><br><span class="line">11      cout &lt;&lt; <span class="string">"c = "</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure><p>上面的操作通过 <code>cd /mnt/e/newpro/core/</code> 命令直接进入了源代码目录，当然就找到了，但是这还是会有点问题，当碰到需要调试好几个文件的时候就需要使用 <code>cd</code> 命令跳来跳去，要想一劳永逸，请看下面这个方法。</p><h2 id="使用-set-substitute-path-命令解决"><a href="#使用-set-substitute-path-命令解决" class="headerlink" title="使用 set substitute-path 命令解决"></a>使用 set substitute-path 命令解决</h2><p>我们移动源代码的时候往往会整个目录移动，或者说开发机和发布机上面的代码文件组织结构是一样，只是所在的磁盘位置是不一样的，所以如果可以设置用一个路径替换原代码文件的路径就好了， <code>set substitute-path from-path to-path</code> 这个命令就可以达到想要的目的，这个命令还可以简写成 <code>set substitute from-path to-path</code>，比如还是前面的例子，源代码从 <code>/mnt/d/mainrpo</code> 目录整体移动到了 <code>/mnt/e/newpro</code> 目录，调试时找不到源代码可以使用 <code>set substitute /mnt/d/mainrpo /mnt/e/newpro</code> 命令来指定替换目录，这样就可以找到源代码啦，下面来测试一下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:~$ gdb -q mainpro</span><br><span class="line">Reading symbols from mainpro...done.</span><br><span class="line">(gdb) <span class="built_in">set</span> substitute-path /mnt/d/mainrpo /mnt/e/newpro</span><br><span class="line">(gdb) b main</span><br><span class="line">Breakpoint 1 at 0x4008de: file /mnt/d/mainpro/core/mainpro.cpp, line 7.</span><br><span class="line">(gdb) run</span><br><span class="line">Starting program: /home/albert/mainpro</span><br><span class="line"></span><br><span class="line">Breakpoint 1, main () at /mnt/d/mainpro/core/mainpro.cpp:7</span><br><span class="line">7   /mnt/d/mainpro/core/mainpro.cpp: No such file or directory.</span><br><span class="line">(gdb) <span class="built_in">cd</span> /mnt/e/newpro/</span><br><span class="line">Working directory /mnt/e/newpro.</span><br><span class="line">(gdb) list</span><br><span class="line">2   /mnt/d/mainpro/core/mainpro.cpp: No such file or directory.</span><br><span class="line">(gdb) <span class="built_in">set</span> substitute-path /mnt/d/mainpro /mnt/e/newpro</span><br><span class="line">(gdb) list 0</span><br><span class="line">1   <span class="comment">#include "../kit/mymath.h"</span></span><br><span class="line">2   <span class="comment">#include &lt;iostream&gt;</span></span><br><span class="line">3   using namespace std;</span><br><span class="line">4</span><br><span class="line">5   int main()</span><br><span class="line">6   &#123;</span><br><span class="line">7       int a = 1, b = 2;</span><br><span class="line">8       mymath* m = new mymath();</span><br><span class="line">9</span><br><span class="line">10      int c = m-&gt;add(a, b);</span><br><span class="line">(gdb) info <span class="built_in">source</span></span><br><span class="line">Current <span class="built_in">source</span> file is /mnt/d/mainpro/core/mainpro.cpp</span><br><span class="line">Compilation directory is /mnt/d/mainpro</span><br><span class="line">Located <span class="keyword">in</span> /mnt/e/newpro/core/mainpro.cpp</span><br><span class="line">Contains 14 lines.</span><br><span class="line">Source language is c++.</span><br><span class="line">Producer is GNU C++ 5.4.0 20160609 -mtune=generic -march=x86-64 -g -fstack-protector-strong.</span><br><span class="line">Compiled with DWARF 2 debugging format.</span><br><span class="line">Does not include preprocessor macro info.</span><br><span class="line">(gdb) <span class="built_in">pwd</span></span><br><span class="line">Working directory /home/albert.</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure><p>通过调试信息 <code>Located in /mnt/e/newpro/core/mainpro.cpp</code> 可以看到，果然在新的位置找到了源代码。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>调试的时候找不到源码有多种解决方法，需要根据实际情况选择最合适的解决方案。</li><li>编译时使用绝对路径时，推荐使用 <code>set substitute-path from-path to-path</code> 的方式。</li><li>编译时使用相对路径时，使用 <code>set substitute from-path to-path</code> 或者 <code>dir new-path</code> 都可以。</li><li>对于临时查找一个问题，单独调试某一个文件时使用 <code>cd</code> 命令就可以搞定了。</li><li>直接在 <code>gdb</code> 环境输入 <code>dir</code> 命令回车确认，可以重置 <code>dir 目录</code> 或者 <code>set dir 目录</code> 命令修改过的源代码搜索目录集合。</li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/107274490" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>当人的才华不足以撑起个人的欲望时就会感到焦虑，当面对不利的情况和事件却又无力改变时就会感到愤怒，而弱肉强食一直都是生活的本质，惟有强大才是解决这一切负面情绪的良药~</p><p>2020-7-18 15:36:53</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;通过 &lt;code&gt;gdb&lt;/code&gt; 启动程序，打好断点运行，开始调试输入 &lt;code&gt;list&lt;/code&gt; 命令，结果发现找不到源代码，是不是很糟心，让我们来看看怎么解决这种情况。&lt;/p&gt;
    
    </summary>
    
      <category term="linux" scheme="http://AlbertGithubHome.github.io/blog/categories/linux/"/>
    
    
      <category term="C/C++" scheme="http://AlbertGithubHome.github.io/blog/tags/C-C/"/>
    
      <category term="source" scheme="http://AlbertGithubHome.github.io/blog/tags/source/"/>
    
      <category term="linux" scheme="http://AlbertGithubHome.github.io/blog/tags/linux/"/>
    
      <category term="gdb" scheme="http://AlbertGithubHome.github.io/blog/tags/gdb/"/>
    
      <category term="dir" scheme="http://AlbertGithubHome.github.io/blog/tags/dir/"/>
    
      <category term="path" scheme="http://AlbertGithubHome.github.io/blog/tags/path/"/>
    
  </entry>
  
  <entry>
    <title>Shell脚本中获取命令运行结果、特殊变量使用、条件判断等常用操作</title>
    <link href="http://AlbertGithubHome.github.io/blog/2020/07/07/Shell%E8%84%9A%E6%9C%AC%E4%B8%AD%E8%8E%B7%E5%8F%96%E5%91%BD%E4%BB%A4%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C%E3%80%81%E6%9D%A1%E4%BB%B6%E5%88%A4%E6%96%AD%E7%AD%89%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/"/>
    <id>http://AlbertGithubHome.github.io/blog/2020/07/07/Shell脚本中获取命令运行结果、条件判断等常用操作/</id>
    <published>2020-07-07T15:27:09.000Z</published>
    <updated>2020-07-11T07:54:07.068Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近在处理一个 <code>Python</code> 局部变量的作用域问题时发现有些奇怪，想起了之前常写的 <code>Lua</code> 脚本，于是想写个函数测试一下，结果发现短短的十几行代码出现了多个错误，这可是我写了近三年的代码啊，才放下半年就记不清了，所以知识这个东西还是要不断“温故”，今天要总结的 <code>Shell</code> 脚本命令也是，基本属于一看就会，一写不对的状态，所以还是要把常用的操作总结到一起，方便查找和复习。</p><a id="more"></a><h1 id="获取命令执行结果"><a href="#获取命令执行结果" class="headerlink" title="获取命令执行结果"></a>获取命令执行结果</h1><p>脚本中常常要获取一些命令的执行结果，比如当前目录 <code>pwd</code>、当前时间 <code>date</code> 等等，如果在控制台时直接输入后回车就能看到结果，但是在 <code>Shell</code> 脚本中却不能这样做，常见的有以下两种方式。</p><h2 id="使用反引号-command-来执行命令"><a href="#使用反引号-command-来执行命令" class="headerlink" title="使用反引号 `command `来执行命令"></a>使用反引号 <code>`</code>command <code>`</code>来执行命令</h2><p>反引号就是键盘上 <code>Tab</code> 键上方的那个按键对应的符号，常写 Markdown 的小伙伴知道这个符号就是包裹代码块的那个符号，在 <code>Shell</code> 脚本中被用来执行命令得到结果，举个简单的例子</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">result=date</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$result</span></span><br><span class="line"></span><br><span class="line">result=`date`</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$result</span></span><br></pre></td></tr></table></figure><p>将上述命令保存到文件 <code>cmd.sh</code> 中运行 <code>./cmd.sh</code> 得到结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ./cmd.sh</span><br><span class="line">date</span><br><span class="line">Tue Jul 7 23:48:03 CST 2020</span><br></pre></td></tr></table></figure><p>从运行结果可以看出，如果不加反引号，我们常用的这些命令会被当成普通的字符串处理。</p><h2 id="使用括号组合-command-来执行命令"><a href="#使用括号组合-command-来执行命令" class="headerlink" title="使用括号组合 $(command) 来执行命令"></a>使用括号组合 $(command) 来执行命令</h2><p>除了上面的反引号，使用美元符和小括号组合也可以在 Shell 脚本中运行命令，使用同样的例子测试</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">result=`date`</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$result</span></span><br><span class="line"></span><br><span class="line">result=$(date)</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$result</span></span><br></pre></td></tr></table></figure><p>保存到文件 <code>cmd.sh</code> 中运行 <code>./cmd.sh</code> 得到结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ./cmd.sh</span><br><span class="line">Tue Jul 7 23:53:27 CST 2020</span><br><span class="line">Tue Jul 7 23:53:27 CST 2020</span><br></pre></td></tr></table></figure><p>对比可以看出两种方式在这个命令下运行结果是一样的。</p><h2 id="两种方式的区别"><a href="#两种方式的区别" class="headerlink" title="两种方式的区别"></a>两种方式的区别</h2><p>虽然上述两种方式都可以在 <code>Shell</code> 脚本中得到命令运行的结果，但是有一点是不一样的，那就是反引号执行命令不支持嵌套，不能实现反引号中再出现反引号，而 <code>$(command)</code>的方式是支持嵌套的，关于这一点可以看下面这个例子。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> $(ls $(<span class="built_in">pwd</span>))</span><br><span class="line">cmd.sh</span><br></pre></td></tr></table></figure><p>分析一下这个命令 <code>echo $(ls $(pwd))</code>，最里面的命令是 <code>$(pwd)</code>先执行得到当前目录，然后执行命令 <code>$(ls 当前目录)</code>得到目录下的文件，再通过 <code>echo</code> 命令把这个结果输出，就得到了 <code>cmd.sh</code> 这个文件名，因为我这个目录下只有这一个文件。</p><p>系统的命令使用反引号的方式改写就不生效了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> `ls `<span class="built_in">pwd</span>``</span><br><span class="line">cmd.shpwd</span><br></pre></td></tr></table></figure><p>我们还是仿照上面嵌套来写，但是 <code>echo</code> 后面的内容其实被分成了3部分，一个<code>ls</code>命令，一个<code>pwd</code>字符串、一个空命令，这样就能解释运行结果 <code>cmd.shpwd</code>了。</p><p>对照着结果我们就可以知道了， <code>$(command)</code>的方式更加强大，可以支持命令的嵌套，应用更广泛一点，而反引号的方式跟多出现在之前的脚本中。</p><h1 id="特殊变量使用"><a href="#特殊变量使用" class="headerlink" title="特殊变量使用"></a>特殊变量使用</h1><p>从学习语言的第一天起就记住了变量名中只能有数字、字母、下划线，并且数字不能打头（Shell中只能字母开头），但是在 <code>Shell</code> 脚本中有一些特殊的变量，包含各种奇奇怪怪的符号。</p><h2 id="0-1-2-…"><a href="#0-1-2-…" class="headerlink" title="$0 $1 $2 …"></a>$0 $1 $2 …</h2><p>这些是运行 <code>Shell</code> 脚本时传递给脚本的命令行参数。命令行参数用 $n 表示，$0表示当前脚本的文件名，$1 表示第一个参数，$2 表示第二个参数，依次类推，可以类比 Windows 下的 <code>%0</code>、<code>%1</code>、<code>%2</code>…</p><h2 id=""><a href="#" class="headerlink" title="$$"></a>$$</h2><p>当前 <code>Shell</code> 脚本的进程ID。如果在命令行执行得到的是当前 <code>bash</code> 的进程ID，如果放到脚本中，得到的是脚本的进程ID。</p><h2 id="-1"><a href="#-1" class="headerlink" title="$?"></a>$?</h2><p>可以获取上一个命令执行后的返回结果。</p><h2 id="-2"><a href="#-2" class="headerlink" title="$"></a>$</h2><p>传递给脚本的命令行参数的个数。</p><h2 id="-3"><a href="#-3" class="headerlink" title="$*"></a>$*</h2><p>传递给脚本的命令行参数的所有参数。</p><h2 id="-4"><a href="#-4" class="headerlink" title="$@"></a>$@</h2><p>传递给脚本的命令行参数的所有参数，与 <code>$*</code> 稍有不同。</p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>写个脚本测试一下，新建 <code>cmdargs.sh</code> 文件，编写下面代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> \<span class="variable">$0</span> is <span class="variable">$0</span></span><br><span class="line"><span class="built_in">echo</span> \<span class="variable">$1</span> is <span class="variable">$1</span></span><br><span class="line"><span class="built_in">echo</span> \<span class="variable">$2</span> is <span class="variable">$2</span></span><br><span class="line"><span class="built_in">echo</span> \$$ is $$</span><br><span class="line"><span class="built_in">echo</span> \<span class="variable">$#</span> is <span class="variable">$#</span></span><br><span class="line"><span class="built_in">echo</span> \$* is $*</span><br><span class="line"><span class="built_in">echo</span> \<span class="variable">$@</span> is <span class="variable">$@</span></span><br></pre></td></tr></table></figure><p>先执行 <code>./cmdargs.sh</code> 脚本， 然后输出 <code>$?</code> 脚本的退出状态，运行结果如下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ ./cmdargs.sh I love my daughter</span><br><span class="line"><span class="variable">$0</span> is ./cmdargs.sh</span><br><span class="line"><span class="variable">$1</span> is I</span><br><span class="line"><span class="variable">$2</span> is love</span><br><span class="line">$$ is 197</span><br><span class="line"><span class="variable">$#</span> is 4</span><br><span class="line">$* is I love my daughter</span><br><span class="line"><span class="variable">$@</span> is I love my daughter</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">echo</span> $?</span><br><span class="line">0</span><br></pre></td></tr></table></figure><h2 id="和-的区别"><a href="#和-的区别" class="headerlink" title="$* 和 $@ 的区别"></a><code>$*</code> 和 <code>$@</code> 的区别</h2><p>对照这个源码和输出结果，这些特殊变量应该可以分清楚了，其中 <code>$*</code> 和 <code>$@</code> 都是把所有内容都列出来了，但它俩还是有点区别的，当这两个变量都被双引号包裹时，通过 <code>for</code> 循环会得到不同结果，写个脚本 <code>cmdargs2.sh</code> 试一下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"test for \"\$*\""</span></span><br><span class="line"><span class="keyword">for</span> var <span class="keyword">in</span> <span class="string">"$*"</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"<span class="variable">$var</span>"</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"test for \"\$@\""</span></span><br><span class="line"><span class="keyword">for</span> var <span class="keyword">in</span> <span class="string">"<span class="variable">$@</span>"</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"<span class="variable">$var</span>"</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>运行结果如下, <code>&quot;$*&quot;</code>把所有的参数当成了一个整体，而 <code>&quot;$@&quot;</code> 把各个参数都拆分开了，可以通过循环依次打印出来。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ ./cmdargs2.sh I love my daughter</span><br><span class="line"><span class="built_in">test</span> <span class="keyword">for</span> <span class="string">"$*"</span></span><br><span class="line">I love my daughter</span><br><span class="line"><span class="built_in">test</span> <span class="keyword">for</span> <span class="string">"<span class="variable">$@</span>"</span></span><br><span class="line">I</span><br><span class="line">love</span><br><span class="line">my</span><br><span class="line">daughter</span><br></pre></td></tr></table></figure><h1 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h1><p>说起条件判断第一反应就是 <code>if</code> 了，在 <code>Shell</code> 脚本中也有 <code>if</code> 语句，同样是条件判断的中坚力量，先来看看 <code>if</code> 语句的写法：</p><h2 id="if-语句格式"><a href="#if-语句格式" class="headerlink" title="if 语句格式"></a><code>if</code> 语句格式</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ -d <span class="variable">$filename</span> ]; <span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"this is a directory."</span></span><br><span class="line"><span class="keyword">elif</span> [ -a <span class="variable">$filename</span> ]; <span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"the file is exist."</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"the file is not exist."</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p>直接提供一个最复杂的情况，如果不需要 <code>elif</code> 或者 <code>else</code> 分支，直接删掉就可以，但是 <code>if</code>、<code>then</code>、<code>fi</code> 这些都是必须的，并且中括号里面的表达式与中括号之间都要有空格，如果挨着写会报错的。</p><h2 id="中括号-的作用"><a href="#中括号-的作用" class="headerlink" title="中括号 [] 的作用"></a>中括号 <code>[]</code> 的作用</h2><p>一度认为 <code>if</code> 条件语句就是这样写，中括号 <code>[]</code> 应该是语法的一部分，但是查询后发现这居然是一个命令，和 <code>ls</code>，<code>pwd</code> 一样是一个可以执行命令，放在 <code>if</code> 条件判断时基本等同于 <code>test</code> 命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">which</span> [</span><br><span class="line">/usr/bin/[</span><br><span class="line">$ <span class="built_in">which</span> <span class="built_in">test</span></span><br><span class="line">/usr/bin/<span class="built_in">test</span></span><br></pre></td></tr></table></figure><p>看着这个查询结果感觉神奇吧，此外还有一个 <code>[[]]</code> 双中括号的操作，这个就不是命令了，而是 <code>Shell</code> 的一个关键字，比 <code>[]</code> 要强大的多。</p><h2 id="具体条件"><a href="#具体条件" class="headerlink" title="具体条件"></a>具体条件</h2><p><code>Shell</code> 脚本最常见的条件就是文件判断，数字判断和字符串判断了，接下来列举一下这些判断的常见写法。</p><h3 id="文件判断"><a href="#文件判断" class="headerlink" title="文件判断"></a>文件判断</h3><table><thead><tr><th style="text-align:center">命令</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">-a $filename</td><td style="text-align:center">文件存在时为真</td></tr><tr><td style="text-align:center">-d $filename</td><td style="text-align:center">文件名对应的是目录时为真</td></tr><tr><td style="text-align:center">-s $filename</td><td style="text-align:center">文件非空时为真</td></tr><tr><td style="text-align:center">-r $filename</td><td style="text-align:center">文件可读时为真</td></tr><tr><td style="text-align:center">-w $filename</td><td style="text-align:center">文件可写时为真</td></tr><tr><td style="text-align:center">-x $filename</td><td style="text-align:center">文件可执行时为真</td></tr></tbody></table><h3 id="数字判断"><a href="#数字判断" class="headerlink" title="数字判断"></a>数字判断</h3><table><thead><tr><th style="text-align:center">命令</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">n1 -eq n2</td><td style="text-align:center">n1等于n2时为真</td></tr><tr><td style="text-align:center">n1 -ne n2</td><td style="text-align:center">n1不等n2时为真</td></tr><tr><td style="text-align:center">n1 -gt n2</td><td style="text-align:center">n1大于n2时为真</td></tr><tr><td style="text-align:center">n1 -lt n2</td><td style="text-align:center">n1小于n2时为真</td></tr><tr><td style="text-align:center">n1 -ge n2</td><td style="text-align:center">n1大于等于n2时为真</td></tr><tr><td style="text-align:center">n1 -le n2</td><td style="text-align:center">n1小于等于n2时为真</td></tr></tbody></table><h3 id="字符串判断"><a href="#字符串判断" class="headerlink" title="字符串判断"></a>字符串判断</h3><table><thead><tr><th style="text-align:center">命令</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">-n str1</td><td style="text-align:center">str1字符串不为空串时值为真</td></tr><tr><td style="text-align:center">-z str1</td><td style="text-align:center">str1字符串为空串时值为真</td></tr><tr><td style="text-align:center">str1 == str2</td><td style="text-align:center">str1与str2相等时为真</td></tr><tr><td style="text-align:center">str1 != str2</td><td style="text-align:center">str1与str2不等时为真</td></tr><tr><td style="text-align:center">str1 &gt; str2</td><td style="text-align:center">按字典序str1排在str2后面时为真</td></tr><tr><td style="text-align:center">str1 &lt; str2</td><td style="text-align:center">按字典序str1排在str2前面时为真</td></tr></tbody></table><h3 id="数字判断特殊写法"><a href="#数字判断特殊写法" class="headerlink" title="数字判断特殊写法"></a>数字判断特殊写法</h3><table><thead><tr><th style="text-align:center">命令</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center"><code>((&quot;$n1&quot; == &quot;$n2&quot;))</code></td><td style="text-align:center">n1等于n2时为真</td></tr><tr><td style="text-align:center"><code>((&quot;$n1&quot; != &quot;$n2&quot;))</code></td><td style="text-align:center">n1不等n2时为真</td></tr><tr><td style="text-align:center"><code>((&quot;$n1&quot; &gt; &quot;$n2&quot;))</code></td><td style="text-align:center">n1大于n2时为真</td></tr><tr><td style="text-align:center"><code>((&quot;$n1&quot; &lt; &quot;$n2&quot;))</code></td><td style="text-align:center">n1小于n2时为真</td></tr><tr><td style="text-align:center"><code>((&quot;$n1&quot; &gt;= &quot;$n2&quot;))</code></td><td style="text-align:center">n1大于等于n2时为真</td></tr><tr><td style="text-align:center"><code>((&quot;$n1&quot; &lt;= &quot;$n2&quot;))</code></td><td style="text-align:center">n1小于等于n2时为真</td></tr></tbody></table><h3 id="逻辑关系运算符"><a href="#逻辑关系运算符" class="headerlink" title="逻辑关系运算符"></a>逻辑关系运算符</h3><table><thead><tr><th style="text-align:center">命令</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">-a</td><td style="text-align:center">与操作，用于<code>[]</code> 和 <code>test</code> 操作符</td></tr><tr><td style="text-align:center">-o</td><td style="text-align:center">或操作，用于<code>[]</code> 和 <code>test</code> 操作符</td></tr><tr><td style="text-align:center">！</td><td style="text-align:center">取反操作，用于<code>[]</code> 、 <code>test</code> 操作符 和 <code>[[]]</code> 关键字</td></tr><tr><td style="text-align:center">&amp;&amp;</td><td style="text-align:center">与操作，用于<code>[[]]</code> 关键字</td></tr><tr><td style="text-align:center">\</td><td style="text-align:center">\</td><td></td><td>或操作，用于<code>[[]]</code> 关键字</td></tr></tbody></table><p>这些逻辑写法千奇百怪的，写两个例子就慢慢就慢慢理解了，比如判断一个字符串不为空，并且这个字符串指定的目录还存在就可以写成</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ -n <span class="string">"<span class="variable">$1</span>"</span> -a -d <span class="string">"<span class="variable">$1</span>"</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$1</span> directory is exist</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p>使用双小括号来比较数值变量，写在双小括号中的变量前面可以不加 <code>$</code> 符号，还有诸多特权等着你去发现</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">num1=<span class="variable">$1</span></span><br><span class="line">num2=<span class="variable">$2</span></span><br><span class="line"><span class="keyword">if</span> (( num1 &gt; num2)); <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> num1 \&gt; num2</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p>总之在学习这些条件比较的时候踩了不少坑，有很多情况都没有注意到，不过慢慢也适应了这种语法，但还是免不了会出现一个小问题，这里提供一个 <code>Shell</code> 语法检查的在线网站 <a href="https://www.shellcheck.net/" target="_blank" rel="noopener">《shellcheck》</a>，将要检查的脚本放到页面上检测，会给出详细的错误信息，当然也有命令版本，可以自己到对应的 github 页面上下载哦~</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li><code>Shell</code> 脚本中获取命令的执行结果，可以通过反引号<code>`</code>command<code>`</code>，或者小括号 <code>$(command)</code> 的方式得到</li><li><code>Shell</code> 脚本中有一系列 <code>$</code> 开头的变量，用好他们是脚本和函数传递参数的关键</li><li><code>Shell</code> 脚本中的条件判断对于初学者来说很头大，有许多注意的点要记住，判断形式也多种多样</li><li>脚本中有单引号、双引号、反引号，简单来记就是单引号中原样输出，双引号中变量求值后输出，反引号中只能写需要执行的命令</li><li>脚本中还要中括号、双中括号、小括号、双小括号等，上面都提到过，可以自己练习下，具体的细节怕是要单独总结了，放到一起太多了</li><li>脚本的中的分号起到语句结束的作用，如果有换行就不需要分号了，比如 <code>if</code> 条件后面的 <code>then</code> 如果换行，那么 <code>then</code> 前面的分号可以省略</li><li>再记住一个坑，脚本赋值等号两端不能有空格，脚本判断等号两端必须有空格</li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/107147803" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>有些局，选择不入便立于不败之地，选择介入，即使曾身经百战，也恐难全身而退，更不要谈什么收益了~</p></blockquote><hr><blockquote><p>2020-7-11 00:30:00</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;最近在处理一个 &lt;code&gt;Python&lt;/code&gt; 局部变量的作用域问题时发现有些奇怪，想起了之前常写的 &lt;code&gt;Lua&lt;/code&gt; 脚本，于是想写个函数测试一下，结果发现短短的十几行代码出现了多个错误，这可是我写了近三年的代码啊，才放下半年就记不清了，所以知识这个东西还是要不断“温故”，今天要总结的 &lt;code&gt;Shell&lt;/code&gt; 脚本命令也是，基本属于一看就会，一写不对的状态，所以还是要把常用的操作总结到一起，方便查找和复习。&lt;/p&gt;
    
    </summary>
    
      <category term="shell" scheme="http://AlbertGithubHome.github.io/blog/categories/shell/"/>
    
    
      <category term="if" scheme="http://AlbertGithubHome.github.io/blog/tags/if/"/>
    
      <category term="Shell" scheme="http://AlbertGithubHome.github.io/blog/tags/Shell/"/>
    
      <category term="command" scheme="http://AlbertGithubHome.github.io/blog/tags/command/"/>
    
  </entry>
  
  <entry>
    <title>根证书的应用和信任基础</title>
    <link href="http://AlbertGithubHome.github.io/blog/2020/07/06/%E6%A0%B9%E8%AF%81%E4%B9%A6%E7%9A%84%E5%BA%94%E7%94%A8%E5%92%8C%E4%BF%A1%E4%BB%BB%E5%9F%BA%E7%A1%80/"/>
    <id>http://AlbertGithubHome.github.io/blog/2020/07/06/根证书的应用和信任基础/</id>
    <published>2020-07-06T14:54:28.000Z</published>
    <updated>2020-07-11T07:54:29.538Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>人生在世总要相信点什么，信亲人、信朋友、信你面前的陌生人，即便这些你都不信，也要信自己吧，假如连自己都不信了，那在地球上恐怕很难生存了。</p><a id="more"></a><p>我们把钱存入银行，因为我们相信当我们需要用钱时可以通过银行卡把钱取出来；我们拿着车票准时来到候车大厅，因为我们相信除非特殊情况，我们买的那趟车绝不会提前丢下我们而去；遇到纠纷我们会选择打官司，因为我们相信法官最后会给我们公正的判决结果。</p><p>生活中我们信任自己的经验，信任自己的亲人朋友，并依赖这些信任来做许多事情，这些信任是我们正常生活学习的前提，缺了这些我们将寸步难行。而在网络中我们同样需要信任，这些信任是筑造网络社会的基石。</p><p>有些信任是有条件的，比如银行贷款时不能通过空口白话就借来白花花的银子，而抵押物是贷款银行为了相信你附加的筹码；有些信任是无条件的，比如前面一篇总结 <a href="https://blog.csdn.net/albertsh/article/details/106754135" target="_blank" rel="noopener">《认证、HTTPS、证书的基本含义》</a>中提到的根证书，我们必须无条件信任，否则我们将置身于网络猜疑的海洋之中，无法正常利用网络带给我们的便利。</p><h1 id="信任链"><a href="#信任链" class="headerlink" title="信任链"></a>信任链</h1><p>我们常听说 <code>HTTPS</code> 更加安全，它是通过非对称加密技术，让我们可以在不确定的网络环境中可以确认对方的身份，安全传输密钥，但这一切都是有前提的，你得相信你的操作环境是安全的，你没有被人监控，你的电脑没有被人控制，你的数据没有被人篡改，抛开环境谈安全都是耍流氓~</p><p>好了，我们可以回顾一下，要想验证一个网站的身份，我们需要得到网站的公钥，如果可以解开网站拿私钥加密的消息，我们就证明了网站的身份，而网站的公钥不能由网站直接发给我们，需要找权威机构给它证明，相当于找了个担保人。</p><p>权威机构会用自己的私钥把网站的信息和公钥合在一起生成证书，当我们访问网站时首先得到这个证书，然后用权威机构的公钥来解开证书内容，得到网站的信息和网站的公钥，然后进行信息比对和公钥解密来认证身份，这时我们需要思考，权威机构的公钥从哪里来？</p><p>权威机构可以找更加权威的机构按照相同的方式给它做证书，这样一环一环的就走下去，形成了信任链，然后就无穷无尽了，一个权威机构给另一个权威机构证明，我可以玩到天荒地老，到底什么时候是个头啊，其实我们可以人为的确定一个，那就是根证书，他不需要找别的人给它证明，如果一个网站证书最终信任链顶端是有效的根证书，那么网站身份被确认。</p><h1 id="根证书"><a href="#根证书" class="headerlink" title="根证书"></a>根证书</h1><p>接下来看看根证书在哪呢？它内置在我们的浏览器（Firefox）和操作系统中，我们需要无条件的信任，从理论上讲没办法判断根证书的真假，它是自证清白的。这里需要注意，根证书不止有一个，它可以有很多个，“根”只是说明信任链到此为止，整条信任链上的节点都是“可信”的。所以说还是不要随意安装根证书，因为有了它就可以在你的电脑为所欲为。</p><p>说到这里有些人会想，根证书内置在操作系统和浏览器（Firefox）中，如果我下载一个被恶意修改的浏览器岂不是危险了，这种担心是有必要的，所以请尽量在正规网站下载，可是怎么证明哪些网站是正规网站呢？可以使用系统自带的根证书判断。</p><p>如果我的系统是盗版系统，根证书被人改过，那不是更危险了，事实确实如此，算了吧，还是暂时不相信网络了，我去买个系统光盘吧（不知道现在还有没有人用光盘装系统），可是卖你光盘的人能保证光盘的内容不被篡改吗？你说那不能，因为他是微软高级经理的小舅子，应该不能卖盗版碟吧。</p><p>即使光盘不是盗版的，但是制作光盘的内容有没有人动过手脚呢？这些我们还是无法确认，我们能做的只是尽可能的在正规渠道购买正版系统，这种情况遇到证书被篡改的情况很小，然后就无条件相信这个系统了，这就是我文章开头说的，我么总要信点什么，试想如果盖茨在 <code>Windows</code> 操作系统的证书中留有后门，你又能做些什么呢，所以还是不要纠结了，既然用就在正常使用的前提下信任它。</p><h1 id="应用及分析"><a href="#应用及分析" class="headerlink" title="应用及分析"></a>应用及分析</h1><p>说是应用，实际上我只是想吐槽而已，在吐槽之前我们应该了解，证书可以跟各大证书机构（也就是各种CA）来买，也可以自己生成，可能有人会想了，自己生成挺好啊，不用花钱谁还买啊？可是刚刚说过了，跟CA买的证书都是操作系统内置证书认证过的，自己生成的证书操作系统和浏览器可不认，那怎么办呢？</p><p>干脆自己安装个根证书，自己给自己认证得了，用户岂是你想让安装就安装的，别说，还真是这样，只要你说的情况很危急，必须安装，那么大多数的小白用户是会自动安装的，这时你想到了谁？</p><p>不知道大家想到了谁，反正我是想到了建行网银证书和令人“可歌可气”的12306，接下来简单扒一扒他们两个的故事…</p><h2 id="建行网银证书"><a href="#建行网银证书" class="headerlink" title="建行网银证书"></a>建行网银证书</h2><p>最先接触的证书就是建行网银证书，我的第一代网银盾用了将近10年，去年才刚刚升级成2代，可以说真的是太稳定了，不知道做网银的产品经理是谁，你简直就是程序员的福音，在2020年的今天打开建行的官网，首页倒是好看了许多，但是有些内容，比如证书安装、U盾介绍的页面还是原来丑丑的样子。</p><p><img src="https://cdn.jsdelivr.net/gh/albertgithubhome/cdn/img/auth03/ccb2.png" alt="ccb2"></p><p>之前办理U盾时还花钱，根本都不懂啊，使用U盾必须装证书啊，不装就不安全啊，现在回想起来，和我说这话的人可能根本就不懂什么是安全，什么是不安全，反正装就是了，每次付款都要启动建行验证程序，这也是我手动安装过的次数最多的证书，是它开启了我网上购物的里程。</p><p>已经2020年了，打开建行的官网依旧提示我正在使用不安全的连接，使用网银依旧让我自己安装证书，可能作为一个大银行，官方网站迟迟不启用 <code>HTTPS</code>，使用网银盾坚持要用户自己安装证书，应该不仅仅是证书价格的问题，可能还有什么其他的原因。</p><p><img src="https://cdn.jsdelivr.net/gh/albertgithubhome/cdn/img/auth03/ccb3.png" alt="ccb3"></p><h2 id="神奇的12306"><a href="#神奇的12306" class="headerlink" title="神奇的12306"></a>神奇的12306</h2><p>毕业后直接在12306买票的次数就少了，现在一般使用 APP 来解决，前一阵发现12306居然不要求自己安装证书了，仔细一查原来从2017年开始，12306官网就购买了 <code>DigiCert Inc</code> 认证的证书，确实是一个进步的boy，终于舍得花点钱买证书了，作为一个巨大型的网站，它方便了人们购票的方式，是值得歌颂和称赞的，但是每次购票前还要安装烦人的证书，确实挺令人生气的。</p><p><img src="https://cdn.jsdelivr.net/gh/albertgithubhome/cdn/img/auth03/12306_0.png" alt="12306_0"></p><p>原来“根证书”3个红字显示在页面正中间，确实起到了提醒的作用，挺扎眼的，不过那已经一去不复返了，我再放个图，大家一起回顾一下。</p><p><img src="https://cdn.jsdelivr.net/gh/albertgithubhome/cdn/img/auth03/12306.png" alt="12306"></p><h2 id="ESET-SSL-Filter-CA"><a href="#ESET-SSL-Filter-CA" class="headerlink" title="ESET SSL Filter CA"></a>ESET SSL Filter CA</h2><p>最后放一个例子，让你感受下根证书的威力，ESET是总部位于斯洛伐克布拉迪斯拉发的一家世界知名的电脑安全软件公司，主要做杀毒软件，前不久复习 <code>HTTPS</code> 知识的时候发现，我访问各大网站的证书全都变成了 <code>ESET SSL Filter CA</code>，这是什么鬼，难道 <code>ESET SSL Filter CA</code> 是个特别大的证书机构？</p><p>当时还没有意识到是杀毒软件的证书，以为大家都是买的这家证书，后来发现不太对，百度、谷歌、GitHub、Stack Overflow，怎么都是一样的证书，继续深究才发现被“窃听”了。</p><p>我们知道使用 <code>HTTPS</code> 通信因为使用了非对称加密，没有私钥是无法窃听加密内容的，但是这款杀毒软件做到了，它有一个HTTPS 内容过滤的功能，做了我的电脑和各大网站的中间人，按理说 <code>HTTPS</code> 是可以检测出中间人的，但是这款软件在电脑中安装了根证书，所有浏览器认为它是合法的，理论上可以窃听你所有内容，甚至为所欲为。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>信任不仅是人类社会的基石，在网络世界同样重要</li><li>证书之间的层层信任构成了信任链，而根证书是不需要被其他人证明的</li><li>不要随意安装来历不明的根证书，那样可能会使的电脑更容易遭受到攻击</li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/106976688" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>若衣食无忧，谁甘愿拼搏！努力鞭策自己无非是为了挣得可以选择生活的权利~</p></blockquote><hr><blockquote><p>2020-7-5 23:44:41</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;人生在世总要相信点什么，信亲人、信朋友、信你面前的陌生人，即便这些你都不信，也要信自己吧，假如连自己都不信了，那在地球上恐怕很难生存了。&lt;/p&gt;
    
    </summary>
    
      <category term="加密与认证" scheme="http://AlbertGithubHome.github.io/blog/categories/%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%AE%A4%E8%AF%81/"/>
    
    
      <category term="认证" scheme="http://AlbertGithubHome.github.io/blog/tags/%E8%AE%A4%E8%AF%81/"/>
    
      <category term="非对称加密" scheme="http://AlbertGithubHome.github.io/blog/tags/%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/"/>
    
      <category term="HTTPS" scheme="http://AlbertGithubHome.github.io/blog/tags/HTTPS/"/>
    
      <category term="根证书" scheme="http://AlbertGithubHome.github.io/blog/tags/%E6%A0%B9%E8%AF%81%E4%B9%A6/"/>
    
      <category term="中间人" scheme="http://AlbertGithubHome.github.io/blog/tags/%E4%B8%AD%E9%97%B4%E4%BA%BA/"/>
    
  </entry>
  
  <entry>
    <title>码龄10年工作6年的搬砖小哥，最常访问的学习网站都在这里了</title>
    <link href="http://AlbertGithubHome.github.io/blog/2020/06/18/%E7%A0%81%E9%BE%8410%E5%B9%B4%E5%B7%A5%E4%BD%9C6%E5%B9%B4%E7%9A%84%E6%90%AC%E7%A0%96%E5%B0%8F%E5%93%A5%EF%BC%8C%E6%9C%80%E5%B8%B8%E8%AE%BF%E9%97%AE%E7%9A%84%E5%AD%A6%E4%B9%A0%E7%BD%91%E7%AB%99%E9%83%BD%E5%9C%A8%E8%BF%99%E9%87%8C%E4%BA%86/"/>
    <id>http://AlbertGithubHome.github.io/blog/2020/06/18/码龄10年工作6年的搬砖小哥，最常访问的学习网站都在这里了/</id>
    <published>2020-06-18T14:31:18.000Z</published>
    <updated>2020-06-20T04:09:35.073Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这完全是一篇水文，主要看别人分享的文章很有收藏价值，所以也想试着总结一下这种类型的文章，不过之前确实用过一些比较好的网站，有些网站是查找问题时找到的，但是解决完问题就找不到了很可惜，所以我养成了收藏网址的习惯，感觉有用就会分门别类的添加到书签中，再次遇到之前解决过的问题就先在书签里搜一下，有时候会加快解决问题的进度，下面这幅图是我浏览器书签中的一部分。</p><a id="more"></a><p><img src="https://img-blog.csdnimg.cn/20200618224021946.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9hbGJlcnRnaXRodWJob21lLmdpdGh1Yi5pby9ibG9nL2Fib3V0,size_10,color_FFFFFF,t_70#pic_center" alt="bookmark"><br>网络技术飞速发展到今天，越来越多的功能被搬到了“云”上，导致原来需要在本地安装的多种开发环境完全不需要搭建了，如果是临时使用完全可以在浏览器中实现，比如对于程序猿来说不可或缺的编程开发环境，已经出现很多在线编译和运行的网站，再比如原来被称作 <code>PS大神</code> 的设计者们必须要在电脑上安装 <code>Photoshop</code> 这个庞然大物，可是现在你可以发现很多在线 <code>PS</code> 的软件，处理简单功能分分钟搞定，这是我截取的网页上 <code>在线PS软件</code> 的一部分，足以以假乱真。</p><p><img src="https://img-blog.csdnimg.cn/2020061822583286.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9hbGJlcnRnaXRodWJob21lLmdpdGh1Yi5pby9ibG9nL2Fib3V0,size_10,color_FFFFFF,t_70#pic_center" alt="onlinePS"><br>好了，开始进入正题了，作为一个天天写代码的搬砖小伙，每天都在敲敲敲，不是在敲代码就是在敲代码的路上，还有一种可能就是在学习如何敲代码，那么这样的榆木脑袋每天都会访问哪些学习网站呢？接下来我把最常访问的一些网站列举一下，有可能后续会更新，但我要是犯懒就算了。</p><h1 id="网站列表"><a href="#网站列表" class="headerlink" title="网站列表"></a>网站列表</h1><p>接下来会分成几个大类来列举一个我最常用的一些网站，每个人的喜好不同，但是仔细看看，或许有些你会感兴趣哦！</p><h2 id="一、文档项目"><a href="#一、文档项目" class="headerlink" title="一、文档项目"></a>一、文档项目</h2><p>如果写一个功能有现成的轮子给我用就好了，其实网络上有很多现成的轮子，我们要善于利用别人的成果转换为自己进步的阶梯。</p><p>1、<strong>cppreference</strong> &gt;&gt; <a href="https://en.cppreference.com/w/" target="_blank" rel="noopener">https://en.cppreference.com/w/</a></p><p>首推这个网站其实是有点偏心的，因为每天都在写C++，所以还是首先就想到了这个网站，这个网站中可以查到已经发布的各个C++标准的库函数，特性、头文件等等，对于不确定的函数返回值、新标准的特性、函数的常见用法都可以在这个网站找到，这个网站还有中文版的，学习C++的小伙伴可以常来逛逛。</p><p><img src="https://img-blog.csdnimg.cn/20200618233424911.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9hbGJlcnRnaXRodWJob21lLmdpdGh1Yi5pby9ibG9nL2Fib3V0,size_10,color_FFFFFF,t_70#pic_center" alt="cppreference"></p><p>2、 <strong>GitHub</strong> &gt;&gt; <a href="https://github.com/" target="_blank" rel="noopener">https://github.com/</a></p><p>被广大程序员调侃成“全球最大的同性交友网站”怎么能不上榜，<code>GitHub</code> 这个网站就算你不常用但也会常听到吧，上面充满了全世界精英团队编写的轮子，有趣的是这样一个最支持开源的网站居然被微软的这个最大的闭源厂商受够了，不过现在还是发展的越来越好了。你可以在上面阅读一些开源代码，看看那些明星产品究竟是怎样实现的，真正为我所用。</p><p><img src="https://img-blog.csdnimg.cn/20200618233959952.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9hbGJlcnRnaXRodWJob21lLmdpdGh1Yi5pby9ibG9nL2Fib3V0,size_10,color_FFFFFF,t_70#pic_center" alt="github"></p><h2 id="二、数据仓库"><a href="#二、数据仓库" class="headerlink" title="二、数据仓库"></a>二、数据仓库</h2><p>程序发展离不开数据存储，数据是支撑程序发展的基石，现在的数据库已经不是当初的关系数据满天下了，各种各样的数据库类型被发明了出来，列数据库、文档数据库、键值数据库等等，真的是太多了。</p><p>1、 <strong>Redis</strong> &gt;&gt; <a href="https://redis.io/commands" target="_blank" rel="noopener">https://redis.io/commands</a></p><p>非关系型数据库中最火的一个了吧，在认真学习之前一度认为它是一个新产品，后来才知道 <code>Redis</code> 其实在 2009 年就已经诞生了，作为一款键值型的内存数据库，现在被广泛引用于各个领域，而 <code>Redis</code> 的官方文档是需要不断去翻阅的，最近发布了 <code>Redis 6.0</code>，引入了网络多线程，以后的面试题可能要留神了。</p><p><img src="https://img-blog.csdnimg.cn/20200618235824411.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9hbGJlcnRnaXRodWJob21lLmdpdGh1Yi5pby9ibG9nL2Fib3V0,size_10,color_FFFFFF,t_70#pic_center" alt="redis"></p><p>2、 <strong>MySQL</strong>  &gt;&gt; <a href="https://dev.mysql.com/doc/refman/8.0/en/" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/8.0/en/</a></p><p>虽然 <code>NoSQL</code> 数据库在各个领域兴起，但是现在还是关系数据库占据着主导地位，<code>MySQL</code> 就是关系数据库中的明星产品了，自从被 <code>ORACLE</code> 收购以后也在不断发展，最近版本从5.7一跃直接到8.0，据说<code>MySQL 8</code> 要比 <code>MySQL 5.7</code> 快 2 倍，还带来了大量的改进和更快的性能！感兴趣的可以查阅一下 <code>MySQL</code> 的文档，它的文档格式特别棒，看着就让人赏心悦目。</p><p><img src="https://img-blog.csdnimg.cn/20200619000455910.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9hbGJlcnRnaXRodWJob21lLmdpdGh1Yi5pby9ibG9nL2Fib3V0,size_10,color_FFFFFF,t_70#pic_center" alt="MySQL"><br>3、 <strong>墨天轮</strong> &gt;&gt; <a href="https://www.modb.pro/dbRank" target="_blank" rel="noopener">https://www.modb.pro/dbRank</a></p><p>墨天轮上聚集了很多数据库爱好者，是一个新兴的数据库技术交流平台，一直渴望成为一个专业的技术社区，高效便捷、开放互助、乐于分享，能够承载我们数据人的学习和成长，促进整个行业的发展和创新，在这个网站上我们可以看到各大数据库排行，了解数据库相关的最新发展和方向。</p><p><img src="https://img-blog.csdnimg.cn/20200619002322531.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9hbGJlcnRnaXRodWJob21lLmdpdGh1Yi5pby9ibG9nL2Fib3V0,size_10,color_FFFFFF,t_70#pic_center" alt="modb"></p><h2 id="三、工具集合"><a href="#三、工具集合" class="headerlink" title="三、工具集合"></a>三、工具集合</h2><p>文章开头也提到了，如今很多工具都搬到了线上，这样既节省了电脑空间，也免去了安装和配置工具的麻烦，只要不是IDE的重度依赖者，使用在线工具还是很方便的。</p><p>1、 <strong>在线工具</strong> &gt;&gt; <a href="https://tool.lu/" target="_blank" rel="noopener">https://tool.lu/</a></p><p>这个网站提供了众多的在线工具，每次一用到时间戳转换或者URL编码等操作，我肯定会第一时间打开这个页面，因为本地调 <code>API</code> 太麻烦了，有时还需要搭建环境，在网站上找到对应的工具直接操作就可以了，还带有实时刷新的功能，完全没必要自己在本地写代码。</p><p><img src="https://img-blog.csdnimg.cn/2020061922082255.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9hbGJlcnRnaXRodWJob21lLmdpdGh1Yi5pby9ibG9nL2Fib3V0,size_10,color_FFFFFF,t_70#pic_center" alt="tool"></p><p>2、<strong>AlbertWorld</strong> &gt;&gt; <a href="http://www.008ct.top/blog/tools/" target="_blank" rel="noopener">http://www.008ct.top</a></p><p>这个网站收录了很多有用的网址，不仅仅是工具，文档、教程、数据、资源包括方方面面，其中包括很多讲解原理的知识和有用的素材，很像一个小小的杂货铺，偶尔上新哦！</p><p><img src="https://img-blog.csdnimg.cn/20200619220657719.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9hbGJlcnRnaXRodWJob21lLmdpdGh1Yi5pby9ibG9nL2Fib3V0,size_10,color_FFFFFF,t_70#pic_center" alt="008ct"></p><h2 id="四、疑难解答"><a href="#四、疑难解答" class="headerlink" title="四、疑难解答"></a>四、疑难解答</h2><p>解决问题是程序员每天都要面临的功课，而程序员要解决的问题往往是没见过的，如果一个程序猿天天值只处理那么几个相同的问题，那么他已经走上了被淘汰的道路，查找问题原因，给出解决方案，祝贺你，你今天又进步了。</p><p>1、 <strong>CSDN</strong> &gt;&gt; <a href="https://www.csdn.net/" target="_blank" rel="noopener">https://www.csdn.net/</a></p><p>用了这么久的 <code>CSDN</code> 一直不知道全称是什么？前几天才查了一下全称是 <code>Chinese Software Developer Network</code>，立意很深远的样子，不过确实是一个不错的网站，从去年开始大面积调整，原来的广告真是惨不忍睹，改版后现在好多了，工作中很多解决方案都出自这个网站，之前在论坛里没少逛，解答问题的同时，自己的知识也得到了巩固。</p><p><img src="https://img-blog.csdnimg.cn/20200619220017417.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9hbGJlcnRnaXRodWJob21lLmdpdGh1Yi5pby9ibG9nL2Fib3V0,size_10,color_FFFFFF,t_70#pic_center" alt="csdn"></p><p>2、 <strong>StackOverflow</strong> &gt;&gt; <a href="https://stackoverflow.com/" target="_blank" rel="noopener">https://stackoverflow.com/</a></p><p>一个和 <code>GitHub</code> 比肩的网站，一个专门解决程序猿问题的网站，你要坚信，作为一个普通的程序搬砖工，你遇到的问题别人也遇到过，所以遇到问题来这个网站查一查，有时问题瞬间就被解决了，特别是一些专业的工具仅仅报了一个错误代码，通过搜索引擎很难定位具体问题，但是在这个网站上的前辈已经为你趟好路了。</p><p><img src="https://img-blog.csdnimg.cn/20200619002926880.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9hbGJlcnRnaXRodWJob21lLmdpdGh1Yi5pby9ibG9nL2Fib3V0,size_10,color_FFFFFF,t_70#pic_center" alt="stackoverflow"></p><h2 id="五、进阶刷题"><a href="#五、进阶刷题" class="headerlink" title="五、进阶刷题"></a>五、进阶刷题</h2><p>程序猿就是一个活到老学到老的职业（如果35岁被淘汰就不用学了），必须时刻保证自己的学习状态，更新自己的知识储备，刷题成为了一项锻炼脑力的活动，因为很多公司特别是大公司都会要求算法达到一定的水平，所以没事多刷刷题，不要让自己的大脑锈住了。</p><p>1、<strong>力扣</strong> &gt;&gt; <a href="https://leetcode-cn.com/problemset/all/" target="_blank" rel="noopener">https://leetcode-cn.com/problemset/all/</a></p><p>这个网站貌似有很多名字，现在显示的是力扣，之前是在全球服注册的，后来莫名其妙的有注册了一次，变成了家门口的版本，这上面有很多算法题，一段时间没看居然还加上了面试题，不过它搞的那个竞赛挺有意思的，作为长期的两题选手，看着高手们10分钟做完4题，犹如神仙打架一般。</p><p><img src="https://img-blog.csdnimg.cn/20200619220440231.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9hbGJlcnRnaXRodWJob21lLmdpdGh1Yi5pby9ibG9nL2Fib3V0,size_10,color_FFFFFF,t_70#pic_center" alt="leetcode"></p><p>2、 <strong>POJ</strong> &gt;&gt; <a href="http://poj.org/" target="_blank" rel="noopener">http://poj.org/</a></p><p>这个 <code>Online Judge</code> 有些历史了，不过一直保持着更新，<code>ACM</code> 竞赛时也尝试在这里刷过题，和 <code>LeetCode</code> 比起来这里的题似乎更难一些，如果想挑战更高难度，不妨来这里试一下。</p><p><img src="https://img-blog.csdnimg.cn/20200619221129502.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9hbGJlcnRnaXRodWJob21lLmdpdGh1Yi5pby9ibG9nL2Fib3V0,size_10,color_FFFFFF,t_70#pic_center" alt="poj"></p><h2 id="六、教程案例"><a href="#六、教程案例" class="headerlink" title="六、教程案例"></a>六、教程案例</h2><p>当我们想学习一门新技术的时候，很渴望得到一份简单明了的教程，实际上很多技术的官方网站文档都非常完整，但是对于初学者来说理解起来会有些难度，这时候可以看一些边学边做的教程，在不断尝试中学习知识。</p><p>1、<strong>廖雪峰官网</strong> &gt;&gt; <a href="https://www.liaoxuefeng.com/wiki/1016959663602400" target="_blank" rel="noopener">https://www.liaoxuefeng.com/wiki/1016959663602400</a></p><p>廖雪峰此乃神人也，看看我截取的这篇教程的访问量你就清楚了，前两年我看到这篇文章的时候访问量才几亿，跟着教程完整的学了一遍，现在访问量已经400多亿了，受欢迎程序难以想象，廖大神写得教程浅显易懂，非常适合初学者，从头来一步步的就学会了，想当初我跟着他学爬虫把他的文章都爬了，哈哈~<br><img src="https://img-blog.csdnimg.cn/20200619221531788.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9hbGJlcnRnaXRodWJob21lLmdpdGh1Yi5pby9ibG9nL2Fib3V0,size_10,color_FFFFFF,t_70#pic_center" alt="liaoxuefeng"><br>2、 <strong>菜鸟教程</strong> &gt;&gt; <a href="https://www.runoob.com/" target="_blank" rel="noopener">https://www.runoob.com/</a></p><p>同样是一个接地气的教程网站，谁刚开始学的时候不是一只菜鸟呢，这个网站教程很多，只要你想学总能找到你喜欢的那款，并且在讲解时会有例子和函数参数说明，非常适合初学者。<br><img src="https://img-blog.csdnimg.cn/20200619221355785.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9hbGJlcnRnaXRodWJob21lLmdpdGh1Yi5pby9ibG9nL2Fib3V0,size_10,color_FFFFFF,t_70#pic_center" alt="runoob"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>总有小伙伴调侃说：收藏从未停止，学习从未开始，其实收藏是一个好苗头，只有想学才有可能去学</li><li>如果仔细看了这些网站，你会发现有些网站的设计让人真的很舒服，临时补充一个 <code>https://git-scm.com/</code></li><li>真正应了那句话，比你优秀的人比你还努力，你的产品都那么强了，网站居然还那么好看，还让不让人活了~</li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/106754135" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>我们没有生活在和平的年代，只是生活在了和平的国度，想开点，珍惜眼前的一切，灾难都会过去，我们还有一双手去争夺属于自己的未来。</p><p>2020-6-20 00:16:49</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;这完全是一篇水文，主要看别人分享的文章很有收藏价值，所以也想试着总结一下这种类型的文章，不过之前确实用过一些比较好的网站，有些网站是查找问题时找到的，但是解决完问题就找不到了很可惜，所以我养成了收藏网址的习惯，感觉有用就会分门别类的添加到书签中，再次遇到之前解决过的问题就先在书签里搜一下，有时候会加快解决问题的进度，下面这幅图是我浏览器书签中的一部分。&lt;/p&gt;
    
    </summary>
    
      <category term="Thinking" scheme="http://AlbertGithubHome.github.io/blog/categories/Thinking/"/>
    
    
      <category term="收集" scheme="http://AlbertGithubHome.github.io/blog/tags/%E6%94%B6%E9%9B%86/"/>
    
      <category term="网站" scheme="http://AlbertGithubHome.github.io/blog/tags/%E7%BD%91%E7%AB%99/"/>
    
      <category term="working" scheme="http://AlbertGithubHome.github.io/blog/tags/working/"/>
    
  </entry>
  
</feed>
