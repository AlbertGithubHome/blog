<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Albert World</title>
  <icon>https://www.gravatar.com/avatar/8ccc6291d5bfd34e7aaf601c4ebec7e1</icon>
  
  <link href="/blog/atom.xml" rel="self"/>
  
  <link href="http://AlbertGithubHome.github.io/blog/"/>
  <updated>2023-06-18T07:29:48.091Z</updated>
  <id>http://AlbertGithubHome.github.io/blog/</id>
  
  <author>
    <name>Albert Shi</name>
    <email>347070901@qq.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>初识Telegraf、InfluxDB和Grafana铁三角形成的监控可视化解决方案</title>
    <link href="http://AlbertGithubHome.github.io/blog/2023/06/17/%E5%88%9D%E8%AF%86Telegraf%E3%80%81InfluxDB%E5%92%8CGrafana%E9%93%81%E4%B8%89%E8%A7%92%E5%BD%A2%E6%88%90%E7%9A%84%E7%9B%91%E6%8E%A7%E5%8F%AF%E8%A7%86%E5%8C%96%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <id>http://AlbertGithubHome.github.io/blog/2023/06/17/初识Telegraf、InfluxDB和Grafana铁三角形成的监控可视化解决方案/</id>
    <published>2023-06-17T11:39:56.000Z</published>
    <updated>2023-06-18T07:29:48.091Z</updated>
    
    <content type="html"><![CDATA[<p>@[toc]</p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>数据监控目前用于各行各业，服务器开发也不例外，进程什么时候被杀死了？内存占用已经达到98%了怎么早点没发现，网络带宽已经占满了怪不得玩家反馈说登录不上去了，这些都是服务器开发人员常常听到的“抱怨”，他们都涉及到服务器资源的使用情况，如果有一种方便的途径可以高效的监控各个服务器的情况就好了，单靠人去各个服务器查看是不现实的，今天就来简单介绍一种我刚刚学到的方案。</p><a id="more"></a><h1 id="原始的监控靠人盯"><a href="#原始的监控靠人盯" class="headerlink" title="原始的监控靠人盯"></a>原始的监控靠人盯</h1><p>如果服务器只有一台或者很少，可以每隔一段时间去服务器上看看，<code>top</code> 看一下整体运行情况，<code>free</code> 查一下内存详情，<code>df</code> 看一下硬盘还够不够，<code>iftop</code> 看一下网络带宽情况，不要觉得不可能，有次测试我真的就是开了好几个远程窗口来盯着各个指标，不过人的精力有限，这样做毕竟不是长久之计。</p><h1 id="进化的监控靠批处理脚本"><a href="#进化的监控靠批处理脚本" class="headerlink" title="进化的监控靠批处理脚本"></a>进化的监控靠批处理脚本</h1><p>随着服务器的增多，靠人盯的方式的已经达不到要求了，看看上面的这些命令都是已知的，并且只需要定期得到这些值就可以了，完全可以使用脚本定期执行来做呀，把上面提到的命令封装成脚本然后定期执行得到结果列表，然后发送到指定的地址，我们就可以只分析这些结果，没必要登录到各个服务器上去查询了。</p><h1 id="高端的监控靠完整的可视化解决方案"><a href="#高端的监控靠完整的可视化解决方案" class="headerlink" title="高端的监控靠完整的可视化解决方案"></a>高端的监控靠完整的可视化解决方案</h1><p>懒惰是科学发展的推动力，使用脚本收集数据就不用登录服务器去实时查询了，那能不能帮我自动分析结果，或者在异常时直接给出提醒，因为我连分析的操作都不想做，肯定有人这样想当然也有人这样做了，并且形成了成熟的解决方案，我们只需要简单搭建和配置就可以早点下班了，半夜收到服务器报警电话时起来解决就可以了。</p><h1 id="Telegraf、InfluxDB和Grafana铁三角"><a href="#Telegraf、InfluxDB和Grafana铁三角" class="headerlink" title="Telegraf、InfluxDB和Grafana铁三角"></a>Telegraf、InfluxDB和Grafana铁三角</h1><p>Telegraf是一个用于收集、处理和发送指标数据的代理，它可以与各种数据源和监控系统集成，定期收集数据并将其发送到目标位置。</p><p>InfluxDB是一个开源的时间序列数据库，用于存储和查询大量时间序列数据。它被广泛用于存储来自Telegraf等数据收集器的指标数据。</p><p>Grafana用于创建交互式仪表板，从各种数据源中提取数据，并将数据以图表、图形和表格等形式展示出来。</p><p>通过将Telegraf用作数据收集代理，将数据发送到InfluxDB中存储，然后使用Grafana从InfluxDB中提取数据进行可视化，这个铁三角组合提供了一个强大的监控和数据可视化解决方案。</p><h2 id="Telegraf"><a href="#Telegraf" class="headerlink" title="Telegraf"></a>Telegraf</h2><p>Telegraf是一个开源的代理程序，用于收集、处理和发送指标数据。它设计用于高效地收集各种类型的数据，并将其发送到不同的目标位置，如时序数据库、消息队列等，具有以下是关键特点和功能：</p><ul><li><p>插件架构：Telegraf采用模块化的插件架构，具有丰富的输入和输出插件。它支持多种输入插件，如系统性能指标、日志文件、数据库查询、API调用等，以便从不同的数据源中收集数据。同样，Telegraf还支持多种输出插件，如InfluxDB、Elasticsearch、Kafka等，用于将收集到的数据发送到不同的目标位置。</p></li><li><p>多平台支持：Telegraf可在多个操作系统上运行，包括Linux、Windows和macOS，以适应不同的部署环境和需求。</p></li><li><p>轻量级和高性能：Telegraf被设计为轻量级和高性能的代理程序，可以在资源受限的环境中高效运行。它使用Golang编写，具有低的内存和CPU占用，并能够处理高并发的数据收集和处理任务。</p></li><li><p>数据转换和处理：Telegraf提供了灵活的数据转换和处理功能，可以对收集到的数据进行过滤、转换、聚合等操作。它支持各种数据处理任务，如标签添加、数据格式转换、聚合计算等，以便对数据进行预处理和清洗，使其适应目标存储或分析平台的要求。</p></li><li><p>插件生态系统：Telegraf拥有一个活跃的插件生态系统，用户可以根据自己的需求选择和配置适当的插件。社区提供了大量的插件，覆盖了各种数据源和目标位置，使得Telegraf具备广泛的适用性和灵活性。</p></li></ul><h2 id="InfluxDB"><a href="#InfluxDB" class="headerlink" title="InfluxDB"></a>InfluxDB</h2><p>InfluxDB是一个开源的高性能时序数据库，专门用于存储和处理时间序列数据。它被设计为能够高效地处理大规模的时间相关数据，并提供快速的数据插入、查询和聚合能力，具有关键特点和功能：</p><ul><li><p>时序数据存储：InfluxDB专注于存储和管理时间序列数据，如传感器数据、监控指标、日志事件等。它使用特定的数据结构和索引机制，以优化对时间序列数据的写入和查询操作。</p></li><li><p>高性能和可扩展性：InfluxDB被设计为具有高吞吐量和低延迟的数据库系统。它采用了一系列的优化策略，包括压缩算法、分片存储、数据分区等，以实现高效的数据处理和查询性能。此外，InfluxDB还支持水平扩展，可以通过添加更多节点来提高性能和容量。</p></li><li><p>查询语言：InfluxDB提供了InfluxQL和Flux两种查询语言。InfluxQL是类似于SQL的查询语言，专门用于时间序列数据的查询和聚合操作。Flux是一种功能更强大和灵活的查询语言，它支持更复杂的数据处理和转换操作，并具有扩展性更好的能力。</p></li><li><p>数据保留策略：InfluxDB允许定义数据保留策略，以指定数据在数据库中的保存期限和存储策略。这样可以根据数据的时效性需求和存储资源限制来管理数据的保留和清理。</p></li><li><p>数据一致性和持久性：InfluxDB采用了写时复制（Write Ahead Log）的机制，确保数据的一致性和持久性。它使用持久化引擎来保证数据在故障情况下的可靠性，同时提供数据备份和恢复的功能。</p></li><li><p>整合生态系统：InfluxDB具有丰富的整合生态系统，可以与各种数据源和工具集成。它支持与Telegraf等数据收集代理的无缝集成，以及与Grafana等数据可视化工具的联合使用，提供完整的监控和数据处理解决方案。</p></li></ul><h2 id="Grafana"><a href="#Grafana" class="headerlink" title="Grafana"></a>Grafana</h2><p>Grafana是一个开源的数据可视化和监控平台，用于创建、展示和分析实时指标和数据的交互式仪表板。它提供了丰富的可视化选项和灵活的配置，使用户能够轻松地创建各种类型的仪表板，并实时监控和分析数据，具有以下关键特点和功能：</p><ul><li><p>数据源支持：Grafana支持广泛的数据源，包括各种数据库（如MySQL、PostgreSQL、InfluxDB）、时序数据库（如Prometheus、Graphite）、日志文件、API等。它提供了内置的数据源插件和API接口，以便与不同的数据源进行集成和数据获取。</p></li><li><p>丰富的可视化选项：Grafana提供多种可视化选项，如折线图、柱状图、仪表盘、热力图等，可以根据数据的特点选择适合的图表类型。它还支持动态图表、图表注释、数据标记等功能，以增强数据的可视化效果和交互性。</p></li><li><p>交互式仪表板：Grafana的仪表板具有交互式的功能，用户可以自由地缩放、选择时间范围、过滤数据等。它还支持实时数据更新和自动刷新，以确保仪表板上的数据保持最新。</p></li><li><p>告警和通知：Grafana提供了强大的告警功能，用户可以根据自定义的条件设置告警规则，并通过电子邮件、Slack等渠道接收告警通知。这样可以及时发现数据异常或重要指标的变化。</p></li><li><p>用户管理和权限控制：Grafana支持多用户和团队管理，可以设置不同的用户角色和权限，以控制对仪表板和数据的访问和操作。它还提供了LDAP、OAuth等身份验证和单点登录功能，与企业的用户管理系统集成更加便捷。</p></li><li><p>社区支持和插件生态系统：Grafana拥有庞大的开源社区支持和活跃的插件生态系统。用户可以从社区中获取各种主题、模板和插件，以扩展和定制Grafana的功能和外观。</p></li></ul><h1 id="Grafana仪表板展示"><a href="#Grafana仪表板展示" class="headerlink" title="Grafana仪表板展示"></a>Grafana仪表板展示</h1><p>说实话第一次看到Grafana仪表板还是挺震撼的，展示的信息很多，可以帮助服务器维护人员分析很多问题，下面来展示一些主要的面板。</p><h2 id="服务器资源总览"><a href="#服务器资源总览" class="headerlink" title="服务器资源总览"></a>服务器资源总览</h2><p><img src="https://img-blog.csdnimg.cn/2baa1c032a6c48d6b6ff0ee634c4268f.png" alt="服务器总览"></p><h2 id="负载和内存使用"><a href="#负载和内存使用" class="headerlink" title="负载和内存使用"></a>负载和内存使用</h2><p><img src="https://img-blog.csdnimg.cn/f622fa54e73a400c857d697d047dd031.png" alt="负载和内存"></p><h2 id="网络带宽"><a href="#网络带宽" class="headerlink" title="网络带宽"></a>网络带宽</h2><p><img src="https://img-blog.csdnimg.cn/bf5f90b7524b43449ff26d01057ce636.png" alt="网络带宽"></p><h2 id="磁盘IO"><a href="#磁盘IO" class="headerlink" title="磁盘IO"></a>磁盘IO</h2><p><img src="https://img-blog.csdnimg.cn/fc2d904cb3684df380f84ec5d19e7d48.png" alt="磁盘IO"></p><h2 id="IO延迟"><a href="#IO延迟" class="headerlink" title="IO延迟"></a>IO延迟</h2><p><img src="https://img-blog.csdnimg.cn/3a4a5c9b3860410a8776a89a2326c86f.png" alt="IO延迟"></p><h2 id="其他指标"><a href="#其他指标" class="headerlink" title="其他指标"></a>其他指标</h2><p><img src="https://img-blog.csdnimg.cn/9d22f9db6a76477e981a81d8ac90135d.png" alt="其他指标"></p><h2 id="进程信息"><a href="#进程信息" class="headerlink" title="进程信息"></a>进程信息</h2><p><img src="https://img-blog.csdnimg.cn/986fefd7d3464d6eb3919b7e67ecdf9b.png" alt="进程信息"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>Telegraf、Grafana和InfluxDB通常被称为”铁三角”，因为它们经常一起使用，形成一个完整的监控和数据可视化解决方案</li><li>Telegraf是一个用于收集、处理和发送指标数据的代理，它可以与各种数据源和监控系统集成，定期收集数据并将其发送到目标位置</li><li>InfluxDB是一个开源的时间序列数据库，用于存储和查询大量时间序列数据。它被广泛用于存储来自Telegraf等数据收集器的指标数据</li><li>Grafana用于创建交互式仪表板，从各种数据源中提取数据，并将数据以图表、图形和表格等形式展示出来</li><li>Grafana的仪表板真的挺漂亮的</li></ul><center><a href="https://blog.csdn.net/albertsh/article/details/130569748" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>把烦恼痛了吞了认了算了<br>不对别人讲<br>谁还没有辜负几段 昂贵的时光</p><p>2023-6-17 19:39:56</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;@[toc]&lt;/p&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;数据监控目前用于各行各业，服务器开发也不例外，进程什么时候被杀死了？内存占用已经达到98%了怎么早点没发现，网络带宽已经占满了怪不得玩家反馈说登录不上去了，这些都是服务器开发人员常常听到的“抱怨”，他们都涉及到服务器资源的使用情况，如果有一种方便的途径可以高效的监控各个服务器的情况就好了，单靠人去各个服务器查看是不现实的，今天就来简单介绍一种我刚刚学到的方案。&lt;/p&gt;
    
    </summary>
    
      <category term="linux" scheme="http://AlbertGithubHome.github.io/blog/categories/linux/"/>
    
    
      <category term="linux" scheme="http://AlbertGithubHome.github.io/blog/tags/linux/"/>
    
      <category term="服务器" scheme="http://AlbertGithubHome.github.io/blog/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
      <category term="Telegraf" scheme="http://AlbertGithubHome.github.io/blog/tags/Telegraf/"/>
    
      <category term="InfluxDB" scheme="http://AlbertGithubHome.github.io/blog/tags/InfluxDB/"/>
    
      <category term="Grafana" scheme="http://AlbertGithubHome.github.io/blog/tags/Grafana/"/>
    
  </entry>
  
  <entry>
    <title>linux环境下熟悉又陌生的sudo命令</title>
    <link href="http://AlbertGithubHome.github.io/blog/2023/05/26/linux%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%86%9F%E6%82%89%E5%8F%88%E9%99%8C%E7%94%9F%E7%9A%84sudo%E5%91%BD%E4%BB%A4/"/>
    <id>http://AlbertGithubHome.github.io/blog/2023/05/26/linux环境下熟悉又陌生的sudo命令/</id>
    <published>2023-05-26T14:08:38.000Z</published>
    <updated>2023-06-18T07:26:33.243Z</updated>
    
    <content type="html"><![CDATA[<p>@[TOC]</p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><code>sudo</code>命令应该是任何一个服务器使用人员都绕不开的命令，比如那个大名鼎鼎的删库跑路命令 <code>sudo rm -rf /*</code>，虽然经常使用，也知道用它能做一些普通用户无法完成的事情，那么它究竟是什么意思，有什么作用和好处，和超级无敌的 <code>root</code> 用户又有什么关系呢？接下来我们来简单梳理一下。</p><h1 id="关于sudo的一些疑问"><a href="#关于sudo的一些疑问" class="headerlink" title="关于sudo的一些疑问"></a>关于sudo的一些疑问</h1><h2 id="sudo是什么"><a href="#sudo是什么" class="headerlink" title="sudo是什么"></a>sudo是什么</h2><p><code>sudo</code> 是一种在类 Unix 系统中使用的命令，用于以超级用户（superuser）的身份执行其他命令。它是 “Super User Do” 的缩写。超级用户通常是系统管理员，具有对操作系统的完全控制权。</p><p>当你以普通用户的身份登录到系统时，可能没有足够的权限来执行某些敏感的系统操作或访问某些文件。在这种情况下，可以使用 <code>sudo</code> 命令在临时提升权限的情况下执行特定命令。</p><p>使用 <code>sudo</code> 命令时，需要输入管理员密码以验证你的身份。一旦验证成功，就可以以超级用户的权限执行命令。这样可以确保系统安全，因为只有经过授权的用户才能执行特权操作。</p><p>例如，如果想要安装软件包或修改系统设置，但这些操作需要超级用户权限，你可以在命令前加上 <code>sudo</code>，然后输入密码以执行该命令。</p><p>以下是一个sudo命令使用的示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install git</span><br></pre></td></tr></table></figure></p><p>这个命令将使用 <code>apt-get</code> 工具安装一个软件包，由于它需要对系统进行修改，所以需要超级用户权限。通过使用 <code>sudo</code>，可以在普通用户的身份下临时获取这些权限来执行该操作。</p><h2 id="sudo-和-root-的区别和联系"><a href="#sudo-和-root-的区别和联系" class="headerlink" title="sudo 和 root 的区别和联系"></a>sudo 和 root 的区别和联系</h2><p><code>sudo</code> 和 <code>root</code> 在类 Unix 系统中具有不同的角色和功能。以下是它们之间的区别和联系：</p><ol><li><p><strong>权限级别：</strong> <code>root</code> 是超级用户，也称为系统管理员。拥有 <code>root</code> 权限意味着拥有对整个系统的完全控制权，可以执行所有操作并访问所有文件。相比之下，<code>sudo</code> 是一个命令，允许普通用户在需要时以超级用户的身份执行特定的命令。</p></li><li><p><strong>使用方式：</strong> <code>root</code> 用户可以直接登录到系统并拥有持久的超级用户权限。而 <code>sudo</code> 是一种临时提升权限的机制，允许普通用户在需要时以超级用户的身份执行特定命令。普通用户可以使用 <code>sudo</code> 命令来运行特权命令，但在执行时需要输入管理员密码进行身份验证。</p></li><li><p><strong>安全性：</strong> <code>sudo</code> 的使用可以提高系统的安全性。通过限制普通用户的特权，只有在需要执行特定任务时才临时提升权限，可以减少意外或恶意操作造成的潜在风险。相比之下，<code>root</code> 用户拥有系统的完全权限，因此使用 <code>root</code> 用户执行命令时需要格外小心，以免对系统造成损坏。</p></li><li><p><strong>日常操作：</strong> 为了提高系统安全性，通常建议使用 <code>sudo</code> 来执行需要特权的命令，而不是直接使用 <code>root</code> 用户。使用 <code>sudo</code> 可以在普通用户的身份下执行特权命令，并避免了在常规操作中长时间保持 <code>root</code> 权限，从而减少了潜在的错误或安全风险。</p></li></ol><p>总结来说，<code>root</code> 是系统的超级用户，拥有完全的权限，而 <code>sudo</code> 是一种临时提升权限的机制，允许普通用户以超级用户的身份执行特定命令。使用 <code>sudo</code> 可以提高系统的安全性，同时避免在日常操作中过多使用 <code>root</code> 用户带来的潜在风险。</p><h2 id="使用-sudo-的好处"><a href="#使用-sudo-的好处" class="headerlink" title="使用 sudo 的好处"></a>使用 sudo 的好处</h2><p>使用 <code>sudo</code> 有以下几个好处：</p><ol><li><p><strong>安全性：</strong> <code>sudo</code> 增加了系统的安全性。通过限制普通用户的特权，只有在需要执行特定任务时才临时提升权限，可以减少潜在的错误或恶意操作对系统造成的风险。普通用户在执行需要特权的命令时需要输入管理员密码，这种身份验证确保只有经过授权的用户才能执行特权操作。</p></li><li><p><strong>权限控制：</strong> <code>sudo</code> 允许系统管理员细粒度地控制用户对系统资源和命令的访问权限。管理员可以通过配置 <code>sudo</code> 的策略文件，精确地指定哪些用户可以执行哪些命令以及以何种方式执行。这种权限控制有助于实施最小权限原则，即用户只能以最低权限执行任务，从而降低了潜在的安全风险。</p></li><li><p><strong>审计和日志记录：</strong> <code>sudo</code> 提供了审计和日志记录功能，可以记录执行特权操作的用户、时间和执行的命令。这对于追踪系统中的活动、故障排查和安全审计非常有价值。通过审计和日志记录，管理员可以了解特权操作的细节，以及哪些用户在何时执行了哪些命令。</p></li><li><p><strong>限制特权操作：</strong> 使用 <code>sudo</code> 可以限制特权操作的范围。普通用户只有在需要执行特定命令时才能使用 <code>sudo</code> 提升权限。这种限制可以避免用户误操作或滥用超级用户权限，从而减少了对系统的潜在风险。</p></li></ol><p>总而言之，使用 <code>sudo</code> 可以提高系统的安全性、实施最小权限原则、提供审计和日志记录功能，并限制特权操作的范围。这使得系统管理员能够更好地管理用户权限并降低潜在的风险。</p><h2 id="怎样查看sudo命令日志"><a href="#怎样查看sudo命令日志" class="headerlink" title="怎样查看sudo命令日志"></a>怎样查看sudo命令日志</h2><p>可以使用适当的文本编辑器打开 sudo 日志文件：选择适用于你的系统的文本编辑器（如 nano、vim、或者其他）以超级用户权限打开 sudo 日志文件。日志文件的位置和名称可能会因操作系统的不同而异。下面是一些常见的 sudo 日志文件路径：</p><ul><li><p>Ubuntu、Debian 等基于 Debian 的系统：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo nano /var/log/auth.log</span><br></pre></td></tr></table></figure></li><li><p>CentOS、Fedora、Red Hat 等基于 Red Hat 的系统：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo nano /var/log/secure</span><br></pre></td></tr></table></figure></li><li><p>macOS：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo nano /var/log/system.log</span><br></pre></td></tr></table></figure></li></ul><p>查看 sudo 日志文件通常需要管理员或超级用户权限。确保你具有足够的权限才能访问和查看日志文件。此外，一些操作系统可能还提供了特定的命令或工具来查看系统日志，例如 <code>journalctl</code> 命令在某些 Linux 发行版中可用于查看系统日志。你可以根据你的操作系统和日志管理方式来选择适合的方法来查看 sudo 日志。</p><h1 id="修改sudo配置"><a href="#修改sudo配置" class="headerlink" title="修改sudo配置"></a>修改sudo配置</h1><p>sudo的配置文件是 <code>/etc/sudoers</code> 但是不建议直接用文本工具打开它，一旦修改出错可能导致很多严重问题，可以使用 <code>visudo</code> 命令进行打开编辑，使用 <code>visudo</code> 命令编辑 sudoers 文件时，系统会执行语法检查以确保配置的正确性，以避免可能的权限问题，下面展示一个简单配置样例：</p><h2 id="简单样例"><a href="#简单样例" class="headerlink" title="简单样例"></a>简单样例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># User privilege specification</span><br><span class="line">root    ALL=(ALL:ALL) ALL</span><br><span class="line"></span><br><span class="line"># Allow members of group sudo to execute any command</span><br><span class="line">%sudo   ALL=(ALL:ALL) ALL</span><br><span class="line"></span><br><span class="line"># Allow members of group admin to execute any command</span><br><span class="line">%admin  ALL=(ALL:ALL) ALL</span><br><span class="line"></span><br><span class="line"># Allow specific user to run specific command as another user</span><br><span class="line">johndoe ALL=(appuser) /usr/local/bin/git</span><br></pre></td></tr></table></figure><p><code>visudo</code> 是一个用于编辑 sudoers 文件的命令，该文件包含了与 sudo（以管理员权限执行命令）相关的配置信息。在 sudoers 文件中，每一行都由多个列组成，其中包含不同的字段和含义。以下是 sudoers 文件中各列的一般含义：</p><ol><li><p>列1：用户列表</p><ul><li>该列指定了可以使用 sudo 命令的用户或用户组。</li><li>可以是单个用户名，如 “bob”。</li><li>可以是用户组前缀 “%” 后跟用户组名，如 “%admin”。</li></ul></li><li><p>列2：主机列表</p><ul><li>该列指定了可以在哪些主机上使用 sudo 命令。</li><li>可以是单个主机名，如 “localhost”。</li><li>可以是主机名前缀 “ALL”，表示适用于所有主机。</li></ul></li><li><p>列3：=(运行 as) 列表</p><ul><li>该列指定了可以以哪个用户身份来运行命令。</li><li>可以是单个用户名，如 “root”。</li><li>可以是用户组前缀 “ALL”，表示可以以任何用户身份运行命令。</li><li>=(ALL:ALL)：表示可以以任何用户身份 (ALL) 在任何终端 (ALL) 上运行命令。</li></ul></li><li><p>列4：NOPASSWD: 标志</p><ul><li>该列指定了是否需要输入密码才能使用 sudo 命令。</li><li>如果列中包含 “NOPASSWD:”，则表示不需要密码。</li><li>如果列为空或未包含 “NOPASSWD:”，则需要输入密码。</li></ul></li><li><p>列5及以后：命令列表</p><ul><li>该列指定了可以使用 sudo 命令执行的具体命令。</li><li>可以是完整的命令路径，如 “/usr/bin/apt-get”。</li><li>可以是通配符，如 “/usr/bin/*” 表示该目录下的所有命令。</li></ul></li></ol><h2 id="复杂样例及解释"><a href="#复杂样例及解释" class="headerlink" title="复杂样例及解释"></a>复杂样例及解释</h2><p>下面是一个复杂一些的 visudo 配置示例，其中包含了多个用户、用户组和命令的授权规则：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># User privilege specification</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## Allow root to run any commands on all hosts</span></span><br><span class="line">root    ALL=(ALL:ALL) ALL</span><br><span class="line"></span><br><span class="line"><span class="comment">## Allow members of the admin group to run any commands on all hosts</span></span><br><span class="line">%admin  ALL=(ALL:ALL) ALL</span><br><span class="line"></span><br><span class="line"><span class="comment">## Allow specific user to run specific commands as root without password</span></span><br><span class="line">johndoe ALL=(root) NOPASSWD: /bin/ls, /usr/bin/apt-get</span><br><span class="line"></span><br><span class="line"><span class="comment">## Allow specific user to run commands in specific directories as another user</span></span><br><span class="line">johndoe ALL=(appuser) /opt/app/bin/*</span><br><span class="line">johndoe ALL=(backupuser) /var/backup/scripts/*</span><br><span class="line"></span><br><span class="line"><span class="comment">## Allow specific user to run specific command with arguments as root</span></span><br><span class="line">johndoe ALL=(root) /usr/sbin/usermod [a-z]*</span><br><span class="line"></span><br><span class="line"><span class="comment">## Deny specific user to run any command</span></span><br><span class="line">banneduser ALL=(ALL:ALL) ALL, !/usr/bin/*</span><br><span class="line"></span><br><span class="line"><span class="comment">## Allow members of the wheel group to run any commands on localhost without password</span></span><br><span class="line">%wheel  localhost=(ALL:ALL) NOPASSWD: ALL</span><br><span class="line"></span><br><span class="line"><span class="comment">## Allow users in the developer group to run specific commands with arguments</span></span><br><span class="line">%developer ALL=(ALL:ALL) /usr/bin/git *, /usr/bin/make clean</span><br><span class="line"></span><br><span class="line"><span class="comment">## Allow users in the support group to restart specific services</span></span><br><span class="line">%support ALL=(root) /usr/sbin/service apache2 restart, /usr/sbin/service nginx restart</span><br></pre></td></tr></table></figure><p>上述配置说明不考虑注释行，含义如下：</p><ul><li>第1行表示允许 root 用户在所有主机上以任何用户身份执行任何命令。</li><li>第3行表示允许 johndoe 用户作为 root 用户以无需密码的方式执行 <code>/bin/ls</code> 和 <code>/usr/bin/apt-get</code> 命令。</li><li>第4行和第5行表示允许 johndoe 用户作为 appuser 用户或 backupuser 用户在特定目录下执行命令。</li><li>第6行表示允许 johndoe 用户作为 root 用户执行带有特定参数的 <code>/usr/sbin/usermod</code> 命令。</li><li>第7行表示禁止 banneduser 用户执行除 <code>/usr/bin/*</code> 之外的所有命令。</li><li>第8行表示允许 wheel 组的用户在 localhost 主机上以任何用户身份执行任何命令，且无需密码。</li><li>第9行表示允许 developer 组的用户执行带有特定参数的 <code>/usr/bin/git</code> 和 <code>/usr/bin/make</code> 命令。</li><li>第10行表示允许 support 组的用户作为 root 用户重启特定服务。</li></ul><h1 id="使用sudo用户"><a href="#使用sudo用户" class="headerlink" title="使用sudo用户"></a>使用sudo用户</h1><h2 id="创建用户并添加到-sudo-组"><a href="#创建用户并添加到-sudo-组" class="headerlink" title="创建用户并添加到 sudo 组"></a>创建用户并添加到 sudo 组</h2><p>在 Linux 上创建用户并将其添加到 <code>sudo</code> 组，可以按照以下步骤进行操作：</p><ol><li><p>打开终端：在操作系统中打开终端或命令行界面。</p></li><li><p>使用 <code>adduser</code> 命令创建新用户：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo adduser newuser</span><br></pre></td></tr></table></figure><p>这将提示你输入新用户的密码和其他详细信息。</p></li><li><p>将新用户添加到 <code>sudo</code> 组。可以使用 <code>usermod</code> 命令执行此操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo usermod -aG sudo newuser</span><br></pre></td></tr></table></figure><p>这将将新用户 <code>newuser</code> 添加到 <code>sudo</code> 组中。</p></li><li><p>验证用户是否成功添加到 <code>sudo</code> 组。你可以通过执行以下命令来检查用户所属的组：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">groups newuser</span><br></pre></td></tr></table></figure><p>如果 <code>sudo</code> 组在列表中显示，表示用户已成功添加到 <code>sudo</code> 组。</p></li></ol><p>现在，新创建的用户已经添加到 <code>sudo</code> 组，拥有 sudo 权限。他们可以使用 <code>sudo</code> 命令以管理员权限执行特权操作。请确保将适当的权限授予新用户，以确保系统的安全性和合规性。</p><h2 id="查看是否有sudo权限"><a href="#查看是否有sudo权限" class="headerlink" title="查看是否有sudo权限"></a>查看是否有sudo权限</h2><p>可以通过id命令查看指定用户是否在 <code>sudo</code> 组内，比如下面的用户就在27(sudo)这个组内：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@jenkins1604:~# id gyee</span><br><span class="line">uid=1004(gyee) gid=1004(gyee) groups=1004(gyee),27(sudo)</span><br></pre></td></tr></table></figure><p>也可以查看(sudo)组内是否包含当前用户：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@jenkins1604:~# getent group sudo</span><br><span class="line">sudo:x:27:admin,gyee</span><br></pre></td></tr></table></figure></p><p><code>getent</code> 是一个命令行工具，用于从系统数据库（如密码、组、主机、服务等）中获取条目的信息。它可以用于检索和显示与系统用户、组、网络服务和其他系统资源相关的信息 ，<code>getent</code> 命令的基本语法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getent database entry</span><br></pre></td></tr></table></figure><p>其中，<code>database</code> 表示要查询的数据库，而 <code>entry</code> 则表示要获取的数据库条目。 以下是一些常见的 <code>getent</code> 命令示例：</p><ul><li><p>获取系统中所有用户的信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getent passwd</span><br></pre></td></tr></table></figure></li><li><p>获取特定用户的信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getent passwd &lt;username&gt;</span><br></pre></td></tr></table></figure></li><li><p>获取系统中所有组的信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getent group</span><br></pre></td></tr></table></figure></li><li><p>获取特定组的信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getent group &lt;groupname&gt;</span><br></pre></td></tr></table></figure></li><li><p>获取系统中所有网络服务的信息（/etc/services 文件中定义的服务）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getent services</span><br></pre></td></tr></table></figure></li></ul><h2 id="没有sudo权限时执行会被记录"><a href="#没有sudo权限时执行会被记录" class="headerlink" title="没有sudo权限时执行会被记录"></a>没有sudo权限时执行会被记录</h2><p>当没有sudo权限时，执行命令会输出以下信息，显示此操作被记录在案：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gyee@jenkins1604:/root$ sudo usermod -aG sudo gyee</span><br><span class="line">[sudo] password for gyee:</span><br><span class="line">gyee is not in the sudoers file.  This incident will be reported.</span><br></pre></td></tr></table></figure><p>可以查询系统安全日志</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@jenkins1604:~# cat /var/log/auth.log | grep gyee</span><br><span class="line">May 26 22:07:13 machine sudo:     gyee : user NOT in sudoers ; TTY=pts/1 ; PWD=/root ; USER=root ; COMMAND=/usr/sbin/usermod -aG sudo gyee</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li><code>sudo</code> 是一种在类 Unix 系统中使用的命令，用于以超级用户（superuser）的身份执行其他命令</li><li><code>root</code> 是超级用户，拥有对整个系统的完全控制权，<code>sudo</code> 是一个允许普通用户在需要时以超级用户的身份执行特定的命令</li><li><code>adduser</code> 和 <code>useradd</code> 都是在 Linux 系统上用于创建用户的命令，但 <code>adduser</code>命令更方便友好，尤其适用于交互式的用户创建</li><li><code>getent</code> 是一个命令行工具，用于从系统数据库（如密码、组、主机、服务等）中获取条目的信息</li></ul><center><a href="https://blog.csdn.net/albertsh/article/details/130569748" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>大家所谓的不满，是不满自己没成为人上人吧，至于温饱，很多人已经绰绰有余了~</p><p>2023-5-26 22:08:38</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;@[TOC]&lt;/p&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&lt;code&gt;sudo&lt;/code&gt;命令应该是任何一个服务器使用人员都绕不开的命令，比如那个大名鼎鼎的删库跑路命令
      
    
    </summary>
    
      <category term="linux" scheme="http://AlbertGithubHome.github.io/blog/categories/linux/"/>
    
    
      <category term="linux" scheme="http://AlbertGithubHome.github.io/blog/tags/linux/"/>
    
      <category term="服务器" scheme="http://AlbertGithubHome.github.io/blog/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
      <category term="sudo" scheme="http://AlbertGithubHome.github.io/blog/tags/sudo/"/>
    
      <category term="adduser" scheme="http://AlbertGithubHome.github.io/blog/tags/adduser/"/>
    
      <category term="getent" scheme="http://AlbertGithubHome.github.io/blog/tags/getent/"/>
    
  </entry>
  
  <entry>
    <title>linux环境下使用daemon函数实现守护进程</title>
    <link href="http://AlbertGithubHome.github.io/blog/2023/05/12/linux%E7%8E%AF%E5%A2%83%E4%B8%8B%E4%BD%BF%E7%94%A8daemon%E5%87%BD%E6%95%B0%E5%AE%9E%E7%8E%B0%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B/"/>
    <id>http://AlbertGithubHome.github.io/blog/2023/05/12/linux环境下使用daemon函数实现守护进程/</id>
    <published>2023-05-12T14:38:40.000Z</published>
    <updated>2023-06-18T07:27:04.083Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>daemon进程是后台守护进程，比如linux 下server都是daemon进程，像httpd、sshd等这些服务你肯定听说过，如果我们想写一个后台运行程序应该怎么做呢？其实非常容易，只要添加头文件 <code>#include &lt;unistd.h&gt;</code>，然后在调用 <code>daemon(1, 0)</code>函数即可。</p><a id="more"></a><h1 id="daemon函数说明"><a href="#daemon函数说明" class="headerlink" title="daemon函数说明"></a>daemon函数说明</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Put the program in the background, and dissociate from the controlling</span></span><br><span class="line"><span class="comment">   terminal.  If NOCHDIR is zero, do `chdir ("/")'.  If NOCLOSE is zero,</span></span><br><span class="line"><span class="comment">   redirects stdin, stdout, and stderr to /dev/null.  */</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">daemon</span> <span class="params">(<span class="keyword">int</span> __nochdir, <span class="keyword">int</span> __noclose)</span> __THROW __wur</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* Use misc.  */</span></span></span><br></pre></td></tr></table></figure><p>头文件中已经说得很清楚了，当 nochdir为零时，将当前目录变为根目录，否则不变，当 noclose为零时，标准输入、标准输出和错误输出重导向为/dev/null不输出任何信息，否则照样输出。</p><h1 id="daemon函数的实现"><a href="#daemon函数的实现" class="headerlink" title="daemon函数的实现"></a>daemon函数的实现</h1><p>关于找daemon函数的实现还是费了一些功夫的，我发现我根本不会在github上查代码，一开始以为是linux源码所以去翻了Linus Torvalds的Linux源码结果没找到，最后还是在google收到了一些，整理如下：</p><h2 id="安卓源码"><a href="#安卓源码" class="headerlink" title="安卓源码"></a>安卓源码</h2><blockquote><p><a href="https://android.googlesource.com/platform/bionic.git/+/donut-release/libc/unistd/daemon.c" target="_blank" rel="noopener">https://android.googlesource.com/platform/bionic.git/+/donut-release/libc/unistd/daemon.c</a></p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">daemon</span><span class="params">( <span class="keyword">int</span>  nochdir, <span class="keyword">int</span>  noclose )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">pid_t</span>  pid;</span><br><span class="line">   <span class="keyword">if</span> ( !nochdir &amp;&amp; chdir(<span class="string">"/"</span>) != <span class="number">0</span> )</span><br><span class="line">       <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> ( !noclose )</span><br><span class="line">   &#123;</span><br><span class="line">     <span class="keyword">int</span>  fd = open(<span class="string">"/dev/null"</span>, O_RDWR);</span><br><span class="line">     <span class="keyword">if</span> ( fd &lt; <span class="number">0</span> )</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">     <span class="keyword">if</span> ( dup2( fd, <span class="number">0</span> ) &lt; <span class="number">0</span> ||</span><br><span class="line">      dup2( fd, <span class="number">1</span> ) &lt; <span class="number">0</span> ||</span><br><span class="line">          dup2( fd, <span class="number">2</span> ) &lt; <span class="number">0</span> )</span><br><span class="line">     &#123;</span><br><span class="line">       close(fd);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     close(fd);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   pid = fork();</span><br><span class="line">   <span class="keyword">if</span> (pid &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">   <span class="keyword">if</span> (pid &gt; <span class="number">0</span>)</span><br><span class="line">    _exit(<span class="number">0</span>);</span><br><span class="line">   <span class="keyword">if</span> ( setsid() &lt; <span class="number">0</span> )</span><br><span class="line">     <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="苹果源码"><a href="#苹果源码" class="headerlink" title="苹果源码"></a>苹果源码</h2><blockquote><p><a href="https://opensource.apple.com/source/Libc/Libc-167/gen.subproj/daemon.c.auto.html" target="_blank" rel="noopener">https://opensource.apple.com/source/Libc/Libc-167/gen.subproj/daemon.c.auto.html</a></p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;paths.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">daemon(nochdir, noclose)</span><br><span class="line">    <span class="keyword">int</span> nochdir, noclose;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (fork()) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">-1</span>:</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        _exit(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (setsid() == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!nochdir)</span><br><span class="line">        (<span class="keyword">void</span>)chdir(<span class="string">"/"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!noclose &amp;&amp; (fd = open(_PATH_DEVNULL, O_RDWR, <span class="number">0</span>)) != <span class="number">-1</span>) &#123;</span><br><span class="line">        (<span class="keyword">void</span>)dup2(fd, STDIN_FILENO);</span><br><span class="line">        (<span class="keyword">void</span>)dup2(fd, STDOUT_FILENO);</span><br><span class="line">        (<span class="keyword">void</span>)dup2(fd, STDERR_FILENO);</span><br><span class="line">        <span class="keyword">if</span> (fd &gt; <span class="number">2</span>)</span><br><span class="line">            (<span class="keyword">void</span>)close (fd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="glibc源码"><a href="#glibc源码" class="headerlink" title="glibc源码"></a>glibc源码</h2><blockquote><p><a href="https://elixir.bootlin.com/glibc/glibc-2.37/source/misc/daemon.c" target="_blank" rel="noopener">https://elixir.bootlin.com/glibc/glibc-2.37/source/misc/daemon.c</a></p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(LIBC_SCCS) &amp;&amp; !defined(lint)</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> sccsid[] = <span class="string">"@(#)daemon.c    8.1 (Berkeley) 6/4/93"</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* LIBC_SCCS and not lint */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;paths.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;device-nrs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;not-cancel.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">daemon (<span class="keyword">int</span> nochdir, <span class="keyword">int</span> noclose)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (__fork()) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">-1</span>:</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        _exit(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (__setsid() == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!nochdir)</span><br><span class="line">        (<span class="keyword">void</span>)__chdir(<span class="string">"/"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!noclose) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> __<span class="title">stat64_t64</span> <span class="title">st</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((fd = __open_nocancel(_PATH_DEVNULL, O_RDWR, <span class="number">0</span>)) != <span class="number">-1</span></span><br><span class="line">            &amp;&amp; __glibc_likely (__fstat64_time64 (fd, &amp;st) == <span class="number">0</span>)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (__builtin_expect (S_ISCHR (st.st_mode), <span class="number">1</span>) != <span class="number">0</span></span><br><span class="line">#<span class="keyword">if</span> defined DEV_NULL_MAJOR &amp;&amp; defined DEV_NULL_MINOR</span><br><span class="line">                &amp;&amp; (st.st_rdev</span><br><span class="line">                == makedev (DEV_NULL_MAJOR, DEV_NULL_MINOR))</span><br><span class="line">#endif</span><br><span class="line">                ) &#123;</span><br><span class="line">                (<span class="keyword">void</span>)__dup2(fd, STDIN_FILENO);</span><br><span class="line">                (<span class="keyword">void</span>)__dup2(fd, STDOUT_FILENO);</span><br><span class="line">                (<span class="keyword">void</span>)__dup2(fd, STDERR_FILENO);</span><br><span class="line">                <span class="keyword">if</span> (fd &gt; <span class="number">2</span>)</span><br><span class="line">                    (<span class="keyword">void</span>)__close (fd);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">/* We must set an errno value since no</span></span><br><span class="line"><span class="comment">                   function call actually failed.  */</span></span><br><span class="line">                __close_nocancel_nostatus (fd);</span><br><span class="line">                __set_errno (ENODEV);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            __close_nocancel_nostatus (fd);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="glibc-github地址"><a href="#glibc-github地址" class="headerlink" title="glibc github地址"></a>glibc github地址</h2><blockquote><p><a href="https://github.com/lattera/glibc/blob/master/misc/daemon.c" target="_blank" rel="noopener">https://github.com/lattera/glibc/blob/master/misc/daemon.c</a></p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(LIBC_SCCS) &amp;&amp; !defined(lint)</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> sccsid[] = <span class="string">"@(#)daemon.c    8.1 (Berkeley) 6/4/93"</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* LIBC_SCCS and not lint */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;paths.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;device-nrs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;not-cancel.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">daemon (<span class="keyword">int</span> nochdir, <span class="keyword">int</span> noclose)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (__fork()) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">-1</span>:</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        _exit(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (__setsid() == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!nochdir)</span><br><span class="line">        (<span class="keyword">void</span>)__chdir(<span class="string">"/"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!noclose) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">stat64</span> <span class="title">st</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((fd = __open_nocancel(_PATH_DEVNULL, O_RDWR, <span class="number">0</span>)) != <span class="number">-1</span></span><br><span class="line">            &amp;&amp; (__builtin_expect (__fxstat64 (_STAT_VER, fd, &amp;st), <span class="number">0</span>)</span><br><span class="line">            == <span class="number">0</span>)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (__builtin_expect (S_ISCHR (st.st_mode), <span class="number">1</span>) != <span class="number">0</span></span><br><span class="line">#<span class="keyword">if</span> defined DEV_NULL_MAJOR &amp;&amp; defined DEV_NULL_MINOR</span><br><span class="line">                &amp;&amp; (st.st_rdev</span><br><span class="line">                == makedev (DEV_NULL_MAJOR, DEV_NULL_MINOR))</span><br><span class="line">#endif</span><br><span class="line">                ) &#123;</span><br><span class="line">                (<span class="keyword">void</span>)__dup2(fd, STDIN_FILENO);</span><br><span class="line">                (<span class="keyword">void</span>)__dup2(fd, STDOUT_FILENO);</span><br><span class="line">                (<span class="keyword">void</span>)__dup2(fd, STDERR_FILENO);</span><br><span class="line">                <span class="keyword">if</span> (fd &gt; <span class="number">2</span>)</span><br><span class="line">                    (<span class="keyword">void</span>)__close (fd);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">/* We must set an errno value since no</span></span><br><span class="line"><span class="comment">                   function call actually failed.  */</span></span><br><span class="line">                __close_nocancel_nostatus (fd);</span><br><span class="line">                __set_errno (ENODEV);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            __close_nocancel_nostatus (fd);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="挺有意思的写法"><a href="#挺有意思的写法" class="headerlink" title="挺有意思的写法"></a>挺有意思的写法</h2><blockquote><p><a href="https://github.com/bmc/daemonize/blob/master/daemon.c" target="_blank" rel="noopener">https://github.com/bmc/daemonize/blob/master/daemon.c</a></p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">daemon</span><span class="params">(<span class="keyword">int</span> nochdir, <span class="keyword">int</span> noclose)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> status = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    openlog(<span class="string">"daemonize"</span>, LOG_PID, LOG_DAEMON);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Fork once to go into the background. */</span></span><br><span class="line">    <span class="keyword">if</span>((status = do_fork()) &lt; <span class="number">0</span> )</span><br><span class="line">        ;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Create new session */</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(setsid() &lt; <span class="number">0</span>)               <span class="comment">/* shouldn't fail */</span></span><br><span class="line">        status = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Fork again to ensure that daemon never reacquires a control terminal. */</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>((status = do_fork()) &lt; <span class="number">0</span> )</span><br><span class="line">        ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* clear any inherited umask(2) value */</span></span><br><span class="line"></span><br><span class="line">        umask(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* We're there. */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(! nochdir)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* Go to a neutral corner. */</span></span><br><span class="line">            chdir(<span class="string">"/"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(! noclose)</span><br><span class="line">            redirect_fds();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="nginx中实现"><a href="#nginx中实现" class="headerlink" title="nginx中实现"></a>nginx中实现</h2><blockquote><p><a href="https://github.com/nginx/nginx/blob/master/src/os/unix/ngx_daemon.c" target="_blank" rel="noopener">https://github.com/nginx/nginx/blob/master/src/os/unix/ngx_daemon.c</a></p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ngx_int_t</span></span><br><span class="line">ngx_daemon(<span class="keyword">ngx_log_t</span> *<span class="built_in">log</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span>  fd;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (fork()) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">-1</span>:</span><br><span class="line">        ngx_log_error(NGX_LOG_EMERG, <span class="built_in">log</span>, ngx_errno, <span class="string">"fork() failed"</span>);</span><br><span class="line">        <span class="keyword">return</span> NGX_ERROR;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ngx_parent = ngx_pid;</span><br><span class="line">    ngx_pid = ngx_getpid();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (setsid() == <span class="number">-1</span>) &#123;</span><br><span class="line">        ngx_log_error(NGX_LOG_EMERG, <span class="built_in">log</span>, ngx_errno, <span class="string">"setsid() failed"</span>);</span><br><span class="line">        <span class="keyword">return</span> NGX_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    umask(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    fd = open(<span class="string">"/dev/null"</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        ngx_log_error(NGX_LOG_EMERG, <span class="built_in">log</span>, ngx_errno,</span><br><span class="line">                      <span class="string">"open(\"/dev/null\") failed"</span>);</span><br><span class="line">        <span class="keyword">return</span> NGX_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dup2(fd, STDIN_FILENO) == <span class="number">-1</span>) &#123;</span><br><span class="line">        ngx_log_error(NGX_LOG_EMERG, <span class="built_in">log</span>, ngx_errno, <span class="string">"dup2(STDIN) failed"</span>);</span><br><span class="line">        <span class="keyword">return</span> NGX_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dup2(fd, STDOUT_FILENO) == <span class="number">-1</span>) &#123;</span><br><span class="line">        ngx_log_error(NGX_LOG_EMERG, <span class="built_in">log</span>, ngx_errno, <span class="string">"dup2(STDOUT) failed"</span>);</span><br><span class="line">        <span class="keyword">return</span> NGX_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">    <span class="keyword">if</span> (dup2(fd, STDERR_FILENO) == <span class="number">-1</span>) &#123;</span><br><span class="line">        ngx_log_error(NGX_LOG_EMERG, <span class="built_in">log</span>, ngx_errno, <span class="string">"dup2(STDERR) failed"</span>);</span><br><span class="line">        <span class="keyword">return</span> NGX_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fd &gt; STDERR_FILENO) &#123;</span><br><span class="line">        <span class="keyword">if</span> (close(fd) == <span class="number">-1</span>) &#123;</span><br><span class="line">            ngx_log_error(NGX_LOG_EMERG, <span class="built_in">log</span>, ngx_errno, <span class="string">"close() failed"</span>);</span><br><span class="line">            <span class="keyword">return</span> NGX_ERROR;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> NGX_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="chatgpt生成"><a href="#chatgpt生成" class="headerlink" title="chatgpt生成"></a>chatgpt生成</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">daemon</span><span class="params">(<span class="keyword">int</span> nochdir, <span class="keyword">int</span> noclose)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建子进程并退出父进程</span></span><br><span class="line">    <span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建新的会话</span></span><br><span class="line">    <span class="keyword">if</span> (setsid() &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 忽略 SIGHUP 信号</span></span><br><span class="line">    signal(SIGHUP, SIG_IGN);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 再次创建子进程并退出父进程</span></span><br><span class="line">    <span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更改当前工作目录</span></span><br><span class="line">    <span class="keyword">if</span> (!nochdir) &#123;</span><br><span class="line">        <span class="keyword">if</span> (chdir(<span class="string">"/"</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭文件描述符</span></span><br><span class="line">    <span class="keyword">if</span> (!noclose) &#123;</span><br><span class="line">        <span class="keyword">int</span> fd;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((fd = open(<span class="string">"/dev/null"</span>, O_RDWR, <span class="number">0</span>)) != <span class="number">-1</span>) &#123;</span><br><span class="line">            dup2(fd, STDIN_FILENO);</span><br><span class="line">            dup2(fd, STDOUT_FILENO);</span><br><span class="line">            dup2(fd, STDERR_FILENO);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (fd &gt; STDERR_FILENO) &#123;</span><br><span class="line">                close(fd);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="daemon函数fork两次的原因"><a href="#daemon函数fork两次的原因" class="headerlink" title="daemon函数fork两次的原因"></a>daemon函数fork两次的原因</h1><p>以上这些开源实现中，有的fork一次，有的fork两次，不过fork一次的多一些，对于这个问题我还查了不少资料</p><blockquote><p><a href="http://www.cppblog.com/justin-shi/archive/2014/10/10/208530.html" target="_blank" rel="noopener">http://www.cppblog.com/justin-shi/archive/2014/10/10/208530.html</a><br><a href="https://blog.csdn.net/shaoye_csdn1/article/details/94599271" target="_blank" rel="noopener">https://blog.csdn.net/shaoye_csdn1/article/details/94599271</a><br><a href="https://m.xp.cn/b.php/75000.html" target="_blank" rel="noopener">https://m.xp.cn/b.php/75000.html</a></p></blockquote><p>关于为什么要fork两次，我找到了上面几篇相关的解释，总结如下：</p><p>第一次fork使父进程终止，让子进程中进入后台执行，同时保证了会话id与当前子进程id不同，可以调用setsid函数创建新的会话，保证了子进程是会话组长(sid==pid)，也是进程组组长(pgid == pid)。</p><p>第二次fork目的是防止进程再次打开一个控制终端，因为打开一个控制终端的前提条件是该进程必须是会话组长，再fork一次可以保证子进程pid != sid（sid是进程父进程的sid），所以也无法打开新的控制终端。</p><p><strong><em>关于第一次fork我是理解的，第二次fork我也做过实验，无论fork一次还是两次，都可以再次打开新的终端，也就是说即使保证了pid != sid，一样可以打开新的终端，而有很多daemon函数的开源的实现中也只是调用了一次fork，包括我使用的Ubuntu20.04实验结果也是调用了一次fork，所以调用两次fork的原因成谜。</em></strong></p><blockquote><p><a href="https://www.cntofu.com/book/46/linux_system/153.md" target="_blank" rel="noopener">https://www.cntofu.com/book/46/linux_system/153.md</a></p></blockquote><p>而这篇文章总结了两次fork技巧，不过和我们本文中所说的daemon两次fork前提不一样，在父进程不退出时会使用两次fork技巧避免出现僵尸进程，但时在daemon函数中fork只之后的父进程都是直接退出的，所以应该不是这个原因。</p><p>关于这个疑问我还专门去ChatGPT上问了一下，它给的答案如下：</p><blockquote><p>在早期的Unix系统中，使用 <code>daemon()</code> 函数通常需要调用两次 <code>fork()</code> 函数，以确保子进程成为孤儿进程（orphan process），即与任何终端无关联，并且不会收到终端信号。孤儿进程通常是由父进程创建的子进程，但父进程已经退出或被杀死。</p><p>以下是调用两次 <code>fork()</code> 函数的工作原理：</p><ol><li>调用第一次 <code>fork()</code> 函数：创建子进程1。父进程退出，子进程1成为孤儿进程，也就是没有父进程的进程。此时，子进程1仍然与原来的控制终端相关联。</li><li>子进程1调用 <code>setsid()</code> 函数创建一个新的会话，并成为新会话的领头进程和新进程组的组长进程。由于孤儿进程已经成为新会话的领头进程，因此它无法再重新关联到终端。此时，子进程1仍然是当前进程组的组长进程，并且与新的控制终端相关联。</li><li><p>调用第二次 <code>fork()</code> 函数：创建子进程2。由于子进程1是新会话的领头进程，因此子进程2不再与任何控制终端相关联。此时，子进程2成为孤儿进程，并与新会话和新进程组分离。</p></li><li><p>子进程2关闭不需要的文件描述符，改变工作目录和文件掩码，最后运行守护进程。</p></li></ol></blockquote><p>&gt;</p><blockquote><p>需要注意的是，在现代的Linux系统中，使用 <code>daemon()</code> 函数只需要调用一次 <code>fork()</code> 函数和一些必要的操作（如 <code>setsid()</code>、关闭文件描述符等），就可以将进程变成守护进程，而不需要调用两次 <code>fork()</code> 函数。</p></blockquote><h1 id="自己做实验的代码"><a href="#自己做实验的代码" class="headerlink" title="自己做实验的代码"></a>自己做实验的代码</h1><p>自己在测试 <code>daemon</code> 函数的时候写了一些代码，记录一下方便再次拿来用，请原谅我c/c++混用，为了验证某个问题我已经各种尝试了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt; //open O_RDWR</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt; //umask</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">my_daemon</span> <span class="params">(<span class="keyword">int</span> nochdir, <span class="keyword">int</span> noclose)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Fork and exit parent process.  */</span></span><br><span class="line">  <span class="keyword">if</span> ((pid = fork ()) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (pid != <span class="number">0</span>)</span><br><span class="line">    _exit (<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Detach ourselves from the parent process group.  */</span></span><br><span class="line">  <span class="keyword">if</span> (setsid () &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Fork again to ensure we are not session leader.  */</span></span><br><span class="line">  <span class="keyword">if</span> ((pid = fork ()) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (pid != <span class="number">0</span>)</span><br><span class="line">    _exit (<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Change the file mode mask.  */</span></span><br><span class="line">  umask (<span class="number">022</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* If nochdir is zero, change to the root directory.  */</span></span><br><span class="line">  <span class="keyword">if</span> (!nochdir)</span><br><span class="line">    chdir (<span class="string">"/"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* If noclose is zero, redirect standard input, standard output,</span></span><br><span class="line"><span class="comment">     and standard error to /dev/null.  */</span></span><br><span class="line">  <span class="keyword">if</span> (!noclose)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">int</span> fd;</span><br><span class="line"></span><br><span class="line">      fd = open (<span class="string">"/dev/null"</span>, O_RDWR, <span class="number">0</span>);</span><br><span class="line">      <span class="keyword">if</span> (fd != <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">          dup2 (fd, STDIN_FILENO);</span><br><span class="line">          dup2 (fd, STDOUT_FILENO);</span><br><span class="line">          dup2 (fd, STDERR_FILENO);</span><br><span class="line">          <span class="keyword">if</span> (fd &gt; <span class="number">2</span>)</span><br><span class="line">            close (fd);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showpidinfo</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* info)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; info &lt;&lt; <span class="string">"\n"</span></span><br><span class="line">        &lt;&lt; <span class="string">"getpid="</span> &lt;&lt; getpid() &lt;&lt; <span class="string">"\n"</span></span><br><span class="line">        &lt;&lt; <span class="string">"getppid="</span> &lt;&lt; getppid() &lt;&lt; <span class="string">"\n"</span></span><br><span class="line">        &lt;&lt; <span class="string">"getpgrp="</span> &lt;&lt; getpgrp() &lt;&lt; <span class="string">"\n"</span></span><br><span class="line">        &lt;&lt; <span class="string">"getpgid(pid)="</span> &lt;&lt; getpgid(getpid()) &lt;&lt; <span class="string">"\n"</span></span><br><span class="line">        &lt;&lt; <span class="string">"getsid(pid)="</span> &lt;&lt; getsid(getpid()) &lt;&lt; <span class="string">"\n"</span></span><br><span class="line">        &lt;&lt; <span class="string">"getuid="</span> &lt;&lt; getuid() &lt;&lt; <span class="string">"\n"</span></span><br><span class="line">        &lt;&lt; <span class="string">"geteuid="</span> &lt;&lt; geteuid() &lt;&lt; <span class="string">"\n"</span></span><br><span class="line">        &lt;&lt; <span class="string">"getgid="</span> &lt;&lt; getgid() &lt;&lt; <span class="string">"\n"</span></span><br><span class="line">        &lt;&lt; <span class="string">"getegid="</span> &lt;&lt; getegid() &lt;&lt; <span class="string">"\n"</span></span><br><span class="line">        &lt;&lt; <span class="string">"ttyname(0)="</span> &lt;&lt; ttyname(<span class="number">0</span>) &lt;&lt; <span class="string">"\n"</span></span><br><span class="line">        &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">open_new_terminal</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    system(<span class="string">"gnome-terminal -- /bin/bash -c 'date; exec bash'"</span>);</span><br><span class="line">    <span class="comment">//system("konsole  -e './v'");</span></span><br><span class="line">    <span class="comment">//system("xterm   -e './v'");</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> strCurPath[PATH_MAX];</span><br><span class="line"></span><br><span class="line">    showpidinfo(<span class="string">"===before daemon:"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//while(1);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n = daemon(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//int n = my_daemon(0, 1);</span></span><br><span class="line"></span><br><span class="line">    open_new_terminal();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"daemon result %d\n"</span>, n);</span><br><span class="line">    showpidinfo(<span class="string">"===after daemon:"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(n &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"error daemon.../n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sleep(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(getcwd(strCurPath, PATH_MAX) == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"error getcwd"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"cur path [%s]\n"</span>, strCurPath);  <span class="comment">//打印当前目录</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>showpidinfo</code> 函数用于输出进程id相关信息</li><li><code>open_new_terminal</code> 函数用于打开一个新的控制台</li><li><code>my_daemon</code> 函数是自定义的daemon实现，采用fork两次的形式</li><li><code>perror</code> 可以输出详细的报错信息</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># demo @ ThinkPad-X390 in ~/cpp/daemontest [23:30:53]</span></span><br><span class="line">$ g++ a.cpp</span><br><span class="line">$ ./a.out</span><br><span class="line">===before daemon:</span><br><span class="line">getpid=352638</span><br><span class="line">getppid=62351</span><br><span class="line">getpgrp=352638</span><br><span class="line">getpgid(pid)=352638</span><br><span class="line">getsid(pid)=62351</span><br><span class="line">getuid=1000</span><br><span class="line">geteuid=1000</span><br><span class="line">getgid=1000</span><br><span class="line">getegid=1000</span><br><span class="line">ttyname(0)=/dev/pts/15</span><br><span class="line"><span class="comment"># demo @ ThinkPad-X390 in ~/cpp/daemontest [23:30:57]</span></span><br><span class="line">$ Unable to init server: Could not connect: Connection refused</span><br><span class="line"><span class="comment"># Failed to parse arguments: Cannot open display:</span></span><br><span class="line">daemon result 0</span><br><span class="line">===after daemon:</span><br><span class="line">getpid=352639</span><br><span class="line">getppid=1</span><br><span class="line">getpgrp=352639</span><br><span class="line">getpgid(pid)=352639</span><br><span class="line">getsid(pid)=352639</span><br><span class="line">getuid=1000</span><br><span class="line">geteuid=1000</span><br><span class="line">getgid=1000</span><br><span class="line">getegid=1000</span><br><span class="line">ttyname(0)=/dev/pts/15</span><br><span class="line"></span><br><span class="line">cur path [/]</span><br></pre></td></tr></table></figure><p>试验结果不论是fork一次还是两次，都可以打开新的控制台，这与网络上很多文章是相悖的，真相还需继续检验。运行结果中的报错”Unable to init server: Could not connect: Connection refused” 是因为我远程连接无法打开GUI。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>想实现后台守护进程，只需添加头文件 <code>#include &lt;unistd.h&gt;</code>，然后在调用 <code>daemon(1, 0)</code>函数即可</li><li><code>daemon</code> 的开源实现有很多种，早期很多说是fork两次，但是查了很多最新的版本都是fork一次</li><li>c/c++代码中打开控制台可以使用 <code>system(&quot;gnome-terminal -- /bin/bash -c &#39;date; exec bash&#39;&quot;);</code> 前提是可以正常打开用户界面的电脑，远程操作是不可以的</li></ul><center><a href="https://blog.csdn.net/albertsh/article/details/130395473" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>除了死亡，都是擦伤~</p><p>2023-5-12 22:38:40</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;daemon进程是后台守护进程，比如linux 下server都是daemon进程，像httpd、sshd等这些服务你肯定听说过，如果我们想写一个后台运行程序应该怎么做呢？其实非常容易，只要添加头文件 &lt;code&gt;#include &amp;lt;unistd.h&amp;gt;&lt;/code&gt;，然后在调用 &lt;code&gt;daemon(1, 0)&lt;/code&gt;函数即可。&lt;/p&gt;
    
    </summary>
    
      <category term="linux" scheme="http://AlbertGithubHome.github.io/blog/categories/linux/"/>
    
    
      <category term="linux" scheme="http://AlbertGithubHome.github.io/blog/tags/linux/"/>
    
      <category term="服务器" scheme="http://AlbertGithubHome.github.io/blog/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
      <category term="daemon" scheme="http://AlbertGithubHome.github.io/blog/tags/daemon/"/>
    
      <category term="gnome-terminal" scheme="http://AlbertGithubHome.github.io/blog/tags/gnome-terminal/"/>
    
  </entry>
  
  <entry>
    <title>linux下使用dd命令测试磁盘的读写速度</title>
    <link href="http://AlbertGithubHome.github.io/blog/2023/04/26/linux%E4%B8%8B%E4%BD%BF%E7%94%A8dd%E5%91%BD%E4%BB%A4%E6%B5%8B%E8%AF%95%E7%A3%81%E7%9B%98%E7%9A%84%E8%AF%BB%E5%86%99%E9%80%9F%E5%BA%A6/"/>
    <id>http://AlbertGithubHome.github.io/blog/2023/04/26/linux下使用dd命令测试磁盘的读写速度/</id>
    <published>2023-04-26T14:28:10.000Z</published>
    <updated>2023-06-18T07:31:13.931Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近打包更新总是特别慢，其中有一步使用<code>md5sum</code>命令计算MD5值的操作有时居然要卡一个小时，虽说计算MD5比较耗时，但通常计算5个G数据的md5值也就1分多钟，卡一个多小时有点说不过去了，所以在卡顿时使用 <code>top</code> 命令查看了进程情况，发现md5sum进程在卡顿时总是处于 <code>D</code> 状态，这个还是第一次遇到，所以查了些资料记录一下。</p><a id="more"></a><h1 id="D状态进程"><a href="#D状态进程" class="headerlink" title="D状态进程"></a>D状态进程</h1><p>D 状态进程(TASK_UNINTERRUPTIBLE)，处于不可中断的睡眠状态，指进程不响应异步信号。<br>绝大多数情况下，进程处在睡眠状态时，总是应该能够响应异步信号的。而D状态存在的意义就在于，内核的某些处理流程是不能被打断，比如进程调用read系统调用对某个设备文件进行读操作，一般需要使用D状态对进程进行保护，以避免进程与设备交互的过程被打断，造成设备陷入不可控的状态。这种情况下的D状态总是非常短暂的，通过ps命令基本上不可能捕捉到。</p><p><strong>但是我捉到了，在执行md5sum命令时经常捉到，D状态往往是由于 I/O 资源得不到满足，而引发等待~</strong></p><p>这是个关键点，既然IO得不到满足就查一下IO，计算md5也就从磁盘上读一些文件，所以怀疑问题出现在磁盘的读写上，进而想测一些磁盘的读写速度，这就用到了今天想说的 <code>dd</code> 命令。</p><h1 id="dd命令"><a href="#dd命令" class="headerlink" title="dd命令"></a>dd命令</h1><p>磁盘的读写速度需要通过实际读写文件来测试，<code>dd</code> 命令就可以完成这种测试，配合 <code>time</code> 命令可以统计命令执行时间</p><ul><li><p>仅测读取速度</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># time dd if=/tmp/test of=/dev/null bs=16k</span></span><br><span class="line">1000000+0 records <span class="keyword">in</span></span><br><span class="line">1000000+0 records out</span><br><span class="line">16384000000 bytes (16 GB) copied, 42.7044 s, 384 MB/s</span><br><span class="line"></span><br><span class="line">real    0m42.718s</span><br><span class="line">user    0m0.387s</span><br><span class="line">sys     0m8.951s</span><br></pre></td></tr></table></figure></li><li><p>仅测写入速度</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># time dd if=/dev/zero of=/tmp/test bs=16k count=1000000</span></span><br><span class="line">1000000+0 records <span class="keyword">in</span></span><br><span class="line">1000000+0 records out</span><br><span class="line">16384000000 bytes (16 GB) copied, 35.7006 s, 459 MB/s</span><br><span class="line"></span><br><span class="line">real    0m38.428s</span><br><span class="line">user    0m0.356s</span><br><span class="line">sys     0m12.608s</span><br></pre></td></tr></table></figure></li><li><p>测试读写速度</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># time dd if=/tmp/test of=/tmp/test2 bs=16k</span></span><br><span class="line">1000000+0 records <span class="keyword">in</span></span><br><span class="line">1000000+0 records out</span><br><span class="line">16384000000 bytes (16 GB) copied, 87.3214 s, 188 MB/s</span><br><span class="line"></span><br><span class="line">real    1m27.331s</span><br><span class="line">user    0m0.430s</span><br><span class="line">sys     0m15.799s</span><br></pre></td></tr></table></figure></li></ul><h1 id="问题原因"><a href="#问题原因" class="headerlink" title="问题原因"></a>问题原因</h1><p>最后测试发现硬盘读写速度不是很稳定，找运维沟通发现这台服务器使用的网络硬盘，存储带宽有限，当执行太多磁盘任务时，存储带宽会被占满，会造成硬盘读写缓慢，进而影响了之前提到的计算MD5的操作步骤，换了块本地硬盘就好了。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>进程显示D状态时处于不可中断的睡眠状态，往是由于 I/O 资源得不到满足而引发了等待</li><li>仅测试写入速度 <code>time dd if=/dev/zero of=/tmp/test bs=16k count=1000000</code></li><li>仅测试读取速度 <code>time dd if=/tmp/test of=/dev/null bs=16k</code></li><li>测试读写速度 <code>time dd if=/tmp/test of=/tmp/test2 bs=16k</code></li><li><code>/dev/zero</code> 是一个特殊的文件，当你读它的时候会得到无限的空字符，可用来初始化文件，不产生IO</li><li><code>/dev/null</code> 也是一个特殊的文件，它丢弃一切写入其中的数据，被称为黑洞，也不产生IO</li><li>网络硬盘受存储带宽的影响，一旦带宽被打满，硬盘读写速度也就慢了</li></ul><center><a href="https://blog.csdn.net/albertsh/article/details/130353739" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>好像遥不可及，但突然有那么一瞬间又感觉触手可及，貌似也没什么退路，只有往前冲了</p><p>2023-4-26 22:28:10</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;最近打包更新总是特别慢，其中有一步使用&lt;code&gt;md5sum&lt;/code&gt;命令计算MD5值的操作有时居然要卡一个小时，虽说计算MD5比较耗时，但通常计算5个G数据的md5值也就1分多钟，卡一个多小时有点说不过去了，所以在卡顿时使用 &lt;code&gt;top&lt;/code&gt; 命令查看了进程情况，发现md5sum进程在卡顿时总是处于 &lt;code&gt;D&lt;/code&gt; 状态，这个还是第一次遇到，所以查了些资料记录一下。&lt;/p&gt;
    
    </summary>
    
      <category term="linux" scheme="http://AlbertGithubHome.github.io/blog/categories/linux/"/>
    
    
      <category term="linux" scheme="http://AlbertGithubHome.github.io/blog/tags/linux/"/>
    
      <category term="运维" scheme="http://AlbertGithubHome.github.io/blog/tags/%E8%BF%90%E7%BB%B4/"/>
    
      <category term="服务器" scheme="http://AlbertGithubHome.github.io/blog/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
      <category term="硬盘读写" scheme="http://AlbertGithubHome.github.io/blog/tags/%E7%A1%AC%E7%9B%98%E8%AF%BB%E5%86%99/"/>
    
      <category term="dd" scheme="http://AlbertGithubHome.github.io/blog/tags/dd/"/>
    
  </entry>
  
  <entry>
    <title>Nginx返回静态的json字符串</title>
    <link href="http://AlbertGithubHome.github.io/blog/2023/04/24/Nginx%E8%BF%94%E5%9B%9E%E9%9D%99%E6%80%81%E7%9A%84json%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>http://AlbertGithubHome.github.io/blog/2023/04/24/Nginx返回静态的json字符串/</id>
    <published>2023-04-24T14:40:16.000Z</published>
    <updated>2023-06-18T07:31:25.107Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>自从上次安装完nginx我把服务器对外开发的端口都通过它来转发了，真香，最近要加一个获取最新版本号的功能，一开始还想写在服务器里，后来想想可不可以直接通过nginx配置呢？经过一番尝试果然是可以的，这样就不用单独编写代码来响应请求了，并且可以减少服务器资源占用，同时响应性能也非常快。</p><a id="more"></a><h1 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h1><p>还是在上次<a href="https://blog.csdn.net/albertsh/article/details/129543700" target="_blank" rel="noopener">《记录一下第一次安装和配置Nginx》</a>的配置文件 <code>project.conf</code>基础上改吧，修改下面这一段</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       4100;</span><br><span class="line">    server_name  localhost;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line"></span><br><span class="line">        proxy_pass http://login_entrance;</span><br><span class="line">        proxy_set_header Host $host;</span><br><span class="line">        proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="返回简单json字符串"><a href="#返回简单json字符串" class="headerlink" title="返回简单json字符串"></a>返回简单json字符串</h2><p>如果是简单的json字符串，可以直接写在配置文件中，比较方便：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">location /version/en &#123;</span><br><span class="line">    default_type application/json;</span><br><span class="line">    return 200 '&#123;"code":0,  "version":"1.6"&#125;';</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="返回json文件内容"><a href="#返回json文件内容" class="headerlink" title="返回json文件内容"></a>返回json文件内容</h2><p>如果json内容较多，，是无法完全放到配置中的，因为 <code>nginx</code> 的 <code>config buffer</code> 有4kb大小限制，这时就可以将json内容放到文件中：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">location /version/cn &#123;</span><br><span class="line">    default_type application/json;</span><br><span class="line">    alias /data/update/cn_version.json;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>综合到一起的配置文件就变成了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       4100;</span><br><span class="line">    server_name  localhost;</span><br><span class="line"></span><br><span class="line">    location /version/en &#123;</span><br><span class="line">        default_type application/json;</span><br><span class="line">        return 200 &apos;&#123;&quot;code&quot;:0,  &quot;version&quot;:&quot;1.6&quot;&#125;&apos;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location /version/cn &#123;</span><br><span class="line">        default_type application/json;</span><br><span class="line">        alias /data/update/cn_version.json;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line"></span><br><span class="line">        proxy_pass http://login_entrance;</span><br><span class="line">        proxy_set_header Host $host;</span><br><span class="line">        proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>通过nginx可以直接配置返回一些静态文本或json信息，这样不用写额外的处理逻辑，同时效率比较高</li><li>在返回json内容时如果数据比较多，可以保存到文件中直接在配置文件中引用文件名即可</li></ul><center><a href="https://blog.csdn.net/albertsh/article/details/130277612" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>好汉不提当年勇，如今落寞谁能懂，唯有鹤立鸡群中，任他必敬又必恭。</p><p>2023-4-24 22:40:16</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;自从上次安装完nginx我把服务器对外开发的端口都通过它来转发了，真香，最近要加一个获取最新版本号的功能，一开始还想写在服务器里，后来想想可不可以直接通过nginx配置呢？经过一番尝试果然是可以的，这样就不用单独编写代码来响应请求了，并且可以减少服务器资源占用，同时响应性能也非常快。&lt;/p&gt;
    
    </summary>
    
      <category term="Nginx" scheme="http://AlbertGithubHome.github.io/blog/categories/Nginx/"/>
    
    
      <category term="Nginx" scheme="http://AlbertGithubHome.github.io/blog/tags/Nginx/"/>
    
      <category term="配置文件" scheme="http://AlbertGithubHome.github.io/blog/tags/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/"/>
    
      <category term="json" scheme="http://AlbertGithubHome.github.io/blog/tags/json/"/>
    
      <category term="静态文本" scheme="http://AlbertGithubHome.github.io/blog/tags/%E9%9D%99%E6%80%81%E6%96%87%E6%9C%AC/"/>
    
  </entry>
  
  <entry>
    <title>SVN通过备份、过滤、再导入的方式彻底删除废弃目录</title>
    <link href="http://AlbertGithubHome.github.io/blog/2023/04/21/SVN%E9%80%9A%E8%BF%87%E5%A4%87%E4%BB%BD%E3%80%81%E8%BF%87%E6%BB%A4%E3%80%81%E5%86%8D%E5%AF%BC%E5%85%A5%E7%9A%84%E6%96%B9%E5%BC%8F%E5%BD%BB%E5%BA%95%E5%88%A0%E9%99%A4%E5%BA%9F%E5%BC%83%E7%9B%AE%E5%BD%95/"/>
    <id>http://AlbertGithubHome.github.io/blog/2023/04/21/SVN通过备份、过滤、再导入的方式彻底删除废弃目录/</id>
    <published>2023-04-21T13:56:28.000Z</published>
    <updated>2023-06-18T07:31:36.331Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>SVN占用的空间随着项目版本迭代越来越大，因为保存了历史记录中的各个版本，所以即使本地把废弃的目录删掉提交，也不会释放出多余的空间，大概率因为操作删除增加了一个版本号，使得占用的空间更大了。</p><a id="more"></a><p>怎么才能让它的空间变小的，最简单粗暴的方式就是丢弃历史记录，在最新的版本中剔除的废弃的目录直接上传创建一个新的仓库，这样操作后所有的人需要重新下载才行，如果想保留历史记录，就要用到今天说的这种备份、过滤、再导入的方式了。</p><h1 id="简要步骤"><a href="#简要步骤" class="headerlink" title="简要步骤"></a>简要步骤</h1><p>假设svn库A在服务器上的路径是：<code>/data/svndata/repos/A</code>，需要删除的文件路径为 <code>/arts/tmp/pictures</code>，注意要过滤的文件夹路径以 <code>/</code> 开头，其实代指起始目录 <code>A</code>。</p><p>操作的步骤如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//1.备份</span><br><span class="line">svnadmin dump /data/svndata/repos/A &gt; A.dump</span><br><span class="line"></span><br><span class="line">//2.过滤掉废弃目录</span><br><span class="line">cat A.dump | svndumpfilter exclude /arts/tmp/pictures &gt; B.dump</span><br><span class="line"></span><br><span class="line">//3.创建新的库</span><br><span class="line">svnadmin create /data/svndata/repos/B</span><br><span class="line"></span><br><span class="line">//4.导入新库</span><br><span class="line">svnadmin load /data/svndata/repos/B &lt; B.dump</span><br><span class="line"></span><br><span class="line">//5.重命名老库</span><br><span class="line">mv A A_backup</span><br><span class="line"></span><br><span class="line">//6.重命名新库代替老库</span><br><span class="line">mv B A</span><br></pre></td></tr></table></figure><h1 id="操作示例"><a href="#操作示例" class="headerlink" title="操作示例"></a>操作示例</h1><p>操作过程使用的是一个真实的SVN仓库，就是按照上面的步骤试了一次，主要想看下是不是传说中的那么耗时，仓库名为R，数据量115G，共10843个版本。</p><ul><li><p><strong>导出备份文件</strong></p>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># svnadmin dump/data/svndata/repos/R &gt; r.dump</span><br><span class="line">* Dumped revision 0.</span><br><span class="line">* Dumped revision 1.</span><br><span class="line">* Dumped revision 2.</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>   完整导出用了2小时40分钟，导出文件大小为514G，数据量翻了近5倍。</p></li><li><p><strong>过滤掉指定目录</strong></p>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># cat r.dump | svndumpfilter exclude /arts/tmp/pictures &gt; r-exclude.dump</span><br><span class="line">Excluding prefixes:</span><br><span class="line">   &apos;/arts/tmp/pictures&apos;</span><br><span class="line"></span><br><span class="line">Revision 0 committed as 0.</span><br><span class="line">Revision 1 committed as 1.</span><br><span class="line">Revision 2 committed as 2.</span><br><span class="line">Revision 3 committed as 3.</span><br><span class="line">Revision 4 committed as 4.</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p> 将/arts/tmp/pictures目录过滤掉，总共用时58分钟，过滤后的备份文件大小442G</p></li><li><p><strong>创建新的临时仓库</strong></p>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># svnadmin create r-new</span><br></pre></td></tr></table></figure></li><li><p><strong>将过滤后的备份文件导入新库</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># svnadmin load ./r-new &lt; r-exclude.dump</span><br><span class="line">&lt;&lt;&lt; Started new transaction, based on original revision 1</span><br><span class="line">     * editing path : arts ... done.</span><br><span class="line">     * editing path : develop ... done.</span><br><span class="line"></span><br><span class="line">------- Committed revision 1 &gt;&gt;&gt;</span><br><span class="line"></span><br><span class="line">&lt;&lt;&lt; Started new transaction, based on original revision 2</span><br><span class="line">     * editing path : develop/client ... done.</span><br><span class="line">     * editing path : develop/server ... done.</span><br><span class="line"></span><br><span class="line">------- Committed revision 2 &gt;&gt;&gt;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>  导入工作从第一个版本依次应用，总共用时4小时。</p></li></ul><p>这个过程真的是很慢，完整用时近8小时，并且对磁盘空间要求很大，另外还有个接近1万个版本号大小为800G的库，在24核机器上仅导出就花了41小时，备份文件大小4.5T，后面我就没试了，磁盘快满了。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>备份    <code>svnadmin dump /data/svndata/repos/A &gt; A.dump</code></li><li>过滤  <code>cat A.dump | svndumpfilter exclude /arts/tmp/pictures &gt; B.dump</code></li><li>建新  <code>svnadmin create /data/svndata/repos/B</code></li><li>导入  <code>svnadmin load /data/svndata/repos/B &lt; B.dump</code></li></ul><center><a href="https://blog.csdn.net/albertsh/article/details/130095406" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>朝气蓬勃的孩子真的可爱，可是我还是想长大，这样才有机会掌控节奏，虽然现在看起来像个提线木偶，但正在尝试突破束缚~</p><p>2023-4-21 21:56:28</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;SVN占用的空间随着项目版本迭代越来越大，因为保存了历史记录中的各个版本，所以即使本地把废弃的目录删掉提交，也不会释放出多余的空间，大概率因为操作删除增加了一个版本号，使得占用的空间更大了。&lt;/p&gt;
    
    </summary>
    
      <category term="SVN" scheme="http://AlbertGithubHome.github.io/blog/categories/SVN/"/>
    
    
      <category term="SVN" scheme="http://AlbertGithubHome.github.io/blog/tags/SVN/"/>
    
      <category term="备份" scheme="http://AlbertGithubHome.github.io/blog/tags/%E5%A4%87%E4%BB%BD/"/>
    
      <category term="运维" scheme="http://AlbertGithubHome.github.io/blog/tags/%E8%BF%90%E7%BB%B4/"/>
    
      <category term="服务器" scheme="http://AlbertGithubHome.github.io/blog/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
      <category term="数据清理" scheme="http://AlbertGithubHome.github.io/blog/tags/%E6%95%B0%E6%8D%AE%E6%B8%85%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>C++代码使用 gperftools 工具进行性能分析</title>
    <link href="http://AlbertGithubHome.github.io/blog/2023/04/19/C-%E4%BB%A3%E7%A0%81%E4%BD%BF%E7%94%A8-gperftools-%E5%B7%A5%E5%85%B7%E8%BF%9B%E8%A1%8C%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/"/>
    <id>http://AlbertGithubHome.github.io/blog/2023/04/19/C-代码使用-gperftools-工具进行性能分析/</id>
    <published>2023-04-19T15:22:53.000Z</published>
    <updated>2023-06-18T07:31:43.587Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>一直想用 <code>gperftools</code> 做一下性能方面的尝试，之前一直忙着开发，目前已经到了后期，忙里抽闲亲自操作一遍，从安装到分析做个简单的记录，以便后续拿来直接用。</p><a id="more"></a><h1 id="gperftools-是什么"><a href="#gperftools-是什么" class="headerlink" title="gperftools 是什么"></a>gperftools 是什么</h1><p><a href="https://github.com/gperftools/gperftools" target="_blank" rel="noopener">gperftools</a> 是Google开发的用来进行代码性能分析工具，其实他是一系列高性能多线程 malloc() 实现的集合，同时添加了一些精巧的性能分析工具。</p><p><img src="https://img-blog.csdnimg.cn/5cbaab098ea1428bb5d1c62c073dc1aa.png" alt="gperftools "></p><p>使用gperftools工具可以通过采样的方式生成上面这种图形化的代码性能分析结果，便于我们分析程序性能瓶颈。</p><h1 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h1><p>C++程序按照代码插桩的方式引入了gperftools工具，不过这个工具需要单独安装，为了生成图形化的分析结果，还需要安装一些依赖库，下面简述以下使用功能步骤。</p><h2 id="安装工具"><a href="#安装工具" class="headerlink" title="安装工具"></a>安装工具</h2><ol><li><p>安装编译所需基础软件</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install autoconf automake libtool</span><br></pre></td></tr></table></figure></li><li><p>安装graphviz，用于图形化显示分析结果</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install graphviz</span><br></pre></td></tr></table></figure></li><li><p>安装libunwind, 这个库提供了可用于分析程序调用栈的 API</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /tmp</span><br><span class="line">wget https://github.com/libunwind/libunwind/releases/download/v1.6.2/libunwind-1.6.2.tar.gz</span><br><span class="line">tar -zxvf libunwind-1.6.2.tar.gz</span><br><span class="line"><span class="built_in">cd</span> libunwind-1.6.2</span><br><span class="line">./configure</span><br><span class="line">make -j4</span><br><span class="line">sudo make install</span><br><span class="line"><span class="built_in">cd</span> /tmp</span><br><span class="line">rm -rf libunwind-1.6.2.tar.gz libunwind-1.6.2</span><br></pre></td></tr></table></figure></li><li><p>安装gperftools</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /tmp</span><br><span class="line">wget https://github.com/gperftools/gperftools/releases/download/gperftools-2.10/gperftools-2.10.tar.gz</span><br><span class="line">tar -zxvf gperftools-2.10.tar.gz</span><br><span class="line"><span class="built_in">cd</span> gperftools-2.10</span><br><span class="line">./configure</span><br><span class="line">make -j4</span><br><span class="line">sudo make install</span><br><span class="line"><span class="built_in">cd</span> ~</span><br><span class="line">rm -rf gperftools-2.10.tar.gz gperftools-2.10</span><br></pre></td></tr></table></figure></li><li><p>刷新动态装入程序所需的链接和缓存文件</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ldconfig</span><br></pre></td></tr></table></figure></li></ol><h2 id="代码插桩引入工具"><a href="#代码插桩引入工具" class="headerlink" title="代码插桩引入工具"></a>代码插桩引入工具</h2><h2 id="代码修改"><a href="#代码修改" class="headerlink" title="代码修改"></a>代码修改</h2><p>主要在源程序中引入头文件，并且在待测试逻辑前后添加启动分析和结束分析的语句就行了，对于服务类程序，因为要一直运行，可以通过<code>kill</code>信号通知来开启和关闭性能分析。</p><h3 id="关键代码"><a href="#关键代码" class="headerlink" title="关键代码"></a>关键代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;gperftools/profiler.h&gt; // 引入头文件</span></span></span><br><span class="line">...</span><br><span class="line">ProfilerStart(<span class="string">"cpp_demo.prof"</span>);  <span class="comment">// 启动分析</span></span><br><span class="line">...</span><br><span class="line">ProfilerStop();                  <span class="comment">// 结束分析</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="完整示例"><a href="#完整示例" class="headerlink" title="完整示例"></a>完整示例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;gperftools/profiler.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sig</span><span class="params">(<span class="keyword">int</span> sig)</span> <span class="comment">// kill -10 pid to trigger</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">bool</span> b = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (!b)</span><br><span class="line">        ProfilerStart(<span class="string">"cpp_demo.prof"</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        ProfilerStop();</span><br><span class="line"></span><br><span class="line">    b= !b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    signal(SIGUSR1, sig);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::this_thread::sleep_for(<span class="built_in">std</span>::chrono::milliseconds(<span class="number">1</span>));</span><br><span class="line">        <span class="comment">//..</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::chrono::duration_cast&lt;<span class="built_in">std</span>::chrono::milliseconds&gt;(</span><br><span class="line">                <span class="built_in">std</span>::chrono::system_clock::now().time_since_epoch()).count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="编译链接"><a href="#编译链接" class="headerlink" title="编译链接"></a>编译链接</h3><p>编译时我们需要将 <code>profiler</code> 库和 <code>libunwind</code> 库链接到可执行程序，如果使用 <code>cmake</code>来构建，那么 CMakeLists 文件中的语句为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">target_link_libraries($&#123;PROJECT_NAME&#125; profiler unwind)</span><br></pre></td></tr></table></figure><h3 id="启动分析程序"><a href="#启动分析程序" class="headerlink" title="启动分析程序"></a>启动分析程序</h3><ol><li><p>正常启动游戏服务器，通过ps命令查找到要分析的进程id，比如查找到demoserver的进程是 <code>7217</code></p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ps -ef | grep demoserver</span><br><span class="line">demo        7217       1 22 21:51 ?        00:00:18 ./demoserver-d</span><br></pre></td></tr></table></figure></li><li><p>通过kill命令传递自定义信号<code>10</code>的方式启动和关闭分析程序，第一次运行命令是启动，第二次运行相同的命令是关闭，两次命令之间是分析的时间段</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kill -10 7217</span><br></pre></td></tr></table></figure></li><li><p>关闭分析程序之后，会在可执行程序所在目录生成 <code>cpp_demo.porf</code> 文件，可以使用下面命令将结果图形化</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ pprof --pdf demoserver cpp_demo.prof &gt; demoserver.pdf</span><br><span class="line">Using local file demoserver.</span><br><span class="line">Using local file cpp_demo.prof.</span><br><span class="line">Dropping nodes with &lt;= 1 samples; edges with &lt;= 0 abs(samples)</span><br></pre></td></tr></table></figure></li><li><p>最终生成的 <code>demoserver.pdf</code> 文件就是我们要用的分析结果，如文章开头所示。</p></li></ol><h1 id="数据分析"><a href="#数据分析" class="headerlink" title="数据分析"></a>数据分析</h1><p>上面提到了生成pdf图，其实可以生成txt文本的，只要修改生成选项就可以，比如像这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># pprof --text demoserver cpp_demo.prof</span><br><span class="line">Using local file demoserver.</span><br><span class="line">Using local file cpp_demo.prof.</span><br><span class="line">Total: 13 samples</span><br><span class="line">       3  21.4%  21.4%        3  21.4% SpinLock::Unlock (inline)</span><br><span class="line">       3  21.4%  42.9%        3  21.4% __GI_madvise</span><br><span class="line">       2  14.3%  57.1%        2  14.3% SpinLock::Lock (inline)</span><br><span class="line">       1   7.1%  64.3%        1   7.1% TCMalloc_PageMap2::get (inline)</span><br><span class="line">       ...</span><br></pre></td></tr></table></figure><p>上述文本数据每行包含6列数据，依次为:</p><ol><li>分析样本数量（不包含其他函数调用）</li><li>分析样本百分比（不包含其他函数调用）</li><li>目前为止的分析样本百分比（不包含其他函数调用）</li><li>分析样本数量（包含其他函数调用）</li><li>分析样本百分比（包含其他函数调用）</li><li>函数名(或者类名+方法名)</li></ol><p>样本数量相当于消耗的CPU时间，整个函数消耗的CPU时间相当于包括函数内部其他函数调用所消耗的CPU时间，如果是分析最上面的pdf图，每个节点代表一个函数，包含2~3行数据：</p><ol><li>函数名(或者类名+方法名)</li><li>不包含内部函数调用的样本数 (百分比)</li><li>of 包含内部函数调用的样本数 (百分比)  #如果没有内部调用函数则不显示<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1></li></ol><ul><li><code>gperftools</code> 是可以通过采样的方式进行代码性能分析工具，可生成图形化结果便于我们分析程序性能瓶颈</li><li>待分析程序中引入<code>gperftools</code>非常方便，但是需要单独安装这个工具</li><li>程序引入时只需要添加头文件，在目标位置插入 <code>ProfilerStart(&quot;cpp_demo.prof&quot;);</code> 和 <code>ProfilerStop();</code> 语句即可</li><li>对于服务类程序通常不会直接结束，可以通过 <code>kill</code> 命令传递信号的方式来启动和关闭分析程序</li></ul><center><a href="https://blog.csdn.net/albertsh/article/details/129964056" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>可能终于有一天  刚好遇见爱情<br>可能永远在路上  有人奋斗前行<br>可能一切的可能  相信才有可能<br>可能拥有过梦想  才能叫做青春</p><p>2023-4-19 23:22:53</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;一直想用 &lt;code&gt;gperftools&lt;/code&gt; 做一下性能方面的尝试，之前一直忙着开发，目前已经到了后期，忙里抽闲亲自操作一遍，从安装到分析做个简单的记录，以便后续拿来直接用。&lt;/p&gt;
    
    </summary>
    
      <category term="C/C++" scheme="http://AlbertGithubHome.github.io/blog/categories/C-C/"/>
    
    
      <category term="C/C++" scheme="http://AlbertGithubHome.github.io/blog/tags/C-C/"/>
    
      <category term="服务器调优" scheme="http://AlbertGithubHome.github.io/blog/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%B0%83%E4%BC%98/"/>
    
      <category term="linux" scheme="http://AlbertGithubHome.github.io/blog/tags/linux/"/>
    
      <category term="gperftools" scheme="http://AlbertGithubHome.github.io/blog/tags/gperftools/"/>
    
  </entry>
  
  <entry>
    <title>linux环境下查看因内存占用过大被杀掉的进程</title>
    <link href="http://AlbertGithubHome.github.io/blog/2023/04/04/linux%E7%8E%AF%E5%A2%83%E4%B8%8B%E6%9F%A5%E7%9C%8B%E5%9B%A0%E5%86%85%E5%AD%98%E5%8D%A0%E7%94%A8%E8%BF%87%E5%A4%A7%E8%A2%AB%E6%9D%80%E6%8E%89%E7%9A%84%E8%BF%9B%E7%A8%8B/"/>
    <id>http://AlbertGithubHome.github.io/blog/2023/04/04/linux环境下查看因内存占用过大被杀掉的进程/</id>
    <published>2023-04-04T15:31:40.000Z</published>
    <updated>2023-06-18T07:26:48.362Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近发生两次游戏服务器进程突然消失的事件，查询日志上下文没有找到有用的信息，日志显示运行到某处戛然而止，此处代码逻辑简单，排除异常逻辑导致的服务器进程崩溃，所以联想到之前同一台服务器上部署多个进程，因占用内存太大被内核杀死的情况，猜测本次也是这个原因。</p><a id="more"></a><h1 id="查询方法"><a href="#查询方法" class="headerlink" title="查询方法"></a>查询方法</h1><p>通过搜索引擎找到了两种查询方法，一种是直接过滤系统日志，一种是借助 <code>dmesg</code> 命令，备注以下命令在 <code>CentOS 7</code> 上测试通过</p><h2 id="通过系统日志查找"><a href="#通过系统日志查找" class="headerlink" title="通过系统日志查找"></a>通过系统日志查找</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@demo]<span class="comment"># grep "Out of memory" /var/log/messages</span></span><br><span class="line">Apr  4 10:32:30 hk-dev kernel: Out of memory: Kill process 2434 (Game9) score 212 or sacrifice child</span><br><span class="line">Apr  4 10:33:53 hk-dev kernel: Out of memory: Kill process 2476 (git) score 381 or sacrifice child</span><br><span class="line">Apr  4 10:33:53 hk-dev kernel: Out of memory: Kill process 2777 (git) score 381 or sacrifice child</span><br></pre></td></tr></table></figure><h2 id="通过dmesg命令查找"><a href="#通过dmesg命令查找" class="headerlink" title="通过dmesg命令查找"></a>通过dmesg命令查找</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@demo]<span class="meta"># dmesg -T | grep <span class="meta-string">"Out of memory"</span></span></span><br><span class="line">[Mon Aug <span class="number">30</span> <span class="number">12</span>:<span class="number">06</span>:<span class="number">25</span> <span class="number">2021</span>] Out of memory: Kill process <span class="number">22437</span> (git) score <span class="number">400</span> <span class="keyword">or</span> sacrifice child</span><br><span class="line">[Wed Sep <span class="number">22</span> <span class="number">20</span>:<span class="number">23</span>:<span class="number">52</span> <span class="number">2021</span>] Out of memory: Kill process <span class="number">29780</span> (Game6) score <span class="number">161</span> <span class="keyword">or</span> sacrifice child</span><br><span class="line">[Wed Mar <span class="number">29</span> <span class="number">15</span>:<span class="number">54</span>:<span class="number">31</span> <span class="number">2023</span>] Out of memory: Kill process <span class="number">29093</span> (git) score <span class="number">388</span> <span class="keyword">or</span> sacrifice child</span><br><span class="line">[Tue Apr  <span class="number">4</span> <span class="number">10</span>:<span class="number">24</span>:<span class="number">05</span> <span class="number">2023</span>] Out of memory: Kill process <span class="number">2434</span> (Game9) score <span class="number">212</span> <span class="keyword">or</span> sacrifice child</span><br><span class="line">[Tue Apr  <span class="number">4</span> <span class="number">10</span>:<span class="number">25</span>:<span class="number">29</span> <span class="number">2023</span>] Out of memory: Kill process <span class="number">2476</span> (git) score <span class="number">381</span> <span class="keyword">or</span> sacrifice child</span><br></pre></td></tr></table></figure><h1 id="进程被杀的原因"><a href="#进程被杀的原因" class="headerlink" title="进程被杀的原因"></a>进程被杀的原因</h1><p>Linux 内核有个机制叫OOM killer，全称为 Out Of Memory killer，很形象的一个名字——内存溢出杀手，这个机制会监控那些占用内存过大，尤其是瞬间占用内存很快的进程，为防止机器内存耗尽而主动把该进程杀掉。</p><p>当内核检测到系统内存不足、挑选并杀掉某个进程的过程可以参考内核源代码 <code>linux/mm/oom_kill.c</code>（2023-4-4 23:24:07确认了此文件存在），当系统内存不足的时候，<code>out_of_memory()</code> 函数被触发，然后调用 <code>select_bad_process()</code> 函数选择一个进程杀掉，这个选择的过程是通过调用 <code>oom_badness()</code> 函数实现的，挑选的算法和想法都暴力但朴实：就是找到最占用内存的进程。</p><p>源码如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * oom_badness - heuristic function to determine which candidate task to kill</span></span><br><span class="line"><span class="comment"> * @p: task struct of which task we should calculate</span></span><br><span class="line"><span class="comment"> * @totalpages: total present RAM allowed for page allocation</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The heuristic for determining which task to kill is made to be as simple and</span></span><br><span class="line"><span class="comment"> * predictable as possible.  The goal is to return the highest value for the</span></span><br><span class="line"><span class="comment"> * task consuming the most memory to avoid subsequent oom failures.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">oom_badness</span><span class="params">(struct task_struct *p, <span class="keyword">unsigned</span> <span class="keyword">long</span> totalpages)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> points;</span><br><span class="line">    <span class="keyword">long</span> adj;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (oom_unkillable_task(p))</span><br><span class="line">        <span class="keyword">return</span> LONG_MIN;</span><br><span class="line"></span><br><span class="line">    p = find_lock_task_mm(p);</span><br><span class="line">    <span class="keyword">if</span> (!p)</span><br><span class="line">        <span class="keyword">return</span> LONG_MIN;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Do not even consider tasks which are explicitly marked oom</span></span><br><span class="line"><span class="comment">     * unkillable or have been already oom reaped or the are in</span></span><br><span class="line"><span class="comment">     * the middle of vfork</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    adj = (<span class="keyword">long</span>)p-&gt;signal-&gt;oom_score_adj;</span><br><span class="line">    <span class="keyword">if</span> (adj == OOM_SCORE_ADJ_MIN ||</span><br><span class="line">            test_bit(MMF_OOM_SKIP, &amp;p-&gt;mm-&gt;flags) ||</span><br><span class="line">            in_vfork(p)) &#123;</span><br><span class="line">        task_unlock(p);</span><br><span class="line">        <span class="keyword">return</span> LONG_MIN;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * The baseline for the badness score is the proportion of RAM that each</span></span><br><span class="line"><span class="comment">     * task's rss, pagetable and swap space use.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    points = get_mm_rss(p-&gt;mm) + get_mm_counter(p-&gt;mm, MM_SWAPENTS) +</span><br><span class="line">        mm_pgtables_bytes(p-&gt;mm) / PAGE_SIZE;</span><br><span class="line">    task_unlock(p);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Normalize to oom_score_adj units */</span></span><br><span class="line">    adj *= totalpages / <span class="number">1000</span>;</span><br><span class="line">    points += adj;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> points;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>如果你发现运行了一段时间的进程突然不见了，那可能是内核嫉妒生恨把它给干掉了</li><li>查询内存溢出被杀掉的进程可以直接通过系统日志来查 <code>grep &quot;Out of memory&quot; /var/log/messages</code></li><li>也可以通过专门的命令查找 <code>dmesg -T | grep &quot;Out of memory&quot;</code></li><li>刚刚看了linus 的 <code>linux</code> 代码库，昨天还在提交，真的是更新无止境</li></ul><center><a href="https://blog.csdn.net/albertsh/article/details/129941568" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>做人一辈子 快乐没几天<br>一条大路分两边 随你要走哪一边<br>不怕不怕就不怕 我是年轻人<br>风大雨大太阳大 我就是敢打拼</p><p>2023-4-4 23:31:40</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;最近发生两次游戏服务器进程突然消失的事件，查询日志上下文没有找到有用的信息，日志显示运行到某处戛然而止，此处代码逻辑简单，排除异常逻辑导致的服务器进程崩溃，所以联想到之前同一台服务器上部署多个进程，因占用内存太大被内核杀死的情况，猜测本次也是这个原因。&lt;/p&gt;
    
    </summary>
    
      <category term="linux" scheme="http://AlbertGithubHome.github.io/blog/categories/linux/"/>
    
    
      <category term="linux" scheme="http://AlbertGithubHome.github.io/blog/tags/linux/"/>
    
      <category term="服务器" scheme="http://AlbertGithubHome.github.io/blog/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
      <category term="dmesg" scheme="http://AlbertGithubHome.github.io/blog/tags/dmesg/"/>
    
      <category term="oom" scheme="http://AlbertGithubHome.github.io/blog/tags/oom/"/>
    
      <category term="centos" scheme="http://AlbertGithubHome.github.io/blog/tags/centos/"/>
    
  </entry>
  
  <entry>
    <title>简单谈谈图形界面和命令行的区别</title>
    <link href="http://AlbertGithubHome.github.io/blog/2023/04/03/%E7%AE%80%E5%8D%95%E8%B0%88%E8%B0%88%E5%9B%BE%E5%BD%A2%E7%95%8C%E9%9D%A2%E5%92%8C%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://AlbertGithubHome.github.io/blog/2023/04/03/简单谈谈图形界面和命令行的区别/</id>
    <published>2023-04-03T14:31:29.000Z</published>
    <updated>2023-06-18T07:32:12.898Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>随着总结的文章越写越多，我发现自己是一个“追求完美”的人，但同时也是一个“虎头蛇尾”的人，这两者看起来冲突，却可以融于一身。去写一个问题是总想从三皇五帝时写起，总想把各个分支情况都写清楚，这就会创造一个“虎头”，但写着写着就发现时间不允许了，或者已经触及了自己的知识边界，最后不得不退化成了“蛇尾”。</p><a id="more"></a><p>这对于总结和传播知识是不合适的，对于知识的总结应该做到详略得当，这一点上我还有很大的提升空间，推荐一本这方面做的比较好的书籍《图解HTTP》，这本书从始至终让人感觉到很丰满，没有哪一部分让人感觉是凑数的，特别的讲到电信号在同轴电缆中的传播，给人一种知识体系非常完整的体验。</p><p>言归正传，今天我要谈谈图形用户界面和命令行的区别，工作久了以后总会有点自己的心得，灵光一闪时就想记录下来，算是给今后的自己保存一点点瞬时的记忆，今天就不从三皇五帝开始讲了，我们从计算机的诞生开始说起。</p><p>世界世界上第一台电子计算机 <code>ENIAC</code>，是一个占地170平方米，重达30吨的庞然大物，慢慢的计算机的体积越来越小，但主要用于特定领域，并未进入寻常人家，此阶段的计算机多用于完成特定任务，也就是输入指令完成任务，我们看到的更多的是黑框框，后来随着windows系统（当然苹果系统也出现了）的普及，鼠标点点点极大的降低了入门的难度，也使得图形用于界面深入人心。</p><p>关于Windows内置的四款游戏据说每一款都有其特殊的目的与作用，纸牌希望让用户熟悉拖动和释放鼠标；扫雷是为了训练用户使用鼠标进行精准的点击，并掌握左键与右键的区别；红心大战是为了鼓励用户使用互联网与其他玩家交流；空当接龙是为了测试32位的数据处理子系统是否正确安装。这些游戏的出现让人们快速适应了图形用户界面，甚至这是他们接触电脑的第一印象，可能他们并不懂得什么是命令行。</p><h1 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h1><p>图形用户界面和命令行不能说哪一种更好，只能说哪一种更合适，一些情况下图形界面会给你更直观的感受，一些情况下命令行可以代替重复性的操作。</p><h2 id="图形用户界面"><a href="#图形用户界面" class="headerlink" title="图形用户界面"></a>图形用户界面</h2><p>图形用户界面，简称GUI，现在绝大多数的用户面对的都是图形界面，而传统意义上的命令行总被看成是上世纪的东西，图形界面首先看起来很直观，就像给你一堆散列的数据很难看出关系，但是如果画一个折线图，立马就能看出数据的走向。</p><h2 id="命令行"><a href="#命令行" class="headerlink" title="命令行"></a>命令行</h2><p>它的门槛要高一些，虽然使用起来不如图形界面清晰，但是在一些自动化程序中，命令行可以简化操作，省去了点点点的麻烦操作</p><h2 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h2><p>我们以git为例，他在被Linus发明出来的时候肯定只有命令行，但是后来git的图形界面工具多到数不清，一个又一个方便的软件被创造出来，但是git命令行一直没有消失，而且我每天都在用，是因为我不会用图形界面吗？当然不是，因为在我使用的大部分需求中，我只要敲一两个命令就可以完成了，不必拿起鼠标右键菜单再去等几秒中的界面刷新。</p><p>还有一方面我需要经常编写自动化脚本，使用Jenkins部署服务器程序，这些环境下是没办法使用图形界面的，只能用命令行还编写逻辑。</p><h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><h3 id="图形界面"><a href="#图形界面" class="headerlink" title="图形界面"></a>图形界面</h3><p>适用于需要直观显示的情景，以及需要根据显示结果反复调整输入的情景，比如过滤commit，我可以在界面上不断调整和尝试过滤的关键词，而结果会随着我的调整发生改变。</p><h3 id="命令行-1"><a href="#命令行-1" class="headerlink" title="命令行"></a>命令行</h3><p>适用于简单命令和机械化的操作，最好是那种写完一遍可以用一辈子的逻辑，如果是类似过滤commit这种需求，我们必须不断的重新输入命令参数，也就是说命令行在我输入命令之后他的参数都确定了，绝大多数不能再调节了。</p><h3 id="总有例外"><a href="#总有例外" class="headerlink" title="总有例外"></a>总有例外</h3><p>命令行的参数输入之后真的不能调吗？大多数是这样的，但总有例外，这种例外要求命令结果处于定时刷新状态，比如 <code>top</code> 命令，因为它的结果是可以刷新的，所以当你按下键盘上的 <code>c</code> 、<code>P</code> 等按键时，输出结果是会发生变化的。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>图形界面和命令行两者没有更好，只有更合适</li><li>图形界面适用于直观显示需求，可以根据用户输入随时调整输出结果</li><li>命令行更适用于自动化场景，可以将指令编写到操作逻辑中，通常来说更加高效</li></ul><center><a href="https://blog.csdn.net/albertsh/article/details/129698728" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>发现了一种我称之为反围城的状态：外面的人不想进去，里面的人不想出来~</p><p>2023-4-3 22:31:29</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;随着总结的文章越写越多，我发现自己是一个“追求完美”的人，但同时也是一个“虎头蛇尾”的人，这两者看起来冲突，却可以融于一身。去写一个问题是总想从三皇五帝时写起，总想把各个分支情况都写清楚，这就会创造一个“虎头”，但写着写着就发现时间不允许了，或者已经触及了自己的知识边界，最后不得不退化成了“蛇尾”。&lt;/p&gt;
    
    </summary>
    
      <category term="Thinking" scheme="http://AlbertGithubHome.github.io/blog/categories/Thinking/"/>
    
    
      <category term="git" scheme="http://AlbertGithubHome.github.io/blog/tags/git/"/>
    
      <category term="图形用户界面" scheme="http://AlbertGithubHome.github.io/blog/tags/%E5%9B%BE%E5%BD%A2%E7%94%A8%E6%88%B7%E7%95%8C%E9%9D%A2/"/>
    
      <category term="命令行" scheme="http://AlbertGithubHome.github.io/blog/tags/%E5%91%BD%E4%BB%A4%E8%A1%8C/"/>
    
  </entry>
  
  <entry>
    <title>CentOS7通过rpm包离线安装git</title>
    <link href="http://AlbertGithubHome.github.io/blog/2023/03/21/CentOS7%E9%80%9A%E8%BF%87rpm%E5%8C%85%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85git/"/>
    <id>http://AlbertGithubHome.github.io/blog/2023/03/21/CentOS7通过rpm包离线安装git/</id>
    <published>2023-03-21T15:11:12.000Z</published>
    <updated>2023-06-18T07:37:52.709Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>如果能连接外网，谁甘愿在离线状态下折腾，重新安装git的起因是服务器上的git版本(1.8.3.1)过低，Mac客户端升级后git版本(2.40.0)太高，导致无法验证密钥来进行拉取操作，所以要把服务器上的git升级一下，而git的1.8.3.1版本貌似是CentOS7的默认版本，我在多篇文章中看到了这个版本号，本来以为分分钟搞定，结果的折腾到半夜。</p><a id="more"></a><h1 id="初次安装失败"><a href="#初次安装失败" class="headerlink" title="初次安装失败"></a>初次安装失败</h1><p>开始觉得挺顺利的，如果能升级就直接升级，不能升级就直接移除掉然后安装就行了，然后我就直接通过 <code>sudo yum remove git</code> 删除了git，刷的一下很快啊。</p><p>据说在 CentOS 7 上安装新版本 git 最快的方法是通过 End Point 库，所以我跟着找到的教程输入下面的命令企图添加 “End Point Package Repository”，但是报错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum install https://packages.endpointdev.com/rhel/7/os/x86_64/endpoint-repo.x86_64.rpm</span><br><span class="line">yum install git</span><br></pre></td></tr></table></figure><p>官网 <a href="https://packages.endpointdev.com/" target="_blank" rel="noopener">packages.endpointdev.com/</a>有专门讲解安装git 2.x的<a href="https://www.endpointdev.com/blog/2021/12/installing-git-2-on-centos-7/" target="_blank" rel="noopener">帖子</a>，看起来很轻松，但是这条路我可能走不通了</p><p>我这里提示 “curl:(6) Could resolve host: packages.endpointdev.com; Unknown error”，我的天，难道这台机器不能访问外网？</p><h1 id="尝试修改软件源"><a href="#尝试修改软件源" class="headerlink" title="尝试修改软件源"></a>尝试修改软件源</h1><p>然后我尝试ping了几个常见的域名均已失败告终，所以我只能离线安装了？后来我发现它不是不能访问外网，只是不能访问域名，所以我自作聪明的把软件源<code>/etc/yum.repos.d/CentOS-Base.repo</code>里的域名都改成了IP:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#mirrors.cloud.aliyuncs.com被我改成了100.100.2.148</span></span><br><span class="line"></span><br><span class="line">enabled=1</span><br><span class="line">failovermethod=priority</span><br><span class="line">baseurl=http://mirrors.cloud.aliyuncs.com/centos/<span class="variable">$releasever</span>/os/<span class="variable">$basearch</span>/</span><br><span class="line">gpgcheck=1</span><br><span class="line">gpgkey=http://mirrors.cloud.aliyuncs.com/centos/RPM-GPG-KEY-CentOS-7</span><br><span class="line"></span><br><span class="line">[updates]</span><br><span class="line">name=CentOS-<span class="variable">$releasever</span></span><br><span class="line">enabled=1</span><br><span class="line">failovermethod=priority</span><br><span class="line">baseurl=http://mirrors.cloud.aliyuncs.com/centos/<span class="variable">$releasever</span>/updates/<span class="variable">$basearch</span>/</span><br><span class="line">gpgcheck=1</span><br><span class="line">gpgkey=http://mirrors.cloud.aliyuncs.com/centos/RPM-GPG-KEY-CentOS-7</span><br><span class="line"></span><br><span class="line">[extras]</span><br><span class="line">name=CentOS-<span class="variable">$releasever</span></span><br><span class="line">enabled=1</span><br><span class="line">failovermethod=priority</span><br><span class="line">baseurl=http://mirrors.cloud.aliyuncs.com/centos/<span class="variable">$releasever</span>/extras/<span class="variable">$basearch</span>/</span><br><span class="line">gpgcheck=1</span><br><span class="line">gpgkey=http://mirrors.cloud.aliyuncs.com/centos/RPM-GPG-KEY-CentOS-7</span><br></pre></td></tr></table></figure><p>接着我就发现这样是无法使用的，这个域名的IP一直在变，然后我又找了公司内部的软件源直接把IP替换上去，发现访问超时，看来得解决无法解析域名的问题，后来查到的修改 <code>/etc/resolv.conf</code>，于是在文件中添加一下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nameserver 114.114.114.114</span><br><span class="line">nameserver 8.8.8.8</span><br></pre></td></tr></table></figure><p>保存之后可以解析域名了，将软件源修改为域名的形式依旧访问超时，这条路彻底走不通了。</p><h2 id="离线安装git"><a href="#离线安装git" class="headerlink" title="离线安装git"></a>离线安装git</h2><p>离线安装类似于Window上安装一个<code>.msi</code>文件，不过git貌似没有特别方便的安装包，看看Linux下这些安装方式，基本都是需要联网下载的，其中CentOS还是最麻烦的，需要编译安装。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">Debian/Ubuntu</span><br><span class="line">For the latest stable version <span class="keyword">for</span> your release of Debian/Ubuntu</span><br><span class="line"></span><br><span class="line"><span class="meta"># apt-get install git</span></span><br><span class="line">For Ubuntu, <span class="keyword">this</span> PPA provides the latest stable upstream Git version</span><br><span class="line"></span><br><span class="line"><span class="meta"># add-apt-repository ppa:git-core/ppa # apt update; apt install git</span></span><br><span class="line">Fedora</span><br><span class="line"><span class="meta"># yum install git (up to Fedora 21)</span></span><br><span class="line"><span class="meta"># dnf install git (Fedora 22 and later)</span></span><br><span class="line">Gentoo</span><br><span class="line"><span class="meta"># emerge --ask --verbose dev-vcs/git</span></span><br><span class="line">Arch Linux</span><br><span class="line"><span class="meta"># pacman -S git</span></span><br><span class="line">openSUSE</span><br><span class="line"><span class="meta"># zypper install git</span></span><br><span class="line">Mageia</span><br><span class="line"><span class="meta"># urpmi git</span></span><br><span class="line">Nix/NixOS</span><br><span class="line"><span class="meta"># nix-env -i git</span></span><br><span class="line">FreeBSD</span><br><span class="line"><span class="meta"># pkg install git</span></span><br><span class="line">Solaris <span class="number">9</span>/<span class="number">10</span>/<span class="number">11</span> (OpenCSW)</span><br><span class="line"><span class="meta"># pkgutil -i git</span></span><br><span class="line">Solaris <span class="number">11</span> Express</span><br><span class="line"><span class="meta"># pkg install developer/versioning/git</span></span><br><span class="line">OpenBSD</span><br><span class="line"># pkg_add git</span><br><span class="line">Alpine</span><br><span class="line">$ apk add git</span><br><span class="line">Red Hat Enterprise Linux, Oracle Linux, CentOS, Scientific Linux, et al.</span><br><span class="line">RHEL <span class="keyword">and</span> derivatives typically ship older versions of git. You can download a tarball <span class="keyword">and</span> build from source, <span class="keyword">or</span> use a <span class="number">3</span>rd-party repository such as the IUS Community Project to obtain a more recent version of git.</span><br><span class="line"></span><br><span class="line">Slitaz</span><br><span class="line">$ tazpkg get-install git</span><br></pre></td></tr></table></figure><p>但是编译git需要有依赖项，还好它依赖的不多，很多教程上来就装一堆，不管有用没有了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y zlib-devel bzip2-devel openssl-devel ncurses-devel gcc perl-ExtUtils-MakeMaker package</span><br></pre></td></tr></table></figure><p>但是我的机器上 <code>yum</code> 命令已经废了，无法联网安装新的东西，所以这些依赖项我必须找到安装包来离线安装，这就要用到rpm包了。</p><h2 id="什么是rpm"><a href="#什么是rpm" class="headerlink" title="什么是rpm"></a>什么是rpm</h2><p><code>rpm</code>（redhat package manager） 原本是 Red Hat Linux 发行版专门用来管理 Linux 各项套件的程序，由于它遵循 GPL 规则且功能强大方便，因而广受欢迎，逐渐受到其他发行版的采用。RPM 套件管理方式的出现，让 Linux 上的软件易于安装和升级，说白了就是可以通过它来安装软件包。</p><p>RPM包里面包含可执行的二进制程序，还包括程序运行时所需要的文件有时除了自身所带的附加文件保证其正常以外，还需要其它特定版本文件，这就是软件包的依赖关系，这和Windows的软件包结构类似。</p><h2 id="安装准备"><a href="#安装准备" class="headerlink" title="安装准备"></a>安装准备</h2><ul><li>下载指定版本git源码 <a href="https://github.com/git/git/tags" target="_blank" rel="noopener">source code</a></li><li>下载zlib-devel-1.2.7-15.el7.x86_64.rpm <a href="http://mirror.centos.org/centos/7/os/x86_64/Packages/" target="_blank" rel="noopener">RPM库</a></li><li>机器上本来有gcc，如果没有自己想办法装吧<!-- https://zhuanlan.zhihu.com/p/352955774 --></li></ul><p>幸运的是我的机器上有gcc，并且经过实践发现只要成功安装了zlib-devel就可以完成git的编译，如果没安装会报编译错误：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cache.h:<span class="number">21</span>:<span class="number">18</span>: fatal error: zlib.h: No such file <span class="keyword">or</span> directory</span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;zlib.h&gt;</span></span></span><br><span class="line">                  ^</span><br><span class="line">compilation terminated.</span><br><span class="line">make: *** [fuzz-commit-graph.o] Error <span class="number">1</span></span><br></pre></td></tr></table></figure><p>在有网的情况下，CentOS使用 <code>yum install zlib-devel</code>  解决，Ubuntu安装 <code>apt-get install zlib1g-dev</code> 解决</p><h2 id="安装zlib-devel"><a href="#安装zlib-devel" class="headerlink" title="安装zlib-devel"></a>安装zlib-devel</h2><p>如果版本正确通过rpm安装还是挺快的，但是我一开始下载了另一个版本 zlib-devel-1.2.7-18.el7.x86_64.rpm，安装时提示我：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@demo software]<span class="comment"># rpm -i zlib-devel-1.2.7-18.el7.x86_64.rpm</span></span><br><span class="line">error: Failed dependencies:</span><br><span class="line">        zlib = 1.2.7-18.el7 is needed by zlib-devel-1.2.7-18.el7.x86_64</span><br></pre></td></tr></table></figure><p>我又去下载了 zlib-1.2.7-18.el7.x86_64.rpm ，结果安装时出现冲突：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@demo software]<span class="comment"># rpm -i zlib-1.2.7-18.el7.x86_64.rpm</span></span><br><span class="line">        file /usr/lib64/libz.so.1.2.7 from install of zlib-1.2.7-18.el7.x86_64 conflicts with file from package zlib-1.2.7-15.el7.x86_64</span><br></pre></td></tr></table></figure><p>最后找了兼容的版本 <code>rpm -i zlib-devel-1.2.7-15.el7.x86_64.rpm</code> 解决了这个问题。</p><h2 id="编译git"><a href="#编译git" class="headerlink" title="编译git"></a>编译git</h2><ul><li>解压git源码 <code>tar -zxf git-2.28.0.tar.gz</code></li><li>进入解压后的目录，执行安装前检查 <code>make configure</code></li><li>指定安装目录 <code>./configure --prefix=/usr/local</code></li><li>执行编译安装 <code>make install</code></li><li>查看git版本 <code>git --version</code></li></ul><p>终于装完了，呼~</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>服务端和客户端的git版本差距过大时可能导致无法验证密钥的问题</li><li>在CentOS上git可以采用yum安装，也可以使用 “End Point Package Repository” 来安装</li><li>如果想通过编译安装git需要有gcc，还要能安装上zlib-devel依赖项</li><li>参考文档：<a href="https://zhuanlan.zhihu.com/p/352955774" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/352955774</a></li></ul><h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><h2 id="yum失败"><a href="#yum失败" class="headerlink" title="yum失败"></a>yum失败</h2><p>终于找到了我的yum更新源一直超时的原因，是因为我通过 <code>Wandisco GIT存储库</code> 方式尝试安装过 git，步骤如下：</p><ul><li>先写入新yum存储库配置文件启用Wandisco GIT存储库，在终端输入 <code>vim /etc/yum.repos.d/wandisco-git.repo</code></li><li><p>文件中加入如下内容，保存退出</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[wandisco-git]</span><br><span class="line">name=Wandisco GIT Repository</span><br><span class="line">baseurl=http://opensource.wandisco.com/centos/7/git/$basearch/</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=1</span><br><span class="line">gpgkey=http://opensource.wandisco.com/RPM-GPG-KEY-WANdisco</span><br></pre></td></tr></table></figure></li><li><p>导入存储库GPG密钥 <code>sudo rpm --import http://opensource.wandisco.com/RPM-GPG-KEY-WANdisco</code></p></li><li>安装Git <code>yum install git</code></li></ul><p>结果 opensource.wandisco.com 无法正常访问，导致 <code>yum update</code> 报错，把 wandisco-git.repo 文件删掉就好了</p><h2 id="rpm-和-yum-的关系"><a href="#rpm-和-yum-的关系" class="headerlink" title="rpm 和 yum 的关系"></a>rpm 和 yum 的关系</h2><p>之前讲到rpm是由Red Hat公司开发的软件包管理方式，使用它可以方便的进行软件的安装、查询、卸载、升级等工作。但处理rpm软件包之间的依赖性问题往往会很繁琐，尤其是当软件由多个rpm包组成时，比如我们在离线安装git时遭遇到的问题。</p><p>Yum（Yellow dog Updater, Modified）是一个在Fedora和RedHat等系统上基于RPM包管理前端软件包管理软件，能够从指定的服务器自动下载RPM包并且安装，并自动处理软件包的依赖关系，可以一次安装所有依赖的软体包。</p><p>总结来说就是, rpm命令只能安装已经下载到本地机器上的rpm包，并且自己解决依赖问题，yum能在线下载并安装rpm包、更新内核、并自动处理包与包之间的依赖问题。</p><center><a href="https://blog.csdn.net/albertsh/article/details/129629916" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>死去元知万事空，但悲不见九州同~</p><p>2023-3-21 23:11:12</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;如果能连接外网，谁甘愿在离线状态下折腾，重新安装git的起因是服务器上的git版本(1.8.3.1)过低，Mac客户端升级后git版本(2.40.0)太高，导致无法验证密钥来进行拉取操作，所以要把服务器上的git升级一下，而git的1.8.3.1版本貌似是CentOS7的默认版本，我在多篇文章中看到了这个版本号，本来以为分分钟搞定，结果的折腾到半夜。&lt;/p&gt;
    
    </summary>
    
      <category term="linux" scheme="http://AlbertGithubHome.github.io/blog/categories/linux/"/>
    
    
      <category term="linux" scheme="http://AlbertGithubHome.github.io/blog/tags/linux/"/>
    
      <category term="git" scheme="http://AlbertGithubHome.github.io/blog/tags/git/"/>
    
      <category term="centos" scheme="http://AlbertGithubHome.github.io/blog/tags/centos/"/>
    
      <category term="rpm" scheme="http://AlbertGithubHome.github.io/blog/tags/rpm/"/>
    
      <category term="yum" scheme="http://AlbertGithubHome.github.io/blog/tags/yum/"/>
    
  </entry>
  
  <entry>
    <title>linux环境下利用rsync+find实现同步指定时间段文件</title>
    <link href="http://AlbertGithubHome.github.io/blog/2023/03/18/linux%E7%8E%AF%E5%A2%83%E4%B8%8B%E5%88%A9%E7%94%A8rsync-find%E5%AE%9E%E7%8E%B0%E5%90%8C%E6%AD%A5%E6%8C%87%E5%AE%9A%E6%97%B6%E9%97%B4%E6%AE%B5%E6%96%87%E4%BB%B6/"/>
    <id>http://AlbertGithubHome.github.io/blog/2023/03/18/linux环境下利用rsync-find实现同步指定时间段文件/</id>
    <published>2023-03-18T13:52:29.000Z</published>
    <updated>2023-06-18T04:06:59.637Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这几天一直在处理shell脚本，作为服务器开发人员免不了要部署一些环境，数据备份和同步工作也是家常便饭，最近常搞的几个命令有 <code>find</code>、<code>rsync</code>、<code>sed</code> 等，之前也写过一篇 <a href="https://blog.csdn.net/albertsh/article/details/127840091" target="_blank" rel="noopener">《linux环境下使用rsync命令完成数据同步》</a>，不过这次有新的需求了。</p><a id="more"></a><h1 id="插曲"><a href="#插曲" class="headerlink" title="插曲"></a>插曲</h1><p>前段时间发现通过 <code>rysnc</code> 同步游戏版本数据时，在数据同步前有一个较长的等待时间，大概12G数据需要等待4分钟，多方面查找原因后定位到应该是 <code>rsync</code> 的 <code>-c</code> 参数导致的，参数全称是 <code>--checksum</code> 打开校验开关，强制对文件传输进行校验，多次实验后发现只要把 <code>-c</code> 参数省略，这个检验所花的4分钟就能省掉，同步前校验只会根据修改的时间戳和文件大小来判断，这在大多数情况下足够了。</p><h1 id="根据时间段同步"><a href="#根据时间段同步" class="headerlink" title="根据时间段同步"></a>根据时间段同步</h1><p>现在想同步日志文件，因为日志文件是每小时产生一个，之前的日志文件绝大多数情况也不会改动，所以再同步时没必要检测所有的日志文件，只需要同步最近一段时间的就可以了，这样可以减少文件比对的时间。</p><p>查询了 <code>sync</code> 命令的所有参数，没有找到指定同步时间段的参数，但是有个 <code>--files-from=FILE</code> 看起来能实现这个需求，man手册中是这样写的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Using this option allows you to specify the exact list of files to transfer (as read from the specified FILE or - for standard input).  It also tweaks the default behavior of rsync to make transferring just the specified files and directories easier:</span><br><span class="line"></span><br><span class="line">    o      The  --relative  (-R) option is implied, which preserves the path information that is specified for each item in the file (use --no-relative or --no-R if you want to turn that off).</span><br><span class="line"></span><br><span class="line">    o      The --dirs (-d) option is implied, which will create directories specified in the list on the destination rather than noisily skipping them (use --no-dirs or  --no-d if you want to turn that off).</span><br><span class="line"></span><br><span class="line">    o      The --archive (-a) option’s behavior does not imply --recursive (-r), so specify it explicitly, if you want it.</span><br><span class="line"></span><br><span class="line">    o      These  side-effects  change the default state of rsync, so the position of the --files-from option on the command-line has no bearing on how other options are parsed (e.g. -a works the same before or after --files-from, as does --no-R and all other options).</span><br><span class="line"></span><br><span class="line">    The filenames that are read from the FILE are all relative to the source dir -- any leading slashes are removed and no &quot;..&quot; references are allowed to  go  higher  than  the source dir.  For example, take this command:</span><br><span class="line"></span><br><span class="line">        rsync -a --files-from=/tmp/foo /usr remote:/backup</span><br></pre></td></tr></table></figure><p>基于参数的描述，我只要提供一个包含指定时间段的待同步的所有文件名的文件就可以了，比如将指定时间段需要同步的文件名放到 <code>/tmp/foo</code> 文件中，然后以 <code>--files-from=/tmp/foo</code> 形式来指定就行了。</p><p>其实还有一个方便的写法，就是直接在参数后面利用 <code>find</code> 写过滤文件的命令，比如只同步最近3天修改过的文件就可以写成：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rsync -avz --files-from=&lt;(find /var/<span class="built_in">log</span>/ -mtime -3) /usr remote:/backup</span><br></pre></td></tr></table></figure><p>其中 <code>find /var/log/ -mtime -3</code> 命令的含义就是找出 <code>/var/log/</code> 目录下最近3天修改的文件。</p><h1 id="按时间过滤文件"><a href="#按时间过滤文件" class="headerlink" title="按时间过滤文件"></a>按时间过滤文件</h1><p>有了上面的基础命令，想要同步不同时间段的文件只需要修改 <code>find</code> 命令参数就可以了，比较常用的参数就是 <code>mtime</code> 了。</p><h2 id="使用-mtime-参数查找"><a href="#使用-mtime-参数查找" class="headerlink" title="使用 mtime 参数查找"></a>使用 mtime 参数查找</h2><p>mtime 表示文件的修改时间，用在 <code>find</code> 查找时是以天为单位的，最小间隔24小时，数字是几就表示几天前，带有 <code>+</code> 表示几天前之外，带有 <code>-</code> 表示今天前之内，下面举几个例子：</p><ul><li>查找修改时间在3天之前的文件（修改时间距今大于96小时）</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find /var/<span class="built_in">log</span>/ -mtime +3</span><br></pre></td></tr></table></figure><ul><li>查找修改时间在3天之内的文件（修改时间距今小于72小时）</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find /var/<span class="built_in">log</span>/ -mtime -3</span><br></pre></td></tr></table></figure><ul><li>查找修改时间在3天前当天的文件（修改时间距今大于72小时，小于96小时）</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find /var/<span class="built_in">log</span>/ -mtime 3</span><br></pre></td></tr></table></figure><p>如果对mtime参数的使用有点疑惑，可以看一下下面的示意图：</p><p>除了上面提到的 <code>-mtime</code> 参数，还有类似的 <code>-atime</code> 和 <code>-ctime</code> 参数，这三个参数的含义如下，使用时可根据定义来选择：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-atime：文件访问时间，文件被读取或执行的时间。</span><br><span class="line">-ctime：属性改变时间，文件的inode被修改的时间</span><br><span class="line">-mtime：内容修改时间</span><br></pre></td></tr></table></figure><h2 id="使用-newermt-进行更精确查找"><a href="#使用-newermt-进行更精确查找" class="headerlink" title="使用 newermt 进行更精确查找"></a>使用 newermt 进行更精确查找</h2><p><code>find -newermt</code> 的通用形式是find -newerXY reference，目的是找到一些X属性比variable的Y属性更早的文件，其中X代表find的目标文件属性，Y代表参照属性。X可选a,c,m，Y可选a,c,m,t，其中t代表客观绝对时间，只作为参照属性存在，具体详细的用法参照man手册：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-newerXY reference</span><br><span class="line">    Compares the timestamp of the current file with reference.  The reference argument is normally the name of a file (and one of its timestamps is used for the comparison) but it may also be a string describing an absolute time.  X and Y are placeholders for other letters, and these letters select which time belonging to how reference is used for the comparison.</span><br><span class="line"></span><br><span class="line">    a   The access time of the file reference</span><br><span class="line">    B   The birth time of the file reference</span><br><span class="line">    c   The inode status change time of reference</span><br><span class="line">    m   The modification time of the file reference</span><br><span class="line">    t   reference is interpreted directly as a time</span><br><span class="line"></span><br><span class="line">    Some combinations are invalid; for example, it is invalid for X to be t.  Some combinations are not implemented on all systems; for example B is not supported on  all  sys‐tems.   If an invalid or unsupported combination of XY is specified, a fatal error results.  Time specifications are interpreted as for the argument to the -d option of GNU date.  If you try to use the birth time of a reference file, and the birth time cannot be determined, a fatal error message results.  If you specify a test which refers  to the birth time of files being examined, this test will fail for any files where the birth time is unknown.</span><br></pre></td></tr></table></figure><p>如果要找到修改时间在2023-3-18 20:00:00 和 2023-3-18 22:00:00 之间的文件可以写成：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find /var/<span class="built_in">log</span> -newermt <span class="string">'2023-3-18 20:00:00'</span> ! -newermt <span class="string">'2023-3-18 22:00:00'</span></span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li><code>rsync</code> 命令本身不能指定同步的时间段，可搭配 <code>find</code> 命令来同步指定时间段的文件</li><li><code>rsync -avz --files-from=&lt;(find /var/log/ -mtime -3) /usr remote:/backup</code> 同步修改时间在3天内的文件</li><li>使用 <code>newermt</code> 可按时间精确查找，形式如 <code>find /var/log -newermt &#39;2023-3-18 20:00:00&#39; ! -newermt &#39;2023-3-18 22:00:00&#39;</code></li><li>假设变量 KEY=birthday、FILE=myfile.log，查找KEY所在的行号可以使用 <code>grep -rn $KEY&quot; $FILE | awk -F &#39;:&#39; &#39;{print $1}&#39;</code></li><li>还是在上面的假设 <code>sed -n &#39;/${KEY}=/&#39; $FILE</code> 无法获得行号，使用 <code>sed -n &#39;/birthday=/&#39; $FILE</code> 就可以</li><li>上面这种sed命令中使用变量不生效的问题目前还没找到解决方法，有解决方案的大佬请指教</li><li>不过 <code>sed -e &quot;${LINE},${LINE}s%$OLD_VAL%$NEW_VAL%g&quot; $FILE</code> 这种替换命令就支持变量，但sed不支持非贪婪模式，目前有点迷糊，还在探索中</li></ul><center><a href="https://blog.csdn.net/albertsh/article/details/129629916" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>不要规划孩子必须在哪一个领域取得成就，但只要她喜欢，就提供一个舞台，让她尽情去发挥~</p><p>2023-3-19 21:01:51</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;这几天一直在处理shell脚本，作为服务器开发人员免不了要部署一些环境，数据备份和同步工作也是家常便饭，最近常搞的几个命令有 &lt;code&gt;find&lt;/code&gt;、&lt;code&gt;rsync&lt;/code&gt;、&lt;code&gt;sed&lt;/code&gt; 等，之前也写过一篇 &lt;a href=&quot;https://blog.csdn.net/albertsh/article/details/127840091&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《linux环境下使用rsync命令完成数据同步》&lt;/a&gt;，不过这次有新的需求了。&lt;/p&gt;
    
    </summary>
    
      <category term="linux" scheme="http://AlbertGithubHome.github.io/blog/categories/linux/"/>
    
    
      <category term="find" scheme="http://AlbertGithubHome.github.io/blog/tags/find/"/>
    
      <category term="linux" scheme="http://AlbertGithubHome.github.io/blog/tags/linux/"/>
    
      <category term="shell" scheme="http://AlbertGithubHome.github.io/blog/tags/shell/"/>
    
      <category term="sed" scheme="http://AlbertGithubHome.github.io/blog/tags/sed/"/>
    
      <category term="rsync" scheme="http://AlbertGithubHome.github.io/blog/tags/rsync/"/>
    
  </entry>
  
  <entry>
    <title>Ununtu环境下的判断字符串相等出现sh: xxx: [: xxx: unexpected operator的问题</title>
    <link href="http://AlbertGithubHome.github.io/blog/2023/03/17/Ununtu%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%9A%84sh-xxx-xxx-unexpected-operator%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://AlbertGithubHome.github.io/blog/2023/03/17/Ununtu环境下的sh-xxx-xxx-unexpected-operator的问题/</id>
    <published>2023-03-16T16:10:47.000Z</published>
    <updated>2023-03-18T13:53:11.014Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这是个小问题，本质原因是判断字符相等使用两个 <code>==</code> 需要在 <code>bash</code> 环境下，而Ubuntu默认不是这个Shell环境，所以就会出现在 CentOS 上运行的好好的Shell，放到Ubuntu上就运行出错的问题，我遇到的问题本质也是这个原因，不过在复杂的状况下却不能一眼找到是哪里导致的。</p><a id="more"></a><h1 id="现场还原"><a href="#现场还原" class="headerlink" title="现场还原"></a>现场还原</h1><p>为了找出这个问题的原因，我把无关逻辑都去掉了，出现了下面<code>a.sh</code> 和 <code>b.sh</code> 两个脚本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">VAL=<span class="variable">$1</span></span><br><span class="line"></span><br><span class="line">sh ./b.sh <span class="variable">$VAL</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">VAL=<span class="variable">$1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$VAL</span> == <span class="string">"1"</span> ] ; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"find it"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"end"</span></span><br></pre></td></tr></table></figure><p>考虑到兼容问题，我还在开头写了 <code>#!/bin/bash</code>，让它默认的用bash来执行，这样我无论在 Ununtu 还是其他的 Linux 版本都应该没问题了，可事实却不是这样，运行结果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@demo:~<span class="comment"># ./a.sh fly</span></span><br><span class="line">./b.sh: 5: [: fly: unexpected operator</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>如果眼尖的话一眼就看出来了，问题出在 <code>sh ./b.sh $VAL</code> 这一句，导致 <code>#!/bin/bash</code> 没有起到作用，使用 <code>sh</code> 这个shell 来执行的 <code>b.sh</code> 脚本，所以用 <code>==</code> 判断字符串相等会报错。</p><p>这个例子里很好发现，但是放在实际工作中的复杂脚本中就比较难发现了，再看报错 <code>./b.sh: 5</code> 没有发现任何问题，因为查到可能是 Ubuntu 系统下的shell 语法导致的，我还尝试了多次改成单等号的写法，其他比较字符串的方式，依旧报错，但是当我发现问题的所在之后，无论单个等号还是两个等号我都能让他正确执行，这就是忙中出乱，静下来就好了</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>使用 <code>==</code> 判断字符串相等是 <code>bash</code> 中的语法</li><li>Shell 脚本开头的 <code>#!/bin/bash</code> 表示执行脚本时若没有指定Shell类型，则用说明的这种Shell执行</li><li>遇到问题时需要静下心来慢慢解决，切忌忙中出乱</li></ul><center><a href="https://blog.csdn.net/albertsh/article/details/129543700" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>有的人活下来就已经花光了所有力气，还要靠什么去抗争命运~</p><p>2023-3-17 22:55:15</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;这是个小问题，本质原因是判断字符相等使用两个 &lt;code&gt;==&lt;/code&gt; 需要在 &lt;code&gt;bash&lt;/code&gt; 环境下，而Ubuntu默认不是这个Shell环境，所以就会出现在 CentOS 上运行的好好的Shell，放到Ubuntu上就运行出错的问题，我遇到的问题本质也是这个原因，不过在复杂的状况下却不能一眼找到是哪里导致的。&lt;/p&gt;
    
    </summary>
    
      <category term="linux" scheme="http://AlbertGithubHome.github.io/blog/categories/linux/"/>
    
    
      <category term="Ubuntu" scheme="http://AlbertGithubHome.github.io/blog/tags/Ubuntu/"/>
    
      <category term="shell" scheme="http://AlbertGithubHome.github.io/blog/tags/shell/"/>
    
      <category term="字符串判断" scheme="http://AlbertGithubHome.github.io/blog/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%88%A4%E6%96%AD/"/>
    
      <category term="等号问题" scheme="http://AlbertGithubHome.github.io/blog/tags/%E7%AD%89%E5%8F%B7%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>记录一下第一次安装和配置Nginx</title>
    <link href="http://AlbertGithubHome.github.io/blog/2023/03/14/%E8%AE%B0%E5%BD%95%E4%B8%80%E4%B8%8B%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AENginx/"/>
    <id>http://AlbertGithubHome.github.io/blog/2023/03/14/记录一下第一次安装和配置Nginx/</id>
    <published>2023-03-14T15:49:41.000Z</published>
    <updated>2023-03-14T16:55:38.869Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Nginx虽不是第一次接触，但是使用较少，今天算是完整的安装了配置了一次，前段时间想写一写的<a href="https://blog.csdn.net/albertsh/article/details/128367971" target="_blank" rel="noopener">《Nginx的安装与常用配置》</a>，因突发状况没有写完，今天补充一下。</p><a id="more"></a><h1 id="安装-nginx"><a href="#安装-nginx" class="headerlink" title="安装 nginx"></a>安装 nginx</h1><p>nginx 安装比较方便，我安装的环境是拥有root权限的Ubuntu 20.04，安装只需要以下两个命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt update</span><br><span class="line">apt install nginx</span><br></pre></td></tr></table></figure><p>安装完默认启动，查询运行状态的命令 <code>systemctl status nginx</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># systemctl status nginx</span></span><br><span class="line">● nginx.service - A high performance web server and a reverse proxy server</span><br><span class="line">     Loaded: loaded (/lib/systemd/system/nginx.service; enabled; vendor preset: enabled)</span><br><span class="line">     Active: active (running) since Tue 2023-03-14 21:09:35 CST; 2h 55min ago</span><br><span class="line">       Docs: man:nginx(8)</span><br><span class="line">    Process: 943307 ExecStartPre=/usr/sbin/nginx -t -q -g daemon on; master_process on; (code=exited, status=0/SUCCESS)</span><br><span class="line">    Process: 943314 ExecStart=/usr/sbin/nginx -g daemon on; master_process on; (code=exited, status=0/SUCCESS)</span><br><span class="line">   Main PID: 943315 (nginx)</span><br><span class="line">      Tasks: 5 (<span class="built_in">limit</span>: 9132)</span><br><span class="line">     Memory: 10.6M</span><br><span class="line">     CGroup: /system.slice/nginx.service</span><br><span class="line">             ├─943315 nginx: master process /usr/sbin/nginx -g daemon on; master_process on;</span><br><span class="line">             ├─943316 nginx: worker process</span><br><span class="line">             ├─943317 nginx: worker process</span><br><span class="line">             ├─943318 nginx: worker process</span><br><span class="line">             └─943319 nginx: worker process</span><br><span class="line"></span><br><span class="line">Mar 14 21:09:35 w-mi-dev systemd[1]: Starting A high performance web server and a reverse proxy server...</span><br><span class="line">Mar 14 21:09:35 w-mi-dev snoopy[943307]: [hostname:w-mi-dev ssh:((undefined)) uid:0 username:root pid:943307 ppid:1 rpname:(nginx) sid:943307 tty:(none) cwd:/ filename:/usr/sbin/nginx]: /usr/sbin/ng&gt;</span><br><span class="line">Mar 14 21:09:35 w-mi-dev snoopy[943314]: [hostname:w-mi-dev ssh:((undefined)) uid:0 username:root pid:943314 ppid:1 rpname:(nginx) sid:943314 tty:(none) cwd:/ filename:/usr/sbin/nginx]: /usr/sbin/ng&gt;</span><br><span class="line">Mar 14 21:09:35 w-mi-dev systemd[1]: Started A high performance web server and a reverse proxy server.</span><br></pre></td></tr></table></figure><p>要想测试的话通过浏览器访问 <code>http://YOUR_IP</code>，通常会看到 “Welcome to nginx” 字样的界面，但这对于我是没用的，我的默认端口访问不了。</p><h1 id="查找nginx安装和配置文件的位置"><a href="#查找nginx安装和配置文件的位置" class="headerlink" title="查找nginx安装和配置文件的位置"></a>查找nginx安装和配置文件的位置</h1><p>我的nginx安装在 <code>/usr/sbin/nginx</code> 目录，配置文件主目录在 <code>/etc/nginx/nginx.conf</code>，找的方法比较简单就是用 <code>which</code> 命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># which nginx</span></span><br><span class="line">/usr/sbin/nginx</span><br></pre></td></tr></table></figure><p>找配置文件时利用 nginx 检查配置文件的 <code>-t</code> 参数就可以了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># nginx -t</span></span><br><span class="line">nginx: the configuration file /etc/nginx/nginx.conf syntax is ok</span><br><span class="line">nginx: configuration file /etc/nginx/nginx.conf <span class="built_in">test</span> is successful</span><br></pre></td></tr></table></figure><p>如果使用 <code>which</code> 命令找不到，可以利用 <code>ps -ef | grep nginx</code> 找到进程id，在利用 <code>ll /proc/nginx_pid</code> 来找到安装的位置。</p><h1 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h1><p>进入 <code>/etc/nginx</code> 目录，可以看到多个配置文件和目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cd /etc/nginx/</span></span><br><span class="line"><span class="comment"># ll</span></span><br><span class="line">total 64</span><br><span class="line">drwxr-xr-x 2 root root 4096 Mar 14 20:56 conf.d/</span><br><span class="line">-rw-r--r-- 1 root root 1077 Feb  4  2019 fastcgi.conf</span><br><span class="line">-rw-r--r-- 1 root root 1007 Feb  4  2019 fastcgi_params</span><br><span class="line">-rw-r--r-- 1 root root 2837 Feb  4  2019 koi-utf</span><br><span class="line">-rw-r--r-- 1 root root 2223 Feb  4  2019 koi-win</span><br><span class="line">-rw-r--r-- 1 root root 3957 Feb  4  2019 mime.types</span><br><span class="line">drwxr-xr-x 2 root root 4096 Nov 10 14:38 modules-available/</span><br><span class="line">drwxr-xr-x 2 root root 4096 Mar  9 21:30 modules-enabled/</span><br><span class="line">-rw-r--r-- 1 root root 1490 Feb  4  2019 nginx.conf</span><br><span class="line">-rw-r--r-- 1 root root  180 Feb  4  2019 proxy_params</span><br><span class="line">-rw-r--r-- 1 root root  636 Feb  4  2019 scgi_params</span><br><span class="line">drwxr-xr-x 2 root root 4096 Mar  9 21:30 sites-available/</span><br><span class="line">drwxr-xr-x 2 root root 4096 Mar  9 21:30 sites-enabled/</span><br><span class="line">drwxr-xr-x 2 root root 4096 Mar  9 21:30 snippets/</span><br><span class="line">-rw-r--r-- 1 root root  664 Feb  4  2019 uwsgi_params</span><br><span class="line">-rw-r--r-- 1 root root 3071 Feb  4  2019 win-utf</span><br></pre></td></tr></table></figure><p>其中 <code>nginx.conf</code> 是主配置文件，内容如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">user www-data;</span><br><span class="line">worker_processes auto;</span><br><span class="line">pid /run/nginx.pid;</span><br><span class="line">include /etc/nginx/modules-enabled/*.conf;</span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">        worker_connections 768;</span><br><span class="line">        <span class="comment"># multi_accept on;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">##</span></span><br><span class="line">        <span class="comment"># Basic Settings</span></span><br><span class="line">        <span class="comment">##</span></span><br><span class="line"></span><br><span class="line">        sendfile on;</span><br><span class="line">        tcp_nopush on;</span><br><span class="line">        tcp_nodelay on;</span><br><span class="line">        keepalive_timeout 65;</span><br><span class="line">        types_hash_max_size 2048;</span><br><span class="line">        <span class="comment"># server_tokens off;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># server_names_hash_bucket_size 64;</span></span><br><span class="line">        <span class="comment"># server_name_in_redirect off;</span></span><br><span class="line"></span><br><span class="line">        include /etc/nginx/mime.types;</span><br><span class="line">        default_type application/octet-stream;</span><br><span class="line"></span><br><span class="line">        <span class="comment">##</span></span><br><span class="line">        <span class="comment"># SSL Settings</span></span><br><span class="line">        <span class="comment">##</span></span><br><span class="line"></span><br><span class="line">        ssl_protocols TLSv1 TLSv1.1 TLSv1.2 TLSv1.3; <span class="comment"># Dropping SSLv3, ref: POODLE</span></span><br><span class="line">        ssl_prefer_server_ciphers on;</span><br><span class="line"></span><br><span class="line">        <span class="comment">##</span></span><br><span class="line">        <span class="comment"># Logging Settings</span></span><br><span class="line">        <span class="comment">##</span></span><br><span class="line"></span><br><span class="line">        access_log /var/<span class="built_in">log</span>/nginx/access.log;</span><br><span class="line">        error_log /var/<span class="built_in">log</span>/nginx/error.log;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Gzip Settings</span></span><br><span class="line">        <span class="comment">##</span></span><br><span class="line"></span><br><span class="line">        gzip on;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># gzip_vary on;</span></span><br><span class="line">        <span class="comment"># gzip_proxied any;</span></span><br><span class="line">        <span class="comment"># gzip_comp_level 6;</span></span><br><span class="line">        <span class="comment"># gzip_buffers 16 8k;</span></span><br><span class="line">        <span class="comment"># gzip_http_version 1.1;</span></span><br><span class="line">        <span class="comment"># gzip_types text/plain text/css application/json application/javascript text/xml application/xml application/xml+rss text/javascript;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">##</span></span><br><span class="line">        <span class="comment"># Virtual Host Configs</span></span><br><span class="line">        <span class="comment">##</span></span><br><span class="line"></span><br><span class="line">        include /etc/nginx/conf.d/*.conf;</span><br><span class="line">        include /etc/nginx/sites-enabled/*;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#mail &#123;</span></span><br><span class="line"><span class="comment">#       # See sample authentication script at:</span></span><br><span class="line"><span class="comment">#       # http://wiki.nginx.org/ImapAuthenticateWithApachePhpScript</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#       # auth_http localhost/auth.php;</span></span><br><span class="line"><span class="comment">#       # pop3_capabilities "TOP" "USER";</span></span><br><span class="line"><span class="comment">#       # imap_capabilities "IMAP4rev1" "UIDPLUS";</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#       server &#123;</span></span><br><span class="line"><span class="comment">#               listen     localhost:110;</span></span><br><span class="line"><span class="comment">#               protocol   pop3;</span></span><br><span class="line"><span class="comment">#               proxy      on;</span></span><br><span class="line"><span class="comment">#       &#125;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#       server &#123;</span></span><br><span class="line"><span class="comment">#               listen     localhost:143;</span></span><br><span class="line"><span class="comment">#               protocol   imap;</span></span><br><span class="line"><span class="comment">#               proxy      on;</span></span><br><span class="line"><span class="comment">#       &#125;</span></span><br><span class="line"><span class="comment">#&#125;</span></span><br></pre></td></tr></table></figure><p>这个文件是默认的配置文件，我们可以先不管，先注意几点就行：</p><ul><li>访问日志在 <code>/var/log/nginx/access.log</code></li><li>错误日志在 <code>/var/log/nginx/error.log</code></li><li>主配置文件包含了 <code>/etc/nginx/conf.d/*.conf</code> 这个目录下所有配置</li></ul><p>所以我们在 <code>/etc/nginx/conf.d/</code> 目录下新建一个 <code>project.conf</code> 文件，编写如下内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">upstream login_entrance &#123;</span><br><span class="line">    server localhost:4101;</span><br><span class="line">    server localhost:4102;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">upstream exit_entrance &#123;</span><br><span class="line">    server localhost:6101;</span><br><span class="line">    server localhost:6102;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen       4100;</span><br><span class="line">    server_name  localhost;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line"></span><br><span class="line">        proxy_pass http://login_entrance;</span><br><span class="line">        proxy_set_header Host <span class="variable">$host</span>;</span><br><span class="line">        proxy_set_header X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">        proxy_set_header X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen       6100;</span><br><span class="line">    server_name  localhost;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line"></span><br><span class="line">        proxy_pass http://exit_entrance;</span><br><span class="line">        proxy_set_header Host <span class="variable">$host</span>;</span><br><span class="line">        proxy_set_header X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">        proxy_set_header X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen      8100;</span><br><span class="line">    server_name localhost;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        root    /usr/share/nginx/html;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置文件的含义：</p><ul><li>访问 8100 端口可以看到 nginx 欢迎页</li><li>将发送给4100端口的数据转发给4101和4102端口</li><li>将发送给6100端口的数据转发给6101和6102端口</li></ul><h1 id="重启nginx服务"><a href="#重启nginx服务" class="headerlink" title="重启nginx服务"></a>重启nginx服务</h1><p>重启可采用关闭服务器再开启的方式，也可以直接使用以下命令：</p><ul><li>systemctl restart nginx</li><li>nginx -s reload</li></ul><h1 id="查看报错"><a href="#查看报错" class="headerlink" title="查看报错"></a>查看报错</h1><p>当nginx启动不起来是可以通过 <code>systemctl status nginx</code> 命令查看，也可以直接查看 errorlog 文件，比如可能会看到如下内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2023/03/14 20:51:06 [emerg] 937503<span class="comment">#937503: bind() to 0.0.0.0:4100 failed (98: Address already in use)</span></span><br><span class="line">2023/03/14 20:51:06 [emerg] 937503<span class="comment">#937503: bind() to 0.0.0.0:4100 failed (98: Address already in use)</span></span><br><span class="line">2023/03/14 20:51:06 [emerg] 937503<span class="comment">#937503: bind() to 0.0.0.0:4100 failed (98: Address already in use)</span></span><br><span class="line">2023/03/14 20:51:06 [emerg] 937503<span class="comment">#937503: bind() to 0.0.0.0:4100 failed (98: Address already in use)</span></span><br></pre></td></tr></table></figure><p>一看就应该知道是端口4100被占用了。</p><h1 id="负载均衡配置"><a href="#负载均衡配置" class="headerlink" title="负载均衡配置"></a>负载均衡配置</h1><p>负载均衡是nginx一个常见的应用，只需要在配置文件中加入一些参数即可：</p><h2 id="轮询"><a href="#轮询" class="headerlink" title="轮询"></a>轮询</h2><p>这是默认的策略，把每个请求按次序逐一分配到不同可用的server，如果分配到的server不可用，则自动分配到下一个</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">upstream good.cc &#123;</span><br><span class="line">    server localhost:4101;</span><br><span class="line">    server localhost:4102;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="权重"><a href="#权重" class="headerlink" title="权重"></a>权重</h2><p>weight默认值为1，值越大则代表被访问的几率越大，下面配置中4102端口的访问几率是4101的二倍</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">upstream good.cc &#123;</span><br><span class="line">    server localhost:4101 weight=1;</span><br><span class="line">    server localhost:4102 weight=2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最少连接"><a href="#最少连接" class="headerlink" title="最少连接"></a>最少连接</h2><p>顾名思义就是把请求分配到连接数最少的server</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">upstream good.cc &#123;</span><br><span class="line">    least_conn;</span><br><span class="line">    server localhost:4101;</span><br><span class="line">    server localhost:4102;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="IP哈希"><a href="#IP哈希" class="headerlink" title="IP哈希"></a>IP哈希</h2><p>根据访问客户端ip的hash值分配，这样同一客户端的请求都会被分配到同一个server上，适合有状态的服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">upstream good.cc &#123;</span><br><span class="line">    ip_hash;</span><br><span class="line">    server localhost:4101;</span><br><span class="line">    server localhost:4102;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>nginx 在 Ununtu 20.04 上安装非常简单，使用 <code>apt install nginx</code> 就行啦</li><li>nginx 的默认主配置文件是 <code>/etc/nginx/nginx.conf</code> 会包含同级目录下 <code>conf.d/*.conf</code> 所有配置</li><li>nginx 服务可以用 <code>systemctl status nginx</code> 方式查看</li><li>nginx 的重启方式 <code>systemctl restart nginx</code> 或 <code>nginx -s reload</code></li><li>nginx 作为负载均衡服务器有轮询、权重、最少连接、ipHash等多种配置方式</li><li>我也是刚刚入门，关于使用方法和配置文件还有很多东西要学，后面慢慢总结吧</li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/129271813" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>无善无恶心之体，有善有恶意之动，知善知恶是良知，为善去恶是格物，愣凑数啊~</p></blockquote><!--2023-3-15 00:47:25-->]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;Nginx虽不是第一次接触，但是使用较少，今天算是完整的安装了配置了一次，前段时间想写一写的&lt;a href=&quot;https://blog.csdn.net/albertsh/article/details/128367971&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《Nginx的安装与常用配置》&lt;/a&gt;，因突发状况没有写完，今天补充一下。&lt;/p&gt;
    
    </summary>
    
      <category term="Nginx" scheme="http://AlbertGithubHome.github.io/blog/categories/Nginx/"/>
    
    
      <category term="Nginx" scheme="http://AlbertGithubHome.github.io/blog/tags/Nginx/"/>
    
      <category term="负载均衡" scheme="http://AlbertGithubHome.github.io/blog/tags/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
    
      <category term="反向代理" scheme="http://AlbertGithubHome.github.io/blog/tags/%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>git配置中的core.autocrlf和core.safecrlf</title>
    <link href="http://AlbertGithubHome.github.io/blog/2023/03/04/git%E9%85%8D%E7%BD%AE%E4%B8%AD%E7%9A%84core-autocrlf%E5%92%8Ccore-safecrlf/"/>
    <id>http://AlbertGithubHome.github.io/blog/2023/03/04/git配置中的core-autocrlf和core-safecrlf/</id>
    <published>2023-03-04T08:25:56.000Z</published>
    <updated>2023-03-04T08:36:48.163Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>使用git作为版本管理工具的朋友们，有没有遇到更新完同事写的脚本无法运行的问题？逻辑正确的脚本换台机器不能运行了多半是换行符捣的鬼，修改git中的core.autocrlf设置即可解决问题，那么autocrlf是什么意思呢？我来简单件解释下。</p><a id="more"></a><h1 id="core-autocrlf"><a href="#core-autocrlf" class="headerlink" title="core.autocrlf"></a>core.autocrlf</h1><p><code>autocrlf</code> 是三部分的缩写 <code>auto-cr-lf</code>，分开来看应该是3组词 auto/carriage-return/linefeed，直译的话就是自动回车换行。</p><p>还是说下前面的问题，这是因为 Windows 使用回车（CR）和换行（LF）两个字符来结束一行，而 MacOS 和 Linux 只使用换行（LF）一个字符来结束一行。</p><p>当你在Windows下用常见编辑器写一个Shell脚本是，直接拿到Linux去执行很可能会报错，而在Linux编辑的文件拿到Windows环境下打开通常会显示成一行。</p><p>git 作为一个多人共同使用的版本管理工具，使用者的系统可能是Windows、Linux或者是Mac中的任意一种，所以在共同操作一个文件时就会造成换行符混乱，这时就要用到 core.autocrlf参数了。</p><p><code>core.autocrlf</code> 参数不仅影响检出时的换行符装换，还会影响提交时的换行符转换，共有 <code>true</code>、<code>false</code>、<code>input</code> 三种可选值</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 提交时转换为LF，检出时转换为CRLF</span></span><br><span class="line">git config --global core.autocrlf <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 提交和检出时都不转换</span></span><br><span class="line">git config --global core.autocrlf <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 提交时转换为LF，检出时不转换</span></span><br><span class="line">git config --global core.autocrlf input</span><br></pre></td></tr></table></figure><p>根据他们的定义我们可以选择一种保险的方式，在windows系统上设置为 <code>true</code>，在 Linux 和 Mac 上设置为 <code>input</code>，如果所有使用者仅在统一系统下工作，设置成 <code>false</code> 就好了。</p><h1 id="core-safecrlf"><a href="#core-safecrlf" class="headerlink" title="core.safecrlf"></a>core.safecrlf</h1><p>前一个 autocrlf 大家听到的应该比较多，而这个safecrlf可能很多人是第一次听到，它的默认只是<code>false</code>，若果改成<code>true</code>表示拒绝提交混合换行符的代码，也就是说如果你的代码中同时包含两种系统中不同的换行格式会被禁止提交，如果设置成 <code>warn</code> 表示只提出警告但可以提交。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>多人合作的git库如果下载之后，其中的脚本不能直接运行先看看是不是换行符搞的鬼</li><li>Windows平台建议设置 <code>git config --global core.autocrlf true</code></li><li>Linux平台建议设置 <code>git config --global core.autocrlf input</code></li><li>可以使用工具 <code>dos2unix</code> 与 <code>unix2dos</code> 将 <code>LF</code> 和 <code>CRLF</code> 相互转化</li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/128892715" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>一代文豪东坡居士，却写多篇祈雨文~</p></blockquote><!--2023-2-28 23:57:41 -->]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;使用git作为版本管理工具的朋友们，有没有遇到更新完同事写的脚本无法运行的问题？逻辑正确的脚本换台机器不能运行了多半是换行符捣的鬼，修改git中的core.autocrlf设置即可解决问题，那么autocrlf是什么意思呢？我来简单件解释下。&lt;/p&gt;
    
    </summary>
    
      <category term="Git" scheme="http://AlbertGithubHome.github.io/blog/categories/Git/"/>
    
    
      <category term="Git" scheme="http://AlbertGithubHome.github.io/blog/tags/Git/"/>
    
      <category term="换行符" scheme="http://AlbertGithubHome.github.io/blog/tags/%E6%8D%A2%E8%A1%8C%E7%AC%A6/"/>
    
      <category term="配置" scheme="http://AlbertGithubHome.github.io/blog/tags/%E9%85%8D%E7%BD%AE/"/>
    
      <category term="autocrlf" scheme="http://AlbertGithubHome.github.io/blog/tags/autocrlf/"/>
    
  </entry>
  
  <entry>
    <title>工作十年对游戏看法的转变历程</title>
    <link href="http://AlbertGithubHome.github.io/blog/2023/02/05/%E5%B7%A5%E4%BD%9C%E5%8D%81%E5%B9%B4%E5%AF%B9%E6%B8%B8%E6%88%8F%E7%9C%8B%E6%B3%95%E7%9A%84%E8%BD%AC%E5%8F%98%E5%8E%86%E7%A8%8B/"/>
    <id>http://AlbertGithubHome.github.io/blog/2023/02/05/工作十年对游戏看法的转变历程/</id>
    <published>2023-02-05T09:09:17.000Z</published>
    <updated>2023-02-05T11:19:56.567Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>现在一提到玩游戏很多人的第一反应就是『手游』『网游』，是社会的发展将“游戏”这个词狭义化了，甚至在搜索引擎中输入『游戏』一词，得到的前几页搜索结果都是手机游戏推荐，而游戏本来的定义是指体育手段的一种，也是文化娱乐的一种形式。以一定的形式反映人类社会劳动、军事、文化等方面的活动。</p><p>称之为游戏论之父的豪伊金格说：“游戏是在明确规定的时间、空间里所进行的行为或者活动。它是按照自发接受的规则来进行的。这种规则一旦被接受就具有绝对的约束力。游戏的目的就存在于游戏行为自身之中，它伴有紧张和喜悦的感情与日常生活不同。”</p><a id="more"></a><p>现在也很少听到“网瘾少年”这个词了，在网络刚刚兴起时，这个词可是让很多父母闻风丧胆，当网络开始和游戏相结合时，又让多少自制力差的孩子深陷其中，所以当时的网络、游戏都被看做是大老虎，是一切美好事物的对立面，但随着时间的推移，互联网开始普及并渗透到生活中方方面面。</p><p>人们理智了很多，认识到了我们的生活离不开网络，而孩子们从小生活在这样的环境中，对一切都习以为常，所以很难出现深陷其中无法自拔的情况，之前是因为没有接触过，所以一旦陷入这种虚拟环境中很容易无法自控，而如今社会网络无处不在，没有而来环境落差也就不容易沉迷了，就像一个穷苦孩子落入富豪家就会沉迷，而富二代的公子哥只觉得眼前的生活无趣而已。</p><h1 id="初识游戏"><a href="#初识游戏" class="headerlink" title="初识游戏"></a>初识游戏</h1><p>我们从来到这个世界就在和游戏打交道，三岁前父母家人是我们最亲密的游戏玩伴，上了幼儿园又有了其他的小伙伴，而我对这些记忆已经模糊了，除了捉迷藏、丢沙包、跳皮筋这些常规游戏外，记得还算清楚的一个游戏应该是小学时玩的，名字叫『鸭子嘴』，就是一群孩子追来追去，那时的孩子们玩这些游戏很开心的。</p><p>那时的电脑还是一个昂贵的稀罕物，我记得经常在电视购物广告里看到，“电脑只要9999轻松搬回家”，当时并不知道电脑能做什么，其实当时的家用电脑还真做不了什么，方方的大头，粗糙的98。</p><p>后来老爸给买了一台学习机，就是小霸王横行的那个年代，这是我第一次接触电子游戏，虽然他的目的是让我来学习打字的，可是我的盲打真的很烂，还是工作之后才慢慢好的，为此还被同事嘲笑过。</p><p>这台学习机是我对电脑的启蒙，真正接触电脑是初中的微机课，每周只有一节课，大头电脑没有网络，操作完Excel和Word能让玩一会扫雷都开心的不得了，当然，课业紧张时微机老师总是恰好来不了。</p><p>在高中时我家买了台电脑，当时整个村子应该也没有几台，而我对电脑也渐渐熟悉了，当时对游戏没有那么痴迷，但是对QQ太阳过分迷恋，整天的挂着QQ升等级，没事养养动物偷偷菜，电脑里的红色警戒我就没玩明白过。</p><h1 id="计算机专业"><a href="#计算机专业" class="headerlink" title="计算机专业"></a>计算机专业</h1><p>因为接触过电脑觉的很有意思，所以大学想学计算机专业，而我也很幸运的被第一志愿的计算机专业录取，大学军训的刚结束就跟着班长去网吧了，当时好像没玩游戏，去网吧是登QQ跟家人视频了，说出来可能很多人不信，那是我第一次去网吧，那天晚上视频时老爸还说呢，刚上大学就学会上网吧了，你这是要学坏吧，看了吧，这就是那个谈『网吧』色变的时代。</p><p>其实当时学计算机也不是为了游戏，但是因为学计算机，让我更多的接触到了游戏。前面提到说我要挂QQ等级、要偷菜、要升级农场，这就为我后来的游戏风格建立的开端，这样游戏都是养成类，也就是你的付出在游戏中一直有积累，比较偏向于RPG类型游戏。</p><p>所以我在上大学后，同学邀我一起玩对战游戏dota时，我觉得简直不可思议，花了半天时间攒的金钱装备，下一把游戏时一点用都没有了，这游戏有什么意思啊。</p><p>但是人总是会变的，当融入兄弟环境中，一起开黑打dota，打CF，我也渐渐迷上了这种MOBA类风格，但是我是个手残，技术特别烂，技能通常是一顿乱按，就是喜欢和大家凑热闹，一起在游戏里玩而已，我就是传说中越菜越爱玩的菜狗。</p><h1 id="步入游戏开发行业"><a href="#步入游戏开发行业" class="headerlink" title="步入游戏开发行业"></a>步入游戏开发行业</h1><p>大学时光转瞬即逝，时间来到大四实习阶段，从几份Offer中选择了工资较低但比较感兴趣的游戏公司，找工作之前并没有想着一定要开发游戏，但是缘分来了挡都挡不住，众多工作中只有一份游戏开发，而我就选择了它，在一家小公司工资只有可怜的3K。</p><p>那是2013年页游风靡的时代，我们也不落俗套，正正经经的微端页游，类型MMORPG。后来在同一家公司接触了端游，手游，虽然形式不同，但类型一直是MMORPG，没想到这家签了毕业三方的小公司，我一待就是6年多。</p><p>长时间同质化游戏的开发，使我对游戏的兴趣大大降低，从刚开始的新奇，到后来的麻木，我发现我对这些游戏不再感冒，有时候甚至都不想伸手点一点了。</p><p>这一阶段我还能坚持玩的两款游戏，一个是之前玩的《dota》，一个是后来通了几千关的《开心消消乐》，重度的RPG我真的不想再玩，因为我真的有点肝吐了，各种游戏玩法上线前我都测了几百遍，上线后真的不想玩了。</p><h1 id="转变游戏开发类型"><a href="#转变游戏开发类型" class="headerlink" title="转变游戏开发类型"></a>转变游戏开发类型</h1><p>肝不动的RPG影响了心情，在2020年我跳出了原来的舒适圈，开始了回合制游戏的开发，新换的环境必然会带来新鲜感，我开始了新的征程，体会着回合制与RPG游戏的差距。</p><p>但是近几年回合制游戏变了，除了战斗模式，回合制变得越来越RPG化，重度的培养系统慢慢加入，导致回合制游戏也很肝，工作3年之后我觉得之前很多的兴趣点也没有了。</p><p>现在的对于我这些哪里亮光点哪里的游戏，真的感觉有些麻木，难道我做出来的游戏就是引导大家一直点亮光？难道就是让大家熬夜点亮光？难道就是让大家把钱放到游戏中不断点亮光？</p><h1 id="手机游戏应该什么样"><a href="#手机游戏应该什么样" class="headerlink" title="手机游戏应该什么样"></a>手机游戏应该什么样</h1><p>最近我经常有些错觉，我之前真的是做游戏的？我做的那些真的叫游戏吗？我总有一种感觉，这种跟着指引点点点的东西没有游戏性，根本不能叫游戏，甚至是扫雷、蜘蛛纸牌、俄罗斯方块这些才能叫做游戏，一个RPG游戏整天无脑点点点到底有什么游戏性可言？</p><p>回归游戏的本质，“游戏的目的就存在于游戏行为自身之中，它伴有紧张和喜悦的感情与日常生活不同”。也就是说这些东西是不是游戏要分人的，如果玩这个东西能让你感觉到快乐、感觉到兴趣使然，那么它就是游戏，而对于我来说，这种东西我真的是不爱玩了。</p><p>现在的我想去试一试休闲游戏的开发，因为我觉得那才是我现在的兴趣点，是能给我带来快乐的游戏类型。</p><h1 id="我的历程"><a href="#我的历程" class="headerlink" title="我的历程"></a>我的历程</h1><p>人生进行到现在和游戏密不可分，接触电脑 -&gt; 报计算机专业 -&gt; 和同学一起打电脑游戏 -&gt; 毕业进行游戏开发 -&gt; MMORPG -&gt; 回合制卡牌。</p><p>喜欢的游戏类型也在悄然发生变化，小游戏 -&gt; 模拟经营养成类 -&gt; MOBA、FPS -&gt; MMORPG、回合制卡牌 -&gt; dota、休闲类，因为现在的网络游戏太肝了，所以渐渐只玩随时可以暂停的小游戏了。</p><p>现在的我也很迷茫，觉得自己并不是一个游戏开发人员，起码是不合格的，除了十几前年的学习机让我体验了几把游戏，后来的游戏机我是一窍不通，所以我也想回归游戏本质，去年年末我在便利店买了一个8090掌上游戏机，就是最原始的俄罗斯方块，玩了几次感觉挺好的。</p><p>这是我曾经梦寐以求却得不到的，现在终于有能力把它买回家好好玩了，经典的游戏永不过时。</p><p>买年货时又和老婆在商场的游戏厅体验了一下当年的手柄游戏，感觉这才有游戏的乐趣。</p><p>为了不与时代脱轨，我前段时间又在网上下单了台Switch游戏机，真的是查了很多资料才弄清楚要买什么，已经在海关卡了好几天了，估计还得至少半个月才能到我手中，希望我能从这个现代的游戏机中找到一点灵感。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>游戏本来的定义是指体育手段的一种，也是文化娱乐的一种形式，如今的社会将游戏狭义化成了网游</li><li>我与游戏有缘，从接触电脑、选择专业，到毕业后找到游戏开发工作，因为喜欢dota、所以选择游戏</li><li>我对于我开发游戏的喜欢不是因为游戏性，而是有一种作为自己产品的感情，所以我自己做的游戏我都有充钱，但并不是因为它好玩</li><li>同一款游戏中玩法思路也在变，之前玩dota总喜欢玩战士或刺客，享受对拼的感觉，而现在更喜欢玩法师，变着花样搞怪更有意思</li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/122916170" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>最近一周从好几个地方看到“人生的意义是什么”这个问题，有些问题我也做了回答，甚至很多人去请教了ChatGPT，但问这种问题真的有意义吗？问这种问题的人目前应该处于迷茫期，想要过来人提供一些答案，可人生必须要有意义吗？每个人的追求不同，人生意义的解释也就不同。我现在觉得清晨能看见一缕阳光，静静的呼吸着清晰的空气这就够了，如果还要奢侈一点，那么我想说“有事做，有人爱，有所期待”。</p><p>2023-2-5 19:03:15</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;现在一提到玩游戏很多人的第一反应就是『手游』『网游』，是社会的发展将“游戏”这个词狭义化了，甚至在搜索引擎中输入『游戏』一词，得到的前几页搜索结果都是手机游戏推荐，而游戏本来的定义是指体育手段的一种，也是文化娱乐的一种形式。以一定的形式反映人类社会劳动、军事、文化等方面的活动。&lt;/p&gt;
&lt;p&gt;称之为游戏论之父的豪伊金格说：“游戏是在明确规定的时间、空间里所进行的行为或者活动。它是按照自发接受的规则来进行的。这种规则一旦被接受就具有绝对的约束力。游戏的目的就存在于游戏行为自身之中，它伴有紧张和喜悦的感情与日常生活不同。”&lt;/p&gt;
    
    </summary>
    
      <category term="Thinking" scheme="http://AlbertGithubHome.github.io/blog/categories/Thinking/"/>
    
    
      <category term="工作" scheme="http://AlbertGithubHome.github.io/blog/tags/%E5%B7%A5%E4%BD%9C/"/>
    
      <category term="游戏" scheme="http://AlbertGithubHome.github.io/blog/tags/%E6%B8%B8%E6%88%8F/"/>
    
      <category term="想法" scheme="http://AlbertGithubHome.github.io/blog/tags/%E6%83%B3%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>跟风试试ChatGPT</title>
    <link href="http://AlbertGithubHome.github.io/blog/2023/02/05/%E8%B7%9F%E9%A3%8E%E8%AF%95%E8%AF%95ChatGPT/"/>
    <id>http://AlbertGithubHome.github.io/blog/2023/02/05/跟风试试ChatGPT/</id>
    <published>2023-02-05T08:55:19.000Z</published>
    <updated>2023-03-14T16:46:51.584Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>其实现在也不算是跟风了，从 <code>ChatGPT</code> 出现至今已经有几个月的时间，这股风似乎已经刮过去了，虽然各种新闻铺天盖地，但因为懒一直没有亲手试一试，这两天尝试了一下，发现要想使用还是有点门槛的，它使用方式很简单，可以把它想象成一个智能机器人，可以回答你的各种提问，当然它比淘宝机器人客服智能多了，它的门槛在于地域限制非常强，中国用户要想使用须得费一番功夫。</p><a id="more"></a><h1 id="什么是ChatGPT"><a href="#什么是ChatGPT" class="headerlink" title="什么是ChatGPT"></a>什么是ChatGPT</h1><p><code>ChatGPT</code> 以其强大的信息整合和对话能力惊艳了全球，是人工智能研究实验室OpenAI新推出的一种人工智能技术驱动的自然语言处理工具，使用了Transformer神经网络架构，也是GPT-3.5架构，能够在输入序列中捕捉长期依赖性。它还使用了大量的语料库来训练模型，这些语料库包含了真实世界中的对话，以便模型能够更好地理解人类语言。</p><h1 id="ChatGPT怎么玩"><a href="#ChatGPT怎么玩" class="headerlink" title="ChatGPT怎么玩"></a>ChatGPT怎么玩</h1><p>要想使用 <code>ChatGPT</code> 主要有以下几步：</p><ol><li>注册 ChatGPT 账号</li><li>完成 ChatGPT 手机号验证后登录</li><li>输入任意话题，探索 ChatGPT 的强大功能</li></ol><h2 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h2><ul><li>需要将网络环境切换成国外IP完成整个注册步骤（美国、加拿大、日本等，大陆IP肯定不行，香港澳门 IP 据说也不行）</li><li>访问 <a href="https://chat.openai.com/auth/login" target="_blank" rel="noopener">https://chat.openai.com/auth/login</a> 链接并使用自己的邮箱进行账号注册，我就偷了个懒使用 <code>Microsoft Account</code> 直接登录的</li><li>不管是用邮箱注册，还是第三方账号登录都需要打开邮箱查收 OpenAI 账号验证邮件，并完成邮箱验证</li></ul><h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><ul><li>登录成功之后需要验证手机号，这一步中国大陆手机号不好使，需要借助短信接码平台 <a href="https://sms-activate.org" target="_blank" rel="noopener">sms-activate.org</a></li><li>具体使用方法比较简单，可以自己试试或者百度一下，其实就是提供一个外国号码给我们验证使用，在网站上可以收验证码，把收到的验证码填到 ChatGPT 平台就可以完成验证了</li><li>使用前需要先用邮箱在 <code>sms-activate.org</code> 注册账号后充值，用支付宝可以自动转汇率充值，佣金2.3%，我充值的这段过年时间好像免佣金</li><li>一般充值0.2美元就可以，因为免佣金我充了0.5，方便以后再用</li><li>选择号码地区时尽量使用印度尼西亚，这个地区验证过了，没有问题</li></ul><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>直接在最下方的框中输入想问的问题就可以了，下面随便截两个问题，有些问题它还是答不上来的，我曾让它用 Python 画一个猪猪，每次代码生成约10分钟就卡主了，让它画一个兔子结果只画了耳朵。</p><h3 id="设计型"><a href="#设计型" class="headerlink" title="设计型"></a>设计型</h3><p><img src="https://img-blog.csdnimg.cn/8f92a30516954be1b5bc1aca27db583e.png#pic_center" alt="write_game"></p><hr><h3 id="开发型"><a href="#开发型" class="headerlink" title="开发型"></a>开发型</h3><p><img src="https://img-blog.csdnimg.cn/832b39cc853d453c82fc9f1a0bb212e1.png#pic_center" alt="c++"></p><hr><h3 id="强人所难型"><a href="#强人所难型" class="headerlink" title="强人所难型"></a>强人所难型</h3><p><img src="https://img-blog.csdnimg.cn/c2b194eec9eb4d00957f1d3478c311df.png#pic_center" alt="song"></p><h1 id="Python调用ChatGPT"><a href="#Python调用ChatGPT" class="headerlink" title="Python调用ChatGPT"></a>Python调用ChatGPT</h1><p>先去 <a href="https://beta.openai.com/account/api-keys" target="_blank" rel="noopener">https://beta.openai.com/account/api-keys</a> 点击 <code>Create new secret key</code> 按钮创建一个API密钥，然后赋值给下面代码中的 <code>openai.api_key</code> 变量直接运行就可以了</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> openai</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">use_openai</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># Set your API key</span></span><br><span class="line">    openai.api_key = <span class="string">"YOUR_API_KEY"</span></span><br><span class="line">    <span class="comment"># Use the GPT-3 model</span></span><br><span class="line">    completion = openai.Completion.create(</span><br><span class="line">        engine=<span class="string">"text-davinci-002"</span>,</span><br><span class="line">        prompt=<span class="string">"今天中午吃什么"</span>,</span><br><span class="line">        max_tokens=<span class="number">1024</span>,</span><br><span class="line">        temperature=<span class="number">0.5</span></span><br><span class="line">    )</span><br><span class="line">    <span class="comment"># Print the generated text</span></span><br><span class="line">    print(completion.choices[<span class="number">0</span>].text)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    use_openai()</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li><code>ChatGPT</code> 是经过训练的语言模型，以GPT-3.5为基础，其强大的信息整合和对话能力惊艳了全球</li><li><code>ChatGPT</code> 有时很聪明，仿佛是一个拥有了自己的智力，可以应对许多问题，甚至可以直接写代码</li><li><code>ChatGPT</code> 有时却很蠢，特意回避了一些问题，并认为加了一些限制，所以目前来看局限性还很大</li><li><code>ChatGPT</code> 注册登录地址 <a href="https://chat.openai.com/auth/login" target="_blank" rel="noopener">https://chat.openai.com/auth/login</a></li><li><code>ChatGPT</code> 短信验证可使用的第三方平台 <a href="https://sms-activate.org" target="_blank" rel="noopener">https://sms-activate.org</a></li><li><code>ChatGPT</code> 创建密钥地址 <a href="https://beta.openai.com/account/api-keys" target="_blank" rel="noopener">https://beta.openai.com/account/api-keys</a></li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/128731058" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>试图窥探整个世界的运行规律，至今一无所获~</p></blockquote><!--2023-1-31 00:57:05-->]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;其实现在也不算是跟风了，从 &lt;code&gt;ChatGPT&lt;/code&gt; 出现至今已经有几个月的时间，这股风似乎已经刮过去了，虽然各种新闻铺天盖地，但因为懒一直没有亲手试一试，这两天尝试了一下，发现要想使用还是有点门槛的，它使用方式很简单，可以把它想象成一个智能机器人，可以回答你的各种提问，当然它比淘宝机器人客服智能多了，它的门槛在于地域限制非常强，中国用户要想使用须得费一番功夫。&lt;/p&gt;
    
    </summary>
    
      <category term="AI" scheme="http://AlbertGithubHome.github.io/blog/categories/AI/"/>
    
    
      <category term="python" scheme="http://AlbertGithubHome.github.io/blog/tags/python/"/>
    
      <category term="OpenAI" scheme="http://AlbertGithubHome.github.io/blog/tags/OpenAI/"/>
    
      <category term="人工智能" scheme="http://AlbertGithubHome.github.io/blog/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
      <category term="智能机器人" scheme="http://AlbertGithubHome.github.io/blog/tags/%E6%99%BA%E8%83%BD%E6%9C%BA%E5%99%A8%E4%BA%BA/"/>
    
  </entry>
  
  <entry>
    <title>Windows10彻底关闭自动更新</title>
    <link href="http://AlbertGithubHome.github.io/blog/2023/02/05/Windows10%E5%BD%BB%E5%BA%95%E5%85%B3%E9%97%AD%E8%87%AA%E5%8A%A8%E6%9B%B4%E6%96%B0/"/>
    <id>http://AlbertGithubHome.github.io/blog/2023/02/05/Windows10彻底关闭自动更新/</id>
    <published>2023-02-05T08:53:53.000Z</published>
    <updated>2023-06-18T07:40:51.774Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在写这篇总结之前，我已经尝试过多次关闭<code>Win10</code>的自动更新了，一般来说更新之后可以使操作系统更加健壮，但总会有一些原因让我们不想更新，比如我最近总是需要远程操作电脑，如果它临时更新会导致我无法继续使用，所以我一般会关掉更新，然后在一个空闲的时间让他尽情更新个够。</p><a id="more"></a><p>网上有很多关于停止自动更新的文章，有些操作起来比较简单，有些则非常繁琐，但大多数教程都不太好使，很多时候就是临时有效，过段时间就又开始自动更新了，这让我想起了很久之前设计的流氓软件。</p><h1 id="无赖"><a href="#无赖" class="headerlink" title="无赖"></a>无赖</h1><p>一个软件会有一个正常的A进程，然后还有一个默默守护着A进程的B进程，当B进程发现一段时间内A进程不见了，就自动启动A进程，如果担心B进程被发现，还可以搞一个默默守护B进程的C进程，子子孙孙无穷尽也。</p><p>操作系统的自动更新当然不会这么直白，但是禁用之后还能自动启动，说明一定有其他的东西在默默的守护着他，如果找到这些守护者，把他们干掉，自动更新也就被真正禁止了。</p><h1 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h1><h2 id="关闭自动更新服务"><a href="#关闭自动更新服务" class="headerlink" title="关闭自动更新服务"></a>关闭自动更新服务</h2><p>按下快捷键 <code>Win+R</code> 打开运行对话框，输入<code>services.msc</code>，点击『确定』按钮或者直接回车打开服务页面</p><p><img src="https://img-blog.csdnimg.cn/3997daa12352465eb471729574b2c31e.png#pic_center" alt="win-update1"></p><p>如图所示，找到 <code>Windows Update</code> 双击打开属性</p><p><img src="https://img-blog.csdnimg.cn/e75a4b851099431c9f16597b2d57a6cd.png#pic_center" alt="win-update2"></p><p>在 <code>Windows Update</code> 属性页面的『常规』选项卡中，将启动类型设置为选择『禁用』，一次点击『停止』『应用』按钮</p><p><img src="https://img-blog.csdnimg.cn/6981925bd9964cde850a3c9931765907.png#pic_center" alt="win-update3"></p><p>我们点击切换到『恢复』选项卡中，将失败后的操作均设置为『无操作』后，点击『应用』按钮</p><p><img src="https://img-blog.csdnimg.cn/d5eb184dbfe64fbfb39db7dadb61371a.png#pic_center" alt="win-update4"></p><p>按照相同的方式处理 <code>Update Orchestrator Service</code> 服务，有些电脑中名字是 <code>更新 Orchestrator  服务</code>，也是按照上面的方法设置『常规』和『恢复』两个选项卡就好。</p><h2 id="关闭自动更新策略"><a href="#关闭自动更新策略" class="headerlink" title="关闭自动更新策略"></a>关闭自动更新策略</h2><p>上面的步骤是很多教程中都提到的，一开始耗时，过一段时间发现又开始自动更新了，所以要按照后面的步骤继续操作一下。</p><p>按下快捷键 <code>Win+R</code> 打开运行对话框，输入<code>gpedit.msc</code>，点击『确定』按钮或者直接回车打开组策略编辑器</p><p><img src="https://img-blog.csdnimg.cn/348414254f2c4d718d3ae65ec4620336.png#pic_center" alt="win-update5"></p><p>依次打开树形结构中『计算机配置』-『管理模板』-『Windows组件』-『Windows更新』，双击打开右侧『配置自动更新』选项</p><p><img src="https://img-blog.csdnimg.cn/0db795e01c614b25ad29dbcf1128ba92.png#pic_center" alt="win-update6"></p><p>在弹出的界面中选择『已禁用』，然后点击『应用』『确定』按钮</p><p><img src="https://img-blog.csdnimg.cn/1aeea34f09a64a3b81e3b8fa51582b59.png#pic_center" alt="win-update7"></p><p>继续在右侧找到『删除使用所有Windows更新功能的访问权限』选项，双击打开</p><p><img src="https://img-blog.csdnimg.cn/1afd215705ce4014a5a069fbde01ec1e.png#pic_center" alt="win-update8"></p><p>在弹出的界面中选择『已启用』，然后点击『应用』『确定』按钮</p><p><img src="https://img-blog.csdnimg.cn/7ed9717b421c4c7d9186b46ab9a4dc3f.png#pic_center" alt="win-update9"></p><p>至此就设置完了，以后Windows10就不会偷偷摸摸的自动更新了</p><h1 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h1><p>我司的电脑上安装有安全监测软件，之前我关闭自动更新服务器时该软件只是给我提示个警告，提醒我要保持自动更新的好习惯，但是当我设置完更新组策略之后，安全软件直接提示我已经高危风险了，并且提示将在10分钟后给我自动断网，说明这次的禁用真的生效了，无奈，为了上网我还是还原了更新组策略的设置。</p><p><img src="https://img-blog.csdnimg.cn/6160d8c31ee045549c1685aa6b7c3788.png#pic_center" alt="win-update10"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>网上的教程虽然多，但要注意甄别，找到好使的方案记下来，方便日后重复操作</li><li>关闭Windows自动更新，不仅要关闭自动更新的服务，还要设置更新组策略，防止死灰复燃</li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/128509220" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>得不到的永远在躁动，被偏爱的都有恃无恐~</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;在写这篇总结之前，我已经尝试过多次关闭&lt;code&gt;Win10&lt;/code&gt;的自动更新了，一般来说更新之后可以使操作系统更加健壮，但总会有一些原因让我们不想更新，比如我最近总是需要远程操作电脑，如果它临时更新会导致我无法继续使用，所以我一般会关掉更新，然后在一个空闲的时间让他尽情更新个够。&lt;/p&gt;
    
    </summary>
    
      <category term="windows" scheme="http://AlbertGithubHome.github.io/blog/categories/windows/"/>
    
    
      <category term="Win10" scheme="http://AlbertGithubHome.github.io/blog/tags/Win10/"/>
    
      <category term="update" scheme="http://AlbertGithubHome.github.io/blog/tags/update/"/>
    
      <category term="关闭自动更新" scheme="http://AlbertGithubHome.github.io/blog/tags/%E5%85%B3%E9%97%AD%E8%87%AA%E5%8A%A8%E6%9B%B4%E6%96%B0/"/>
    
      <category term="自动更新" scheme="http://AlbertGithubHome.github.io/blog/tags/%E8%87%AA%E5%8A%A8%E6%9B%B4%E6%96%B0/"/>
    
      <category term="service" scheme="http://AlbertGithubHome.github.io/blog/tags/service/"/>
    
  </entry>
  
  <entry>
    <title>2022年终总结——人生中最美好的一站</title>
    <link href="http://AlbertGithubHome.github.io/blog/2023/02/05/2022%E5%B9%B4%E7%BB%88%E7%BB%93%E2%80%94%E2%80%94%E4%BA%BA%E7%94%9F%E4%B8%AD%E6%9C%80%E7%BE%8E%E5%A5%BD%E7%9A%84%E4%B8%80%E7%AB%99/"/>
    <id>http://AlbertGithubHome.github.io/blog/2023/02/05/2022年终结——人生中最美好的一站/</id>
    <published>2023-02-05T08:51:25.000Z</published>
    <updated>2023-02-05T08:58:29.026Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>有一种责任与压力，叫做上有老下有小，但有一种幸福也叫做上有老下有小，当你遭遇挫折与困难时，这些“老小”以及那个同龄的“她”是你坚实的后盾，同时也是你最后的港湾~</p></blockquote><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>2022年已经接近尾声，在经历了多次封控之后终于趁着元旦假期回到老家，和家人聚在了一起，这种平淡的幸福正是我想要的，作为普通平淡的人，我没有拯救世界的梦想，也没达到忧国忧民的高度，我就是芸芸众生中的一员，渴望过着普通而平淡的人生。</p><a id="more"></a><p>我深知这种平凡的生活来之不易，更知许多人为了这份平凡在负重前行，感恩我们这个和平的环境和为了这份和平在努力付出的人，我会好好珍惜。</p><h1 id="回顾2022"><a href="#回顾2022" class="headerlink" title="回顾2022"></a>回顾2022</h1><p>去年依旧设立了不少目标，虽然总体上完成的不太好，但还是要勇敢面对，接下来会逐个回顾一下。</p><h2 id="工作上"><a href="#工作上" class="headerlink" title="工作上"></a>工作上</h2><blockquote><p>FLAG</p><ul><li>继续踏实做好本职工作，做好工作内容的总结，落实到纸上</li><li>学习和了解常见中间件的使用，更多的参与设计的工作</li></ul><p>完成度 ： 90%</p></blockquote><p>个人的性格决定了我不能摆烂，所以对待任何事情都比较认真，对待各项工作也是比较谨慎的，一直在踏踏实实的完成，做好日报记录和周报总结，好记性不如烂笔头，有些问题记录下来再回过头查找时会非常方便。</p><p>时代在发展，落实到纸上已经不单单指的是“纸”，而是一切可以记录新的媒介，电子版的记录还有一个非常大的好处就是查找信息方便，这可以大大加快我们解决问题的速度，不过我读书时还是喜欢写在纸上，不太喜欢电子版的书籍。</p><p>今年工作上有一个比较大的变化就是，从一个被动的执行者转变成了一个初级的管理者，这个身份的转变给我带来了机会，同时也带来了不小的挑战，关于设计工作也一直在进行，因为目前的身份导致我必须做一些决定，所以这部分工作是逃不开的。</p><p>通过一些课程学习和与大佬的沟通的交流后发现，管理重点不在“管”而在“理”，管理者并没有身份上的优越感，而在于合理的分配自己拥有的资源，巧妇难为无米之炊，手上什么也没有，最后肯定完不成任务。</p><p>在管理者的岗位上，自己能调动的一切皆为“资源”，这些包括时间、金钱、合作、甚至是人员，合理的调配这些才能达到最大的效果，否则就会产生浪费，效果也大大折扣。</p><p>这个Flag中的扣分项应该是学习和了解常见中间件的使用，今年确实使用和配置过一些中间件，但是没有好好的系统的学习，这方面后面要加油了。</p><p>今年关于工作上的付出基本达到最大化了，最近一段时间为了阶段性版本，大多数都是后半夜才能回家了，很累，但是并不排斥，我喜欢自己做的东西，为了取得好的结果，目前的付出是值得的。</p><h2 id="学习上"><a href="#学习上" class="headerlink" title="学习上"></a>学习上</h2><blockquote><p>FLAG</p><ul><li>博客总结不能落，继续保持一周一更，完成40篇基础目标</li><li>刷题不用太频繁，每周总得有贡献，不可抗拒因素除外</li><li>建立自己的技能树，搭配工作总结，统计出自己到底会什么</li><li>选取经典开源代码学习，代码量要少一点，毕竟精力有限了</li><li>读书、读书、读书，书都买好了</li></ul><p>完成度 ： 70%</p></blockquote><p>博客总结flag达标，依旧是40篇踩线通过，今年CSDN改变挺大的，但不影响我在上面记录工作学习内容的初衷，40篇博客内容比较基础，大多数来源于工作之中，也有一部分来源与生活需求，简单记录，记忆珍存，以下是近两年的数据对比。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/a3c1985ca04500715bbdc1bf96e6c042.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9hbGJlcnRnaXRodWJob21lLmdpdGh1Yi5pby9ibG9nL2Fib3V0,size_14,color_FFFFFF,t_70#pic_center" alt="2021csdn"><br><img src="https://img-blog.csdnimg.cn/14783313ca054a32b757f8891a07624b.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9hbGJlcnRnaXRodWJob21lLmdpdGh1Yi5pby9ibG9nL2Fib3V0,size_14,color_FFFFFF,t_70#pic_center" alt="2022csdn"><br>今年的博客还诞生了第一篇浏览量过10W的文章，<a href="https://blog.csdn.net/albertsh/article/details/92385277" target="_blank" rel="noopener">《float的精度和取值范围》</a>，目前浏览量到达了117805，这篇总结当初确实花了不少时间，也侧面说明了高质量的文章才能得到粉丝的认可。</p><p>今年的CSDN玩出了不少新花样，特别是与博主的互动上，经常会发一些实体的证书，虽然这些东西不值什么钱，但是对博主来说得到认可还是很开心的。</p><p><img src="https://img-blog.csdnimg.cn/ad5b7fa66d3f4d63990f04aa1ff88752.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9hbGJlcnRnaXRodWJob21lLmdpdGh1Yi5pby9ibG9nL2Fib3V0,size_14,color_FFFFFF,t_70#pic_center" alt="csdn证书"><br>关于刷题这个Flag今年的情况有点拉跨，别说参加比赛了，每周的刷题数也保证不了，时间真的不太够用，虽然这听起来像是在找理由，但确实是客观存在的，毕竟从早上9点工作到凌晨4点，我是真的抽不出时间来刷题了，还是要命的，活着才有未来，噶了就什么都没了。</p><p><img src="https://img-blog.csdnimg.cn/4a551c2c1ca44c68ae4415e5281ca036.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9hbGJlcnRnaXRodWJob21lLmdpdGh1Yi5pby9ibG9nL2Fib3V0,size_14,color_FFFFFF,t_70#pic_center" alt="LeetCode2022"></p><p>建立自己的技能树，这方面已经着手开始做了，目前只列举了一个大概的<a href="http://www.008ct.top/images/knowledgehierarchy.png" target="_blank" rel="noopener">知识框架</a>，今后会随着工作和学习继续补充，主要是总结自己，为今后的职业发展打好基础。</p><p><img src="https://img-blog.csdnimg.cn/d082096395ac4863893dfb4a9edd2058.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9hbGJlcnRnaXRodWJob21lLmdpdGh1Yi5pby9ibG9nL2Fib3V0,size_14,color_FFFFFF,t_70#pic_center" alt="2022知识框架"><br>读取经典开源代码这个Flag今年完成的最差了，几乎没有什么进展，阅读代码一直被项目牵着走，代码确实没少读，一直在Code Review，完整的开源项目几乎没有读，不过发现了一个 magic_enum 项目还不错，把他按照项目需求改造了一下，目前正在使用。</p><p>读书一直在进行，中间因为身体原因和项目忙的原因暂停过一段时间，不过去年Flag列举的书单都翻了翻，毕竟书都买回来了，但是有些真的不适合精读，比如民法典，有空了翻一翻还是比较有意思的。</p><ul><li>股票大作手回忆录（2022-02-12 22:58:39）<ul><li>顺势而为，不与大盘做对，永远朝着阻力小的方向操作</li></ul></li><li>世界很烦，但你要很可爱（2022-02-28 07:09:45）<ul><li>不管别人对你如何，请记得一定要对自己好一点儿</li></ul></li><li>洛克菲勒写给儿子的38封信<ul><li>商人就是靠创造资源、掠夺他人的资源，甚至逼迫他人转让自己的资源来致富的。</li></ul></li><li>两次全球大危机的比较研究<ul><li>经济发展比较注重效率，收入分配比较关注公平</li></ul></li><li>创华为 —— 任正非传（2022-07-17 11:00:19）<ul><li>你不要说未来有什么贡献，万一活不到未来，未来的贡献和我们没有关系</li></ul></li><li>孙子兵法与三十六计（没看完）<ul><li>历史总是在重演，只有胜利的人才能诉说</li></ul></li><li>世界经济简史（看了一点）<ul><li>原始的经济就不纯粹</li></ul></li><li>民法典（翻阅）<ul><li>没想到这么薄薄的一本干掉了那么多大部头</li></ul></li><li>活着（2022-12-17 11:22:10）<ul><li>生活是属于每个人自己的感受，不属于任何别人的看法</li></ul></li></ul><p>《创华为》是一部任正非的传记，这是继《乔布斯传》之后我读的有一本比较厚的传记书籍了，大佬们的经历总是能鼓舞人心，虽然有些描写我觉得不真实，但是所有的经历不太可能都是伪造的，去伪存真，相信那些正能量的内容。</p><p>《活着》这本书很出名，但是我读了一遍感觉这本书宣传时给我的印象完全不同，整本书的描写朴实无华，就真的像我等小老百姓在村头树下闲聊，很多情景并没有刻意描写，“她死了”——仅仅三个字就断送了别人姓名，并没有更多的叙述。读过之后我并没有觉得富贵有多惨，这就是那个时代的一个缩影，他不仅不惨，而且也经历过很多人没有经历过的幸福，有一个衣食无忧的童年，有一个不离不弃的妻子，经历战乱却活了下来…</p><h2 id="投资上"><a href="#投资上" class="headerlink" title="投资上"></a>投资上</h2><blockquote><p>FLAG</p><ul><li>基金和ETF继续定投，适当配置债券固收</li><li>股票池里把曾经“瞎选”的股票逐渐出清，依旧拥抱大白马，少折腾</li><li>目标收益不太高，8个点，希望不要打脸</li></ul><p>完成度：85%</p></blockquote><p>今年的投资严格按照Flag策略执行，基金和ETF持续定投，目前有周定投和月定投两套策略，中概、恒生、红利还设置了智能条件单，不主动干预，实现被动调仓，只是最后的收益结果没有达标(ಥ_ಥ)</p><p>曾经瞎选的股票也出清了一部分，有一只最多赔了90%的票拿了5年，今年回本之后也卖掉了，所以只要股票不退市都有回本的机会。</p><p>持仓依旧银地保三傻和大白马——万安招富，虽然没挣钱，但今年的回撤控制的还可以，做了一波过山车，4月份感觉股市要崩了，6月份股市要飞了，不仅回本还有了盈利，10月份股市要炸了，12月份又飘起来了，可谓一波三折。</p><p><img src="https://img-blog.csdnimg.cn/49493ec0b75a4f3ea24b89a43c390832.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9hbGJlcnRnaXRodWJob21lLmdpdGh1Yi5pby9ibG9nL2Fib3V0,size_14,color_FFFFFF,t_70#pic_center" alt="2022投资"></p><p>本来在2021年已经预测2022在加息周期中，能保住本金就可以了，没想到又遭遇俄乌战争，疫情反复，股市受到了比较大的冲击，不过结果还是不错的，虽然Flag想达到8%，最终收益达到了6.72%，也还可以接受，不过基金和ETF有点浮亏，吃掉了股票的部分收益，整体上略有盈余。</p><h2 id="生活上"><a href="#生活上" class="headerlink" title="生活上"></a>生活上</h2><blockquote><p>FLAG</p><ul><li>疫情结束了多回几次老家吧，去看看那些想我又不愿说出口的亲人</li><li>注重身体的保养，锻炼提上日程，降低亮红灯的指标</li></ul><p>完成度60%</p></blockquote><p>生活上的Flag是完成的最差的，本来想今年疫情结束多回几次老家，结果今天封闭的时间最长，刚刚统计完2022年算上春节假期一共回家14天，达到了历史最低值。</p><p>身体的保养和锻炼更是拉跨，年初的时候因为胸腔疼痛，3、4月份吃了两个月的中药来调理，医生告诉我不要熬夜，晚上10点准时睡觉，这几乎是不可能完成的任务，每天有太多的事情需要忙了，不过今年体检各项指标比较稳定，注意血压、视力和肝脏。</p><p>有趣的是这个中医岁数不大，但是找他看病的人很多，每次门诊都持续到晚上12点钟，医生门诊持续到12点这还是我第一次遇到，所以我每次挂号都看一下时间，大概每次都赶在周六晚上9点去找他，当有一次他告诉我要10点钟睡觉时，我反问还在忙碌的他为什么不10点睡，他只说了一句：“你比我幸福”。其实就是生活所迫呗，他因为工作无法按时睡觉，我又何尝不是呢？</p><p>今年陪娃的时间不太多，娃娃也顺利的上了幼儿园，认识了很多小伙伴，虽然因为疫情只上了1个多月，但每天还是开开心心的。我因为有两个月封控在家，在一起相处的时间还蛮多的，但是也在忙于工作，居家办公导致生活和工作融在一起，无法分割，个人不太喜欢长时间处在这种环境下，还是喜欢公司办公，回家陪娃的日子。</p><p><img src="https://img-blog.csdnimg.cn/ce62daf422b44245899491810d55e7d4.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9hbGJlcnRnaXRodWJob21lLmdpdGh1Yi5pby9ibG9nL2Fib3V0,size_14,color_FFFFFF,t_70#pic_center" alt="2022花草"></p><p><img src="https://img-blog.csdnimg.cn/f2a844cb01e64694978d44c0eb052cc9.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9hbGJlcnRnaXRodWJob21lLmdpdGh1Yi5pby9ibG9nL2Fib3V0,size_14,color_FFFFFF,t_70#pic_center" alt="2022花草2"></p><p>去年总结中提到的那批多肉，今年一年过得不错，长势喜人，已经成了我的小花园中重要的组成部分，今年12月初的时候又买了一批，还买了几颗文竹，结果花盆到了、营养土到了，这都新年了多肉和文竹还没到，看来得等到春天才能发货了。</p><h1 id="展望2023"><a href="#展望2023" class="headerlink" title="展望2023"></a>展望2023</h1><h2 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h2><ul><li>适应自己身份的转变，提升自己的管理技能，做一名合格的管理者</li><li>继续做好本职可开发工作，做好工作内容的总结，推动新项目顺利上线</li><li>根据自己的技能树框架，查漏补缺，有针对性的学习和探索</li></ul><h2 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h2><ul><li>继续博客总结，40篇是基础线，2023要超过这个值，尽量一周一篇，放假可休息</li><li>新的一年依旧很忙，刷题不强制要求，每周最好有贡献，每月必须有输出</li><li>在现有的技能树框架上继续丰富，做到枝繁叶茂，试试找点副业</li><li>开源代码还是以项目为驱动，选取经典实现，比如kafka</li><li>继续读书，今年书也买好了，数量不多，下半年应该还会买一批</li></ul><p><img src="https://img-blog.csdnimg.cn/bf7a7540f0e8452eb7ae89bea39fe9d5.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9hbGJlcnRnaXRodWJob21lLmdpdGh1Yi5pby9ibG9nL2Fib3V0,size_14,color_FFFFFF,t_70#pic_center" alt="2022读书"></p><h2 id="投资"><a href="#投资" class="headerlink" title="投资"></a>投资</h2><ul><li>定投和智能条件单保持现状，ETF追加1~2个新的行业赛道</li><li>股票池还有几个垃圾票要找机会清理掉，手里的价投股票适当做做趋势</li><li>保持对新年经济的乐观，目标收益10个点</li></ul><h2 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h2><ul><li>疫情放开了，有事没事都趁着假期回家看看</li><li>身体很重要，锻炼的很费时，中和一下，可以跳跳绳</li><li>周末了陪娃耍一耍，工作尽量不占用周末的时间</li></ul><p><img src="https://img-blog.csdnimg.cn/3498339b668148a5a3b56452a64badc2.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9hbGJlcnRnaXRodWJob21lLmdpdGh1Yi5pby9ibG9nL2Fib3V0,size_14,color_FFFFFF,t_70#pic_center" alt="2022生活"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>旧的一年虽然看起来很拉跨，但我认为是人生中最美好的一站，因为照片人上的人都还在，而我也在成长</li><li>新的一年稳中向好，不盲目乐观，也不宜过分悲观，投资环境应该会转好</li><li>身体方面自己要多注意，有些情况并不是自己要熬夜，其实多为生活所迫，若衣食无忧，谁甘愿拼搏</li><li>珍惜周末时光，珍惜和家人在一起的日子，收起自己的坏脾气</li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/128432753" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>往昔总是回忆情，未来光景亦可期。<br>若问此生弥珍贵，还看今朝不分离。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;有一种责任与压力，叫做上有老下有小，但有一种幸福也叫做上有老下有小，当你遭遇挫折与困难时，这些“老小”以及那个同龄的“她”是你坚实的后盾，同时也是你最后的港湾~&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;2022年已经接近尾声，在经历了多次封控之后终于趁着元旦假期回到老家，和家人聚在了一起，这种平淡的幸福正是我想要的，作为普通平淡的人，我没有拯救世界的梦想，也没达到忧国忧民的高度，我就是芸芸众生中的一员，渴望过着普通而平淡的人生。&lt;/p&gt;
    
    </summary>
    
      <category term="Thinking" scheme="http://AlbertGithubHome.github.io/blog/categories/Thinking/"/>
    
    
      <category term="总结" scheme="http://AlbertGithubHome.github.io/blog/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="工作" scheme="http://AlbertGithubHome.github.io/blog/tags/%E5%B7%A5%E4%BD%9C/"/>
    
      <category term="学习" scheme="http://AlbertGithubHome.github.io/blog/tags/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="生活，投资" scheme="http://AlbertGithubHome.github.io/blog/tags/%E7%94%9F%E6%B4%BB%EF%BC%8C%E6%8A%95%E8%B5%84/"/>
    
  </entry>
  
  <entry>
    <title>圣诞平安夜了还要继续敲代码吗</title>
    <link href="http://AlbertGithubHome.github.io/blog/2022/12/25/%E5%9C%A3%E8%AF%9E%E5%B9%B3%E5%AE%89%E5%A4%9C%E4%BA%86%E8%BF%98%E8%A6%81%E7%BB%A7%E7%BB%AD%E6%95%B2%E4%BB%A3%E7%A0%81%E5%90%97/"/>
    <id>http://AlbertGithubHome.github.io/blog/2022/12/25/圣诞平安夜了还要继续敲代码吗/</id>
    <published>2022-12-24T16:26:13.000Z</published>
    <updated>2023-03-04T10:29:22.995Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>此时不敲，更待何时~</p></blockquote><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>先不说圣诞节算不算我们的节日，单纯就节日还要不要敲代码这个问题来说，每个程序猿/媛都有自己的答案。如果说你把工作敲代码当做一种负担，那么节假日正好可以作为自己休息的理由，好好休息一下也是不错的选择；如果把敲代码作为一种乐趣，那么节假日难得清净，少了很多杂事的打扰，正好是敲代码的黄金时间段，想一下自己的状态很容易就应该明白了。</p><a id="more"></a><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="节日"><a href="#节日" class="headerlink" title="节日"></a>节日</h2><p>圣诞节很明显不是我们的传统节日，应该被归为“洋节”一类，有些人对这些外来节日特别喜欢，同时也有人对此特别排斥，每个人都有自己的理由，其实不止是对这些节日，人们对于其他任何事物都存在着截然相反的评价，这些评价通常是基于自身利益、过往经验而给出的，它代表了每个人的想法，这些想法不是一成不变的，随着时间的推移，人们对它的评价甚至会走到相反的对立面。</p><p>我觉得不必过分排斥这些节日，一些人推崇这些节日自然有他们的目的，比如一些商家为了销售业绩往往会推一些节日活动，如果我们也能在这些活动中获得优惠，那么何乐而不为呢？</p><p>无论是中国节还是“洋节”出现的原因基本都是用来纪念一些事件或者寄托某种情感的，但是节日的这些属性在如今这个快节奏的社会环境下渐渐淡化，人们更多的是希望在节日假期中能好好的放松一下。</p><h2 id="代码与技术"><a href="#代码与技术" class="headerlink" title="代码与技术"></a>代码与技术</h2><p>写代码对我来说算是一种爱好，没有达到痴迷的程度，但是有空了还是想随便写点东西，不过今天只写了一点点，毕竟今天周末，多花了点时间陪伴家人，最近一段时间太忙了，心中总是有所亏欠，暂时停下来歇一歇。</p><p>每次进入新的领域时总是一头雾水，当渐渐入门以后便会发现一些规律，最近发现linux中也有很多蹭热度的命令，比如 <code>ls</code> 这个命令实在太常用了，可以展示指定目录下的所有文件，<code>lscpu</code>、<code>lsgpu</code>、<code>lsmem</code>、<code>lspci</code>、<code>lsusb</code> 这些命令的出现我觉得就是在蹭 <code>ls</code> 的热度。</p><p>除了 <code>ls</code> 还有一个 <code>top</code> 命令用来展示正在运行的进程信息，<code>iftop</code>、<code>iotop</code>、<code>htop</code>、<code>atop</code> 这些命令自然是蹭了它的热度，起一个相似度很高的名字，然后便于自己推广。</p><p>上面 <code>ls</code> 和 <code>top</code> 两个被蹭热度的命令，与后续命令还有有相似的功能，比如 <code>ls</code> 展示目录下的所有文件，而 <code>lscpu</code> 是用来展示 cpu 信息的，那么 “ls” 变成了一个基础功能的代表，就是用来展示信息，类似于英语中的词根，以及汉字中的偏旁。</p><p>而编程语言的历史上，还有一对完全为了蹭热度没有任何关系的语言，那就是 java 和 javascript 语言，<code>javascript</code> 在当时为了推广自己蹭了流行语言 <code>java</code> 的热度，它俩实际的关系就像是周杰和周杰伦的关系，仅仅是名字长得像罢了。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li><code>ls</code> 家族有 <code>lscpu</code>、<code>lsgpu</code>、<code>lsmem</code>、<code>lspci</code>、<code>lsusb</code> 等命令</li><li><code>top</code> 家族有 <code>iftop</code>、<code>iotop</code>、<code>htop</code>、<code>atop</code> 等命令</li><li>把写代码当做一种兴趣爱好，其实没有什么节假日，想写就写咯</li></ul><center><a href="https://blog.csdn.net/albertsh/article/details/128367971" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>当下的今天就是最好的，我不想回退到之前人生中的任何一个时间点。我一直有这种感觉，今天是最好的，所以珍惜现在拥有的一切，我不想让自己产生回退到过去的想法，因为那样肯定是发生了痛苦的事情。恰好今天和她看了《想见你》这部穿越剧，更加深了我的这种想法，今天就是最好的。</p><p>2022-12-25 01:37:25</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;此时不敲，更待何时~&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;先不说圣诞节算不算我们的节日，单纯就节日还要不要敲代码这个问题来说，每个程序猿/媛都有自己的答案。如果说你把工作敲代码当做一种负担，那么节假日正好可以作为自己休息的理由，好好休息一下也是不错的选择；如果把敲代码作为一种乐趣，那么节假日难得清净，少了很多杂事的打扰，正好是敲代码的黄金时间段，想一下自己的状态很容易就应该明白了。&lt;/p&gt;
    
    </summary>
    
      <category term="Thinking" scheme="http://AlbertGithubHome.github.io/blog/categories/Thinking/"/>
    
    
      <category term="工作" scheme="http://AlbertGithubHome.github.io/blog/tags/%E5%B7%A5%E4%BD%9C/"/>
    
      <category term="学习" scheme="http://AlbertGithubHome.github.io/blog/tags/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="生活" scheme="http://AlbertGithubHome.github.io/blog/tags/%E7%94%9F%E6%B4%BB/"/>
    
      <category term="linux" scheme="http://AlbertGithubHome.github.io/blog/tags/linux/"/>
    
      <category term="节日" scheme="http://AlbertGithubHome.github.io/blog/tags/%E8%8A%82%E6%97%A5/"/>
    
  </entry>
  
  <entry>
    <title>Nginx的安装与常用配置</title>
    <link href="http://AlbertGithubHome.github.io/blog/2022/12/19/Nginx%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE/"/>
    <id>http://AlbertGithubHome.github.io/blog/2022/12/19/Nginx的安装与常用配置/</id>
    <published>2022-12-18T17:11:36.000Z</published>
    <updated>2023-03-04T10:29:22.915Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Nginx 是开源、高性能、高可靠的 Web 和反向代理服务器，而且支持热部署，几乎可以做到 7 * 24 小时不间断运行，出镜率很高，从2004年发布至今，凭借开源的力量，日趋完善。其占用内存少、并发能力强、并且Nginx 是免费的还可以商业化，配置使用也比较简单。</p><a id="more"></a><h1 id="常用功能"><a href="#常用功能" class="headerlink" title="常用功能"></a>常用功能</h1><h2 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h2><p>Nginx 可以用作正向代理和反向代理，而在做反向代理时，能提供性能稳定，且配置灵活的转发功能</p><h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><p>Nginx 对于负载均衡策略提供了内置策略和扩展策略。内置策略有轮询，加权轮询，IP哈希。而扩展策略，就可以随心所欲了，只要遵循规则就可以搞出各种花样。</p><h2 id="静态资源服务"><a href="#静态资源服务" class="headerlink" title="静态资源服务"></a>静态资源服务</h2><p>Nginx 可以通过本地文件系统提供服务</p><h2 id="web缓存服务器"><a href="#web缓存服务器" class="headerlink" title="web缓存服务器"></a>web缓存服务器</h2><p>Nginx 可以对不同的文件做缓存处理，配置灵活，支持FastCGI_Cache，可用于对 FastCGI 的动态程序进行缓存。配合着第三方的ngx_cache_purge可以对制定的URL缓存内容进行增删管理。</p><hr><h1 id="插播快讯"><a href="#插播快讯" class="headerlink" title="插播快讯"></a>插播快讯</h1><p>本来今天打算总结一下Nginx的安装和使用的，结果中午的几个未接电话打破了宁静，游戏居然进不去了，看到几个未接电话就觉得不妙了，了解完情况才知道居然是阿里云香港C区的服务器挂了，本来觉得很快就能恢复，但随着时间的推移和官方的不表态，渐渐发现事情没有这么简单，虽然在过去好几个小时以后更新了公告，但这反应速度也太慢了。</p><p>现在已经过去了10多个小时（2022-12-18 10:47:22开始），尽管最新的公告说机房已经恢复，产品功能还在陆续恢复，但我们的游戏现在（2022-12-19 02:10:06）依旧处于停服状态，目前的云服务器依旧不可用，我还在等实在是写不下去了，关于Nginx的使用后面再补充吧，现在只希望云服务器能快点恢复。</p><blockquote><p>【已恢复】阿里云香港地域电讯盈科机房制冷设备故障<br>尊敬的客户：<br>   您好！阿里云监控发现香港地域某机房设备异常，影响香港地域可用区C的云服务器ECS、云数据库PolarDB等云产品使用，阿里云工程师已在紧急处理中，非常抱歉给您的使用带来不便，若您有任何问题，请随时联系我们。<br>—进展更新—<br>尊敬的客户：<br>   您好！经排查，阿里云香港地域故障确认系香港PCCW机房制冷设备故障所致，影响香港地域可用区C的云服务器ECS、云数据库、存储产品（对象存储、表格存储等）、云网络产品（全球加速、NAT网关、VPN网关等）等云产品使用。这一故障也影响了香港地域控制台访问和API调用操作，目前阿里云工程师在配合PCCW机房工程师加速处理，部分制冷设备正在恢复中。非常抱歉给您的使用带来不便。若您有任何问题，请随时联系我们。<br>—进展更新—<br>尊敬的客户：</p><h2 id="您好！目前阿里云所租用的香港电讯盈科公司机房已修复制冷设备故障，阿里云香港地域所有可用区云产品功能正在陆续恢复正常。对于受本次故障影响的产品，阿里云将根据相关产品的SLA协议进行赔付。非常抱歉给您的使用带来的不便-，若您有任何问题，请随时联系我们。"><a href="#您好！目前阿里云所租用的香港电讯盈科公司机房已修复制冷设备故障，阿里云香港地域所有可用区云产品功能正在陆续恢复正常。对于受本次故障影响的产品，阿里云将根据相关产品的SLA协议进行赔付。非常抱歉给您的使用带来的不便-，若您有任何问题，请随时联系我们。" class="headerlink" title="   您好！目前阿里云所租用的香港电讯盈科公司机房已修复制冷设备故障，阿里云香港地域所有可用区云产品功能正在陆续恢复正常。对于受本次故障影响的产品，阿里云将根据相关产品的SLA协议进行赔付。非常抱歉给您的使用带来的不便 ，若您有任何问题，请随时联系我们。"></a>   您好！目前阿里云所租用的香港电讯盈科公司机房已修复制冷设备故障，阿里云香港地域所有可用区云产品功能正在陆续恢复正常。对于受本次故障影响的产品，阿里云将根据相关产品的SLA协议进行赔付。非常抱歉给您的使用带来的不便 ，若您有任何问题，请随时联系我们。</h2></blockquote><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>Nginx服务器配置方便、高效可靠，可以用作反向代理、负载均衡、静态资源服务、Web缓存服务等</li></ul><center><a href="https://blog.csdn.net/albertsh/article/details/128178632" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>生活是属于每个人自己的感受，不属于任何别人的看法~ 阿根廷夺冠了，虽然我从不看球，但这场比赛真的跌宕起伏，不到最后一秒永远不知道会发生什么~</p><p>2022-12-19 02:14:22</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;Nginx 是开源、高性能、高可靠的 Web 和反向代理服务器，而且支持热部署，几乎可以做到 7 * 24 小时不间断运行，出镜率很高，从2004年发布至今，凭借开源的力量，日趋完善。其占用内存少、并发能力强、并且Nginx 是免费的还可以商业化，配置使用也比较简单。&lt;/p&gt;
    
    </summary>
    
      <category term="Nginx" scheme="http://AlbertGithubHome.github.io/blog/categories/Nginx/"/>
    
    
      <category term="Nginx" scheme="http://AlbertGithubHome.github.io/blog/tags/Nginx/"/>
    
      <category term="安装" scheme="http://AlbertGithubHome.github.io/blog/tags/%E5%AE%89%E8%A3%85/"/>
    
      <category term="负载均衡" scheme="http://AlbertGithubHome.github.io/blog/tags/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
    
      <category term="反向代理" scheme="http://AlbertGithubHome.github.io/blog/tags/%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/"/>
    
  </entry>
  
</feed>
