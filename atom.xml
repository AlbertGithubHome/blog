<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Albert World</title>
  <icon>https://www.gravatar.com/avatar/8ccc6291d5bfd34e7aaf601c4ebec7e1</icon>
  
  <link href="/blog/atom.xml" rel="self"/>
  
  <link href="http://AlbertGithubHome.github.io/blog/"/>
  <updated>2022-09-10T04:05:19.878Z</updated>
  <id>http://AlbertGithubHome.github.io/blog/</id>
  
  <author>
    <name>Albert Shi</name>
    <email>347070901@qq.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>关于竞赛，CSDN还有很长的路要走</title>
    <link href="http://AlbertGithubHome.github.io/blog/2022/09/09/%E5%85%B3%E4%BA%8E%E7%AB%9E%E8%B5%9B%EF%BC%8CCSDN%E8%BF%98%E6%9C%89%E5%BE%88%E9%95%BF%E7%9A%84%E8%B7%AF%E8%A6%81%E8%B5%B0/"/>
    <id>http://AlbertGithubHome.github.io/blog/2022/09/09/关于竞赛，CSDN还有很长的路要走/</id>
    <published>2022-09-09T15:42:00.000Z</published>
    <updated>2022-09-10T04:05:19.878Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>CSDN 编程竞赛·第五期总结<br>AlbertS    41  52.5    52m36s  竞赛勋章</p></blockquote><p>虽说这篇总结写在第五期之后，但是我却是从第三期就开始参加了的，前两期没有注意到就错过了，好在最近这几期比赛成绩很喜人，第三期6分，第四期67.5，第五期52.5，我承认我有点水，可是我也是能在力扣竞赛里常年水两题的选手啊，这个6分（满分100）真的惊到我了，从最近几期的参赛体验来看，CSDN在竞赛这个方向上还有很长的路要走。</p><a id="more"></a><h1 id="第三期"><a href="#第三期" class="headerlink" title="第三期"></a>第三期</h1><p>其实我也不算竞赛小白啦，毕竟之前在力扣参加过很多次了，因为平时总在CSDN上写总结，所以看到这里也有竞赛就想来试试，结果第一次有点手足无措，开头居然是4道Java和前端的选择题，我可是C++后端搬运工，嗯，我承认确实不会，根据经验选一选总能对一道题吧，既然选择题是特定语言的，那我直接写大题吧，一段操作猛如虎，一看分数2.5，当然分数不是立马出来的，我感觉答得还可以，结果过了几天出成绩是6分~</p><p><strong>吐槽开始：</strong></p><ul><li>要求关闭聊天软件，应该是防止作弊，关就关吧，这倒也无所谓</li><li>不能切屏，必须一直保持在答题状态，这有点严格了吧，万一这会我有事要处理呢，其实通常就是处理一些聊天信息</li><li>不能复制粘贴，你说不能从其他地方复制答案我可以理解，但是复制自己的代码也不行是要闹哪样</li><li>我知道为啥不能粘贴自己刚写的代码了，因为判断不出来是从哪里复制的，可是已经限制切屏了呀</li><li>测试用例简陋，有时看不太懂题全靠用例，好嘛，这里看不懂题就算了，用例可有可无</li><li>验证流程麻烦，好几个关闭按钮切来切去的</li><li>主函数不用给我提供，我又不能改，写在那有啥用</li><li>头文件要自己加，这是考算法来还是考背诵呢？（我确实被惯得不想写包含头文件了）</li></ul><h1 id="第四期"><a href="#第四期" class="headerlink" title="第四期"></a>第四期</h1><p>这期已经取消了选择题，直接是4道编程题，还是这样答起来顺利一点，各种语言都行，哪个顺手就用哪个了</p><p><strong>吐槽开始：</strong></p><p>因为取消了选择题，一时间竟找不到槽点了(#^.^#)，必须编一条</p><ul><li>测试用例依旧简单的可怜</li></ul><h1 id="第五期"><a href="#第五期" class="headerlink" title="第五期"></a>第五期</h1><p>我知道为啥第四期表现好了，因为在憋大招对付第五期，因为早饭吃的迟了，晚来了半小时参赛，结果发现进不去，正想报个bug发现帖子里都说进不去，这可有意思了，总共就一两千人参加，应该不是服务器性能不行吧，肯定是页面bug了</p><p>虽然大部分人都进不去，但还是有个别人进去比赛了的，已经出了成绩，20分暂居第一名，如果能保持到比赛结束就开心了，官方一直在回帖说解决问题，反正到比赛结束我也没进去。</p><p>一直到下午的1点之后，距离开始已经过去了5个小时，我终于进去了，告诉我比赛结束，分数是0，居然不能答题了，赶紧发帖找客服处理，好在工作人员及时赶到，帮我重置了一下，可以正常进入了。</p><p><strong>吐槽开始：</strong></p><ul><li>千人左右的比赛服务器就炸了</li><li>出现问题后修复过程缓慢</li><li>发帖提示我违规，但是不说哪里有问题，我也不知道哪句话说错了</li><li>通过BUG交流，沟通效率低下</li></ul><h1 id="优势与不足"><a href="#优势与不足" class="headerlink" title="优势与不足"></a>优势与不足</h1><p>前面吐槽了那么多，接下来说说优点吧：</p><ul><li>答题参与时间相对自由，仅限制了答题时长2小时候，不严格限制开始时间</li><li>分数按照通过的用例比例来给，没有采用非1即0的赋分方式，照顾了很多缺乏竞赛经验的选手，但是这样做未必是正确的</li><li>参加基本上都有奖品可以拿，调动了选手们的积极性，礼不在重，有就行</li><li>出现问题后尽力解决，虽然解决的慢了点，但是让人看到了负责人的一面</li></ul><p>缺点前面已经说了那么多，就不再赘述了，重点说一下答题环境需要改进，给出一些建议吧，其实编程竞赛已经不是新鲜事物了，有那么多好的平台可以学，比如力扣，每次的比赛都很多人参加的，把好的地方学过来就行：</p><ul><li>删除无关代码，只保留必要的输入参数就行了，把main函数给我也没用，又不允许本地调试</li><li>限制切屏这条尽力优化，限制复制自己代码这条必须去掉，我调整一下逻辑还要重新敲一遍体验未免太差了</li><li>比赛之后可以查看别人提交的代码，用于学习提升</li><li>赛后有针对这些题的讨论渠道，可以了解到自己有哪些不足，知道什么样的用例通不过</li><li>写包含头文件的这件事不太重要，重点放在逻辑实现上，现在谁还不是面向搜索引擎编程了，只要找到方法，头文件算什么难事</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>继续参加这个比赛，督促自己进步，同时也促进平台进步</li><li>如果自己不知道怎么做，就照着表现好的学，前面有那么多优秀的产品可以借鉴</li><li>产品上线还是要充分测试，像服务器炸了这种事最好不要出现了</li></ul><hr><center><a href="https://bbs.csdn.net/topics/608117734" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>『雄关漫道真如铁 而今迈步从头越』豪气如虹，真的很有才~</p><p>2022-9-10 11:50:37</p></blockquote><!--【CSDN】第五期编程竞赛获奖名单已经公布，恭喜您取得优异成绩并获奖，获奖用户需在CSDN发布一篇竞赛相关博客才可领取奖品哦，具体请查看详情：t.csdn.cn/HSLp5g-->]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;CSDN 编程竞赛·第五期总结&lt;br&gt;AlbertS    41  52.5    52m36s  竞赛勋章&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;虽说这篇总结写在第五期之后，但是我却是从第三期就开始参加了的，前两期没有注意到就错过了，好在最近这几期比赛成绩很喜人，第三期6分，第四期67.5，第五期52.5，我承认我有点水，可是我也是能在力扣竞赛里常年水两题的选手啊，这个6分（满分100）真的惊到我了，从最近几期的参赛体验来看，CSDN在竞赛这个方向上还有很长的路要走。&lt;/p&gt;
    
    </summary>
    
      <category term="Thinking" scheme="http://AlbertGithubHome.github.io/blog/categories/Thinking/"/>
    
    
      <category term="竞赛" scheme="http://AlbertGithubHome.github.io/blog/tags/%E7%AB%9E%E8%B5%9B/"/>
    
      <category term="CNDN" scheme="http://AlbertGithubHome.github.io/blog/tags/CNDN/"/>
    
      <category term="活动" scheme="http://AlbertGithubHome.github.io/blog/tags/%E6%B4%BB%E5%8A%A8/"/>
    
      <category term="编程" scheme="http://AlbertGithubHome.github.io/blog/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>简单总结下近期遇到的网络概念gcp、anycast IP、vlan</title>
    <link href="http://AlbertGithubHome.github.io/blog/2022/09/04/%E7%AE%80%E5%8D%95%E6%80%BB%E7%BB%93%E4%B8%8B%E8%BF%91%E6%9C%9F%E9%81%87%E5%88%B0%E7%9A%84%E7%BD%91%E7%BB%9C%E6%A6%82%E5%BF%B5gcp%E3%80%81anycast-IP%E3%80%81vlan/"/>
    <id>http://AlbertGithubHome.github.io/blog/2022/09/04/简单总结下近期遇到的网络概念gcp、anycast-IP、vlan/</id>
    <published>2022-09-03T16:35:37.000Z</published>
    <updated>2022-09-03T17:57:38.116Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>你知道得越多，就越会意识到自己知道得多么少</p></blockquote><p>知识这个东西总是越学越越多，特别是你去接触一个新领域的时候，会忽然发现之前的自己是多么的狂妄，多么的无知，最近有一些网络相关的需求，这沟通过程中接触到了一些新的概念，比如gcp、anycast IP、vlan等等，初听这些词确实不太理解，所以查了一些资料，对了解到的内容进行一个简单的总结。</p><a id="more"></a><h1 id="gcp"><a href="#gcp" class="headerlink" title="gcp"></a>gcp</h1><p>GCP 全称 Google Cloud Platform，即谷歌云平台，再这样一个万物皆可云的发展趋势下，云服务发展突飞猛进，作为海外乃至全球的科技巨头，谷歌在云服务领域有着极强的优势，特别是在海外环境下被广泛使用，为计算、存储、网络、大数据、机器学习和物联网（IoT）以及云管理、安全和开发人员工具提供服务，云计算产品包括：</p><ul><li><p>Google Compute Engine，这是一种基础架构即服务 (IaaS) 产品，可为用户提供用于工作负载托管的虚拟机实例。</p></li><li><p>Google App Engine，这是一种平台即服务 (PaaS) 产品，可让软件开发人员访问 Google 的可扩展托管。开发人员还可以使用软件开发工具包 (SDK) 来开发在 App Engine 上运行的软件产品</p></li><li><p>Google Cloud Storage，这是一个云存储平台，旨在存储大型非结构化数据集。Google 还提供数据库存储选项，包括用于NoSQL 非关系存储的Cloud Datastore 、用于MySQL 完全关系存储的Cloud SQL 和 Google 的原生 Cloud Bigtable 数据库。</p></li><li><p>Google Container Engine，它是运行在 Google 公共云中的Docker容器的管理和编排系统，是基于 Google Kubernetes 容器编排引擎。</p></li><li><p>Google Cloud Pub/Sub 是一种托管的实时消息传递服务，允许在应用程序之间交换消息，是一种应用程序开发和集成服务。</p></li><li><p>Google Cloud Endpoints 允许开发人员创建基于RESTful API 的服务，然后让 Apple iOS、Android 和 JavaScript 客户端可以访问这些服务。</p></li><li><p>其他产品包括任播 DNS 服务器、直接网络互连、 负载平衡、监控和日志服务。</p></li></ul><h1 id="Anycast"><a href="#Anycast" class="headerlink" title="Anycast"></a>Anycast</h1><p>任播(Anycast)，又称为选播、泛播或任意播，是IPv6中定义的一种新型通信服务，是IPv6中三大通信方式之一，该定义最早由C Partridge在RFC 1546中首次提出，但是RFC1546对任播的描述仅仅是一个实验性的服务。</p><p>Anycast指IPV6协议中一个发送方同最近的一组接收方之间的通信，当一个单播地址被分配到多于一个的接口上时，发到该接口的报文被网络路由到由路由协议度量的“最近”的目标接口上。</p><p>与Unicast和Multicast类似，Anycast也是IP网络的一种通信模式。</p><p>Multicast指多播，它是指网络中一个节点发出的信息被多个节点收到。与此相对的有单播Unicast和广播Broadcast，前者是指一个节点发出的信息只被一个节点收到，后者是指一个节点发出的信息被子网内所有节点收到</p><p>Anycast 允许源结点向一组目标结点中的一个结点发送数据报，而这个结点由路由系统选择，对源结点透明；同时，路由系统就近选择结点为源结点提供服务，从而在一定程度上为源结点提供了更好的服务也减轻了网络负载。</p><p>实现上分布的服务共享相同的IP地址，同时在IP层进行透明的服务定位，这使得各种网络服务特别是应用层服务具有更强的透明性，而路由系统选择了“最近”的服务，缩短了服务响应的时间，同时减轻了网络负载，同时在网络上冗余分布相同的服务，路由系统可以提供机制选择负载相对轻的带宽相对高的路径来转发报文，这样就给用户带来了两个方面的好处：</p><ul><li>减弱了分布式拒绝服务攻击（DDOS）</li><li>减弱了网络拥塞给用户带来的影响</li></ul><h2 id="Anycast-IP"><a href="#Anycast-IP" class="headerlink" title="Anycast IP"></a>Anycast IP</h2><p>Anycast IP 是集Multicast（多播IP）和Unicast（单播IP）特性于一身的特殊IP地址类型，在Anycast 这种通信模式下，同时存在多个有效的数据包接收端，但是就某一个特定IP数据包而言，仅有一个接收端主机收到了此数据包。</p><p>客户分散在多地又需要就近接入的服务，需要IP不同的多个地域部署机器、配置 DNS 实现负载均衡，十分繁琐。使用 Anycast 的 IP 后，无需每个地域都配置 IP，后端维护一套逻辑即可，各地域请求直接用专线加速到后端机器。</p><p>Anycast 的 IP 能起到游戏加速器的作用，游戏请求就近进入云服务，走云服务的内网专线到达游戏服务器，极大缩短经过的公网路径，减少了延时、抖动、丢包。此外跟传统加速比，IP 入口无需额外部署流量接收设备，且IP无需区分地域，简化了 DNS 部署。</p><h1 id="vlan"><a href="#vlan" class="headerlink" title="vlan"></a>vlan</h1><p>VLAN 全称 Virtual Local Area Network，即虚拟局域网。</p><p>VALN 是一组逻辑上的设备和用户，这些设备和用户并不受物理位置的限制，可以根据功能、部门及应用等因素将它们组织起来，相互之间的通信就好像它们在同一个网段中一样，由此得名虚拟局域网。</p><p>VLAN可以为信息业务和子业务、以及信息业务间提供一个相符合业务结构的虚拟网络拓扑架构并实现访问控制功能。与传统的局域网技术相比较，VLAN技术更加灵活，它具有以下优点： 网络设备的移动、添加和修改的管理开销减少；可以控制广播活动；可提高网络的安全性。</p><p>当一个交换机上的所有端口中有至少一个端口属于不同网段的时候，当路由器的一个物理端口要连接2个或者以上的网段的时候，就是VLAN发挥作用的时候，这就是VLAN的目的。</p><p>VLAN限制网络上的广播，将网络划分为多个VLAN可减少参与广播风暴的设备数量。VLAN分段可以防止广播风暴波及整个网络。VLAN可以提供建立防火墙的机制，防止交换网络的过量广播。</p><ul><li>WAN：Wide Area Network，广域网</li><li>LAN：Local Area Network，局域网</li><li>WLAN：Wireless  Local Area Network，无线局域网</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>GCP 全称 Google Cloud Platform，指的是谷歌云平台</li><li>Anycast IP 可以实现多地用户就近接入服务，提升用户体验</li><li>VLAN 指虚拟局域网，可以更合理划分网络资源，控制广播活动，提高安全性</li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/126552069" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>飞鸟尽，良弓藏；狡兔死，走狗烹。缘何众人都执着登顶？恐被藏与烹而已~</p><p>2022-9-4 01:49:39</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;你知道得越多，就越会意识到自己知道得多么少&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;知识这个东西总是越学越越多，特别是你去接触一个新领域的时候，会忽然发现之前的自己是多么的狂妄，多么的无知，最近有一些网络相关的需求，这沟通过程中接触到了一些新的概念，比如gcp、anycast IP、vlan等等，初听这些词确实不太理解，所以查了一些资料，对了解到的内容进行一个简单的总结。&lt;/p&gt;
    
    </summary>
    
      <category term="Network" scheme="http://AlbertGithubHome.github.io/blog/categories/Network/"/>
    
    
      <category term="Network" scheme="http://AlbertGithubHome.github.io/blog/tags/Network/"/>
    
      <category term="gcp" scheme="http://AlbertGithubHome.github.io/blog/tags/gcp/"/>
    
      <category term="anycast" scheme="http://AlbertGithubHome.github.io/blog/tags/anycast/"/>
    
      <category term="vlan" scheme="http://AlbertGithubHome.github.io/blog/tags/vlan/"/>
    
  </entry>
  
  <entry>
    <title>rm -rf 真是删库跑路的一把好手</title>
    <link href="http://AlbertGithubHome.github.io/blog/2022/08/26/rm-rf-%E7%9C%9F%E6%98%AF%E5%88%A0%E5%BA%93%E8%B7%91%E8%B7%AF%E7%9A%84%E4%B8%80%E6%8A%8A%E5%A5%BD%E6%89%8B/"/>
    <id>http://AlbertGithubHome.github.io/blog/2022/08/26/rm-rf-真是删库跑路的一把好手/</id>
    <published>2022-08-26T14:52:15.000Z</published>
    <updated>2022-08-28T10:10:43.086Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>上回书说到<a href="https://blog.csdn.net/albertsh/article/details/126075098" target="_blank" rel="noopener">《一个月黑风高的夜晚紧急完成gitlab服务器数据迁移》</a>，因为数据迁移后原数据还是存在的，该分区硬盘快满了，进而影响了原目录下的日志存储，既然数据已经迁移到新的路径了，那原来的库直接删掉就好了，往往就是这么不经意间做了一个令人十分后怕的决定。</p><a id="more"></a><h1 id="删库"><a href="#删库" class="headerlink" title="删库"></a>删库</h1><p>说干就干，连上服务器就开始操作了，为了避免搞错了，我还打开了另一个ssh窗口，对照着正在使用的git库，来一步步查找原来路径下已经废弃的仓库，嗯，终于找到了，对比各种信息没啥问题，两个窗口相互对照，十分“保险”。</p><p><code>rm -rf xxx</code> 走你，一切都安静了，好了退出当前路径检查一下空间大小，咦？路径怎么不对，好像删的是正在使用的那个库哎！服了，还真是受到了惊吓啊！背后发凉啊！gitlab网站访问一下，嗯，果然找不到了，拜拜！</p><h1 id="跑路"><a href="#跑路" class="headerlink" title="跑路"></a>跑路</h1><p>既然库都删完了，要不跑路吧？</p><blockquote><p>算了，能跑到哪呢？先回去看看能不能找回来吧~</p></blockquote><h1 id="恢复"><a href="#恢复" class="headerlink" title="恢复"></a>恢复</h1><p><code>rm -rf</code> 恢复硬盘数据是别想了，一般会让你卸载硬盘，断网，防止擦除，用第三方工具等，这我之前都演练过，几乎没什么用，这个时候需要冷静，先理智的分析一下：</p><p>既然是git库，我本地也是有的，要不我把我的库推上去试试？虽然没有那么新，但也差不了几个提交了，不过远程库都被我删了，我如果推上去一个新库，别人是不是直接访问不了，或者引发冲突呢？</p><p>想起之前迁移的时候我还备份了数据目录呢，那这样，先把备份的数据恢复到误删除的目录下，然后我再找一个本地的拉取到了最新状态git库推上去，既然想清楚了，那就动手吧。</p><ol><li><p>通知相关人员先不要拉取和推送数据</p></li><li><p>把一月前备份的git-data目录中对应数据通过 <code>rsync</code> 命令拷贝到误删除目录，这时通过gitlab网站已经能看到数据了，只是数据是一个月前的</p></li><li><p>跳到版本发布机，上面的Git库数据是最新的，按照分支把版本发布机上的git数据逐个推送到gitlab服务器</p></li><li><p>再次打开gitlab网站发现一切恢复如初，真是……</p></li></ol><h1 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h1><p><code>rm -rf</code> 命令真是删库跑路的一把好手，一点也不拖泥带水，更无回收站这个后悔药可以吃，所以在服务器上对文件使用了这个命令，基本上等于判了死刑，但是git库真是一个好东西，分布式的存储可以保证每个人那都有完整的仓库，只要能找到一个最新的就行。</p><p>为了保证我能有最新的库可以用，我赶紧在 jenkins 上新建了两个定时任务，每天定时把仓库拉取到最新，防止类似意外的发生。</p><h1 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h1><p>其实这个后续和删库这件事没有任何关系，如果非得说有什么关系，就是它们都属于“灾难”，删库刚刚处理完，紧接着游戏玩家出现登录不上的问题，一开始以为是网络波动，因为我登录过程也不太顺畅，直到玩家发来了录屏，我才发现这个问题又有的查了。</p><p>玩家所说的无法登录并不是真的登不进去，而是登录之后加载完读条刚要进场景，直接退到登录界面，查询网络消息发现每次登录后几秒钟，网络连接自动断开，但是断开前的通讯流程日志显示的延迟信息，又说明网络状况良好，一头雾水。</p><p>最后耗时两天，在收集了各种线索以后，发现是升级Unity版本后，在法语、俄语、乌克兰语作为系统语言时，对c#的字符串处理逻辑要求更加严格，如果不做处理沿用之前的写法，很容易出现崩溃错误，因为有try-catch处理，表现出来就是直接断网会登录界面，统一设置语言处理函数时修复了此问题。</p><p>身心俱疲~</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>使用 <code>rm -rf</code> 命令还是要谨慎，谨慎，再谨慎</li><li>如果真的删库了，也不一定非得跑路，先冷静想想有没有补救的措施</li><li>语言、字符集、编码真的是相互纠结，至此我的bug库里又收录了系统语言运行时，神奇</li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/126455725" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>北风卷地白草折，胡天八月即飞雪~</p><p>2022-8-26 23:41:18</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;上回书说到&lt;a href=&quot;https://blog.csdn.net/albertsh/article/details/126075098&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《一个月黑风高的夜晚紧急完成gitlab服务器数据迁移》&lt;/a&gt;，因为数据迁移后原数据还是存在的，该分区硬盘快满了，进而影响了原目录下的日志存储，既然数据已经迁移到新的路径了，那原来的库直接删掉就好了，往往就是这么不经意间做了一个令人十分后怕的决定。&lt;/p&gt;
    
    </summary>
    
      <category term="linux" scheme="http://AlbertGithubHome.github.io/blog/categories/linux/"/>
    
    
      <category term="linux" scheme="http://AlbertGithubHome.github.io/blog/tags/linux/"/>
    
      <category term="Git" scheme="http://AlbertGithubHome.github.io/blog/tags/Git/"/>
    
      <category term="rm" scheme="http://AlbertGithubHome.github.io/blog/tags/rm/"/>
    
      <category term="删除" scheme="http://AlbertGithubHome.github.io/blog/tags/%E5%88%A0%E9%99%A4/"/>
    
      <category term="恢复" scheme="http://AlbertGithubHome.github.io/blog/tags/%E6%81%A2%E5%A4%8D/"/>
    
  </entry>
  
  <entry>
    <title>git查看历史记录及修改内容</title>
    <link href="http://AlbertGithubHome.github.io/blog/2022/08/21/git%E6%9F%A5%E7%9C%8B%E5%8E%86%E5%8F%B2%E8%AE%B0%E5%BD%95%E5%8F%8A%E4%BF%AE%E6%94%B9%E5%86%85%E5%AE%B9/"/>
    <id>http://AlbertGithubHome.github.io/blog/2022/08/21/git查看历史记录及修改内容/</id>
    <published>2022-08-21T00:04:41.000Z</published>
    <updated>2022-08-21T13:39:44.717Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在 <code>Git</code> 中没有真正的方法来做任何事情，这就是它的妙处！比如查看修改内容这件事，有些人会想到 <code>git log</code>，有些人会想到 <code>git show</code>，最近我又学到一个 <code>git whatchanged</code>，实现目的方法多种多样，各种途径任君挑选。</p><p>刚开始步入软件开发行业时喜欢捣鼓各种软件，进行各种个性化配置，任意修改快捷键，这样在开发过程中确实会舒服一些，但是换了一个环境时（电脑重装或在别人的机器），就好像一个什么也不会的傻子一样，所以慢慢的我开始强迫自己熟悉软件自己的快捷键和各种命令，这样在重装系统时会免去很多麻烦，并且因为一些命令用习惯了，在编写部署脚本时也不会总是写出不能识别的简写命令了。</p><a id="more"></a><h1 id="修改文件"><a href="#修改文件" class="headerlink" title="修改文件"></a>修改文件</h1><p>为了测试各种的查找修改记录的命令，我先进行一次包含增加、修改、删除的提交，然后对比来看各个命令的作用，实际修改如下：</p><ol><li>在文件address.txt中增加两行数据</li><li>清空文件age.txt中4行数据</li><li>修改文件name.txt中一行数据</li><li>增加带有3行数据的phone.txt文件</li><li>删除带有2行数据的story.txt文件</li></ol><p>在执行了 <code>git add .</code> 命令后，可以用 <code>git diff --staged</code> 查看即将提交的文件修改，展示如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">$ git diff --staged</span><br><span class="line">diff --git a/address.txt b/address.txt</span><br><span class="line">index e69de29..8f9d6e6 100644</span><br><span class="line">--- a/address.txt</span><br><span class="line">+++ b/address.txt</span><br><span class="line">@@ -0,0 +1,2 @@</span><br><span class="line">+beijing</span><br><span class="line">+shanghai</span><br><span class="line">\ No newline at end of file</span><br><span class="line">diff --git a/age.txt b/age.txt</span><br><span class="line">index 58f78c9..e69de29 100644</span><br><span class="line">--- a/age.txt</span><br><span class="line">+++ b/age.txt</span><br><span class="line">@@ -1,4 +0,0 @@</span><br><span class="line">-12</span><br><span class="line">-16</span><br><span class="line">-17</span><br><span class="line">-15</span><br><span class="line">\ No newline at end of file</span><br><span class="line">diff --git a/name.txt b/name.txt</span><br><span class="line">index ac37a53..0ed306a 100644</span><br><span class="line">--- a/name.txt</span><br><span class="line">+++ b/name.txt</span><br><span class="line">@@ -1,4 +1,4 @@</span><br><span class="line"> tom</span><br><span class="line">-alice</span><br><span class="line">+jerry</span><br><span class="line"> bily</span><br><span class="line"> andy</span><br><span class="line">\ No newline at end of file</span><br><span class="line">diff --git a/phone.txt b/phone.txt</span><br><span class="line">new file mode 100644</span><br><span class="line">index 0000000..241bcdb</span><br><span class="line">--- /dev/null</span><br><span class="line">+++ b/phone.txt</span><br><span class="line">@@ -0,0 +1,3 @@</span><br><span class="line">+110</span><br><span class="line">+120</span><br><span class="line">+119</span><br><span class="line">\ No newline at end of file</span><br><span class="line">diff --git a/story.txt b/story.txt</span><br><span class="line">deleted file mode 100644</span><br><span class="line">index 0d89902..0000000</span><br><span class="line">--- a/story.txt</span><br><span class="line">+++ /dev/null</span><br><span class="line">@@ -1,2 +0,0 @@</span><br><span class="line">-King</span><br><span class="line">-Wolf</span><br><span class="line">\ No newline at end of file</span><br></pre></td></tr></table></figure><p>关于 <code>git diff</code> 对于很多使用 <code>git</code> 管理代码的小伙伴再熟悉不过了，但是其中有些细节还是需要学习的：</p><ol><li><p><code>diff --git a/name.txt b/name.txt</code> 这一行是说以下展示 <code>name.txt</code> 文件修改前后的信息，<code>a/name.txt</code> 和 <code>b/name.txt</code> 分别表示修改前后的文件名</p></li><li><p><code>index ac37a53..0ed306a 100644</code> 这一行表示文件修改前后的 <code>object</code>，<code>100644</code> 表示这是一个常规文件，文件权限为 <code>644</code>，使用 <code>git cat-file -p</code>可以查看文件内容：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ git cat-file -p ac37a53</span><br><span class="line">tom</span><br><span class="line">alice</span><br><span class="line">bily</span><br><span class="line">andy</span><br><span class="line"></span><br><span class="line">$ git cat-file -p 0ed306a</span><br><span class="line">tom</span><br><span class="line">jerry</span><br><span class="line">bily</span><br><span class="line">andy</span><br></pre></td></tr></table></figure></li><li><figure class="highlight plain"><figcaption><span>a/name.txt``` 表示修改前的文件，```+++ b/name.txt``` 表示修改后的文件</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">4. `@@ -1,4 +1,4 @@` 这一句应该是最有意思的，也是不用一看懂的一行，其中开头和结尾的 `@@` 为固定格式，`-1,4` 表示修改前的 `1~4`行，`+1~4`表示修改后的`1~4`行，这句话的意思就是，以下内容展示了修改前 `1~4`行到修改后 `1~4`行的文件变化，因为我们只修改了一行，所以修改前后行数不变，如果新增行数和删除行数不同，那么这个位置展示的行数也是不同的，例如 `phone.txt` 文件的变化 `@@ -0,0 +1,3 @@`</span><br><span class="line"></span><br><span class="line">5. 最后就是文件具体的变化了，新增内容前面是加号 `+`，删除内容前面是减号 `-`：</span><br><span class="line"></span><br><span class="line">    ```bash</span><br><span class="line">     tom</span><br><span class="line">    -alice</span><br><span class="line">    +jerry</span><br><span class="line">     bily</span><br><span class="line">     andy</span><br></pre></td></tr></table></figure></li></ol><h1 id="查询文件修改"><a href="#查询文件修改" class="headerlink" title="查询文件修改"></a>查询文件修改</h1><p>当我们把修改的内容提交以后，这条修改属于存入了仓库的历史之中，<code>git diff</code> 就无法再查看文件的变化了，而需要使用 <code>git log</code> 或 <code>git show</code> 来查看文件修改的内容，接下来我们来看看这些命令都能用来干嘛。</p><h2 id="git-show"><a href="#git-show" class="headerlink" title="git show"></a>git show</h2><p><code>git show</code> 默认展示最近一次提交的修改，与执行 <code>git commit</code> 命令之前的 <code>git diff --staged</code> 查看得到的绝大部分内容相同，只是在开头位置包含最新提交的信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">$ git show</span><br><span class="line">commit 2447e2b9c15472f2ead7bf451aa5fc9c3f34f5ee (HEAD -&gt; master)</span><br><span class="line">Author: albert &lt;albert101@163.com&gt;</span><br><span class="line">Date:   Sun Aug 21 15:22:08 2022 +0800</span><br><span class="line"></span><br><span class="line">    update example data</span><br><span class="line"></span><br><span class="line">diff --git a/address.txt b/address.txt</span><br><span class="line">index e69de29..8f9d6e6 100644</span><br><span class="line">--- a/address.txt</span><br><span class="line">+++ b/address.txt</span><br><span class="line">@@ -0,0 +1,2 @@</span><br><span class="line">+beijing</span><br><span class="line">+shanghai</span><br><span class="line">\ No newline at end of file</span><br><span class="line">diff --git a/age.txt b/age.txt</span><br><span class="line">index 58f78c9..e69de29 100644</span><br><span class="line">--- a/age.txt</span><br><span class="line">+++ b/age.txt</span><br><span class="line">@@ -1,4 +0,0 @@</span><br><span class="line">-12</span><br><span class="line">-16</span><br><span class="line">-17</span><br><span class="line">-15</span><br><span class="line">\ No newline at end of file</span><br><span class="line">diff --git a/name.txt b/name.txt</span><br><span class="line">index ac37a53..0ed306a 100644</span><br><span class="line">--- a/name.txt</span><br><span class="line">+++ b/name.txt</span><br><span class="line">@@ -1,4 +1,4 @@</span><br><span class="line"> tom</span><br><span class="line">-alice</span><br><span class="line">+jerry</span><br><span class="line"> bily</span><br><span class="line"> andy</span><br><span class="line">\ No newline at end of file</span><br><span class="line">diff --git a/phone.txt b/phone.txt</span><br><span class="line">new file mode 100644</span><br><span class="line">index 0000000..241bcdb</span><br><span class="line">--- /dev/null</span><br><span class="line">+++ b/phone.txt</span><br><span class="line">@@ -0,0 +1,3 @@</span><br><span class="line">+110</span><br><span class="line">+120</span><br><span class="line">+119</span><br><span class="line">\ No newline at end of file</span><br><span class="line">diff --git a/story.txt b/story.txt</span><br><span class="line">deleted file mode 100644</span><br><span class="line">index 0d89902..0000000</span><br><span class="line">--- a/story.txt</span><br><span class="line">+++ /dev/null</span><br><span class="line">@@ -1,2 +0,0 @@</span><br><span class="line">-King</span><br><span class="line">-Wolf</span><br><span class="line">\ No newline at end of file</span><br></pre></td></tr></table></figure><p><code>git show</code> 还可以加数字，比如 <code>git show -3</code> 就是展示最近3次提交修改信息。</p><p><code>git show --stat</code> 可以查看最新提交的修改文件，如果想查看指定提交的修改文件信息，可以在后面跟上<code>commit-id</code>，例如 <code>git show --stat 2447e2b9c15472f2ead7bf451aa5fc9c3f34f5ee</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ git show --<span class="built_in">stat</span></span><br><span class="line">commit 2447e2b9c15472f2ead7bf451aa5fc9c3f34f5ee (HEAD -&gt; master)</span><br><span class="line">Author: albert &lt;albert101@163.com&gt;</span><br><span class="line">Date:   Sun Aug 21 15:22:08 2022 +0800</span><br><span class="line"></span><br><span class="line">    update example data</span><br><span class="line"></span><br><span class="line"> address.txt | 2 ++</span><br><span class="line"> age.txt     | 4 ----</span><br><span class="line"> name.txt    | 2 +-</span><br><span class="line"> phone.txt   | 3 +++</span><br><span class="line"> story.txt   | 2 --</span><br><span class="line"> 5 files changed, 6 insertions(+), 7 deletions(-)</span><br></pre></td></tr></table></figure><p>这个展示信息可以清楚的看出哪些文件新增了内容，哪些文件删除了内容，并且展示了文件增伤行数的比例，但是有一点它不够清晰，那就是无法看出哪些是新增的文件，哪些是删除的文件，比如 <code>age.txt</code> 和 <code>story.txt</code> 都显示删除了数据，但实际上 <code>story.txt</code> 整个文件都从仓库中删除了，要想看出文件增删状态可以使用接下来展示的这个命令 <code>git whatchanged</code></p><h2 id="git-whatchanged"><a href="#git-whatchanged" class="headerlink" title="git whatchanged"></a>git whatchanged</h2><p><code>git whatchanged</code> 可以展示出文件的增删状态和权限修改，默认分页展示所有提交记录，可以后面加数字来展示最近几次的文件增删状态：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ git whatchanged -1</span><br><span class="line">commit 2447e2b9c15472f2ead7bf451aa5fc9c3f34f5ee (HEAD -&gt; master)</span><br><span class="line">Author: albert &lt;albert101@163.com&gt;</span><br><span class="line">Date:   Sun Aug 21 15:22:08 2022 +0800</span><br><span class="line"></span><br><span class="line">    update example data</span><br><span class="line"></span><br><span class="line">:100644 100644 e69de29 8f9d6e6 M        address.txt</span><br><span class="line">:100644 100644 58f78c9 e69de29 M        age.txt</span><br><span class="line">:100644 100644 ac37a53 0ed306a M        name.txt</span><br><span class="line">:000000 100644 0000000 241bcdb A        phone.txt</span><br><span class="line">:100644 000000 0d89902 0000000 D        story.txt</span><br></pre></td></tr></table></figure><p>从这个文件中就可以看出 address.txt、age.txt、name.txt 三个文件被修改了，phone.txt 是新增加的，story.txt 文件被删除了，如果在命令后面加上选项 <code>--stat</code> 作用就和 <code>git show</code> 一样了，兜兜转转回到原点~</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ git whatchanged -1 --<span class="built_in">stat</span></span><br><span class="line">commit 2447e2b9c15472f2ead7bf451aa5fc9c3f34f5ee (HEAD -&gt; master)</span><br><span class="line">Author: albert &lt;albert101@163.com&gt;</span><br><span class="line">Date:   Sun Aug 21 15:22:08 2022 +0800</span><br><span class="line"></span><br><span class="line">    update example data</span><br><span class="line"></span><br><span class="line"> address.txt | 2 ++</span><br><span class="line"> age.txt     | 4 ----</span><br><span class="line"> name.txt    | 2 +-</span><br><span class="line"> phone.txt   | 3 +++</span><br><span class="line"> story.txt   | 2 --</span><br><span class="line"> 5 files changed, 6 insertions(+), 7 deletions(-)</span><br></pre></td></tr></table></figure><h2 id="git-log"><a href="#git-log" class="headerlink" title="git log"></a>git log</h2><p>根据我个人的理解，<code>git show</code> 注重查看一次提交中修改的内容，而 <code>git log</code> 主要用于查找历史提交的脉络，但这不是绝对的，因为git做一件事，没有绝对的一种方式，你也可以用 <code>git log</code> 来实现 <code>git show</code>。</p><ul><li><p>展示最近一次提交</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> -1</span><br><span class="line">commit 2447e2b9c15472f2ead7bf451aa5fc9c3f34f5ee (HEAD -&gt; master)</span><br><span class="line">Author: albert &lt;albert101@163.com&gt;</span><br><span class="line">Date:   Sun Aug 21 15:22:08 2022 +0800</span><br><span class="line"></span><br><span class="line">    update example data</span><br></pre></td></tr></table></figure></li><li><p>展示其他分支最近一次提交</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> -1 dev</span><br><span class="line">commit 62cc52cbc7f9581fa825b443aba3481083459656 (dev)</span><br><span class="line">Author: albert &lt;albert101@163.com&gt;</span><br><span class="line">Date:   Sun Aug 21 12:02:11 2022 +0800</span><br><span class="line"></span><br><span class="line">    init git repository</span><br></pre></td></tr></table></figure></li><li><p>展示修改的文件列表及文件修改的统计</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> -1 --<span class="built_in">stat</span></span><br><span class="line">commit 2447e2b9c15472f2ead7bf451aa5fc9c3f34f5ee (HEAD -&gt; master)</span><br><span class="line">Author: albert &lt;albert101@163.com&gt;</span><br><span class="line">Date:   Sun Aug 21 15:22:08 2022 +0800</span><br><span class="line"></span><br><span class="line">    update example data</span><br><span class="line"></span><br><span class="line"> address.txt | 2 ++</span><br><span class="line"> age.txt     | 4 ----</span><br><span class="line"> name.txt    | 2 +-</span><br><span class="line"> phone.txt   | 3 +++</span><br><span class="line"> story.txt   | 2 --</span><br><span class="line"> 5 files changed, 6 insertions(+), 7 deletions(-)</span><br></pre></td></tr></table></figure></li><li><p>展示每次修改的文件列表</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> -1 --name-only</span><br><span class="line">commit 2447e2b9c15472f2ead7bf451aa5fc9c3f34f5ee (HEAD -&gt; master)</span><br><span class="line">Author: albert &lt;albert101@163.com&gt;</span><br><span class="line">Date:   Sun Aug 21 15:22:08 2022 +0800</span><br><span class="line"></span><br><span class="line">    update example data</span><br><span class="line"></span><br><span class="line">address.txt</span><br><span class="line">age.txt</span><br><span class="line">name.txt</span><br><span class="line">phone.txt</span><br><span class="line">story.txt</span><br></pre></td></tr></table></figure></li><li><p>展示修改的文件列表和显示状态</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> -1 --name-status</span><br><span class="line">commit 2447e2b9c15472f2ead7bf451aa5fc9c3f34f5ee (HEAD -&gt; master)</span><br><span class="line">Author: albert &lt;albert101@163.com&gt;</span><br><span class="line">Date:   Sun Aug 21 15:22:08 2022 +0800</span><br><span class="line"></span><br><span class="line">    update example data</span><br><span class="line"></span><br><span class="line">M       address.txt</span><br><span class="line">M       age.txt</span><br><span class="line">M       name.txt</span><br><span class="line">A       phone.txt</span><br><span class="line">D       story.txt</span><br></pre></td></tr></table></figure></li><li><p>展示指定作者提交的记录</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> -1 --author=<span class="string">"albert"</span></span><br><span class="line">commit 2447e2b9c15472f2ead7bf451aa5fc9c3f34f5ee (HEAD -&gt; master)</span><br><span class="line">Author: albert &lt;albert101@163.com&gt;</span><br><span class="line">Date:   Sun Aug 21 15:22:08 2022 +0800</span><br><span class="line"></span><br><span class="line">    update example data</span><br></pre></td></tr></table></figure></li><li><p>单行展示提交的记录</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> --oneline</span><br><span class="line">2447e2b (HEAD -&gt; master) update example data</span><br><span class="line">62cc52c (dev) init git repository</span><br></pre></td></tr></table></figure></li><li><p>展示指定日期之前的提交记录</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> --before=<span class="string">'2022-08-22'</span></span><br><span class="line">commit 2447e2b9c15472f2ead7bf451aa5fc9c3f34f5ee (HEAD -&gt; master)</span><br><span class="line">Author: albert &lt;albert101@163.com&gt;</span><br><span class="line">Date:   Sun Aug 21 15:22:08 2022 +0800</span><br><span class="line"></span><br><span class="line">    update example data</span><br><span class="line"></span><br><span class="line">commit 62cc52cbc7f9581fa825b443aba3481083459656 (dev)</span><br><span class="line">Author: albert &lt;albert101@163.com&gt;</span><br><span class="line">Date:   Sun Aug 21 12:02:11 2022 +0800</span><br><span class="line"></span><br><span class="line">    init git repository</span><br></pre></td></tr></table></figure></li><li><p>展示一天之内的提交记录</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> --since=1.day.ago</span><br><span class="line">commit 2447e2b9c15472f2ead7bf451aa5fc9c3f34f5ee (HEAD -&gt; master)</span><br><span class="line">Author: albert &lt;albert101@163.com&gt;</span><br><span class="line">Date:   Sun Aug 21 15:22:08 2022 +0800</span><br><span class="line"></span><br><span class="line">    update example data</span><br><span class="line"></span><br><span class="line">commit 62cc52cbc7f9581fa825b443aba3481083459656 (dev)</span><br><span class="line">Author: albert &lt;albert101@163.com&gt;</span><br><span class="line">Date:   Sun Aug 21 12:02:11 2022 +0800</span><br><span class="line"></span><br><span class="line">    init git repository</span><br></pre></td></tr></table></figure></li><li><p>展示指定包含指定内容的提交记录</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> --grep=update</span><br><span class="line">commit 2447e2b9c15472f2ead7bf451aa5fc9c3f34f5ee (HEAD -&gt; master)</span><br><span class="line">Author: albert &lt;albert101@163.com&gt;</span><br><span class="line">Date:   Sun Aug 21 15:22:08 2022 +0800</span><br><span class="line"></span><br><span class="line">    update example data</span><br></pre></td></tr></table></figure></li><li><p>展示指定不包含指定内容的提交记录</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> --grep=update --invert-grep</span><br><span class="line">commit 62cc52cbc7f9581fa825b443aba3481083459656 (dev)</span><br><span class="line">Author: albert &lt;albert101@163.com&gt;</span><br><span class="line">Date:   Sun Aug 21 12:02:11 2022 +0800</span><br><span class="line"></span><br><span class="line">    init git repository</span><br></pre></td></tr></table></figure></li><li><p>终极大招，图形化展示，其实用的并不多</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> --graph --pretty=format:<span class="string">'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset'</span> --abbrev-commit --date=relative --all</span><br><span class="line">* 2447e2b - (HEAD -&gt; master) update example data (77 minutes ago) &lt;albert&gt;</span><br><span class="line">* 62cc52c - (dev) init git repository (2 hours ago) &lt;albert&gt;</span><br><span class="line">*   719ec7a - (refs/stash) WIP on master: 83f00c5 init git repository (2 hours ago) &lt;albert&gt;</span><br><span class="line">|\</span><br><span class="line">| * 9c87e06 - index on master: 83f00c5 init git repository (2 hours ago) &lt;albert&gt;</span><br><span class="line">|/</span><br><span class="line">* 83f00c5 - init git repository (5 hours ago) &lt;albert&gt;</span><br></pre></td></tr></table></figure></li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>查看最近一次修改的内容使用 <code>git show</code></li><li>查看最近一次修改的文件使用 <code>git show --stat</code> 或 <code>git log -1 --name-only</code></li><li>查看最近一次修改的文件状态使用 <code>git whatchanged -1</code> 或 <code>git log -1 --name-status</code></li><li>图形化显示git提交记录使用 <code>git log --graph</code></li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/126214355" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>轻生的人到底是勇敢还是懦弱呢？虽说我未经历过他的人生不该轻易评判，但就我主观来思考这类事，大抵是因为对生活失去了信心。人固有一死，或重于泰山，或轻于鸿毛。而遇到困难就选择轻生的人是自私且不负责任的，若你无牵无挂走了也就走了，倘若还有家人岂不是还要拿出额外一笔钱给你办个葬礼？连死都不怕了，还有什么是过不去的呢？</p><p>2022-8-21 21:19:13</p></blockquote><p>&lt;!–<br>我曾走过山，走过水，其实只是借助它们走过我的生命；<br>我看着天，看着地，其实只是借助它们确定我的位置；<br>我爱着他，爱着你，其实只是借助别人实现了我的爱欲。</p><p>——史铁生《务虚笔记》<br>– &gt;</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;在 &lt;code&gt;Git&lt;/code&gt; 中没有真正的方法来做任何事情，这就是它的妙处！比如查看修改内容这件事，有些人会想到 &lt;code&gt;git log&lt;/code&gt;，有些人会想到 &lt;code&gt;git show&lt;/code&gt;，最近我又学到一个 &lt;code&gt;git whatchanged&lt;/code&gt;，实现目的方法多种多样，各种途径任君挑选。&lt;/p&gt;
&lt;p&gt;刚开始步入软件开发行业时喜欢捣鼓各种软件，进行各种个性化配置，任意修改快捷键，这样在开发过程中确实会舒服一些，但是换了一个环境时（电脑重装或在别人的机器），就好像一个什么也不会的傻子一样，所以慢慢的我开始强迫自己熟悉软件自己的快捷键和各种命令，这样在重装系统时会免去很多麻烦，并且因为一些命令用习惯了，在编写部署脚本时也不会总是写出不能识别的简写命令了。&lt;/p&gt;
    
    </summary>
    
      <category term="Git" scheme="http://AlbertGithubHome.github.io/blog/categories/Git/"/>
    
    
      <category term="版本控制" scheme="http://AlbertGithubHome.github.io/blog/tags/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"/>
    
      <category term="Git" scheme="http://AlbertGithubHome.github.io/blog/tags/Git/"/>
    
      <category term="log" scheme="http://AlbertGithubHome.github.io/blog/tags/log/"/>
    
      <category term="历史记录" scheme="http://AlbertGithubHome.github.io/blog/tags/%E5%8E%86%E5%8F%B2%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>参考开源项目实现一个简易的C++枚举转字符串的函数</title>
    <link href="http://AlbertGithubHome.github.io/blog/2022/08/07/%E5%8F%82%E8%80%83%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E6%98%93%E7%9A%84C-%E6%9E%9A%E4%B8%BE%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%87%BD%E6%95%B0/"/>
    <id>http://AlbertGithubHome.github.io/blog/2022/08/07/参考开源项目实现一个简易的C-枚举转字符串的函数/</id>
    <published>2022-08-07T06:44:08.000Z</published>
    <updated>2022-08-07T11:36:52.823Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>前段时间接触了 <a href="https://github.com/Neargye/magic_enum" target="_blank" rel="noopener">magic_enum</a> 这个开源库，代码量不算太多，是一个但头文件的枚举操作库，关于如何使用还写了一篇总结 <a href="https://blog.csdn.net/albertsh/article/details/125955230" target="_blank" rel="noopener">《推荐一个C++枚举转字符串的开源项目magic_enum》</a>，当时觉得这个库很棒，但是对于我当前枚举转化字符串的需求还说还是太臃肿了，所以决定改造一下，这不今天过来填坑了。</p><a id="more"></a><h1 id="改造"><a href="#改造" class="headerlink" title="改造"></a>改造</h1><p>一开始还没太理解开源库的原理，认为原来的实现限制太大，为了实现后面字符串转枚举，获取所有枚举名等需求，不得不限定一个枚举的范围，这个范围在 magic_enum 这个开源库中是 [-128, 128]，所以当我开始改造时打算把这个范围去掉，但是当我真正弄懂它的原理后，才发现这个范围是必须指定的，不然无法在编译期预处理，从而达到枚举值转换成字符串的目的。</p><p>认识到这一点以后，我也不再纠结范围的限制，设定了一个 <code>[0, 31]</code> 的常用枚举范围，相比于原来 <code>[-128, 128]</code> 的范围缩小了不少，这样能加快编译的速度，参考这个开源库和一些网络上关于这个库的讲解，我也实现了一个功能单一的简洁的枚举转字符串的函数 <code>Enum2String</code>，大约70行代码，使用起来还是比较方便的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string_view&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E, E V&gt;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">auto</span> <span class="title">PrettyName</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::string_view name&#123;__PRETTY_FUNCTION__, <span class="keyword">sizeof</span>(__PRETTY_FUNCTION__) - <span class="number">2</span>&#125;;</span><br><span class="line">    name.remove_prefix(name.find_last_of(<span class="string">" "</span>) + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (name.front() == <span class="string">'('</span>) name.remove_prefix(name.size());</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E, E V&gt;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">bool</span> <span class="title">IsValidEnum</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !PrettyName&lt;E, V&gt;().empty();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span>... Seq&gt;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">auto</span> <span class="title">MakeIntegerSequence</span><span class="params">(<span class="built_in">std</span>::integer_sequence&lt;<span class="keyword">int</span>, Seq...&gt;)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::integer_sequence&lt;<span class="keyword">int</span>, (Seq)...&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> NormalIntegerSequence = MakeIntegerSequence(<span class="built_in">std</span>::make_integer_sequence&lt;<span class="keyword">int</span>, <span class="number">32</span>&gt;());</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E, <span class="keyword">int</span>... Seq&gt;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> size_t <span class="title">GetEnumSize</span><span class="params">(<span class="built_in">std</span>::integer_sequence&lt;<span class="keyword">int</span>, Seq...&gt;)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">bool</span>, <span class="keyword">sizeof</span>...(Seq)&gt; valid&#123;IsValidEnum&lt;E, <span class="keyword">static_cast</span>&lt;E&gt;(Seq)&gt;()...&#125;;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="built_in">std</span>::<span class="keyword">size_t</span> count = [](<span class="keyword">decltype</span>((valid)) v) <span class="keyword">constexpr</span> <span class="keyword">noexcept</span>-&gt;<span class="built_in">std</span>::<span class="keyword">size_t</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> cnt = <span class="built_in">std</span>::<span class="keyword">size_t</span>&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> b : v) <span class="keyword">if</span> (b) ++cnt;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;(valid);</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E, <span class="keyword">int</span>... Seq&gt;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">auto</span> <span class="title">GetAllValidValues</span><span class="params">(<span class="built_in">std</span>::integer_sequence&lt;<span class="keyword">int</span>, Seq...&gt;)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="built_in">std</span>::<span class="keyword">size_t</span> count = <span class="keyword">sizeof</span>...(Seq);</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">bool</span>, count&gt; valid&#123;IsValidEnum&lt;E, <span class="keyword">static_cast</span>&lt;E&gt;(Seq)&gt;()...&#125;;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>, count&gt; seq&#123;Seq...&#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>, GetEnumSize&lt;E&gt;(NormalIntegerSequence)&gt; values&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">std</span>::<span class="keyword">size_t</span> i = <span class="number">0</span>, v = <span class="number">0</span>; i &lt; count; ++i) <span class="keyword">if</span> (valid[i]) values[v++] = seq[i];</span><br><span class="line">    <span class="keyword">return</span> values;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E, <span class="keyword">int</span>... Seq&gt;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">auto</span> <span class="title">GetAllValidNames</span><span class="params">(<span class="built_in">std</span>::integer_sequence&lt;<span class="keyword">int</span>, Seq...&gt;)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="built_in">std</span>::string_view, <span class="keyword">sizeof</span>...(Seq)&gt; names&#123;PrettyName&lt;E, <span class="keyword">static_cast</span>&lt;E&gt;(Seq)&gt;()...&#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="built_in">std</span>::string_view, GetEnumSize&lt;E&gt;(NormalIntegerSequence)&gt; validNames&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">std</span>::<span class="keyword">size_t</span> i = <span class="number">0</span>, v = <span class="number">0</span>; i &lt; names.size(); ++i) <span class="keyword">if</span> (!names[i].empty()) validNames[v++] = names[i];</span><br><span class="line">    <span class="keyword">return</span> validNames;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="built_in">std</span>::<span class="function">string_view <span class="title">Enum2String</span><span class="params">(E V)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> names = GetAllValidNames&lt;E&gt;(NormalIntegerSequence);</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> values = GetAllValidValues&lt;E&gt;(NormalIntegerSequence);</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> size = GetEnumSize&lt;E&gt;(NormalIntegerSequence);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; size; ++i) <span class="keyword">if</span> (<span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(V) == values[i]) <span class="keyword">return</span> names[i];</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::to_string(<span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(V));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="函数使用"><a href="#函数使用" class="headerlink" title="函数使用"></a>函数使用</h1><p>这个<code>Enum2String</code>函数使用也非常方便，直接把枚举变量作为参数传进去就可以了:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"myenum.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">Color</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    RED,</span><br><span class="line">    GREEN,</span><br><span class="line">    BLUE,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Color c = Color::BLUE;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; Enum2String(c) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译运行后的结果为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ g++ enumtest.cpp -<span class="built_in">std</span>=c++<span class="number">17</span> &amp;&amp; ./a.out</span><br><span class="line">Color::BLUE</span><br></pre></td></tr></table></figure><h1 id="各函数的作用"><a href="#各函数的作用" class="headerlink" title="各函数的作用"></a>各函数的作用</h1><p>前面提到过，我这个库还是参考 <a href="https://github.com/Neargye/magic_enum" target="_blank" rel="noopener">magic_enum</a> 这个开源库的源码及网上对它的讲解来实现的，只不过精简了大部分我用不到的内容，仅实现了我想要的枚举转字符串的功能，并且大部分都在编译器求值，仅 <code>Enum2String</code> 函数中遍历的部分只能在运行时才能计算求得，所以效率还算不错，各个模板函数作用明确，下面简单描述下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E, E V&gt;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">auto</span> <span class="title">PrettyName</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::string_view name&#123;__PRETTY_FUNCTION__, <span class="keyword">sizeof</span>(__PRETTY_FUNCTION__) - <span class="number">2</span>&#125;;</span><br><span class="line">    name.remove_prefix(name.find_last_of(<span class="string">" "</span>) + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (name.front() == <span class="string">'('</span>) name.remove_prefix(name.size());</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>PrettyName()</code> 函数是利用 <code>__PRETTY_FUNCTION__</code> 这个宏来截取最终我们想要的字符串，如果不做处理，<code>__PRETTY_FUNCTION__</code> 的值会是这样：</p><blockquote><p>constexpr auto PrettyName() [with E = Color; E V = Color::BLUE]</p></blockquote><p>靠近结尾的 <code>Color::BLUE</code> 正是我们想要得到的字符串，所以我们可以按照自己的需要把它截取出来。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E, E V&gt;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">bool</span> <span class="title">IsValidEnum</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !PrettyName&lt;E, V&gt;().empty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>IsValidEnum()</code> 函数是用于判断一个枚举名字是否有效，如果截取的最终名字为空，则认为此枚举无效。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span>... Seq&gt;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">auto</span> <span class="title">MakeIntegerSequence</span><span class="params">(<span class="built_in">std</span>::integer_sequence&lt;<span class="keyword">int</span>, Seq...&gt;)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::integer_sequence&lt;<span class="keyword">int</span>, (Seq)...&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> NormalIntegerSequence = MakeIntegerSequence(<span class="built_in">std</span>::make_integer_sequence&lt;<span class="keyword">int</span>, <span class="number">32</span>&gt;());</span><br></pre></td></tr></table></figure><p><code>MakeIntegerSequence()</code> 用于生成一个范围是 <code>[0, 32)</code> 的整数数列。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E, <span class="keyword">int</span>... Seq&gt;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> size_t <span class="title">GetEnumSize</span><span class="params">(<span class="built_in">std</span>::integer_sequence&lt;<span class="keyword">int</span>, Seq...&gt;)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">bool</span>, <span class="keyword">sizeof</span>...(Seq)&gt; valid&#123;IsValidEnum&lt;E, <span class="keyword">static_cast</span>&lt;E&gt;(Seq)&gt;()...&#125;;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="built_in">std</span>::<span class="keyword">size_t</span> count = [](<span class="keyword">decltype</span>((valid)) v) <span class="keyword">constexpr</span> <span class="keyword">noexcept</span>-&gt;<span class="built_in">std</span>::<span class="keyword">size_t</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> cnt = <span class="built_in">std</span>::<span class="keyword">size_t</span>&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> b : v) <span class="keyword">if</span> (b) ++cnt;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;(valid);</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>GetEnumSize()</code> 用于遍历数列范围内的各个整数，找出有效的枚举有多少个。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E, <span class="keyword">int</span>... Seq&gt;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">auto</span> <span class="title">GetAllValidValues</span><span class="params">(<span class="built_in">std</span>::integer_sequence&lt;<span class="keyword">int</span>, Seq...&gt;)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="built_in">std</span>::<span class="keyword">size_t</span> count = <span class="keyword">sizeof</span>...(Seq);</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">bool</span>, count&gt; valid&#123;IsValidEnum&lt;E, <span class="keyword">static_cast</span>&lt;E&gt;(Seq)&gt;()...&#125;;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>, count&gt; seq&#123;Seq...&#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>, GetEnumSize&lt;E&gt;(NormalIntegerSequence)&gt; values&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">std</span>::<span class="keyword">size_t</span> i = <span class="number">0</span>, v = <span class="number">0</span>; i &lt; count; ++i) <span class="keyword">if</span> (valid[i]) values[v++] = seq[i];</span><br><span class="line">    <span class="keyword">return</span> values;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>GetAllValidValues()</code> 用于遍历数列范围内各个整数，找出全部有效枚举值，返回包含有效值的数组。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E, <span class="keyword">int</span>... Seq&gt;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">auto</span> <span class="title">GetAllValidNames</span><span class="params">(<span class="built_in">std</span>::integer_sequence&lt;<span class="keyword">int</span>, Seq...&gt;)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="built_in">std</span>::string_view, <span class="keyword">sizeof</span>...(Seq)&gt; names&#123;PrettyName&lt;E, <span class="keyword">static_cast</span>&lt;E&gt;(Seq)&gt;()...&#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="built_in">std</span>::string_view, GetEnumSize&lt;E&gt;(NormalIntegerSequence)&gt; validNames&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">std</span>::<span class="keyword">size_t</span> i = <span class="number">0</span>, v = <span class="number">0</span>; i &lt; names.size(); ++i) <span class="keyword">if</span> (!names[i].empty()) validNames[v++] = names[i];</span><br><span class="line">    <span class="keyword">return</span> validNames;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>GetAllValidNames()</code> 用于遍历数列范围内各个整数，找出全部有效枚举值的名字，返回包含这些名字的数组。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="built_in">std</span>::<span class="function">string_view <span class="title">Enum2String</span><span class="params">(E V)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> names = GetAllValidNames&lt;E&gt;(NormalIntegerSequence);</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> values = GetAllValidValues&lt;E&gt;(NormalIntegerSequence);</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> size = GetEnumSize&lt;E&gt;(NormalIntegerSequence);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; size; ++i) <span class="keyword">if</span> (<span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(V) == values[i]) <span class="keyword">return</span> names[i];</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::to_string(<span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(V));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Enum2String()</code> 用于从编译期生成的数组中遍历寻找枚举值等于参数的枚举值名字，如果枚举值无效或者超出范围就范围对应的整数字符串。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li><code>magic_enum</code> 是个很不错的库，但他相对于我的需求来说显得太大了</li><li>根据自己的需求改造开源库，一方面巩固了知识，另一方面也更适合自己的要求</li><li><code>constexpr</code> 这个东东可以在编译期求值，后面可以多花点时间研究一下</li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/126204253" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>原始财富的积累的真的是太难了，那些趁着各种东风各种红利的人们是幸运的，运气也是人生的一部分，而大部分没有这运气的人们想要积累财富，必然要付出十倍甚至上百倍的努力，这些不可选择也无需抱怨，只要踏踏实实往前走就好了~</p></blockquote><!-- 记一次美团师傅清晰洗衣机的经历，一个使用了10多年的小天鹅洗衣机，拆成零件清理了2个多小时 --><blockquote><p>2022-8-7 16:19:20</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;前段时间接触了 &lt;a href=&quot;https://github.com/Neargye/magic_enum&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;magic_enum&lt;/a&gt; 这个开源库，代码量不算太多，是一个但头文件的枚举操作库，关于如何使用还写了一篇总结 &lt;a href=&quot;https://blog.csdn.net/albertsh/article/details/125955230&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《推荐一个C++枚举转字符串的开源项目magic_enum》&lt;/a&gt;，当时觉得这个库很棒，但是对于我当前枚举转化字符串的需求还说还是太臃肿了，所以决定改造一下，这不今天过来填坑了。&lt;/p&gt;
    
    </summary>
    
      <category term="C/C++" scheme="http://AlbertGithubHome.github.io/blog/categories/C-C/"/>
    
    
      <category term="C/C++" scheme="http://AlbertGithubHome.github.io/blog/tags/C-C/"/>
    
      <category term="字符串" scheme="http://AlbertGithubHome.github.io/blog/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="enum" scheme="http://AlbertGithubHome.github.io/blog/tags/enum/"/>
    
      <category term="开源项目" scheme="http://AlbertGithubHome.github.io/blog/tags/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/"/>
    
      <category term="枚举" scheme="http://AlbertGithubHome.github.io/blog/tags/%E6%9E%9A%E4%B8%BE/"/>
    
  </entry>
  
  <entry>
    <title>std::uniform_real_distribution的一个bug引发的服务器崩溃</title>
    <link href="http://AlbertGithubHome.github.io/blog/2022/08/06/std-uniform-real-distribution%E7%9A%84%E4%B8%80%E4%B8%AAbug%E5%BC%95%E5%8F%91%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%B4%A9%E6%BA%83/"/>
    <id>http://AlbertGithubHome.github.io/blog/2022/08/06/std-uniform-real-distribution的一个bug引发的服务器崩溃/</id>
    <published>2022-08-06T15:44:55.000Z</published>
    <updated>2022-08-06T17:56:05.757Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>近日发生一次线上游戏服务器宕机问题，通过日志和core文件信息定位到崩溃的函数，但是崩溃的位置却是一段很长时间都没有改动过的代码，起初怀疑是配置数据的问题，但仔细查看之后均正常，然后又怀疑是玩家旧数据异常导致，但是分析代码逻辑后也没发现问题，最后是一个同事发现生成随机数的代码有bug，导致数组越界了，还真是个意想不到的原因。</p><a id="more"></a><h1 id="崩溃问题"><a href="#崩溃问题" class="headerlink" title="崩溃问题"></a>崩溃问题</h1><p>崩溃出现在从数组中随机一个数的逻辑中，其中用到了 <code>std::uniform_real_distribution</code> 这个模板类，示例代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::random_device rd;</span><br><span class="line">std::mt19937 gen(rd());</span><br><span class="line"><span class="built_in">std</span>::uniform_real_distribution&lt;<span class="keyword">float</span>&gt; dis(<span class="number">0</span>, <span class="number">1.0f</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(dis(gen) * v.size());</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> v[n];</span><br></pre></td></tr></table></figure><p>之前也了解过 <code>std::uniform_real_distribution&lt;float&gt; dis(0, 1.0f);</code> 这个用法，他应该返回的范围是 <code>[0, 1.0)</code> 内左闭右开的浮点数，所以最终计算出的 <code>n</code> 的值应该为 <code>[0, n-1]</code> 范围内的整数，所以这段代码不应该有问题，但是问题却恰恰出现在 <code>std::uniform_real_distribution</code> 的身上。</p><h1 id="std-uniform-real-distribution-lt-gt-的bug"><a href="#std-uniform-real-distribution-lt-gt-的bug" class="headerlink" title="std::uniform_real_distribution&lt;&gt; 的bug"></a>std::uniform_real_distribution&lt;&gt; 的bug</h1><p>std::uniform_real_distribution 这个模板类定义在头文件 <code>&lt;random&gt;</code> 中，是C++11新加的内容，定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt; <span class="class"><span class="keyword">class</span> <span class="title">RealType</span> = <span class="title">double</span> &gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">uniform_real_distribution</span>;</span></span><br></pre></td></tr></table></figure><p>可产生均匀分布在区间 [a, b) 上的随机浮点值 x。</p><p>但是这个函数有个bug，它有时候会返回边界值b，也就是说实际范围变成了 <code>[a, b]</code>。 可以通过 <a href="https://en.cppreference.com/w/cpp/numeric/random/uniform_real_distribution" target="_blank" rel="noopener">cppreference.com - uniform_real_distribution</a>查到，具体描如下：</p><blockquote><p>It is difficult to create a distribution over the closed interval [a,b] from this distribution. Using std::nextafter(b, std::numeric_limits<realtype>::max()) as the second parameter does not always work due to rounding error.</realtype></p><p>Most existing implementations have a bug where they may occasionally return b (GCC #63176 LLVM #18767 MSVC STL #1074). This was originally only thought to happen when RealType is float and when LWG issue 2524 is present, but it has since been shown that neither is required to trigger the bug.</p></blockquote><p>关于这个bug还可以看一下这个帖子的讨论：</p><ul><li><a href="https://stackoverflow.com/questions/25668600/is-1-0-a-valid-output-from-stdgenerate-canonical" target="_blank" rel="noopener">Is 1.0 a valid output from std::generate_canonical?</a></li></ul><p>看得时候注意一下这段描述</p><blockquote><p>This problem can also occur with std::uniform_real_distribution<float>; the solution is the same, to specialize the distribution on double and round the result towards negative infinity in float.</float></p></blockquote><h1 id="bug-重现方法"><a href="#bug-重现方法" class="headerlink" title="bug 重现方法"></a>bug 重现方法</h1><p>这个bug有多种变体，其中一个就是说它和 <code>generate_canonical</code> 产生随机数有关</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;random&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::mt19937 rng;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::seed_seq sequence&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;;</span><br><span class="line">    rng.seed(sequence);</span><br><span class="line">    rng.discard(<span class="number">12</span> * <span class="number">629143</span> + <span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">float</span> random = <span class="built_in">std</span>::generate_canonical&lt;<span class="keyword">float</span>,</span><br><span class="line">                   <span class="built_in">std</span>::numeric_limits&lt;<span class="keyword">float</span>&gt;::digits&gt;(rng);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (random == <span class="number">1.0f</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Bug!\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此段代码在编译器 <code>g++ 5.4.0</code> 上编译执行时能重现，但是在 <code>g++ 10.0.3</code> 上已经被修复无法重现了，再看下面这段代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;random&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::random_device rd;</span><br><span class="line">    std::mt19937 gen(rd());</span><br><span class="line">    <span class="built_in">std</span>::uniform_real_distribution&lt;&gt; dis(<span class="number">0</span>, <span class="number">1.0f</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">float</span> f = dis(gen);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (f &gt;= <span class="number">1.0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"BUG\n"</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码无论是 <code>g++ 5.4.0</code> 版本还是 <code>g++ 10.0.3</code> 都能重现打印出 <code>BUG</code>，这个问题在于模板默认是 <code>double</code> 类型，最后转化成 <code>float</code> 来使用，我按照建议之前帖子中的建议，都改成 <code>double</code> 来使用，之后一直运行了10来天再没出现过随机到边界值的问题。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>标准库中的内容很权威，但是不保证一定是正确的，可以持有怀疑态度</li><li>std::uniform_real_distribution的历史版本是有bug，几乎各个编译器都出现过随机到边界值的情况</li><li>这个bug其实在文档中已经指出了，所以大家看文档时还是要仔细一点，往往使用不规范也容易造成bug</li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/126090054" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>适当的放松是生活的调味剂，有时候真的需要肆意挥霍一下，一张一弛，生活之道~<br><!-- 今天买了100块钱游戏币80个，和猪猪一起玩推小玩具的机器，类似推币，还有打地鼠，打弹珠 --></p><p>2022-8-7 01:30:30</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;近日发生一次线上游戏服务器宕机问题，通过日志和core文件信息定位到崩溃的函数，但是崩溃的位置却是一段很长时间都没有改动过的代码，起初怀疑是配置数据的问题，但仔细查看之后均正常，然后又怀疑是玩家旧数据异常导致，但是分析代码逻辑后也没发现问题，最后是一个同事发现生成随机数的代码有bug，导致数组越界了，还真是个意想不到的原因。&lt;/p&gt;
    
    </summary>
    
      <category term="C/C++" scheme="http://AlbertGithubHome.github.io/blog/categories/C-C/"/>
    
    
      <category term="C/C++" scheme="http://AlbertGithubHome.github.io/blog/tags/C-C/"/>
    
      <category term="随机数" scheme="http://AlbertGithubHome.github.io/blog/tags/%E9%9A%8F%E6%9C%BA%E6%95%B0/"/>
    
      <category term="uniform_real_distribution" scheme="http://AlbertGithubHome.github.io/blog/tags/uniform-real-distribution/"/>
    
      <category term="bug" scheme="http://AlbertGithubHome.github.io/blog/tags/bug/"/>
    
      <category term="random" scheme="http://AlbertGithubHome.github.io/blog/tags/random/"/>
    
  </entry>
  
  <entry>
    <title>SVN如何删除文件名包含空格的文件</title>
    <link href="http://AlbertGithubHome.github.io/blog/2022/07/31/SVN%E5%A6%82%E4%BD%95%E5%88%A0%E9%99%A4%E6%96%87%E4%BB%B6%E5%90%8D%E5%8C%85%E5%90%AB%E7%A9%BA%E6%A0%BC%E7%9A%84%E6%96%87%E4%BB%B6/"/>
    <id>http://AlbertGithubHome.github.io/blog/2022/07/31/SVN如何删除文件名包含空格的文件/</id>
    <published>2022-07-31T09:21:53.000Z</published>
    <updated>2022-07-31T12:37:52.060Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><code>SVN</code> 和 <code>Git</code> 两个常用的版本管理工具都有 <code>add</code> 和 <code>commit</code> 命令，但是这两个命令的含义是不同的，<code>git add</code> 命令添加的是变化的文件，不管是增加的文件、删除的文件还是更新的文件，使用 <code>git add</code> 命令之后都可以放到暂存区，而 <code>svn add</code> 命令只能影响新增和变化的文件，对原在库中现已删除的文件没有影响，想要真正删除文件需要在执行 <code>svn commit</code> 命令之前先执行 <code>svn delete</code> 命令。</p><a id="more"></a><h1 id="SVN删除文件"><a href="#SVN删除文件" class="headerlink" title="SVN删除文件"></a>SVN删除文件</h1><p><code>SVN</code> 删除文件需要指定文件名字，而使用在一些自动化脚本中时，被删除的文件都是其他脚本自动删除的，要想获得这些文件的名字，可以利用 <code>svn st</code> 命令来查询，然后搭配管道再使用 <code>svn del</code> 命令来删除这些文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ svn st</span><br><span class="line">!       test/A.txt</span><br><span class="line">!       test/B.txt</span><br><span class="line">!       test/C Blank.txt</span><br><span class="line">!       test/DD.txt</span><br><span class="line">M       test/E.txt</span><br><span class="line">?       test/F.txt</span><br><span class="line">A       test/G.txt</span><br></pre></td></tr></table></figure><p><code>svn st</code> 命令的结果对每个变化文件显示一行，第一列是文件状态，第二列及后面的部分是文件名</p><ul><li><code>!</code>：表示已经删除的文件</li><li><code>M</code>：表示文件内容发生变化的文件</li><li><code>?</code>：表示一个新文件，不在原版本库中</li><li><code>A</code>：表示本次新增的文件</li></ul><p>要想删除文件只需要把 <code>!</code> 开头的文件删除就可以了，常规命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">svn st | grep ^! | awk <span class="string">'&#123;print " --force "$2&#125;'</span> | xargs -r svn del</span><br></pre></td></tr></table></figure><p>这个命令就是要生成 <code>svn del --force test/A.txt</code> 命令然后执行，这样就能达到删除文件的目的了</p><p>基于这个目的，一般自动化部署的机器上的svn提交命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">svn st | grep ^! | awk <span class="string">'&#123;print " --force "$2&#125;'</span> | xargs -r svn del</span><br><span class="line">svn add . --no-ignore --force</span><br><span class="line">svn commit -m <span class="string">"build message"</span></span><br></pre></td></tr></table></figure><h1 id="被删除的文件名带空格"><a href="#被删除的文件名带空格" class="headerlink" title="被删除的文件名带空格"></a>被删除的文件名带空格</h1><p>上述命令能处理绝大部分的情况，但是如果被删除的文件中包含空格，那么执行命令时就会报错:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ svn st | grep ^! | awk <span class="string">'&#123;print " --force "$2&#125;'</span> | xargs -r svn del</span><br><span class="line">svn: E125001: <span class="string">'test/C'</span> does not exist</span><br></pre></td></tr></table></figure><p>为什么会报错的呢？就是说因为文件 <code>test/C Blank.txt</code> 的名字中包含了空格，使用 <code>awk &#39;{print &quot; --force &quot;$2}&#39;</code> 把空格后半部分的文件名丢掉了，所以只要处理一下这种情况就可以了，处理命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">svn st | grep ^! | awk <span class="string">'&#123;$1="";print $0 &#125;'</span> | awk <span class="string">'$1=$1'</span> | awk <span class="string">'&#123;print " --force ""\""$0"\""&#125;'</span> | xargs -r svn del</span><br></pre></td></tr></table></figure><ul><li><code>svn st</code> 显示个文件状态</li><li><code>grep ^!</code> 过滤出原在版本库中但现已删除的文件</li><li><code>awk &#39;{$1=&quot;&quot;;print $0 }&#39;</code> 去掉每行信息中第一列的状态值</li><li><code>awk &#39;$1=$1&#39;</code> 去掉数据开头和结尾的空格</li><li><code>awk &#39;{print &quot; --force &quot;&quot;\&quot;&quot;$0&quot;\&quot;&quot;}&#39;</code> 拼接文件名，并在前后添加引号，<code>--force &quot;test/C Blank.txt&quot;</code></li><li><code>xargs -r svn del</code> 利用管道传递文件名将文件删除</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li><code>svn st</code> 命令可以查询 <code>SVN</code> 当前目录下各个文件的状态</li><li><code>svn del</code> 命令用于删除原版本库中的文件</li><li>如果待删除的文件名包含空格可使用 <code>svn st | grep ^! | awk &#39;{$1=&quot;&quot;;print $0}&#39; | awk &#39;$1=$1&#39; | awk &#39;{print &quot; --force &quot;&quot;\&quot;&quot;$0&quot;\&quot;&quot;}&#39; | xargs -r svn del</code></li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/126075098" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>互发声明并非只是打打嘴架，应该是在相互试探着对方的底线，各自盘算着多方的利益，双方都是极其聪明的人，背后也都有强大的团队提供支持，博弈啊博弈，每一方都会选择对自己最有利的行动~</p><p>2022-7-31 20:13:21</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&lt;code&gt;SVN&lt;/code&gt; 和 &lt;code&gt;Git&lt;/code&gt; 两个常用的版本管理工具都有 &lt;code&gt;add&lt;/code&gt; 和 &lt;code&gt;commit&lt;/code&gt; 命令，但是这两个命令的含义是不同的，&lt;code&gt;git add&lt;/code&gt; 命令添加的是变化的文件，不管是增加的文件、删除的文件还是更新的文件，使用 &lt;code&gt;git add&lt;/code&gt; 命令之后都可以放到暂存区，而 &lt;code&gt;svn add&lt;/code&gt; 命令只能影响新增和变化的文件，对原在库中现已删除的文件没有影响，想要真正删除文件需要在执行 &lt;code&gt;svn commit&lt;/code&gt; 命令之前先执行 &lt;code&gt;svn delete&lt;/code&gt; 命令。&lt;/p&gt;
    
    </summary>
    
      <category term="SVN" scheme="http://AlbertGithubHome.github.io/blog/categories/SVN/"/>
    
    
      <category term="SVN" scheme="http://AlbertGithubHome.github.io/blog/tags/SVN/"/>
    
      <category term="del" scheme="http://AlbertGithubHome.github.io/blog/tags/del/"/>
    
      <category term="add" scheme="http://AlbertGithubHome.github.io/blog/tags/add/"/>
    
      <category term="commit" scheme="http://AlbertGithubHome.github.io/blog/tags/commit/"/>
    
  </entry>
  
  <entry>
    <title>一个月黑风高的夜晚紧急完成gitlab服务器数据迁移</title>
    <link href="http://AlbertGithubHome.github.io/blog/2022/07/30/%E4%B8%80%E4%B8%AA%E6%9C%88%E9%BB%91%E9%A3%8E%E9%AB%98%E7%9A%84%E5%A4%9C%E6%99%9A%E7%B4%A7%E6%80%A5%E5%AE%8C%E6%88%90gitlab%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%95%B0%E6%8D%AE%E8%BF%81%E7%A7%BB/"/>
    <id>http://AlbertGithubHome.github.io/blog/2022/07/30/一个月黑风高的夜晚紧急完成gitlab服务器数据迁移/</id>
    <published>2022-07-30T07:05:29.000Z</published>
    <updated>2022-07-30T09:29:45.138Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>真是无巧不成书，白天刚刚讨论了一天<code>SVN</code>服务器迁移事情，晚上突然被告知 <code>gitlab</code> 服务无法访问了，赶紧连接到服务器上查看，好家伙，磁盘还剩下可怜的 <code>98K</code>，<code>SVN</code> 不管了，先把 <code>gitlab</code> 搞定吧，毕竟第二天的游戏更新包都打不出来了，确认是磁盘不足问题后已经是9点半了，月亮都升起老高了，赶紧开始修复吧。</p><a id="more"></a><h1 id="修复过程"><a href="#修复过程" class="headerlink" title="修复过程"></a>修复过程</h1><p>关于修复过程，网上有很多文章写了具体的步骤，都非常的相似，基本来自于官方文档的翻译，不过抄来抄去的内容产生了一些错误，甚至是在关键的步骤上出错，所以在看这些文章是要特别注意，如果你的英文还不错的话，建议看一下<a href="https://docs.gitlab.com/omnibus/settings/configuration.html#store-git-data-in-an-alternative-directory" target="_blank" rel="noopener">官方文档</a></p><p>为了记录过程我也不免俗套的把这些步骤写一写，方便日后拿来即用，关于每步的作用我会进行简述，并且提一下注意事项。</p><blockquote><p>总体步骤：在配置文件中把存放数据的路径改一个新目录，把原数据移动到新的目录，重启gitlab服务即可</p></blockquote><h2 id="备份数据"><a href="#备份数据" class="headerlink" title="备份数据"></a>备份数据</h2><p>虽然只是做数据迁移，不涉及切换物理机，也不会更换服务版本，但是为了保险起见，还是先把数据备份一份，现在遇到的问题是 <code>gitlab</code> 是默认安装的，数据存放在 <code>/var/opt/gitlab/git-data</code> 目录下，仓库存放在子目录 <code>repositories</code> 里面，这个目录一般空间都不大，很容易出现磁盘满的情况，目录结构如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">git-data</span><br><span class="line">└── repositories</span><br><span class="line">    ├── +gitaly</span><br><span class="line">    │   ├── cache</span><br><span class="line">    │   ├── state</span><br><span class="line">    │   └── tmp</span><br><span class="line">    └── @hashed</span><br><span class="line">        ├── 19</span><br><span class="line">        ├── 35</span><br><span class="line">        ├── 3f</span><br><span class="line">        ├── 45</span><br><span class="line">        ├── 4a</span><br><span class="line">        ├── 4b</span><br><span class="line">        ├── ...</span><br><span class="line">        └── f5</span><br></pre></td></tr></table></figure><p>真正的仓库数据就在 <code>@hashed</code> 目录下众多子目录下，再往下走就是一个个 <code>.git</code>目录了，结构与我们本地的 <code>.git</code> 目录一致。</p><p>备份的命令需要记录一下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gitlab-rake gitlab:backup:create</span><br></pre></td></tr></table></figure><p>备份的路径可以在配置文件 <code>/etc/gitlab/gitlab.rb</code> 中修改：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@code-server ~]<span class="comment"># vim /etc/gitlab/gitlab.rb</span></span><br><span class="line">gitlab_rails[<span class="string">'manage_backup_path'</span>] = <span class="literal">true</span></span><br><span class="line">gitlab_rails[<span class="string">'backup_path'</span>] = <span class="string">"/data/gitlab/backups"</span>    // gitlab备份目录</span><br><span class="line">gitlab_rails[<span class="string">'backup_archive_permissions'</span>] = 0644       // 生成的备份文件权限</span><br><span class="line">gitlab_rails[<span class="string">'backup_keep_time'</span>] = 7776000              // 备份保留天数为90天</span><br></pre></td></tr></table></figure><p>备份从21:30开始一直到凌晨1点左右结束，<code>200G</code> 数据用时3个半小时，真是太慢了，大部分的时间都卡在备份了 <code>Dumping lfs objects</code> 了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">[root@gitlab-server ~]# gitlab-rake gitlab:backup:create</span><br><span class="line">2022-07-25 21:27:34 +0800 -- Dumping database ...</span><br><span class="line">Dumping PostgreSQL database gitlabhq_production ... [DONE]</span><br><span class="line">2022-07-25 21:27:42 +0800 -- done</span><br><span class="line">2022-07-25 21:27:42 +0800 -- Dumping repositories ...</span><br><span class="line"> * xxxx/project (@hashed/d4/73/d4735e3a265e16eee03f59718b9b5d03019c07d8b6c51f90da3a666eec13ab3x) ...</span><br><span class="line"> * xxxx/project (@hashed/d4/73/d4735e3a265e16eee03f59718b9b5d03019c07d8b6c51f90da3a666eec13ab3x) ... [DONE]</span><br><span class="line"> * xxxx/project.wiki (@hashed/d4/73/d4735e3a265e16eee03f59718b9b5d03019c07d8b6c51f90da3a666eec13ab3x.wiki) ...</span><br><span class="line"> * xxxx/project.wiki (@hashed/d4/73/d4735e3a265e16eee03f59718b9b5d03019c07d8b6c51f90da3a666eec13ab3x.wiki) ... [EMPTY] [SKIPPED]</span><br><span class="line"> * xxxx/project.design (@hashed/d4/73/d4735e3a265e16eee03f59718b9b5d03019c07d8b6c51f90da3a666eec13ab3x.design) ...</span><br><span class="line"> * xxxx/project.design (@hashed/d4/73/d4735e3a265e16eee03f59718b9b5d03019c07d8b6c51f90da3a666eec13ab3x.design) ... [EMPTY] [SKIPPED]</span><br><span class="line"> ...</span><br><span class="line"> ...</span><br><span class="line">2022-07-25 22:16:14 +0800 -- done</span><br><span class="line">2022-07-25 22:16:14 +0800 -- Dumping uploads ...</span><br><span class="line">2022-07-25 22:16:15 +0800 -- done</span><br><span class="line">2022-07-25 22:16:15 +0800 -- Dumping builds ...</span><br><span class="line">2022-07-25 22:16:15 +0800 -- done</span><br><span class="line">2022-07-25 22:16:15 +0800 -- Dumping artifacts ...</span><br><span class="line">2022-07-25 22:16:15 +0800 -- done</span><br><span class="line">2022-07-25 22:16:15 +0800 -- Dumping pages ...</span><br><span class="line">2022-07-25 22:16:15 +0800 -- done</span><br><span class="line">2022-07-25 22:16:15 +0800 -- Dumping lfs objects ...</span><br><span class="line">2022-07-26 00:41:39 +0800 -- done</span><br><span class="line">2022-07-26 00:41:39 +0800 -- Dumping container registry images ...</span><br><span class="line">2022-07-26 00:41:39 +0800 -- [DISABLED]</span><br><span class="line">Creating backup archive: 1658767299_2022_07_26_xx.xx.xx-ee_gitlab_backup.tar ... done</span><br><span class="line">Uploading backup archive to remote storage  ... skipped</span><br><span class="line">Deleting tmp directories ... done</span><br><span class="line">done</span><br><span class="line">done</span><br><span class="line">done</span><br><span class="line">done</span><br><span class="line">done</span><br><span class="line">done</span><br><span class="line">done</span><br><span class="line">Deleting old backups ... skipping</span><br><span class="line">Warning: Your gitlab.rb and gitlab-secrets.json files contain sensitive data</span><br><span class="line">and are not included in this backup. You will need these files to restore a backup.</span><br><span class="line">Please back them up manually.</span><br><span class="line">Backup task is done.</span><br></pre></td></tr></table></figure><h2 id="修改存放目录"><a href="#修改存放目录" class="headerlink" title="修改存放目录"></a>修改存放目录</h2><p>这一步注意创建新目录后修改权限，并修改配置文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@gitlab ~]<span class="comment"># mkdir -p /data/gitlab-data</span></span><br><span class="line">[root@gitlab ~]<span class="comment"># chown -R git:root /data/gitlab-data</span></span><br><span class="line">[root@gitlab ~]<span class="comment"># vim /etc/gitlab/gitlab.rb</span></span><br><span class="line"><span class="comment"># 把注释取消然后指定新的仓库存储位置，原配置是# git_data_dirs(&#123; "default" =&gt; &#123; "path" =&gt; "/mnt/nas/git-data" &#125; &#125;)</span></span><br><span class="line">git_data_dirs(&#123; <span class="string">"default"</span> =&gt; &#123; <span class="string">"path"</span> =&gt; <span class="string">"/data/gitlab-data"</span> &#125; &#125;)</span><br></pre></td></tr></table></figure><p><code>/data/gitlab-data</code> 是新挂载的目录，目标路径和其子路径必须不能为软链接。</p><h2 id="关闭服务"><a href="#关闭服务" class="headerlink" title="关闭服务"></a>关闭服务</h2><p>迁移数据前关闭服务主要是怕别人再使用，其实已经凌晨应该没有人用了，为了保险起见还是先关了吧</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gitlab-ctl stop</span><br></pre></td></tr></table></figure><p>关闭时会自动关闭多个服务项</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[root@gitlab-server gitlab]<span class="comment"># gitlab-ctl stop</span></span><br><span class="line">ok: down: alertmanager: 0s, normally up</span><br><span class="line">ok: down: gitaly: 0s, normally up</span><br><span class="line">ok: down: gitlab-exporter: 0s, normally up</span><br><span class="line">ok: down: gitlab-workhorse: 0s, normally up</span><br><span class="line">ok: down: grafana: 0s, normally up</span><br><span class="line">ok: down: logrotate: 0s, normally up</span><br><span class="line">ok: down: nginx: 1s, normally up</span><br><span class="line">ok: down: node-exporter: 0s, normally up</span><br><span class="line">ok: down: postgres-exporter: 1s, normally up</span><br><span class="line">ok: down: postgresql: 0s, normally up</span><br><span class="line">ok: down: prometheus: 0s, normally up</span><br><span class="line">ok: down: puma: 0s, normally up</span><br><span class="line">ok: down: redis: 0s, normally up</span><br><span class="line">ok: down: redis-exporter: 1s, normally up</span><br><span class="line">ok: down: sidekiq: 0s, normally up</span><br></pre></td></tr></table></figure><h2 id="迁移数据"><a href="#迁移数据" class="headerlink" title="迁移数据"></a>迁移数据</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rsync -av /var/opt/gitlab/git-data/repositories /data/gitlab-data/</span><br></pre></td></tr></table></figure><p>末尾的<code>/</code>要有，这一点很多文章都提到了，但是它们给的例子中有没有，很容易造成迷惑，这一步其实就是把 <code>repositories</code> 完整的拷贝到 <code>/data/gitlab-data/</code> 目录下，并保留原文件和目录的属性，不加 <code>/</code> 就少了一级目录，不过也有文章让使用 <code>cp</code> 或者 <code>mv</code> 命令迁移数据，虽然也能达到目的，但是不如 <code>rsync</code> 合适，他们无法保留原属性。</p><p>200G 数据拷贝了半小时，比备份操作快多了</p><h2 id="刷新配置"><a href="#刷新配置" class="headerlink" title="刷新配置"></a>刷新配置</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gitlab-ctl reconfigure</span><br></pre></td></tr></table></figure><p>这一步我在执行前以为瞬间就能完成，运行后才发现这个命令检查了很多数据，在控制台输出了一大堆内容，可以注意一下有没有报错信息。</p><h2 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gitlab-ctl start</span><br></pre></td></tr></table></figure><p>启动之后需要等大概一分钟才能访问，否则会报服务器内部错误，应该是有些服务还没完全开始工作吧</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[root@gitlab-server gitlab]<span class="comment"># gitlab-ctl start</span></span><br><span class="line">ok: run: alertmanager: (pid 17961) 1s</span><br><span class="line">ok: run: gitaly: (pid 17984) 0s</span><br><span class="line">ok: run: gitlab-exporter: (pid 18023) 0s</span><br><span class="line">ok: run: gitlab-workhorse: (pid 18025) 1s</span><br><span class="line">ok: run: grafana: (pid 18054) 0s</span><br><span class="line">ok: run: logrotate: (pid 18063) 1s</span><br><span class="line">ok: run: nginx: (pid 18082) 0s</span><br><span class="line">ok: run: node-exporter: (pid 18111) 1s</span><br><span class="line">ok: run: postgres-exporter: (pid 18120) 0s</span><br><span class="line">ok: run: postgresql: (pid 18129) 0s</span><br><span class="line">ok: run: prometheus: (pid 18136) 1s</span><br><span class="line">ok: run: puma: (pid 18151) 0s</span><br><span class="line">ok: run: redis: (pid 18157) 1s</span><br><span class="line">ok: run: redis-exporter: (pid 18173) 0s</span><br><span class="line">ok: run: sidekiq: (pid 18183) 1s</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li><code>gitlab</code> 服务器配置文件是 <code>/etc/gitlab/gitlab.rb</code></li><li><code>gitlab</code> 配置文中设置备份目录 <code>gitlab_rails[&#39;manage_backup_path&#39;]</code>，存储目录 <code>git_data_dirs</code></li><li><code>gitlab-rake gitlab:backup:create</code> 用于备份</li><li><code>gitlab</code> 关闭组件 <code>gitlab-ctl stop</code>，开启组件 <code>gitlab-ctl start</code>，重启组件 <code>gitlab-ctl restart</code></li><li><code>gitlab-ctl reconfigure</code> 用于刷新配置</li><li><code>gitlab</code> 迁移数据命令 <code>rsync -av /var/opt/gitlab/git-data/repositories /data/gitlab-data/</code></li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/126068911" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>曾经幅员辽阔，东征西讨的元朝占据了欧亚大陆，但持续时间不过百年，在历史长河中只是星星点点，若要在这长河中留下痕迹，必然要做出影响全人类的重大成就，而你我绝大多数都是普通人，承认自己是普通人的那一刻你已经成长了~</p><p>2022-7-30 16:59:18</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;真是无巧不成书，白天刚刚讨论了一天&lt;code&gt;SVN&lt;/code&gt;服务器迁移事情，晚上突然被告知 &lt;code&gt;gitlab&lt;/code&gt; 服务无法访问了，赶紧连接到服务器上查看，好家伙，磁盘还剩下可怜的 &lt;code&gt;98K&lt;/code&gt;，&lt;code&gt;SVN&lt;/code&gt; 不管了，先把 &lt;code&gt;gitlab&lt;/code&gt; 搞定吧，毕竟第二天的游戏更新包都打不出来了，确认是磁盘不足问题后已经是9点半了，月亮都升起老高了，赶紧开始修复吧。&lt;/p&gt;
    
    </summary>
    
      <category term="CI/CD" scheme="http://AlbertGithubHome.github.io/blog/categories/CI-CD/"/>
    
    
      <category term="git" scheme="http://AlbertGithubHome.github.io/blog/tags/git/"/>
    
      <category term="gitlab" scheme="http://AlbertGithubHome.github.io/blog/tags/gitlab/"/>
    
      <category term="数据迁移" scheme="http://AlbertGithubHome.github.io/blog/tags/%E6%95%B0%E6%8D%AE%E8%BF%81%E7%A7%BB/"/>
    
      <category term="服务器" scheme="http://AlbertGithubHome.github.io/blog/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>推荐一个C++枚举转字符串的开源项目magic_enum</title>
    <link href="http://AlbertGithubHome.github.io/blog/2022/07/23/%E6%8E%A8%E8%8D%90%E4%B8%80%E4%B8%AAC-%E6%9E%9A%E4%B8%BE%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AEmagic-enum/"/>
    <id>http://AlbertGithubHome.github.io/blog/2022/07/23/推荐一个C-枚举转字符串的开源项目magic-enum/</id>
    <published>2022-07-23T14:20:14.000Z</published>
    <updated>2022-08-21T00:11:08.627Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>C++11引入了强类型的枚举类 <code>enum class</code> 用来代替旧风格枚举<code>enum</code>，新引入的 <code>enum class</code> 具有诸多优点：防止命名空间污染，不能隐式的转换为整型，防止不同类型的枚举相互赋值，支持前置声明。当然它也不是只有优点，因为类型不能隐式转换成int，所以在使用或者输出时需要使用 <code>static_cast</code> 进行转换，不过即便使用 <code>static_cast</code> 可以转换后输出，也不便于我们辨识枚举的值，如果想输出枚举定义时的名字就需要使用一些魔法了。</p><a id="more"></a><h1 id="magic-enum"><a href="#magic-enum" class="headerlink" title="magic_enum"></a>magic_enum</h1><p>因为C++本身不支持反射，或者说反射能力极弱，所以想反射我们必须自己实现一些东西，比如 <code>UE</code> 引擎就为C++写了一套自己的反射标签，而我们想获得枚举定义时的名字就需要自己记录了，因为编译后的枚举一般都转化成了整数，一个简单粗暴的想法是在定义时为每个枚举值同时指定一个同名字符串，构成map存储下来，不过我们不想每次都自己来做这件事，要是有人能帮忙就好了，这不它来了， <a href="https://github.com/Neargye/magic_enum" target="_blank" rel="noopener">magic_enum</a> 就可以帮你实现这个愿望。</p><h2 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h2><p><a href="https://github.com/Neargye/magic_enum" target="_blank" rel="noopener">magic_enum</a> 是一个单头文件的开源库，使用方便，可以轻松帮你实现打印枚举值定义时名字的需求，另外除了可以实现这个功能，还可以根据字符串生成枚举值，根据整数生成枚举值，获取枚举值数组，获取枚举值和名字对应的数字组等等，简直是一个封装了枚举操作的宝库。</p><h2 id="具体使用"><a href="#具体使用" class="headerlink" title="具体使用"></a>具体使用</h2><p>直接引用头文件 <code>magic_enum.hpp</code>，然后调用函数 <code>magic_enum::enum_name(enum_xxx)</code> 即可：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"magic_enum.hpp"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">WeekDay</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    WD_SUNDAY = <span class="number">0</span>,</span><br><span class="line">    WD_MONDAY,</span><br><span class="line">    WD_TUESDAY,</span><br><span class="line">    WD_WEDNESDAY,</span><br><span class="line">    WD_THURSDAY,</span><br><span class="line">    WD_FRIDAY,</span><br><span class="line">    WD_SATURDAY,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    WeekDay day = WeekDay::WD_MONDAY;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"enum value: "</span> &lt;&lt; <span class="keyword">static_cast</span>&lt;<span class="built_in">std</span>::underlying_type&lt;WeekDay&gt;::type&gt;(day) &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"enum name:  "</span> &lt;&lt; magic_enum::enum_name(day) &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译运行如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ g++ testenum.cpp -std=c++17 &amp;&amp; ./a.out</span><br><span class="line">enum value: 1</span><br><span class="line">enum name:  WD_MONDAY</span><br></pre></td></tr></table></figure><h2 id="原理简述"><a href="#原理简述" class="headerlink" title="原理简述"></a>原理简述</h2><p>很神奇对不对，其实枚举值转换成字符串这一步，是是利用了函数模板和 <code>__PRETTY_FUNCTION__</code> 组合使用获得到的，也就是对 <code>__PRETTY_FUNCTION__</code> 进行截取得到的字符串。</p><p><code>__PRETTY_FUNCTION__</code> 在预编译阶段会替换成带有参数的函数名，比如 <code>constexpr auto magic_enum::detail::n() [with E = WeekDay; E e = WD_MONDAY]</code> 从中截取出 <code>WD_MONDAY</code> 就可以了。</p><h2 id="局限性"><a href="#局限性" class="headerlink" title="局限性"></a>局限性</h2><p>为了实现从字符串到枚举值的转换，这个库的内部定义了一个整数范围，默认从-128到128，用于遍历查找字符串对应的枚举值是多少，并且在代码中加了 <code>static_assert</code> 来判断范围，如果超过了这个范围就会报编译错误，这个范围可以通过修改源码中的 <code>MAGIC_ENUM_RANGE_MIN</code> 和 <code>MAGIC_ENUM_RANGE_MAX</code> 重新编译来修改，在这个范围之外还有个最大值 <code>std::numeric_limits&lt;std::uint16_t&gt;::max</code> 的限制。</p><p>这个最大限制也是可以改的，不过我尝试把 <code>MAGIC_ENUM_RANGE_MAX</code> 改到上限值 32767 之后编译时间明显变成，编译过程变得异常的慢，单个文件编译30秒，所以不建议把这个值调太大。</p><p>对比一下不使用 <code>magic_enum</code> 和使用它之后生成的汇编代码，从100多行扩充到1000多行，利用 <code>type_traits</code> 生成了大量的函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    .type   _ZN10magic_enum6detail7names_vI7WeekDayEE, @gnu_unique_object</span><br><span class="line">    .size   _ZN10magic_enum6detail7names_vI7WeekDayEE, 112</span><br><span class="line">_ZN10magic_enum6detail7names_vI7WeekDayEE:</span><br><span class="line">    .quad   9</span><br><span class="line">    .quad   _ZN10magic_enum6detail11enum_name_vI7WeekDayLS2_0EEE</span><br><span class="line">    .quad   9</span><br><span class="line">    .quad   _ZN10magic_enum6detail11enum_name_vI7WeekDayLS2_1EEE</span><br><span class="line">    .quad   10</span><br><span class="line">    .quad   _ZN10magic_enum6detail11enum_name_vI7WeekDayLS2_2EEE</span><br><span class="line">    .quad   12</span><br><span class="line">    .quad   _ZN10magic_enum6detail11enum_name_vI7WeekDayLS2_3EEE</span><br><span class="line">    .quad   11</span><br><span class="line">    .quad   _ZN10magic_enum6detail11enum_name_vI7WeekDayLS2_4EEE</span><br><span class="line">    .quad   9</span><br><span class="line">    .quad   _ZN10magic_enum6detail11enum_name_vI7WeekDayLS2_5EEE</span><br><span class="line">    .quad   11</span><br><span class="line">    .quad   _ZN10magic_enum6detail11enum_name_vI7WeekDayLS2_6EEE</span><br><span class="line">    .weak   _ZN10magic_enum6detail11enum_name_vI7WeekDayLS2_0EEE</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h1 id="简化与改进"><a href="#简化与改进" class="headerlink" title="简化与改进"></a>简化与改进</h1><p>其实我最想要的还是通过枚举值转化转化成字符串名称的功能，可以将这个开源库简化一下，仅保留这个功能，这样也不会有范围限制了，感觉这个库为了实现从字符串到枚举值转换背负了太多，去掉它会很清爽。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li><code>magic_enum</code> 是一个开源的、单头文件的、枚举操作工具箱</li><li><code>magic_enum</code> 可以实现枚举值到字符串、字符串到枚举值、获取所有枚举名等多种操作</li><li><code>magic_enum</code> 本身对枚举值有范围限制，默认是 [-128, 128], 可通过 <code>MAGIC_ENUM_RANGE_MIN</code> 和 <code>MAGIC_ENUM_RANGE_MAX</code> 修改</li><li>不建议将 <code>magic_enum</code> 默认枚举范围改的太大，这会明显拖慢编译时间</li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/125839078" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>世界上有那么多美好，不要跟自己过不去，总是揪着那些角落里的肮脏不放。我们无法选择抓到什么牌，但可以决定怎么把已经抓到手的牌打出去，摆烂是一天，奋斗也是一天，究竟要怎么做，取决于你自己~</p><p>2022-7-24 02:30:58</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;C++11引入了强类型的枚举类 &lt;code&gt;enum class&lt;/code&gt; 用来代替旧风格枚举&lt;code&gt;enum&lt;/code&gt;，新引入的 &lt;code&gt;enum class&lt;/code&gt; 具有诸多优点：防止命名空间污染，不能隐式的转换为整型，防止不同类型的枚举相互赋值，支持前置声明。当然它也不是只有优点，因为类型不能隐式转换成int，所以在使用或者输出时需要使用 &lt;code&gt;static_cast&lt;/code&gt; 进行转换，不过即便使用 &lt;code&gt;static_cast&lt;/code&gt; 可以转换后输出，也不便于我们辨识枚举的值，如果想输出枚举定义时的名字就需要使用一些魔法了。&lt;/p&gt;
    
    </summary>
    
      <category term="C/C++" scheme="http://AlbertGithubHome.github.io/blog/categories/C-C/"/>
    
    
      <category term="C/C++" scheme="http://AlbertGithubHome.github.io/blog/tags/C-C/"/>
    
      <category term="enum" scheme="http://AlbertGithubHome.github.io/blog/tags/enum/"/>
    
      <category term="枚举类" scheme="http://AlbertGithubHome.github.io/blog/tags/%E6%9E%9A%E4%B8%BE%E7%B1%BB/"/>
    
      <category term="magic_enum" scheme="http://AlbertGithubHome.github.io/blog/tags/magic-enum/"/>
    
  </entry>
  
  <entry>
    <title>C++17使用std::optional表示一个可能存在的值</title>
    <link href="http://AlbertGithubHome.github.io/blog/2022/07/17/C-17%E4%BD%BF%E7%94%A8std-optional%E8%A1%A8%E7%A4%BA%E4%B8%80%E4%B8%AA%E5%8F%AF%E8%83%BD%E5%AD%98%E5%9C%A8%E7%9A%84%E5%80%BC/"/>
    <id>http://AlbertGithubHome.github.io/blog/2022/07/17/C-17使用std-optional表示一个可能存在的值/</id>
    <published>2022-07-17T12:33:58.000Z</published>
    <updated>2022-07-17T15:38:39.290Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>平时写代码会遇到一种传递参数<code>特殊值</code>标记特殊流程，或者函数返回值存在魔法数的情况，很需要一种标记参数或返回值状态的结构，那么在 C++17 标准下提供了 <code>std::optional</code> 这个模板类，可以表示一个值不存在的状态，一起来看看用法吧。</p><a id="more"></a><h1 id="返回一个bool值"><a href="#返回一个bool值" class="headerlink" title="返回一个bool值"></a>返回一个bool值</h1><p>以下例子纯属虚构，只为说明问题，无实际意义</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">getBoolVal</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>* n = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line">    <span class="keyword">if</span> (!n)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    *n = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (a + *n &gt; b)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (getBoolVal(<span class="number">10</span>, <span class="number">9</span>))</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="number">1</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="number">1</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个例子中的函数 <code>getBoolVal</code> 本意是想返回一个 bool 类型的判断结果，但是函数中有一些异常情况时，比如申请内存异常时，也会返回一个bool值，这是与原判断结果语义不同的，所以需要单独返回这种情况，如果也放到同一个返回值中会导致含义模糊，这时可以考虑使用引用变量参数来返回实际比较结果。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">getBoolVal</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">bool</span>&amp; ret)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>* n = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line">    <span class="keyword">if</span> (!n)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    *n = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (a + *n &gt; b)</span><br><span class="line">        ret = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        ret = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> ret = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (getBoolVal(<span class="number">10</span>, <span class="number">9</span>, ret))</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"error"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (ret)</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="number">1</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="number">0</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个引用参数 <code>ret</code> 使用起来有点不方便，那把两个值都返回怎么样，虽然C++不允许有多个返回值，但可以把它们包装成 <code>std::pair</code> 或者 <code>std::tuple</code> 来返回，再来改写一下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::pair&lt;<span class="keyword">bool</span>, <span class="keyword">bool</span>&gt; getBoolVal3(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span>* n = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line">    <span class="keyword">if</span> (!n)</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="literal">false</span>, <span class="literal">false</span>&#125;;</span><br><span class="line"></span><br><span class="line">    *n = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (a + *n &gt; b)</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="literal">true</span>, <span class="literal">true</span>&#125;;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="literal">true</span>, <span class="literal">false</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> [err, ret] = getBoolVal(<span class="number">10</span>, <span class="number">9</span>);</span><br><span class="line">    <span class="keyword">if</span> (err)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"error"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (ret)</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="number">1</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="number">0</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方法把实际的返回值，搭配一个表示状态的 bool 变量，组成 <code>std::pair</code> 进行返回，基本上得到而来语义明确的目的，但是看起来还是不太优雅，而 <code>std::optional</code> 可以帮助我们实现类似的需求，并且代码看起来能更简洁一点。</p><h1 id="使用-std-optional-改写"><a href="#使用-std-optional-改写" class="headerlink" title="使用 std::optional 改写"></a>使用 std::optional 改写</h1><p><code>std::optional</code> 本身是一个模板类：会有一个 <code>std::nullopt</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">optional</span>;</span></span><br></pre></td></tr></table></figure><p>它内部有两种状态，要么有一个T类型的值，要么用 <code>std::nullopt</code> 表示没有值，查看一个 <code>std::optional</code> 对象是否有值，可以用 <code>has_value()</code> 进行判断，当一个 <code>std::optional</code> 有值时，可以通过用指针的方式(<code>*</code>号和<code>-&gt;</code>号)来使用它，或者用 <code>value()</code>函数取它的值，下面我们用它来改写一下之前的实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::optional&lt;<span class="keyword">bool</span>&gt; getBoolVal4(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span>* n = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line">    <span class="keyword">if</span> (!n)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">std</span>::nullopt;</span><br><span class="line"></span><br><span class="line">    *n = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (a + *n &gt; b)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::optional&lt;<span class="keyword">bool</span>&gt; ret = getBoolVal(<span class="number">10</span>, <span class="number">9</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret.has_value())</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"error"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (ret.value())</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="number">1</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="number">0</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用了 <code>std::optional</code> 之后就把 <code>bool</code> 类型之前的两态变成了三态，很多类似的逻辑也被封装成了函数，使用它之后代码更清晰了，从此可以告别一些烦人的魔法数了，一些函数参数也可以使用 <code>std::optional</code> 来包装，用法类似，在此就不展开说了。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li><code>std::optional</code> 是一个模板类，可以表示一个可能存在的值</li><li><code>std::optional</code> 的内部有两种状态，要么表示一个T类型的值，要么用 <code>std::nullopt</code> 表示没有值</li><li>可以用 <code>has_value()</code> 判断一个 <code>std::optional</code> 是否有值，然后用 <code>value()</code> 函数取它表示的值</li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/125581553" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>子未经历过，安知此文是鸡汤，子非我，安知我不知此文是鸡汤。意见向左的人往往在内心互道傻X，而现实生活中哪有什么绝对的对错，只是出发点和眼界不同罢了，即使是真理也有适用的环境，“两点之间线段最短”，这一定是对的吗？</p><p>2022-7-17 23:26:03</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;平时写代码会遇到一种传递参数&lt;code&gt;特殊值&lt;/code&gt;标记特殊流程，或者函数返回值存在魔法数的情况，很需要一种标记参数或返回值状态的结构，那么在 C++17 标准下提供了 &lt;code&gt;std::optional&lt;/code&gt; 这个模板类，可以表示一个值不存在的状态，一起来看看用法吧。&lt;/p&gt;
    
    </summary>
    
      <category term="C/C++" scheme="http://AlbertGithubHome.github.io/blog/categories/C-C/"/>
    
    
      <category term="C/C++" scheme="http://AlbertGithubHome.github.io/blog/tags/C-C/"/>
    
      <category term="optional" scheme="http://AlbertGithubHome.github.io/blog/tags/optional/"/>
    
      <category term="可选值" scheme="http://AlbertGithubHome.github.io/blog/tags/%E5%8F%AF%E9%80%89%E5%80%BC/"/>
    
      <category term="魔法数" scheme="http://AlbertGithubHome.github.io/blog/tags/%E9%AD%94%E6%B3%95%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>偶然在github开源项目中发现了.travis.yml这货</title>
    <link href="http://AlbertGithubHome.github.io/blog/2022/07/02/%E5%81%B6%E7%84%B6%E5%9C%A8github%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E4%B8%AD%E5%8F%91%E7%8E%B0%E4%BA%86-travis-yml%E8%BF%99%E8%B4%A7/"/>
    <id>http://AlbertGithubHome.github.io/blog/2022/07/02/偶然在github开源项目中发现了-travis-yml这货/</id>
    <published>2022-07-02T15:34:45.000Z</published>
    <updated>2022-07-03T02:46:53.807Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>偶然在一个github开源项目中发现了.travis.yml这货，然后一发不可收拾，翻了翻之前看的几个开源库都有这个文件，并且最近经常看到它，这被称为“巴德尔-迈因霍夫现象”，是一种认知偏见，即在第一次注意到某一事物后，有一种更频繁地注意到它的倾向，导致某人相信它有很高的频率，既然这样索性就深入研究了一下这个文件，发现它原来是用于持续集成的。</p><a id="more"></a><h1 id="持续集成"><a href="#持续集成" class="headerlink" title="持续集成"></a>持续集成</h1><p>持续集成是一种 DevOps（Development和Operations的组合词）软件开发实践。采用持续集成时，开发人员会定期将代码变更合并到一个中央存储库中，之后系统会自动运行构建和测试操作。每次集成都通过自动化的构建（包括编译，发布，自动化测试）来进行验证，从而尽早地发现集成错误，提高软件质量，并减少验证和发布新软件更新所需的时间。</p><p>持续集成是将构建并测试的过程自动化，在你提交代码时，持续集成服务能够自动触发构建与测试过程，并反馈结果，加快开发周期，同时减少脏代码的引入，而持续集成工具有很多，常见的包括 <code>Jenkins</code>、<code>Gitlab-CI</code>、<code>Travis CI</code> 和 <code>AppVeyor</code>，github上项目的持续集成可以选择使用 <code>Travis CI</code>，也有项目使用 <code>AppVeyor</code>，它们都是开源持续集成云服务。</p><h1 id="YAML"><a href="#YAML" class="headerlink" title="YAML"></a>YAML</h1><p><code>.travis.yml</code> 是 github 用于说明持续集成步骤配置文件，使用的语言是 <code>YAML</code>。它是一种可读性非常高，与程序语言数据结构非常接近，同时具备丰富的表达能力和可扩展性，并且易于使用的数据标记语言。经常会拿它和 <code>XML</code> 和 <code>JSON</code> 进行对比，<code>YAML</code> 比 <code>XML</code> 语法简洁得多，但是没有 <code>XML</code> 的标签概念，而 <code>JSON</code> 语法是 <code>YAML 1.2</code> 的子集，非常接近 <code>YAML1.0</code> 与 <code>YAML1.1</code> 的子集。</p><p><code>YAML</code> 可以简单表达清单、散列表，标量等数据结构。它使用空白符号缩进，适合用来表达或编辑数据结构、各种配置文件、倾印调试内容、文件大纲等，配置文件后缀为通常为 <code>.yml</code>，比如：<code>.travis.yml</code>。</p><p>关于具体的语法本文就不展开说了，网上自行搜索一下，不同类型的项目的配置通常有自己的规范，可以参照<a href="https://docs.travis-ci.com/user/languages/" target="_blank" rel="noopener">travis官方</a>配置说明，下面展示一个 <code>.travis.yml</code> 文件</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">language:</span> <span class="string">cpp</span></span><br><span class="line"></span><br><span class="line"><span class="attr">sudo:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="attr">os:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">linux</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">osx</span></span><br><span class="line"></span><br><span class="line"><span class="attr">compiler:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">gcc</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">clang</span></span><br><span class="line"></span><br><span class="line"><span class="attr">script:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">$CC</span> <span class="string">ccronexpr.c</span> <span class="string">ccronexpr_test.c</span> <span class="bullet">-I.</span> <span class="bullet">-Wall</span> <span class="bullet">-Wextra</span> <span class="bullet">-std=c89</span> <span class="bullet">-DCRON_TEST_MALLOC</span> <span class="bullet">-o</span> <span class="string">a.out</span> <span class="string">&amp;&amp;</span> <span class="string">./a.out</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">$CXX</span> <span class="string">ccronexpr.c</span> <span class="string">ccronexpr_test.c</span> <span class="bullet">-I.</span> <span class="bullet">-Wall</span> <span class="bullet">-Wextra</span> <span class="bullet">-std=c++11</span> <span class="bullet">-DCRON_TEST_MALLOC</span> <span class="bullet">-o</span> <span class="string">a.out</span> <span class="string">&amp;&amp;</span> <span class="string">./a.out</span></span><br><span class="line"></span><br><span class="line"><span class="attr">notifications:</span></span><br><span class="line"><span class="attr">  email:</span></span><br><span class="line"><span class="attr">    on_success:</span> <span class="string">always</span></span><br></pre></td></tr></table></figure><h1 id="第一次使用-travis-yml"><a href="#第一次使用-travis-yml" class="headerlink" title="第一次使用 .travis.yml"></a>第一次使用 .travis.yml</h1><p>要想学会一件事必须反复强化记忆，所以我决定自己写个<code>.travis.yml</code>来使用一次，刚开始语法还不太熟悉，所以我打算在一些开源项目的文件基础上来修改，需求也比较简单，只要能实现我上传到github的代码能自动编译就可以了。</p><h2 id="注册登录travis"><a href="#注册登录travis" class="headerlink" title="注册登录travis"></a>注册登录travis</h2><p>登陆 <a href="http://www.travis-ci.com/" target="_blank" rel="noopener">travis</a> 官网，直接用github账号登陆即可，这样 travis 可以直接关联登录的github账号，自动获取你的仓库信息。</p><p><img src="https://img-blog.csdnimg.cn/0bc3c9354ef9427891f0530202c4ae6d.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9hbGJlcnRnaXRodWJob21lLmdpdGh1Yi5pby9ibG9nL2Fib3V0,size_18,color_FFFFFF,t_70#pic_center" alt="travis-ci-1"></p><p>登陆之后，点击settings，然后激活 <code>Travis CI</code> 勾选需要持续集成的仓库。</p><p><img src="https://img-blog.csdnimg.cn/5b498cb0518b47d4a0a03db5cf758c51.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9hbGJlcnRnaXRodWJob21lLmdpdGh1Yi5pby9ibG9nL2Fib3V0,size_18,color_FFFFFF,t_70#pic_center" alt="travis-ci2"></p><h2 id="编写代码"><a href="#编写代码" class="headerlink" title="编写代码"></a>编写代码</h2><p>为了方便测试，我们只编写一个简单的 <code>HelloWolrd.cpp</code> 测试文件好了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello World!"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="编写-travis-yml"><a href="#编写-travis-yml" class="headerlink" title="编写.travis.yml"></a>编写.travis.yml</h2><p>我只写了一个文件，要求只要编译 <code>gcc</code> 通过就行了，暂时也不需要邮件通知</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">language:</span> <span class="string">cpp</span></span><br><span class="line"></span><br><span class="line"><span class="attr">sudo:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="attr">os:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">linux</span></span><br><span class="line"></span><br><span class="line"><span class="attr">compiler:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">gcc</span></span><br><span class="line"></span><br><span class="line"><span class="attr">script:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">$CXX</span> <span class="string">wolrd/code/c++/HelloWorld.cpp</span> <span class="bullet">-o</span> <span class="string">a.out</span> <span class="string">&amp;&amp;</span> <span class="string">./a.out</span></span><br></pre></td></tr></table></figure><h2 id="推送代码启动Travis-CI"><a href="#推送代码启动Travis-CI" class="headerlink" title="推送代码启动Travis CI"></a>推送代码启动Travis CI</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Albert@home-pc MINGW64 /d/data/maingit/HelloWorld (master)</span><br><span class="line">$ git add .</span><br><span class="line"></span><br><span class="line">Albert@home-pc MINGW64 /d/data/maingit/HelloWorld (master)</span><br><span class="line">$ git commit -m&quot;test travis ci&quot;</span><br><span class="line">[master 8e92384] test travis ci</span><br><span class="line"> 2 files changed, 2 insertions(+), 2 deletions(-)</span><br><span class="line">Albert@home-pc MINGW64 /d/data/maingit/HelloWorld (master)</span><br><span class="line">$ git push</span><br><span class="line">Enumerating objects: 13, done.</span><br><span class="line">Counting objects: 100% (13/13), done.</span><br><span class="line">Delta compression using up to 4 threads</span><br><span class="line">Compressing objects: 100% (6/6), done.</span><br><span class="line">Writing objects: 100% (7/7), 604 bytes | 302.00 KiB/s, done.</span><br><span class="line">Total 7 (delta 3), reused 0 (delta 0)</span><br><span class="line">remote: Resolving deltas: 100% (3/3), completed with 3 local objects.</span><br><span class="line">To github.com:AlbertGithubHome/HelloWorld.git</span><br><span class="line">   af45c67..8e92384  master -&gt; master</span><br></pre></td></tr></table></figure><p>推送之后travis-ci网站会自动启动，构建过程和结果如下：</p><p><img src="https://img-blog.csdnimg.cn/fe6b6fa985ca4c15a6cde637ea6b7a7d.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9hbGJlcnRnaXRodWJob21lLmdpdGh1Yi5pby9ibG9nL2Fib3V0,size_18,color_FFFFFF,t_70#pic_center" alt="travis-ci-3"></p><p>第一次尝试失败，检查发现编译文件的路径写错了，修改后再次推送，成功构建的界面如下：</p><p><img src="https://img-blog.csdnimg.cn/b24395840e414c41b3c17e84a64de06e.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9hbGJlcnRnaXRodWJob21lLmdpdGh1Yi5pby9ibG9nL2Fib3V0,size_18,color_FFFFFF,t_70#pic_center" alt="travis-ci4"></p><p>然后就可以在编译状态按钮后面领取这样一个标签，它可以根据项目构建状态实时变化，快把它加到项目的README文件里吧。</p><blockquote><p><code>[![Build Status](https://app.travis-ci.com/AlbertGithubHome/HelloWorld.svg?branch=master)](https://app.travis-ci.com/AlbertGithubHome/HelloWorld)</code></p></blockquote><p><img src="https://img-blog.csdnimg.cn/0b7885e61e294b74919b8015c9bf0fdd.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9hbGJlcnRnaXRodWJob21lLmdpdGh1Yi5pby9ibG9nL2Fib3V0,size_18,color_FFFFFF,t_70#pic_center" alt="travis-ci5"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li><code>.travis.yml</code> 是使用 <code>Travis CI</code> 持续集成服务的配置文件，使用 <code>YAML</code> 语言编写</li><li><code>YAML</code> 比 <code>XML</code> 语法简洁得多，但是没有 <code>XML</code> 的标签概念，而 <code>JSON</code> 语法是 <code>YAML 1.2</code> 的子集</li><li><code>GitHub</code> 和 <code>Travis CI</code> 是一对好基友，几乎不用额外的配置，只要按照<a href="https://docs.travis-ci.com/user/languages/cpp/" target="_blank" rel="noopener">官方语法</a>写好 <code>.travis.yml</code> 文件即可</li><li>可以把<code>Travis CI</code> 看成一个机器人，每当我们 push 代码时，这个机器人会按照既定流程帮我们自动构建和检测</li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/125472083" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>卅是一个阶段，更是一个开始~</p><p>2022-7-3 01:08:33</p></blockquote><!--Worker informationhostname: 169a91ed-3bb1-48d9-8497-63b441cbeace@1.worker-com-54588667bc-zl94w.gce-production-1version: 6.2.22 https://github.com/travis-ci/worker/tree/858cb91994a513269f2fe9782c15fc113e966231instance: travis-job-744f0f48-566f-4629-864a-f4f36a446ae0 travis-ci-sardonyx-xenial-1647862066-c38d3375 (via amqp)startup: 6.008688253s0.12s0.01s0.00s0.01ssystem_infoBuild system informationBuild language: cppBuild dist: xenialBuild id: 252700359Job id: 575450900Runtime kernel version: 4.15.0-1098-gcptravis-build version: ac64d3c6Build image provisioning date and timeMon Mar 21 11:50:29 UTC 2022Operating System DetailsDistributor ID: UbuntuDescription:    Ubuntu 16.04.7 LTSRelease:    16.04Codename:   xenialSystemd Versionsystemd 229Cookbooks Version187d986 https://github.com/travis-ci/travis-cookbooks/tree/187d986git versiongit version 2.35.1bash versionGNU bash, version 4.3.48(1)-release (x86_64-pc-linux-gnu)gcc versiongcc (Ubuntu 5.4.0-6ubuntu1~16.04.12) 5.4.0 20160609docker versionClient: Docker Engine - Community Version:           20.10.7 API version:       1.41 Go version:        go1.13.15 Git commit:        f0df350 Built:             Wed Jun  2 11:56:47 2021 OS/Arch:           linux/amd64 Context:           default Experimental:      trueServer: Docker Engine - Community Engine:  Version:          20.10.7  API version:      1.41 (minimum version 1.12)  Go version:       go1.13.15  Git commit:       b0f5bc3  Built:            Wed Jun  2 11:54:58 2021  OS/Arch:          linux/amd64  Experimental:     false containerd:  Version:          1.4.6  GitCommit:        d71fcd7d8303cbf684402823e425e9dd2e99285d runc:  Version:          1.0.0-rc95  GitCommit:        b9ee9c6314599f1b4a7f497e1f1f856fe433d3b7 docker-init:  Version:          0.19.0  GitCommit:        de40ad0clang versionclang version 7.0.0 (tags/RELEASE_700/final)jq versionjq-1.6bats versionBats 0.4.0shellcheck version0.7.2shfmt versionv3.2.1ccache version3.2.4cmake versioncmake version 3.12.4heroku versionheroku/7.59.4 linux-x64 node-v12.21.0imagemagick versionVersion: ImageMagick 6.8.9-9 Q16 x86_64 2020-12-04 http://www.imagemagick.orgmd5deep version4.4mercurial versionversion 4.8mysql versionmysql  Ver 14.14 Distrib 5.7.33, for Linux (x86_64) using  EditLine wrapperopenssl versionOpenSSL 1.0.2g  1 Mar 2016packer version1.7.5postgresql client versionpsql (PostgreSQL) 10.17 (Ubuntu 10.17-1.pgdg16.04+1)ragel versionRagel State Machine Compiler version 6.8 Feb 2013sudo version1.8.16gzip versiongzip 1.6zip versionZip 3.0vim versionVIM - Vi IMproved 7.4 (2013 Aug 10, compiled Oct 13 2020 16:04:38)4miptables versioniptables v1.6.0curl versioncurl 7.47.0 (x86_64-pc-linux-gnu) libcurl/7.47.0 GnuTLS/3.4.10 zlib/1.2.8 libidn/1.32 librtmp/2.3wget versionGNU Wget 1.17.1 built on linux-gnu.rsync versionrsync  version 3.1.1  protocol version 31gimme versionv1.5.4nvm version0.39.1perlbrew version/home/travis/perl5/perlbrew/bin/perlbrew  - App::perlbrew/0.94phpenv versionrbenv 1.2.0-14-gc6cc0a1rvm versionrvm 1.29.12 (latest) by Michal Papis, Piotr Kuczynski, Wayne E. Seguin [https://rvm.io]default ruby versionruby 2.5.3p105 (2018-10-18 revision 65156) [x86_64-linux]CouchDB versioncouchdb 1.6.1ElasticSearch version7.16.3Installed Firefox versionfirefox 63.0.1MongoDB versionMongoDB 4.0.28PhantomJS version2.1.1Pre-installed PostgreSQL versions9.4.269.5.259.6.22Redis versionredis-server 6.0.6Pre-installed Go versions1.11.1ant versionApache Ant(TM) version 1.9.6 compiled on July 20 2018mvn versionApache Maven 3.6.3 (cecedd343002696d0abb50b32b541b8a6ba2883f)gradle versionGradle 5.1.1!lein versionLeiningen 2.9.8 on Java 11.0.2 OpenJDK 64-Bit Server VMPre-installed Node.js versionsv10.24.1v11.0.0v12.22.11v14.19.1v16.14.2v4.9.1v6.17.1v8.12.0v8.17.0v8.9phpenv versions  system  5.6  5.6.40  7.1  7.1.27  7.2* 7.2.15 (set by /home/travis/.phpenv/version)  hhvm-stable  hhvmcomposer --versionComposer version 1.8.4 2019-02-11 10:52:10Pre-installed Ruby versionsruby-2.3.8ruby-2.4.5ruby-2.5.30.01s0.00s0.67s0.24s0.05s0.00s0.03s0.00s0.01s0.01s0.01s0.01s0.01s0.00s0.00s0.02s0.00s0.01s0.29s0.00s0.00s0.00s0.01s0.00s0.09s0.00s0.90s0.00s0.00s6.03s0.00s3.25s0.00s2.48sdocker_mtu_and_registry_mirrorsresolvconfgit.checkout0.54s$ git clone --depth=50 --branch=master https://github.com/AlbertGithubHome/HelloWorld.git AlbertGithubHome/HelloWorldCloning into 'AlbertGithubHome/HelloWorld'...remote: Enumerating objects: 159, done.remote: Counting objects: 100% (31/31), done.remote: Compressing objects: 100% (21/21), done.remote: Total 159 (delta 10), reused 25 (delta 6), pack-reused 128Receiving objects: 100% (159/159), 102.32 KiB | 1.76 MiB/s, done.Resolving deltas: 100% (49/49), done.$ cd AlbertGithubHome/HelloWorld$ git checkout -qf 8e92384a17051bbaf41d039e4f4c736464d953a40.00s$ export TRAVIS_COMPILER=gcc$ export CXX=${CXX:-g++}$ export CXX_FOR_BUILD=${CXX_FOR_BUILD:-g++}$ export CC=${CC:-gcc}$ export CC_FOR_BUILD=${CC_FOR_BUILD:-gcc}$ gcc --versiongcc (Ubuntu 5.4.0-6ubuntu1~16.04.12) 5.4.0 20160609Copyright (C) 2015 Free Software Foundation, Inc.This is free software; see the source for copying conditions.  There is NOwarranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.0.35s$ $CXX world/code/c++/HelloWorld.cpp -o a.out && ./a.outThe command "$CXX world/code/c++/HelloWorld.cpp -o a.out && ./a.out" exited with 0.Done. Your build exited with 0.-->]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;偶然在一个github开源项目中发现了.travis.yml这货，然后一发不可收拾，翻了翻之前看的几个开源库都有这个文件，并且最近经常看到它，这被称为“巴德尔-迈因霍夫现象”，是一种认知偏见，即在第一次注意到某一事物后，有一种更频繁地注意到它的倾向，导致某人相信它有很高的频率，既然这样索性就深入研究了一下这个文件，发现它原来是用于持续集成的。&lt;/p&gt;
    
    </summary>
    
      <category term="CI/CD" scheme="http://AlbertGithubHome.github.io/blog/categories/CI-CD/"/>
    
    
      <category term="C/C++" scheme="http://AlbertGithubHome.github.io/blog/tags/C-C/"/>
    
      <category term="CI" scheme="http://AlbertGithubHome.github.io/blog/tags/CI/"/>
    
      <category term="CD" scheme="http://AlbertGithubHome.github.io/blog/tags/CD/"/>
    
      <category term="YAML" scheme="http://AlbertGithubHome.github.io/blog/tags/YAML/"/>
    
      <category term="travis" scheme="http://AlbertGithubHome.github.io/blog/tags/travis/"/>
    
  </entry>
  
  <entry>
    <title>C++11中的noexcept说明符和操作符</title>
    <link href="http://AlbertGithubHome.github.io/blog/2022/06/26/C-11%E4%B8%AD%E7%9A%84noexceptno%E7%9A%84%E8%AF%B4%E6%98%8E%E7%AC%A6%E5%92%8C%E6%93%8D%E4%BD%9C%E7%AC%A6/"/>
    <id>http://AlbertGithubHome.github.io/blog/2022/06/26/C-11中的noexceptno的说明符和操作符/</id>
    <published>2022-06-25T16:47:36.000Z</published>
    <updated>2022-06-26T09:28:03.124Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><code>noexcept</code> 这个说明符看起来很厉害的样子，给人一种函数加上它就可以不产生异常的感觉，但事实真的如此吗？它真的能消除一切异常吗？答案是不能！它只是函数的一种说明，作为开发者我们需要自己保证标记了 <code>noexcept</code> 的函数不产生异常。啥？这不是没事找事吗？</p><a id="more"></a><h1 id="为什么要用-noexcept"><a href="#为什么要用-noexcept" class="headerlink" title="为什么要用 noexcept"></a>为什么要用 noexcept</h1><p>既然给函数添加了 <code>noexcept</code> 说明符并不能杜绝异常的产生，那我们为什么还要用它呢？我个人的理解是为了优化，因为异常存在的意义就是用来干脏活累活的，为了实现异常的处理，我们编写逻辑的每一次函数调用，编译器都会生成一堆外围的处理代码，而当我们把一个函数标记为 <code>noexcept</code> 时，表示开发者向运行时保证调用这个函数不会抛出异常，这意味着这些脏活累活都不用干了，如果声明了 <code>noexcept</code> 的函数还试图抛出异常，C++会调用std::terminate函数终止程序运行。</p><p>添加 <code>noexcept</code> 说明符后编译器是否会进行优化，我们可以通过生成的汇编代码来看一下，编译器是 <code>gcc 12.1</code>，先看下面这段代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Obj</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ~Obj();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inner</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">entrance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Obj instance;</span><br><span class="line">    inner();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数 <code>entrance()</code> 先定义一个<code>Obj</code>类型的对象，然后调用一个 <code>inner()</code> 函数，假如 <code>inner()</code> 在执行过程中抛出了异常，我们需要在保证对象实例 <code>instance</code> 被正确析构后才能退出 <code>entrance()</code> 函数，为了实现了这个保证，编译器真的是操碎了心，可以看一下生成汇编代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">entrance():</span><br><span class="line">        push    rbp</span><br><span class="line">        mov     rbp, rsp</span><br><span class="line">        push    rbx</span><br><span class="line">        sub     rsp, 24</span><br><span class="line">        call    inner()</span><br><span class="line">        lea     rax, [rbp-17]</span><br><span class="line">        mov     rdi, rax</span><br><span class="line">        call    Obj::~Obj() [complete object destructor]</span><br><span class="line">        jmp     .L4</span><br><span class="line">        mov     rbx, rax</span><br><span class="line">        lea     rax, [rbp-17]</span><br><span class="line">        mov     rdi, rax</span><br><span class="line">        call    Obj::~Obj() [complete object destructor]</span><br><span class="line">        mov     rax, rbx</span><br><span class="line">        mov     rdi, rax</span><br><span class="line">        call    _Unwind_Resume</span><br><span class="line">.L4:</span><br><span class="line">        mov     rbx, QWORD PTR [rbp-8]</span><br><span class="line">        leave</span><br><span class="line">        ret</span><br></pre></td></tr></table></figure><p>从这段汇编代码中可以发现，有两句是调用了析构函数 <code>Obj::~Obj()</code>，其中第二次就是为了异常发生时准备的，接下来我们加上 <code>noexcept</code> 后代码变成了下面这样：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Obj</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ~Obj();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inner</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">entrance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Obj o;</span><br><span class="line">    inner();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>源代码几乎没有变化，而生成的汇编代码清爽了太多：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">entrance():</span><br><span class="line">        push    rbp</span><br><span class="line">        mov     rbp, rsp</span><br><span class="line">        sub     rsp, 16</span><br><span class="line">        call    inner()</span><br><span class="line">        lea     rax, [rbp-1]</span><br><span class="line">        mov     rdi, rax</span><br><span class="line">        call    Obj::~Obj() [complete object destructor]</span><br><span class="line">        leave</span><br><span class="line">        ret</span><br></pre></td></tr></table></figure><p>对比来看，以下这部分代码一直都是编译器在默默付出，现在你可以通过 <code>noexcept</code> 帮它减负了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">        jmp     .L4</span><br><span class="line">        mov     rbx, rax</span><br><span class="line">        lea     rax, [rbp-17]</span><br><span class="line">        mov     rdi, rax</span><br><span class="line">        call    Obj::~Obj() [complete object destructor]</span><br><span class="line">        mov     rax, rbx</span><br><span class="line">        mov     rdi, rax</span><br><span class="line">        call    _Unwind_Resume</span><br><span class="line">.L4:</span><br><span class="line">        mov     rbx, QWORD PTR [rbp-8]</span><br></pre></td></tr></table></figure><h1 id="实际测试-noexcept"><a href="#实际测试-noexcept" class="headerlink" title="实际测试 noexcept"></a>实际测试 noexcept</h1><h2 id="不处理异常"><a href="#不处理异常" class="headerlink" title="不处理异常"></a>不处理异常</h2><p>首先实验一下不处理异常时的情景：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Obj</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ~Obj()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"~Obj"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inner</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Obj o;</span><br><span class="line">    inner();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译运行结果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:/mnt/d/data/cpp/testExcept$ g++ testexcept.cpp --std=c++11</span><br><span class="line">albert@home-pc:/mnt/d/data/cpp/testExcept$ ./a.out</span><br><span class="line">terminate called after throwing an instance of <span class="string">'int'</span></span><br><span class="line">Aborted (core dumped)</span><br></pre></td></tr></table></figure><p>可以看到程序直接崩溃了，在抛出一个异常之后被终止了。</p><h2 id="正常捕获异常"><a href="#正常捕获异常" class="headerlink" title="正常捕获异常"></a>正常捕获异常</h2><p>再实验一次不加 noexcept 时常规处理异常的方式，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Obj</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ~Obj()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"~Obj"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inner</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Obj o;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        inner();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(<span class="keyword">int</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"catch exception."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译运行结果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:/mnt/d/data/cpp/testExcept$ g++ testexcept.cpp --std=c++11</span><br><span class="line">albert@home-pc:/mnt/d/data/cpp/testExcept$ ./a.out</span><br><span class="line">catch exception.</span><br><span class="line">~Obj</span><br></pre></td></tr></table></figure><p>异常被捕获，Obj对象被正常析构，程序正常退出了</p><h2 id="添加noexcept标记"><a href="#添加noexcept标记" class="headerlink" title="添加noexcept标记"></a>添加noexcept标记</h2><p>给函数加上noexcept标记，再测试一次：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Obj</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ~Obj()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"~Obj"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inner</span><span class="params">()</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Obj o;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        inner();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(<span class="keyword">int</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"catch exception."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译运行结果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:/mnt/d/data/cpp/testExcept$ g++ testexcept.cpp --std=c++11</span><br><span class="line">albert@home-pc:/mnt/d/data/cpp/testExcept$ ./a.out</span><br><span class="line">terminate called after throwing an instance of <span class="string">'int'</span></span><br><span class="line">Aborted (core dumped)</span><br></pre></td></tr></table></figure><p>我们看到加了noexcept如果抛出异常，程序会被直接终止，<code>try...catch</code> 语句就不起作用了，所以 <code>noexcept</code> 不能随便加，一定得保证确实没有异常才可以应用此优化。</p><h1 id="noexcept操作符"><a href="#noexcept操作符" class="headerlink" title="noexcept操作符"></a>noexcept操作符</h1><p>noexcept本身后面可以加一个表达式，返回一个bool值，用来判定一个函数是否会抛出异常，可以看一下这个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inner</span><span class="params">()</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::boolalpha</span><br><span class="line">        &lt;&lt; <span class="string">"Is inner() noexcept? "</span> &lt;&lt; <span class="keyword">noexcept</span>(inner()) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span></span><br><span class="line">        &lt;&lt; <span class="string">"Is test() noexcept? "</span> &lt;&lt; <span class="keyword">noexcept</span>(test()) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span></span><br><span class="line">        &lt;&lt; <span class="string">"Is tes2() noexcept? "</span> &lt;&lt; <span class="keyword">noexcept</span>(test2()) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译运行后的结果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:/mnt/d/data/cpp/testExcept$ g++ testexcept.cpp --std=c++11</span><br><span class="line">albert@home-pc:/mnt/d/data/cpp/testExcept$ ./a.out</span><br><span class="line">Is inner() noexcept? <span class="literal">true</span></span><br><span class="line">Is <span class="built_in">test</span>() noexcept? <span class="literal">false</span></span><br><span class="line">Is tes2() noexcept? <span class="literal">true</span></span><br></pre></td></tr></table></figure><p><code>test()</code> 和 <code>test2()</code> 函数的判断应该没有什么疑问，而 <code>inner()</code>明明会抛出异常，而 <code>noexcept</code>操作符却返回了false，这是因为我们在函数后面加上了 <code>noexcept</code> 说明符，这时就需要我们自己保证函数不会抛出异常了，如果你硬要抛出异常那编译器也没有办法了。</p><h1 id="noexcept的优缺点"><a href="#noexcept的优缺点" class="headerlink" title="noexcept的优缺点"></a>noexcept的优缺点</h1><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p>调用标记为 <code>noexcept</code> 的函数时不需要额外记录exception handler，所以编译器拥有更高的自由度，便于生成更加高效的执行代码。</p><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p><code>noexcept</code>关键字啊会影响接口的灵活性，如果基类某个虚函数设置为<code>noexcept</code>，派生类重写虚函数时也必须遵守，派生类中只要有一个函数遗漏了noexcept约定，就可能会导致整个程序在发生异常时被终止。</p><p>如果标记为<code>noexcept</code>的函数调用了第三方库的函数，就需要对这些第三方库都做一层封装，保证处理了第三方库所有可能抛出的异常，增大了工作量。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li><code>noexcept</code> 是一个说明符同时也是一个操作符</li><li><code>noexcept</code> 作为说明符放在函数名后面，表明次函数不会抛出异常，等同于 <code>noexcept(true)</code></li><li><code>noexcept</code> 作为操作符时，可以用来判断一个函数是否会抛出异常，用法为 <code>noexcept(funcName)</code></li><li>当使用 <code>noexcept</code> 标记函数时，我们需要自己保证函数不会抛出异常，这样可以生成更高效的代码</li><li>如果标记了 <code>noexcept</code>函数还是抛出了异常，那么程序会直接调用 <code>std::abort()</code> 终止程序，<code>try...catch</code>都没用</li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/125354000" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>曾经接受教育努力学习是打破阶级固化的长矛，如今教育更多表现为阻碍阶级跨越的护盾，不能否认好好学习可以让我们的生活变得更好，但寒门再难出贵子确实是摆在我们面前的现实，马太效应，强者愈强、弱者愈弱。条条大路通罗马，而有些人就生在罗马，我们只能靠自己微弱的锋利，去尝试突破那一层层禁锢。</p><p>2022-6-26 17:23:42</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&lt;code&gt;noexcept&lt;/code&gt; 这个说明符看起来很厉害的样子，给人一种函数加上它就可以不产生异常的感觉，但事实真的如此吗？它真的能消除一切异常吗？答案是不能！它只是函数的一种说明，作为开发者我们需要自己保证标记了 &lt;code&gt;noexcept&lt;/code&gt; 的函数不产生异常。啥？这不是没事找事吗？&lt;/p&gt;
    
    </summary>
    
      <category term="C/C++" scheme="http://AlbertGithubHome.github.io/blog/categories/C-C/"/>
    
    
      <category term="C/C++" scheme="http://AlbertGithubHome.github.io/blog/tags/C-C/"/>
    
      <category term="noexcept" scheme="http://AlbertGithubHome.github.io/blog/tags/noexcept/"/>
    
      <category term="terminate" scheme="http://AlbertGithubHome.github.io/blog/tags/terminate/"/>
    
      <category term="try-catch" scheme="http://AlbertGithubHome.github.io/blog/tags/try-catch/"/>
    
  </entry>
  
  <entry>
    <title>C++17新语法之if和switch语句中可以初始化变量啦</title>
    <link href="http://AlbertGithubHome.github.io/blog/2022/06/18/C-17%E6%96%B0%E8%AF%AD%E6%B3%95%E4%B9%8Bif%E5%92%8Cswitch%E8%AF%AD%E5%8F%A5%E4%B8%AD%E5%8F%AF%E4%BB%A5%E5%88%9D%E5%A7%8B%E5%8C%96%E5%8F%98%E9%87%8F%E5%95%A6/"/>
    <id>http://AlbertGithubHome.github.io/blog/2022/06/18/C-17新语法之if和switch语句中可以初始化变量啦/</id>
    <published>2022-06-18T14:16:40.000Z</published>
    <updated>2022-06-18T17:55:55.887Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>今天在看一些c++代码时偶然间发现一些示例，在if语句的小括号内居然出现了分号，难道这一段是伪代码吗？之前从来没见过这种写法，然后写了一个例子，用最新的编译器编译后发现真的是正常的代码，并且可以成功运行，然后脑袋有个声音一闪而过，是不是一直就支持这种写法，只是我不知道而已，后来几经周折，终于发现真相，原来这其实是C++17新的语法。</p><a id="more"></a><h1 id="if-语句本来的样子"><a href="#if-语句本来的样子" class="headerlink" title="if 语句本来的样子"></a>if 语句本来的样子</h1><p>C++17之前 <code>if</code> 语句的小括号内只能放判断逻辑，<code>if (condition) { /* ... */ }</code> 也就是这样，所以如果想使用一个变量进行判断，那么这个变量必须在if语句之前进行定义，比如我们常常使用的查找map元素的逻辑：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">auto</span> it = mp.find(<span class="string">"key"</span>);</span><br><span class="line">    <span class="keyword">if</span> (it != mp.end())</span><br><span class="line">        <span class="keyword">return</span> it-&gt;second;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> defaultValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="if-语句新能力"><a href="#if-语句新能力" class="headerlink" title="if 语句新能力"></a>if 语句新能力</h1><p>从C++17开始，<code>if</code> 语句的小括号之中也可以初始化变量了，语法为 <code>if (initializer; condition) { /* ... */ }</code>，这样做的好处就是可以更加精细的控制变量的作用域，使代码看起来更加紧凑，比如上面的例子可以改写为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">auto</span> it = mp.find(<span class="string">"key"</span>); it != mp.end())</span><br><span class="line">        <span class="keyword">return</span> it-&gt;second;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> defaultValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最直观的感受就是少了一行代码，但是更重要的特点还是他把变量 <code>it</code> 的作用域限制在了 <code>if</code> 语句之内。</p><p>另外就是能一定程度上解决代码缩进层数太多的问题，这也是实际开发过程中遇到的问题，比如下面这段代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">auto</span> it = mp.find(<span class="string">"key"</span>);</span><br><span class="line">    <span class="keyword">if</span> (it != mp.end())</span><br><span class="line">        <span class="keyword">return</span> it-&gt;second;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> cfg = GetConfig();</span><br><span class="line">        <span class="keyword">if</span> (cfg)</span><br><span class="line">            <span class="keyword">return</span> defaultValue1;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> defaultValue2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在C++17之前的代码中，因为 <code>if</code> 语句中不能包含初始化变量的逻辑，所以会造成 <code>if</code> 嵌套层层递进，当这种条件太多时，缩进层数太多导致代码可读性变差，使用C++17的语法再改进一下就变成了下面这样，逻辑更加清晰了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">auto</span> it = mp.find(<span class="string">"key"</span>); it != mp.end())</span><br><span class="line">        <span class="keyword">return</span> it-&gt;second;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">int</span> cfg = GetConfig(); cfg)</span><br><span class="line">        <span class="keyword">return</span> defaultValue1;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> defaultValue2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>switch</code> 语句也是相同的能力扩展，就不再展开说了，这里贴一个 <a href="https://en.cppreference.com/w/cpp/language/switch" target="_blank" rel="noopener">cppreference - switch</a> 上的例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Device</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="keyword">enum</span> State &#123; SLEEP, READY, BAD &#125;;</span><br><span class="line">        <span class="function"><span class="keyword">auto</span> <span class="title">state</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_state; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*...*/</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        State m_state&#123;&#125;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (<span class="keyword">auto</span> dev = Device&#123;&#125;; dev.state())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> Device::SLEEP:</span><br><span class="line">            <span class="comment">/*...*/</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> Device::READY:</span><br><span class="line">            <span class="comment">/*...*/</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> Device::BAD:</span><br><span class="line">            <span class="comment">/*...*/</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="似曾相识在go中"><a href="#似曾相识在go中" class="headerlink" title="似曾相识在go中"></a>似曾相识在go中</h1><p>这个在if中既初始化又进行判断的语法，之前在go中也用过，类似的需求在go中的写法是：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">xxx</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> value := mp[<span class="string">"key"</span>]; value != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> defaultValue</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是不是很像？其实在golang中更规范的用法是使用map查找的第二个返回值来判断元素是否存在，就像下面这样：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">xxx</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> value, ok := mp[<span class="string">"key"</span>]; ok &#123;</span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> defaultValue</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="关于语言的思考"><a href="#关于语言的思考" class="headerlink" title="关于语言的思考"></a>关于语言的思考</h1><p>看到上面这种golang和c++17的对比，会发现语言之间都在相互促进，这些所谓的高级语言，总能在其中一种语言中发现另一种语言的影子，也就是说在某些方面上他们是“趋同”的，可能在不久的将来会出现一种“超高级语言”，类似于C++模板机制，<code>C++</code>、<code>Golang</code>、<code>Python</code> 这些语言作为一种类型，传递到超高级语言之中，编写或者描述完功能逻辑后，自动生成对应语言的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SuperLanguageTemplate&lt;C++/Golang/Python&gt;</span><br><span class="line">[AutoGenerateByFollowingDescription]</span><br><span class="line">&#123;</span><br><span class="line">    / * ... * /</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li><code>if</code> 和 <code>switch</code> 语句都可以在逻辑判断前初始化变量，变量的定义域可以更精细的控制</li><li>编程语言之间相互“借鉴”，部分语法长得越来越像，最后不知道会不会归于统一</li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/125249573" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>人生并不是不断失去，反过来看，其实人生应该是不断拥有，1秒，2秒，3秒，这些本就不一定属于你的时间，作为馈赠出现在了你的生命里~</p><p>2022-6-19 01:44:55</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;今天在看一些c++代码时偶然间发现一些示例，在if语句的小括号内居然出现了分号，难道这一段是伪代码吗？之前从来没见过这种写法，然后写了一个例子，用最新的编译器编译后发现真的是正常的代码，并且可以成功运行，然后脑袋有个声音一闪而过，是不是一直就支持这种写法，只是我不知道而已，后来几经周折，终于发现真相，原来这其实是C++17新的语法。&lt;/p&gt;
    
    </summary>
    
      <category term="C/C++" scheme="http://AlbertGithubHome.github.io/blog/categories/C-C/"/>
    
    
      <category term="C/C++" scheme="http://AlbertGithubHome.github.io/blog/tags/C-C/"/>
    
      <category term="if" scheme="http://AlbertGithubHome.github.io/blog/tags/if/"/>
    
      <category term="switch" scheme="http://AlbertGithubHome.github.io/blog/tags/switch/"/>
    
      <category term="initializer" scheme="http://AlbertGithubHome.github.io/blog/tags/initializer/"/>
    
  </entry>
  
  <entry>
    <title>了解git裸仓库并利用post-receive自动化部署</title>
    <link href="http://AlbertGithubHome.github.io/blog/2022/06/12/%E4%BA%86%E8%A7%A3git%E8%A3%B8%E4%BB%93%E5%BA%93%E5%B9%B6%E5%88%A9%E7%94%A8post-receive%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2/"/>
    <id>http://AlbertGithubHome.github.io/blog/2022/06/12/了解git裸仓库并利用post-receive自动化部署/</id>
    <published>2022-06-12T07:23:08.000Z</published>
    <updated>2022-06-12T14:01:34.328Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>【裸仓库】指的是使用 <code>git init --bare</code> 命令得到的仓库，是对这种操作结果的一种直译，这个词对于刚接触 git 软件的小伙伴来说可能是第一次听说，而我也是最近实际操作了几次才渐渐理解，下面解释一下什么是裸仓库，以及为什么要使用它，有理解不对的地方还请大家指正。</p><a id="more"></a><h1 id="普通库和裸仓库"><a href="#普通库和裸仓库" class="headerlink" title="普通库和裸仓库"></a>普通库和裸仓库</h1><h2 id="普通库"><a href="#普通库" class="headerlink" title="普通库"></a>普通库</h2><p>在解释裸仓库之前，还是先来看看 <code>git init</code>命令创建一个普通仓库的目录结构:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-0-3-centos data]<span class="comment"># git init simple</span></span><br><span class="line">Initialized empty Git repository <span class="keyword">in</span> /data/simple/.git/</span><br><span class="line">[root@VM-0-3-centos data]<span class="comment"># cd simple/</span></span><br><span class="line">[root@VM-0-3-centos simple]<span class="comment"># touch README.md</span></span><br><span class="line">[root@VM-0-3-centos simple]<span class="comment"># cd ..</span></span><br><span class="line">[root@VM-0-3-centos data]<span class="comment"># tree -a simple/</span></span><br><span class="line">simple/</span><br><span class="line">|-- .git</span><br><span class="line">|   |-- branches</span><br><span class="line">|   |-- config</span><br><span class="line">|   |-- description</span><br><span class="line">|   |-- HEAD</span><br><span class="line">|   |-- hooks</span><br><span class="line">|   |   |-- applypatch-msg.sample</span><br><span class="line">|   |   |-- commit-msg.sample</span><br><span class="line">|   |   |-- post-update.sample</span><br><span class="line">|   |   |-- pre-applypatch.sample</span><br><span class="line">|   |   |-- pre-commit.sample</span><br><span class="line">|   |   |-- prepare-commit-msg.sample</span><br><span class="line">|   |   |-- pre-push.sample</span><br><span class="line">|   |   |-- pre-rebase.sample</span><br><span class="line">|   |   `-- update.sample</span><br><span class="line">|   |-- info</span><br><span class="line">|   |   `-- exclude</span><br><span class="line">|   |-- objects</span><br><span class="line">|   |   |-- info</span><br><span class="line">|   |   `-- pack</span><br><span class="line">|   `-- refs</span><br><span class="line">|       |-- heads</span><br><span class="line">|       `-- tags</span><br><span class="line">`-- README.md</span><br><span class="line"></span><br><span class="line">10 directories, 14 files</span><br></pre></td></tr></table></figure><p>通过上述命令操作后可以看到，<code>git init simple</code> 操作之后，创建了一个名为 <code>simple</code> 的库，<code>simple</code> 目录下还有一个 <code>.git</code> 子目录，其中包含了git系统常用的文件，在 <code>.git</code> 目录外是我们的工作区，可以存放我们库中待更新的文件，修改之后可以通过 <code>git add</code>，<code>git commit</code> 等命令更新 <code>.git</code> 中的内容，简单来说普通库就是在工作目录 <code>simple</code> 中还包括一个 <code>.git</code> 目录，下面添加一个文件试试。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-0-3-centos simple]<span class="comment"># git add README.md</span></span><br><span class="line">[root@VM-0-3-centos simple]<span class="comment"># git commit -m"add readme file"</span></span><br><span class="line">[master (root-commit) 9a9b255] add readme file</span><br><span class="line"> 1 file changed, 0 insertions(+), 0 deletions(-)</span><br><span class="line"> create mode 100644 README.md</span><br><span class="line">[root@VM-0-3-centos simple]<span class="comment"># tree . -a</span></span><br><span class="line">.</span><br><span class="line">|-- .git</span><br><span class="line">|   |-- branches</span><br><span class="line">|   |-- COMMIT_EDITMSG</span><br><span class="line">|   |-- config</span><br><span class="line">|   |-- description</span><br><span class="line">|   |-- HEAD</span><br><span class="line">|   |-- hooks</span><br><span class="line">|   |   |-- applypatch-msg.sample</span><br><span class="line">|   |   |-- commit-msg.sample</span><br><span class="line">|   |   |-- post-update.sample</span><br><span class="line">|   |   |-- pre-applypatch.sample</span><br><span class="line">|   |   |-- pre-commit.sample</span><br><span class="line">|   |   |-- prepare-commit-msg.sample</span><br><span class="line">|   |   |-- pre-push.sample</span><br><span class="line">|   |   |-- pre-rebase.sample</span><br><span class="line">|   |   `-- update.sample</span><br><span class="line">|   |-- index</span><br><span class="line">|   |-- info</span><br><span class="line">|   |   `-- exclude</span><br><span class="line">|   |-- logs</span><br><span class="line">|   |   |-- HEAD</span><br><span class="line">|   |   `-- refs</span><br><span class="line">|   |       `-- heads</span><br><span class="line">|   |           `-- master</span><br><span class="line">|   |-- objects</span><br><span class="line">|   |   |-- 9a</span><br><span class="line">|   |   |   `-- 9b255b81e994fa9af2b9c7ecbd852eb716ad6c</span><br><span class="line">|   |   |-- e6</span><br><span class="line">|   |   |   `-- 9de29bb2d1d6434b8b29ae775ad8c2e48c5391</span><br><span class="line">|   |   |-- f9</span><br><span class="line">|   |   |   `-- 3e3a1a1525fb5b91020da86e44810c87a2d7bc</span><br><span class="line">|   |   |-- info</span><br><span class="line">|   |   `-- pack</span><br><span class="line">|   `-- refs</span><br><span class="line">|       |-- heads</span><br><span class="line">|       |   `-- master</span><br><span class="line">|       `-- tags</span><br><span class="line">`-- README.md</span><br><span class="line"></span><br><span class="line">16 directories, 22 files</span><br><span class="line">[root@VM-0-3-centos simple]<span class="comment">#</span></span><br></pre></td></tr></table></figure><p>添加文件之后，<code>.git</code> 目录中的内容发生了变化，多了3个新的object。</p><h2 id="裸仓库"><a href="#裸仓库" class="headerlink" title="裸仓库"></a>裸仓库</h2><p>还是先从目录结构入手，我们使用 <code>git init --bare</code> 命令创建一个裸仓库，目录结构如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-0-3-centos data]<span class="comment"># git init --bare bare.git</span></span><br><span class="line">Initialized empty Git repository <span class="keyword">in</span> /data/bare.git/</span><br><span class="line">[root@VM-0-3-centos data]<span class="comment"># tree bare.git/ -a</span></span><br><span class="line">bare.git/</span><br><span class="line">|-- branches</span><br><span class="line">|-- config</span><br><span class="line">|-- description</span><br><span class="line">|-- HEAD</span><br><span class="line">|-- hooks</span><br><span class="line">|   |-- applypatch-msg.sample</span><br><span class="line">|   |-- commit-msg.sample</span><br><span class="line">|   |-- post-update.sample</span><br><span class="line">|   |-- pre-applypatch.sample</span><br><span class="line">|   |-- pre-commit.sample</span><br><span class="line">|   |-- prepare-commit-msg.sample</span><br><span class="line">|   |-- pre-push.sample</span><br><span class="line">|   |-- pre-rebase.sample</span><br><span class="line">|   `-- update.sample</span><br><span class="line">|-- info</span><br><span class="line">|   `-- exclude</span><br><span class="line">|-- objects</span><br><span class="line">|   |-- info</span><br><span class="line">|   `-- pack</span><br><span class="line">`-- refs</span><br><span class="line">    |-- heads</span><br><span class="line">    `-- tags</span><br><span class="line"></span><br><span class="line">9 directories, 13 files</span><br><span class="line">[root@VM-0-3-centos simple]<span class="comment">#</span></span><br></pre></td></tr></table></figure><p>从目录结构来看裸仓库和普通库很像，但是仔细对比你会发现，这个裸仓库相比普通库少了一层目录，库目录 <code>bare.git</code> 内直接就是之前普通库 <code>.git</code> 目录下的内容，也就是说在 <code>git</code> 目录外层没有了工作目录来进行文件的增删改操作，那么我们仿照普通库操作在这个目录下提交一个文件会怎样呢？</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-0-3-centos data]<span class="comment"># cd bare.git/</span></span><br><span class="line">[root@VM-0-3-centos bare.git]<span class="comment"># touch README.md</span></span><br><span class="line">[root@VM-0-3-centos bare.git]<span class="comment"># git add README.md</span></span><br><span class="line">fatal: This operation must be run <span class="keyword">in</span> a work tree</span><br><span class="line">[root@VM-0-3-centos bare.git]<span class="comment"># git status</span></span><br><span class="line">fatal: This operation must be run <span class="keyword">in</span> a work tree</span><br><span class="line">[root@VM-0-3-centos bare.git]<span class="comment">#</span></span><br></pre></td></tr></table></figure><p>通过操作发现这个裸仓库不允许增删改库内的文件，甚至连 <code>git status</code> 这种命令都无法使用，统一提示了 <code>fatal: This operation must be run in a work tree</code> 这句话，告诉用户这些命令都必须在工作区内操作，既然不能修改，那么这个裸仓库就是“只读”的，那么它还有什么用呢？</p><p>虽然裸仓库不允许直接修改，但是可以作为服务端远程仓库，在本地克隆这个远程仓库之后再进行修改，这也是最常见的应用方式，总结来说，普通库和裸仓库的区别就是：普通库拥有工作目录，并且工作目录中可以存放正常编辑和提交的文件，而裸库只存放这些文件的commit记录，不允许用户直接在上面进行各种git操作。</p><h1 id="使用裸仓库"><a href="#使用裸仓库" class="headerlink" title="使用裸仓库"></a>使用裸仓库</h1><p>前面提到裸仓库不能直接修改，但是我们可以采取修改克隆后库文件的方式达到更新的目的，下面列举两种常见的方式：</p><h2 id="使用-git-remote-add-方式关联"><a href="#使用-git-remote-add-方式关联" class="headerlink" title="使用 git remote add 方式关联"></a>使用 git remote add 方式关联</h2><p>这种方式需要我们先在本地初始化一个普通库，再使用 <code>git remote add</code> 命令建立关联（PowerShell命令行操作，git命令是相同的）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">PS-Win D:\data\maingit\<span class="built_in">test</span>&gt; git init barebyremote</span><br><span class="line">Initialized empty Git repository <span class="keyword">in</span> D:/data/maingit/<span class="built_in">test</span>/barebyremote/.git/</span><br><span class="line">PS-Win D:\data\maingit\<span class="built_in">test</span>&gt; <span class="built_in">cd</span> .\barebyremote\</span><br><span class="line">PS-Win D:\data\maingit\<span class="built_in">test</span>\barebyremote&gt; git remote add origin root@82.156.125.196:/data/bare.git</span><br><span class="line">PS-Win D:\data\maingit\<span class="built_in">test</span>\barebyremote&gt; new-item README.md</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    目录: D:\data\maingit\<span class="built_in">test</span>\barebyremote</span><br><span class="line"></span><br><span class="line">Mode                LastWriteTime         Length Name</span><br><span class="line">----                -------------         ------ ----</span><br><span class="line">-a----        2022/6/12     16:51              0 README.md</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">PS-Win D:\data\maingit\<span class="built_in">test</span>\barebyremote&gt; git add .\README.md</span><br><span class="line">PS-Win D:\data\maingit\<span class="built_in">test</span>\barebyremote&gt; git commit -m<span class="string">"add readme file"</span></span><br><span class="line">[master (root-commit) f1c41db] add readme file</span><br><span class="line"> 1 file changed, 0 insertions(+), 0 deletions(-)</span><br><span class="line"> create mode 100644 README.md</span><br><span class="line">PS-Win D:\data\maingit\<span class="built_in">test</span>\barebyremote&gt; git push -u origin master</span><br><span class="line">Enumerating objects: 3, <span class="keyword">done</span>.</span><br><span class="line">Counting objects: 100% (3/3), <span class="keyword">done</span>.</span><br><span class="line">Writing objects: 100% (3/3), 223 bytes | 223.00 KiB/s, <span class="keyword">done</span>.</span><br><span class="line">Total 3 (delta 0), reused 0 (delta 0)</span><br><span class="line">To 82.156.125.196:/data/bare.git</span><br><span class="line"> * [new branch]      master -&gt; master</span><br><span class="line">Branch <span class="string">'master'</span> <span class="built_in">set</span> up to track remote branch <span class="string">'master'</span> from <span class="string">'origin'</span>.</span><br><span class="line">PS-Win D:\data\maingit\<span class="built_in">test</span>\barebyremote&gt; git <span class="built_in">log</span> -3</span><br><span class="line">commit f1c41db4699f71e9750d8d6aa2c01875ac6d4a14 (HEAD -&gt; master, origin/master)</span><br><span class="line">Author: albert &lt;albert@163.com&gt;</span><br><span class="line">Date:   Sun Jun 12 16:51:34 2022 +0800</span><br><span class="line"></span><br><span class="line">    add readme file</span><br><span class="line">PS-Win D:\data\maingit\<span class="built_in">test</span>\barebyremote&gt;</span><br></pre></td></tr></table></figure><h2 id="使用-git-clone-直接克隆"><a href="#使用-git-clone-直接克隆" class="headerlink" title="使用 git clone 直接克隆"></a>使用 git clone 直接克隆</h2><p>使用克隆方式时，按照普通库来操作就可以（PowerShell命令行操作，git命令是相同的）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">PS-Win D:\data\maingit\<span class="built_in">test</span>&gt; git <span class="built_in">clone</span> root@82.156.125.196:/data/bare.git barebyclone</span><br><span class="line">Cloning into <span class="string">'barebyclone'</span>...</span><br><span class="line">remote: Counting objects: 3, <span class="keyword">done</span>.</span><br><span class="line">remote: Total 3 (delta 0), reused 0 (delta 0)</span><br><span class="line">Receiving objects: 100% (3/3), <span class="keyword">done</span>.</span><br><span class="line">PS-Win D:\data\maingit\<span class="built_in">test</span>&gt; <span class="built_in">cd</span> .\barebyclone\</span><br><span class="line">PS-Win D:\data\maingit\<span class="built_in">test</span>\barebyclone&gt; git <span class="built_in">log</span> -3</span><br><span class="line">commit f1c41db4699f71e9750d8d6aa2c01875ac6d4a14 (HEAD -&gt; master, origin/master, origin/HEAD)</span><br><span class="line">Author: albert &lt;albert@163.com&gt;</span><br><span class="line">Date:   Sun Jun 12 16:51:34 2022 +0800</span><br><span class="line"></span><br><span class="line">    add readme file</span><br><span class="line">PS-Win D:\data\maingit\<span class="built_in">test</span>\barebyclone&gt; ls</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    目录: D:\data\maingit\<span class="built_in">test</span>\barebyclone</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Mode                LastWriteTime         Length Name</span><br><span class="line">----                -------------         ------ ----</span><br><span class="line">-a----        2022/6/12     16:57              0 README.md</span><br></pre></td></tr></table></figure><h1 id="为什么要使用裸仓库"><a href="#为什么要使用裸仓库" class="headerlink" title="为什么要使用裸仓库"></a>为什么要使用裸仓库</h1><p>既然裸仓库相比于普通库只是少了工作目录，那么我们直接用普通库作为远程仓库可不可以呢？结论是可以，但是不建议，我们来实际操作一下，利用刚刚的建立的 <code>simple</code> 作为远端库，我们在本地clone后修改，再上传看看会遇到什么问题。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">PS-Win D:\data\maingit\<span class="built_in">test</span>&gt; git <span class="built_in">clone</span> root@82.156.125.196:/data/simple simple</span><br><span class="line">remote: Counting objects: 3, <span class="keyword">done</span>.</span><br><span class="line">remote: Total 3 (delta 0), reused 0 (delta 0)</span><br><span class="line">Receiving objects: 100% (3/3), <span class="keyword">done</span>.</span><br><span class="line">PS-Win D:\data\maingit\<span class="built_in">test</span>&gt; <span class="built_in">cd</span> .\simple\</span><br><span class="line">PS-Win D:\data\maingit\<span class="built_in">test</span>\simple&gt; git <span class="built_in">log</span> -3</span><br><span class="line">commit 9a9b255b81e994fa9af2b9c7ecbd852eb716ad6c (HEAD -&gt; master, origin/master, origin/HEAD)</span><br><span class="line">Author: albert &lt;albert@example.com&gt;</span><br><span class="line">Date:   Sun Jun 12 15:53:30 2022 +0800</span><br><span class="line"></span><br><span class="line">    add readme file</span><br><span class="line">PS-Win D:\data\maingit\<span class="built_in">test</span>\simple&gt; new-item .gitignore</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    目录: D:\data\maingit\<span class="built_in">test</span>\simple</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Mode                LastWriteTime         Length Name</span><br><span class="line">----                -------------         ------ ----</span><br><span class="line">-a----        2022/6/12     17:20              0 .gitignore</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">PS-Win D:\data\maingit\<span class="built_in">test</span>\simple&gt; git add .\.gitignore</span><br><span class="line">PS-Win D:\data\maingit\<span class="built_in">test</span>\simple&gt; git commit -m<span class="string">"add gitignore file"</span></span><br><span class="line">[master b5a679f] add gitignore file</span><br><span class="line"> 1 file changed, 0 insertions(+), 0 deletions(-)</span><br><span class="line"> create mode 100644 .gitignore</span><br><span class="line">PS-Win D:\data\maingit\<span class="built_in">test</span>\simple&gt; git push</span><br><span class="line">Enumerating objects: 3, <span class="keyword">done</span>.</span><br><span class="line">Counting objects: 100% (3/3), <span class="keyword">done</span>.</span><br><span class="line">Delta compression using up to 4 threads</span><br><span class="line">Compressing objects: 100% (2/2), <span class="keyword">done</span>.</span><br><span class="line">Writing objects: 100% (2/2), 263 bytes | 263.00 KiB/s, <span class="keyword">done</span>.</span><br><span class="line">Total 2 (delta 0), reused 0 (delta 0)</span><br><span class="line">remote: error: refusing to update checked out branch: refs/heads/master</span><br><span class="line">remote: error: By default, updating the current branch <span class="keyword">in</span> a non-bare repository</span><br><span class="line">remote: error: is denied, because it will make the index and work tree inconsistent</span><br><span class="line">remote: error: with what you pushed, and will require <span class="string">'git reset --hard'</span> to match</span><br><span class="line">remote: error: the work tree to HEAD.</span><br><span class="line">remote: error:</span><br><span class="line">remote: error: You can <span class="built_in">set</span> <span class="string">'receive.denyCurrentBranch'</span> configuration variable to</span><br><span class="line">remote: error: <span class="string">'ignore'</span> or <span class="string">'warn'</span> <span class="keyword">in</span> the remote repository to allow pushing into</span><br><span class="line">remote: error: its current branch; however, this is not recommended unless you</span><br><span class="line">remote: error: arranged to update its work tree to match what you pushed <span class="keyword">in</span> some</span><br><span class="line">remote: error: other way.</span><br><span class="line">remote: error:</span><br><span class="line">remote: error: To squelch this message and still keep the default behaviour, <span class="built_in">set</span></span><br><span class="line">remote: error: <span class="string">'receive.denyCurrentBranch'</span> configuration variable to <span class="string">'refuse'</span>.</span><br><span class="line">To 82.156.125.196:/data/simple</span><br><span class="line"> ! [remote rejected] master -&gt; master (branch is currently checked out)</span><br><span class="line">error: failed to push some refs to <span class="string">'root@82.156.125.196:/data/simple'</span></span><br><span class="line">PS-Win D:\data\maingit\<span class="built_in">test</span>\simple&gt;</span><br></pre></td></tr></table></figure><p>克隆之后正常的修改和提交都没有问题，但是 <code>git push</code>的时候报错，原因提示 <code>! [remote rejected] master -&gt; master (branch is currently checked out)</code>，提示当前的 <code>master</code> 分支是检出状态，不允许直接推送。</p><p>仔细想想就会有些思路，普通库实际上包含两份数据的，一份在 <code>.git</code> 目录中以object形式存在，一份在工作目录中以源文件形式存在，我们每次使用 <code>git</code> 命令，可以保证工作目录内文件和 <code>.git</code> 目录数据是一致的，但是如果将普通库作为远端时，在下游提交数据时，远端库中的 <code>.git</code> 目录会直接更新，但是工作区却不知道此时谁在用，不能直接更新覆盖，这就造成了数据不一致的情况。</p><p>如果非得使用普通库作为服务端仓库，那么可以参照上面报错的建议，在采用额外方式保证一致性的同时，修改服务端库的 <code>receive.denyCurrentBranch</code> 这个git配置项，或者将服务端分支切换到一个无人使用的分支上，这样下游端就可以直接推送了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-0-3-centos data]<span class="comment"># cd simple/</span></span><br><span class="line">[root@VM-0-3-centos simple]<span class="comment"># git checkout -b unless</span></span><br><span class="line">Switched to a new branch <span class="string">'unless'</span></span><br><span class="line">[root@VM-0-3-centos simple]<span class="comment"># git branch -a</span></span><br><span class="line">  master</span><br><span class="line">* unless</span><br><span class="line">[root@VM-0-3-centos simple]<span class="comment">#</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">PS-Win D:\data\maingit\<span class="built_in">test</span>\simple&gt; <span class="built_in">pwd</span></span><br><span class="line"></span><br><span class="line">Path</span><br><span class="line">----</span><br><span class="line">D:\data\maingit\<span class="built_in">test</span>\simple</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">PS-Win D:\data\maingit\<span class="built_in">test</span>\simple&gt; git push</span><br><span class="line">Enumerating objects: 3, <span class="keyword">done</span>.</span><br><span class="line">Counting objects: 100% (3/3), <span class="keyword">done</span>.</span><br><span class="line">Delta compression using up to 4 threads</span><br><span class="line">Compressing objects: 100% (2/2), <span class="keyword">done</span>.</span><br><span class="line">Writing objects: 100% (2/2), 263 bytes | 263.00 KiB/s, <span class="keyword">done</span>.</span><br><span class="line">Total 2 (delta 0), reused 0 (delta 0)</span><br><span class="line">To 82.156.125.196:/data/simple</span><br><span class="line">   9a9b255..b5a679f  master -&gt; master</span><br><span class="line">PS-Win D:\data\maingit\<span class="built_in">test</span>\simple&gt;</span><br></pre></td></tr></table></figure><h1 id="自动化部署"><a href="#自动化部署" class="headerlink" title="自动化部署"></a>自动化部署</h1><p>利用 <code>post-receive</code> 进行自动化部署的原理就是，<code>git</code> 本身提供了一些脚本接口，在某些 <code>git</code> 操作发生时，会调用预定脚本执行命令，相当于给 <code>git</code> 用户开放了接口，我们可以修改 <code>post-receive</code> 脚本，在修改提交后自动部署最新内容，进一步实现自动化集成。</p><p>因为前面已经介绍了很多有关裸仓库的知识，接下来我只叙述操作步骤，看了之前的介绍，这部分内容应该没什么难度了。</p><h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>服务端建立裸仓库，在接收到新的提交时，自动将项目部署到<code>/data/publish/game</code> 目录下</p><h2 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h2><h3 id="服务端远端操作"><a href="#服务端远端操作" class="headerlink" title="服务端远端操作"></a>服务端远端操作</h3><p>建立裸仓库 <code>/data/repo/game.git</code>，对应部署目录是 <code>/data/publish/game</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-0-3-centos data]<span class="comment"># mkdir -p /data/repo</span></span><br><span class="line">[root@VM-0-3-centos data]<span class="comment"># mkdir -p /data/publish/game</span></span><br><span class="line">[root@VM-0-3-centos data]<span class="comment"># cd repo/</span></span><br><span class="line">[root@VM-0-3-centos repo]<span class="comment"># git init --bare game.git</span></span><br><span class="line">Initialized empty Git repository <span class="keyword">in</span> /data/repo/game.git/</span><br><span class="line">[root@VM-0-3-centos repo]<span class="comment">#</span></span><br></pre></td></tr></table></figure><p>新建 <code>/data/repo/game.git/hooks/post-receive</code> 脚本，可以拷贝 <code>post-receive.sample</code> 进行修改，脚本内编写内容如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 指定部署目录</span></span><br><span class="line">DIR=/data/publish/game</span><br><span class="line">git --work-tree=<span class="variable">$&#123;DIR&#125;</span> clean -fd</span><br><span class="line"><span class="comment"># 强制检出</span></span><br><span class="line">git --work-tree=<span class="variable">$&#123;DIR&#125;</span> checkout --force</span><br><span class="line"><span class="comment"># 运行启动脚本</span></span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$&#123;DIR&#125;</span></span><br><span class="line">chmod 755 start.sh</span><br><span class="line">./start.sh</span><br></pre></td></tr></table></figure><h3 id="客户端本地操作"><a href="#客户端本地操作" class="headerlink" title="客户端本地操作"></a>客户端本地操作</h3><p>本地项目普通库目录结构如下，启动脚本为 <code>start.sh</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc MINGW64 /d/data/maingit/<span class="built_in">test</span>/game (master)</span><br><span class="line">$ tree game/ -a</span><br><span class="line">game/</span><br><span class="line">├── .git</span><br><span class="line">│   ├── COMMIT_EDITMSG</span><br><span class="line">│   ├── config</span><br><span class="line">│   ├── description</span><br><span class="line">│   ├── HEAD</span><br><span class="line">│   ├── hooks</span><br><span class="line">│   │   ├── applypatch-msg.sample</span><br><span class="line">│   │   ├── commit-msg.sample</span><br><span class="line">│   │   ├── fsmonitor-watchman.sample</span><br><span class="line">│   │   ├── post-update.sample</span><br><span class="line">│   │   ├── pre-applypatch.sample</span><br><span class="line">│   │   ├── pre-commit.sample</span><br><span class="line">│   │   ├── pre-merge-commit.sample</span><br><span class="line">│   │   ├── prepare-commit-msg.sample</span><br><span class="line">│   │   ├── pre-push.sample</span><br><span class="line">│   │   ├── pre-rebase.sample</span><br><span class="line">│   │   ├── pre-receive.sample</span><br><span class="line">│   │   └── update.sample</span><br><span class="line">│   ├── index</span><br><span class="line">│   ├── info</span><br><span class="line">│   │   └── exclude</span><br><span class="line">│   ├── logs</span><br><span class="line">│   │   ├── HEAD</span><br><span class="line">│   │   └── refs</span><br><span class="line">│   │       └── heads</span><br><span class="line">│   │           └── master</span><br><span class="line">│   ├── objects</span><br><span class="line">│   │   ├── 53</span><br><span class="line">│   │   │   └── dd8b65afe02329eb73cbe142b9359ffd2c4c70</span><br><span class="line">│   │   ├── 68</span><br><span class="line">│   │   │   └── 31f81503989c192a10b47ecf48bc6bfe7c2cf4</span><br><span class="line">│   │   ├── 81</span><br><span class="line">│   │   │   └── aaa9093e1d32996c53766fa5f943e3ea6c79b0</span><br><span class="line">│   │   ├── e6</span><br><span class="line">│   │   │   └── 9de29bb2d1d6434b8b29ae775ad8c2e48c5391</span><br><span class="line">│   │   ├── info</span><br><span class="line">│   │   └── pack</span><br><span class="line">│   └── refs</span><br><span class="line">│       ├── heads</span><br><span class="line">│       │   └── master</span><br><span class="line">│       └── tags</span><br><span class="line">├── README.md</span><br><span class="line">└── start.sh</span><br><span class="line"></span><br><span class="line">16 directories, 27 files</span><br><span class="line">albert@home-pc MINGW64 /d/data/maingit/<span class="built_in">test</span>/game (master)</span><br><span class="line">$ cat start.sh</span><br><span class="line">cp README.md test.txt</span><br></pre></td></tr></table></figure><h3 id="与远端裸仓库建立关联"><a href="#与远端裸仓库建立关联" class="headerlink" title="与远端裸仓库建立关联"></a>与远端裸仓库建立关联</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc MINGW64 /d/data/maingit/<span class="built_in">test</span>/game (master)</span><br><span class="line">$ git remote add origin root@82.156.125.196:/data/repo/game.git</span><br><span class="line"></span><br><span class="line">albert@home-pc MINGW64 /d/data/maingit/<span class="built_in">test</span>/game (master)</span><br><span class="line">$ git push -u origin master</span><br><span class="line">Enumerating objects: 4, <span class="keyword">done</span>.</span><br><span class="line">Counting objects: 100% (4/4), <span class="keyword">done</span>.</span><br><span class="line">Delta compression using up to 4 threads</span><br><span class="line">Compressing objects: 100% (2/2), <span class="keyword">done</span>.</span><br><span class="line">Writing objects: 100% (4/4), 286 bytes | 286.00 KiB/s, <span class="keyword">done</span>.</span><br><span class="line">Total 4 (delta 0), reused 0 (delta 0)</span><br><span class="line">To 82.156.125.196:/data/repo/game.git</span><br><span class="line"> * [new branch]      master -&gt; master</span><br><span class="line">Branch <span class="string">'master'</span> <span class="built_in">set</span> up to track remote branch <span class="string">'master'</span> from <span class="string">'origin'</span>.</span><br></pre></td></tr></table></figure><p>至此自动化部署环境已建立，当本地 game 仓库推送更新时，远端服务器会自动更新部署</p><h1 id="快速回顾"><a href="#快速回顾" class="headerlink" title="快速回顾"></a>快速回顾</h1><p>文中主要命令收于此节，方便自己后期快速查找操作</p><ul><li>服务端远程新建裸仓库</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /data/repo</span><br><span class="line">git init --bare game.git</span><br></pre></td></tr></table></figure><ul><li>本地库与远端库建立关联</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin root@82.156.125.196:/data/repo/game.git</span><br></pre></td></tr></table></figure><ul><li>新建或修改 <code>hooks</code> 目录下 <code>post-receive</code> 脚本</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DIR=/data/publish/game</span><br><span class="line">git --work-tree=<span class="variable">$&#123;DIR&#125;</span> clean -fd</span><br><span class="line">git --work-tree=<span class="variable">$&#123;DIR&#125;</span> checkout --force</span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$&#123;DIR&#125;</span></span><br><span class="line">chmod 755 start.sh</span><br><span class="line">./start.sh</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>裸仓库是一个只包含提交记录，没有工作目录的仓库，适合用来做服务端远程仓库</li><li>裸仓库不能直接在仓库中执行修改文件的git命令，可以在客户端克隆之后修改之后再进行提交</li><li>自动化部署利用了git服务器提供的脚本接口，当新的推送达到时会调用 <code>post-receive</code> 脚本</li><li>配置自动化部署环境时需要注意，如果没有配置ssh免密码登陆，需要在push代码的时候输入密码</li><li>另外自动化部署时要注意各个文件及目录的权限，因为要运行脚本，要保证推送用户有足够的运行权限</li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/125157732" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>每个人都有自己的选择，很多看似突如其来的决定，往往都是深思熟虑后的结果，每个人在自己的旅途中不断的分类、选择、分类、选择，无法逃离的坚持到最后一刻~</p><p>2022-6-12 20:19:30</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;【裸仓库】指的是使用 &lt;code&gt;git init --bare&lt;/code&gt; 命令得到的仓库，是对这种操作结果的一种直译，这个词对于刚接触 git 软件的小伙伴来说可能是第一次听说，而我也是最近实际操作了几次才渐渐理解，下面解释一下什么是裸仓库，以及为什么要使用它，有理解不对的地方还请大家指正。&lt;/p&gt;
    
    </summary>
    
      <category term="Git" scheme="http://AlbertGithubHome.github.io/blog/categories/Git/"/>
    
    
      <category term="bare" scheme="http://AlbertGithubHome.github.io/blog/tags/bare/"/>
    
      <category term="clone" scheme="http://AlbertGithubHome.github.io/blog/tags/clone/"/>
    
      <category term="post_receive" scheme="http://AlbertGithubHome.github.io/blog/tags/post-receive/"/>
    
      <category term="deploy" scheme="http://AlbertGithubHome.github.io/blog/tags/deploy/"/>
    
  </entry>
  
  <entry>
    <title>linux环境下常用的查找命令find、which、grep</title>
    <link href="http://AlbertGithubHome.github.io/blog/2022/06/05/linux%E7%8E%AF%E5%A2%83%E4%B8%8B%E5%B8%B8%E7%94%A8%E7%9A%84%E6%9F%A5%E6%89%BE%E5%91%BD%E4%BB%A4find%E3%80%81which%E3%80%81grep/"/>
    <id>http://AlbertGithubHome.github.io/blog/2022/06/05/linux环境下常用的查找命令find、which、grep/</id>
    <published>2022-06-05T15:07:29.000Z</published>
    <updated>2022-06-06T17:38:33.750Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>查找是运维工作的很重要的一部分，不管是文件查找，还是内容查找，在日常开发维护过程中都常常用到，本文把一些日常用到的查找命令总结到一起，通过对比来学习异同点，进而达到 增强记忆的目的。</p><a id="more"></a><p>本文只是想对常用命令进行一个罗列，并不会对每个命令进行详细的解释，如果想看更详细的用法，直接查询 <code>man</code> 手册是一个不错的选择，我们接下来会说到通用文件查找的 <code>find</code> 命令，快速定位文件的 <code>locate</code> 命令，仅用于搜索程序和文档的 <code>whereis</code> 命令，用于查找系统命令的 <code>which</code> 命令，最后是用于文件内容查找的 <code>grep</code> 命令。</p><h1 id="find"><a href="#find" class="headerlink" title="find"></a>find</h1><h2 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find [指定目录] 搜索条件 [指定动作]</span><br></pre></td></tr></table></figure><h2 id="具体示例"><a href="#具体示例" class="headerlink" title="具体示例"></a>具体示例</h2><ul><li>全局查找tendis文件所在目录</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-0-3-centos ~]<span class="comment"># find / -name tendis</span></span><br><span class="line">/root/tendis</span><br></pre></td></tr></table></figure><ul><li>当前目录按指定名找到tendis并打印文件信息</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-0-3-centos ~]<span class="comment"># find . -name tendis -ls</span></span><br><span class="line">918146    4 drwxr-xr-x   4 root     root         4096 May  1  2021 ./tendis</span><br></pre></td></tr></table></figure><ul><li>全局查找test开头的文件</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-0-3-centos ~]<span class="comment"># find / -name 'test*'</span></span><br><span class="line">/boot/grub2/i386-pc/testspeed.mod</span><br><span class="line">/boot/grub2/i386-pc/test.mod</span><br><span class="line">/boot/grub2/i386-pc/test_blockarg.mod</span><br><span class="line">/boot/grub2/i386-pc/testload.mod</span><br><span class="line">/usr/lib/modules/3.10.0-1127.19.1.el7.x86_64/kernel/drivers/ntb/<span class="built_in">test</span></span><br><span class="line">/usr/lib/python2.7/site-packages/jinja2/tests.pyc</span><br><span class="line">/usr/lib/python2.7/site-packages/jinja2/tests.py</span><br><span class="line">/usr/lib/python2.7/site-packages/jinja2/testsuite</span><br><span class="line">...</span><br></pre></td></tr></table></figure><ul><li>当前目录下查找所有的目录</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-0-3-centos ~]<span class="comment"># find . -type d</span></span><br><span class="line">.</span><br><span class="line">./tendis</span><br><span class="line">./tendis/scripts</span><br><span class="line">./tendis/bin</span><br><span class="line">./tendis/bin/deps</span><br><span class="line">./extundelete-0.2.4</span><br><span class="line">...</span><br></pre></td></tr></table></figure><ul><li>查找大于1M的文件</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-0-3-centos ~]<span class="comment"># find . -size +1M -ls</span></span><br><span class="line">918152 164712 -rwxr-xr-x   1 root     root     168663910 Dec 17  2020 ./tendis/bin/tendisplus_static</span><br><span class="line">918151 18036 -rwxr-xr-x   1 root     root     18464898 Dec 17  2020 ./tendis/bin/binlog_tool</span><br><span class="line">918148 2576 -rwxr-xr-x   1 root     root      2635759 Dec 17  2020 ./tendis/bin/redis-cli</span><br><span class="line">918150 10896 -rwxr-xr-x   1 root     root     11154937 Dec 17  2020 ./tendis/bin/deps/libstdc++.so.6</span><br><span class="line">918145 165076 -rwxr-xr-x   1 root     root     169036319 Dec 17  2020 ./tendis/bin/tendisplus</span><br><span class="line">1311915 1860 -rw-r--r--   1 root     root      1904320 Nov 28  2021 ./extundelete-0.2.4/src/extundelete-extundelete.o</span><br><span class="line">1311926 1296 -rwxr-xr-x   1 root     root      1323360 Nov 28  2021 ./extundelete-0.2.4/src/extundelete</span><br><span class="line">...</span><br></pre></td></tr></table></figure><ul><li>查找10分钟内修改的普通文件</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-0-3-centos ~]<span class="comment"># find . -type f -mmin -10</span></span><br><span class="line">./b.txt</span><br><span class="line">./.bash_history</span><br></pre></td></tr></table></figure><h1 id="locate"><a href="#locate" class="headerlink" title="locate"></a>locate</h1><p>locate 也是用来查找文件的，只不过它不是通过文件系统来找，而是通过自己的数据库来找，默认在 <code>/var/lib/mlocate/mlocate.db</code>，每天自动更新一次，所以查不到最新变动的文件，可以手动通过 <code>updatedb</code> 来更新数据库（我查了一下才2M很小的）。</p><h2 id="命令格式-1"><a href="#命令格式-1" class="headerlink" title="命令格式"></a>命令格式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">locate [选项] [匹配串]</span><br></pre></td></tr></table></figure><h2 id="具体示例-1"><a href="#具体示例-1" class="headerlink" title="具体示例"></a>具体示例</h2><ul><li>查找家目录下包含te的文件</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-0-3-centos ~]<span class="comment"># locate ~/te</span></span><br><span class="line">/root/tendis</span><br><span class="line">/root/test.iso</span><br><span class="line">/root/tendis/bin</span><br><span class="line">/root/tendis/file.xml</span><br><span class="line">/root/tendis/scripts</span><br><span class="line">/root/tendis/bin/binlog_tool</span><br><span class="line">/root/tendis/bin/deps</span><br><span class="line">/root/tendis/bin/redis-cli</span><br><span class="line">/root/tendis/bin/tendisplus</span><br><span class="line">/root/tendis/bin/tendisplus_static</span><br><span class="line">/root/tendis/bin/deps/libstdc++.so.6</span><br><span class="line">/root/tendis/scripts/start.sh</span><br><span class="line">/root/tendis/scripts/stop.sh</span><br><span class="line">/root/tendis/scripts/tendisplus.conf</span><br></pre></td></tr></table></figure><ul><li>不区分大小写查找</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-0-3-centos ~]<span class="comment"># locate -i ~/tE</span></span><br><span class="line">/root/TE.txt</span><br><span class="line">/root/tendis</span><br><span class="line">/root/test.iso</span><br><span class="line">/root/tendis/bin</span><br><span class="line">/root/tendis/file.xml</span><br><span class="line">/root/tendis/scripts</span><br><span class="line">/root/tendis/bin/binlog_tool</span><br><span class="line">/root/tendis/bin/deps</span><br><span class="line">/root/tendis/bin/redis-cli</span><br><span class="line">/root/tendis/bin/tendisplus</span><br><span class="line">/root/tendis/bin/tendisplus_static</span><br><span class="line">/root/tendis/bin/deps/libstdc++.so.6</span><br><span class="line">/root/tendis/scripts/start.sh</span><br><span class="line">/root/tendis/scripts/stop.sh</span><br><span class="line">/root/tendis/scripts/tendisplus.conf</span><br></pre></td></tr></table></figure><h1 id="whereis"><a href="#whereis" class="headerlink" title="whereis"></a>whereis</h1><p>whereis 只能用于二进制文件、man手册和源代码文件的搜索，默认返回所有信息。</p><h2 id="命令格式-2"><a href="#命令格式-2" class="headerlink" title="命令格式"></a>命令格式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">whereis [-bmsBMS] 匹配串</span><br></pre></td></tr></table></figure><h2 id="具体示例-2"><a href="#具体示例-2" class="headerlink" title="具体示例"></a>具体示例</h2><ul><li>查找二进制程序 <code>ls</code></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-0-3-centos ~]<span class="comment"># whereis -b ls</span></span><br><span class="line">ls: /usr/bin/ls</span><br></pre></td></tr></table></figure><ul><li>查找 <code>grep</code> 所有信息</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-0-3-centos ~]<span class="comment"># whereis grep</span></span><br><span class="line">grep: /usr/bin/grep /usr/share/man/man1/grep.1.gz</span><br></pre></td></tr></table></figure><h1 id="which"><a href="#which" class="headerlink" title="which"></a>which</h1><p>which 是在 PATH 变量中找到第一个匹配的命令并返回，这能帮助我们确认多个相同命令时用的是哪一个。</p><h2 id="命令格式-3"><a href="#命令格式-3" class="headerlink" title="命令格式"></a>命令格式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">which [选项] 匹配串</span><br></pre></td></tr></table></figure><h2 id="具体示例-3"><a href="#具体示例-3" class="headerlink" title="具体示例"></a>具体示例</h2><ul><li>打印当前使用的gcc程序，打印所有可加 <code>-a</code> 参数</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-0-3-centos ~]<span class="comment"># which gcc</span></span><br><span class="line">/usr/bin/gcc</span><br><span class="line">[root@VM-0-3-centos ~]<span class="comment"># which gcc -a</span></span><br><span class="line">/usr/bin/gcc</span><br></pre></td></tr></table></figure><h1 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h1><p>grep 不算是单纯查找文件的命令，更多的是用于从文件中过滤指定内容。</p><h2 id="命令格式-4"><a href="#命令格式-4" class="headerlink" title="命令格式"></a>命令格式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep [选项] 匹配串 [指定文件]</span><br></pre></td></tr></table></figure><h2 id="具体示例-4"><a href="#具体示例-4" class="headerlink" title="具体示例"></a>具体示例</h2><ul><li>过滤包含指定字符串的行</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-0-3-centos ~]<span class="comment"># grep "which" w.txt</span></span><br><span class="line">       <span class="built_in">which</span> - shows the full path of (shell) commands.</span><br><span class="line">       <span class="built_in">which</span> [options] [--] programname [...]</span><br><span class="line">       This man page is generated from the file which.texinfo.</span><br></pre></td></tr></table></figure><ul><li>显示匹配行之后的2行</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-0-3-centos ~]<span class="comment"># grep "which" w.txt -A 2</span></span><br><span class="line">       <span class="built_in">which</span> - shows the full path of (shell) commands.</span><br><span class="line"></span><br><span class="line">SYNOPSIS</span><br><span class="line">       <span class="built_in">which</span> [options] [--] programname [...]</span><br><span class="line"></span><br><span class="line">DESCRIPTION</span><br><span class="line">--</span><br><span class="line">       This man page is generated from the file which.texinfo.</span><br><span class="line"></span><br><span class="line">OPTIONS</span><br><span class="line">--</span><br></pre></td></tr></table></figure><ul><li>当前目录下查找包含 <code>wonderful</code> 的文件</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-0-3-centos ~]<span class="comment"># grep -r "wonderful" .</span></span><br><span class="line">./.rediscli_history:hset life family wonderful</span><br><span class="line">./.bash_history:grep -r <span class="string">"wonderful"</span> . | head</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li><code>find</code>命令查找文件最全面 <code>find . -name tendis -ls</code></li><li><code>locate</code> 命令查找最快，<code>locate -i /etc/redis</code>，可用 <code>updatedb</code> 命令更新数据库</li><li><code>whereis</code> 命令可以查找二进制、man手册、源码，<code>whereis -b grep</code></li><li><code>which</code> 可以从PATH路径下找到第一个匹配的二进制程序</li><li><code>grep</code> 一个强大的过滤命令，也可用于找文件 <code>grep -r &quot;wonderful&quot; .</code></li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/124790386" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>幸福感从比较中诞生，亦从比较中消亡，并且与比较双方的关系紧密程度高度相关。我有一块糖，而你没有，我就很幸福，转身发现他有10块糖，然后嘴里的糖瞬间就不甜了~</p><p>2022-6-5 23:21:58</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;查找是运维工作的很重要的一部分，不管是文件查找，还是内容查找，在日常开发维护过程中都常常用到，本文把一些日常用到的查找命令总结到一起，通过对比来学习异同点，进而达到 增强记忆的目的。&lt;/p&gt;
    
    </summary>
    
      <category term="linux" scheme="http://AlbertGithubHome.github.io/blog/categories/linux/"/>
    
    
      <category term="find" scheme="http://AlbertGithubHome.github.io/blog/tags/find/"/>
    
      <category term="查找" scheme="http://AlbertGithubHome.github.io/blog/tags/%E6%9F%A5%E6%89%BE/"/>
    
      <category term="grep" scheme="http://AlbertGithubHome.github.io/blog/tags/grep/"/>
    
      <category term="locate" scheme="http://AlbertGithubHome.github.io/blog/tags/locate/"/>
    
      <category term="which" scheme="http://AlbertGithubHome.github.io/blog/tags/which/"/>
    
  </entry>
  
  <entry>
    <title>.bat批处理（十一）：替换字符串中包含百分号%的子串</title>
    <link href="http://AlbertGithubHome.github.io/blog/2022/05/15/bat%E6%89%B9%E5%A4%84%E7%90%86%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89%EF%BC%9A%E6%9B%BF%E6%8D%A2%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E5%8C%85%E5%90%AB%E7%99%BE%E5%88%86%E5%8F%B7-%E7%9A%84%E5%AD%90%E4%B8%B2/"/>
    <id>http://AlbertGithubHome.github.io/blog/2022/05/15/bat批处理（十一）：替换字符串中包含百分号-的子串/</id>
    <published>2022-05-15T14:28:46.000Z</published>
    <updated>2022-05-15T15:21:16.099Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>今天这篇总结是之前批处理替换字符串的延伸问题，同样来源于读者的提问，要处理的问题是被替换的子串中如果有百分号 <code>%</code> 要怎样替换，因为 <code>%</code> 在批处理脚本中也比较特殊，如果要想表示一个 <code>%</code> 字符，那么在给变量赋值时需要写成 <code>%%</code> 的样子，用两个表示一个，类似于进行转义，因为在批处理中， <code>%</code>开头的内容通常表示一个变量。</p><p>之前也处理过一些替换问题，列举如下，不过今天的问题需要新的解法。</p><a id="more"></a><ul><li><a href="https://blog.csdn.net/albertsh/article/details/79919465" target="_blank" rel="noopener">《.bat批处理（六）：替换字符串中匹配的子串》</a></li><li><a href="https://blog.csdn.net/albertsh/article/details/105611277" target="_blank" rel="noopener">《.bat批处理（九）：替换带有等号=的字符串的子串》</a></li></ul><h1 id="问题示例"><a href="#问题示例" class="headerlink" title="问题示例"></a>问题示例</h1><blockquote><p>将字符串 <code>https://blog.csdn.net/alb%3crtsh/articl%3c/d%3ctails/124760925</code> 中的 <code>%3c</code> 替换成字母 <code>e</code></p></blockquote><p>问题比较明确，就是因为被替换的子串中包含了 <code>%</code> 导致常规的替换写法 <code>%a:b=c%</code> 的写法失效了。</p><h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><p>既然子串中包含 <code>%</code> 会影响变量替换字符串的写法，我们就可以考虑换一种变量写法，用 <code>!</code> 代替 <code>%</code>，看到这很多人应该反应过来了，那就是启用延迟变量扩展，这个我就不展开说了，之前总结过，可以看一下这篇文章<a href="https://blog.csdn.net/albertsh/article/details/102985590" target="_blank" rel="noopener">《.bat批处理（八）：各种形式的变量%0、%i、%%i、var、%var%、!var!的含义和区别》</a>。</p><h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line">rem 将输入字符串中的%3c替换成字母e</span><br><span class="line"></span><br><span class="line">SET INPUT_PARAM=%1</span><br><span class="line">setlocal EnableDelayedExpansion</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> -</span><br><span class="line"><span class="built_in">echo</span> replace result is !INPUT_PARAM:%%3c=e!</span><br><span class="line"><span class="built_in">echo</span> -</span><br><span class="line"></span><br><span class="line">pause</span><br></pre></td></tr></table></figure><h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">D:\data\bat&gt;replace%.bat https://blog.csdn.net/alb%3crtsh/articl%3c/d%3ctails/124760925</span><br><span class="line">-</span><br><span class="line">replace result is https://blog.csdn.net/albertsh/article/details/124760925</span><br><span class="line">-</span><br><span class="line">请按任意键继续. . .</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>批处理脚本中的替换语法不仅可以写成 <code>%a:b=c%</code>，还可以写成 <code>!a:b=c!</code>的形式</li><li>批处理脚本执行机制是会按行执行，在执行之前会先预处理</li><li>开启延迟环境变量扩展<code>setlocal enabledelayedexpansion</code>，变量会在用到时再估值，不会预处理了</li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/124760925" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>公平不一定平等，平等也不代表公平。究竟什么是秩序，往往强者指定规则，弱者小心遵守，达到一个稳态，那就是秩序~</p><p>2022-5-15 23:02:49</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;今天这篇总结是之前批处理替换字符串的延伸问题，同样来源于读者的提问，要处理的问题是被替换的子串中如果有百分号 &lt;code&gt;%&lt;/code&gt; 要怎样替换，因为 &lt;code&gt;%&lt;/code&gt; 在批处理脚本中也比较特殊，如果要想表示一个 &lt;code&gt;%&lt;/code&gt; 字符，那么在给变量赋值时需要写成 &lt;code&gt;%%&lt;/code&gt; 的样子，用两个表示一个，类似于进行转义，因为在批处理中， &lt;code&gt;%&lt;/code&gt;开头的内容通常表示一个变量。&lt;/p&gt;
&lt;p&gt;之前也处理过一些替换问题，列举如下，不过今天的问题需要新的解法。&lt;/p&gt;
    
    </summary>
    
      <category term="bat" scheme="http://AlbertGithubHome.github.io/blog/categories/bat/"/>
    
    
      <category term="实用工具" scheme="http://AlbertGithubHome.github.io/blog/tags/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/"/>
    
      <category term="bat" scheme="http://AlbertGithubHome.github.io/blog/tags/bat/"/>
    
  </entry>
  
  <entry>
    <title>linux环境下常用的网络命令ping、telnet、traceroute、tcpdump</title>
    <link href="http://AlbertGithubHome.github.io/blog/2022/05/10/linux%E7%8E%AF%E5%A2%83%E4%B8%8B%E5%B8%B8%E7%94%A8%E7%9A%84%E7%BD%91%E7%BB%9C%E5%91%BD%E4%BB%A4ping%E3%80%81telnet%E3%80%81traceroute%E3%80%81tcpdump/"/>
    <id>http://AlbertGithubHome.github.io/blog/2022/05/10/linux环境下常用的网络命令ping、telnet、traceroute、tcpdump/</id>
    <published>2022-05-10T13:11:20.000Z</published>
    <updated>2022-05-15T14:30:43.178Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>因特网(Internet)的前身是美国国防部高级研究计划局(ARPA)用于军事目的的通信网络，真的就是一个内部的工具出圈成了改变世界的事物。网这个词用的很形象也很贴切，如今的世界任何事情都离不开这个大网了，特别是之前炒的非常火爆的万物互联概念，更是把所有事物都挂在了“网”上，虽然这张大网某些节点偶尔会不太通畅，但这并不能阻断消息的往来。之前都在讲全球化，谁能想到短短几年“逆全球化”居然越来越热。</p><a id="more"></a><p>1983年1月1日被认为是互联网的官方生日，在此之前，各种计算机网络没有相互通信的标准方式。但从这一天开始，用于军事目的的阿帕网和国防数据网络正式定义为TCP/IP标准，建立了一种统一的通信协议，它允许不同网络上不同类型的计算机相互”交谈”，互联网就此诞生了。</p><h1 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h1><p>如今人们已经离不开网络了，不管是每天工作，还是日常娱乐，网络无处不在，连两岁的宝宝看到动画片转圈圈都知道是网卡了，而进行应用开发和游戏开发的搬砖小哥儿们更是无人能逃脱网络问题，遇到网络问题不可怕，重启电脑、重启路由器，重启光猫，问题很可能就解决了。</p><p>但，总有那么几个问题是重启解决不了的，所以我们还是得掌握一些正常的工具来排查问题，那么接下来就列举几个常用的命令，真的很常见，大神请绕路~</p><h1 id="网络命令"><a href="#网络命令" class="headerlink" title="网络命令"></a>网络命令</h1><h2 id="ping"><a href="#ping" class="headerlink" title="ping"></a>ping</h2><p>这应该是用的最多的一个网络命令了吧，“ping一下通不通”，这句话经常在日常开发调试中被提及，<code>ping</code> 命令常常用来测试，指定的两台机器之间的网络是否可以连通，命令格式如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping [OPTIONS] 域名或IP地址</span><br></pre></td></tr></table></figure><p>一些常用的选项：</p><ul><li><code>-4</code>：只使用 IPv4</li><li><code>-6</code>：只使用 IPv6</li><li><code>-c count</code>：发送多少个测试包之后停止，linux环境下如果不加这个参数会一直发包</li><li><code>-i interval</code>：指定发包的的间隔时间</li></ul><p>用常用网站测试一下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-0-3-centos ~]<span class="comment"># ping -c 5 -i 2 www.baidu.com</span></span><br><span class="line">PING www.a.shifen.com (110.242.68.3) 56(84) bytes of data.</span><br><span class="line">64 bytes from 110.242.68.3 (110.242.68.3): icmp_seq=1 ttl=251 time=10.3 ms</span><br><span class="line">64 bytes from 110.242.68.3 (110.242.68.3): icmp_seq=2 ttl=251 time=10.2 ms</span><br><span class="line">64 bytes from 110.242.68.3 (110.242.68.3): icmp_seq=3 ttl=251 time=10.2 ms</span><br><span class="line">64 bytes from 110.242.68.3 (110.242.68.3): icmp_seq=4 ttl=251 time=10.2 ms</span><br><span class="line">64 bytes from 110.242.68.3 (110.242.68.3): icmp_seq=5 ttl=251 time=10.2 ms</span><br><span class="line"></span><br><span class="line">--- www.a.shifen.com ping statistics ---</span><br><span class="line">5 packets transmitted, 5 received, 0% packet loss, time 8007ms</span><br><span class="line">rtt min/avg/max/mdev = 10.217/10.243/10.311/0.132 ms</span><br></pre></td></tr></table></figure><p>测试信息的含义：</p><table><thead><tr><th style="text-align:left">数据</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td style="text-align:left">-c 5</td><td style="text-align:left">发送5个测试包</td></tr><tr><td style="text-align:left">-i 2</td><td style="text-align:left">每个测试包发送间隔2s</td></tr><tr><td style="text-align:left">www.baidu.com</td><td style="text-align:left">指定的目标地址</td></tr><tr><td style="text-align:left">www.a.shifen.com (110.242.68.3)</td><td style="text-align:left">实际的目标主机的主机名和IP地址</td></tr><tr><td style="text-align:left">56(84) bytes</td><td style="text-align:left">ICMP数据部分的大小56字节，加上8字节的ICMP头，则ICMP包大小为64字节，再加上20字节的IP头，IP包大小为84字节</td></tr><tr><td style="text-align:left">64 bytes</td><td style="text-align:left">ICMP数据包大小</td></tr><tr><td style="text-align:left">icmp_seq=1</td><td style="text-align:left">ICMP包序号</td></tr><tr><td style="text-align:left">ttl=251</td><td style="text-align:left">剩余生存时间，生存时间是指数据包被路由器丢弃之前允许通过的网段数量，由发送主机设置的，以防止数据包在互联网络上永不终止的循环，每经过一个路由器至少将TTL减 1</td></tr><tr><td style="text-align:left">time=10.3 ms</td><td style="text-align:left">响应时间，这个时间越小，连接速度越快</td></tr><tr><td style="text-align:left">— www.a.shifen.com ping statistics —</td><td style="text-align:left">统计信息分割线，以下为统计信息</td></tr><tr><td style="text-align:left">5 packets transmitted</td><td style="text-align:left">发送数据包的数量</td></tr><tr><td style="text-align:left">5 received</td><td style="text-align:left">接收到的数据包的数量</td></tr><tr><td style="text-align:left">0% packet loss</td><td style="text-align:left">数据包的丢失率</td></tr><tr><td style="text-align:left">time 8007ms</td><td style="text-align:left">整个过程消耗的总时间</td></tr><tr><td style="text-align:left">rtt min/avg/max/mdev = 10.217/10.243/10.311/0.132 ms</td><td style="text-align:left">最小响应时间/平均响应时间/最大响应时间/响应时间的平均差</td></tr></tbody></table><p>ping 命令全称 Packe InterNet Groper， 翻译为因特网包探索器，是一个用于测试网络连接状况的程序。该令会使用ICMP（Internet Control Message Protocol）传输协议，向特定的目标主机发出要求回应的信息，若远端主机的网络功能没有问题，就会回应该信息，因而得知该主机运作正常。</p><p>ICMP协议是IP层的附属协议，是介于IP层和TCP层之间的协议，一般认为属于IP层协议，也就是网络层协议。ICMP用于在IP主机、路由器之间传递控制消息。控制消息是指网络通不通、主机是否可达、路由是否可用等网络本身的消息。这些控制消息虽然并不传输用户数据，但是对于用户数据的传递起着重要的作用。</p><blockquote><p>注意：在Windows命令行中执行ping命令，默认只发送4个数据包就停止，这个行为和Linux环境下是不同的</p></blockquote><h2 id="telnet"><a href="#telnet" class="headerlink" title="telnet"></a>telnet</h2><p>telnet是电信(telecommunications)和网络(networks)的联合缩写，是Internet远程登陆服务的标准协议，为用户提供了在本地计算机上完成远程主机工作的能力。在终端使用者的电脑上使用telnet程序，可以连接到服务器，直接在telnet程序中输入命令，这些命令会在服务器上运行，就像直接在服务器的控制台上输入一样，进而可以在本地就能控制远端的服务器。</p><p>telnet位于OSI模型的第7层，属于应用层上的一种协议，使用端口23，底层基于TCP协议。传输的数据和口令是明文形式，相对来说不安全，存在很大的安全隐患，不再用于通过公共网络访问网络设备和服务器。</p><p>现在使用更加安全的ssh代替telnet进行远程管理终端，ssh传输方式是以加密形式传输，并且功能比telnet更齐全，而telnet主要作用变成了查看某个端口是否可访问，常用命令格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">telnet IP或域名 端口</span><br></pre></td></tr></table></figure><p>测试一下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-0-3-centos ~]<span class="comment"># telnet www.baidu.com 80</span></span><br><span class="line">Trying 110.242.68.4...</span><br><span class="line">Connected to www.baidu.com.</span><br><span class="line">Escape character is <span class="string">'^]'</span>.</span><br><span class="line">^]</span><br><span class="line">telnet&gt; send ?</span><br><span class="line">ao              Send Telnet Abort output</span><br><span class="line">ayt             Send Telnet <span class="string">'Are You There'</span></span><br><span class="line">brk             Send Telnet Break</span><br><span class="line">ec              Send Telnet Erase Character</span><br><span class="line">el              Send Telnet Erase Line</span><br><span class="line">escape          Send current escape character</span><br><span class="line">ga              Send Telnet <span class="string">'Go Ahead'</span> sequence</span><br><span class="line">ip              Send Telnet Interrupt Process</span><br><span class="line">nop             Send Telnet <span class="string">'No operation'</span></span><br><span class="line">eor             Send Telnet <span class="string">'End of Record'</span></span><br><span class="line">abort           Send Telnet <span class="string">'Abort Process'</span></span><br><span class="line">susp            Send Telnet <span class="string">'Suspend Process'</span></span><br><span class="line">eof             Send Telnet End of File Character</span><br><span class="line">synch           Perform Telnet <span class="string">'Synch operation'</span></span><br><span class="line">getstatus       Send request <span class="keyword">for</span> STATUS</span><br><span class="line">?               Display send options</span><br><span class="line">telnet&gt; ?</span><br><span class="line">Commands may be abbreviated.  Commands are:</span><br><span class="line"></span><br><span class="line">close       close current connection</span><br><span class="line"><span class="built_in">logout</span>      forcibly <span class="built_in">logout</span> remote user and close the connection</span><br><span class="line">display     display operating parameters</span><br><span class="line">mode        try to enter line or character mode (<span class="string">'mode ?'</span> <span class="keyword">for</span> more)</span><br><span class="line">open        connect to a site</span><br><span class="line">quit        <span class="built_in">exit</span> telnet</span><br><span class="line">send        transmit special characters (<span class="string">'send ?'</span> <span class="keyword">for</span> more)</span><br><span class="line"><span class="built_in">set</span>         <span class="built_in">set</span> operating parameters (<span class="string">'set ?'</span> <span class="keyword">for</span> more)</span><br><span class="line"><span class="built_in">unset</span>       <span class="built_in">unset</span> operating parameters (<span class="string">'unset ?'</span> <span class="keyword">for</span> more)</span><br><span class="line">status      <span class="built_in">print</span> status information</span><br><span class="line">toggle      toggle operating parameters (<span class="string">'toggle ?'</span> <span class="keyword">for</span> more)</span><br><span class="line">slc         change state of special charaters (<span class="string">'slc ?'</span> <span class="keyword">for</span> more)</span><br><span class="line">z           <span class="built_in">suspend</span> telnet</span><br><span class="line">!           invoke a subshell</span><br><span class="line">environ     change environment variables (<span class="string">'environ ?'</span> <span class="keyword">for</span> more)</span><br><span class="line">?           <span class="built_in">print</span> <span class="built_in">help</span> information</span><br><span class="line">telnet&gt; q</span><br><span class="line">Connection closed.</span><br><span class="line">[root@VM-0-3-centos ~]<span class="comment">#</span></span><br></pre></td></tr></table></figure><p>一般情况下测试80端口是否可用，看到第3行的 <code>Connected to www.baidu.com.</code> 就够了，如果想使用telnet工具发送数据，可以按组合键 <code>Ctrl+]</code>进入输入命令的模式，按字母 <code>q</code> 可以退出。</p><blockquote><p>注意：在Windows环境下如果端口可以连通会显示一个无任何信息的黑框，按组合键 <code>Ctrl+]</code>才会有反应，如果端口不通则会提示超时</p></blockquote><h2 id="nc"><a href="#nc" class="headerlink" title="nc"></a>nc</h2><p>上一小节说过，telnet是基于TCP的应用层协议，所以只能检测TCP端口是否正常，如果想检测一个UDP端口是否可用，使用telnet命令是办不到的，这时候就可以使用 <code>nc</code> 命令来实现，详细的用法可以参考之前的文章<a href="https://blog.csdn.net/albertsh/article/details/121896012" target="_blank" rel="noopener">《网络工具nc的常见功能和用法》</a>，下面只列举一下检查UDP端口的命令参数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:~$ nc -nvuz 82.156.125.169 666</span><br><span class="line">Connection to 82.156.125.169 666 port [udp/*] succeeded!</span><br></pre></td></tr></table></figure><h2 id="traceroute"><a href="#traceroute" class="headerlink" title="traceroute"></a>traceroute</h2><p>traceroute是一个路由跟踪命令，用于追踪数据包在网络上的传输时的全部路径，IPv4是发送的探测包大小是60字节，而IPv6默认是80字节，这个可以通过查询 <code>man</code> 手册来查询。</p><p>通过traceroute我们可以探测出数据从当前计算机到另一台主机是走了什么样网络路径，不过相同的数据包每次由从相同的出发点到相同目的地走的路径可能并相同，但大部分时候所走的路由是一样的，所以可以帮助我们了解网络状况。</p><p>traceroute的原理是利用逐步设置 <code>ttl</code> 参数进行参数，这个参数全称<code>time-to-live</code>, 指当前数据包在网络中存在的是时间，而时间不是我们平常所说的时间，指的是数据包在网络环境中最多可以被中转的次数，每经过一个路由设备就要减1，减到0则说明数据包超时，要给原地址一个包含自身信息的回应。</p><p>既然这样就可以利用 <code>ttl</code> 的特点来探测出路径，先将第一个数据包的 <code>ttl</code> 设置为 1，到达第一个路由设备后 <code>ttl</code> 减为0，返回给发送数据的起始设备，这样我们就找到了网络路径中的第一个点。然后将下一个数据包的 <code>ttl</code> 设置为2，就可以探测出路径上的第二个路由设备，直到找到目的地址，整个探测过程结束。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">traceroute [OPTIONS] IP或域名</span><br></pre></td></tr></table></figure><p>一些常用的选项：</p><ul><li><code>-4</code>：强制使用 IPv4 追踪，默认自动选择</li><li><code>-6</code>：强制使用 IPv6 追踪，默认自动选择</li><li><code>-I</code>：使用 ICMP 回应进行探测</li><li><code>-T</code>：使用 TCP 同步进行探测</li><li><code>-m max_ttl</code>：指定 <code>time-to-live</code> 的最大值，默认是30</li></ul><p>测试如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-0-3-centos ~]<span class="comment"># traceroute www.baidu.com -T</span></span><br><span class="line">traceroute to www.baidu.com (110.242.68.4), 30 hops max, 60 byte packets</span><br><span class="line"> 1  9.61.26.129 (9.61.26.129)  0.464 ms  0.626 ms  0.788 ms</span><br><span class="line"> 2  9.61.119.152 (9.61.119.152)  0.843 ms  1.085 ms  1.282 ms</span><br><span class="line"> 3  * * *</span><br><span class="line"> 4  10.200.44.221 (10.200.44.221)  1.130 ms 10.162.5.252 (10.162.5.252)  1.089 ms 10.200.44.205 (10.200.44.205)  1.385 ms</span><br><span class="line"> 5  61.49.142.157 (61.49.142.157)  2.842 ms 61.49.142.153 (61.49.142.153)  0.923 ms 61.49.142.149 (61.49.142.149)  1.467 ms</span><br><span class="line"> 6  123.126.0.217 (123.126.0.217)  2.031 ms 61.148.7.157 (61.148.7.157)  2.057 ms 202.96.13.5 (202.96.13.5)  5.015 ms</span><br><span class="line"> 7  125.33.186.17 (125.33.186.17)  2.499 ms 124.65.194.161 (124.65.194.161)  6.422 ms 124.65.194.157 (124.65.194.157)  3.125 ms</span><br><span class="line"> 8  * * *</span><br><span class="line"> 9  110.242.66.190 (110.242.66.190)  10.030 ms 110.242.66.166 (110.242.66.166)  10.261 ms 110.242.66.162 (110.242.66.162)  10.751 ms</span><br><span class="line">10  * * *</span><br><span class="line">11  * * *</span><br><span class="line">12  * * *</span><br><span class="line">13  * * *</span><br><span class="line">14  * * 110.242.68.4 (110.242.68.4)  9.245 ms</span><br></pre></td></tr></table></figure><p>从上面的测试结果来看，每一行都是一个记录，每个纪录表示一跳，从我的机器到 <code>www.baidu.com</code> 一共经过了14个设备才到达，不过并不是每次探测的结果都一样，这个是会变化的，可以看到每行有3个以ms为单位时间，是因为该命令每次默认发送3个探测数据包，这3个时间就是网关响应后返回的时间。</p><p>另外在输出信息中部分节点显示 <code>* * *</code>，关于这种现象，我找到几种说法，遇到了需要针对具体情况进行分析：</p><ul><li>设备防火墙封掉了ICMP的返回信息，我们得不到什么相关的数据包返回数据</li><li>由于回送TTL超时信息的时候，CPU生成这个返回包必须被打断，为保证其它工作的正常进行，每隔一秒才会处理traceroute，所以可能会看到中间一路 <code>* * *</code>，但却看得到最后的destination. 这时往往是路由设备CPU太忙或者中间路由器不回送TTL超时包的原因（感觉不太靠谱）。</li><li>虚拟机nat路由器，默认丢弃port&gt;32767的包，导致看不到中间路由的信息</li></ul><blockquote><p>注意：在Windows环境下，相同功能的命令为Tracert，而不是traceroute</p></blockquote><h2 id="tcpdump"><a href="#tcpdump" class="headerlink" title="tcpdump"></a>tcpdump</h2><p>tcpdump命令是一个网络嗅探，它可以打印所有经过该设备网卡的数据包的信息，也可以使用-w选项将数据包保存到文件中，方便以后分析，功能与Windows平台上的Wiresh相同，生成的数据文件也可以传送到Windows平台，使用 Wireshark 软件进行分析。</p><p>命令格式非常简单，必要时加一些参数就可以：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump [OPTIONS]</span><br></pre></td></tr></table></figure><p>一些常用的选项：</p><ul><li><code>-c count</code>：接受count个数据包之后退出</li><li><code>-i</code>：指定网卡</li><li><code>-v</code>：打印较详细的信息用于分析</li><li><code>-w</code>：结果写到文件之中</li><li><code>tcp</code>：过滤出tcp数据</li><li><code>port xxxx</code>：仅打印指定端口的数据</li></ul><p>测试一下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-0-3-centos ~]<span class="comment"># tcpdump -c 6 -v</span></span><br><span class="line">tcpdump: listening on eth0, link-type EN10MB (Ethernet), capture size 262144 bytes</span><br><span class="line">10:30:45.344349 IP (tos 0x10, ttl 64, id 47149, offset 0, flags [DF], proto TCP (6), length 188)</span><br><span class="line">    VM-0-3-centos.ssh &gt; 68.128.126.124.broad.bjtelecom.net.6183: Flags [P.], cksum 0x9127 (correct), seq 14744777:14744925, ack 1170924064, win 340, length 148</span><br><span class="line">10:30:45.344782 IP (tos 0x0, ttl 64, id 39263, offset 0, flags [DF], proto UDP (17), length 73)</span><br><span class="line">    VM-0-3-centos.35281 &gt; 183.60.83.19.domain: 48669+ PTR? 68.128.126.124.in-addr.arpa. (45)</span><br><span class="line">10:30:45.344826 IP (tos 0x10, ttl 64, id 47150, offset 0, flags [DF], proto TCP (6), length 188)</span><br><span class="line">    VM-0-3-centos.ssh &gt; 68.128.126.124.broad.bjtelecom.net.6183: Flags [P.], cksum 0x5e8b (correct), seq 148:296, ack 1, win 340, length 148</span><br><span class="line">10:30:45.353844 IP (tos 0xa0, ttl 251, id 62658, offset 0, flags [DF], proto TCP (6), length 40)</span><br><span class="line">    68.128.126.124.broad.bjtelecom.net.6183 &gt; VM-0-3-centos.ssh: Flags [.], cksum 0x6909 (correct), ack 296, win 258, length 0</span><br><span class="line">10:30:45.424218 IP (tos 0x0, ttl 56, id 9062, offset 0, flags [DF], proto UDP (17), length 121)</span><br><span class="line">    183.60.83.19.domain &gt; VM-0-3-centos.35281: 48669 1/0/0 68.128.126.124.in-addr.arpa. PTR 68.128.126.124.broad.bjtelecom.net. (93)</span><br><span class="line">10:30:45.424327 IP (tos 0x0, ttl 64, id 17697, offset 0, flags [DF], proto UDP (17), length 68)</span><br><span class="line">    VM-0-3-centos.40741 &gt; 183.60.82.98.domain: 15078+ PTR? 3.0.10.10.in-addr.arpa. (40)</span><br><span class="line">6 packets captured</span><br><span class="line">13 packets received by filter</span><br><span class="line">0 packets dropped by kernel</span><br></pre></td></tr></table></figure><p>因为不能一直盯着某个设备的网络情况，所以会将数据打印到文件中便于日后分析，常常将tcpdump命令后台运行，比如可以写成下面这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup tcpdump -i eth0 tcp port 8080 -v -w dm8080.cap &amp;</span><br></pre></td></tr></table></figure><blockquote><p>在Windows平台一般就直接使用Wiresh软件啦，非常方便</p></blockquote><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>设备一旦接入网络很难“独善其身”</li><li><code>ping</code> 命令可以测试目的IP是否可达 <code>ping www.baidu.com</code></li><li><code>telnet</code> 命令可以测试指定的tcp端口是否可达 <code>telnet 110.242.68.4 80</code></li><li><code>nc</code> 命令可以测试指定udp端口是否可达 <code>nc -nvuz 110.242.68.4 666</code></li><li><code>tracerout</code> 命令可以探测网络路径 <code>traceroute www.baidu.com</code></li><li><code>tcpdump</code> 命令可以收集所有经过网卡的数据包 <code>tcpdump -i eth0 tcp port 8080 -v</code></li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/124562399" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>“王侯将相，宁有种乎？”讲的是权利；<br>“天下兴亡，匹夫有责！”说的是义务；<br>权力和义务的辩证关系体现于此，二者统一，不可分离~</p><p>2022-5-13 20:59:38</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;因特网(Internet)的前身是美国国防部高级研究计划局(ARPA)用于军事目的的通信网络，真的就是一个内部的工具出圈成了改变世界的事物。网这个词用的很形象也很贴切，如今的世界任何事情都离不开这个大网了，特别是之前炒的非常火爆的万物互联概念，更是把所有事物都挂在了“网”上，虽然这张大网某些节点偶尔会不太通畅，但这并不能阻断消息的往来。之前都在讲全球化，谁能想到短短几年“逆全球化”居然越来越热。&lt;/p&gt;
    
    </summary>
    
      <category term="linux" scheme="http://AlbertGithubHome.github.io/blog/categories/linux/"/>
    
    
      <category term="网络" scheme="http://AlbertGithubHome.github.io/blog/tags/%E7%BD%91%E7%BB%9C/"/>
    
      <category term="ping" scheme="http://AlbertGithubHome.github.io/blog/tags/ping/"/>
    
      <category term="telnet" scheme="http://AlbertGithubHome.github.io/blog/tags/telnet/"/>
    
      <category term="traceroute" scheme="http://AlbertGithubHome.github.io/blog/tags/traceroute/"/>
    
      <category term="tcpdump" scheme="http://AlbertGithubHome.github.io/blog/tags/tcpdump/"/>
    
  </entry>
  
  <entry>
    <title>C++11新式洗牌std::shuffle与老式洗牌函数std::random_shuffle的区别</title>
    <link href="http://AlbertGithubHome.github.io/blog/2022/05/03/C-11%E6%96%B0%E5%BC%8F%E6%B4%97%E7%89%8Cstd-shuffle%E4%B8%8E%E8%80%81%E5%BC%8F%E6%B4%97%E7%89%8C%E5%87%BD%E6%95%B0std-random-shuffle%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://AlbertGithubHome.github.io/blog/2022/05/03/C-11新式洗牌std-shuffle与老式洗牌函数std-random-shuffle的区别/</id>
    <published>2022-05-03T04:14:45.000Z</published>
    <updated>2022-05-03T14:31:38.760Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>洗牌算法是项目开发中常用的一种算法，它和随机数有着密不可分的关系，比如我们从报名参与活动的前10个用户中选取一个人发放幸运奖，这时可以从[1, 10] 范围内随机一个数来确定幸运儿；如果是抽取两个人呢？那就随机两次！是的，确实可以这样做，但是随着随机次数的增多，后面随机的数字很可能和前面一样，这时就要重复随机才能解决。</p><a id="more"></a><p>想想现实生活中我们可以怎么做，取红桃A-红桃10一共10张扑克牌，然后把它们随机洗一洗牌，如果需要取3个幸运儿，那么只需取扑克牌的前三张就可以了，这样很容易就取到了不重复的3个数字，当然你从中间随机抽取也是可以的，这样操作在逻辑实现上要复杂一点点。</p><h1 id="洗牌算法"><a href="#洗牌算法" class="headerlink" title="洗牌算法"></a>洗牌算法</h1><p>其实洗牌利用的是一个排列的概念，学过排列组合的知识以后我们很清楚，n个元素排列的种类数一共是:</p><p>$$<br>A^n_n<br>$$</p><p>也就是n!，这是个恐怖的数字，比如打印N个数字的全排列，它的是时间复杂度就是O(N!)，这个谁也没办法优化，因为打印这些排列情况就需要O(N!)这么多的时间，而洗牌就是保证从这些元素组成的全排列中等概率的选取一种排列。</p><p>把所有的排列情况列举出来，然后从中选择一个所需时间是O(N!)，这显然是不现实的，所以很多大神们进行了优化，出现了多种洗牌算法，下面我只列举一种比较好理解的 <code>Knuth-Durstenfeld Shuffle</code> 算法。</p><p>改洗牌算法可简单表述为：一个拥有n个元素的初始序列，将最后一个数和该序列的前 <code>n</code> 个数中的随机一个数进行交换（如果随机结果是和第n个数交换，相当于没换），然后倒数第二个数和该序列的前 <code>n - 1</code> 个数中的随机一个数进行交换，以此类推，直到将该序列第一个数操作完，就完成了洗牌，该算法保证了每个元素在每个位置的概率都是相等的，时间复杂度为O(N)。</p><p>举个例子就像下面这样：</p><p>初始序列是 <code>A</code>、<code>B</code>、<code>C</code>、<code>D</code>、<code>E</code>、<code>F</code>，为了便于和刚才的算法思路对应描述，索引从1开始</p><p>第一轮从1-6个位置中随机一个和最后的 <code>F</code> 交换，假如随机到位置3，也就是和 <code>C</code> 交换，结果为：</p><blockquote><p>A B F D E C</p></blockquote><p>概率是P=1/6，也就是随机一个数字的概率</p><p>第二轮从1-5个位置中随机一个和倒数第二个元素 <code>E</code> 交换，假如随机到的是位置2，也就是和 <code>B</code> 交换，结果为：</p><blockquote><p>A E F D B C</p></blockquote><p>概率是P=(5/6)*(1/5)=1/6，为什么这么算呢？要想和 <code>B</code> 交换必须第一轮随机不到<code>B</code>才可以，所以要在前面乘以 5/6</p><p>第三轮从1-2个位置中随机一个和倒数第二个元素 <code>D</code> 交换，假如随机到的还是位置2，也就是和 <code>E</code> 交换，结果为</p><blockquote><p>A D F E B C</p></blockquote><p>概率是P=(5/6)*(4/5)*(1/4)=1/6，有了第二轮这个就应该明白了吧</p><p>依次类推，直到操作完第五次随机交换，整个洗牌算法也就完成了，伪代码也就几行</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = vec.size() - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::swap(vec[i], vec[<span class="built_in">std</span>::rand() % (i + <span class="number">1</span>)]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="std-random-shuffle"><a href="#std-random-shuffle" class="headerlink" title="std::random_shuffle"></a>std::random_shuffle</h1><p>使用这个函数需要引用头文件 <code>&lt;algorithm&gt;</code>，共有以下几个重载函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt; <span class="class"><span class="keyword">class</span> <span class="title">RandomIt</span> &gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">random_shuffle</span>( <span class="title">RandomIt</span> <span class="title">first</span>, <span class="title">RandomIt</span> <span class="title">last</span> );</span> <span class="comment">//(deprecated in C++14)(removed in C++17)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt; <span class="class"><span class="keyword">class</span> <span class="title">RandomIt</span>, <span class="title">class</span> <span class="title">RandomFunc</span> &gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">random_shuffle</span>( <span class="title">RandomIt</span> <span class="title">first</span>, <span class="title">RandomIt</span> <span class="title">last</span>, <span class="title">RandomFunc</span>&amp; <span class="title">r</span> );</span>  <span class="comment">//(until C++11)</span></span><br><span class="line">                                            <span class="comment">//(deprecated in C++14)(removed in C++17)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt; <span class="class"><span class="keyword">class</span> <span class="title">RandomIt</span>, <span class="title">class</span> <span class="title">RandomFunc</span> &gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">random_shuffle</span>( <span class="title">RandomIt</span> <span class="title">first</span>, <span class="title">RandomIt</span> <span class="title">last</span>, <span class="title">RandomFunc</span>&amp;&amp; <span class="title">r</span> );</span> <span class="comment">//(since C++11)</span></span><br><span class="line">                                            <span class="comment">//(deprecated in C++14)(removed in C++17)</span></span><br></pre></td></tr></table></figure><p>从文档来看 <code>std::random_shuffle</code> 这个函数的实现在C++14标准中已经不推荐使用，在C++17中已经被移除了，函数定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   *  @brief Randomly shuffle the elements of a sequence.</span></span><br><span class="line"><span class="comment">   *  @ingroup mutating_algorithms</span></span><br><span class="line"><span class="comment">   *  @param  __first   A forward iterator.</span></span><br><span class="line"><span class="comment">   *  @param  __last    A forward iterator.</span></span><br><span class="line"><span class="comment">   *  @return  Nothing.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   *  Reorder the elements in the range @p [__first,__last) using a random</span></span><br><span class="line"><span class="comment">   *  distribution, so that every possible ordering of the sequence is</span></span><br><span class="line"><span class="comment">   *  equally likely.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _RandomAccessIterator&gt;</span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">void</span></span><br><span class="line">    random_shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// concept requirements</span></span><br><span class="line">      __glibcxx_function_requires(_Mutable_RandomAccessIteratorConcept&lt;</span><br><span class="line">        _RandomAccessIterator&gt;)</span><br><span class="line">      __glibcxx_requires_valid_range(__first, __last);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (__first != __last)</span><br><span class="line">      <span class="keyword">for</span> (_RandomAccessIterator __i = __first + <span class="number">1</span>; __i != __last; ++__i)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">// XXX rand() % N is not uniformly distributed</span></span><br><span class="line">        _RandomAccessIterator __j = __first</span><br><span class="line">                    + <span class="built_in">std</span>::rand() % ((__i - __first) + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (__i != __j)</span><br><span class="line">          <span class="built_in">std</span>::iter_swap(__i, __j);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   *  @brief Shuffle the elements of a sequence using a random number</span></span><br><span class="line"><span class="comment">   *         generator.</span></span><br><span class="line"><span class="comment">   *  @ingroup mutating_algorithms</span></span><br><span class="line"><span class="comment">   *  @param  __first   A forward iterator.</span></span><br><span class="line"><span class="comment">   *  @param  __last    A forward iterator.</span></span><br><span class="line"><span class="comment">   *  @param  __rand    The RNG functor or function.</span></span><br><span class="line"><span class="comment">   *  @return  Nothing.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   *  Reorders the elements in the range @p [__first,__last) using @p __rand to</span></span><br><span class="line"><span class="comment">   *  provide a random distribution. Calling @p __rand(N) for a positive</span></span><br><span class="line"><span class="comment">   *  integer @p N should return a randomly chosen integer from the</span></span><br><span class="line"><span class="comment">   *  range [0,N).</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _RandomAccessIterator, <span class="keyword">typename</span> _RandomNumberGenerator&gt;</span><br><span class="line">    <span class="keyword">void</span></span><br><span class="line">    random_shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last,</span><br><span class="line">#<span class="keyword">if</span> __cplusplus &gt;= <span class="number">201103L</span></span><br><span class="line">           _RandomNumberGenerator&amp;&amp; __rand)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">           _RandomNumberGenerator&amp; __rand)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// concept requirements</span></span><br><span class="line">      __glibcxx_function_requires(_Mutable_RandomAccessIteratorConcept&lt;</span><br><span class="line">        _RandomAccessIterator&gt;)</span><br><span class="line">      __glibcxx_requires_valid_range(__first, __last);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (__first == __last)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      <span class="keyword">for</span> (_RandomAccessIterator __i = __first + <span class="number">1</span>; __i != __last; ++__i)</span><br><span class="line">        &#123;</span><br><span class="line">            _RandomAccessIterator __j = __first + __rand((__i - __first) + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (__i != __j)</span><br><span class="line">                <span class="built_in">std</span>::iter_swap(__i, __j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>以上函数实现来源于文件 <code>/usr/include/c++/5/bits/stl_algo.h</code>，看源码时发现一个问题，原来标准库中的代码也是空格和Tab混用，复制过来的时候我还专门整理了一下。</p><p>第一个仅两个参数的函数中首先验证了迭代器的类型和范围的有效性，同时使用了 <code>std::rand()</code> 函数来随机选择了一个需要交换的元素，而拥有三个参数的函数逻辑几乎一样，只是使用了自定义传入的随机函数来选择需要交换的元素，所以洗牌算法的核心逻辑就是这个随机函数。</p><h1 id="rand-和-srand"><a href="#rand-和-srand" class="headerlink" title="rand 和 srand"></a>rand 和 srand</h1><p>这两个是C标准函数，在C++中被放在头文件 <code>&lt;cstdlib&gt;</code> 之中，搜索到的函数声明如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">__BEGIN_NAMESPACE_STD</span><br><span class="line"><span class="comment">/* Return a random integer between 0 and RAND_MAX inclusive.  */</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">rand</span> <span class="params">(<span class="keyword">void</span>)</span> __THROW</span>;</span><br><span class="line"><span class="comment">/* Seed the random number generator with the given number.  */</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">srand</span> <span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> __seed)</span> __THROW</span>;</span><br><span class="line">__END_NAMESPACE_STD</span><br></pre></td></tr></table></figure><p>其中 <code>std::rand()</code> 是用于返回一个介于[0, RAND_MAX] 范围的伪随机整型值，<code>RAND_MAX</code> 的值最小为 32767，也就是有符号short的最大值，我查到的版本库中的值是2147483647，即有符号int的最大值。</p><p><code>std::srand()</code> 的作用是为 <code>st::rand()</code> 这个伪随机数生成器设置种子，如果在调用 <code>std::srand()</code> 之前使用了 <code>std::rand()</code>，种子默认为1，相当于调用了 <code>std::srand(1)</code>，rand通常不是线程安全的函数，依赖于具体的实现。</p><p>另外你可能还见过 <code>random</code> 和 <code>srandom</code> 等函数，他们通常是另一个标准（BSD）的随机函数，比如下面这段描述：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* These are the functions that actually do things.  The `random', `srandom',</span></span><br><span class="line"><span class="comment">   `initstate' and `setstate' functions are those from BSD Unices.</span></span><br><span class="line"><span class="comment">   The `rand' and `srand' functions are required by the ANSI standard.</span></span><br><span class="line"><span class="comment">   We provide both interfaces to the same random number generator.  */</span></span><br><span class="line"><span class="comment">/* Return a random long integer between 0 and RAND_MAX inclusive.  */</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">long</span> <span class="keyword">int</span> <span class="title">random</span> <span class="params">(<span class="keyword">void</span>)</span> __THROW</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Seed the random number generator with the given number.  */</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">srandom</span> <span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> __seed)</span> __THROW</span>;</span><br></pre></td></tr></table></figure><p>如果是在 <code>POSIX</code> 平台你可能还会遇到 <code>rand_r(int *seed)</code> 函数。</p><p>需要注意的是， <code>std::rand()</code> 生成的是一个伪随机序列，如果随机种子相同，则得到的序列也是相同的，这也是 <code>std::rand</code> 不建议使用的原因，建议是使用C++11随机数生成工具来替换它。</p><p>伪随机序列也并不是“一无是处”，两个进程可以通过设置相同的随机数种子来产生相同的序列，比如可以用于服务器和客户端做帧同步时产生随机数，这样的随机数产生是同步可控的。</p><p>下面举个 <code>std::rand()</code> 使用的例子</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::srand(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::rand() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::srand(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::rand() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::srand(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::rand() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:/mnt/d/data/cpp/testrandom$ g++ testrandom.cpp --std=c++11</span><br><span class="line">albert@home-pc:/mnt/d/data/cpp/testrandom$ ./a.out</span><br><span class="line">1804289383</span><br><span class="line">1804289383</span><br><span class="line">1804289383</span><br></pre></td></tr></table></figure><p>我们可以看到因为随机种子相同，生成的随机数都是同一个，为了使的生成的序列更随机，通常使用当前时间戳 <code>std::time(nullptr)</code> 作为随机种子，然后再生成随机序列：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::srand(<span class="built_in">std</span>::time(<span class="literal">nullptr</span>));</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::rand() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::srand(<span class="built_in">std</span>::time(<span class="literal">nullptr</span>));</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::rand() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::srand(<span class="built_in">std</span>::time(<span class="literal">nullptr</span>));</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::rand() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:/mnt/d/data/cpp/testrandom$ g++ testrandom.cpp --std=c++11</span><br><span class="line">albert@home-pc:/mnt/d/data/cpp/testrandom$ ./a.out</span><br><span class="line">1777572541</span><br><span class="line">1777572541</span><br><span class="line">1777572541</span><br></pre></td></tr></table></figure><p>怎么还是相同的呢？那是因为 <code>std::time(nullptr)</code> 函数返回的时间戳单位是秒，在一秒中内的时间种子是相同的，所以返回的序列也是相同的，通常的使用方法是在程序启动时设置一次时间种子就可以了，并不需要每次都进行设置，而 <code>random_shuffle</code> 中使用了 <code>std::rand()</code> 函数，如果不手动设置时间种子，每次同一时间洗同一副牌，得到的结果也是相同的，所以这也是random_shuffle被后续版本移除的一个原因。</p><h1 id="随机数生成器和分布器"><a href="#随机数生成器和分布器" class="headerlink" title="随机数生成器和分布器"></a>随机数生成器和分布器</h1><p>random是C++11提供的一个头文件，其中包含多个随机数生成工具，可以使用生成器和分布器的组合产生随机数，其中包含随机数生成器和分布器的多个类实现，分为以下两种：</p><p>Uniform random bit generators (URBGs)：均匀随机位生成器，也就是生成均匀分布随机数的对象，可以生成伪随机序列，也可生成真正的随机数序列<br>Random number distributions：随机数分布器，用于将URBGs产生的随机数转换为某种特定数学概率分布的序列，如均匀分布、正态分布、泊松分布等</p><p>常见的生成器：</p><ul><li><strong>linear_congruential_engine</strong>: 线性同余生成算法，是最常用也是速度最快的，随机效果一般</li><li><strong>mersenne_twister_engine</strong>: 梅森旋转算法，随机效果最好</li><li><strong>subtract_with_carry_engine</strong>: 滞后Fibonacci算法</li></ul><p>常见的适配器，我理解的它的作用是生成器的二次加工厂，对生成器结果进行特定操作</p><ul><li><strong>discard_block_engine</strong>: 丢弃一些数</li><li><strong>independent_bits_engine</strong>: 将序列打包成指定位数的块</li><li><strong>shuffle_order_engine</strong>: 调整序列顺序</li></ul><p>预定义的随机数生成器，利用通用生成器和适配器组合出的流行特定生成器：</p><ul><li><strong>minstd_rand</strong></li><li><strong>minstd_rand0</strong></li><li><strong>mt19937</strong>: mt是因为这个伪随机数产生器基于Mersenne Twister算法，19937来源于产生随的机数的周期长可达到2^19937-1。</li><li><strong>mt19937_64</strong></li><li><strong>ranlux24_base</strong></li><li><strong>ranlux48_base</strong></li><li><strong>ranlux24</strong></li><li><strong>ranlux48</strong></li><li><strong>knuth_b</strong></li><li><strong>default_random_engine</strong>: 编译器可以自行实现</li></ul><p>以上随机数引擎需要一个整型参数作为种子，对于给定的随机数种子，伪随机数生成器总会生成相同的序列，这在测试的时候是相当有用的。而在实际使用时，需要设置随机树作为种子来产出不同的随机数，推荐使用 <code>std::random_device</code> 的值作为随机数种子。</p><p><code>std::random_device</code> 是一个使用硬件熵源的非确定性随机数发生器，不可预测。</p><p>常见的分布器：</p><ul><li><strong>uniform_int_distribution</strong>: 均匀离散分布</li><li><strong>uniform_real_distribution</strong>: 均匀实数分布</li><li><strong>bernoulli_distribution</strong>: 伯努利分布</li><li><strong>binomial_distribution</strong>: 二项式分布</li><li><strong>geometric_distribution</strong>: 几何分布</li><li><strong>negative_binomial_distribution</strong>: 负二项式分布</li><li><strong>poisson_distribution</strong>: 泊松分布</li><li><strong>exponential_distribution</strong>: 指数分布</li><li><strong>gamma_distribution</strong>: 伽玛分布</li><li><strong>weibull_distribution</strong>: 威布尔分布</li><li><strong>extreme_value_distribution</strong>: 极值分配</li><li><strong>normal_distribution</strong>: 正态分布</li><li><strong>lognormal_distribution</strong>: 对数正态分布</li><li><strong>chi_squared_distribution</strong>: 卡方分布</li><li><strong>cauchy_distribution</strong>: 柯西分布</li><li><strong>fisher_f_distribution</strong>: Fisher F分布</li><li><strong>student_t_distribution</strong>: 学生T分布</li><li><strong>discrete_distribution</strong>: 离散分布</li><li><strong>piecewise_constant_distribution</strong>: 分段常数分布</li><li><strong>piecewise_linear_distribution</strong>: 分段线性分布</li></ul><p>下面举个生成器和分布器组合生成随机常用例子，以下为模拟掷骰子生成点数的实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;random&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::mt19937 gen(std::random_device&#123;&#125;());</span><br><span class="line">    <span class="built_in">std</span>::uniform_int_distribution&lt;&gt; dist(<span class="number">1</span>, <span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; dist(gen) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译运行结果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:/mnt/d/data/cpp/testrandom$ g++ testrandom.cpp --std=c++11</span><br><span class="line">albert@home-pc:/mnt/d/data/cpp/testrandom$ ./a.out</span><br><span class="line">3</span><br><span class="line">2</span><br><span class="line">4</span><br><span class="line">1</span><br><span class="line">5</span><br><span class="line">4</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td></tr></table></figure><h1 id="std-shuffle"><a href="#std-shuffle" class="headerlink" title="std::shuffle"></a>std::shuffle</h1><p>终于又转回来了，去随机数那一块儿溜了半天，终于回到了洗牌函数，这个函数是C++11版本才加入的，函数定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  @brief Shuffle the elements of a sequence using a uniform random</span></span><br><span class="line"><span class="comment"> *         number generator.</span></span><br><span class="line"><span class="comment"> *  @ingroup mutating_algorithms</span></span><br><span class="line"><span class="comment"> *  @param  __first   A forward iterator.</span></span><br><span class="line"><span class="comment"> *  @param  __last    A forward iterator.</span></span><br><span class="line"><span class="comment"> *  @param  __g       A UniformRandomNumberGenerator (26.5.1.3).</span></span><br><span class="line"><span class="comment"> *  @return  Nothing.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  Reorders the elements in the range @p [__first,__last) using @p __g to</span></span><br><span class="line"><span class="comment"> *  provide random numbers.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _RandomAccessIterator,</span><br><span class="line">     <span class="keyword">typename</span> _UniformRandomNumberGenerator&gt;</span><br><span class="line">  <span class="keyword">void</span></span><br><span class="line">  shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last,</span><br><span class="line">      _UniformRandomNumberGenerator&amp;&amp; __g)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// concept requirements</span></span><br><span class="line">    __glibcxx_function_requires(_Mutable_RandomAccessIteratorConcept&lt;</span><br><span class="line">      _RandomAccessIterator&gt;)</span><br><span class="line">    __glibcxx_requires_valid_range(__first, __last);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (__first == __last)</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> iterator_traits&lt;_RandomAccessIterator&gt;::difference_type</span><br><span class="line">  _DistanceType;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> <span class="built_in">std</span>::make_unsigned&lt;_DistanceType&gt;::type __ud_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> <span class="built_in">std</span>::uniform_int_distribution&lt;__ud_type&gt; __distr_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> __distr_type::param_type __p_type;</span><br><span class="line">    __distr_type __d;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (_RandomAccessIterator __i = __first + <span class="number">1</span>; __i != __last; ++__i)</span><br><span class="line">  <span class="built_in">std</span>::iter_swap(__i, __first + __d(__g, __p_type(<span class="number">0</span>, __i - __first)));</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>这种实现和之前 <code>std::random_shuffle</code> 函数实现很类似，只是随机数部分有些不同，它的第3个参数需要的是一个均匀随机数生成器URBGs，一个常见的使用方法如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;random&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line"></span><br><span class="line">    std::mt19937 gen(std::random_device&#123;&#125;());</span><br><span class="line">    <span class="built_in">std</span>::shuffle(vec.begin(), vec.end(), gen);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::copy(vec.begin(), vec.end(), <span class="built_in">std</span>::ostream_iterator&lt;<span class="keyword">int</span>&gt;(<span class="built_in">std</span>::<span class="built_in">cout</span>, <span class="string">" "</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译后运行结果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:/mnt/d/data/cpp/testrandom$ g++ testrandom.cpp --std=c++11</span><br><span class="line">albert@home-pc:/mnt/d/data/cpp/testrandom$ ./a.out</span><br><span class="line">3 5 1 2 6 4</span><br></pre></td></tr></table></figure><h1 id="randint"><a href="#randint" class="headerlink" title="randint"></a>randint</h1><p>结尾了顺便说一下偶然看到的一个实验性函数 <code>std::experimental::randint</code>，用于生成指定范围内的一个随机数，目前还没有进入标准，不过看起来使用很方便了，后续有可能被纳入标准吧，贴一下 cppreference 上的例子 <a href="https://en.cppreference.com/w/cpp/experimental/randint" target="_blank" rel="noopener">std::experimental::randint</a> 如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;experimental/random&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> random_number = <span class="built_in">std</span>::experimental::randint(<span class="number">100</span>, <span class="number">999</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"random 3-digit number: "</span> &lt;&lt; random_number &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li><code>std::random_shuffle</code> 可以只传递一个待洗牌的区间，函数内会使用默认的 <code>std::rand</code> 函数来完成随机元素的选择，依赖全局状态</li><li><code>std::random_shuffle</code> 也可以传入自定义的随机函数，不过这个函数在C++14表中已经不建议时使用了，在C++17标准中已经被移除</li><li><code>std::shuffle</code> 是C++11标准添加的，也是推荐使用的洗牌函数，它的第三个参数需要传递一个均匀随机数生成器对象</li><li>C++11中的<code>&lt;random&gt;</code>头文件中提供了很多生成随机数的工具，需要搭配生成器和分布器来使用</li><li><code>mt19937</code> 名字看起来有点怪，但它是常用的生成器，mt表示它基于Mersenne Twister算法，19937源于产生随的机数的周期长可达到2^19937-1</li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/124534579" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>当被误解时，解释或者争论都是没有用的，有些事情就解释不清楚，或者根本无法解释，甚至没有人会听你解释，想一想，真的什么也做不了，就像一句名言说的，你永远叫不醒一个装睡的人，那个故意误解你的人又怎会听你解释~</p><p>2022-5-3 21:02:56</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;洗牌算法是项目开发中常用的一种算法，它和随机数有着密不可分的关系，比如我们从报名参与活动的前10个用户中选取一个人发放幸运奖，这时可以从[1, 10] 范围内随机一个数来确定幸运儿；如果是抽取两个人呢？那就随机两次！是的，确实可以这样做，但是随着随机次数的增多，后面随机的数字很可能和前面一样，这时就要重复随机才能解决。&lt;/p&gt;
    
    </summary>
    
      <category term="C/C++" scheme="http://AlbertGithubHome.github.io/blog/categories/C-C/"/>
    
    
      <category term="C/C++" scheme="http://AlbertGithubHome.github.io/blog/tags/C-C/"/>
    
      <category term="shuffle" scheme="http://AlbertGithubHome.github.io/blog/tags/shuffle/"/>
    
      <category term="洗牌" scheme="http://AlbertGithubHome.github.io/blog/tags/%E6%B4%97%E7%89%8C/"/>
    
      <category term="随机数" scheme="http://AlbertGithubHome.github.io/blog/tags/%E9%9A%8F%E6%9C%BA%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>恶搞一下std::forward函数</title>
    <link href="http://AlbertGithubHome.github.io/blog/2022/04/20/%E6%81%B6%E6%90%9E%E4%B8%80%E4%B8%8Bstd-forward%E5%87%BD%E6%95%B0/"/>
    <id>http://AlbertGithubHome.github.io/blog/2022/04/20/恶搞一下std-forward函数/</id>
    <published>2022-04-20T14:12:10.000Z</published>
    <updated>2022-05-01T14:58:23.068Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>关于 <code>std::forward</code> 的用法在之前的文章 <a href="https://blog.csdn.net/albertsh/article/details/118886009" target="_blank" rel="noopener">《C++11中std::move和std::forward到底干了啥》</a>已经总结过了，它被称为完美转发函数，用于函数模板中完成参数转发任务，当形参为左值引用时把它转发成左值，而在形参成为右值引用时把它转发成右值，依靠了引用折叠规则和 <code>std::remove_reference</code> 模板。<br><a id="more"></a></p><p>前段时间看到<code>std::forward</code>的源代码时突然有发现有些疑问，后来弄明白了决定换个花样试一试，不过在“恶搞”这个函数之前，先来看一看使用模板的规则，我们以模板函数为例，看看模板是怎么用的。</p><h1 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">T</span> <span class="title">Add</span>(<span class="title">T</span> <span class="title">a</span>, <span class="title">T</span> <span class="title">b</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一个非常简单的模板函数，直接传入参数就可以调用这个函数做加法运算，就像下面这样：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">T</span> <span class="title">Add</span>(<span class="title">T</span> <span class="title">a</span>, <span class="title">T</span> <span class="title">b</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; Add(<span class="number">2020</span>, <span class="number">2</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; Add(<span class="number">3.0</span>, <span class="number">2.1</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; Add(<span class="built_in">std</span>::<span class="built_in">string</span>(<span class="string">"happy"</span>), <span class="built_in">std</span>::<span class="built_in">string</span>(<span class="string">" holiday"</span>)) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数的运行结果如下：</p><blockquote><p>2022<br>5.1<br>happyholiday</p></blockquote><p>我们在调用模板函数时虽然没有指定模板 <code>T</code> 的类型，但是编译器会自动推导，分别生成以下三个函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Add</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">Add</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> a, <span class="built_in">std</span>::<span class="built_in">string</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是当我们采用以下的方式调用函数的时候就会出现编译错误</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; Add(<span class="number">3</span>, <span class="number">2.1</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:/mnt/d/data/cpp/testtemplate$ g++ testt.cpp --std=c++11</span><br><span class="line">testt.cpp: In <span class="keyword">function</span> ‘int main()’:</span><br><span class="line">testt.cpp:13:28: error: no matching <span class="keyword">function</span> <span class="keyword">for</span> call to ‘Add(int, double)’</span><br><span class="line">     std::cout &lt;&lt; Add(3, 2.1) &lt;&lt; std::endl;</span><br><span class="line">                            ^</span><br><span class="line">testt.cpp:5:3: note: candidate: template&lt;class T&gt; T Add(T, T)</span><br><span class="line"> T Add(T a, T b)</span><br><span class="line">   ^</span><br><span class="line">testt.cpp:5:3: note:   template argument deduction/substitution failed:</span><br><span class="line">testt.cpp:13:28: note:   deduced conflicting types <span class="keyword">for</span> parameter ‘T’ (‘int’ and ‘double’)</span><br><span class="line">     std::cout &lt;&lt; Add(3, 2.1) &lt;&lt; std::endl;</span><br><span class="line">                            ^</span><br></pre></td></tr></table></figure><p>编译器给出的错误很明显，那就是没有匹配 <code>Add(int, double)</code> 的函数生成，这个模板只提供了一个类型参数，遇到这种情况应该怎么办呢？我们知道 int 可以隐式转换成 double 类型，那就让它默认生成一个类型为 double 的模板函数 <code>Add(int, double)</code> 就可以了，所以这种情况下把调用函数写成下面这样就可以成功编译了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; Add&lt;<span class="keyword">double</span>&gt;(<span class="number">3</span>, <span class="number">2.1</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>通过这个例子我们发现有些情况下，这个模板函数的参数类型必须显式传递，接下来我们再来熟悉一下 <code>std::forward</code> 函数。</p><h1 id="forwawrd-函数定义"><a href="#forwawrd-函数定义" class="headerlink" title="forwawrd 函数定义"></a>forwawrd 函数定义</h1><p>先来复习一下函数的定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  @brief  Forward an lvalue.</span></span><br><span class="line"><span class="comment"> *  @return The parameter cast to the specified type.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  This function is used to implement "perfect forwarding".</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line">  <span class="keyword">constexpr</span> _Tp&amp;&amp;</span><br><span class="line">  forward(<span class="keyword">typename</span> <span class="built_in">std</span>::remove_reference&lt;_Tp&gt;::type&amp; <span class="keyword">__t</span>) <span class="keyword">noexcept</span></span><br><span class="line">  &#123; <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;_Tp&amp;&amp;&gt;(<span class="keyword">__t</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  @brief  Forward an rvalue.</span></span><br><span class="line"><span class="comment"> *  @return The parameter cast to the specified type.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  This function is used to implement "perfect forwarding".</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line">  <span class="keyword">constexpr</span> _Tp&amp;&amp;</span><br><span class="line">  forward(<span class="keyword">typename</span> <span class="built_in">std</span>::remove_reference&lt;_Tp&gt;::type&amp;&amp; <span class="keyword">__t</span>) <span class="keyword">noexcept</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">static_assert</span>(!<span class="built_in">std</span>::is_lvalue_reference&lt;_Tp&gt;::value, <span class="string">"template argument"</span></span><br><span class="line">          <span class="string">" substituting _Tp is an lvalue reference type"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;_Tp&amp;&amp;&gt;(<span class="keyword">__t</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>以上两个模板函数就是用来实现完美转发左值引用和右值引用的，那么你可以试试，当调用第一个函数的时候能不能推导出 <code>_Tp</code> 是什么类型，我之前的疑惑也在这里，这个函数的参数 <code>typename std::remove_reference&lt;_Tp&gt;::type&amp; __t</code> 和模板参数类型 <code>_Tp</code> 看起来关系很密切，但好像又没关系，因为虽然知道参数类型 <code>typename std::remove_reference&lt;_Tp&gt;::type&amp; __t</code> 是个左值引用，但是你并不知道 <code>_Tp</code> 是什么类型，它还是需要显式来指定的，我们接下来试一试和我们想的一不一样。</p><h1 id="forwawrd-完美转发"><a href="#forwawrd-完美转发" class="headerlink" title="forwawrd 完美转发"></a>forwawrd 完美转发</h1><p>直接拿一个之前写过的完美转发例子吧，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">(<span class="keyword">int</span>&amp; val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"lvalue refrence: val="</span> &lt;&lt; val &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">(<span class="keyword">int</span>&amp;&amp; val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"rvalue refrence: val="</span> &lt;&lt; val &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TPrint</span><span class="params">(T&amp;&amp; t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Print(<span class="built_in">std</span>::forward&lt;T&gt;(t));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> date = <span class="number">2022</span>;</span><br><span class="line">    TPrint(date);</span><br><span class="line">    TPrint(<span class="number">501</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译运行之后的结果如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:/mnt/d/data/cpp/testtemplate$ g++ testf.cpp --std=c++11</span><br><span class="line">albert@home-pc:/mnt/d/data/cpp/testtemplate$ ./a.out</span><br><span class="line">lvalue refrence: val=2022</span><br><span class="line">rvalue refrence: val=501</span><br></pre></td></tr></table></figure><p>通过结果我们发现 <code>std::forward</code> 函数在拥有万能引用参数的模板函数中实现了完美转发，左值转发后调用了参数为左值引用的函数，右值转发后调用了参数为右值引用的函数，这时如果我们把调用 <code>std::forward</code> 的地方改一下，去掉指定的参数类型 <code>T</code>，写成 <code>return Print(std::forward(t));</code>，然后编译看看会发生什么</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:/mnt/d/data/cpp/testtemplate$ g++ testf.cpp --std=c++11</span><br><span class="line">testf.cpp: In instantiation of ‘void TPrint(T&amp;&amp;) [with T = int&amp;]’:</span><br><span class="line">testf.cpp:23:16:   required from here</span><br><span class="line">testf.cpp:17:30: error: no matching <span class="keyword">function</span> <span class="keyword">for</span> call to ‘forward(int&amp;)’</span><br><span class="line">     <span class="built_in">return</span> Print(std::forward(t));</span><br><span class="line">                              ^</span><br><span class="line">In file included from /usr/include/c++/5/bits/stl_pair.h:59:0,</span><br><span class="line">                 from /usr/include/c++/5/bits/stl_algobase.h:64,</span><br><span class="line">                 from /usr/include/c++/5/bits/char_traits.h:39,</span><br><span class="line">                 from /usr/include/c++/5/ios:40,</span><br><span class="line">                 from /usr/include/c++/5/ostream:38,</span><br><span class="line">                 from /usr/include/c++/5/iostream:39,</span><br><span class="line">                 from testf.cpp:1:</span><br><span class="line">/usr/include/c++/5/bits/move.h:76:5: note: candidate: template&lt;class _Tp&gt; constexpr _Tp&amp;&amp; std::forward(typename std::remove_reference&lt;_From&gt;::<span class="built_in">type</span>&amp;)</span><br><span class="line">     forward(typename std::remove_reference&lt;_Tp&gt;::<span class="built_in">type</span>&amp; __t) noexcept</span><br><span class="line">     ^</span><br><span class="line">/usr/include/c++/5/bits/move.h:76:5: note:   template argument deduction/substitution failed:</span><br><span class="line">testf.cpp:17:30: note:   couldn<span class="string">'t deduce template parameter ‘_Tp’</span></span><br><span class="line"><span class="string">     return Print(std::forward(t));</span></span><br><span class="line"><span class="string">                              ^</span></span><br><span class="line"><span class="string">In file included from /usr/include/c++/5/bits/stl_pair.h:59:0,</span></span><br><span class="line"><span class="string">                 from /usr/include/c++/5/bits/stl_algobase.h:64,</span></span><br><span class="line"><span class="string">                 from /usr/include/c++/5/bits/char_traits.h:39,</span></span><br><span class="line"><span class="string">                 from /usr/include/c++/5/ios:40,</span></span><br><span class="line"><span class="string">                 from /usr/include/c++/5/ostream:38,</span></span><br><span class="line"><span class="string">                 from /usr/include/c++/5/iostream:39,</span></span><br><span class="line"><span class="string">                 from testf.cpp:1:</span></span><br><span class="line"><span class="string">/usr/include/c++/5/bits/move.h:87:5: note: candidate: template&lt;class _Tp&gt; constexpr _Tp&amp;&amp; std::forward(typename std::remove_reference&lt;_From&gt;::type&amp;&amp;)</span></span><br><span class="line"><span class="string">     forward(typename std::remove_reference&lt;_Tp&gt;::type&amp;&amp; __t) noexcept</span></span><br><span class="line"><span class="string">     ^</span></span><br><span class="line"><span class="string">/usr/include/c++/5/bits/move.h:87:5: note:   template argument deduction/substitution failed:</span></span><br><span class="line"><span class="string">testf.cpp:17:30: note:   couldn'</span>t deduce template parameter ‘_Tp’</span><br><span class="line">     <span class="built_in">return</span> Print(std::forward(t));</span><br><span class="line">                              ^</span><br><span class="line">testf.cpp:17:33: error: <span class="built_in">return</span>-statement with a value, <span class="keyword">in</span> <span class="keyword">function</span> returning <span class="string">'void'</span> [-fpermissive]</span><br><span class="line">     <span class="built_in">return</span> Print(std::forward(t));</span><br><span class="line">                                 ^</span><br><span class="line">testf.cpp: In instantiation of ‘void TPrint(T&amp;&amp;) [with T = int]’:</span><br><span class="line">testf.cpp:24:15:   required from here</span><br><span class="line">testf.cpp:17:30: error: no matching <span class="keyword">function</span> <span class="keyword">for</span> call to ‘forward(int&amp;)’</span><br><span class="line">     <span class="built_in">return</span> Print(std::forward(t));</span><br><span class="line">                              ^</span><br><span class="line">In file included from /usr/include/c++/5/bits/stl_pair.h:59:0,</span><br><span class="line">                 from /usr/include/c++/5/bits/stl_algobase.h:64,</span><br><span class="line">                 from /usr/include/c++/5/bits/char_traits.h:39,</span><br><span class="line">                 from /usr/include/c++/5/ios:40,</span><br><span class="line">                 from /usr/include/c++/5/ostream:38,</span><br><span class="line">                 from /usr/include/c++/5/iostream:39,</span><br><span class="line">                 from testf.cpp:1:</span><br><span class="line">/usr/include/c++/5/bits/move.h:76:5: note: candidate: template&lt;class _Tp&gt; constexpr _Tp&amp;&amp; std::forward(typename std::remove_reference&lt;_From&gt;::<span class="built_in">type</span>&amp;)</span><br><span class="line">     forward(typename std::remove_reference&lt;_Tp&gt;::<span class="built_in">type</span>&amp; __t) noexcept</span><br><span class="line">     ^</span><br><span class="line">/usr/include/c++/5/bits/move.h:76:5: note:   template argument deduction/substitution failed:</span><br><span class="line">testf.cpp:17:30: note:   couldn<span class="string">'t deduce template parameter ‘_Tp’</span></span><br><span class="line"><span class="string">     return Print(std::forward(t));</span></span><br><span class="line"><span class="string">                              ^</span></span><br><span class="line"><span class="string">In file included from /usr/include/c++/5/bits/stl_pair.h:59:0,</span></span><br><span class="line"><span class="string">                 from /usr/include/c++/5/bits/stl_algobase.h:64,</span></span><br><span class="line"><span class="string">                 from /usr/include/c++/5/bits/char_traits.h:39,</span></span><br><span class="line"><span class="string">                 from /usr/include/c++/5/ios:40,</span></span><br><span class="line"><span class="string">                 from /usr/include/c++/5/ostream:38,</span></span><br><span class="line"><span class="string">                 from /usr/include/c++/5/iostream:39,</span></span><br><span class="line"><span class="string">                 from testf.cpp:1:</span></span><br><span class="line"><span class="string">/usr/include/c++/5/bits/move.h:87:5: note: candidate: template&lt;class _Tp&gt; constexpr _Tp&amp;&amp; std::forward(typename std::remove_reference&lt;_From&gt;::type&amp;&amp;)</span></span><br><span class="line"><span class="string">     forward(typename std::remove_reference&lt;_Tp&gt;::type&amp;&amp; __t) noexcept</span></span><br><span class="line"><span class="string">     ^</span></span><br><span class="line"><span class="string">/usr/include/c++/5/bits/move.h:87:5: note:   template argument deduction/substitution failed:</span></span><br><span class="line"><span class="string">testf.cpp:17:30: note:   couldn'</span>t deduce template parameter ‘_Tp’</span><br><span class="line">     <span class="built_in">return</span> Print(std::forward(t));</span><br><span class="line">                              ^</span><br><span class="line">testf.cpp:17:33: error: <span class="built_in">return</span>-statement with a value, <span class="keyword">in</span> <span class="keyword">function</span> returning <span class="string">'void'</span> [-fpermissive]</span><br><span class="line">     <span class="built_in">return</span> Print(std::forward(t));</span><br></pre></td></tr></table></figure><p>这次出了一个很长的编译错误，看来还是需要指定类型的，既然是需要指定的，那我们指定成其他的有没有问题呢？比如写成下面这样：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> Print(<span class="built_in">std</span>::forward&lt;<span class="keyword">float</span>&gt;(t));</span><br></pre></td></tr></table></figure><p>编译运行结果如下，都变成了右值引用：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:/mnt/d/data/cpp/testtemplate$ g++ testf.cpp --std=c++11</span><br><span class="line">albert@home-pc:/mnt/d/data/cpp/testtemplate$ ./a.out</span><br><span class="line">rvalue refrence: val=2022</span><br><span class="line">rvalue refrence: val=501</span><br></pre></td></tr></table></figure><p>再改成下面这样：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> Print(<span class="built_in">std</span>::forward&lt;T&amp;&gt;(t));</span><br></pre></td></tr></table></figure><p>编译运行结果如下，都变成了左值引用：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:/mnt/d/data/cpp/testtemplate$ g++ testf.cpp --std=c++11</span><br><span class="line">albert@home-pc:/mnt/d/data/cpp/testtemplate$ ./a.out</span><br><span class="line">lvalue refrence: val=2022</span><br><span class="line">lvalue refrence: val=501</span><br></pre></td></tr></table></figure><h1 id="完美转发失效"><a href="#完美转发失效" class="headerlink" title="完美转发失效"></a>完美转发失效</h1><p>上面的这两个例子能说明完美转发失效了吗？这倒也不能说明，第一个例子全都转发成了右值引用，第二个例子全部转发成了左值引用，和我们指定的类型是一致的，也算实现了完美转发，只不过通过这些例子更加深入的理解了完美转发的含义，就是能保证转化成指定的类型，如果指定的类型是个万能引用，就会根据原始类型来完成转发，本次探索之旅到此也就结束了，解答疑惑是个有趣的事情。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li><code>std::forward</code> 的本质还是进行强制类型转换，它会把传入的参数转发成指定的类型</li><li>完美转发其实是可以脱离左值右值概念的，这也是对完美转发更加深入的理解吧</li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/123978539" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>每一点付出终有回报，每一滴汗水从不会白流，可能你看不见也摸不着，但其实它已经悄然声息的改变了你，改变了你周围的点点滴滴~</p><p>2022-5-1 22:58:21</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;关于 &lt;code&gt;std::forward&lt;/code&gt; 的用法在之前的文章 &lt;a href=&quot;https://blog.csdn.net/albertsh/article/details/118886009&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《C++11中std::move和std::forward到底干了啥》&lt;/a&gt;已经总结过了，它被称为完美转发函数，用于函数模板中完成参数转发任务，当形参为左值引用时把它转发成左值，而在形参成为右值引用时把它转发成右值，依靠了引用折叠规则和 &lt;code&gt;std::remove_reference&lt;/code&gt; 模板。&lt;br&gt;
    
    </summary>
    
      <category term="C/C++" scheme="http://AlbertGithubHome.github.io/blog/categories/C-C/"/>
    
    
      <category term="C++" scheme="http://AlbertGithubHome.github.io/blog/tags/C/"/>
    
      <category term="C++11" scheme="http://AlbertGithubHome.github.io/blog/tags/C-11/"/>
    
      <category term="forward" scheme="http://AlbertGithubHome.github.io/blog/tags/forward/"/>
    
      <category term="完美转发" scheme="http://AlbertGithubHome.github.io/blog/tags/%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91/"/>
    
      <category term="funny" scheme="http://AlbertGithubHome.github.io/blog/tags/funny/"/>
    
  </entry>
  
  <entry>
    <title>C++可变参数模板的展开方式</title>
    <link href="http://AlbertGithubHome.github.io/blog/2022/04/04/C-%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E6%A8%A1%E6%9D%BF%E7%9A%84%E5%B1%95%E5%BC%80%E6%96%B9%E5%BC%8F/"/>
    <id>http://AlbertGithubHome.github.io/blog/2022/04/04/C-可变参数模板的展开方式/</id>
    <published>2022-04-04T12:46:40.000Z</published>
    <updated>2022-04-05T14:16:20.917Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><a href="https://en.cppreference.com/w/cpp/language/parameter_pack" target="_blank" rel="noopener">可变参数模板</a>（variadic templates）是C++11新增的强大的特性之一，它对模板参数进行了高度泛化，能表示0到任意个数、任意类型的参数。相比C++98/03这些类模版和函数模版中只能含固定数量模版参数的“老古董”，可变模版参数无疑是一个巨大的进步。</p><a id="more"></a><p>如果是刚接触可变参数模板可能会觉得比较抽象，使用起来会不太顺手，使用可变参数模板时通常离不开模板参数的展开，所以本文来列举一些常用的模板展开方式，帮助我们来对可变参数模板有一个初步的了解。</p><h1 id="可变参数模板的定义"><a href="#可变参数模板的定义" class="headerlink" title="可变参数模板的定义"></a>可变参数模板的定义</h1><p>可变参数模板和普通模板的定义类似，在写法上需要在 <code>typename</code> 或 <code>class</code> 后面带上省略号<code>...</code>，以下为一个常见的可变参数函数模板：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span>... <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">func</span>(<span class="title">T</span>... <span class="title">args</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这个函数模板的参数 <code>args</code> 前面有省略号，所以它就是一个被称为模板参数包（template parameter pack）的可变模版参数，它里面包含了0到N个模版参数，而我们是无法直接获取 <code>args</code> 中的每个参数的，只能通过展开参数包的方式来获取参数包中的每个参数，这也是本文要重点总结的内容。</p><h1 id="参数包的展开"><a href="#参数包的展开" class="headerlink" title="参数包的展开"></a>参数包的展开</h1><p>参数包展开的方式随着c++语言的发展也在与时俱进，我们以实现一个可变参格式化打印函数为例，列举一些常用的方式：</p><h2 id="递归函数方式展开"><a href="#递归函数方式展开" class="headerlink" title="递归函数方式展开"></a>递归函数方式展开</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FormatPrint</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> ...<span class="title">Args</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">FormatPrint</span>(<span class="title">T</span> <span class="title">first</span>, <span class="title">Args</span>... <span class="title">args</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"["</span> &lt;&lt; first &lt;&lt; <span class="string">"]"</span>;</span><br><span class="line">   FormatPrint(args...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   FormatPrint(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">   FormatPrint(<span class="string">"good"</span>, <span class="number">2</span>, <span class="string">"hello"</span>, <span class="number">4</span>, <span class="number">110</span>);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种递归展开的方式与递归函数的定义是一样的，需要递归出口和不断调用自身，仔细看看这个函数模板是不是都满足啦？递归出口就是这个无模板参数的 <code>FormatPrint</code>，并且在有参模板中一直在调用自身，递归调用的过程时这样的 <code>FormatPrint(4,3,2,1)</code> -&gt; <code>FormatPrint(3,2,1)</code> -&gt; <code>FormatPrint(2,1)</code> -&gt; <code>FormatPrint(1)</code> -&gt; <code>FormatPrint()</code>，输出内容如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:/mnt/d/data/cpp/testtemplate$ g++ testtemplate.cpp --std=c++11</span><br><span class="line">albert@home-pc:/mnt/d/data/cpp/testtemplate$ ./a.out</span><br><span class="line">[1][2][3][4]</span><br><span class="line">[good][2][hello][4][110]</span><br></pre></td></tr></table></figure><h2 id="逗号表达式展开"><a href="#逗号表达式展开" class="headerlink" title="逗号表达式展开"></a>逗号表达式展开</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> ...<span class="title">Args</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">FormatPrint</span>(<span class="title">Args</span>... <span class="title">args</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   (<span class="keyword">void</span>)<span class="built_in">std</span>::<span class="built_in">initializer_list</span>&lt;<span class="keyword">int</span>&gt;&#123; (<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"["</span> &lt;&lt; args &lt;&lt; <span class="string">"]"</span>, <span class="number">0</span>)... &#125;;</span><br><span class="line">   <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   FormatPrint(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">   FormatPrint(<span class="string">"good"</span>, <span class="number">2</span>, <span class="string">"hello"</span>, <span class="number">4</span>, <span class="number">110</span>);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方式用到了C++11的新特性<a href="https://en.cppreference.com/w/cpp/language/list_initialization" target="_blank" rel="noopener">初始化列表</a>（Initializer lists）以及很传统的逗号表达式，我们知道逗号表达式的优先级最低，<code>(a, b)</code> 这个表达式的值就是 <code>b</code>，那么上述代码中<code>(std::cout &lt;&lt; &quot;[&quot; &lt;&lt; args &lt;&lt; &quot;]&quot;, 0)</code>这个表达式的值就是0，初始化列表保证其中的内容从左往右执行，args参数包会被逐步展开，表达式前的<code>(void)</code>是为了防止变量未使用的警告，运行过后我们就得到了一个N个元素为0的初始化列表，内容也被格式化输出了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:/mnt/d/data/cpp/testtemplate$ g++ testtemplate.cpp --std=c++11</span><br><span class="line">albert@home-pc:/mnt/d/data/cpp/testtemplate$ ./a.out</span><br><span class="line">[1][2][3][4]</span><br><span class="line">[good][2][hello][4][110]</span><br></pre></td></tr></table></figure><p>说到这顺便提一下，可以使用<code>sizeof...(args)</code>得到参数包中参数个数。</p><h2 id="enable-if方式展开"><a href="#enable-if方式展开" class="headerlink" title="enable_if方式展开"></a>enable_if方式展开</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;tuple&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;type_traits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="built_in">std</span>::<span class="keyword">size_t</span> k = <span class="number">0</span>, <span class="keyword">typename</span> tup&gt;</span><br><span class="line"><span class="keyword">typename</span> <span class="built_in">std</span>::enable_if&lt;k == <span class="built_in">std</span>::tuple_size&lt;tup&gt;::value&gt;::type FormatTuple(<span class="keyword">const</span> tup&amp; t)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="built_in">std</span>::<span class="keyword">size_t</span> k = <span class="number">0</span>, <span class="keyword">typename</span> tup&gt;</span><br><span class="line"><span class="keyword">typename</span> <span class="built_in">std</span>::enable_if&lt;k &lt; <span class="built_in">std</span>::tuple_size&lt;tup&gt;::value&gt;::type FormatTuple(<span class="keyword">const</span> tup&amp; t)&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"["</span> &lt;&lt; <span class="built_in">std</span>::get&lt;k&gt;(t) &lt;&lt; <span class="string">"]"</span>;</span><br><span class="line">    FormatTuple&lt;k + <span class="number">1</span>&gt;(t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FormatPrint</span><span class="params">(Args... args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FormatTuple(<span class="built_in">std</span>::make_tuple(args...));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   FormatPrint(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">   FormatPrint(<span class="string">"good"</span>, <span class="number">2</span>, <span class="string">"hello"</span>, <span class="number">4</span>, <span class="number">110</span>);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>C++11的<a href="https://en.cppreference.com/w/cpp/types/enable_if" target="_blank" rel="noopener"><code>enable_if</code></a>常用于构建需要根据不同的类型的条件实例化不同模板的时候。顾名思义，当满足条件时类型有效。可作为选择类型的小工具，其广泛的应用在 C++ 的模板元编程（meta programming）之中，利用的就是SFINAE原则，英文全称为Substitution failure is not an error，意思就是匹配失败不是错误，假如有一个特化会导致编译时错误，只要还有别的选择，那么就无视这个特化错误而去选择另外的实现，这里的特化概念不再展开，感兴趣可以自行了解，后续可以单独总结一下。</p><p>在上面的代码实现中，基本思路是先将可变模版参数转换为<code>std::tuple</code>，然后通过递增参数的索引来选择恰当的<code>FormatTuple</code>函数，当参数的索引小于tuple元素个数时，会不断取出当前索引位置的参数并输出，当参数索引等于总的参数个数时调用另一个模板重载函数终止递归，编译运行输入以下内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:/mnt/d/data/cpp/testtemplate$ g++ testtemplate.cpp --std=c++11</span><br><span class="line">albert@home-pc:/mnt/d/data/cpp/testtemplate$ ./a.out</span><br><span class="line">[1][2][3][4]</span><br><span class="line">[good][2][hello][4][110]</span><br></pre></td></tr></table></figure><h2 id="折叠表达式展开（c-17）"><a href="#折叠表达式展开（c-17）" class="headerlink" title="折叠表达式展开（c++17）"></a>折叠表达式展开（c++17）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FormatPrint</span><span class="params">(Args... args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    (<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ... &lt;&lt; args) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   FormatPrint(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">   FormatPrint(<span class="string">"good"</span>, <span class="number">2</span>, <span class="string">"hello"</span>, <span class="number">4</span>, <span class="number">110</span>);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://en.cppreference.com/w/cpp/language/fold" target="_blank" rel="noopener">折叠表达式</a>（Fold Expressions）是C++17新引进的语法特性，使用折叠表达式可以简化对C++11中引入的参数包的处理，可以在某些情况下避免使用递归，更加方便的展开参数，如上述代码中展示的这样可以方便的展开参数包，不过输出的内容和之前的有些不一样：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:/mnt/d/data/cpp/testtemplate$ g++ testtemplate.cpp --std=c++17</span><br><span class="line">albert@home-pc:/mnt/d/data/cpp/testtemplate$ ./a.out</span><br><span class="line">1234</span><br><span class="line">good2hello4110</span><br></pre></td></tr></table></figure><p>对比结果发现缺少了格式化的信息，需要以辅助函数的方式来格式化：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">format</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">stringstream</span> ss;</span><br><span class="line">    ss &lt;&lt; <span class="string">"["</span> &lt;&lt; t &lt;&lt; <span class="string">"]"</span>;</span><br><span class="line">    <span class="keyword">return</span> ss.str();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FormatPrint</span><span class="params">(Args... args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    (<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ... &lt;&lt; format(args)) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   FormatPrint(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">   FormatPrint(<span class="string">"good"</span>, <span class="number">2</span>, <span class="string">"hello"</span>, <span class="number">4</span>, <span class="number">110</span>);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这次格式化内容就被加进来了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:/mnt/d/data/cpp/testtemplate$ g++ testtemplate.cpp --std=c++17</span><br><span class="line">albert@home-pc:/mnt/d/data/cpp/testtemplate$ ./a.out</span><br><span class="line">[1][2][3][4]</span><br><span class="line">[good][2][hello][4][110]</span><br></pre></td></tr></table></figure><p>这样好像还是有点麻烦，我们可以把折叠表达式和逗号表达式组合使用，这样得到的代码就简单多啦，也能完成格式化输出的任务：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FormatPrint</span><span class="params">(Args... args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    (<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ... &lt;&lt; (<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"["</span> &lt;&lt; args, <span class="string">"]"</span>)) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   FormatPrint(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">   FormatPrint(<span class="string">"good"</span>, <span class="number">2</span>, <span class="string">"hello"</span>, <span class="number">4</span>, <span class="number">110</span>);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li><code>Variadic templates</code> 是C++11新增的强大的特性之一，它对模板参数进行了高度泛化</li><li><code>Initializer lists</code> 是C++11新加的特性，可以作为函数参数和返回值，长度不受限制比较方便</li><li><code>Fold Expressions</code> 是C++17新引进的语法特性，可以方便的展开可变参数模板的参数包</li><li>可变参数模板的参数包在C++11的环境下，可以利用递归、逗号表达式、enable_if等方式进行展开</li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/123958013" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>有些人苦中作乐，而有些人却是身在福中不知福。人性本贪婪，只是度不同。我虽知福，奈何要想一家安稳还差的太多~</p><p>2022-4-5 22:02:27</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://en.cppreference.com/w/cpp/language/parameter_pack&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;可变参数模板&lt;/a&gt;（variadic templates）是C++11新增的强大的特性之一，它对模板参数进行了高度泛化，能表示0到任意个数、任意类型的参数。相比C++98/03这些类模版和函数模版中只能含固定数量模版参数的“老古董”，可变模版参数无疑是一个巨大的进步。&lt;/p&gt;
    
    </summary>
    
      <category term="C/C++" scheme="http://AlbertGithubHome.github.io/blog/categories/C-C/"/>
    
    
      <category term="C/C++" scheme="http://AlbertGithubHome.github.io/blog/tags/C-C/"/>
    
      <category term="可变参数" scheme="http://AlbertGithubHome.github.io/blog/tags/%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0/"/>
    
      <category term="template" scheme="http://AlbertGithubHome.github.io/blog/tags/template/"/>
    
      <category term="模板" scheme="http://AlbertGithubHome.github.io/blog/tags/%E6%A8%A1%E6%9D%BF/"/>
    
  </entry>
  
</feed>
