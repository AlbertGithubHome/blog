<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Albert World</title>
  <icon>https://www.gravatar.com/avatar/8ccc6291d5bfd34e7aaf601c4ebec7e1</icon>
  
  <link href="/blog/atom.xml" rel="self"/>
  
  <link href="http://AlbertGithubHome.github.io/blog/"/>
  <updated>2021-12-26T15:59:10.826Z</updated>
  <id>http://AlbertGithubHome.github.io/blog/</id>
  
  <author>
    <name>Albert Shi</name>
    <email>347070901@qq.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Windows设置防火墙允许指定应用正常使用网络</title>
    <link href="http://AlbertGithubHome.github.io/blog/2021/12/26/Windows%E8%AE%BE%E7%BD%AE%E9%98%B2%E7%81%AB%E5%A2%99%E5%85%81%E8%AE%B8%E6%8C%87%E5%AE%9A%E5%BA%94%E7%94%A8%E6%AD%A3%E5%B8%B8%E4%BD%BF%E7%94%A8%E7%BD%91%E7%BB%9C/"/>
    <id>http://AlbertGithubHome.github.io/blog/2021/12/26/Windows设置防火墙允许指定应用正常使用网络/</id>
    <published>2021-12-26T09:58:52.000Z</published>
    <updated>2021-12-26T15:59:10.826Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>很长一段时间以来，防火墙这个神奇的“玩意”在我的电脑上基本属于名存死亡，因为做网络软件开发的缘故，经常需要别人连接我的电脑来进行测试，打开Windows的防火墙常常出现网络无法联通的情况，所以在我的电脑上防火墙基本处于关闭状态，就像下面这样：</p><p><img src="https://cdn.jsdelivr.net/gh/albertgithubhome/cdn/img/firewall/1.png" alt="pressure"></p><p>但这确实不是一个好的习惯，最近学习了一些网络安全相关的课程，发现打开防火墙还是很有必要的，它可以避免我们遭受一些攻击，最起码可以降低受到攻击的概率，所以我还是决定打开防火墙，同时设置防火墙对自己的开发的应用放行，也就是把应用放到防火墙白名单里，这样就既安全又方便了。</p><h1 id="什么是Windows防火墙"><a href="#什么是Windows防火墙" class="headerlink" title="什么是Windows防火墙"></a>什么是Windows防火墙</h1><blockquote><p>防火墙是一项协助确保信息安全的设备，会依照特定的规则，允许或限制传输的数据通过。防火墙可以是一台专属的硬件也可以是架设在一般硬件上的一套软件。总而言之，防火墙就是帮助计算机网络于其内、外网之间构建一道相对隔绝的保护屏障。</p></blockquote><p>这段文字来自于百科，翻译的直白一点就是说：你的电脑就相当于一个城池，然后网络上的病毒、木马等恶意程序就相当于敌对势力派来的间谍，想混进城去，而防火墙就相当于城门口设置的关卡哨兵用来盘查筛选，放合适的人进城，同时放合法的人出去，既要满足城内人与外界的交流，又要防止恶意的坏人蒙混过关。</p><h1 id="设置允许通过防火墙的应用"><a href="#设置允许通过防火墙的应用" class="headerlink" title="设置允许通过防火墙的应用"></a>设置允许通过防火墙的应用</h1><p>要想设置指定应用允许通过防火墙，需要先打开防火墙功能再设置才会生效，下面以Windows10为例操作一次。</p><ol><li>打开<code>控制面板</code></li></ol><p>按键盘上的 <code>Win</code> 键，然后输入控制面板，在筛选结果中点击“控制面板”选项：</p><p><img src="https://cdn.jsdelivr.net/gh/albertgithubhome/cdn/img/firewall/2.png" alt="pressure"></p><ol><li>点击<code>系统和安全</code>选项</li></ol><p><img src="https://cdn.jsdelivr.net/gh/albertgithubhome/cdn/img/firewall/3.png" alt="pressure"></p><ol><li>点击<code>Windows Defender防火墙</code>选项</li></ol><p><img src="https://cdn.jsdelivr.net/gh/albertgithubhome/cdn/img/firewall/4.png" alt="pressure"></p><blockquote><p>其实前面这三步可以简化为，按<code>Win+R</code>快捷键，输入<code>firewall.cpl</code>回车即可</p></blockquote><ol><li>点击<code>启用或关闭Windows Defender防火墙</code>选项</li></ol><p><img src="https://cdn.jsdelivr.net/gh/albertgithubhome/cdn/img/firewall/5.png" alt="pressure"></p><ol><li>勾选<code>启用 Windows Defender 防火墙</code> 选项，点击确定按钮</li></ol><p><img src="https://cdn.jsdelivr.net/gh/albertgithubhome/cdn/img/firewall/6.png" alt="pressure"></p><ol><li>点击<code>允许应用或功能通过 Windows Defender 防火墙</code>选项</li></ol><p><img src="https://cdn.jsdelivr.net/gh/albertgithubhome/cdn/img/firewall/7.png" alt="pressure"></p><ol><li>找到目标应用，把后面两个选项勾选上，然后点击确定即可</li></ol><p><img src="https://cdn.jsdelivr.net/gh/albertgithubhome/cdn/img/firewall/8.png" alt="pressure"></p><p>这里以 <code>WeChat</code> 为例，在<code>专用</code> 和 <code>公用</code>两个复选框上打钩，然后单击下面的确定按钮就可以了，如果列表中没有想要添加白名单的应用，还可以点击确定按钮上面的 <code>允许其他应用(R)</code>按钮来自己添加。</p><h1 id="防火墙中的专用和公用"><a href="#防火墙中的专用和公用" class="headerlink" title="防火墙中的专用和公用"></a>防火墙中的专用和公用</h1><p>防火墙中的<code>专用</code> 和 <code>公用</code>是针对网络而言的，Windows中给出的说明：专用网络，例如家庭或工作网络；公用网络，比如机场和咖啡店中的网络。那么是不是当我在家里连网时就是专用网络，而在咖啡厅连接网络时就自动识别为公用网络呢？</p><p>Windows当然没有这么智能，连接新的网络时属于什么类型的网络需要你自己选择，也就是说你自己要做出判断，如果是自己家的网络，基本是上独享的安全的，那就可以设置为专用网络，如果是连接的公共Wifi那必须要选择公用网络。</p><p>而防火墙中对专用网络和公用网络有不同的设置，这个比较好理解，还是以前面城池和哨兵的比喻为例，防火墙作为哨兵在不同的环境下有不同的标准，比如在和平时期，对非常可疑的人才禁止入城，而在战时，除了必要的粮草供应，其他的普通商人可能都不允许入内了。</p><p>所以当一个应用无法联网时，需要检查一下应用设置白名单中是在哪个网络环境下，如果是可以信赖的应用，通常在专用网络和公用网络都会设置允许通过防火墙。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>快捷键 <code>Win+R</code> 输入 <code>firewall.cpl</code> 后回车，可以快速打开防火墙设置</li><li>Windows中的专用网络和公用网络需要自己在连接网络时设置，系统本身没有准确分辨的能力</li><li>防火墙中对专用网络和公用网络有不同的设置，相当于在不同的网络环境下设置了不同的安全级别</li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/122032810" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>默默的付出是否值得？一查问题就消耗几个小时，修复个BUG前前后后花了几天，有时会假设站在高处，望着此时的自己，这样做是否值得？成年人的世界往往只看性价比，如果说花了几天时间却一无所获，那之前的付出确实不值得，也就是做了一件性价比很低的事情。但是这个结果是做完才知道的，在做之前并不能准确判断是否值得，无法进行“挑选”，也不应该抱着我不做总有人会做的态度，既然做就全力以赴，若无果也仅仅是我们“赌”输了而已。但要记住，现实的世界只记得功劳，没有结论、没有反馈、毫无借鉴意义的苦劳一文不值~</p><p>2021-12-26 23:54:19</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;很长一段时间以来，防火墙这个神奇的“玩意”在我的电脑上基本属于名存死亡，因为做网络软件开发的缘故，经常需要别人连接我的电脑来进行测试，打开W
      
    
    </summary>
    
      <category term="windows" scheme="http://AlbertGithubHome.github.io/blog/categories/windows/"/>
    
    
      <category term="Win10" scheme="http://AlbertGithubHome.github.io/blog/tags/Win10/"/>
    
      <category term="windows" scheme="http://AlbertGithubHome.github.io/blog/tags/windows/"/>
    
      <category term="防火墙" scheme="http://AlbertGithubHome.github.io/blog/tags/%E9%98%B2%E7%81%AB%E5%A2%99/"/>
    
      <category term="firewall" scheme="http://AlbertGithubHome.github.io/blog/tags/firewall/"/>
    
      <category term="白名单" scheme="http://AlbertGithubHome.github.io/blog/tags/%E7%99%BD%E5%90%8D%E5%8D%95/"/>
    
  </entry>
  
  <entry>
    <title>git常用配置——git show/diff tab 显示宽度</title>
    <link href="http://AlbertGithubHome.github.io/blog/2021/12/19/git%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE%E2%80%94%E2%80%94git-show-diff-tab-%E6%98%BE%E7%A4%BA%E5%AE%BD%E5%BA%A6/"/>
    <id>http://AlbertGithubHome.github.io/blog/2021/12/19/git常用配置——git-show-diff-tab-显示宽度/</id>
    <published>2021-12-19T15:44:39.000Z</published>
    <updated>2021-12-19T16:13:49.758Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>平时在代码开发过程中使用编辑器时一般会使用空格来代替Tab符，而Tab的宽度通常设置为4个空格的宽度。在使用<code>git diff</code> 命令时发现有些老代码的格式混乱，原因就是使用了8个字符宽度的Tab显示格式，经过一番查找发现可以修改 <code>core.pager</code> 来进行调整，特此记录方便日后查找。</p><a id="more"></a><h1 id="常用配置"><a href="#常用配置" class="headerlink" title="常用配置"></a>常用配置</h1><ul><li>设置Tab显示为4个字符的宽度</li></ul><p><code>git config --global core.pager &#39;less -x1,5&#39;</code></p><ul><li>设置Tab显示为8个字符的宽度（默认）</li></ul><p><code>git config --global core.pager &#39;less&#39;</code></p><ul><li>设置用户名</li></ul><p><code>git config --global user.name &quot;albert&quot;</code></p><ul><li>设置邮箱</li></ul><p><code>git config --global user.email &quot;albert52190@gmail.com&quot;</code></p><ul><li>设置别名</li></ul><p><code>git config --global alias.st status</code></p><ul><li>配置自动更新子模块的命令</li></ul><p><code>git config --global alias.pullall &#39;!f(){ git pull &quot;$@&quot; &amp;&amp; git submodule update --init --recursive; }; f&#39;</code></p><ul><li>设置自动处理换行符</li></ul><p><code>git config --global core.autocrlf true</code></p><blockquote><p>true 在提交时将CRLF转换为LF，当签出代码时，LF会被转换成CRLF<br>input 在提交是将CRLF转换为LF，签出时不转换<br>false 不进行转换</p></blockquote><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li><code>git config --global core.pager &#39;less -x1,5&#39;</code> 可将 <code>git show/diff</code> 命令的tab按照4字符宽度显示</li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/121896012" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>时间不多了，还有很多事情没有做呢，虽说欲速则不达，但是有些事如果还不做可能就真的没机会了<br>《一荤一素》</p><p>2021-12-20 00:09:54</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;平时在代码开发过程中使用编辑器时一般会使用空格来代替Tab符，而Tab的宽度通常设置为4个空格的宽度。在使用&lt;code&gt;git diff&lt;/code&gt; 命令时发现有些老代码的格式混乱，原因就是使用了8个字符宽度的Tab显示格式，经过一番查找发现可以修改 &lt;code&gt;core.pager&lt;/code&gt; 来进行调整，特此记录方便日后查找。&lt;/p&gt;
    
    </summary>
    
      <category term="Git" scheme="http://AlbertGithubHome.github.io/blog/categories/Git/"/>
    
    
      <category term="版本控制" scheme="http://AlbertGithubHome.github.io/blog/tags/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"/>
    
      <category term="Git" scheme="http://AlbertGithubHome.github.io/blog/tags/Git/"/>
    
      <category term="config" scheme="http://AlbertGithubHome.github.io/blog/tags/config/"/>
    
      <category term="pager" scheme="http://AlbertGithubHome.github.io/blog/tags/pager/"/>
    
  </entry>
  
  <entry>
    <title>网络工具nc的常见使用功能方法</title>
    <link href="http://AlbertGithubHome.github.io/blog/2021/12/12/%E7%BD%91%E7%BB%9C%E5%B7%A5%E5%85%B7nc%E7%9A%84%E5%B8%B8%E8%A7%81%E4%BD%BF%E7%94%A8%E5%8A%9F%E8%83%BD%E6%96%B9%E6%B3%95/"/>
    <id>http://AlbertGithubHome.github.io/blog/2021/12/12/网络工具nc的常见使用功能方法/</id>
    <published>2021-12-12T12:36:16.000Z</published>
    <updated>2021-12-12T14:30:22.211Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><code>nc</code> 是一个Linux环境下常用的工具命令，可以用来帮助开发者查询和解决网路问题，通常被认为是 <code>NetCat</code> 工具的缩写，在网络工具中有“瑞士军刀”的美誉。</p><a id="more"></a><p><code>nc</code> 在Linux环境下常常是自带的，如果你使用的Linux发行版本没有这个工具也可以自行安装，比如在CentOS上的安装命令就是 <code>yum install nc -y</code>，并且这个工具在Windows上也可以直接下载使用，下载页面地址为 <a href="https://eternallybored.org/misc/netcat/" target="_blank" rel="noopener">netcat</a>，简约而不简单。</p><h1 id="nc-netcat-ncat"><a href="#nc-netcat-ncat" class="headerlink" title="nc netcat ncat"></a>nc netcat ncat</h1><p>这三个名字常常出现在一起，也常常混用，可以简单的认为它们都一样，但是如果要追究细节它们还是有些差异的。原始netcat（也就是nc），在2007年发布1.10稳定版本之后，就不再更新了，原作者是Hobbit。而ncat是nmap项目的作者Fyodor，在原始nc之上进行二次开发的另一款强大工具。另外socat、cryptcat等也属于是原始nc的升级，而原始nc在windows上有时会被杀毒软件查杀，这时可以考虑使用ncat、socat。</p><p>关于nc的不同，可以看下我本地的查看情况，第一条是在Ubuntu中的man手册说明，第二条是在CentOS中的man手册说明：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">NC(1)                               BSD General Commands Manual                      NC(1)</span><br><span class="line"></span><br><span class="line">NAME</span><br><span class="line">     nc — arbitrary TCP and UDP connections and listens</span><br><span class="line"></span><br><span class="line">SYNOPSIS</span><br><span class="line">     nc [-46bCDdhklnrStUuvZz] [-I length] [-i interval] [-O length] [-P proxy_username] [-p source_port] [-q seconds] [-s <span class="built_in">source</span>] [-T toskeyword] [-V rtable] [-w timeout] [-X proxy_protocol] [-x</span><br><span class="line">        proxy_address[:port]] [destination] [port]</span><br><span class="line"></span><br><span class="line">DESCRIPTION</span><br><span class="line">     The nc (or netcat) utility is used <span class="keyword">for</span> just about anything under the sun involving TCP, UDP, or UNIX-domain sockets.  It can open TCP connections, send UDP packets, listen on arbitrary TCP and UDP</span><br><span class="line">     ports, <span class="keyword">do</span> port scanning, and deal with both IPv4 and IPv6.  Unlike telnet(1), nc scripts nicely, and separates error messages onto standard error instead of sending them to standard output, as</span><br><span class="line">     telnet(1) does with some</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">NCAT(1)                         Ncat Reference Guide                       NCAT(1)</span><br><span class="line"></span><br><span class="line">NAME</span><br><span class="line">       ncat - Concatenate and redirect sockets</span><br><span class="line"></span><br><span class="line">SYNOPSIS</span><br><span class="line">       ncat [OPTIONS...] [hostname] [port]</span><br><span class="line"></span><br><span class="line">DESCRIPTION</span><br><span class="line">       Ncat is a feature-packed networking utility <span class="built_in">which</span> reads and writes data across networks from the <span class="built_in">command</span> line. Ncat was written <span class="keyword">for</span> the Nmap Project and is the culmination of the</span><br><span class="line">       currently splintered family of Netcat incarnations. It is designed to be a reliable back-end tool to instantly provide network connectivity to other applications and users. Ncat</span><br><span class="line">       will not only work with IPv4 and IPv6 but provides the user with a virtually limitless number of potential uses.</span><br></pre></td></tr></table></figure><p>ncat 是 nmap 套件的一部分，关于nmap的介绍可以参考下来自百科的以下引用内容：</p><blockquote><p>nmap是linux最早的网络扫描工具和嗅探工具包，它可以用来扫描网络上电脑开放的网络连接端，确定哪些服务运行在那些连接端，并且推断出计算机运行的是哪个操作系统（这是亦称 fingerprinting）。它是网络管理员必用的软件之一，用以评估网络系统安全。</p><p>正如大多数被用于网络安全的工具，nmap 也是不少黑客及骇客爱用的工具 。系统管理员可以利用nmap来探测工作环境中未经批准使用的服务器，但是黑客会利用nmap来搜集目标电脑的网络设定，从而计划攻击的方法。</p></blockquote><h1 id="nc的用法"><a href="#nc的用法" class="headerlink" title="nc的用法"></a>nc的用法</h1><p>nc是一个强大的网络工具，下面列举几个常见的用法。</p><h2 id="测试udp端口是否可用"><a href="#测试udp端口是否可用" class="headerlink" title="测试udp端口是否可用"></a>测试udp端口是否可用</h2><p>如果是测试某个IP地址地址是否可以访问，通常会使用 <code>ping</code> 命令，执行之后如果可以到达就会得到数据反馈：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:~$ ping 82.156.125.169</span><br><span class="line">PING 82.156.125.169 (82.156.125.169) 56(84) bytes of data.</span><br><span class="line">64 bytes from 82.156.125.169: icmp_seq=1 ttl=54 time=17.8 ms</span><br><span class="line">64 bytes from 82.156.125.169: icmp_seq=2 ttl=54 time=39.9 ms</span><br><span class="line">64 bytes from 82.156.125.169: icmp_seq=3 ttl=54 time=12.9 ms</span><br><span class="line">64 bytes from 82.156.125.169: icmp_seq=4 ttl=54 time=6.81 ms</span><br><span class="line">^C</span><br><span class="line">--- 82.156.125.169 ping statistics ---</span><br><span class="line">4 packets transmitted, 4 received, 0% packet loss, time 3008ms</span><br><span class="line">rtt min/avg/max/mdev = 6.816/19.397/39.961/12.502 ms</span><br></pre></td></tr></table></figure><p>想要测试一个tcp端口是否可以访问，映入脑海的第一个命令应该是telnet，直接在IP后面加空格和端口就可以了：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:~$ telnet 82.156.125.169 22</span><br><span class="line">Trying 82.156.125.169...</span><br><span class="line">Connected to 82.156.125.169.</span><br><span class="line">Escape character is <span class="string">'^]'</span>.</span><br><span class="line">SSH-2.0-OpenSSH_7.4</span><br></pre></td></tr></table></figure><p>如果想测试UDP端口是否可达使用telnet就不行了，因为它是一种基于TCP的应用层协议，用来测试UDP端口会因为长时间没有反应而超时：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:~$ telnet 82.156.125.169 666</span><br><span class="line">Trying 82.156.125.169...</span><br><span class="line">telnet: Unable to connect to remote host: Connection refused</span><br></pre></td></tr></table></figure><p>这时用 <code>nc</code> 命令就可以解决了，命令格式为 <code>nc -nvuz ip port</code>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:~$ nc -nvuz 82.156.125.169 666</span><br><span class="line">Connection to 82.156.125.169 666 port [udp/*] succeeded!</span><br></pre></td></tr></table></figure><h2 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h2><p>这实际实际上是对上一个应用的扩展，使用 <code>nc</code> 命令可以指定一个端口范围，用来扫描多个端口是否可用：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:~$ nc -nvz 82.156.125.169 20-24</span><br><span class="line">nc: connect to 82.156.125.169 port 20 (tcp) failed: Connection refused</span><br><span class="line">nc: connect to 82.156.125.169 port 21 (tcp) failed: Connection refused</span><br><span class="line">Connection to 82.156.125.169 22 port [tcp/*] succeeded!</span><br><span class="line">nc: connect to 82.156.125.169 port 23 (tcp) failed: Connection refused</span><br><span class="line">nc: connect to 82.156.125.169 port 24 (tcp) failed: Connection refused</span><br></pre></td></tr></table></figure><h2 id="一对一聊天"><a href="#一对一聊天" class="headerlink" title="一对一聊天"></a>一对一聊天</h2><p>使用 <code>nc</code> 命令可以监听一个端口作为服务器，然后在另一台机器上启动 <code>nc</code> 作为客户端发数据：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动服务器</span></span><br><span class="line">[root@VM-0-3-centos ~]<span class="comment"># nc -l 1314</span></span><br><span class="line"><span class="comment"># 以下为接收到客户端发来的数据</span></span><br><span class="line">12</span><br><span class="line">client send msg</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动客户端</span></span><br><span class="line">albert@home-pc:~$ nc 82.156.125.169 1314</span><br><span class="line"><span class="comment"># 以下为输入的数据</span></span><br><span class="line">12</span><br><span class="line">client send msg</span><br></pre></td></tr></table></figure><h2 id="传输文件"><a href="#传输文件" class="headerlink" title="传输文件"></a>传输文件</h2><p>这个用法是对上一种用法的扩展，通过重定向将文件内容通过网络传输：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 服务端将socket内容保存到w文件中</span></span><br><span class="line">[root@VM-0-3-centos ~]<span class="comment"># nc -l 1314 &gt; w.txt</span></span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:~$ cat w.txt</span><br><span class="line">w</span><br><span class="line">-</span><br><span class="line">r</span><br><span class="line">x</span><br><span class="line">d</span><br><span class="line"><span class="comment"># 客户端将w.txt文件内容发送给服务器</span></span><br><span class="line">albert@home-pc:~$ nc 82.156.125.169 1314 &lt; w.txt</span><br><span class="line">albert@home-pc:~$</span><br></pre></td></tr></table></figure><p>客户端运行完 <code>nc</code> 命令之后就会退出，服务器端的 <code>nc</code> 命令也会结束，<code>w.txt</code> 文件的内容就传送过去了。</p><h2 id="端口转发"><a href="#端口转发" class="headerlink" title="端口转发"></a>端口转发</h2><p>这其实也是传输数据的命令的一个变种，使用 <code>-c</code> 参数可以完成数据转发：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-0-3-centos ~]<span class="comment"># nc -l 520 -c "nc 82.156.125.169 1314"</span></span><br></pre></td></tr></table></figure><p>执行命令之后，发送到本机 520 端口的数据就会被转发到 IP 为82.156.125.169的1314端口上了。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li><code>nc -nvuz ip port</code> 可以检测指定IP的UDP端口能否访问，如果是TCP端口去掉 <code>-u</code> 选项就可以了</li><li><code>nc -l port</code> 可以启动一个本地服务器，接受发往指定端口的数据，并打印到控制台</li><li><code>nc -l port &gt; filename</code> 可以启动一个本地服务器，接受发往指定端口的数据，并保存到名为 <code>filename</code> 的文件中</li><li><code>nc -l port -c &quot;nc ip new_port&quot;</code> 可以启动一个本地服务器，接受发往指定端口的数据，并转发到ip:new_port的机器上</li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/121724688" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>人生每时每刻都在积攒素材，能否拼凑出高光的时刻，决定了某些事迹有无机会诉说。</p><p>2021-12-12 22:11:51</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&lt;code&gt;nc&lt;/code&gt; 是一个Linux环境下常用的工具命令，可以用来帮助开发者查询和解决网路问题，通常被认为是 &lt;code&gt;NetCat&lt;/code&gt; 工具的缩写，在网络工具中有“瑞士军刀”的美誉。&lt;/p&gt;
    
    </summary>
    
      <category term="Network" scheme="http://AlbertGithubHome.github.io/blog/categories/Network/"/>
    
    
      <category term="Network" scheme="http://AlbertGithubHome.github.io/blog/tags/Network/"/>
    
      <category term="nc" scheme="http://AlbertGithubHome.github.io/blog/tags/nc/"/>
    
      <category term="NetCat" scheme="http://AlbertGithubHome.github.io/blog/tags/NetCat/"/>
    
      <category term="ncat" scheme="http://AlbertGithubHome.github.io/blog/tags/ncat/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://AlbertGithubHome.github.io/blog/2021/12/03/2021summary/"/>
    <id>http://AlbertGithubHome.github.io/blog/2021/12/03/2021summary/</id>
    <published>2021-12-02T16:11:16.789Z</published>
    <updated>2021-12-02T16:11:16.789Z</updated>
    
    <content type="html"><![CDATA[<p>将技能树补充完整</p><p>面试的功与过</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;将技能树补充完整&lt;/p&gt;
&lt;p&gt;面试的功与过&lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>记一次使用Valgrind查找解决内存问题的玄幻旅程</title>
    <link href="http://AlbertGithubHome.github.io/blog/2021/12/02/%E8%AE%B0%E4%B8%80%E6%AC%A1%E4%BD%BF%E7%94%A8Valgrind%E6%9F%A5%E6%89%BE%E8%A7%A3%E5%86%B3%E5%86%85%E5%AD%98%E9%97%AE%E9%A2%98%E7%9A%84%E7%8E%84%E5%B9%BB%E6%97%85%E7%A8%8B/"/>
    <id>http://AlbertGithubHome.github.io/blog/2021/12/02/记一次使用Valgrind查找解决内存问题的玄幻旅程/</id>
    <published>2021-12-02T15:42:47.000Z</published>
    <updated>2021-12-05T07:40:28.330Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>看题目来说这应该是一篇教程式文章，但为了突出“玄幻”二字，我们不讲细节只讲过程，在过程中体会解决问题的方式和方法，以及避免一些我在这个过程中绕的弯路，如果想找工具的详细使用方法可以去参考文章中翻一翻，有几篇文章写的真不错，下面我们开始扯淡啦。</p><a id="more"></a><h1 id="玄幻旅途"><a href="#玄幻旅途" class="headerlink" title="玄幻旅途"></a>玄幻旅途</h1><blockquote><p>本故事并非虚构，如有雷同，纯属命苦~</p></blockquote><h2 id="故事背景"><a href="#故事背景" class="headerlink" title="故事背景"></a>故事背景</h2><p>作为本文主人公的我——小Z，是一个后端C/C++搬运工（这不废话吗，不是C系列谁老倒腾指针和内存？），在一个阳（<del>yue</del>）光（<del>hei</del>）明（<del>feng</del>）媚（<del>gao</del>）的下（<del>wan</del>）午（<del>shang</del>）接到一个完善游戏战斗系统的需求，然后便开始了紧张开发、积极调试的每一天，事情比较顺利，一切都在计划之中，不过平凡的日子总是无趣，没有一点点意外总让人感到有点意外。</p><h2 id="初入泥潭"><a href="#初入泥潭" class="headerlink" title="初入泥潭"></a>初入泥潭</h2><p>好吧，到目前为止一切都很顺利，服务器各个功能模块分批完成，终于完成了最后拼装，启动调试看结果，出现了一点点逻辑问题，这个战斗过程根本停不下来，整个程序一直在递归，最终导致函数调用栈溢出崩溃。不过这都是小问题，简单梳理逻辑后增加必要的出口判断条件，问题很快被解决。</p><p>再次启动调试，程序正常运行，符合预期结果。啥？这就完了，幸福来的有点突然啊，整个流程基本符合需求，只是缺少一些细节逻辑需要补充，感觉胜利就在前方了啊！</p><h2 id="一片混沌"><a href="#一片混沌" class="headerlink" title="一片混沌"></a>一片混沌</h2><p>补充细节的过程中，也需要不断调试来验证结果，咦？怎么连不上服务器了？查看一下进程，果然服务器进程已经不在了，难道是我不小心关掉了，先记一下，解决掉手头上更重要的问题后再来看它。</p><p>上次的问题好几天都没有出现了，可能真的是我不小心把服务器进程关掉了，今天还有个小BUG需要修复一下，先搭建好调试环境准备定位一下问题。整个过程比较顺利，没过几分钟BUG就找到了，修复后调试看看结果，Duang！进程挂了，好在这次是在调试状态，能看到是哪里引发的崩溃，查看函数调用栈来看看是谁捣的鬼。</p><p>什么玩意，智能指针出作用域时自动析构挂了？这是什么鬼，从上到下看了一遍近百层的函数调用关系，感觉没什么问题啊，真是奇怪。</p><p>重新启动进程，开始了疯狂测试，跑了20几次相同的逻辑，没有任何问题啊，那刚刚发生了什么，转过头来继续看刚刚出现崩溃的位置，完全找不到问题。这个问题先放一放，继续补充细节，调试解决发现的BUG，在多次调试之后，Duang！进程又挂了，这次更离谱，在定义lambda表达式的时候崩了，看着函数调用栈依旧一头雾水，看不出是什么问题。</p><p>退出调试状态，重启进程，继续跑了10多次相同的逻辑，这次进程真的崩溃了，看来程序真的是有隐藏的BUG。再次重启，继续跑，这次又不崩溃了，这种状况让人有点头大啊。启动调试状态开始测试，跑了几次就崩溃了，原来和调试有关系呀！经过多次测试发现，如果在调试状态下测试几次就会出现崩溃的情况，如果在非调试状态下大概需要跑10多次才会崩。</p><p>为了查出问题便开始在调试状态下更加疯狂的测试，这次真的开了眼了，每次崩溃的位置都不太一样，有的在析构函数中，有的设置变量值时，有的在发送函数中，有的在申请内存时，总体来看基本都是围绕着内存出现的问题，但是问题原因未知。</p><h2 id="追根溯源"><a href="#追根溯源" class="headerlink" title="追根溯源"></a>追根溯源</h2><p>虽然经过大量测试仍不能准确给出问题原因，但是几十次的崩溃结果中还是能看到一些规律的，其中有50%左右出现在第二场战斗释放之前战斗对象的时候，40%出现在玩家重新登录释放之前战斗对象的时候，这两种情况加在一起就占了绝大多数，所以要从这里开始入手，查看释放战斗对象的函数是不是存在问题。</p><p>因为程序中很少直接使用简单的指针，基本都会用智能指针来代替，所以在战斗对象析构时会有很多小对象自动析构，花了不少时间来看这些代码，结果一无所获，这就怪了，那么多次崩溃都是在这，居然找不到任何问题。</p><h2 id="抽丝剥茧"><a href="#抽丝剥茧" class="headerlink" title="抽丝剥茧"></a>抽丝剥茧</h2><p>因为之前测试时需要完成跑完整个战斗流程，严重影响了测试效率，既然感觉释放战斗对象这部分代码有问题，那就单独跑这一段逻辑呗，单独建个分支，改代码！！！另外还发现一个事情，本来在我机器上需要在调试状态下跑好几次才能重现出的问题，在另一台发布机上两三次就能重现，干脆用它来验证结果。</p><p>说干就干，从原来的逻辑中，剥离出创建、释放战斗对象的代码，每次测试重复创建和释放过程几百次，这样就应该很容易就能重现问题了，修改完本地先测试，结果跑了十几次也没出现，部署到发布机上测试多次也没出现问题，和预想的完全不一样，实验失败，这个结果基本说明我的方向错误，并不是这段释放战斗对象的逻辑代码问题，又得重新寻找线索了。</p><h2 id="大海捞针"><a href="#大海捞针" class="headerlink" title="大海捞针"></a>大海捞针</h2><p>上面的验证虽说失败了，但也给我提了醒，既然释放战斗对象的逻辑代码没问题，但是绝大多数奔溃还发生在这里，那肯定是别人把它影响了，结合之前看到的内存问题，应该是有其他的逻辑写错了内存数据，导致释放战斗对象的内存时出现了问题。</p><p>这个崩溃在主分支是没有出现过的，在我开发完这个新需求之后才出现了这个问题，那么需要查新加了哪些代码，但是这个版本单单是新的文件就增加了几十个，要想从中找到一个内存问题犹如大海捞针一样。</p><h2 id="祭出法宝"><a href="#祭出法宝" class="headerlink" title="祭出法宝"></a>祭出法宝</h2><p>在大量代码中直接寻找内存问题，非寻常人所能企及，这时可以考虑借助第三方力量——比如检测工具，根据以往经验，我用的最多的内存检测工具是 <code>Valgrind</code> 和 <code>AddressSanitizer</code>，起初 <code>Valgrind</code> 用的比较多的，后来认识了 <code>AddressSanitizer</code> 之后发现使用 <code>Valgrind</code> 后程序运行太慢了，而使用 <code>AddressSanitizer</code> 虽然需要重新编译一次，但是基本不影响原有程序的运行速度，所以渐渐偏向了 <code>ASAN</code>。</p><p>但是，这次我先用了 <code>Valgrind</code>，还原代码，重新编译，调整参数后启动服务器程序，果然是半天没反应，测试多次之后居然没崩溃，查看了它的检测报告也没发现什么问题，决定换 <code>ASAN</code> 试试，因为每次用 <code>Valgrind</code> 启动和运行真的太慢了。</p><p>修改Makefile重新编译，使用 <code>AddressSanitizer</code> 来进行检测，这次更奇怪，添加了 <code>ASAN</code> 选项的程序编译后，貌似代码逻辑感觉到了它（ASAN）的存在，程序运行逻辑直接变了，原来能完整跑完的战斗逻辑，总是跑到一半因为条件不满足停下了，不过有几次跑到了最后，也出现了崩溃的情况，但是从检测报告中未查到问题的原因，仅仅找到一处内存泄漏问题，修改完崩溃问题依旧存在。</p><h2 id="屏蔽无关"><a href="#屏蔽无关" class="headerlink" title="屏蔽无关"></a>屏蔽无关</h2><p>既然上面的工具没能提供帮助，那么还得依靠我硬啃代码了，还是先来分析之前各种崩溃结果，发现每次析构对象前都给客户端发了消息，而这些消息使用了 <code>protobuf</code> 中 <code>oneof</code> 结构，这个结构之前没用过，会不会因为使用不当，把内存写坏了。</p><p>这次我没有直接去看代码的细节，而是采用了屏蔽的方式，将一些不影响战斗逻辑的消息数据精简，不断注释代码，不断发布测试，结果依旧崩溃，最后仅剩一处同步技能的协议，其中也用了 <code>oneof</code> 结构，这时我更加感觉它有问题，但是它不能被注释掉，需要通过它发消息给客户端，然后客户端请求放技能才能将战斗进行下去，测试暂时卡在这了。</p><h2 id="移形换位"><a href="#移形换位" class="headerlink" title="移形换位"></a>移形换位</h2><p>必须想一种办法把这仅剩的一条消息同步去掉，如果不给客户端的同步消息，客户端就不能通知服务器放技能，那只好服务器自己把这些事都做了，修改服务器代码，采用延迟触发的方法，来驱动整个战斗进程能进行下去，最终把仅剩的那一条消息屏蔽掉了，同时把所有的try-catch也屏蔽了。</p><p>打包部署发布服，启动测试，问题依旧存在，唉，我麻了！</p><h2 id="再请法宝"><a href="#再请法宝" class="headerlink" title="再请法宝"></a>再请法宝</h2><p>因为 <code>ASAN</code> 这个工具我一直在观察着输出的报告，并没有发现什么值得注意的问题，所以我打算换为 <code>Valgrind</code>，因为它们两个有点冲突，所以得把Makefile还原回去，重新编译再使用 <code>Valgrind</code> 来测试。</p><p>启动程序，依旧卡的像时间静止了一样，启动客户端开始了常规的疯狂测试，Duang！进程挂了，赶紧打开 <code>Valgrind</code> 的输出报告看看，亲人呐，我在里面找到了 <code>Invalid write</code> 的字样。</p><p>赶紧去查看这段报告对应的代码问题，其中包含了 <code>std::sort</code> 函数的使用，但是自定义的排序函数不满足严格弱排序规则，感觉这逻辑确实有问题，把它先注释掉来试一下。</p><h2 id="风平浪静"><a href="#风平浪静" class="headerlink" title="风平浪静"></a>风平浪静</h2><p>注释掉 <code>std::sort</code> 之后，在本地机器测试半小时未发生崩溃，重新编译打包发布，几十次测试之后也没有发生崩溃的情况，一切又恢复了平静。</p><h2 id="若有所思"><a href="#若有所思" class="headerlink" title="若有所思"></a>若有所思</h2><p><strong>如果在第一次使用工具时，我给予<code>Valgrind</code> 多一点点宽容就好了。</strong></p><p>其实事后看来好像没有多磨曲折，但是真实情况却是，前面的步骤交叉进行，经常会出现反复的情况，前前后后调试了近3天。</p><p>为什么如此执着？因为如果类似的问题不再早期发现时解决，后面要想再解决所付出的成本会更大，所以早发现早解决。</p><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><blockquote><ul><li><a href="https://github.com/google/sanitizers/wiki/AddressSanitizerLeakSanitizer" target="_blank" rel="noopener">AddressSanitizerLeakSanitizer</a></li><li><a href="https://blog.csdn.net/qq_15437629/article/details/114440930" target="_blank" rel="noopener">内存错误检测工具-AddressSanitizer（ASAN）</a></li><li><a href="https://blog.csdn.net/jq0123/article/details/103567194" target="_blank" rel="noopener">查找内存错误</a></li><li><a href="https://www.daimajiaoliu.com/daima/4795bb7ff100410" target="_blank" rel="noopener">c++中智能指针使用小结</a></li><li><a href="https://codeantenna.com/a/NwOaRboXci" target="_blank" rel="noopener">静态或者全局智能指针使用的注意几点</a></li><li><a href="https://cloud.tencent.com/developer/article/1671070" target="_blank" rel="noopener">谈谈如何利用 valgrind 排查内存错误</a></li><li><a href="https://developer.aliyun.com/article/270" target="_blank" rel="noopener">几个C++内存泄漏和越界检测工具简介</a></li><li><a href="https://zhuanlan.zhihu.com/p/75416381" target="_blank" rel="noopener">内存泄漏检测工具valgrind神器</a></li><li><a href="https://developer.aliyun.com/article/416192" target="_blank" rel="noopener">使用valgrind检查内存问题</a></li><li><a href="https://www.cnblogs.com/orangeform/archive/2011/06/05/2073338.html" target="_blank" rel="noopener">Valgrind学习笔记(一)</a></li><li><a href="https://www.codenong.com/29776831/" target="_blank" rel="noopener">关于C#：valgrind-地址是在分配大小为16的块之前的8个字节</a></li><li><a href="https://stackoverflow.com/questions/10362241/c-seg-fault-issue" target="_blank" rel="noopener">c++ seg fault issue: <strong>gnu_cxx::</strong>exchange_and_add</a></li><li><a href="https://zhuanlan.zhihu.com/p/37696341" target="_blank" rel="noopener">记一次 TCMalloc Debug 经历</a></li><li><a href="https://blog.csdn.net/shine_journey/&gt;article/details/70160036" target="_blank" rel="noopener">Segmentation fault in <strong>gnu_cxx::</strong>exchange_and_add () from /usr/lib64/libstdc++.so.6</a></li><li><a href="https://blog.csdn.net/albertsh/article/details/119523587" target="_blank" rel="noopener">C++中使用std::sort自定义排序规则时要注意的崩溃问题</a></li></ul></blockquote><hr><center><a href="https://blog.csdn.net/albertsh/article/details/121599177" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>靠想象打开未来一扇扇大门，靠理性选择其中正确的一扇~</p><p>2021-12-5 01:03:26</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;看题目来说这应该是一篇教程式文章，但为了突出“玄幻”二字，我们不讲细节只讲过程，在过程中体会解决问题的方式和方法，以及避免一些我在这个过程中绕的弯路，如果想找工具的详细使用方法可以去参考文章中翻一翻，有几篇文章写的真不错，下面我们开始扯淡啦。&lt;/p&gt;
    
    </summary>
    
      <category term="C/C++" scheme="http://AlbertGithubHome.github.io/blog/categories/C-C/"/>
    
    
      <category term="C++" scheme="http://AlbertGithubHome.github.io/blog/tags/C/"/>
    
      <category term="linux" scheme="http://AlbertGithubHome.github.io/blog/tags/linux/"/>
    
      <category term="Valgrind" scheme="http://AlbertGithubHome.github.io/blog/tags/Valgrind/"/>
    
      <category term="内存问题" scheme="http://AlbertGithubHome.github.io/blog/tags/%E5%86%85%E5%AD%98%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>linux环境下恢复rm误删的文件</title>
    <link href="http://AlbertGithubHome.github.io/blog/2021/11/25/linux%E7%8E%AF%E5%A2%83%E4%B8%8B%E6%81%A2%E5%A4%8Drm%E8%AF%AF%E5%88%A0%E7%9A%84%E6%96%87%E4%BB%B6/"/>
    <id>http://AlbertGithubHome.github.io/blog/2021/11/25/linux环境下恢复rm误删的文件/</id>
    <published>2021-11-25T15:51:31.000Z</published>
    <updated>2021-11-28T14:19:12.556Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>一提到在 linux 环境下删除文件，那绝对离不开 <code>sudo rm -rf /*</code> 这个梗，每次看到这个命令，我都想到一幅恶搞的图片：</p><p><img src="https://cdn.jsdelivr.net/gh/albertgithubhome/cdn/img/funny/rmrf.png" alt="rm"></p><a id="more"></a><p>这个『清理垃圾』的说明真是解释的“恰到好处”，据说有小白在论坛问问题，被人开玩笑的回复了 <code>sudo rm -rf /*</code> 这个命令，结果问题就解决了，人也拜拜了~</p><p>从删库到跑路，一天一个入狱小技巧，所以我们一定要谨慎使用 <code>rm -rf</code> 命令，这相当于我们在 Windows 上使用 <code>Shift+Delete</code> 组合，文件不会放到回收站中，而是直接永久删除了，在 Linux 中执行 <code>rm</code> 命令就相当于永久删除。</p><p>虽说 <code>sudo rm -rf /*</code> 危险无比，但是我们很少会直接这样写，但是 <code>rm</code> 命令还是经常用的，这不就在前几天，辛辛苦苦写的Shell脚本就被我直接 <code>rm -rf</code> 删掉了，幸亏我之前将内容打印到了控制台，否则整个脚本就白写了。</p><h1 id="rm之后还有救吗"><a href="#rm之后还有救吗" class="headerlink" title="rm之后还有救吗"></a>rm之后还有救吗</h1><p>尽管 <code>rm</code> 命令表示永久删除，但是不代表文件就一定找不回来，只是找回的几率有大有小。其实删除命令只是在文件节点中作删除标记，并不真正清除文件内容，如果删除后马上进行恢复，那么成功的概率还是很大的，但是如果其他用户一直在用这台机器，或者有一些写盘操作的进程一直在执行，那么这部分数据可能很快就会被覆盖。这时基本上就无法恢复该文件了。</p><h2 id="使用foremost找回文件"><a href="#使用foremost找回文件" class="headerlink" title="使用foremost找回文件"></a>使用foremost找回文件</h2><p><code>foremost</code> 是一个基于文件头和尾部信息以及文件的内建数据结构恢复文件的命令行工具，接下来是安装和恢复的步骤：</p><ol><li>安装 <code>foremost</code></li></ol><p>CentOS系统直接运行 <code>sudo yum install https://forensics.cert.org/centos/cert/7/x86_64//foremost-1.5.7-13.1.el7.x86_64.rpm -y</code> 命令就可以完成</p><blockquote><p>如果是Ubuntu系统请尝试命令：<code>sudo apt install foremost</code></p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-0-3-centos ~]<span class="comment"># sudo yum install https://forensics.cert.org/centos/cert/7/x86_64//foremost-1.5.7-13.1.el7.x86_64.rpm -y</span></span><br><span class="line">Loaded plugins: fastestmirror, langpacks</span><br><span class="line">Repository epel is listed more than once <span class="keyword">in</span> the configuration</span><br><span class="line">foremost-1.5.7-13.1.el7.x86_64.rpm                                                     |  46 kB  00:00:01</span><br><span class="line">Examining /var/tmp/yum-root-XJIfxM/foremost-1.5.7-13.1.el7.x86_64.rpm: foremost-1.5.7-13.1.el7.x86_64</span><br><span class="line">Marking /var/tmp/yum-root-XJIfxM/foremost-1.5.7-13.1.el7.x86_64.rpm to be installed</span><br><span class="line">Resolving Dependencies</span><br><span class="line">--&gt; Running transaction check</span><br><span class="line">---&gt; Package foremost.x86_64 0:1.5.7-13.1.el7 will be installed</span><br><span class="line">--&gt; Finished Dependency Resolution</span><br><span class="line">epel/7/x86_64                                                                          | 4.7 kB  00:00:00</span><br><span class="line">epel/7/x86_64/group_gz                                                                 |  96 kB  00:00:00</span><br><span class="line">epel/7/x86_64/updateinfo                                                               | 1.0 MB  00:00:00</span><br><span class="line">epel/7/x86_64/primary_db                                                               | 7.0 MB  00:00:01</span><br><span class="line">extras/7/x86_64                                                                        | 2.9 kB  00:00:00</span><br><span class="line">extras/7/x86_64/primary_db                                                             | 243 kB  00:00:00</span><br><span class="line">os/7/x86_64                                                                            | 3.6 kB  00:00:00</span><br><span class="line">updates/7/x86_64                                                                       | 2.9 kB  00:00:00</span><br><span class="line">updates/7/x86_64/primary_db                                                            |  12 MB  00:00:01</span><br><span class="line"></span><br><span class="line">Dependencies Resolved</span><br><span class="line"></span><br><span class="line">=====================================================================================================================</span><br><span class="line"> Package                    Arch                 Version                 Repository                           Size</span><br><span class="line">=====================================================================================================================</span><br><span class="line">Installing:</span><br><span class="line"> foremost                  x86_64           1.5.7-13.1.el7           /foremost-1.5.7-13.1.el7.x86_64          85 k</span><br><span class="line"></span><br><span class="line">Transaction Summary</span><br><span class="line">=====================================================================================================================</span><br><span class="line">Install  1 Package</span><br><span class="line"></span><br><span class="line">Total size: 85 k</span><br><span class="line">Installed size: 85 k</span><br><span class="line">Downloading packages:</span><br><span class="line">Running transaction check</span><br><span class="line">Running transaction <span class="built_in">test</span></span><br><span class="line">Transaction <span class="built_in">test</span> succeeded</span><br><span class="line">Running transaction</span><br><span class="line">  Installing : foremost-1.5.7-13.1.el7.x86_64                                                1/1</span><br><span class="line">  Verifying  : foremost-1.5.7-13.1.el7.x86_64                                                1/1</span><br><span class="line"></span><br><span class="line">Installed:</span><br><span class="line">  foremost.x86_64 0:1.5.7-13.1.el7</span><br><span class="line"></span><br><span class="line">Complete!</span><br><span class="line">[root@VM-0-3-centos ~]<span class="comment">#</span></span><br></pre></td></tr></table></figure><ol><li>创建一个测试文件</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-0-3-centos ~]<span class="comment"># echo "this is a important file"&gt;important.txt</span></span><br><span class="line">[root@VM-0-3-centos ~]<span class="comment"># pwd</span></span><br><span class="line">/root</span><br><span class="line">[root@VM-0-3-centos ~]<span class="comment"># ls</span></span><br><span class="line">connecttendis.sh  important.txt  restore  tarlist  tendis  test.iso</span><br><span class="line">[root@VM-0-3-centos ~]<span class="comment"># mkdir -p /tmp/restore</span></span><br></pre></td></tr></table></figure><ol><li>删除文件后尝试还原</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-0-3-centos ~]<span class="comment"># rm important.txt</span></span><br><span class="line">[root@VM-0-3-centos ~]<span class="comment"># foremost -i /dev/vda1 -o /tmp/restore/</span></span><br><span class="line">Processing: /dev/vda1</span><br><span class="line">|***********Segmentation fault</span><br></pre></td></tr></table></figure><ol><li>执行几分钟之后崩溃，恢复失败，打开目录查看发现：</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-0-3-centos ~]<span class="comment"># ls /tmp/restore/</span></span><br><span class="line">audit.txt  bmp  doc   exe  htm  jpg  mov  mpg  pdf  ppt   rar  sdw  sxc  sxw  wav  xls   zip</span><br><span class="line">avi        dll  docx  gif  jar  mbd  mp4  ole  png  pptx  rif  sx   sxi  vis  wmv  xlsx</span><br></pre></td></tr></table></figure><ol><li>看来与需要恢复的文件类型有关，换台机器再换一个png文件试试，先找一个showball.png测试文件，然后确认分区 <code>/dev/vda1</code></li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-0-3-centos ~]<span class="comment"># df</span></span><br><span class="line">Filesystem     1K-blocks    Used Available Use% Mounted on</span><br><span class="line">devtmpfs          930496       0    930496   0% /dev</span><br><span class="line">tmpfs             941004      24    940980   1% /dev/shm</span><br><span class="line">tmpfs             941004     508    940496   1% /run</span><br><span class="line">tmpfs             941004       0    941004   0% /sys/fs/cgroup</span><br><span class="line">/dev/vda1       51473868 6458344  42692404  14% /</span><br><span class="line">/dev/loop0        361650  361650         0 100% /mnt/iso</span><br><span class="line">tmpfs             188204       0    188204   0% /run/user/0</span><br><span class="line">[root@VM-0-3-centos ~]<span class="comment"># pwd</span></span><br><span class="line">/root</span><br><span class="line">[root@VM-0-3-centos ~]<span class="comment"># ls</span></span><br><span class="line">restore  showball.png</span><br></pre></td></tr></table></figure><ol><li>删除png文件后尝试恢复，进度条结束后即可进入指定的目录 <code>/root/restore/</code> 查看</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-0-3-centos ~]<span class="comment"># rm showball.png</span></span><br><span class="line">rm: remove regular file ‘showball.png’? y</span><br><span class="line">[root@VM-0-3-centos ~]<span class="comment"># pwd</span></span><br><span class="line">/root</span><br><span class="line">[root@VM-0-3-centos ~]<span class="comment"># foremost -t png -i /dev/vda1 -o /root/restore/</span></span><br><span class="line">Processing: /dev/vda1</span><br><span class="line">|*********************************************************************************************|</span><br></pre></td></tr></table></figure><ol><li>在指定目录下会有一个 <code>audit.txt</code> 统计文件和一个类型文件夹 <code>png</code></li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-0-3-centos ~]<span class="comment"># ll restore/</span></span><br><span class="line">total 40</span><br><span class="line">-rw-r--r-- 1 root root 24548 Nov 27 22:57 audit.txt</span><br><span class="line">drwxr-xr-- 2 root root 16384 Nov 27 22:56 png</span><br><span class="line">[root@VM-0-3-centos ~]<span class="comment"># cd restore/</span></span><br><span class="line">[root@VM-0-3-centos restore]<span class="comment"># ll png</span></span><br><span class="line">total 43764</span><br><span class="line">-rw-r--r-- 1 root root    3500 Nov 27 22:53 00367400.png</span><br><span class="line">-rw-r--r-- 1 root root    3578 Nov 27 22:53 00367408.png</span><br><span class="line">-rw-r--r-- 1 root root    3445 Nov 27 22:53 00367416.png</span><br><span class="line">-rw-r--r-- 1 root root     368 Nov 27 22:53 00367432.png</span><br><span class="line">-rw-r--r-- 1 root root     363 Nov 27 22:53 00367456.png</span><br><span class="line">-rw-r--r-- 1 root root     392 Nov 27 22:53 00367464.png</span><br><span class="line">-rw-r--r-- 1 root root     199 Nov 27 22:53 00367616.png</span><br><span class="line">...</span><br></pre></td></tr></table></figure><ol><li>png目录下的文件名都是一些编号，与原来删除的文件完全不一样了，需要根据 audit.txt 文件确认，打开文件确认一下：</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-0-3-centos restore]<span class="comment"># head audit.txt</span></span><br><span class="line">Foremost version 1.5.7 by Jesse Kornblum, Kris Kendall, and Nick Mikus</span><br><span class="line">Audit File</span><br><span class="line"></span><br><span class="line">Foremost started at Sat Nov 27 22:53:48 2021</span><br><span class="line">Invocation: foremost -t png -i /dev/vda1 -o /root/restore/</span><br><span class="line">Output directory: /root/restore</span><br><span class="line">Configuration file: /etc/foremost.conf</span><br><span class="line">------------------------------------------------------------------</span><br><span class="line">File: /dev/vda1</span><br><span class="line">Start: Sat Nov 27 22:53:48 2021</span><br><span class="line">[root@VM-0-3-centos restore]<span class="comment"># head -n 20 audit.txt</span></span><br><span class="line">Foremost version 1.5.7 by Jesse Kornblum, Kris Kendall, and Nick Mikus</span><br><span class="line">Audit File</span><br><span class="line"></span><br><span class="line">Foremost started at Sat Nov 27 22:53:48 2021</span><br><span class="line">Invocation: foremost -t png -i /dev/vda1 -o /root/restore/</span><br><span class="line">Output directory: /root/restore</span><br><span class="line">Configuration file: /etc/foremost.conf</span><br><span class="line">------------------------------------------------------------------</span><br><span class="line">File: /dev/vda1</span><br><span class="line">Start: Sat Nov 27 22:53:48 2021</span><br><span class="line">Length: 49 GB (53686025728 bytes)</span><br><span class="line"></span><br><span class="line">Num  Name (bs=512)         Size  File Offset     Comment</span><br><span class="line"></span><br><span class="line">0:  00367400.png           3 KB       188108800       (16 x 16)</span><br><span class="line">1:  00367408.png           3 KB       188112896       (16 x 16)</span><br><span class="line">2:  00367416.png           3 KB       188116992       (16 x 16)</span><br><span class="line">3:  00367432.png          368 B       188125184       (16 x 16)</span><br><span class="line">4:  00367456.png          363 B       188137472       (16 x 16)</span><br><span class="line">5:  00367464.png          392 B       188141568       (16 x 16)</span><br><span class="line">...</span><br></pre></td></tr></table></figure><ol><li>audit.txt 文件中记录着恢复文件的简要信息，这需要你知道原来删除文件的相关信息，不然就只能一个个打开查看了，我是通过分辨率查找的</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-0-3-centos restore]<span class="comment"># grep "1217" audit.txt</span></span><br><span class="line">116:    12888200.png          40 KB      6598758400       (1217 x 690)</span><br><span class="line">360:    38088960.png          40 KB      19501547520      (1217 x 690)</span><br></pre></td></tr></table></figure><ol><li>根据过滤出的信息把 <code>12888200.png</code> 打开发现就是自己“误删”的文件这就恢复好了</li></ol><h2 id="使用extundelete找回文件"><a href="#使用extundelete找回文件" class="headerlink" title="使用extundelete找回文件"></a>使用extundelete找回文件</h2><p>extundelete 支持ext3、ext4文件系统下的文件恢复，使用 <code>cat /etc/fstab</code> 可以在linux环境下查看文件系统类型</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-0-3-centos ~]<span class="comment"># cat /etc/fstab</span></span><br><span class="line">UUID=21dbe030-aa71-4b3a-8610-3b942dd447fa            /                    ext4       noatime,acl,user_xattr 1 1</span><br><span class="line">proc                 /proc                proc       defaults              0 0</span><br><span class="line">sysfs                /sys                 sysfs      noauto                0 0</span><br><span class="line">debugfs              /sys/kernel/debug    debugfs    noauto                0 0</span><br><span class="line">devpts               /dev/pts             devpts     mode=0620,gid=5       0 0</span><br><span class="line">[root@VM-0-3-centos ~]<span class="comment">#</span></span><br></pre></td></tr></table></figure><ol><li>安装依赖文件</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-0-3-centos ~]<span class="comment"># yum install e2fsprogs-devel</span></span><br><span class="line">Loaded plugins: fastestmirror, langpacks</span><br><span class="line">Repository epel is listed more than once <span class="keyword">in</span> the configuration</span><br><span class="line">Determining fastest mirrors</span><br><span class="line">epel                                                                                  | 4.7 kB  00:00:00</span><br><span class="line">extras                                                                                | 2.9 kB  00:00:00</span><br><span class="line">os                                                                                    | 3.6 kB  00:00:00</span><br><span class="line">updates                                                                               | 2.9 kB  00:00:00</span><br><span class="line">(1/2): epel/7/x86_64/updateinfo                                                       | 1.0 MB  00:00:00</span><br><span class="line">(2/2): epel/7/x86_64/primary_db                                                       | 7.0 MB  00:00:01</span><br><span class="line">Resolving Dependencies</span><br><span class="line">--&gt; Running transaction check</span><br><span class="line">---&gt; Package e2fsprogs-devel.x86_64 0:1.42.9-19.el7 will be installed</span><br><span class="line">--&gt; Finished Dependency Resolution</span><br><span class="line"></span><br><span class="line">Dependencies Resolved</span><br><span class="line"></span><br><span class="line">===============================================================================================================</span><br><span class="line"> Package                 Arch                     Version                       Repository          Size</span><br><span class="line">===============================================================================================================</span><br><span class="line">Installing:</span><br><span class="line"> e2fsprogs-devel        x86_64                    1.42.9-19.el7                     os              73 k</span><br><span class="line"></span><br><span class="line">Transaction Summary</span><br><span class="line">===============================================================================================================</span><br><span class="line">Install  1 Package</span><br><span class="line"></span><br><span class="line">Total download size: 73 k</span><br><span class="line">Installed size: 162 k</span><br><span class="line">Is this ok [y/d/N]: y</span><br><span class="line">Downloading packages:</span><br><span class="line">e2fsprogs-devel-1.42.9-19.el7.x86_64.rpm                                              |  73 kB  00:00:00</span><br><span class="line">Running transaction check</span><br><span class="line">Running transaction <span class="built_in">test</span></span><br><span class="line">Transaction <span class="built_in">test</span> succeeded</span><br><span class="line">Running transaction</span><br><span class="line">  Installing : e2fsprogs-devel-1.42.9-19.el7.x86_64                                  1/1</span><br><span class="line">  Verifying  : e2fsprogs-devel-1.42.9-19.el7.x86_64                                  1/1</span><br><span class="line"></span><br><span class="line">Installed:</span><br><span class="line">  e2fsprogs-devel.x86_64 0:1.42.9-19.el7</span><br><span class="line"></span><br><span class="line">Complete!</span><br><span class="line">[root@VM-0-3-centos ~]<span class="comment">#</span></span><br></pre></td></tr></table></figure><ol><li>下载extundelete源码</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-0-3-centos ~]<span class="comment"># wget https://src.fedoraproject.org/repo/pkgs/extundelete/extundelete-0.2.4.tar.bz2/77e626ad31433680c0a222069295d2ca/extundelete-0.2.4.tar.bz2</span></span><br><span class="line">--2021-11-28 18:36:15--  https://src.fedoraproject.org/repo/pkgs/extundelete/extundelete-0.2.4.tar.bz2/77e626ad31433680c0a222069295d2ca/extundelete-0.2.4.tar.bz2</span><br><span class="line">Resolving src.fedoraproject.org (src.fedoraproject.org)... 38.145.60.20, 38.145.60.21</span><br><span class="line">Connecting to src.fedoraproject.org (src.fedoraproject.org)|38.145.60.20|:443... connected.</span><br><span class="line">HTTP request sent, awaiting response... 200 OK</span><br><span class="line">Length: 108472 (106K) [application/x-bzip2]</span><br><span class="line">Saving to: ‘extundelete-0.2.4.tar.bz2’</span><br><span class="line"></span><br><span class="line">100%[============================================================================&gt;] 108,472     33.5KB/s   <span class="keyword">in</span> 3.2s</span><br><span class="line"></span><br><span class="line">2021-11-28 18:36:20 (33.5 KB/s) - ‘extundelete-0.2.4.tar.bz2’ saved [108472/108472]</span><br><span class="line"></span><br><span class="line">[root@VM-0-3-centos ~]<span class="comment"># ls</span></span><br><span class="line">extundelete-0.2.4.tar.bz2</span><br></pre></td></tr></table></figure><ol><li>解压extundelete源码</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-0-3-centos ~]<span class="comment"># tar -jxvf extundelete-0.2.4.tar.bz2</span></span><br><span class="line">extundelete-0.2.4/</span><br><span class="line">extundelete-0.2.4/acinclude.m4</span><br><span class="line">extundelete-0.2.4/missing</span><br><span class="line">extundelete-0.2.4/autogen.sh</span><br><span class="line">extundelete-0.2.4/aclocal.m4</span><br><span class="line">extundelete-0.2.4/configure</span><br><span class="line">extundelete-0.2.4/LICENSE</span><br><span class="line">extundelete-0.2.4/README</span><br><span class="line">extundelete-0.2.4/install-sh</span><br><span class="line">extundelete-0.2.4/config.h.in</span><br><span class="line">extundelete-0.2.4/src/</span><br><span class="line">extundelete-0.2.4/src/extundelete.cc</span><br><span class="line">extundelete-0.2.4/src/block.h</span><br><span class="line">extundelete-0.2.4/src/kernel-jbd.h</span><br><span class="line">extundelete-0.2.4/src/insertionops.cc</span><br><span class="line">extundelete-0.2.4/src/block.c</span><br><span class="line">extundelete-0.2.4/src/cli.cc</span><br><span class="line">extundelete-0.2.4/src/extundelete-priv.h</span><br><span class="line">extundelete-0.2.4/src/extundelete.h</span><br><span class="line">extundelete-0.2.4/src/jfs_compat.h</span><br><span class="line">extundelete-0.2.4/src/Makefile.in</span><br><span class="line">extundelete-0.2.4/src/Makefile.am</span><br><span class="line">extundelete-0.2.4/configure.ac</span><br><span class="line">extundelete-0.2.4/depcomp</span><br><span class="line">extundelete-0.2.4/Makefile.in</span><br><span class="line">extundelete-0.2.4/Makefile.am</span><br><span class="line">[root@VM-0-3-centos ~]<span class="comment"># cd extundelete-0.2.4/</span></span><br><span class="line">[root@VM-0-3-centos extundelete-0.2.4]<span class="comment"># ls</span></span><br><span class="line">acinclude.m4  aclocal.m4  autogen.sh   config.h.in  configure  configure.ac  depcomp</span><br><span class="line">install-sh    LICENSE     Makefile.am  Makefile.in  missing    README        src</span><br><span class="line">[root@VM-0-3-centos extundelete-0.2.4]<span class="comment">#</span></span><br></pre></td></tr></table></figure><ol><li>编译xtundelete源码安装</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-0-3-centos extundelete-0.2.4]<span class="comment"># ./configure --prefix=/usr/local/extundelete &amp;&amp; make &amp;&amp; make install</span></span><br><span class="line">Configuring extundelete 0.2.4</span><br><span class="line">Writing generated files to disk</span><br><span class="line">make -s all-recursive</span><br><span class="line">Making all <span class="keyword">in</span> src</span><br><span class="line">extundelete.cc: In <span class="keyword">function</span> ‘ext2_ino_t find_inode(ext2_filsys, ext2_filsys, ext2_inode*, std::string, int)’:</span><br><span class="line">extundelete.cc:1272:29: warning: narrowing conversion of ‘search_flags’ from ‘int’ to ‘ext2_ino_t &#123;aka unsigned int&#125;’ inside &#123; &#125; [-Wnarrowing]</span><br><span class="line">    buf, match_name2, priv, 0&#125;;</span><br><span class="line">                             ^</span><br><span class="line">Making install <span class="keyword">in</span> src</span><br><span class="line">  /usr/bin/install -c extundelete <span class="string">'/usr/local/extundelete/bin'</span></span><br><span class="line">[root@VM-0-3-centos extundelete-0.2.4]<span class="comment"># which extundelete</span></span><br><span class="line">/usr/bin/<span class="built_in">which</span>: no extundelete <span class="keyword">in</span> (/usr/<span class="built_in">local</span>/sbin:/usr/<span class="built_in">local</span>/bin:/usr/sbin:/usr/bin:/root/bin)</span><br><span class="line">[root@VM-0-3-centos extundelete-0.2.4]<span class="comment"># ll /usr/local/extundelete/bin/</span></span><br><span class="line">total 1296</span><br><span class="line">-rwxr-xr-x 1 root root 1323360 Nov 28 18:45 extundelete</span><br></pre></td></tr></table></figure><blockquote><p>如果在这一步报错 <code>configure: error: C++ compiler cannot create executables</code>，可以运行 <code>yum -y install gcc-c++</code> 命令安装编译环境</p></blockquote><ol><li>准备测试文件</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-0-3-centos examples]<span class="comment"># df -T</span></span><br><span class="line">Filesystem     Type     1K-blocks    Used Available Use% Mounted on</span><br><span class="line">devtmpfs       devtmpfs    930496       0    930496   0% /dev</span><br><span class="line">tmpfs          tmpfs       941004      24    940980   1% /dev/shm</span><br><span class="line">tmpfs          tmpfs       941004     508    940496   1% /run</span><br><span class="line">tmpfs          tmpfs       941004       0    941004   0% /sys/fs/cgroup</span><br><span class="line">/dev/vda1      ext4      51473868 6465732  42685016  14% /</span><br><span class="line">/dev/loop0     iso9660     361650  361650         0 100% /mnt/iso</span><br><span class="line">tmpfs          tmpfs       188204       0    188204   0% /run/user/0</span><br><span class="line">[root@VM-0-3-centos examples]<span class="comment"># cp ../extundelete-0.2.4.tar.bz2 .</span></span><br><span class="line">[root@VM-0-3-centos examples]<span class="comment"># ls</span></span><br><span class="line">extundelete-0.2.4.tar.bz2</span><br></pre></td></tr></table></figure><ol><li>查询文件的inode信息</li></ol><p>我们选择刚刚下载的extundelete源码包作为“误删”的文件，先查看一下信息，<code>-li</code> 可以在第一列查看文件的inode信息，examples文件夹的inode值为1311798：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-0-3-centos ~]<span class="comment"># ls examples/</span></span><br><span class="line">extundelete-0.2.4.tar.bz2</span><br><span class="line">[root@VM-0-3-centos ~]<span class="comment"># ls -li</span></span><br><span class="line">total 361676</span><br><span class="line">1311798 drwxr-xr-x 2 root root      4096 Nov 28 20:28 examples</span><br><span class="line">1310761 drwxr-xr-x 3 1000 1000      4096 Nov 28 18:45 extundelete-0.2.4</span><br><span class="line"> 918157 drwxr-xr-x 2 root root      4096 Feb 28  2021 tarlist</span><br><span class="line"> 396057 -rw-r--r-- 1 root root 370329600 Feb 27  2021 test.iso</span><br></pre></td></tr></table></figure><ol><li>删除测试文件，并用查询信息</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-0-3-centos ~]<span class="comment"># cd examples/</span></span><br><span class="line">[root@VM-0-3-centos examples]<span class="comment"># ls</span></span><br><span class="line">extundelete-0.2.4.tar.bz2</span><br><span class="line">[root@VM-0-3-centos examples]<span class="comment"># rm extundelete-0.2.4.tar.bz2 -f</span></span><br><span class="line">[root@VM-0-3-centos examples]<span class="comment"># ls</span></span><br><span class="line">[root@VM-0-3-centos examples]<span class="comment"># /usr/local/extundelete/bin/extundelete /dev/vda1 --inode 1311798</span></span><br><span class="line">NOTICE: Extended attributes are not restored.</span><br><span class="line">WARNING: EXT3_FEATURE_INCOMPAT_RECOVER is <span class="built_in">set</span>.</span><br><span class="line">The partition should be unmounted to undelete any files without further data loss.</span><br><span class="line">If the partition is not currently mounted, this message indicates</span><br><span class="line">it was improperly unmounted, and you should run fsck before continuing.</span><br><span class="line">If you decide to <span class="built_in">continue</span>, extundelete may overwrite some of the deleted</span><br><span class="line">files and make recovering those files impossible.  You should unmount the</span><br><span class="line">file system and check it with fsck before using extundelete.</span><br><span class="line">Would you like to <span class="built_in">continue</span>? (y/n)</span><br><span class="line">y</span><br><span class="line">Loading filesystem metadata ... 400 groups loaded.</span><br><span class="line">Group: 160</span><br><span class="line">Contents of inode 1311798:</span><br><span class="line">0000 | ed 41 00 00 00 10 00 00 7a 62 a3 61 1b 7a a3 61 | .A......zb.a.z.a</span><br><span class="line">0010 | 1b 7a a3 61 00 00 00 00 00 00 02 00 08 00 00 00 | .z.a............</span><br><span class="line">0020 | 00 00 08 00 0b 00 00 00 0a f3 01 00 04 00 00 00 | ................</span><br><span class="line">0030 | 00 00 00 00 00 00 00 00 01 00 00 00 79 20 50 00 | ............y P.</span><br><span class="line">0040 | 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 | ................</span><br><span class="line">0050 | 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 | ................</span><br><span class="line">0060 | 00 00 00 00 7c 63 ab ad 00 00 00 00 00 00 00 00 | ....|c..........</span><br><span class="line">0070 | 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 | ................</span><br><span class="line">0080 | 1c 00 00 00 80 da 0d a3 80 da 0d a3 94 24 04 08 | .............$..</span><br><span class="line">0090 | 7a 62 a3 61 94 24 04 08 00 00 00 00 00 00 00 00 | zb.a.$..........</span><br><span class="line">00a0 | 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 | ................</span><br><span class="line">00b0 | 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 | ................</span><br><span class="line">00c0 | 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 | ................</span><br><span class="line">00d0 | 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 | ................</span><br><span class="line">00e0 | 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 | ................</span><br><span class="line">00f0 | 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 | ................</span><br><span class="line"></span><br><span class="line">Inode is Allocated</span><br><span class="line">File mode: 16877</span><br><span class="line">Low 16 bits of Owner Uid: 0</span><br><span class="line">Size <span class="keyword">in</span> bytes: 4096</span><br><span class="line">Access time: 1638097530</span><br><span class="line">Creation time: 1638103579</span><br><span class="line">Modification time: 1638103579</span><br><span class="line">Deletion Time: 0</span><br><span class="line">Low 16 bits of Group Id: 0</span><br><span class="line">Links count: 2</span><br><span class="line">Blocks count: 8</span><br><span class="line">File flags: 524288</span><br><span class="line">File version (<span class="keyword">for</span> NFS): 2913690492</span><br><span class="line">File ACL: 0</span><br><span class="line">Directory ACL: 0</span><br><span class="line">Fragment address: 0</span><br><span class="line">Direct blocks: 127754, 4, 0, 0, 1, 5251193, 0, 0, 0, 0, 0, 0</span><br><span class="line">Indirect block: 0</span><br><span class="line">Double indirect block: 0</span><br><span class="line">Triple indirect block: 0</span><br><span class="line"></span><br><span class="line">File name                                       | Inode number | Deleted status</span><br><span class="line">.                                                 1311798</span><br><span class="line">..                                                393219</span><br><span class="line">extundelete-0.2.4.tar.bz2                         396764         Deleted</span><br><span class="line">conftest.err                                      1311833        Deleted</span><br><span class="line">[root@VM-0-3-centos examples]<span class="comment">#</span></span><br></pre></td></tr></table></figure><pre><code>我们发现 extundelete-0.2.4.tar.bz2 文件的状态为 `Deleted`</code></pre><ol><li>使用extundelete恢复文件</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-0-3-centos ~]<span class="comment"># /usr/local/extundelete/bin/extundelete /dev/vda1 --restore-directory /tmp</span></span><br><span class="line">NOTICE: Extended attributes are not restored.</span><br><span class="line">WARNING: EXT3_FEATURE_INCOMPAT_RECOVER is <span class="built_in">set</span>.</span><br><span class="line">The partition should be unmounted to undelete any files without further data loss.</span><br><span class="line">If the partition is not currently mounted, this message indicates</span><br><span class="line">it was improperly unmounted, and you should run fsck before continuing.</span><br><span class="line">If you decide to <span class="built_in">continue</span>, extundelete may overwrite some of the deleted</span><br><span class="line">files and make recovering those files impossible.  You should unmount the</span><br><span class="line">file system and check it with fsck before using extundelete.</span><br><span class="line">Would you like to <span class="built_in">continue</span>? (y/n)</span><br><span class="line">y</span><br><span class="line">Loading filesystem metadata ... 400 groups loaded.</span><br><span class="line">Loading journal descriptors ... 31842 descriptors loaded.</span><br><span class="line">*** Error <span class="keyword">in</span> `/usr/<span class="built_in">local</span>/extundelete/bin/extundelete<span class="string">': double free or corruption (!prev): 0x00000000014d6020 ***</span></span><br><span class="line"><span class="string">======= Backtrace: =========</span></span><br><span class="line"><span class="string">/lib64/libc.so.6(+0x81299)[0x7f5c08190299]</span></span><br><span class="line"><span class="string">/usr/local/extundelete/bin/extundelete[0x40cdcb]</span></span><br><span class="line"><span class="string">/usr/local/extundelete/bin/extundelete[0x40fee6]</span></span><br><span class="line"><span class="string">/usr/local/extundelete/bin/extundelete[0x4045b4]</span></span><br><span class="line"><span class="string">/lib64/libc.so.6(__libc_start_main+0xf5)[0x7f5c08131555]</span></span><br><span class="line"><span class="string">/usr/local/extundelete/bin/extundelete[0x404aef]</span></span><br><span class="line"><span class="string">======= Memory map: ========</span></span><br><span class="line"><span class="string">00400000-0041c000 r-xp 00000000 fd:01 1311942                            /usr/local/extundelete/bin/extundelete</span></span><br><span class="line"><span class="string">0061c000-0061d000 r--p 0001c000 fd:01 1311942                            /usr/local/extundelete/bin/extundelete</span></span><br><span class="line"><span class="string">0061d000-0061e000 rw-p 0001d000 fd:01 1311942                            /usr/local/extundelete/bin/extundelete</span></span><br><span class="line"><span class="string">0061e000-0061f000 rw-p 00000000 00:00 0</span></span><br><span class="line"><span class="string">014c6000-0176e000 rw-p 00000000 00:00 0                                  [heap]</span></span><br><span class="line"><span class="string">7f5c00000000-7f5c00021000 rw-p 00000000 00:00 0</span></span><br><span class="line"><span class="string">7f5c00021000-7f5c04000000 ---p 00000000 00:00 0</span></span><br><span class="line"><span class="string">7f5c07ca1000-7f5c07ef3000 rw-p 00000000 00:00 0</span></span><br><span class="line"><span class="string">7f5c07ef3000-7f5c07f0a000 r-xp 00000000 fd:01 265649                     /usr/lib64/libpthread-2.17.so</span></span><br><span class="line"><span class="string">7f5c07f0a000-7f5c08109000 ---p 00017000 fd:01 265649                     /usr/lib64/libpthread-2.17.so</span></span><br><span class="line"><span class="string">7f5c08109000-7f5c0810a000 r--p 00016000 fd:01 265649                     /usr/lib64/libpthread-2.17.so</span></span><br><span class="line"><span class="string">7f5c0810a000-7f5c0810b000 rw-p 00017000 fd:01 265649                     /usr/lib64/libpthread-2.17.so</span></span><br><span class="line"><span class="string">7f5c0810b000-7f5c0810f000 rw-p 00000000 00:00 0</span></span><br><span class="line"><span class="string">7f5c0810f000-7f5c082d2000 r-xp 00000000 fd:01 265623                     /usr/lib64/libc-2.17.so</span></span><br><span class="line"><span class="string">7f5c082d2000-7f5c084d2000 ---p 001c3000 fd:01 265623                     /usr/lib64/libc-2.17.so</span></span><br><span class="line"><span class="string">7f5c084d2000-7f5c084d6000 r--p 001c3000 fd:01 265623                     /usr/lib64/libc-2.17.so</span></span><br><span class="line"><span class="string">7f5c084d6000-7f5c084d8000 rw-p 001c7000 fd:01 265623                     /usr/lib64/libc-2.17.so</span></span><br><span class="line"><span class="string">7f5c084d8000-7f5c084dd000 rw-p 00000000 00:00 0</span></span><br><span class="line"><span class="string">7f5c084dd000-7f5c084f2000 r-xp 00000000 fd:01 291206                     /usr/lib64/libgcc_s-4.8.5-20150702.so.1</span></span><br><span class="line"><span class="string">7f5c084f2000-7f5c086f1000 ---p 00015000 fd:01 291206                     /usr/lib64/libgcc_s-4.8.5-20150702.so.1</span></span><br><span class="line"><span class="string">7f5c086f1000-7f5c086f2000 r--p 00014000 fd:01 291206                     /usr/lib64/libgcc_s-4.8.5-20150702.so.1</span></span><br><span class="line"><span class="string">7f5c086f2000-7f5c086f3000 rw-p 00015000 fd:01 291206                     /usr/lib64/libgcc_s-4.8.5-20150702.so.1</span></span><br><span class="line"><span class="string">7f5c086f3000-7f5c087f4000 r-xp 00000000 fd:01 287349                     /usr/lib64/libm-2.17.so</span></span><br><span class="line"><span class="string">7f5c087f4000-7f5c089f3000 ---p 00101000 fd:01 287349                     /usr/lib64/libm-2.17.so</span></span><br><span class="line"><span class="string">7f5c089f3000-7f5c089f4000 r--p 00100000 fd:01 287349                     /usr/lib64/libm-2.17.so</span></span><br><span class="line"><span class="string">7f5c089f4000-7f5c089f5000 rw-p 00101000 fd:01 287349                     /usr/lib64/libm-2.17.so</span></span><br><span class="line"><span class="string">7f5c089f5000-7f5c08ade000 r-xp 00000000 fd:01 266798                     /usr/lib64/libstdc++.so.6.0.19</span></span><br><span class="line"><span class="string">7f5c08ade000-7f5c08cde000 ---p 000e9000 fd:01 266798                     /usr/lib64/libstdc++.so.6.0.19</span></span><br><span class="line"><span class="string">7f5c08cde000-7f5c08ce6000 r--p 000e9000 fd:01 266798                     /usr/lib64/libstdc++.so.6.0.19</span></span><br><span class="line"><span class="string">7f5c08ce6000-7f5c08ce8000 rw-p 000f1000 fd:01 266798                     /usr/lib64/libstdc++.so.6.0.19</span></span><br><span class="line"><span class="string">7f5c08ce8000-7f5c08cfd000 rw-p 00000000 00:00 0</span></span><br><span class="line"><span class="string">7f5c08cfd000-7f5c08d3f000 r-xp 00000000 fd:01 267873                     /usr/lib64/libext2fs.so.2.4</span></span><br><span class="line"><span class="string">7f5c08d3f000-7f5c08f3f000 ---p 00042000 fd:01 267873                     /usr/lib64/libext2fs.so.2.4</span></span><br><span class="line"><span class="string">7f5c08f3f000-7f5c08f40000 r--p 00042000 fd:01 267873                     /usr/lib64/libext2fs.so.2.4</span></span><br><span class="line"><span class="string">7f5c08f40000-7f5c08f42000 rw-p 00043000 fd:01 267873                     /usr/lib64/libext2fs.so.2.4</span></span><br><span class="line"><span class="string">7f5c08f42000-7f5c08f45000 r-xp 00000000 fd:01 265948                     /usr/lib64/libcom_err.so.2.1</span></span><br><span class="line"><span class="string">7f5c08f45000-7f5c09144000 ---p 00003000 fd:01 265948                     /usr/lib64/libcom_err.so.2.1</span></span><br><span class="line"><span class="string">7f5c09144000-7f5c09145000 r--p 00002000 fd:01 265948                     /usr/lib64/libcom_err.so.2.1</span></span><br><span class="line"><span class="string">7f5c09145000-7f5c09146000 rw-p 00003000 fd:01 265948                     /usr/lib64/libcom_err.so.2.1</span></span><br><span class="line"><span class="string">7f5c09146000-7f5c09168000 r-xp 00000000 fd:01 265614                     /usr/lib64/ld-2.17.so</span></span><br><span class="line"><span class="string">7f5c092b1000-7f5c0935d000 rw-p 00000000 00:00 0</span></span><br><span class="line"><span class="string">7f5c09363000-7f5c09367000 rw-p 00000000 00:00 0</span></span><br><span class="line"><span class="string">7f5c09367000-7f5c09368000 r--p 00021000 fd:01 265614                     /usr/lib64/ld-2.17.so</span></span><br><span class="line"><span class="string">7f5c09368000-7f5c09369000 rw-p 00022000 fd:01 265614                     /usr/lib64/ld-2.17.so</span></span><br><span class="line"><span class="string">7f5c09369000-7f5c0936a000 rw-p 00000000 00:00 0</span></span><br><span class="line"><span class="string">7ffe581db000-7ffe581fc000 rw-p 00000000 00:00 0                          [stack]</span></span><br><span class="line"><span class="string">7ffe581fc000-7ffe581fe000 r-xp 00000000 00:00 0                          [vdso]</span></span><br><span class="line"><span class="string">ffffffffff600000-ffffffffff601000 r-xp 00000000 00:00 0                  [vsyscall]</span></span><br><span class="line"><span class="string">Aborted</span></span><br><span class="line"><span class="string">[root@VM-0-3-centos ~]#</span></span><br></pre></td></tr></table></figure><ol><li><p>恢复失败，此路不通！！！</p><p> 有其他人成功了，但是我测试失败，释放内存崩溃，有大神给说一下怎么改源码吗？此处存疑，后续再测，先记录一下常用参数</p></li></ol><ul><li>查询inode文件状态：<code>/usr/local/extundelete/bin/extundelete /dev/vda1 --inode 1311798</code></li><li>恢复指定节点数据：<code>/usr/local/extundelete/bin/extundelete /dev/vda1 --restore-inode 1311798</code></li><li>恢复单个文件：<code>/usr/local/extundelete/bin/extundelete /dev/vda1 --restore-file root/examples/extundelete-0.2.4.tar.bz2</code></li><li>恢复一个目录：<code>/usr/local/extundelete/bin/extundelete /dev/vda1 --restore-files root/examples</code></li><li>恢复所有文件：<code>/usr/local/extundelete/bin/extundelete /dev/vda1 --restore-all</code></li></ul><h1 id="预防误删引发的事故"><a href="#预防误删引发的事故" class="headerlink" title="预防误删引发的事故"></a>预防误删引发的事故</h1><ul><li><p>定义别名，提示删除</p><p>  定义别名 <code>alias rm=&#39;rm -i&#39;</code>， 在删除文件前会出现一个提示，使用 <code>-i</code> 选项来需要逐个确认要删除的文件，只有用户输入 <code>y</code> 才会将文件删除，但是这种做法在加上 <code>-f</code> 选项之后会失效。</p></li><li><p>禁用rm，使用mv代替</p><p>  在系统中不允许直接使用rm命令直接删除文件，需要mv文件到指定的回收目录 ~/.delete，然后配合一个定时任务，每周清空~/.delete下文件，相当于手动创建了一个回收站。</p></li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>使用foremost恢复时的目标目录最好是另外一个磁盘中的目录，把文件恢复到被删除文件所在的磁盘中很可能会在恢复前覆盖被误删的文件</li><li><code>sodu</code> 的全称目前有 <code>substitute user do</code> 和 <code>super user do</code> 两种说法，使用sudo通常是行驶超级用户的权限，但有时也可以其他普通用户，所以翻译成 <code>substitute user do</code> 代替其他用户来做更准确一点</li><li>foremost 支持的文件系统比较多，其中包括 ext2、 ext3 、vfat、NTFS、ufs、jfs 等，但是只能恢复特定格式的文件，而 extundelete 只支持ext3、ext4文件系统，不过可恢复的文件类型很多。</li><li>除了本文中总结的这两款不怎么好用的恢复软件，还有 testdisk 和 photorec 可以用来恢复，后续可以尝试一下</li><li>数据无价，请谨慎删除，可参考别名方法或禁用 <code>rm -rf</code> 来减少事故的发生</li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/121368339" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>成年人，结果导向！没有功劳的苦劳是那么的虚弱无力~</p><p>2021-11-28 22:14:54</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;一提到在 linux 环境下删除文件，那绝对离不开 &lt;code&gt;sudo rm -rf /*&lt;/code&gt; 这个梗，每次看到这个命令，我都想到一幅恶搞的图片：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/albertgithubhome/cdn/img/funny/rmrf.png&quot; alt=&quot;rm&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="linux" scheme="http://AlbertGithubHome.github.io/blog/categories/linux/"/>
    
    
      <category term="linux" scheme="http://AlbertGithubHome.github.io/blog/tags/linux/"/>
    
      <category term="rm" scheme="http://AlbertGithubHome.github.io/blog/tags/rm/"/>
    
      <category term="rf" scheme="http://AlbertGithubHome.github.io/blog/tags/rf/"/>
    
      <category term="回收站" scheme="http://AlbertGithubHome.github.io/blog/tags/%E5%9B%9E%E6%94%B6%E7%AB%99/"/>
    
  </entry>
  
  <entry>
    <title>完全图与强连通图的那些坑</title>
    <link href="http://AlbertGithubHome.github.io/blog/2021/11/17/%E5%AE%8C%E5%85%A8%E5%9B%BE%E4%B8%8E%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%9B%BE%E7%9A%84%E9%82%A3%E4%BA%9B%E5%9D%91/"/>
    <id>http://AlbertGithubHome.github.io/blog/2021/11/17/完全图与强连通图的那些坑/</id>
    <published>2021-11-16T16:40:21.000Z</published>
    <updated>2021-11-16T16:43:52.612Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>图这个数据结构相比队列、栈、树来说算是复杂多了，关于图的问题也多如牛毛，先来看一下常见的问题：</p><p><strong>若无向图 <code>G</code> 中含7个顶点，要想保证图 <code>G</code> 在任何情况下都是连通的，则需要的边数最少是几条？</strong></p><a id="more"></a><p>回答这种问题一定要注意细节，找到关键的点，不然一定会掉到坑里的。这个题关键点有以下几个：</p><ul><li>7个顶点</li><li>任何条件下连通</li><li>最少几条边</li></ul><p>其中第1点和第3点不容易出错，比较容易出现问题的是第2点，要想保证任何条件下连通，意思给定边数以后无论怎么连都能通？</p><p>先说下答案是16，至于为什么，我们后面先复习一下图相关的概念再慢慢解释，因为此刻的我连什么是强联通图都忘了~</p><h1 id="一些概念"><a href="#一些概念" class="headerlink" title="一些概念"></a>一些概念</h1><ul><li><strong>图</strong>：是由顶点V集和边E集构成，边表示了与之相连的两点间的关系，因此图可以表示成G = (V, E)</li><li><strong>有向图</strong>：是指图中的两个顶点从A到B和从B到A的含义是不同的，我们认为两点的关系是有方向的，则称其为有向图</li><li><strong>无向图</strong>：是指两点间的连接线无方向无关，这种图叫做无向图</li><li><strong>连通性</strong>：从图中一个顶点到达另一顶点，若存在至少一条路径，则称这两个顶点是连通着的</li><li><strong>连通图</strong>：在无向图中，如果任意两个顶点之间都能够连通，则称此无向图为连通图</li><li><strong>完全图</strong>：在无向图中，如果任意两个顶点之间都边直接相连，则称此无向图为完全图</li><li><strong>连通分量</strong>：若无向图不是连通图，但图中存在某个子图符合连通图的性质，则称该子图为连通分量</li><li><strong>强连通图</strong>：在有向图中，若任意两个顶点之间包含至少来回两条通路，则称此有向图为强连通图</li><li><strong>有向完全图</strong>：在有向图中，如果任意两个顶点之间都有相反的两条弧直接相连，则称此有向图为有向完全图</li><li><strong>强连通分量</strong>：若有向图不是强连通图，但图中存在某个子图符合强连通图的性质，则称该子图为强连通分量</li></ul><h1 id="关于题目的解释"><a href="#关于题目的解释" class="headerlink" title="关于题目的解释"></a>关于题目的解释</h1><p>这是一个无向图，要想在任何情况下都连通，那考虑极端情况就是孤立一个顶点，让尽可能多的边连接剩余的顶点，那会构成一个 <code>n-1</code> 个顶点的完全图，然后再考虑加一条边把剩下的孤立顶点连起来，这样得到的边数是 N = 5+4+3+2+1 + 1 = 16，用组合数表示就是</p><p>$$<br>C^2_{n-1} + 1= (n-1) * (n-2) / 2 + 1<br>$$</p><h1 id="题目变型"><a href="#题目变型" class="headerlink" title="题目变型"></a>题目变型</h1><ul><li><p>若无向图 <code>G</code> 中含7个顶点，要想保证图 <code>G</code> 在是连通的，至少需要几条边？</p><blockquote><p>答案6条，即 (n-1)</p></blockquote></li><li><p>一个包含7个顶点的无向图 <code>G</code> 为完全图，那么它共有几条边？</p><blockquote><p>答案21条，即 n * (n-1) / 2</p></blockquote></li><li><p>若有向图 <code>G</code> 中含7个顶点，要想保证图 <code>G</code> 在是强连通的，至少需要几条弧？</p><blockquote><p>答案7条，即 n，也就是形成一个环</p></blockquote></li><li><p>一个包含7个顶点的有向图 <code>G</code> 为完全图，那么它共有几条弧？</p><blockquote><p>答案42条，即 n * (n-1)</p></blockquote></li></ul><!--- 具有 7 个顶点的有向图至少应有多少条边一定成为一个强连通图？  >答案37条，即 (n-1) * (n-1) + 1--><h1 id="补充两个图例"><a href="#补充两个图例" class="headerlink" title="补充两个图例"></a>补充两个图例</h1><ul><li><strong>完全图</strong>，特点是任何两个顶点都有直接的边相连</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">graph TB</span><br><span class="line">    A((A))---B((B));</span><br><span class="line">    A((A))---C((C));</span><br><span class="line">    A((A))---D((D));</span><br><span class="line">    A((A))---E((E));</span><br><span class="line"></span><br><span class="line">    B((B))---C((C));</span><br><span class="line">    B((B))---D((D));</span><br><span class="line">    B((B))---E((E));</span><br><span class="line"></span><br><span class="line">    C((C))---D((D));</span><br><span class="line">    C((C))---E((E));</span><br><span class="line"></span><br><span class="line">    D((D))---E((E));</span><br></pre></td></tr></table></figure><ul><li><strong>强连通图</strong>，任意两点间都有路径可达</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">graph TB</span><br><span class="line">    A((A))--&gt;B((B));</span><br><span class="line">    B((B))--&gt;C((C));</span><br><span class="line">    C((C))--&gt;D((D));</span><br><span class="line">    D((D))--&gt;E((E));</span><br><span class="line">    E((E))--&gt;A((A));</span><br><span class="line">    A((A))--&gt;F((F));</span><br><span class="line">    F((F))--&gt;A((A));</span><br></pre></td></tr></table></figure><!--<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">graph TB</span><br><span class="line">    A((A))---B((B));</span><br><span class="line">    A((A))---C((C));</span><br><span class="line">    A((A))---D((D));</span><br><span class="line">    A((A))---E((E));</span><br><span class="line"></span><br><span class="line">    B((B))---A((A));</span><br><span class="line">    B((B))---C((C));</span><br><span class="line">    B((B))---D((D));</span><br><span class="line">    B((B))---E((E));</span><br><span class="line"></span><br><span class="line">    C((C))---A((A));</span><br><span class="line">    C((C))---B((B));</span><br><span class="line">    C((C))---D((D));</span><br><span class="line">    C((C))---E((E));</span><br><span class="line"></span><br><span class="line">    D((D))---A((A));</span><br><span class="line">    D((D))---C((C));</span><br><span class="line">    D((D))---B((B));</span><br><span class="line">    D((D))---E((E));</span><br><span class="line"></span><br><span class="line">    E((E))---A((A));</span><br><span class="line">    E((E))---C((C));</span><br><span class="line">    E((E))---D((D));</span><br><span class="line">    E((E))---B((B));</span><br></pre></td></tr></table></figure><p>–&gt;</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>解答关于图的问题可以从概念入手，更要注意题目中至多、至少、任何等字眼</li><li>弄清楚连通图、完全图、连通分量、强联通图、强连通分量等概念，迷糊的时候可以画一画</li><li>使用<code>mermaid</code>语法画的图确实不怎么好看，不过它强在了描述性的语言</li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/121219321"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>那些看似漫不经心的成功，其实都是蓄谋已久；那些你以为的驾轻就熟，其实都是有备而来。一个人越活越好的样子应该是不沮当下，不弃未来。你要相信，所有的事与愿违或许都是惊喜的铺垫，所有的坚持不懈终将得到岁月的奖赏~</p><p>2021-11-17 00:24:00</p></blockquote>-->]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;图这个数据结构相比队列、栈、树来说算是复杂多了，关于图的问题也多如牛毛，先来看一下常见的问题：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;若无向图 &lt;code&gt;G&lt;/code&gt; 中含7个顶点，要想保证图 &lt;code&gt;G&lt;/code&gt; 在任何情况下都是连通的，则需要的边数最少是几条？&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构" scheme="http://AlbertGithubHome.github.io/blog/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="图" scheme="http://AlbertGithubHome.github.io/blog/tags/%E5%9B%BE/"/>
    
      <category term="完全图" scheme="http://AlbertGithubHome.github.io/blog/tags/%E5%AE%8C%E5%85%A8%E5%9B%BE/"/>
    
      <category term="强连通图" scheme="http://AlbertGithubHome.github.io/blog/tags/%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>树的带权路径长度和哈夫曼树</title>
    <link href="http://AlbertGithubHome.github.io/blog/2021/11/07/%E6%A0%91%E7%9A%84%E5%B8%A6%E6%9D%83%E8%B7%AF%E5%BE%84%E9%95%BF%E5%BA%A6%E5%92%8C%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91/"/>
    <id>http://AlbertGithubHome.github.io/blog/2021/11/07/树的带权路径长度和哈夫曼树/</id>
    <published>2021-11-07T13:23:09.000Z</published>
    <updated>2021-11-13T15:12:41.863Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>树的所有叶子结点的带权路径长度之和，称为树的带权路径长度，英文缩写为 <code>WPL</code>，从百度百科中得到的信息为 “树的带权路径长度（weighted path length of tree）是2018年公布的计算机科学技术名词”，这就有点奇怪了，这个词印象中在大学课本里学过啊，怎么会是2018年的名词呢？难道我穿越了？</p><p>我赶紧找来严蔚敏、吴伟民老师编著的《数据结构》翻开来看，在2009年9月第30次印刷的图书的144页中，明确的用加粗字体描述了这样个概念：</p><blockquote><p>树的带权路径长度为树中所有叶子结点的带权路径之和，通常记作 WPL = …</p></blockquote><a id="more"></a><p>看来我没记错，不是这个百科弄错了，就是2018年重新公布了一次，并不是新的概念，它确实是一个古老的名词了，接下来可以复习一下了。</p><h1 id="树的带权路径长度"><a href="#树的带权路径长度" class="headerlink" title="树的带权路径长度"></a>树的带权路径长度</h1><p>前面虽然已经给出了定义，可什么是路径，为什么要带权，还要一步步来解释。</p><p>路径是指从树的一个结点到另一个结点所走过的部分，路径长度也可以理解为两个结点之间的距离，可以简单理解为路过的结点数，那为什么要带权呢？这和我们生活中的路径一样，并不是距离短的路所花费的时间就少，还要考虑路况、成本等多种因素，而权值就是在特定场景下我们赋予每条路的选择概率。</p><p>解释了这几个概念之后我们就可以理解文章开头的定义了，把树的每个叶子结点到根结点的带权路径长度加在一起，就是树的带权路径长度。</p><h1 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h1><p>当使用已知结点作为叶子结点，用其构成的所有树中，带全路径长度最小的树被称为最优二叉树，也就是哈夫曼树。</p><p>我们先来计算一下一颗二叉树的带权路径长度，二叉树形态如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">graph TB</span><br><span class="line">    A((ROOT))--&gt;B((P));</span><br><span class="line">    A((ROOT))--&gt;C[[2]];</span><br><span class="line">    B((P))--&gt;D[[4]];</span><br><span class="line">    B((P))--&gt;F((R));</span><br><span class="line">    F((P))--&gt;G[[7]];</span><br><span class="line">    F((P))--&gt;H[[5]];</span><br></pre></td></tr></table></figure><p>计算二叉树的带权路径长度涉及到树的层数和权值，以上面这个图为例，<code>ROOT</code> 结点所在的层数为0层，往下数字2结点为1层，数字4结点为2层，数字7结点和5结点为3层，方块中的数字代表了该叶子结点的权值，那个这颗树的带权路径长度为：</p><blockquote><p>7 <em> 3 + 5 </em> 3 + 4 <em> 2 + 2 </em> 1 = 46</p></blockquote><p>那么这是一颗最优树吗？显然不是，因为它的带权路径长度不是最短，其实从计算公式也可以看出一点门道，计算带权路径长度时会用层数乘以权值，因为权值不会变，那么唯一能减小结果的就是调整层数，一个很直观的贪心思路就是把权值大的放在低层，权值小的放在高层，这样就可以减小最后的值，比如调整成这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">graph TB</span><br><span class="line">    A((ROOT))--&gt;B((P));</span><br><span class="line">    A((ROOT))--&gt;C((P));</span><br><span class="line">    B((P))--&gt;D[[4]];</span><br><span class="line">    B((P))--&gt;F[[2]];</span><br><span class="line">    C((P))--&gt;G[[7]];</span><br><span class="line">    C((P))--&gt;H[[5]];</span><br></pre></td></tr></table></figure><p>这颗树的带权路径长度计算结果为36，比之前的值小了很多：</p><blockquote><p>4 <em> 2 + 2 </em> 2 + 7 <em> 2 + 5 </em> 2 = 36</p></blockquote><p>其实这还不是一颗最优的树，最优的结构应该是这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">graph TB</span><br><span class="line">    A((ROOT))--&gt;B[[7]];</span><br><span class="line">    A((ROOT))--&gt;C((P));</span><br><span class="line">    C((P))--&gt;D[[5]];</span><br><span class="line">    C((P))--&gt;F((P));</span><br><span class="line">    F((P))--&gt;G[[2]];</span><br><span class="line">    F((P))--&gt;H[[4]];</span><br></pre></td></tr></table></figure><p>它的带权路径长度计算结果为5，从这可以看出，树的层数高的不一定计算成的带权路径长度就大。</p><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>前面说了这么多，那么哈夫曼树有什么作用呢？你应该听说过哈夫曼编码吧，这其实就是哈夫曼树的一个应用，用来找到存放一串字符所需的最少的二进制编码。存放二进制还要单独编码吗？也许你想说什么英文字母不都是编好的吗？</p><p>单纯用字母来传递信息有一个问题，那就是会造成浪费，因为每个字母在日常交流中出现的次数并不一样，比如字母 <code>e</code> 是英文中出现频率最高的字母，而字母 <code>z</code> 却出现的很少，所以可以用较短的编码来表示 <code>e</code> 用较长的编码来表示字母 <code>z</code>，这样很直观的就能感觉到同样的信息采取这种方式处理之后会占用更小的空间。</p><h2 id="构建哈夫曼树"><a href="#构建哈夫曼树" class="headerlink" title="构建哈夫曼树"></a>构建哈夫曼树</h2><p>假设有一段英文文件，我们先统计这个文件中每个字母的出现得到次数，统计如下（别问我这个文件写的什么，我胡诌的(#^.^#)）：</p><blockquote><p>a:19<br>b:6<br>c:7<br>d:3<br>e:32<br>f:10<br>g:21<br>h:2</p></blockquote><p>因为哈夫曼树使用叶子结点来推导最终的编码，所有我们先用这些数字作为叶子结点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">graph TB</span><br><span class="line">    A[[19]]</span><br><span class="line">    B[[6]]</span><br><span class="line">    C[[7]]</span><br><span class="line">    D[[3]]</span><br><span class="line">    E[[32]]</span><br><span class="line">    F[[10]]</span><br><span class="line">    G[[21]]</span><br><span class="line">    H[[2]]</span><br></pre></td></tr></table></figure><hr><p>接下来记住一个原则，那就是<strong>找当前树的根结点和剩余叶子结点的最小的两个值，然后组成新的树杈。</strong></p><hr><p>首先，从19、6、7、3、32、10、21、2 中选择频数最小的两个叶子结点，分别为2和3，计算两个结点的和5作为根：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">graph TB</span><br><span class="line"></span><br><span class="line">    A[[19]]</span><br><span class="line">    B[[6]]</span><br><span class="line">    C[[7]]</span><br><span class="line"></span><br><span class="line">    R((5))--&gt;D[[3]]</span><br><span class="line">    R((5))--&gt;H[[2]]</span><br><span class="line"></span><br><span class="line">    E[[32]]</span><br><span class="line">    F[[10]]</span><br><span class="line">    G[[21]]</span><br></pre></td></tr></table></figure><p>接着，从19、6、7、5、32、10、21 中选择两个最小的结点，分别是根结点5和叶子结点6，计算两个结点的和11作为新的树根：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">graph TB</span><br><span class="line"></span><br><span class="line">    A[[19]]</span><br><span class="line">    C[[7]]</span><br><span class="line"></span><br><span class="line">    R2((11))--&gt;R((5))</span><br><span class="line">    R2((11))--&gt;B[[6]]</span><br><span class="line">    R((5))--&gt;D[[3]]</span><br><span class="line">    R((5))--&gt;H[[2]]</span><br><span class="line"></span><br><span class="line">    E[[32]]</span><br><span class="line">    F[[10]]</span><br><span class="line">    G[[21]]</span><br></pre></td></tr></table></figure><p>然后，从19、7、11、32、10、21 中选择两个最小的结点，这次都是叶子结点，分别为7和10，计算两个结点的和17形成一颗新的树：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">graph TB</span><br><span class="line"></span><br><span class="line">    A[[19]]</span><br><span class="line"></span><br><span class="line">    R2((11))--&gt;R((5))</span><br><span class="line">    R2((11))--&gt;B[[6]]</span><br><span class="line">    R((5))--&gt;D[[3]]</span><br><span class="line">    R((5))--&gt;H[[2]]</span><br><span class="line"></span><br><span class="line">    E[[32]]</span><br><span class="line"></span><br><span class="line">    R3((17))--&gt;C[[7]]</span><br><span class="line">    R3((17))--&gt;F[[10]]</span><br><span class="line"></span><br><span class="line">    G[[21]]</span><br></pre></td></tr></table></figure><p>继续，从 19、11、32、17、21 中选择最小的 11 和 17 这两个树的根结点，计算两个结点的和 28 作为组合树的根结点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">graph TB</span><br><span class="line"></span><br><span class="line">    A[[19]]</span><br><span class="line"></span><br><span class="line">    R2((11))--&gt;R((5))</span><br><span class="line">    R2((11))--&gt;B[[6]]</span><br><span class="line">    R((5))--&gt;D[[3]]</span><br><span class="line">    R((5))--&gt;H[[2]]</span><br><span class="line"></span><br><span class="line">    E[[32]]</span><br><span class="line"></span><br><span class="line">    R3((17))--&gt;C[[7]]</span><br><span class="line">    R3((17))--&gt;F[[10]]</span><br><span class="line"></span><br><span class="line">    R4((28))--&gt;R2((11))</span><br><span class="line">    R4((28))--&gt;R3((17))</span><br><span class="line"></span><br><span class="line">    G[[21]]</span><br></pre></td></tr></table></figure><p>然后，从 19、32、28、21 中选择最小的 19 和 21 这两个叶子结点，计算两个结点的和 40 形成一棵新的树：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">graph TB</span><br><span class="line"></span><br><span class="line">    R2((11))--&gt;R((5))</span><br><span class="line">    R2((11))--&gt;B[[6]]</span><br><span class="line">    R((5))--&gt;D[[3]]</span><br><span class="line">    R((5))--&gt;H[[2]]</span><br><span class="line"></span><br><span class="line">    E[[32]]</span><br><span class="line"></span><br><span class="line">    R3((17))--&gt;C[[7]]</span><br><span class="line">    R3((17))--&gt;F[[10]]</span><br><span class="line"></span><br><span class="line">    R4((28))--&gt;R2((11))</span><br><span class="line">    R4((28))--&gt;R3((17))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    R5((40))--&gt;A[[19]]</span><br><span class="line">    R5((40))--&gt;G[[21]]</span><br></pre></td></tr></table></figure><p>接下来，从 32、28、 40 中选择最小的 32 和 28 这两个结点，求和 60 构成一棵树，根结点为60：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">graph TB</span><br><span class="line"></span><br><span class="line">    R2((11))--&gt;R((5))</span><br><span class="line">    R2((11))--&gt;B[[6]]</span><br><span class="line">    R((5))--&gt;D[[3]]</span><br><span class="line">    R((5))--&gt;H[[2]]</span><br><span class="line"></span><br><span class="line">    R3((17))--&gt;C[[7]]</span><br><span class="line">    R3((17))--&gt;F[[10]]</span><br><span class="line"></span><br><span class="line">    R4((28))--&gt;R2((11))</span><br><span class="line">    R4((28))--&gt;R3((17))</span><br><span class="line"></span><br><span class="line">    R6((60))--&gt;E[[32]]</span><br><span class="line">    R6((60))--&gt;R4((28))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    R5((40))--&gt;A[[19]]</span><br><span class="line">    R5((40))--&gt;G[[21]]</span><br></pre></td></tr></table></figure><p>最后把剩下的 40 和 60 两个结点连在一起，和为100就得到了一颗哈夫曼树：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">graph TB</span><br><span class="line"></span><br><span class="line">    R2((11))--&gt;R((5))</span><br><span class="line">    R2((11))--&gt;B[[6]]</span><br><span class="line">    R((5))--&gt;D[[3]]</span><br><span class="line">    R((5))--&gt;H[[2]]</span><br><span class="line"></span><br><span class="line">    R3((17))--&gt;C[[7]]</span><br><span class="line">    R3((17))--&gt;F[[10]]</span><br><span class="line"></span><br><span class="line">    R4((28))--&gt;R2((11))</span><br><span class="line">    R4((28))--&gt;R3((17))</span><br><span class="line"></span><br><span class="line">    R6((60))--&gt;E[[32]]</span><br><span class="line">    R6((60))--&gt;R4((28))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    R5((40))--&gt;A[[19]]</span><br><span class="line">    R5((40))--&gt;G[[21]]</span><br><span class="line"></span><br><span class="line">    R7((100))--&gt;R6((60))</span><br><span class="line">    R7((100))--&gt;R5((40))</span><br></pre></td></tr></table></figure><p>按照上面的定义来算，这颗二叉树的带权路径长度为：</p><blockquote><p>WPL = 2 <em> (32 + 19 + 21) + 4 </em> (6 + 7 + 10) + 5 * (3 + 2) = 261</p></blockquote><p>其实还有另一种计算带权路径长度的方法，那就是把除根结点以外的所有数字都加起来：</p><blockquote><p>WPL = 60 + 40 + 28 + 32 + 19 + 21 + 11 + 17 + 5 + 6 + 7 + 10 + 3 + 2 = 261</p></blockquote><h2 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h2><p>我们用统计数量的字母来替换频数，然后在树的左右指针上分别标上数字就可以得到：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">graph TB</span><br><span class="line"></span><br><span class="line">    R2((11))--0--&gt;R((5))</span><br><span class="line">    R2((11))--1--&gt;B[[b]]</span><br><span class="line">    R((5))--0--&gt;D[[d]]</span><br><span class="line">    R((5))--1--&gt;H[[h]]</span><br><span class="line"></span><br><span class="line">    R3((17))--0--&gt;C[[c]]</span><br><span class="line">    R3((17))--1--&gt;F[[f]]</span><br><span class="line"></span><br><span class="line">    R4((28))--0--&gt;R2((11))</span><br><span class="line">    R4((28))--1--&gt;R3((17))</span><br><span class="line"></span><br><span class="line">    R6((60))--1--&gt;E[[e]]</span><br><span class="line">    R6((60))--0--&gt;R4((28))</span><br><span class="line"></span><br><span class="line">    R5((40))--0--&gt;A[[a]]</span><br><span class="line">    R5((40))--1--&gt;G[[g]]</span><br><span class="line"></span><br><span class="line">    R7((100))--0--&gt;R6((60))</span><br><span class="line">    R7((100))--1--&gt;R5((40))</span><br></pre></td></tr></table></figure><p>至此我们就可以给出编码了呀，从根结点走到每个叶子结点路径上经过的0和1就是编码内容，编码表如下：</p><blockquote><p>a–&gt;10<br>b–&gt;0001<br>c–&gt;0010<br>d–&gt;00000<br>e–&gt;01<br>f–&gt;0011<br>g–&gt;11<br>h–&gt;00001</p></blockquote><p>要想等长编码这8个字母最少需要4个bit，采用哈夫曼编码以后最少用2bit，最多用5bit，这是考虑了出现频率以后的结果，在传输大量数据的时候，采用哈夫曼编码会是一个更优的解决方案。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>树的带权路径长度是指树的所有叶子结点的带权路径长度之和，简称WPL</li><li>当使用已知结点作为叶子结点，用其构造的所有树中，带全路径长度最小的树被称为最优二叉树，也就是哈夫曼树</li><li>哈夫曼树可以用来编码，采用哈夫曼编码后的信息可以可以使空间利用更加高效</li><li>哈夫曼树的构造并不是唯一的，相同的权值结点完全可以构造出不同形态的哈夫曼树，甚至连高度都不同</li><li>哈夫曼编码还保证了长编码不与短编码冲突的的特点，这个后续有时间我们再聊</li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/121072796" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>埋下高昂的头颅，为一飞冲天的壮举积蓄力量，我就在这静静的等，期待你的绽放~</p><p>2021-11-12 00:42:33</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;树的所有叶子结点的带权路径长度之和，称为树的带权路径长度，英文缩写为 &lt;code&gt;WPL&lt;/code&gt;，从百度百科中得到的信息为 “树的带权路径长度（weighted path length of tree）是2018年公布的计算机科学技术名词”，这就有点奇怪了，这个词印象中在大学课本里学过啊，怎么会是2018年的名词呢？难道我穿越了？&lt;/p&gt;
&lt;p&gt;我赶紧找来严蔚敏、吴伟民老师编著的《数据结构》翻开来看，在2009年9月第30次印刷的图书的144页中，明确的用加粗字体描述了这样个概念：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;树的带权路径长度为树中所有叶子结点的带权路径之和，通常记作 WPL = …&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="数据结构" scheme="http://AlbertGithubHome.github.io/blog/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="WPL" scheme="http://AlbertGithubHome.github.io/blog/tags/WPL/"/>
    
      <category term="哈夫曼树" scheme="http://AlbertGithubHome.github.io/blog/tags/%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91/"/>
    
      <category term="带权路径长度" scheme="http://AlbertGithubHome.github.io/blog/tags/%E5%B8%A6%E6%9D%83%E8%B7%AF%E5%BE%84%E9%95%BF%E5%BA%A6/"/>
    
      <category term="树" scheme="http://AlbertGithubHome.github.io/blog/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>MD5是用来加密的吗？BCrypt又是什么呢？</title>
    <link href="http://AlbertGithubHome.github.io/blog/2021/10/31/MD5%E6%98%AF%E7%94%A8%E6%9D%A5%E5%8A%A0%E5%AF%86%E7%9A%84%E5%90%97%EF%BC%9FBCrypt%E5%8F%88%E6%98%AF%E4%BB%80%E4%B9%88%E5%91%A2%EF%BC%9F/"/>
    <id>http://AlbertGithubHome.github.io/blog/2021/10/31/MD5是用来加密的吗？BCrypt又是什么呢？/</id>
    <published>2021-10-31T10:29:03.000Z</published>
    <updated>2021-10-31T16:25:41.220Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近经常看到一种关于 <code>MD5</code> 的说法，比如某某系统的登录模块使用了 <code>MD5</code> 加密算法，保证了用户密码的安全。那么 <code>MD5</code> 究竟是不是一种加密算法呢？从概念上来说『加密』对应的是『解密』，我们把数据采用某种方式加密之后，可以在之后的某一时刻进行解密来获得原始数据，照此观点来说 <code>MD5</code> 并不是一种加密算法，它只能把原文加密成密文，而不能将密文解密成原文。但是 <code>MD5</code> 确实把明文变成了不容易被破解的密文，达到了 “加密” 的目的，好像说它可以用来加密勉强也可以。</p><a id="more"></a><p>更准确的说法，<code>MD5</code> 是一种哈希算法，又叫散列算法或者摘要算法，是一类把任意长度数据转换为定长数据的算法统称，它广泛应用于错误检查，经常通过计算 <code>MD5</code> 来检验下载到的文件的完整性，优秀的哈希算法通常需要具有低碰撞概率，<code>MD5</code> 就是其中的一种。</p><h1 id="MD5的八卦"><a href="#MD5的八卦" class="headerlink" title="MD5的八卦"></a>MD5的八卦</h1><blockquote><p>可用于处理密码，是不可逆的</p></blockquote><p>刚刚前面已经提到它可以把原始数据变成定长的摘要信息，而不能把摘要信息再还原成原始数据。就比如 <code>110+119=229</code>，通过原始信息 110 和 119 可以转化成摘要信息229，而已知229却无法知道它是由那两个数相加得到的，当然这个例子只是象征性的，它的碰撞率太高了。</p><p>既然不可逆，那么怎样才能判断密码信息呢？这可以利用比较hash值来判断，我们在注册时计算密码的 <code>MD5</code> 值入库，当玩家登录时再次使用玩家输入的明文密码再次计算 MD5 值，如果一致就验证成功，这就是为什么哈希算法要有低碰撞率了。</p><blockquote><p>MD5现在不太安全了</p></blockquote><p>因为MD5算法是确定，用一个字符串计算出来的哈希值也是固定的，所以出现了一些针对该算法的破解方法。</p><ol><li>暴力枚举法：因为可以不断尝试，并且随着计算机硬件能力的快速提升，使得这种方法来破解短密码称为了可能</li><li>字典法：也就是撞库，黑客通过收集互联网已泄露的用户和密码信息，生成对应的字典表，通过撞库来完成破解</li><li>彩虹表：在字典法的基础上改进，以时间换空间，使用预计算的哈希链集来降低存储空间，是目前最常用的方法</li></ol><blockquote><p>MD5可以为自己代言（带盐）</p></blockquote><p>对于固定的哈希算法，相同的输入会得到相同的输出，那么针对MD5算法只需要准备一个字典或者一个彩虹表就可以一直沿用，如果在原有的密码上加点料，那么即使两个用户使用相同的密码，因为盐不同，得到的输出值也就不同，那么破解难度大大提高了。</p><h1 id="BCrypt加密"><a href="#BCrypt加密" class="headerlink" title="BCrypt加密"></a>BCrypt加密</h1><p>上面说过单独使用MD5加密不太安全，但是加盐以后可以大大提高破解的难度，为什么BCrypt加密火了起来，大有代替MD5的趋势~</p><p>BCrypt 是 Niels Provos 和 DavidMazières 基于 Blowfish 密码设计的，是 OpenBSD 的默认密码哈希算法。 目前有针对 C、C++、Python 、C# 、Java、JS、PHP 等多种编程语言的实现，使用起来非常方便。</p><p>它相对于MD5有哪些优势呢？</p><h2 id="自己加盐"><a href="#自己加盐" class="headerlink" title="自己加盐"></a>自己加盐</h2><p>首先他不用自己来管理用户的“盐”，如果所有的用户使用相同的盐不太安全，每个人生成不同的盐，需要自己单独来存储使用，而BCrypt内部自己实现了随机加盐处理，可以实现每次加密后的密文是不一样的。</p><p>对于同一个密码，Bcrypt每次生成的哈希结果都不一样，那么它是如何进行校验的？</p><p>其实BCrypt算法将盐随机生成并混入最终加密后的密码之中，验证时会自动提取，无需单独提供“盐”信息，生成的Hash值通常格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$2b$12$ABJPtagiuqTVhnIPvOLoB.hbIlZ3joRkpck3joDsX6xe3O2KShuty</span><br></pre></td></tr></table></figure><p>其中 <code>$</code> 为分隔符，<code>2b</code>是bcrypt加密版本号，<code>12</code>是工作负载，紧接着22位是盐，剩下的字符串就是密码的密文了。</p><p>看到这个密码仿佛就是明牌了跟对手打呀，如果你真的获得了加密后的密码，那你就知道了加密版本、工作负载，盐的信息，这样会不会很危险呢？是挺危险的，但是即使你使用MD5加密，那个盐也是要存储的，也会面临同样的问题，另外BCrypt还有其他的法宝。</p><h2 id="工作负载"><a href="#工作负载" class="headerlink" title="工作负载"></a>工作负载</h2><p>BCrypt的工作负载有时也称为加密轮数、成本因子等等（一提到工作负载就想到比特币，数字游戏而已），目的就是提高破解难度，带来的缺点就是速度慢。MD5的Hash值生成通常是微妙级别的，但是Bcrypt一个密码出来的时间比较长，Python环境使用默认12轮负载需要0.25秒生成一个密码（C++环境需要进一步测试）。</p><p>所以如果使用Bcrypt，需要考虑它的成本，负责做认证的服务器，可能在原基础上扩容几十倍或者几百倍，它是靠把计算成本提高多个数量级来换取安全的。</p><h2 id="使用方便"><a href="#使用方便" class="headerlink" title="使用方便"></a>使用方便</h2><p>目前在各大主流编程语言中都可以方便的使用BCrypt相关函数，下面以Python为例：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> bcrypt</span><br><span class="line"></span><br><span class="line">passwd = <span class="string">b'123456nx'</span></span><br><span class="line"></span><br><span class="line">start = time.time()</span><br><span class="line">salt = bcrypt.gensalt(<span class="number">12</span>)</span><br><span class="line">pwsd = bcrypt.hashpw(passwd, salt)</span><br><span class="line"></span><br><span class="line">cost = time.time() - start</span><br><span class="line">print(<span class="string">"[salt]"</span>, salt)</span><br><span class="line">print(<span class="string">"[pwsd]"</span>, pwsd)</span><br><span class="line">print(<span class="string">"[cost]"</span>, cost)</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[salt] b&apos;$2b$12$lEsQ9dGnRe2vKfFDRUZYAO&apos;</span><br><span class="line">[pwsd] b&apos;$2b$12$lEsQ9dGnRe2vKfFDRUZYAOmmmdlgWfHfNO94C/UqCKGGRioruF77u&apos;</span><br><span class="line">[cost] 0.24636435508728027</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li><code>MD5</code>从严格意义上来说并不是一个加密算法，更准确的说法应该是单向散列算法，因为无法逆向进行解密</li><li>通过 <code>MD5</code> 计算后的密码，可以使用的破解方法有暴力枚举、字典表、彩虹表等，其中<a href="http://project-rainbowcrack.com/table.htm" target="_blank" rel="noopener">《彩虹表》</a>最常用</li><li><code>BCrypt</code>算法可以随机生成盐，并将盐信息混入最终加密后的密码之中，验证时会自动提取</li><li><code>BCrypt</code>算法引入了工作负载机制，生成Hash值的时间大大延长，相应的破解难度也随之增加</li><li><code>BCrypt</code>算法在Python环境下使用默认参数需0.25秒生成一个密码，选用这种方式需考虑时间成本</li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/120941471" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>以史为鉴，理解今天，展望未来~<br>时刻准备着，这次的大团圆无需担心，可能某个清晨的早间新闻，你们已经回来了！</p><p>2021-11-1 00:21:44</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;最近经常看到一种关于 &lt;code&gt;MD5&lt;/code&gt; 的说法，比如某某系统的登录模块使用了 &lt;code&gt;MD5&lt;/code&gt; 加密算法，保证了用户密码的安全。那么 &lt;code&gt;MD5&lt;/code&gt; 究竟是不是一种加密算法呢？从概念上来说『加密』对应的是『解密』，我们把数据采用某种方式加密之后，可以在之后的某一时刻进行解密来获得原始数据，照此观点来说 &lt;code&gt;MD5&lt;/code&gt; 并不是一种加密算法，它只能把原文加密成密文，而不能将密文解密成原文。但是 &lt;code&gt;MD5&lt;/code&gt; 确实把明文变成了不容易被破解的密文，达到了 “加密” 的目的，好像说它可以用来加密勉强也可以。&lt;/p&gt;
    
    </summary>
    
      <category term="加密与认证" scheme="http://AlbertGithubHome.github.io/blog/categories/%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%AE%A4%E8%AF%81/"/>
    
    
      <category term="MD5" scheme="http://AlbertGithubHome.github.io/blog/tags/MD5/"/>
    
      <category term="BCrypt" scheme="http://AlbertGithubHome.github.io/blog/tags/BCrypt/"/>
    
      <category term="Hash" scheme="http://AlbertGithubHome.github.io/blog/tags/Hash/"/>
    
      <category term="单项散列" scheme="http://AlbertGithubHome.github.io/blog/tags/%E5%8D%95%E9%A1%B9%E6%95%A3%E5%88%97/"/>
    
      <category term="加密算法" scheme="http://AlbertGithubHome.github.io/blog/tags/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>linux环境下从路径字符串中截取目录和文件名信息</title>
    <link href="http://AlbertGithubHome.github.io/blog/2021/10/24/linux%E7%8E%AF%E5%A2%83%E4%B8%8B%E4%BB%8E%E8%B7%AF%E5%BE%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E6%88%AA%E5%8F%96%E7%9B%AE%E5%BD%95%E5%92%8C%E6%96%87%E4%BB%B6%E5%90%8D%E4%BF%A1%E6%81%AF/"/>
    <id>http://AlbertGithubHome.github.io/blog/2021/10/24/linux环境下从路径字符串中截取目录和文件名信息/</id>
    <published>2021-10-24T09:01:30.000Z</published>
    <updated>2021-10-24T13:59:57.825Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>之前在文章<a href="https://blog.csdn.net/albertsh/article/details/120818017" target="_blank" rel="noopener">《.bat批处理（十）：从路径字符串中截取盘符、文件名、后缀名等信息》</a>中总结了在批处理文件中，也就是Windows环境下怎样从路径字符串中截取文件名、盘符等信息，利用的是Windows的扩展变量，而这种截取路径的需求在linux脚本中也很常见，实现方法相比批处理脚本而言要简单一些，下面列举一下常见的方法。</p><a id="more"></a><h1 id="使用系统命令完成路径截取"><a href="#使用系统命令完成路径截取" class="headerlink" title="使用系统命令完成路径截取"></a>使用系统命令完成路径截取</h1><p>针对于路径的操作很基础，所以在linux环境下提供了专门的命令来完成路径字符串的截取工作，分别是 <code>basename</code> 和 <code>dirname</code>，从名字就可以很容易知道他们的作用，具体的使用方法如下：</p><h2 id="使用-basename-命令获取文件名"><a href="#使用-basename-命令获取文件名" class="headerlink" title="使用 basename 命令获取文件名"></a>使用 basename 命令获取文件名</h2><p>获取文件名时直接在命令后面添加待截取的路径即可，表现如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:/mnt/d/data/shell$ basename /mnt/d/data/shell/test.txt</span><br><span class="line">test.txt</span><br></pre></td></tr></table></figure><p>在shell脚本的写法通常是这样：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mypath=/mnt/d/data/shell/test.txt</span><br><span class="line"><span class="built_in">echo</span> $(basename <span class="variable">$mypath</span>)</span><br></pre></td></tr></table></figure><p>运行之后得到的带有后缀的文件名，如果想去掉后缀使用 <code>-s</code> 参数指定要去掉的后缀即可：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:/mnt/d/data/shell$ basename -s .txt /mnt/d/data/shell/test.txt</span><br><span class="line"><span class="built_in">test</span></span><br></pre></td></tr></table></figure><p><code>-s</code> 选项也可省略，将后缀名直接放到完整路径后面也可以：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:/mnt/d/data/shell$ basename /mnt/d/data/shell/test.txt .txt</span><br><span class="line"><span class="built_in">test</span></span><br></pre></td></tr></table></figure><p>其实 <code>-s</code> 参数后面不一定非得加后缀名，它就是在结果的末尾去掉匹配的字符串，所以可以指定任何结尾字符：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:/mnt/d/data/shell$ basename /mnt/d/data/shell/test.txt xt</span><br><span class="line">test.t</span><br></pre></td></tr></table></figure><h2 id="使用-dirname-命令获取目录名"><a href="#使用-dirname-命令获取目录名" class="headerlink" title="使用 dirname 命令获取目录名"></a>使用 dirname 命令获取目录名</h2><p>顾名思义 <code>dirname</code> 就是获取目录名的命令，直接在命令后面跟上待截取的路径即可：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:/mnt/d/data/shell$ dirname /mnt/d/data/shell/test.txt</span><br><span class="line">/mnt/d/data/shell</span><br></pre></td></tr></table></figure><p>这个命令不仅可以获取文件所在目录，还可以获取目录的上一级目录，实际上它处理的仅仅是字符串，截取的目标字符也是 <code>/</code>，并不要求目录是有效的</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:/mnt/d/data/shell$ dirname /mnt/d/data/</span><br><span class="line">/mnt/d</span><br></pre></td></tr></table></figure><h1 id="利用变量提取操作完成截取"><a href="#利用变量提取操作完成截取" class="headerlink" title="利用变量提取操作完成截取"></a>利用变量提取操作完成截取</h1><p>通过对 <code>${var}</code> 表达式进行变形可以完成对原变量的部分提取和替换，下面先列举一些主要的截取操作：</p><table><thead><tr><th style="text-align:left">表达式</th><th style="text-align:center">含义</th><th style="text-align:center">示例</th><th style="text-align:center">结果</th></tr></thead><tbody><tr><td style="text-align:left"><code>${var}</code></td><td style="text-align:center"><code>var</code>字符串原始值</td><td style="text-align:center"><code>${var}</code></td><td style="text-align:center">^Can you can a can as a canner can can a can$</td></tr><tr><td style="text-align:left"><code>${\#var}</code></td><td style="text-align:center"><code>var</code>字符串的长度</td><td style="text-align:center"><code>${\#var}</code></td><td style="text-align:center">^43$</td></tr><tr><td style="text-align:left"><code>${var:pos}</code></td><td style="text-align:center">在字符串<code>var</code>中从位置pos提取子串</td><td style="text-align:center"><code>${var:30}</code></td><td style="text-align:center">^can can a can$</td></tr><tr><td style="text-align:left"><code>${var:pos:len}</code></td><td style="text-align:center">在<code>var</code>中从位置pos提取长度为len的子串</td><td style="text-align:center"><code>${var:30:5}</code></td><td style="text-align:center">^can c$</td></tr><tr><td style="text-align:left"><code>${var#substr}</code></td><td style="text-align:center">在<code>var</code>左侧删除最短匹配$substr的子串</td><td style="text-align:center"><code>${var#*can a}</code></td><td style="text-align:center">^ can as a canner can can a can$</td></tr><tr><td style="text-align:left"><code>${var##substr}</code></td><td style="text-align:center">在<code>var</code>左侧删除最长匹配$substr的子串</td><td style="text-align:center"><code>${var##*can a}</code></td><td style="text-align:center">^ can$</td></tr><tr><td style="text-align:left"><code>${var%substr}</code></td><td style="text-align:center">在<code>var</code>右侧删除最短匹配$substr的子串</td><td style="text-align:center"><code>${var%can a*}</code></td><td style="text-align:center">^Can you can a can as a canner can $</td></tr><tr><td style="text-align:left"><code>${var%%substr}</code></td><td style="text-align:center">在<code>var</code>右侧删除最长匹配$substr的子串</td><td style="text-align:center"><code>${var%%can a*}</code></td><td style="text-align:center">^Can you $</td></tr></tbody></table><p>好了，知道了这些规则我们就可以利用这些截取规则，来完成截取目录的需求了，下面假设 var 的值为 <code>./d/data/shell/test.txt</code> 开始具体操作。</p><h2 id="截取根目录"><a href="#截取根目录" class="headerlink" title="截取根目录"></a>截取根目录</h2><p>要想截取根目录就是要把第一个 <code>/</code> 后面的内容删除就可以了，使用 <code>${var%%/*}</code> 在<code>var</code>右侧删除最长匹配<code>/*</code>的子串，结果就只剩下 <code>.</code> 了:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:/mnt/d/data/shell$ var=<span class="string">"./d/data/shell/test.txt"</span></span><br><span class="line">albert@home-pc:/mnt/d/data/shell$ <span class="built_in">echo</span> <span class="variable">$&#123;var%%/*&#125;</span></span><br><span class="line">.</span><br></pre></td></tr></table></figure><h2 id="截取文件名"><a href="#截取文件名" class="headerlink" title="截取文件名"></a>截取文件名</h2><p>截取文件名需要把最后一个 <code>/</code>前面的内容删除，使用 <code>${var##*/}</code> 在<code>var</code>左侧删除最长匹配 <code>*/</code> 的子串，结果为包含后缀的文件名：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:/mnt/d/data/shell$ var=<span class="string">"./d/data/shell/test.txt"</span></span><br><span class="line">albert@home-pc:/mnt/d/data/shell$ <span class="built_in">echo</span> <span class="variable">$&#123;var##*/&#125;</span></span><br><span class="line">test.txt</span><br></pre></td></tr></table></figure><h2 id="截取文件后缀"><a href="#截取文件后缀" class="headerlink" title="截取文件后缀"></a>截取文件后缀</h2><p>截取文件名后缀与截取文件名类似，需要包最后一个 <code>.</code> 前面的内容删除，使用 <code>${var##*.}</code> 在<code>var</code>左侧删除最长匹配 <code>*.</code> 的子串，只保留后缀内容：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:/mnt/d/data/shell$ var=<span class="string">"./d/data/shell/test.txt"</span></span><br><span class="line">albert@home-pc:/mnt/d/data/shell$ <span class="built_in">echo</span> <span class="variable">$&#123;var##*.&#125;</span></span><br><span class="line">txt</span><br></pre></td></tr></table></figure><h2 id="截取文件所在的目录"><a href="#截取文件所在的目录" class="headerlink" title="截取文件所在的目录"></a>截取文件所在的目录</h2><p>截取文件坐在目录就是只删除文件名，把文件名前面的 <code>/</code> 包括之前的内容进行保留，使用 <code>${var%/*}</code> 在<code>var</code>右侧删除最短匹配 <code>/*</code> 的子串：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:/mnt/d/data/shell$ var=<span class="string">"./d/data/shell/test.txt"</span></span><br><span class="line">albert@home-pc:/mnt/d/data/shell$ <span class="built_in">echo</span> <span class="variable">$&#123;var%/*&#125;</span></span><br><span class="line">./d/data/shell</span><br></pre></td></tr></table></figure><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><p>假设 var 的值为 <code>./d/data/shell/test.txt</code>，具体实现的表格总结如下：</p><table><thead><tr><th style="text-align:left">需求</th><th style="text-align:center">表达式</th><th style="text-align:center">结果</th></tr></thead><tbody><tr><td style="text-align:left">根目录</td><td style="text-align:center"><code>${var%%/*}</code></td><td style="text-align:center"><code>.</code></td></tr><tr><td style="text-align:left">文件名</td><td style="text-align:center"><code>${var##*/}</code></td><td style="text-align:center"><code>test.txt</code></td></tr><tr><td style="text-align:left">文件后缀</td><td style="text-align:center"><code>${var##*.}</code></td><td style="text-align:center"><code>txt</code></td></tr><tr><td style="text-align:left">文件所在目录</td><td style="text-align:center"><code>${var%/*}</code></td><td style="text-align:center"><code>./d/data/shell</code></td></tr></tbody></table><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li><code>basename</code> 和 <code>dirname</code> 是linux环境下专门截取文件名和目录名的命令工具</li><li>处理文件路径截取的通常使用 <code>${var}</code> 形式的变量提取方法，这种方法很方便，但不仅限于相关目录的处理</li><li>常用截取表达式：文件名 <code>${var##*/}</code>、文件后缀 <code>${var##*.}</code>、文件所在目录 <code>${var%/*}</code></li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/120818017" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>今年的1024和去年一样又是周末，凌晨登陆冰封了4、5年的对战平台账号，看着全部灰色的dota好友列表，再想凑齐所有人一起开黑几乎不可能了。<br>打了半宿输多赢少，还是那个手残的我。出了新的英雄，添了新的装备，面对这个曾经挚爱的游戏感觉有些陌生，历史的车轮不会因为你不关注就会停止，相反，这些“平行世界”总是在向前奔跑着，唯一不变的就是变化~</p><p>2021-10-24 19:46:47</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;之前在文章&lt;a href=&quot;https://blog.csdn.net/albertsh/article/details/120818017&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《.bat批处理（十）：从路径字符串中截取盘符、文件名、后缀名等信息》&lt;/a&gt;中总结了在批处理文件中，也就是Windows环境下怎样从路径字符串中截取文件名、盘符等信息，利用的是Windows的扩展变量，而这种截取路径的需求在linux脚本中也很常见，实现方法相比批处理脚本而言要简单一些，下面列举一下常见的方法。&lt;/p&gt;
    
    </summary>
    
      <category term="linux" scheme="http://AlbertGithubHome.github.io/blog/categories/linux/"/>
    
    
      <category term="linux" scheme="http://AlbertGithubHome.github.io/blog/tags/linux/"/>
    
      <category term="dirname" scheme="http://AlbertGithubHome.github.io/blog/tags/dirname/"/>
    
      <category term="basename" scheme="http://AlbertGithubHome.github.io/blog/tags/basename/"/>
    
      <category term="路径截取" scheme="http://AlbertGithubHome.github.io/blog/tags/%E8%B7%AF%E5%BE%84%E6%88%AA%E5%8F%96/"/>
    
  </entry>
  
  <entry>
    <title>.bat批处理（十）：从路径字符串中截取盘符、文件名、后缀名等信息</title>
    <link href="http://AlbertGithubHome.github.io/blog/2021/10/16/%E6%89%B9%E5%A4%84%E7%90%86%E4%BB%8E%E8%B7%AF%E5%BE%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E6%88%AA%E5%8F%96%E7%9B%98%E7%AC%A6%E3%80%81%E6%96%87%E4%BB%B6%E5%90%8D%E3%80%81%E5%90%8E%E7%BC%80%E5%90%8D%E7%AD%89%E4%BF%A1%E6%81%AF/"/>
    <id>http://AlbertGithubHome.github.io/blog/2021/10/16/批处理从路径字符串中截取盘符、文件名、后缀名等信息/</id>
    <published>2021-10-16T14:26:35.000Z</published>
    <updated>2021-10-17T15:11:17.382Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>又是实际开发中的问题，想要截取一个文件路径中的盘符、文件名等信息，第一反应是正则表达式？或者是 <code>split</code> 函数？这些往往都是“高级”语言中才会有的实现方法，对于批处理来说有点“带不动”啊，那么在bat批处理中要怎样处理类似的请求呢？最近找到了两种方法，接下来会逐一展示一下，不过在展示具体的写法前，我们先来看一下 <code>%~dp0</code>的含义。</p><a id="more"></a><h1 id="dp0的含义"><a href="#dp0的含义" class="headerlink" title="%~dp0的含义"></a><code>%~dp0</code>的含义</h1><p>关于 <code>%~dp0</code> 的作用在之前的总结中 <a href="https://blog.csdn.net/shihengzhen101/article/details/52807345" target="_blank" rel="noopener">《.bat批处理（四）：路径相关%cd%和%~dp0的区别》</a> 有提到过，它表示当前运行的批处理文件所在的目录，那么它是一个特殊的变量吗？</p><p>可以说算是吧，这个变量特殊在它是从参数变量 <code>%0</code> 扩展而来的，提到 <code>%0</code> 很多人都会想到它是批处理脚本的第一个参数，表示当前运行的脚本全路径，可以写个脚本试一下：</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># Albert <span class="built_in">at</span> home-pc <span class="keyword">in</span> D:\data\bat [<span class="number">0</span>:<span class="number">03</span>:<span class="number">25</span>]</span><br><span class="line">% Get-Content showparams.bat</span><br><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> %<span class="number">0</span></span><br><span class="line"><span class="built_in">echo</span> %<span class="number">1</span></span><br><span class="line"></span><br><span class="line"># Albert <span class="built_in">at</span> home-pc <span class="keyword">in</span> D:\data\bat [<span class="number">0</span>:<span class="number">03</span>:<span class="number">31</span>]</span><br><span class="line">% ./showparams.bat good</span><br><span class="line">"D:\data\bat\showparams.bat"</span><br><span class="line">good</span><br></pre></td></tr></table></figure><p>类似的变量还有 <code>1%</code>、<code>2%</code>、<code>3%</code>…. 一直到<code>9%</code>，都依次表示运行批处理脚本时传入的参数，这些变量还有一个本领，那就是支持扩展，写起来花里胡哨的。</p><h1 id="扩展字符串"><a href="#扩展字符串" class="headerlink" title="扩展字符串"></a>扩展字符串</h1><p>扩展字符串是批处理自带的功能，可以实现对表示文件路径的字符串进行特殊的处理，以<code>%0</code> 参数为例，具体功能列举如下：</p><ul><li><code>%~0</code> - 删除路径中的引号</li><li><code>%~f0</code> - 将 %0 扩展到一个完全合格的路径名</li><li><code>%~d0</code> - 将 %0 扩展到一个驱动器号</li><li><code>%~p0</code> - 将 %0 扩展到一个路径</li><li><code>%~n0</code> - 将 %0 扩展到一个文件名</li><li><code>%~x0</code> - 将 %0 扩展到一个文件扩展名</li><li><code>%~s0</code> - 将 %0 扩展的路径只含有短名</li><li><code>%~a0</code> - 将 %0 扩展到文件的文件属性</li><li><code>%~t0</code> - 将 %0 扩展到文件的日期/时间</li><li><code>%~z0</code> - 将 %0 扩展到文件的大小</li><li><code>%~$PATH:0</code> 查找变量<code>0%</code>在路径环境变量<code>$PATH</code>的目录，并将 <code>%0</code> 扩展到找到的第一个完全合格的名称，<code>$PATH</code>未被定义或没找到文件，则结果为空字符串</li></ul><p>当然这个写法也可以进行组合，比如 <code>%~d0</code> 和 <code>%~p0</code> 组合后变成 <code>%~dp0</code> 也就是我们常见的那个变量啦~</p><p>可以将这些变量打印出来看一下具体的值：</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"># Albert <span class="built_in">at</span> home-pc <span class="keyword">in</span> D:\data\bat [<span class="number">0</span>:<span class="number">26</span>:<span class="number">17</span>]</span><br><span class="line">% Get-Content showparams.bat</span><br><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> %<span class="number">0</span></span><br><span class="line"><span class="built_in">echo</span> %~<span class="number">0</span></span><br><span class="line"><span class="built_in">echo</span> %~f0</span><br><span class="line"><span class="built_in">echo</span> %~d0</span><br><span class="line"><span class="built_in">echo</span> %~p0</span><br><span class="line"><span class="built_in">echo</span> %~n0</span><br><span class="line"><span class="built_in">echo</span> %~x0</span><br><span class="line"><span class="built_in">echo</span> %~s0</span><br><span class="line"><span class="built_in">echo</span> %~a0</span><br><span class="line"><span class="built_in">echo</span> %~t0</span><br><span class="line"><span class="built_in">echo</span> %~z0</span><br><span class="line"><span class="built_in">echo</span> %~dp0</span><br><span class="line"><span class="built_in">echo</span> %~nx0</span><br><span class="line"># Albert <span class="built_in">at</span> home-pc <span class="keyword">in</span> D:\data\bat [<span class="number">0</span>:<span class="number">26</span>:<span class="number">28</span>]</span><br><span class="line">% .\showparams.bat</span><br><span class="line">"D:\data\bat\showparams.bat"</span><br><span class="line"><span class="function">D:\<span class="title">data</span>\<span class="title">bat</span>\<span class="title">showparams.bat</span></span></span><br><span class="line"><span class="function"><span class="title">D</span>:\<span class="title">data</span>\<span class="title">bat</span>\<span class="title">showparams.bat</span></span></span><br><span class="line"><span class="function"><span class="title">D</span>:</span></span><br><span class="line"><span class="function">\<span class="title">data</span>\<span class="title">bat</span>\</span></span><br><span class="line"><span class="function"><span class="title">showparams</span></span></span><br><span class="line"><span class="function">.<span class="title">bat</span></span></span><br><span class="line"><span class="function"><span class="title">D</span>:\<span class="title">data</span>\<span class="title">bat</span>\<span class="title">showparams.bat</span></span></span><br><span class="line"><span class="function">--<span class="title">a</span>--------</span></span><br><span class="line"><span class="function">2021/10/17 00:26</span></span><br><span class="line"><span class="function">156</span></span><br><span class="line"><span class="function"><span class="title">D</span>:\<span class="title">data</span>\<span class="title">bat</span>\</span></span><br><span class="line"><span class="function"><span class="title">showparams.bat</span></span></span><br></pre></td></tr></table></figure><h1 id="从字符串中截取路径、文件名"><a href="#从字符串中截取路径、文件名" class="headerlink" title="从字符串中截取路径、文件名"></a>从字符串中截取路径、文件名</h1><!-- 132903***********736 --><p>上面的部分解释了<code>%~dp0</code>，同时也知道了这些脚本参数指出扩展语法，如果是普通变量的话就不能使用扩展语法了，那么对于一个普通的包含字符串怎么才能使用扩展语法，截取到想要的部分呢？目前我知道的有两种方法：一种是传参使其变成脚本参数，也就是 <code>%n</code>的形式，另一种方法就是使用 <code>for</code> 语句，接下来分别看一下。</p><h2 id="脚本传参"><a href="#脚本传参" class="headerlink" title="脚本传参"></a>脚本传参</h2><p>普通的字符串无法进行扩展，如果想把这种变量就需要把它们变成脚本参数，这就需要将参数传递给另一个脚本，这样实现起来会将脚本调用变得复杂一些，实际上可以在一个脚本中完成截取工作，类似于C/C++中的函数调用，可以在批处理中使用 <code>call</code> 命令搭配标签实现，具体代码如下：</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"># Albert <span class="built_in">at</span> home-pc <span class="keyword">in</span> D:\data\bat [<span class="number">17</span>:<span class="number">37</span>:<span class="number">54</span>]</span><br><span class="line">% Get-Content extract1.bat</span><br><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> OriginStr="C:/Demo/myproject/example.txt"</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">%OriginStr%</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">call</span> :extract <span class="variable">%OriginStr%</span></span><br><span class="line"><span class="keyword">goto</span> :eof</span><br><span class="line"></span><br><span class="line">:extract</span><br><span class="line"><span class="comment">rem 获取到文件路径</span></span><br><span class="line"><span class="built_in">echo</span> %~dp1</span><br><span class="line"><span class="comment">rem 获取到文件盘符</span></span><br><span class="line"><span class="built_in">echo</span> %~d1</span><br><span class="line"><span class="comment">rem 获取到文件名称</span></span><br><span class="line"><span class="built_in">echo</span> %~n1</span><br><span class="line"><span class="comment">rem 获取到文件后缀</span></span><br><span class="line"><span class="built_in">echo</span> %~x1</span><br><span class="line"></span><br><span class="line"># Albert <span class="built_in">at</span> home-pc <span class="keyword">in</span> D:\data\bat [<span class="number">17</span>:<span class="number">41</span>:<span class="number">25</span>]</span><br><span class="line">% .\extract1.bat</span><br><span class="line">"C:/Demo/myproject/example.txt"</span><br><span class="line"><span class="function">C:\<span class="title">Demo</span>\<span class="title">myproject</span>\</span></span><br><span class="line"><span class="function"><span class="title">C</span>:</span></span><br><span class="line"><span class="function"><span class="title">example</span></span></span><br><span class="line"><span class="function">.<span class="title">txt</span></span></span><br></pre></td></tr></table></figure><p>在这段代码中 <code>:eof</code> 标签是一个默认的标签，表示文件结尾，实际需求中需根据具体要求进行调整。</p><h2 id="for语法扩展"><a href="#for语法扩展" class="headerlink" title="for语法扩展"></a>for语法扩展</h2><p>使用 for 循环是另一种实现方式，因为循环变量也可以支持扩展，可以将需要截取的字符串路径放在循环范围中，然后先循环输出测试下：</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># Albert <span class="built_in">at</span> home-pc <span class="keyword">in</span> D:\data\bat [<span class="number">17</span>:<span class="number">46</span>:<span class="number">29</span>]</span><br><span class="line">% Get-Content extract2.bat</span><br><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> OriginStr="C:/Demo/myproject/example.txt"</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="variable">%%I</span> <span class="keyword">in</span> (<span class="variable">%OriginStr%</span>) <span class="keyword">do</span> <span class="built_in">echo</span> <span class="variable">%%I</span></span><br><span class="line"></span><br><span class="line"># Albert <span class="built_in">at</span> home-pc <span class="keyword">in</span> D:\data\bat [<span class="number">17</span>:<span class="number">46</span>:<span class="number">57</span>]</span><br><span class="line">% .\extract2.bat</span><br><span class="line">"C:/Demo/myproject/example.txt"</span><br></pre></td></tr></table></figure><p>在批处理中的循环变量是 <code>%%I</code>的形式，需要两个 % 才可以，后面的变量名可以换成26个字母中的任意一个，并且字母会区分大小写，然后利用这些循环变量就可以进行扩展，然后完成最开始的需求，实现代码如下：</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"># Albert <span class="built_in">at</span> home-pc <span class="keyword">in</span> D:\data\bat [<span class="number">17</span>:<span class="number">53</span>:<span class="number">53</span>]</span><br><span class="line">% Get-Content extract2.bat</span><br><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> OriginStr="C:/Demo/myproject/example.txt"</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="variable">%%I</span> <span class="keyword">in</span> (<span class="variable">%OriginStr%</span>) <span class="keyword">do</span> <span class="built_in">echo</span> <span class="variable">%%I</span></span><br><span class="line"></span><br><span class="line"><span class="comment">rem 获取到文件路径</span></span><br><span class="line"><span class="keyword">for</span> <span class="variable">%%I</span> <span class="keyword">in</span> (<span class="variable">%OriginStr%</span>) <span class="keyword">do</span> <span class="built_in">echo</span> <span class="variable">%%~</span>dpI</span><br><span class="line"><span class="comment">rem 获取到文件盘符</span></span><br><span class="line"><span class="keyword">for</span> <span class="variable">%%I</span> <span class="keyword">in</span> (<span class="variable">%OriginStr%</span>) <span class="keyword">do</span> <span class="built_in">echo</span> <span class="variable">%%~</span>dI</span><br><span class="line"><span class="comment">rem 获取到文件名称</span></span><br><span class="line"><span class="keyword">for</span> <span class="variable">%%I</span> <span class="keyword">in</span> (<span class="variable">%OriginStr%</span>) <span class="keyword">do</span> <span class="built_in">echo</span> <span class="variable">%%~</span>nI</span><br><span class="line"><span class="comment">rem 获取到文件后缀</span></span><br><span class="line"><span class="keyword">for</span> <span class="variable">%%I</span> <span class="keyword">in</span> (<span class="variable">%OriginStr%</span>) <span class="keyword">do</span> <span class="built_in">echo</span> <span class="variable">%%~</span>xI</span><br><span class="line"></span><br><span class="line"># Albert <span class="built_in">at</span> home-pc <span class="keyword">in</span> D:\data\bat [<span class="number">17</span>:<span class="number">54</span>:<span class="number">01</span>]</span><br><span class="line">% .\extract2.bat</span><br><span class="line">"C:/Demo/myproject/example.txt"</span><br><span class="line"><span class="function">C:\<span class="title">Demo</span>\<span class="title">myproject</span>\</span></span><br><span class="line"><span class="function"><span class="title">C</span>:</span></span><br><span class="line"><span class="function"><span class="title">example</span></span></span><br><span class="line"><span class="function">.<span class="title">txt</span></span></span><br></pre></td></tr></table></figure><p>这种写法的好处就是无需控制标签跳转流程，通过循环命令 for 就可以获取想要的参数，使用起来会方便很多。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>在批处理文件中 <code>%~dp0</code> 表示批处理文件所在的目录，而 <code>%cd%</code> 表示执行命令时所在的目录</li><li>在批处理文件中想要截取目录操作可以使用变量扩展来实现，而变量必须是 <code>%i</code> 的形式，其中的 <code>i</code> 是可以是 <code>a~zA~Z0~9</code></li><li>for 表达式中的循环变量在cmd命令行中是 <code>%i</code> 的形式，而在批处理文件中需要协程 <code>%%i</code> 的形式</li><li>常用的变量扩展有：获取到文件盘符使用 <code>%~d0</code>，获取到文件名称使用 <code>%~n0</code>，获取到文件后缀使用 <code>%~x0</code></li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/120611073" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>反人性需要不断修炼，逆向思维才能战胜人性的弱点，很多时候事情往往不是你想的那样~</p><p>2021-10-17 18:01:07</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;又是实际开发中的问题，想要截取一个文件路径中的盘符、文件名等信息，第一反应是正则表达式？或者是 &lt;code&gt;split&lt;/code&gt; 函数？这些往往都是“高级”语言中才会有的实现方法，对于批处理来说有点“带不动”啊，那么在bat批处理中要怎样处理类似的请求呢？最近找到了两种方法，接下来会逐一展示一下，不过在展示具体的写法前，我们先来看一下 &lt;code&gt;%~dp0&lt;/code&gt;的含义。&lt;/p&gt;
    
    </summary>
    
      <category term="bat" scheme="http://AlbertGithubHome.github.io/blog/categories/bat/"/>
    
    
      <category term="实用工具" scheme="http://AlbertGithubHome.github.io/blog/tags/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/"/>
    
      <category term="bat" scheme="http://AlbertGithubHome.github.io/blog/tags/bat/"/>
    
  </entry>
  
  <entry>
    <title>C++11中的std::atomic保证的原子性是什么</title>
    <link href="http://AlbertGithubHome.github.io/blog/2021/10/13/C-11%E4%B8%AD%E7%9A%84std-atomic%E4%BF%9D%E8%AF%81%E7%9A%84%E5%8E%9F%E5%AD%90%E6%80%A7%E6%98%AF%E4%BB%80%E4%B9%88/"/>
    <id>http://AlbertGithubHome.github.io/blog/2021/10/13/C-11中的std-atomic保证的原子性是什么/</id>
    <published>2021-10-13T15:13:54.000Z</published>
    <updated>2021-10-13T15:15:48.223Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>提到atomic这个词，你首先想到的是什么呢？作为一个长时间混迹于编程世界的菜鸟，我首先想到的一个词是“原子性”，接着飞入脑海的是 “ACID” 这个缩写词组，既然提到了 <code>ACID</code> 我们就来简单的复习一下。</p><p><code>ACID</code> 是指事务管理的4个特性，常见于数据库操作管理中，它们分别是：原子性，一致性，隔离性和持久性。</p><a id="more"></a><ul><li><strong>原子性</strong>（Atomicity）是指事务是一个不可分割的工作单位，事务中的操作要么都执行，要么都不执行。</li><li><strong>一致性</strong>（Consistency）是指事务前后数据的完整性必须保持一致，完全符合逻辑原运算。</li><li><strong>隔离性</strong>（Isolation）是指在多个用户并发访问数据库时，数据库为每一个用户开启的事务，不能被其他事务的操作数据所干扰，多个并发事务之间要相互隔离，无需感知其他事务的存在。</li><li><strong>持久性</strong>（Durability）是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来即使数据库发生故障也不应该对数据造成损坏。</li></ul><h1 id="C-中的atomic"><a href="#C-中的atomic" class="headerlink" title="C++中的atomic"></a>C++中的atomic</h1><p>原子（atom）是在化学反应中不可分割基本微粒，而编程世界中的原子性也是取自这里的不可分割的含义，不可分割与事务管理中的原子性含义一致，指的是一个操作或者一系列操作只能全都执行或者都不执行，不会只执行其中一部分，那么C++11中引入atomic有什么用？不使用atomic能不能保证原子性呢？</p><p>其实C++11中引入atomic主要还是降低了编程的复杂度，如果不使用atomic同样可以使用锁机制来保证原子性，接下来我们来看看为什么需要原子性。</p><h1 id="一个简单的自增运算"><a href="#一个简单的自增运算" class="headerlink" title="一个简单的自增运算"></a>一个简单的自增运算</h1><p><code>i++</code> 是个再简单不过的语句了，我们可以使用它来做一个计数器，每次自增加1，假设我们有一个工程项目有两条商品生产的流水线，每个流水线生产出一件商品则需要计数器加1，这时我们用两个线程来模拟两条流水线，每个线程函数来调用自增的计数器，来看看有什么问题？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n; k++) i++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = argc &gt; <span class="number">1</span> ? atoi(argv[<span class="number">1</span>]) : <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">t1</span><span class="params">(func, n)</span></span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">t2</span><span class="params">(func, n)</span></span>;</span><br><span class="line"></span><br><span class="line">    t1.join();</span><br><span class="line">    t2.join();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"i="</span> &lt;&lt; i &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试代码如上所示，执行 <code>g++ -std=c++20 -O0 -pthread main.cpp &amp;&amp; ./a.out 10</code> 命令编译并运行得到结果 <code>i=20</code>，貌似很正常，一共两个线程，每个线程执行10次自增操作，结果就应该是20啊，先别太早下结论，增大自增范围试试。</p><p>执行 <code>g++ -std=c++20 -O0 -pthread main.cpp &amp;&amp; ./a.out 100000</code> 得到结果 <code>i=112831</code>，多次执行发现每次运行结果都不太一样，但是数据范围在 <code>100000~200000</code>，这就有些奇怪了，每个线程执行循环执行一条语句，那么程序结果应该等于 <code>2n</code> 才对，为什么结果总是小于 <code>2n</code> 呢，难道有些循环没有执行？</p><p>其实不是这样的，<code>i++</code>从C++语言的层面来看确实是一条语句，但是真正再和机器打交道时一般会解释成类似于下面这样3条汇编指令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// x86 msvc v19.latest</span><br><span class="line">mov     eax, DWORD PTR _i$[ebp]</span><br><span class="line">add     eax, 1</span><br><span class="line">mov     DWORD PTR _i$[ebp], eax</span><br></pre></td></tr></table></figure><p>3条指令的含义可以理解为读取、自增，设置共三步，既然不是真正的一条语句，那么在多线的环境下就会生语句的交叉执行，比如第一个线程执行读取变量i的值之后，第二个线程也读取了变量i的值，这样两个线程都进行后续的自增和设置指令后，会发现比预期的值少了一个，这种情况在循环次数较多时尤为明显。</p><h1 id="通过加锁把自增变为原子操作"><a href="#通过加锁把自增变为原子操作" class="headerlink" title="通过加锁把自增变为原子操作"></a>通过加锁把自增变为原子操作</h1><p>既然每个自增操作可能会被分解成3条指令，那么我们可以加锁来将3条指令捆绑，当一个线程执行自增操作时加锁来防止其他进程“捣乱”，具体修改如下，可以在自增操作前直接加锁：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">std</span>::mutex mt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inc</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; l(mt);</span><br><span class="line">    i++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n; k++) inc();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = argc &gt; <span class="number">1</span> ? atoi(argv[<span class="number">1</span>]) : <span class="number">100</span>;</span><br><span class="line">    <span class="built_in">std</span>::chrono::steady_clock::time_point start = <span class="built_in">std</span>::chrono::steady_clock::now();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">t1</span><span class="params">(func, n)</span></span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">t2</span><span class="params">(func, n)</span></span>;</span><br><span class="line"></span><br><span class="line">    t1.join();</span><br><span class="line">    t2.join();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"i="</span> &lt;&lt; i &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::chrono::duration&lt;<span class="keyword">double</span>&gt; duration_cost = <span class="built_in">std</span>::chrono::duration_cast&lt;</span><br><span class="line">        <span class="built_in">std</span>::chrono::duration&lt;<span class="keyword">double</span>&gt; &gt;(<span class="built_in">std</span>::chrono::steady_clock::now() - start);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;  <span class="string">"total cost "</span> &lt;&lt; duration_cost.count() &lt;&lt; <span class="string">" seconds."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行 <code>g++ -std=c++20 -O0 -pthread main.cpp &amp;&amp; ./a.out 10000000</code> 命令后运行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">i=20000000</span><br><span class="line">total cost 2.39123 seconds.</span><br></pre></td></tr></table></figure><p>通过加锁，我们已经保证了结果的正确性，但是我们知道加锁的额外消耗还是很大的，有没有其他的方式来实现原子操作呢？</p><h1 id="使用atomic来保证自增的原子性"><a href="#使用atomic来保证自增的原子性" class="headerlink" title="使用atomic来保证自增的原子性"></a>使用atomic来保证自增的原子性</h1><p>其实在C++11之前可以通过嵌入汇编指令来实现，不过自从C++11引入atomic之后，类似的需求变得简单了许多，可以直接使用autmic这个模板类来实现，代码几乎不需要修改，只需将变量 <code>i</code> 改为 <code>atomic&lt;int&gt;</code> 类型，再把锁去掉就可以了，修改后的代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;atomic&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::atomic&lt;<span class="keyword">int</span>&gt; i = <span class="number">0</span>; <span class="comment">// int -&gt; atomic&lt;int&gt;</span></span><br><span class="line"><span class="built_in">std</span>::mutex mt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inc</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//std::lock_guard&lt;std::mutex&gt; l(mt);  //remove lock</span></span><br><span class="line">    i++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n; k++) inc();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = argc &gt; <span class="number">1</span> ? atoi(argv[<span class="number">1</span>]) : <span class="number">100</span>;</span><br><span class="line">    <span class="built_in">std</span>::chrono::steady_clock::time_point start = <span class="built_in">std</span>::chrono::steady_clock::now();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">t1</span><span class="params">(func, n)</span></span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">t2</span><span class="params">(func, n)</span></span>;</span><br><span class="line"></span><br><span class="line">    t1.join();</span><br><span class="line">    t2.join();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"i="</span> &lt;&lt; i &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::chrono::duration&lt;<span class="keyword">double</span>&gt; duration_cost = <span class="built_in">std</span>::chrono::duration_cast&lt;</span><br><span class="line">        <span class="built_in">std</span>::chrono::duration&lt;<span class="keyword">double</span>&gt; &gt;(<span class="built_in">std</span>::chrono::steady_clock::now() - start);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;  <span class="string">"total cost "</span> &lt;&lt; duration_cost.count() &lt;&lt; <span class="string">" seconds."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行 <code>g++ -std=c++20 -O0 -pthread main.cpp &amp;&amp; ./a.out 10000000</code> 命令后运行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">i=20000000</span><br><span class="line">total cost 1.6554 seconds.</span><br></pre></td></tr></table></figure><p>通过对比可以发现，使用 <code>std::atomic</code> 模板类之后，在保证了结果正确的同时，相比于加锁实现原子性速度上有了明显的提升。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li><code>ACID</code> 是指事务管理中的原子性，一致性，隔离性和持久性4个特性。</li><li>加锁（写锁）的目的通常是将可能同时发生的操作串行化，以此来避免对资源的竞争出现问题</li><li>操作的并行加快了任务的处理速度，而“加锁”使部分操作回归到串行，两者相互配合是为了在<strong>更短</strong>的时间内得到<strong>正确</strong>的结果</li><li><code>std::atomic</code> 降低了原子性操作编程的难度，同时相比于加锁实现原子性还有了性能的提升</li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/120245600" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>时光时光慢些吧，不要再让你变老了，我愿用我一切，换你岁月长留~</p><blockquote><p>时间对于每个人来说，都是公平的，真的是这样吗？我觉得未必吧！</p></blockquote><p>2021-10-6 00:32:33–</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;提到atomic这个词，你首先想到的是什么呢？作为一个长时间混迹于编程世界的菜鸟，我首先想到的一个词是“原子性”，接着飞入脑海的是 “ACID” 这个缩写词组，既然提到了 &lt;code&gt;ACID&lt;/code&gt; 我们就来简单的复习一下。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ACID&lt;/code&gt; 是指事务管理的4个特性，常见于数据库操作管理中，它们分别是：原子性，一致性，隔离性和持久性。&lt;/p&gt;
    
    </summary>
    
      <category term="C/C++" scheme="http://AlbertGithubHome.github.io/blog/categories/C-C/"/>
    
    
      <category term="C++" scheme="http://AlbertGithubHome.github.io/blog/tags/C/"/>
    
      <category term="C++11" scheme="http://AlbertGithubHome.github.io/blog/tags/C-11/"/>
    
      <category term="atomic" scheme="http://AlbertGithubHome.github.io/blog/tags/atomic/"/>
    
      <category term="原子性" scheme="http://AlbertGithubHome.github.io/blog/tags/%E5%8E%9F%E5%AD%90%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>Dijkstra——通过不断松弛来解决单源最短路径问题的算法</title>
    <link href="http://AlbertGithubHome.github.io/blog/2021/09/11/Dijkstra%E2%80%94%E2%80%94%E9%80%9A%E8%BF%87%E4%B8%8D%E6%96%AD%E6%9D%BE%E5%BC%9B%E6%9D%A5%E8%A7%A3%E5%86%B3%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98%E7%9A%84%E7%AE%97%E6%B3%95/"/>
    <id>http://AlbertGithubHome.github.io/blog/2021/09/11/Dijkstra——通过不断松弛来解决单源最短路径问题的算法/</id>
    <published>2021-09-11T15:28:12.000Z</published>
    <updated>2021-09-12T15:31:06.530Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Dijkstra算法又称迪杰斯特拉算法，它采用的是一种贪心的策略，使用广度优先搜索的方式解决带权有向图或者无向图的单源最短路径问题，需要注意的是它不能处理带负边权的情况，核心思想就是“<strong>守住现有阵地不断攻占底盘</strong>”，这一点可以在后面代码实现中慢慢体会，接下来梳理一下算法思路。</p><a id="more"></a><h1 id="Dijkstra思路"><a href="#Dijkstra思路" class="headerlink" title="Dijkstra思路"></a>Dijkstra思路</h1><p>Dijkstra 算法的思路是维护一个点集合 <code>S</code> 和一个用来保存起点 <code>m</code> 到各个顶点到各个顶点最短距离的数组 <code>dis</code>，用邻接数组来表示带权图信息。</p><p>初始情况时，集合 <code>S</code> 中只包括起点<code>m</code>，通过图信息来初始化 <code>dis</code> 数组，将起点 <code>m</code> 可以直接到达的点设置为边的权值，不能到达的点设置为无穷大，比如点 <code>m</code> 到点 <code>n</code> 的距离是d，则 <code>dis[n] = d</code>。</p><p>然后从带权图中选择不在集合<code>S</code> 中的到点 <code>m</code> 距离最近的点，假设为 <code>n</code>，把它加到集合 <code>S</code> 中，然后尝试通过点 <code>n</code> “松弛” 那些不在集合 <code>S</code> 中的点到点 <code>m</code>的距离，更新 <code>dis</code> 数组信息，具体操作就是使用点 <code>n</code> 作为中转，如果距离如果点 <code>m</code> 到任意点 <code>x</code> 通过点 <code>n</code> 中转距离变短了，那么就更新 <code>dis[x]</code> 的值。</p><p>之后不断重复上面的“松弛”操作，直到集合 <code>S</code> 中包含了所有得到顶点，至此就通过Dijkstra算法求解出了从点 <code>m</code> 到图中任意点的最短距离。</p><h1 id="图解实例"><a href="#图解实例" class="headerlink" title="图解实例"></a>图解实例</h1><!--看了上面的关于Dijkstra算法的文字描述可能还是有点蒙，这时候需要画个图来解释一下，对于算法问题，特别是图论方面的算法题，有时候真的是一图胜千言，奈何我真的是不想画图，一方面因为“懒”，另一方面就是图片的搬运比较麻烦，所以对于大部分问题我都是文字描述，但是为了解释这个Dijkstra我还是决定画一画，假如求解从点`a` 到各个顶点的最短距离，初始图信息如下：第一步，我们把点 `a` 添加到集合 `S` 中变为 `S = {a}`，然后初始化dis数组为 `dis = {0, 1, 12, ∞, ∞, ∞}`，加入集合的点用红色表示，操作之后更新如下：第二步，找到距离点 `a` 最近的且不在 `S` 中的点，根据 `dis` 数组计算应该是点 `b`，将点 `b` 添加到集合 `S` 中，通过点 `b` 中转更新 `dis` 数组，dis[c]变为8，dis[d]变为4，更新后集合为 `S = {a, b}`， 距离数组为 `dis = {0, 1, 8, 4, ∞, ∞}`, 图信息如下：第三步，找到距离点 `a` 最近的且不在 `S` 中的点，根据 `dis` 数组计算应该是点 `d`，将点 `d` 添加到集合 `S` 中，通过点 `d` 中转更新 `dis` 数组，dis[e]变为14，dis[f]变为17，更新后集合为 `S = {a, b, d}`， 距离数组为 `dis = {0, 1, 8, 4, 14, 17}`, 图信息如下：第四步，找到距离点 `a` 最近的且不在 `S` 中的点，根据 `dis` 数组计算应该是点 `c`，将点 `c` 添加到集合 `S` 中，通过点 `c` 中转更新 `dis` 数组，dis[e]变为13，更新后集合为 `S = {a, b, d, c}`， 距离数组为 `dis = {0, 1, 8, 4, 13, 17}`, 图信息如下：第五步，找到距离点 `a` 最近的且不在 `S` 中的点，根据 `dis` 数组计算应该是点 `e`，将点 `e` 添加到集合 `S` 中，通过点 `e` 中转更新 `dis` 数组，通过距离判断发现此次不需要更新dis数组，更新后集合为 `S = {a, b, d, c, e}`， 距离数组为 `dis = {0, 1, 8, 4, 13, 17}`, 图信息如下：第六步，找到距离点 `a` 最近的且不在 `S` 中的点，根据 `dis` 数组计算应该是点 `f`，将点 `f` 添加到集合 `S` 中，至此集合 `S` 中包含了所有的顶点，Dijkstra算法执行结束，集合信息为 `S = {a, b, d, c, e, f}`， 距离数组为 `dis = {0, 1, 8, 4, 13, 17}`, 图信息如下：--><p>看了上面的关于Dijkstra算法的文字描述可能还是有点蒙，这时候需要画个图来解释一下，对于算法问题，特别是图论方面的算法题，有时候真的是一图胜千言，奈何我真的是不想画图，一方面因为“懒”，另一方面就是图片的搬运比较麻烦，所以对于大部分问题我都是文字描述，但是为了解释这个Dijkstra我还是决定画一画，假如求解从点<code>a</code> 到各个顶点的最短距离，初始图信息如下：</p><p><img src="https://img-blog.csdnimg.cn/0bdcb09cb6574b32b194e25087c4f9a3.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9hbGJlcnRnaXRodWJob21lLmdpdGh1Yi5pby9ibG9nL2Fib3V0,size_18,color_FFFFFF,t_70#pic_center" alt="Dijkstra_0"></p><p>第一步，我们把点 <code>a</code> 添加到集合 <code>S</code> 中变为 <code>S = {a}</code>，然后初始化dis数组为 <code>dis = {0, 1, 12, ∞, ∞, ∞}</code>，加入集合的点用红色表示，操作之后更新如下：</p><p><img src="https://img-blog.csdnimg.cn/51fcb81971eb4d3c8cfdd24ee82e5494.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9hbGJlcnRnaXRodWJob21lLmdpdGh1Yi5pby9ibG9nL2Fib3V0,size_18,color_FFFFFF,t_70#pic_center" alt="Dijkstra_1"></p><p>第二步，找到距离点 <code>a</code> 最近的且不在 <code>S</code> 中的点，根据 <code>dis</code> 数组计算应该是点 <code>b</code>，将点 <code>b</code> 添加到集合 <code>S</code> 中，通过点 <code>b</code> 中转更新 <code>dis</code> 数组，dis[c]变为8，dis[d]变为4，更新后集合为 <code>S = {a, b}</code>， 距离数组为 <code>dis = {0, 1, 8, 4, ∞, ∞}</code>, 图信息如下：</p><p><img src="https://img-blog.csdnimg.cn/9e3b38dd6ab943979002b646bb79c9e4.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9hbGJlcnRnaXRodWJob21lLmdpdGh1Yi5pby9ibG9nL2Fib3V0,size_18,color_FFFFFF,t_70#pic_center" alt="Dijkstra_2"></p><p>第三步，找到距离点 <code>a</code> 最近的且不在 <code>S</code> 中的点，根据 <code>dis</code> 数组计算应该是点 <code>d</code>，将点 <code>d</code> 添加到集合 <code>S</code> 中，通过点 <code>d</code> 中转更新 <code>dis</code> 数组，dis[e]变为14，dis[f]变为17，更新后集合为 <code>S = {a, b, d}</code>， 距离数组为 <code>dis = {0, 1, 8, 4, 14, 17}</code>, 图信息如下：</p><p><img src="https://img-blog.csdnimg.cn/bf9efd1a9f7247318cc3c609af99b46a.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9hbGJlcnRnaXRodWJob21lLmdpdGh1Yi5pby9ibG9nL2Fib3V0,size_18,color_FFFFFF,t_70#pic_center" alt="Dijkstra_3"></p><p>第四步，找到距离点 <code>a</code> 最近的且不在 <code>S</code> 中的点，根据 <code>dis</code> 数组计算应该是点 <code>c</code>，将点 <code>c</code> 添加到集合 <code>S</code> 中，通过点 <code>c</code> 中转更新 <code>dis</code> 数组，dis[e]变为13，更新后集合为 <code>S = {a, b, d, c}</code>， 距离数组为 <code>dis = {0, 1, 8, 4, 13, 17}</code>, 图信息如下：</p><p><img src="https://img-blog.csdnimg.cn/4fc4077f20d141ddaf95ab07940c1bb7.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9hbGJlcnRnaXRodWJob21lLmdpdGh1Yi5pby9ibG9nL2Fib3V0,size_18,color_FFFFFF,t_70#pic_center" alt="Dijkstra_4"></p><p>第五步，找到距离点 <code>a</code> 最近的且不在 <code>S</code> 中的点，根据 <code>dis</code> 数组计算应该是点 <code>e</code>，将点 <code>e</code> 添加到集合 <code>S</code> 中，通过点 <code>e</code> 中转更新 <code>dis</code> 数组，通过距离判断发现此次不需要更新dis数组，更新后集合为 <code>S = {a, b, d, c, e}</code>， 距离数组为 <code>dis = {0, 1, 8, 4, 13, 17}</code>, 图信息如下：</p><p><img src="https://img-blog.csdnimg.cn/37b5260c109f41d1bdb43bf347d88088.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9hbGJlcnRnaXRodWJob21lLmdpdGh1Yi5pby9ibG9nL2Fib3V0,size_18,color_FFFFFF,t_70#pic_center" alt="Dijkstra_5"></p><p>第六步，找到距离点 <code>a</code> 最近的且不在 <code>S</code> 中的点，根据 <code>dis</code> 数组计算应该是点 <code>f</code>，将点 <code>f</code> 添加到集合 <code>S</code> 中，至此集合 <code>S</code> 中包含了所有的顶点，Dijkstra算法执行结束，集合信息为 <code>S = {a, b, d, c, e, f}</code>， 距离数组为 <code>dis = {0, 1, 8, 4, 13, 17}</code>, 图信息如下：</p><p><img src="https://img-blog.csdnimg.cn/17a7704ff3c943b987a7e85b9411b3f2.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9hbGJlcnRnaXRodWJob21lLmdpdGh1Yi5pby9ibG9nL2Fib3V0,size_18,color_FFFFFF,t_70#pic_center" alt="Dijkstra_6"></p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><p>通过上面的图解实例对于Dijkstra的实现应该有了一些思路，那么接下来我们把它转化成代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; graph)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dis = graph[<span class="number">0</span>];</span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; S;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> n = dis.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, x = <span class="number">0</span>; i &lt; n; i++, x = <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// find  minimum weight</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) <span class="keyword">if</span> (!S.count(j) &amp;&amp; (x == <span class="number">0</span> || dis[j] &lt; dis[x])) x = j;</span><br><span class="line"></span><br><span class="line">        S.insert(x);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// relax</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) <span class="keyword">if</span> (!S.count(j) &amp;&amp; dis[x] + graph[x][j] &lt; dis[j]) dis[j] = dis[x] + graph[x][j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行上述代码之后我们便得到了节点0到任意点的最短路径长度数组 <code>dis</code>。</p><p>从上面的分析我们可以知道从点 <code>a</code> 到点 <code>f</code> 的最短路径长度是 17，那么最短路径怎样求呢？</p><p>其实只要在做松弛操作时记录每个节点是从哪个节点松弛得到的就可以了，比如可以使用一个pre数组来记录这个信息，当计算 dis 结束时通过pre数组反推就可以得到最短路径，简单实现如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; graph)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dis = graph[<span class="number">0</span>];</span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; S;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> n = dis.size();</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pre(n, <span class="number">0</span>); <span class="comment">// save previous point index</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, x = <span class="number">0</span>; i &lt; n; i++, x = <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// find  minimum weight</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) <span class="keyword">if</span> (!S.count(j) &amp;&amp; (x == <span class="number">0</span> || dis[j] &lt; dis[x])) x = j;</span><br><span class="line"></span><br><span class="line">        S.insert(x);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// relax</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) <span class="keyword">if</span> (!S.count(j) &amp;&amp; dis[x] + graph[x][j] &lt; dis[j]) &#123;</span><br><span class="line">            dis[j] = dis[x] + graph[x][j];</span><br><span class="line">            pre[j] = x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// output path info</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path&#123;<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">while</span>(path.back() != <span class="number">0</span>) &#123;</span><br><span class="line">        path.push_back(pre[path.back()]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = path.rbegin(); it != path.rend(); it++)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>Dijkstra算法的时间复杂度为<code>O(N^2)</code>，空间复杂度为 <code>O(N)</code>，如果对时间复杂度有更高要求可以使用堆结构进行优化</li><li>Dijkstra是一种求解单源最短路径的算法，在时间复杂度这一项要优于之前所说的 Floyd 算法</li><li>Dijkstra不能处理带负边权的情况，不过实际生活中类似于行车路线、管道铺设等问题都不会有负边权，应用还是比较广泛的</li><li>该算法仔细分析之后还是比较好理解的，不过还是有一些变型和编程技巧，需要在实际问题中灵活变通</li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/120148274" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>历史总是惊人的相似，却不会简单的重复。在柯立芝实行了以放任自流的经济政策之后，紧接着便迎来了1929年的大萧条；而在克林顿到小布什任期内采取的经济自由化的政策，引发了之后2008年的国际金融危机；如今我们抬头看看大洋彼岸那疯狂运转的印钞机，这次的泡泡或许很快就能迎来炸裂的时刻~</p><p>2021-9-12 23:29:46</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;Dijkstra算法又称迪杰斯特拉算法，它采用的是一种贪心的策略，使用广度优先搜索的方式解决带权有向图或者无向图的单源最短路径问题，需要注意的是它不能处理带负边权的情况，核心思想就是“&lt;strong&gt;守住现有阵地不断攻占底盘&lt;/strong&gt;”，这一点可以在后面代码实现中慢慢体会，接下来梳理一下算法思路。&lt;/p&gt;
    
    </summary>
    
      <category term="C/C++" scheme="http://AlbertGithubHome.github.io/blog/categories/C-C/"/>
    
    
      <category term="C++" scheme="http://AlbertGithubHome.github.io/blog/tags/C/"/>
    
      <category term="Dijkstra" scheme="http://AlbertGithubHome.github.io/blog/tags/Dijkstra/"/>
    
      <category term="算法" scheme="http://AlbertGithubHome.github.io/blog/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="最短路径" scheme="http://AlbertGithubHome.github.io/blog/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/"/>
    
  </entry>
  
  <entry>
    <title>Floyd-Warshall——仅用4行代码就能解决多源最短路径问题的算法</title>
    <link href="http://AlbertGithubHome.github.io/blog/2021/09/05/Floyd-Warshall%E2%80%94%E2%80%94%E4%BB%85%E7%94%A85%E8%A1%8C%E4%BB%A3%E7%A0%81%E5%B0%B1%E8%83%BD%E8%A7%A3%E5%86%B3%E5%A4%9A%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98%E7%9A%84%E7%AE%97%E6%B3%95/"/>
    <id>http://AlbertGithubHome.github.io/blog/2021/09/05/Floyd-Warshall——仅用5行代码就能解决多源最短路径问题的算法/</id>
    <published>2021-09-04T16:42:38.000Z</published>
    <updated>2021-09-06T17:25:24.807Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Floyd-Warshall算法简记Floyd算法，又称弗洛伊德算法，是解决任意两点间的最短路径问题的一种常用算法，核心思想就是“<strong>不断利用第三者影响原配关系</strong>”，这一点在4行核心代码中表现的淋漓尽致，接下来梳理一下算法思路。</p><a id="more"></a><h1 id="Floyd思路"><a href="#Floyd思路" class="headerlink" title="Floyd思路"></a>Floyd思路</h1><p>从A点走到B点要想路径最短只有两种可能，一种就是直接从A到B，另一种就是通过其他点来中转，Floyd的思路就是先把直接能到达的点固定下来，然后不断的尝试从其他点来中转来降低路程。</p><p>Floyd算法实现通常使用一个二维数组来表示任意两点之间的初始距离，每个点到自身的距离为0，若两个点之间没有直接连通，则赋值为 <code>+∞</code>，我们假设这个二维数组是 <code>v</code>，则 <code>v[i][j]</code> 代表了从点 <code>i</code> 到点 <code>j</code> 的初始距离。</p><p>假设不允许中转，那么二维数组 <code>v</code> 中的数据就代表了任意两点间的距离。</p><p>如果允许中转一次，我们假设只允许从节点1进行中转，那么点 <code>i</code> 到点 <code>j</code> 的最近距离最小为 <code>v[i][j]</code> 或者 <code>v[i][1] + v[1][j]</code>，如果 <code>v[i][1] + v[1][j]</code> 的值更小，我们可以使用它来更新 <code>v[i][j]</code> 的值，这时 <code>v[i][j]</code> 就不仅仅是一个值了，而是隐含着 <code>i-&gt;1-&gt;j</code> 这样一条路径，这个过程实际上翻译成代码就是：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">        v[i][j] = min(v[i][j], v[i][<span class="number">1</span>] + v[<span class="number">1</span>][j]);</span><br></pre></td></tr></table></figure><p>那么这条路径怎样才能更短呢？</p><p>答案就是引入另一个点，比如我们不仅允许从节点1中转，也允许从节点2中转，从上一步我们知道从从点 <code>i</code> 到点 <code>j</code> 的最短距离是从 <code>i-&gt;1-&gt;j</code> 得到的，实际上经过上面一步，任意两点的距离都是允许从节点1中转条件下的最小值， 那么引入节点2之后就是要看看 <code>v[i][j]</code> 和 <code>v[i][2] + v[2][j]</code> 谁更小一点，然后遍历更新即可，类似的代码可以写成：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">        v[i][j] = min(v[i][j], v[i][<span class="number">2</span>] + v[<span class="number">2</span>][j]);</span><br></pre></td></tr></table></figure><p>看到套路了没有，就是每个点都作为一个可能中转的点来试一下，整个算法就结束了，好神奇~ 完整4行代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n; k++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">            v[i][j] = min(v[i][j], v[i][k] + v[k][j]);</span><br></pre></td></tr></table></figure><p>简单粗暴又不失美感！</p><h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><p>初始路径及每条边的距离如图：</p><p><img src="https://img-blog.csdnimg.cn/7a32a9cd366a4d8eaab56d8916b08953.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9hbGJlcnRnaXRodWJob21lLmdpdGh1Yi5pby9ibG9nL2Fib3V0,size_15,color_FFFFFF,t_70#pic_center" alt="路径"></p><ol><li>翻译成二维数组如下：</li></ol><table><thead><tr><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th></tr></thead><tbody><tr><td style="text-align:center">0</td><td style="text-align:center">2</td><td style="text-align:center">7</td><td style="text-align:center">4</td></tr><tr><td style="text-align:center">∞</td><td style="text-align:center">0</td><td style="text-align:center">4</td><td style="text-align:center">∞</td></tr><tr><td style="text-align:center">9</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">∞</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">∞</td><td style="text-align:center">15</td><td style="text-align:center">0</td></tr></tbody></table><ol><li>仅通过节点0作为中转，二维数组更新如下：</li></ol><table><thead><tr><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th></tr></thead><tbody><tr><td style="text-align:center">0</td><td style="text-align:center">2</td><td style="text-align:center">7</td><td style="text-align:center">4</td></tr><tr><td style="text-align:center">∞</td><td style="text-align:center">0</td><td style="text-align:center">4</td><td style="text-align:center">∞</td></tr><tr><td style="text-align:center">9</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">13</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">8</td><td style="text-align:center">13</td><td style="text-align:center">0</td></tr></tbody></table><ol><li>增加节点1作为中转，二维数组更新如下：</li></ol><table><thead><tr><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th></tr></thead><tbody><tr><td style="text-align:center">0</td><td style="text-align:center">2</td><td style="text-align:center">6</td><td style="text-align:center">4</td></tr><tr><td style="text-align:center">∞</td><td style="text-align:center">0</td><td style="text-align:center">4</td><td style="text-align:center">∞</td></tr><tr><td style="text-align:center">9</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">13</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">8</td><td style="text-align:center">12</td><td style="text-align:center">0</td></tr></tbody></table><ol><li>再增加节点2作为中转，二维数组更新如下：</li></ol><table><thead><tr><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th></tr></thead><tbody><tr><td style="text-align:center">0</td><td style="text-align:center">2</td><td style="text-align:center">6</td><td style="text-align:center">4</td></tr><tr><td style="text-align:center">13</td><td style="text-align:center">0</td><td style="text-align:center">4</td><td style="text-align:center">17</td></tr><tr><td style="text-align:center">9</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">13</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">8</td><td style="text-align:center">12</td><td style="text-align:center">0</td></tr></tbody></table><ol><li>最后增加节点3作为中转，二维数组更新如下：</li></ol><table><thead><tr><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th></tr></thead><tbody><tr><td style="text-align:center">0</td><td style="text-align:center">2</td><td style="text-align:center">6</td><td style="text-align:center">4</td></tr><tr><td style="text-align:center">13</td><td style="text-align:center">0</td><td style="text-align:center">4</td><td style="text-align:center">17</td></tr><tr><td style="text-align:center">9</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">13</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">8</td><td style="text-align:center">12</td><td style="text-align:center">0</td></tr></tbody></table><p>至此我们就求解出了任意两点间的最小距离。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>Floyd算法的时间复杂度为<code>O(N^3)</code>，空间复杂度为 <code>O(N^2)</code></li><li>Floyd是一种求解多源最短路径的算法，如果是求解单源最短路径这 N^3 的时间复杂度确实有点伤</li><li>Floyd可以正确处理有向图或存在负权边的图，但不能处理存在负权回路的图的最短路径问题</li><li>4行代码3层循环或许可以助它称为最容易让人理解的最短路径算法</li><li>这4行代码只是一个理想化的模型，实际在编码时要注意加法的越界问题，因为两个无穷大相加理论上是无穷大，但在代码里可能就崩溃了</li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/119722553" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>人生到底是追求到达目的地还是准备欣赏沿途的风景，一味地向前奔跑忽略了周围的一切，很多美好的事物就在身边却不自知，我们已经被世俗蒙蔽了双眼，什么时候可以慢下来呢？</p><p>2021-9-7 01:14:05</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;Floyd-Warshall算法简记Floyd算法，又称弗洛伊德算法，是解决任意两点间的最短路径问题的一种常用算法，核心思想就是“&lt;strong&gt;不断利用第三者影响原配关系&lt;/strong&gt;”，这一点在4行核心代码中表现的淋漓尽致，接下来梳理一下算法思路。&lt;/p&gt;
    
    </summary>
    
      <category term="C/C++" scheme="http://AlbertGithubHome.github.io/blog/categories/C-C/"/>
    
    
      <category term="C++" scheme="http://AlbertGithubHome.github.io/blog/tags/C/"/>
    
      <category term="算法" scheme="http://AlbertGithubHome.github.io/blog/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="最短路径" scheme="http://AlbertGithubHome.github.io/blog/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/"/>
    
      <category term="Floyd" scheme="http://AlbertGithubHome.github.io/blog/tags/Floyd/"/>
    
  </entry>
  
  <entry>
    <title>从一个小题中的应用来体会下std::tie的便利之处</title>
    <link href="http://AlbertGithubHome.github.io/blog/2021/08/15/%E4%BB%8E%E4%B8%80%E4%B8%AA%E5%B0%8F%E9%A2%98%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8%E6%9D%A5%E4%BD%93%E4%BC%9A%E4%B8%8Bstd-tie%E7%9A%84%E4%BE%BF%E5%88%A9%E4%B9%8B%E5%A4%84/"/>
    <id>http://AlbertGithubHome.github.io/blog/2021/08/15/从一个小题中的应用来体会下std-tie的便利之处/</id>
    <published>2021-08-15T08:28:18.000Z</published>
    <updated>2021-08-15T15:48:38.441Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>今天主要学习一下 <code>std::tie</code> 函数的使用方法，之前看到 <code>tie</code> 函数是和 IO 绑定的，最近发现它是和 <code>std::tuple</code> 绑定的，查询资料后发现两个函数虽然名字相同，但是在不同的作用域下，今天学一下和 tuple 有关的这个 <code>tie</code> 函数，不过在学习之前先看一道小题。</p><a id="more"></a><h1 id="解题过程"><a href="#解题过程" class="headerlink" title="解题过程"></a>解题过程</h1><h2 id="爬楼梯的最少成本"><a href="#爬楼梯的最少成本" class="headerlink" title="爬楼梯的最少成本"></a>爬楼梯的最少成本</h2><p>这是 <a href="https://leetcode-cn.com/problems/GzCJIP/" target="_blank" rel="noopener">LeetCode</a> 上的一道题，题目描述如下：</p><p>数组的每个下标作为一个阶梯，第 i 个阶梯对应着一个非负数的体力花费值 cost[i]（下标从 0 开始）。</p><p>每当爬上一个阶梯都要花费对应的体力值，一旦支付了相应的体力值，就可以选择向上爬一个阶梯或者爬两个阶梯。</p><p>请找出达到楼层顶部的最低花费。在开始时，你可以选择从下标为 0 或 1 的元素作为初始阶梯。</p><p>示例 1：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：cost = [10, 15, 20]</span><br><span class="line">输出：15</span><br><span class="line">解释：最低花费是从 cost[1] 开始，然后走两步即可到阶梯顶，一共花费 15 。</span><br></pre></td></tr></table></figure></p><p> 示例 2：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]</span><br><span class="line">输出：6</span><br><span class="line">解释：最低花费方式是从 cost[0] 开始，逐个经过那些 1 ，跳过 cost[3] ，一共花费 6 。</span><br></pre></td></tr></table></figure></p><p>提示：</p><pre><code>2 &lt;= cost.length &lt;= 10000 &lt;= cost[i] &lt;= 999</code></pre><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>这种求解最小花费、最大方案数，最大价值的题目是典型的动态规划题目，这道题也可以使用动态规划的方式来解，既然每次可以选择爬一个或者两个阶梯，那么到达某一个阶梯的花费就等于这个阶梯的花费加上前一个阶梯花费和前两个花费的之间最小值即可，最终的结果取最后一个阶梯和倒数第二个阶梯中的最小值，代码比较简单，实现如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minCostClimbingStairs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; cost)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = cost.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans(n);</span><br><span class="line">        ans[<span class="number">0</span>] = cost[<span class="number">0</span>];</span><br><span class="line">        ans[<span class="number">1</span>] = cost[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; i++) ans[i] = min(ans[i<span class="number">-1</span>], ans[i<span class="number">-2</span>]) + cost[i];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> min(ans[n<span class="number">-1</span>], ans[n<span class="number">-2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="DP优化"><a href="#DP优化" class="headerlink" title="DP优化"></a>DP优化</h2><p>虽然使用dp数组求解起来很方便，但是从实现上可以看出，每个阶梯的花费只与它前两个阶梯的花费有关，所以使用一个长度为N的数组在空间上有些浪费，其实只要两个变量就可以了，我们用 <code>first</code> 和 <code>second</code> 两个变量分别表示某个阶梯前两个阶梯的花费，可以实现如下代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minCostClimbingStairs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; cost)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = cost.size(), first = cost[<span class="number">0</span>], second = cost[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = min(first, second) + cost[i];</span><br><span class="line">            first = second;</span><br><span class="line">            second = temp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> min(first, second);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="利用tie进行写法优化"><a href="#利用tie进行写法优化" class="headerlink" title="利用tie进行写法优化"></a>利用tie进行写法优化</h2><p>使用两个变量优化之后这个算法变成了 O(1) 的空间复杂度，但是在 for 循环中的写法还是有些啰嗦，其实这种写法和交换两个变量值过程非常相似，在GO语言中可以写成 <code>a,b = b,a</code> 来完成交换，但是在C++中这样的写法是错误的，不管是引入第三个变量，还是通过异或解决都需要写三条语句，但是这种情况在遇到 <code>std::tie</code> 函数之后有望得到改变，上面的写法利用 <code>std::tie</code> 可以改写如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minCostClimbingStairs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; cost)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = cost.size(), first = cost[<span class="number">0</span>], second = cost[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; i++) tie(first, second) = make_tuple(second, min(first, second) + cost[i]);</span><br><span class="line">        <span class="keyword">return</span> min(first, second);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="std-tuple"><a href="#std-tuple" class="headerlink" title="std::tuple"></a>std::tuple</h1><p>在学习 <code>std::tie</code> 的作用方式之前，先来看一下 <code>std::tuple</code> 是什么。如果你对这个结构有些陌生，可以先想想 <code>std::pair</code> 这个结构。首先 <code>std::tuple</code> 是一个类模板，同时他也是一个固定大小的由各种类型的值组成集合，是 <code>std::pair</code> 的一种泛化实现。</p><p><code>std::pair</code> 中包含两个元素，而 <code>std::tuple</code> 可以同时包含多个元素，它拥有 struct 的表现，但是无需定义实际的 struct，在函数返回多个值时拥有良好的表现。</p><h2 id="std-tuple的访问"><a href="#std-tuple的访问" class="headerlink" title="std::tuple的访问"></a>std::tuple的访问</h2><ol><li>利用 <code>std::get</code> 函数通过下标访问（C++11）</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> t = <span class="built_in">std</span>::make_tuple(<span class="number">110</span>, <span class="string">"excellent"</span>, <span class="number">3.14</span>);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"("</span> &lt;&lt; <span class="built_in">std</span>::get&lt;<span class="number">0</span>&gt;(t) &lt;&lt; <span class="string">", "</span> &lt;&lt; <span class="built_in">std</span>::get&lt;<span class="number">1</span>&gt;(t)</span><br><span class="line">        &lt;&lt; <span class="string">", "</span> &lt;&lt; <span class="built_in">std</span>::get&lt;<span class="number">2</span>&gt;(t) &lt;&lt; <span class="string">")"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><ol><li>利用 <code>std::tie</code> 函数进行参数解绑（C++11)</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> t = <span class="built_in">std</span>::make_tuple(<span class="number">110</span>, <span class="string">"excellent"</span>, <span class="number">3.14</span>);</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> s;</span><br><span class="line"><span class="keyword">float</span> d;</span><br><span class="line"><span class="built_in">std</span>::tie(n, s, d) = t;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"("</span> &lt;&lt; n &lt;&lt; <span class="string">", "</span> &lt;&lt; s &lt;&lt; <span class="string">", "</span> &lt;&lt; d &lt;&lt; <span class="string">")"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><ol><li>利用 <code>std::get</code> 函数通过类型访问（C++14），这种使用方式如果每种类型不唯一会出现编译错误</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> t = <span class="built_in">std</span>::make_tuple(<span class="number">110</span>, <span class="string">"excellent"</span>, <span class="number">3.14</span>);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"("</span> &lt;&lt; <span class="built_in">std</span>::get&lt;<span class="keyword">int</span>&gt;(t) &lt;&lt; <span class="string">", "</span> &lt;&lt; <span class="built_in">std</span>::get&lt;<span class="keyword">const</span> <span class="keyword">char</span>*&gt;(t)</span><br><span class="line">        &lt;&lt; <span class="string">", "</span> &lt;&lt; <span class="built_in">std</span>::get&lt;<span class="keyword">double</span>&gt;(t) &lt;&lt; <span class="string">")"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><ol><li>利用结构化绑定的方式来访问（C++17）</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> t = <span class="built_in">std</span>::make_tuple(<span class="number">110</span>, <span class="string">"excellent"</span>, <span class="number">3.14</span>);</span><br><span class="line"><span class="keyword">auto</span> [n, s, d] = t;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"("</span> &lt;&lt; n &lt;&lt; <span class="string">", "</span> &lt;&lt; s &lt;&lt; <span class="string">", "</span> &lt;&lt; d &lt;&lt; <span class="string">")"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>以上的几个例子的输出结果都是 <code>(110, excellent, 3.14)</code></p><h2 id="std-tie函数中使用std-ignore占位"><a href="#std-tie函数中使用std-ignore占位" class="headerlink" title="std::tie函数中使用std::ignore占位"></a>std::tie函数中使用std::ignore占位</h2><p>使用 <code>std::tie</code> 函数来获取 <code>std::tuple</code> 参数时，有时不需要所有的参数，这种情况下可以使用 <code>td::ignore</code> 来占位，代替那些不关心的参数，比如 <code>std::set</code> 结构中 <code>insert</code> 函数的返回值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::pair&lt;<span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator, <span class="keyword">bool</span>&gt; sp1 = st.insert(<span class="number">4</span>);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *sp1.first &lt;&lt; <span class="string">" "</span> &lt;&lt; sp1.second &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::pair&lt;<span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator, <span class="keyword">bool</span>&gt; sp2 = st.insert(<span class="number">4</span>);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *sp2.first &lt;&lt; <span class="string">" "</span> &lt;&lt; sp2.second &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">4 1</span><br><span class="line">4 0</span><br></pre></td></tr></table></figure><p>如果我们不关心插入的元素是什么，只想知道此次插入操作是否成功，可以利用 <code>std::tie</code> 和 <code>std::ignore</code> 来实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line"><span class="keyword">bool</span> inserted = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::tie(<span class="built_in">std</span>::ignore, inserted) = st.insert(<span class="number">4</span>);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; inserted &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::tie(<span class="built_in">std</span>::ignore, inserted) = st.insert(<span class="number">4</span>);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; inserted &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">0</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li><code>std::tuple</code> 是 <code>std::pair</code> 一种更加通用的实现，<code>std::pair</code> 只能包含两个元素，而 <code>std::tuple</code> 可以包含多个任意类型的元素</li><li>tie 本意是系牢、约束、连接、束缚的意思，用在 <code>std::tuple</code> 上却是用来解绑参数的，含义恰好相反了，很有趣是不是</li><li>实际上 <code>std::tie</code> 这个函数的作用是把一些左值绑定到 <code>std::tuple</code> 来达到解析参数的目的，函数作用还是 “tie”</li><li><code>std::ignore</code> 可以用在 <code>std::tie</code> 函数中作为占位符，用来替代一些不关心的参数</li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/119523587" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>有些事情反过来想一想，问题可能很快就解决了——记一次拼图游戏中一个对手的高谈阔论</p><p>2021-8-15 23:48:37</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;今天主要学习一下 &lt;code&gt;std::tie&lt;/code&gt; 函数的使用方法，之前看到 &lt;code&gt;tie&lt;/code&gt; 函数是和 IO 绑定的，最近发现它是和 &lt;code&gt;std::tuple&lt;/code&gt; 绑定的，查询资料后发现两个函数虽然名字相同，但是在不同的作用域下，今天学一下和 tuple 有关的这个 &lt;code&gt;tie&lt;/code&gt; 函数，不过在学习之前先看一道小题。&lt;/p&gt;
    
    </summary>
    
      <category term="C/C++" scheme="http://AlbertGithubHome.github.io/blog/categories/C-C/"/>
    
    
      <category term="C/C++" scheme="http://AlbertGithubHome.github.io/blog/tags/C-C/"/>
    
      <category term="tie" scheme="http://AlbertGithubHome.github.io/blog/tags/tie/"/>
    
      <category term="动态规划" scheme="http://AlbertGithubHome.github.io/blog/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="DP" scheme="http://AlbertGithubHome.github.io/blog/tags/DP/"/>
    
      <category term="tuple" scheme="http://AlbertGithubHome.github.io/blog/tags/tuple/"/>
    
  </entry>
  
  <entry>
    <title>C++中使用std::sort自定义排序规则时要注意的崩溃问题</title>
    <link href="http://AlbertGithubHome.github.io/blog/2021/08/07/C-%E4%B8%AD%E4%BD%BF%E7%94%A8std-sort%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%92%E5%BA%8F%E8%A7%84%E5%88%99%E6%97%B6%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E5%B4%A9%E6%BA%83%E9%97%AE%E9%A2%98/"/>
    <id>http://AlbertGithubHome.github.io/blog/2021/08/07/C-中使用std-sort自定义排序规则时要注意的崩溃问题/</id>
    <published>2021-08-07T15:42:27.000Z</published>
    <updated>2021-08-08T15:57:54.194Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>看到这个标题应该会有很多人一下子就懂了，也会有些人感到迷惑，简简单单排序怎么会奔溃呢？我第一次接触这个问题还是很久以前刚刚参加工作的时候，当时也是写出了导致程序崩溃的代码，通过上网查询解决了问题，至此以后就对这个 <code>sort</code> 函数警惕了一些，一直记得就是在sort的自定义函数中判断条件不要加等号，至于本质的原因一直没有去探究，正好最近又改了一个相关的问题，所以决定从源码和定义的角度来看看为什么会出现这个问题。</p><a id="more"></a><h1 id="sort的使用"><a href="#sort的使用" class="headerlink" title="sort的使用"></a>sort的使用</h1><p>sort函数真的挺好用，比如像下面这样：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; values&#123;<span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="built_in">std</span>::sort(values.begin(), values.end());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> v : values) <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; v &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只是 <code>std::sort(values.begin(), values.end());</code> 这样简简单单的一句就完成了vector数据从小到达的排序，运行结果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:/data/cpp$ g++ testsort.cpp --std=c++11</span><br><span class="line">albert@home-pc:/data/cpp$ ./a.out</span><br><span class="line">1</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">5</span><br></pre></td></tr></table></figure><h1 id="自定义比较函数"><a href="#自定义比较函数" class="headerlink" title="自定义比较函数"></a>自定义比较函数</h1><p>上面举的例子是从小到大排序，这是 sort 函数的默认行为，所以不需要额外的参数，如果是想从大到小排序，那么就需要定义一个比较函数了，方法也比较简单，写一个lambda表达式就可以了，比如像下面这样：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; values&#123;<span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="built_in">std</span>::sort(values.begin(), values.end(), [](<span class="keyword">int</span> v1, <span class="keyword">int</span> v2)&#123;</span><br><span class="line">        <span class="keyword">return</span> v1 &gt;= v2;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> v : values) <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; v &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按照比较函数定义，我们把数据按照前面大于等于后面的方式排序就完成了从大到小的排序的要求，看看这样写有没有什么问题？如果这里的等号 <code>=</code> 已经引起了你的不适，说明你可能踩过这里的坑，是的，这样写容易造成崩溃，我们来运行一下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:/data/cpp$ g++ testsort.cpp --std=c++11</span><br><span class="line">albert@home-pc:/data/cpp$ ./a.out</span><br><span class="line">5</span><br><span class="line">5</span><br><span class="line">4</span><br><span class="line">4</span><br><span class="line">3</span><br><span class="line">1</span><br></pre></td></tr></table></figure><p>咦？怎么没事，我之前用MSVC测试还会崩溃的，难道和编译器有关？</p><p>当我们增大数据量</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; values&#123;<span class="number">3</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行结果如下</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">albert@home-pc:/data/cpp$ g++ testsort.cpp --<span class="built_in">std</span>=c++<span class="number">11</span> -g</span><br><span class="line">albert@home-pc:/data/cpp$ ./a.out</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line">*** Error in `./a.out': <span class="keyword">double</span> <span class="built_in">free</span> <span class="keyword">or</span> corruption (out): <span class="number">0x0000000002016c20</span> ***</span><br><span class="line">======= Backtrace: =========</span><br><span class="line">/lib/x86_64-linux-gnu/libc.so<span class="number">.6</span>(+<span class="number">0x777f5</span>)[<span class="number">0x7ff5ffef77f5</span>]</span><br><span class="line">/lib/x86_64-linux-gnu/libc.so<span class="number">.6</span>(+<span class="number">0x8038a</span>)[<span class="number">0x7ff5fff0038a</span>]</span><br><span class="line">/lib/x86_64-linux-gnu/libc.so<span class="number">.6</span>(cfree+<span class="number">0x4c</span>)[<span class="number">0x7ff5fff0458c</span>]</span><br><span class="line">./a.out[<span class="number">0x4024e2</span>]</span><br><span class="line">./a.out[<span class="number">0x4023ab</span>]</span><br><span class="line">./a.out[<span class="number">0x402226</span>]</span><br><span class="line">./a.out[<span class="number">0x4020a1</span>]</span><br><span class="line">./a.out[<span class="number">0x401edb</span>]</span><br><span class="line">./a.out[<span class="number">0x400c67</span>]</span><br><span class="line">/lib/x86_64-linux-gnu/libc.so<span class="number">.6</span>(__libc_start_main+<span class="number">0xf0</span>)[<span class="number">0x7ff5ffea0840</span>]</span><br><span class="line">./a.out[<span class="number">0x400a39</span>]</span><br><span class="line">======= Memory <span class="built_in">map</span>: ========</span><br><span class="line"><span class="number">00400000</span><span class="number">-00403000</span> r-xp <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">212044</span>                     /mnt/d/data/cpp/testsort/a.out</span><br><span class="line"><span class="number">00403000</span><span class="number">-00404000</span> r-xp <span class="number">00003000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">212044</span>                     /mnt/d/data/cpp/testsort/a.out</span><br><span class="line"><span class="number">00603000</span><span class="number">-00604000</span> r--p <span class="number">00003000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">212044</span>                     /mnt/d/data/cpp/testsort/a.out</span><br><span class="line"><span class="number">00604000</span><span class="number">-00605000</span> rw-p <span class="number">00004000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">212044</span>                     /mnt/d/data/cpp/testsort/a.out</span><br><span class="line"><span class="number">02005000</span><span class="number">-02037000</span> rw-p <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span>                          [heap]</span><br><span class="line"><span class="number">7f</span>f5f8000000<span class="number">-7f</span>f5f8021000 rw-p <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span></span><br><span class="line"><span class="number">7f</span>f5f8021000<span class="number">-7f</span>f5fc000000 ---p <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span></span><br><span class="line"><span class="number">7f</span>f5ffb70000<span class="number">-7f</span>f5ffc78000 r-xp <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">243923</span>             /lib/x86_64-linux-gnu/libm<span class="number">-2.23</span>.so</span><br><span class="line"><span class="number">7f</span>f5ffc78000<span class="number">-7f</span>f5ffc7a000 ---p <span class="number">00108000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">243923</span>             /lib/x86_64-linux-gnu/libm<span class="number">-2.23</span>.so</span><br><span class="line"><span class="number">7f</span>f5ffc7a000<span class="number">-7f</span>f5ffe77000 ---p <span class="number">0010</span>a000 <span class="number">00</span>:<span class="number">00</span> <span class="number">243923</span>             /lib/x86_64-linux-gnu/libm<span class="number">-2.23</span>.so</span><br><span class="line"><span class="number">7f</span>f5ffe77000<span class="number">-7f</span>f5ffe78000 r--p <span class="number">00107000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">243923</span>             /lib/x86_64-linux-gnu/libm<span class="number">-2.23</span>.so</span><br><span class="line"><span class="number">7f</span>f5ffe78000<span class="number">-7f</span>f5ffe79000 rw-p <span class="number">00108000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">243923</span>             /lib/x86_64-linux-gnu/libm<span class="number">-2.23</span>.so</span><br><span class="line"><span class="number">7f</span>f5ffe80000<span class="number">-7f</span>f600040000 r-xp <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">243912</span>             /lib/x86_64-linux-gnu/libc<span class="number">-2.23</span>.so</span><br><span class="line"><span class="number">7f</span>f600040000<span class="number">-7f</span>f600049000 ---p <span class="number">001</span>c0000 <span class="number">00</span>:<span class="number">00</span> <span class="number">243912</span>             /lib/x86_64-linux-gnu/libc<span class="number">-2.23</span>.so</span><br><span class="line"><span class="number">7f</span>f600049000<span class="number">-7f</span>f600240000 ---p <span class="number">001</span>c9000 <span class="number">00</span>:<span class="number">00</span> <span class="number">243912</span>             /lib/x86_64-linux-gnu/libc<span class="number">-2.23</span>.so</span><br><span class="line"><span class="number">7f</span>f600240000<span class="number">-7f</span>f600244000 r--p <span class="number">001</span>c0000 <span class="number">00</span>:<span class="number">00</span> <span class="number">243912</span>             /lib/x86_64-linux-gnu/libc<span class="number">-2.23</span>.so</span><br><span class="line"><span class="number">7f</span>f600244000<span class="number">-7f</span>f600246000 rw-p <span class="number">001</span>c4000 <span class="number">00</span>:<span class="number">00</span> <span class="number">243912</span>             /lib/x86_64-linux-gnu/libc<span class="number">-2.23</span>.so</span><br><span class="line"><span class="number">7f</span>f600246000<span class="number">-7f</span>f60024a000 rw-p <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span></span><br><span class="line"><span class="number">7f</span>f600250000<span class="number">-7f</span>f600266000 r-xp <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">180347</span>             /lib/x86_64-linux-gnu/libgcc_s.so<span class="number">.1</span></span><br><span class="line"><span class="number">7f</span>f600266000<span class="number">-7f</span>f600465000 ---p <span class="number">00016000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">180347</span>             /lib/x86_64-linux-gnu/libgcc_s.so<span class="number">.1</span></span><br><span class="line"><span class="number">7f</span>f600465000<span class="number">-7f</span>f600466000 rw-p <span class="number">00015000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">180347</span>             /lib/x86_64-linux-gnu/libgcc_s.so<span class="number">.1</span></span><br><span class="line"><span class="number">7f</span>f600470000<span class="number">-7f</span>f6005e2000 r-xp <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">189413</span>             /usr/lib/x86_64-linux-gnu/libstdc++.so<span class="number">.6</span><span class="number">.0</span><span class="number">.21</span></span><br><span class="line"><span class="number">7f</span>f6005e2000<span class="number">-7f</span>f6005ef000 ---p <span class="number">00172000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">189413</span>             /usr/lib/x86_64-linux-gnu/libstdc++.so<span class="number">.6</span><span class="number">.0</span><span class="number">.21</span></span><br><span class="line"><span class="number">7f</span>f6005ef000<span class="number">-7f</span>f6007e2000 ---p <span class="number">0017f</span>000 <span class="number">00</span>:<span class="number">00</span> <span class="number">189413</span>             /usr/lib/x86_64-linux-gnu/libstdc++.so<span class="number">.6</span><span class="number">.0</span><span class="number">.21</span></span><br><span class="line"><span class="number">7f</span>f6007e2000<span class="number">-7f</span>f6007ec000 r--p <span class="number">00172000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">189413</span>             /usr/lib/x86_64-linux-gnu/libstdc++.so<span class="number">.6</span><span class="number">.0</span><span class="number">.21</span></span><br><span class="line"><span class="number">7f</span>f6007ec000<span class="number">-7f</span>f6007ee000 rw-p <span class="number">0017</span>c000 <span class="number">00</span>:<span class="number">00</span> <span class="number">189413</span>             /usr/lib/x86_64-linux-gnu/libstdc++.so<span class="number">.6</span><span class="number">.0</span><span class="number">.21</span></span><br><span class="line"><span class="number">7f</span>f6007ee000<span class="number">-7f</span>f6007f2000 rw-p <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span></span><br><span class="line"><span class="number">7f</span>f600800000<span class="number">-7f</span>f600825000 r-xp <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">243945</span>             /lib/x86_64-linux-gnu/ld<span class="number">-2.23</span>.so</span><br><span class="line"><span class="number">7f</span>f600825000<span class="number">-7f</span>f600826000 r-xp <span class="number">00025000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">243945</span>             /lib/x86_64-linux-gnu/ld<span class="number">-2.23</span>.so</span><br><span class="line"><span class="number">7f</span>f600a25000<span class="number">-7f</span>f600a26000 r--p <span class="number">00025000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">243945</span>             /lib/x86_64-linux-gnu/ld<span class="number">-2.23</span>.so</span><br><span class="line"><span class="number">7f</span>f600a26000<span class="number">-7f</span>f600a27000 rw-p <span class="number">00026000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">243945</span>             /lib/x86_64-linux-gnu/ld<span class="number">-2.23</span>.so</span><br><span class="line"><span class="number">7f</span>f600a27000<span class="number">-7f</span>f600a28000 rw-p <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span></span><br><span class="line"><span class="number">7f</span>f600b70000<span class="number">-7f</span>f600b71000 rw-p <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span></span><br><span class="line"><span class="number">7f</span>f600b80000<span class="number">-7f</span>f600b82000 rw-p <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span></span><br><span class="line"><span class="number">7f</span>f600b90000<span class="number">-7f</span>f600b91000 rw-p <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span></span><br><span class="line"><span class="number">7f</span>f600ba0000<span class="number">-7f</span>f600ba1000 rw-p <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span></span><br><span class="line"><span class="number">7f</span>f600bb0000<span class="number">-7f</span>f600bb1000 rw-p <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span></span><br><span class="line"><span class="number">7f</span>f600bc0000<span class="number">-7f</span>f600bc1000 rw-p <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span></span><br><span class="line"><span class="number">7f</span>ffc026e000<span class="number">-7f</span>ffc0a6e000 rw-p <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span>                  [<span class="built_in">stack</span>]</span><br><span class="line"><span class="number">7f</span>ffc10b8000<span class="number">-7f</span>ffc10b9000 r-xp <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span>                  [vdso]</span><br><span class="line">Aborted (core dumped)</span><br></pre></td></tr></table></figure><p>这次终于崩溃了，但显示确实内存越界问题，并且排序后第一个元素是0，这不是我们vector中的元素啊，看来肯定是出问题了</p><p>反复尝试几次又找到一个测试用例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;values&#123;<span class="number">3</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br></pre></td></tr></table></figure><p>运行之后直接得到了 <code>Segmentation fault (core dumped)</code> 错误，没错，这就是我想要的，来从 <code>sort</code> 源码中看看为什么加了 <code>=</code> 就会出现崩溃</p><h1 id="sort源码崩溃分析"><a href="#sort源码崩溃分析" class="headerlink" title="sort源码崩溃分析"></a>sort源码崩溃分析</h1><p>sort 函数的源码还不算太长，我就一点点来看了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _RandomAccessIterator, <span class="keyword">typename</span> _Compare&gt;</span><br><span class="line">  <span class="keyword">inline</span> <span class="keyword">void</span></span><br><span class="line">  sort(_RandomAccessIterator __first, _RandomAccessIterator __last,</span><br><span class="line">   _Compare __comp)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// concept requirements</span></span><br><span class="line">    __glibcxx_function_requires(_Mutable_RandomAccessIteratorConcept&lt;</span><br><span class="line">      _RandomAccessIterator&gt;)</span><br><span class="line">    __glibcxx_function_requires(_BinaryPredicateConcept&lt;_Compare,</span><br><span class="line">      <span class="keyword">typename</span> iterator_traits&lt;_RandomAccessIterator&gt;::value_type,</span><br><span class="line">      <span class="keyword">typename</span> iterator_traits&lt;_RandomAccessIterator&gt;::value_type&gt;)</span><br><span class="line">    __glibcxx_requires_valid_range(__first, __last);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::__sort(__first, __last, __gnu_cxx::__ops::__iter_comp_iter(__comp));</span><br></pre></td></tr></table></figure><p>这算是个入口函数，做了一些类型检查，然后就调用了内部的 <code>std::__sort</code> 函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _RandomAccessIterator, <span class="keyword">typename</span> _Compare&gt;</span><br><span class="line">  <span class="keyword">inline</span> <span class="keyword">void</span></span><br><span class="line">  __sort(_RandomAccessIterator __first, _RandomAccessIterator __last,</span><br><span class="line">     _Compare __comp)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (__first != __last)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">std</span>::__introsort_loop(__first, __last,</span><br><span class="line">              <span class="built_in">std</span>::__lg(__last - __first) * <span class="number">2</span>,</span><br><span class="line">              __comp);</span><br><span class="line">      <span class="built_in">std</span>::__final_insertion_sort(__first, __last, __comp);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>当排序范围不为空时，函数会对传入的范围进行排序，为了最大程度的提高效率，结合了快排、堆排和插入排序等多种排序方法，分为 <code>std::__introsort_loop</code> 和 <code>std::__final_insertion_sort</code> 两个阶段。</p><p>第一阶段使用“快排+堆排”的方法，当元素个数小于等于 <code>_S_threshold</code>（<code>enum { _S_threshold = 16 }</code>）时，不做处理，交给第二阶段来做，对于元素个数大于_S_threshold的序列，执行快排，当快排的递归深入到一定深度 <code>__depth_limit</code>（通过元素个数计算出来的）时，不再递归深入，对待排序元素执行堆排序，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// This is a helper function for the sort routine.</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _RandomAccessIterator, <span class="keyword">typename</span> _Size, <span class="keyword">typename</span> _Compare&gt;</span><br><span class="line">  <span class="keyword">void</span></span><br><span class="line">  __introsort_loop(_RandomAccessIterator __first,</span><br><span class="line">           _RandomAccessIterator __last,</span><br><span class="line">           _Size __depth_limit, _Compare __comp)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">while</span> (__last - __first &gt; <span class="keyword">int</span>(_S_threshold))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (__depth_limit == <span class="number">0</span>)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">std</span>::__partial_sort(__first, __last, __last, __comp);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      --__depth_limit;</span><br><span class="line">      _RandomAccessIterator __cut =</span><br><span class="line">        <span class="built_in">std</span>::__unguarded_partition_pivot(__first, __last, __comp);</span><br><span class="line">      <span class="built_in">std</span>::__introsort_loop(__cut, __last, __depth_limit, __comp);</span><br><span class="line">      __last = __cut;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>第二阶段使用“插入排序”，当元素个数小于等于 <code>_S_threshold</code>（<code>enum { _S_threshold = 16 }</code>）时，执行普通的插入排序，当大于 <code>_S_threshold</code> 时，执行两次的“插入”排序操作，首先使用普通的插入排序来排 <code>[first, _S_threshold)</code> 这个范围的元素，然后使用无保护的插入排序，完成 <code>[_S_threshold, last)</code> 这个范围的排序。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _RandomAccessIterator, <span class="keyword">typename</span> _Compare&gt;</span><br><span class="line">  <span class="keyword">void</span></span><br><span class="line">  __final_insertion_sort(_RandomAccessIterator __first,</span><br><span class="line">             _RandomAccessIterator __last, _Compare __comp)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (__last - __first &gt; <span class="keyword">int</span>(_S_threshold))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">std</span>::__insertion_sort(__first, __first + <span class="keyword">int</span>(_S_threshold), __comp);</span><br><span class="line">      <span class="built_in">std</span>::__unguarded_insertion_sort(__first + <span class="keyword">int</span>(_S_threshold), __last,</span><br><span class="line">                      __comp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="built_in">std</span>::__insertion_sort(__first, __last, __comp);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>其中的普通插入排序没有什么特别的地方，就是遍历前边小于等于<code>_S_threshold</code>个元素进行普通的插入排序，而后面这个无保护的插入排序 <code>std::__unguarded_insertion_sort</code> 往往就是出现问题的地方，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _RandomAccessIterator, <span class="keyword">typename</span> _Compare&gt;</span><br><span class="line">  <span class="keyword">inline</span> <span class="keyword">void</span></span><br><span class="line">  __unguarded_insertion_sort(_RandomAccessIterator __first,</span><br><span class="line">                 _RandomAccessIterator __last, _Compare __comp)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span> (_RandomAccessIterator __i = __first; __i != __last; ++__i)</span><br><span class="line">  <span class="built_in">std</span>::__unguarded_linear_insert(__i,</span><br><span class="line">              __gnu_cxx::__ops::__val_comp_iter(__comp));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _RandomAccessIterator, <span class="keyword">typename</span> _Compare&gt;</span><br><span class="line">  <span class="keyword">void</span></span><br><span class="line">  __unguarded_linear_insert(_RandomAccessIterator __last,</span><br><span class="line">                _Compare __comp)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">typename</span> iterator_traits&lt;_RandomAccessIterator&gt;::value_type</span><br><span class="line">    __val = _GLIBCXX_MOVE(*__last);</span><br><span class="line">    _RandomAccessIterator __next = __last;</span><br><span class="line">    --__next;</span><br><span class="line">    <span class="keyword">while</span> (__comp(__val, __next))</span><br><span class="line">    &#123;</span><br><span class="line">      *__last = _GLIBCXX_MOVE(*__next);</span><br><span class="line">      __last = __next;</span><br><span class="line">      --__next;</span><br><span class="line">    &#125;</span><br><span class="line">    *__last = _GLIBCXX_MOVE(__val);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>这段代码看 <code>__unguarded_insertion_sort</code> 还没有什么问题，但是 <code>__unguarded_linear_insert</code> 中的逻辑就比较迷幻了，只有当 <code>__comp(__val, __next)</code> 的值为false时才会停止。</p><p>其中 <code>__comp</code> 就是我们之前自定义的lambda表达式，我们当时写的是 <code>return v1 &gt;= v2;</code>，翻译过来也就是当<code>!(val &gt;= __next)</code> 时，即后一个元素小于前一个元素的时候停止，那么为什么会出问题呢？</p><p>我们知道前<code>_S_threshold</code>个元素我们之前已经按照从大到小排好序了，那么按道理遍历到这个区域就会找到后一个元素小于前一个元素的情况，也就是插入排序遍历到这就会停止，等等！好像有什么不对劲，如果这里的元素都相等就找不到停止的情况了，这就会造成访问的越界，这就是程序崩溃的本质原因了。</p><p>那么去掉等号会是个什么情况呢？运行到这里就是要找到满足条件的 <code>!(val &gt; __next)</code>元素时停止，也就是找到后一个元素<strong>小于等于</strong>前一个元素的时候停止，因为前<code>_S_threshold</code>个元素已经排好序，这个条件是肯定满足的，所以不会出现越界情况，这就是为什么自定义比较函数中，两个元素相等时一定要返回false了。</p><h1 id="为什么使用无保护的插入排序"><a href="#为什么使用无保护的插入排序" class="headerlink" title="为什么使用无保护的插入排序"></a>为什么使用无保护的插入排序</h1><p>既然这里这么容易越界，为什么不判断一下边界条件来防止越界，而是用这种无保护的插入排序呢？</p><p>这里使用无保护的插入排序原因很简单，就是为了提升效率，因为省略掉越界的检查，少了很多次的比较操作，效率肯定有了提升，它的前提是左边必须有已经排好序的元素，所以在函数 <code>__unguarded_insertion_sort</code> 函数之前先调用 <code>__insertion_sort</code> 来完成了<code>[0, _S_threshold)</code> 这个范围的元素排序，便是为了后面这个无保护插入排序的使用。</p><h1 id="C-标准要求"><a href="#C-标准要求" class="headerlink" title="C++标准要求"></a>C++标准要求</h1><p>说到这里sort函数的自定义比较函数还是太容易出错了，有没有什么实现标准呢？其实标准中对这个比较函数的要求写的很详细，具体可以参考 <a href="https://en.cppreference.com/w/cpp/named_req/Compare" target="_blank" rel="noopener">Compare的实现要求</a>。</p><p><strong>Compare</strong> 是一些标准库函数针对用户提供的函数对象类型所期待的一组要求，其实就是要满足严格若排序关系，翻译成人话就是自定义的比较函数 <code>comp</code> 需要下面三条要求：</p><ol><li>对于任意元素a，需满足 <code>comp(a, a) == true</code></li><li>对于任意两个元素a和b，若 <code>comp(a, b)==true</code> 则要满足 <code>comp(b, a)==false</code></li><li>对于任意三个元素a、b和c，<code>若 comp(a, b)==true</code> 且 <code>comp(b, c)==true</code> 则需要满足 <code>comp(a, c)==true</code></li></ol><p>从这条规则也能看出我们之前定义的问题：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::sort(values.begin(), values.end(), [](<span class="keyword">int</span> v1, <span class="keyword">int</span> v2)&#123;</span><br><span class="line">    <span class="keyword">return</span> v1 &gt;= v2;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这个自定义的比较函数，当 v1 和 v2 相等时，<code>comp(v1, v2)==true</code>， 但是 <code>comp(v2, v1)</code>的值也是 <code>true</code>，当我们把代码中的等号 <code>=</code> 去掉以后，也就满足了条件2，另外在复杂的比价逻辑中，条件3的传递性问题也是需要注意的问题。</p><h1 id="构造一个崩溃的示例"><a href="#构造一个崩溃的示例" class="headerlink" title="构造一个崩溃的示例"></a>构造一个崩溃的示例</h1><p>理解了前面崩溃的原因，我们就不需要猜了，可以直接构造一个百分之百奔溃的测试用例，因为前16（<code>_S_threshold</code>）个元素会使用正常的插入排序，后面的元素才会使用无保护的插入排序，我们其实构造一个17个相同元素的vector就可以了，下面我们来试一下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; values&#123;<span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>&#125;;</span><br><span class="line">    <span class="built_in">std</span>::sort(values.begin(), values.end(), [](<span class="keyword">int</span> v1, <span class="keyword">int</span> v2)&#123;</span><br><span class="line">        <span class="keyword">return</span> v1 &gt;= v2;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> v : values) <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; v &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:/data/cpp$ g++ testsort.cpp --<span class="built_in">std</span>=c++<span class="number">11</span> -g</span><br><span class="line">albert@home-pc:/data/cpp$ ./a.out</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line">*** Error in `./a.out': <span class="keyword">double</span> <span class="built_in">free</span> <span class="keyword">or</span> corruption (out): <span class="number">0x0000000001fd9c20</span> ***</span><br><span class="line">======= Backtrace: =========</span><br><span class="line">/lib/x86_64-linux-gnu/libc.so<span class="number">.6</span>(+<span class="number">0x777f5</span>)[<span class="number">0x7feaf8ef77f5</span>]</span><br><span class="line">/lib/x86_64-linux-gnu/libc.so<span class="number">.6</span>(+<span class="number">0x8038a</span>)[<span class="number">0x7feaf8f0038a</span>]</span><br><span class="line">/lib/x86_64-linux-gnu/libc.so<span class="number">.6</span>(cfree+<span class="number">0x4c</span>)[<span class="number">0x7feaf8f0458c</span>]</span><br><span class="line">./a.out[<span class="number">0x402446</span>]</span><br><span class="line">./a.out[<span class="number">0x40230f</span>]</span><br><span class="line">./a.out[<span class="number">0x40218a</span>]</span><br><span class="line">./a.out[<span class="number">0x402005</span>]</span><br><span class="line">./a.out[<span class="number">0x401e65</span>]</span><br><span class="line">./a.out[<span class="number">0x400bf1</span>]</span><br><span class="line">/lib/x86_64-linux-gnu/libc.so<span class="number">.6</span>(__libc_start_main+<span class="number">0xf0</span>)[<span class="number">0x7feaf8ea0840</span>]</span><br><span class="line">./a.out[<span class="number">0x4009e9</span>]</span><br><span class="line">======= Memory <span class="built_in">map</span>: ========</span><br><span class="line"><span class="number">00400000</span><span class="number">-00403000</span> r-xp <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">211636</span>                     /mnt/d/data/cpp/testsort/a.out</span><br><span class="line"><span class="number">00403000</span><span class="number">-00404000</span> r-xp <span class="number">00003000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">211636</span>                     /mnt/d/data/cpp/testsort/a.out</span><br><span class="line"><span class="number">00603000</span><span class="number">-00604000</span> r--p <span class="number">00003000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">211636</span>                     /mnt/d/data/cpp/testsort/a.out</span><br><span class="line"><span class="number">00604000</span><span class="number">-00605000</span> rw-p <span class="number">00004000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">211636</span>                     /mnt/d/data/cpp/testsort/a.out</span><br><span class="line"><span class="number">01f</span>c8000<span class="number">-01f</span>fa000 rw-p <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span>                          [heap]</span><br><span class="line"><span class="number">7f</span>eaf4000000<span class="number">-7f</span>eaf4021000 rw-p <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span></span><br><span class="line"><span class="number">7f</span>eaf4021000<span class="number">-7f</span>eaf8000000 ---p <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span></span><br><span class="line"><span class="number">7f</span>eaf8b70000<span class="number">-7f</span>eaf8c78000 r-xp <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">243923</span>             /lib/x86_64-linux-gnu/libm<span class="number">-2.23</span>.so</span><br><span class="line"><span class="number">7f</span>eaf8c78000<span class="number">-7f</span>eaf8c7a000 ---p <span class="number">00108000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">243923</span>             /lib/x86_64-linux-gnu/libm<span class="number">-2.23</span>.so</span><br><span class="line"><span class="number">7f</span>eaf8c7a000<span class="number">-7f</span>eaf8e77000 ---p <span class="number">0010</span>a000 <span class="number">00</span>:<span class="number">00</span> <span class="number">243923</span>             /lib/x86_64-linux-gnu/libm<span class="number">-2.23</span>.so</span><br><span class="line"><span class="number">7f</span>eaf8e77000<span class="number">-7f</span>eaf8e78000 r--p <span class="number">00107000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">243923</span>             /lib/x86_64-linux-gnu/libm<span class="number">-2.23</span>.so</span><br><span class="line"><span class="number">7f</span>eaf8e78000<span class="number">-7f</span>eaf8e79000 rw-p <span class="number">00108000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">243923</span>             /lib/x86_64-linux-gnu/libm<span class="number">-2.23</span>.so</span><br><span class="line"><span class="number">7f</span>eaf8e80000<span class="number">-7f</span>eaf9040000 r-xp <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">243912</span>             /lib/x86_64-linux-gnu/libc<span class="number">-2.23</span>.so</span><br><span class="line"><span class="number">7f</span>eaf9040000<span class="number">-7f</span>eaf9049000 ---p <span class="number">001</span>c0000 <span class="number">00</span>:<span class="number">00</span> <span class="number">243912</span>             /lib/x86_64-linux-gnu/libc<span class="number">-2.23</span>.so</span><br><span class="line"><span class="number">7f</span>eaf9049000<span class="number">-7f</span>eaf9240000 ---p <span class="number">001</span>c9000 <span class="number">00</span>:<span class="number">00</span> <span class="number">243912</span>             /lib/x86_64-linux-gnu/libc<span class="number">-2.23</span>.so</span><br><span class="line"><span class="number">7f</span>eaf9240000<span class="number">-7f</span>eaf9244000 r--p <span class="number">001</span>c0000 <span class="number">00</span>:<span class="number">00</span> <span class="number">243912</span>             /lib/x86_64-linux-gnu/libc<span class="number">-2.23</span>.so</span><br><span class="line"><span class="number">7f</span>eaf9244000<span class="number">-7f</span>eaf9246000 rw-p <span class="number">001</span>c4000 <span class="number">00</span>:<span class="number">00</span> <span class="number">243912</span>             /lib/x86_64-linux-gnu/libc<span class="number">-2.23</span>.so</span><br><span class="line"><span class="number">7f</span>eaf9246000<span class="number">-7f</span>eaf924a000 rw-p <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span></span><br><span class="line"><span class="number">7f</span>eaf9250000<span class="number">-7f</span>eaf9266000 r-xp <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">180347</span>             /lib/x86_64-linux-gnu/libgcc_s.so<span class="number">.1</span></span><br><span class="line"><span class="number">7f</span>eaf9266000<span class="number">-7f</span>eaf9465000 ---p <span class="number">00016000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">180347</span>             /lib/x86_64-linux-gnu/libgcc_s.so<span class="number">.1</span></span><br><span class="line"><span class="number">7f</span>eaf9465000<span class="number">-7f</span>eaf9466000 rw-p <span class="number">00015000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">180347</span>             /lib/x86_64-linux-gnu/libgcc_s.so<span class="number">.1</span></span><br><span class="line"><span class="number">7f</span>eaf9470000<span class="number">-7f</span>eaf95e2000 r-xp <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">189413</span>             /usr/lib/x86_64-linux-gnu/libstdc++.so<span class="number">.6</span><span class="number">.0</span><span class="number">.21</span></span><br><span class="line"><span class="number">7f</span>eaf95e2000<span class="number">-7f</span>eaf95ef000 ---p <span class="number">00172000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">189413</span>             /usr/lib/x86_64-linux-gnu/libstdc++.so<span class="number">.6</span><span class="number">.0</span><span class="number">.21</span></span><br><span class="line"><span class="number">7f</span>eaf95ef000<span class="number">-7f</span>eaf97e2000 ---p <span class="number">0017f</span>000 <span class="number">00</span>:<span class="number">00</span> <span class="number">189413</span>             /usr/lib/x86_64-linux-gnu/libstdc++.so<span class="number">.6</span><span class="number">.0</span><span class="number">.21</span></span><br><span class="line"><span class="number">7f</span>eaf97e2000<span class="number">-7f</span>eaf97ec000 r--p <span class="number">00172000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">189413</span>             /usr/lib/x86_64-linux-gnu/libstdc++.so<span class="number">.6</span><span class="number">.0</span><span class="number">.21</span></span><br><span class="line"><span class="number">7f</span>eaf97ec000<span class="number">-7f</span>eaf97ee000 rw-p <span class="number">0017</span>c000 <span class="number">00</span>:<span class="number">00</span> <span class="number">189413</span>             /usr/lib/x86_64-linux-gnu/libstdc++.so<span class="number">.6</span><span class="number">.0</span><span class="number">.21</span></span><br><span class="line"><span class="number">7f</span>eaf97ee000<span class="number">-7f</span>eaf97f2000 rw-p <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span></span><br><span class="line"><span class="number">7f</span>eaf9800000<span class="number">-7f</span>eaf9825000 r-xp <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">243945</span>             /lib/x86_64-linux-gnu/ld<span class="number">-2.23</span>.so</span><br><span class="line"><span class="number">7f</span>eaf9825000<span class="number">-7f</span>eaf9826000 r-xp <span class="number">00025000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">243945</span>             /lib/x86_64-linux-gnu/ld<span class="number">-2.23</span>.so</span><br><span class="line"><span class="number">7f</span>eaf9a25000<span class="number">-7f</span>eaf9a26000 r--p <span class="number">00025000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">243945</span>             /lib/x86_64-linux-gnu/ld<span class="number">-2.23</span>.so</span><br><span class="line"><span class="number">7f</span>eaf9a26000<span class="number">-7f</span>eaf9a27000 rw-p <span class="number">00026000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">243945</span>             /lib/x86_64-linux-gnu/ld<span class="number">-2.23</span>.so</span><br><span class="line"><span class="number">7f</span>eaf9a27000<span class="number">-7f</span>eaf9a28000 rw-p <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span></span><br><span class="line"><span class="number">7f</span>eaf9bc0000<span class="number">-7f</span>eaf9bc1000 rw-p <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span></span><br><span class="line"><span class="number">7f</span>eaf9bd0000<span class="number">-7f</span>eaf9bd2000 rw-p <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span></span><br><span class="line"><span class="number">7f</span>eaf9be0000<span class="number">-7f</span>eaf9be1000 rw-p <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span></span><br><span class="line"><span class="number">7f</span>eaf9bf0000<span class="number">-7f</span>eaf9bf1000 rw-p <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span></span><br><span class="line"><span class="number">7f</span>eaf9c00000<span class="number">-7f</span>eaf9c01000 rw-p <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span></span><br><span class="line"><span class="number">7f</span>eaf9c10000<span class="number">-7f</span>eaf9c11000 rw-p <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span></span><br><span class="line"><span class="number">7f</span>fffb85e000<span class="number">-7f</span>fffc05e000 rw-p <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span>                  [<span class="built_in">stack</span>]</span><br><span class="line"><span class="number">7f</span>fffc61d000<span class="number">-7f</span>fffc61e000 r-xp <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span>                  [vdso]</span><br><span class="line">Aborted (core dumped)</span><br></pre></td></tr></table></figure><p>完全符合预期，如果再删除vector中的一个元素就不会崩溃了。</p><h1 id="平台差异"><a href="#平台差异" class="headerlink" title="平台差异"></a>平台差异</h1><p>这篇文章的代码编译和运行都是在Linux下完成的，但是我之前在Windows上测试时，可不需要最少17个元素的前提，这是为什么呢？因为在微软这一套编译环境下，直接检测了Compare中的条件2，并且是以断言的方式给出提示的，所以与Linux上的运行表现还有一些差异。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>使用 <code>std::sort</code> 函数自定义比较函数时，需要满足严格弱排序性，若 <code>comp(a, b)==true</code> 则 <code>comp(b, a)==false</code>，那么在比较函数中两个元素相等的情况要返回false</li><li>使用 <code>std::sort</code> 函数出现崩溃是往往是不满足严格若排序性，但是在复杂的比较函数中也可能不满足传递性</li><li><code>std::sort</code> 为了把排序效率提高到极致，综合使用了快排、堆排、插入排序等多种排序方法</li><li><code>std::sort</code> 在不同的平台实现不同，当比较函数不满足严格若排序时，gcc环境下至少有17个元素才会崩溃，而 <code>MSVC</code> 则在Debug时没有元素个数限制，会通过断言直接判断这个条件是否满足</li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/119090991" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>可是啊 总有那风吹不散的认真 总有大雨也不能抹去的泪痕~</p><p>2021-8-8 23:57:53</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;看到这个标题应该会有很多人一下子就懂了，也会有些人感到迷惑，简简单单排序怎么会奔溃呢？我第一次接触这个问题还是很久以前刚刚参加工作的时候，当时也是写出了导致程序崩溃的代码，通过上网查询解决了问题，至此以后就对这个 &lt;code&gt;sort&lt;/code&gt; 函数警惕了一些，一直记得就是在sort的自定义函数中判断条件不要加等号，至于本质的原因一直没有去探究，正好最近又改了一个相关的问题，所以决定从源码和定义的角度来看看为什么会出现这个问题。&lt;/p&gt;
    
    </summary>
    
      <category term="C/C++" scheme="http://AlbertGithubHome.github.io/blog/categories/C-C/"/>
    
    
      <category term="C/C++" scheme="http://AlbertGithubHome.github.io/blog/tags/C-C/"/>
    
      <category term="sort" scheme="http://AlbertGithubHome.github.io/blog/tags/sort/"/>
    
      <category term="lambda" scheme="http://AlbertGithubHome.github.io/blog/tags/lambda/"/>
    
      <category term="crash" scheme="http://AlbertGithubHome.github.io/blog/tags/crash/"/>
    
  </entry>
  
  <entry>
    <title>使用box2dweb做一个下落的小球，宝宝玩的不亦乐乎</title>
    <link href="http://AlbertGithubHome.github.io/blog/2021/07/21/%E4%BD%BF%E7%94%A8box2dweb%E5%81%9A%E4%B8%80%E4%B8%AA%E4%B8%8B%E8%90%BD%E7%9A%84%E5%B0%8F%E7%90%83%EF%BC%8C%E5%AE%9D%E5%AE%9D%E7%8E%A9%E7%9A%84%E4%B8%8D%E4%BA%A6%E4%B9%90%E4%B9%8E/"/>
    <id>http://AlbertGithubHome.github.io/blog/2021/07/21/使用box2dweb做一个下落的小球，宝宝玩的不亦乐乎/</id>
    <published>2021-07-21T15:26:57.000Z</published>
    <updated>2021-08-07T17:03:01.583Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>红球球~ 蓝球球~</p><p>家里的宝宝就喜欢玩球球，特别是蓝色的，而最近正好找到了一个优秀的物理引擎，就拿它来做了一个下落的小球，宝宝玩的不亦乐乎~</p><p>起初我是想模拟一个小球在不同曲线上的运动状态，一直在找一个简易的重力引擎，找了一段时间没有什么收获，也想过自己写个重力系统，可是仔细想想觉得有点太麻烦，后来玩了一些flash游戏，发现这类依靠重力的作为主要玩法的游戏还真不少，肯定有一个好的引擎可以直接拿来用，然后就发现了 <code>Box2D</code> 这个物理引擎，不但带有重力系统，还支持碰撞。</p><a id="more"></a><h1 id="box2dweb"><a href="#box2dweb" class="headerlink" title="box2dweb"></a>box2dweb</h1><p>其实 cocos2dx 和 unity 中都有使用 <code>Box2D</code> 引擎，只不过自己进行了封装，如果使用这些客户端引擎做出来的东西依赖性比较强，还好顺着 <code>Box2D</code> 这条线发现了一个 <code>box2dweb</code> 引擎，是一个 <code>Box2D</code> 的 js 版本，这就非常方便了，有个浏览器就可以直接运行了，还免去了编译安装的麻烦。</p><h1 id="下落的小球"><a href="#下落的小球" class="headerlink" title="下落的小球"></a>下落的小球</h1><p>开局一张图，后面接着编。。。</p><p><img src="https://img-blog.csdnimg.cn/bcb3268fa5ce4401923b9222e8653973.gif?" alt="下落的小球"></p><p>把这个下落的小球叫做一个游戏确实有些勉强，但是宝宝就是很喜欢玩啊，游戏本来就是让人开心的，开心就好咯！接下来记录一下这个小球是怎么实现的吧~</p><h1 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h1><h2 id="下载引擎"><a href="#下载引擎" class="headerlink" title="下载引擎"></a>下载引擎</h2><p><code>box2dweb</code> 引擎只有一个js文件，可以在github上搜索下载 <a href="https://github.com/hecht-software/box2dweb" target="_blank" rel="noopener">hecht-software/<br>box2dweb</a> ，不过最近访问缓慢，也可以下载这个我备份的版本 <a href="https://download.csdn.net/download/shihengzhen101/20417213" target="_blank" rel="noopener">Box2dWeb-2.1.a.3.min.js</a>，下载之后直接引用即可。</p><h2 id="引入js引擎"><a href="#引入js引擎" class="headerlink" title="引入js引擎"></a>引入js引擎</h2><p>新建一个 html 文件命名为 <code>fallball-game.html</code>，编写如下内容，引入 <code>Box2dWeb-2.1.a.3.min.js</code> 文件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>fall ball game<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"./Box2dWeb-2.1.a.3.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"./fallball.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">"mycanvas"</span> <span class="attr">width</span>=<span class="string">"1600"</span> <span class="attr">height</span>=<span class="string">"900"</span>&gt;</span><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="编写小球逻辑"><a href="#编写小球逻辑" class="headerlink" title="编写小球逻辑"></a>编写小球逻辑</h2><p>在上面的 html 文件中不仅引入了 <code>Box2dWeb-2.1.a.3.min.js</code> 这个物理引擎，还引入了一个 <code>fallball.js</code> 文件，这是一个新建的自定义的js文件，需要我们在这个文件中编写小球的逻辑。</p><h3 id="引入常用类型并简写"><a href="#引入常用类型并简写" class="headerlink" title="引入常用类型并简写"></a>引入常用类型并简写</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> b2Vec2 = Box2D.Common.Math.b2Vec2</span><br><span class="line">, b2AABB = Box2D.Collision.b2AABB</span><br><span class="line">, b2BodyDef = Box2D.Dynamics.b2BodyDef</span><br><span class="line">, b2Body = Box2D.Dynamics.b2Body</span><br><span class="line">, b2FixtureDef = Box2D.Dynamics.b2FixtureDef</span><br><span class="line">, b2Fixture = Box2D.Dynamics.b2Fixture</span><br><span class="line">, b2World = Box2D.Dynamics.b2World</span><br><span class="line">, b2MassData = Box2D.Collision.Shapes.b2MassData</span><br><span class="line">, b2PolygonShape = Box2D.Collision.Shapes.b2PolygonShape</span><br><span class="line">, b2CircleShape = Box2D.Collision.Shapes.b2CircleShape</span><br><span class="line">, b2DebugDraw = Box2D.Dynamics.b2DebugDraw</span><br><span class="line">, b2MouseJointDef =  Box2D.Dynamics.Joints.b2MouseJointDef</span><br><span class="line">, b2RayCastInput = Box2D.Collision.b2RayCastInput</span><br><span class="line">, b2RayCastOutput = Box2D.Collision.b2RayCastOutput</span><br></pre></td></tr></table></figure><p>以上这些都是 <code>Box2D</code> 引擎中常用的类，使用简写的变量来引用这些类，这样在后面使用时会方便很多。</p><h3 id="创建Box2D世界"><a href="#创建Box2D世界" class="headerlink" title="创建Box2D世界"></a>创建Box2D世界</h3><p><code>b2World</code> 是 <code>Box2D</code> 系统模拟物理世界的核心，可以想象成我们生活中的地球，在地球上有各种各样的物理环境，比如从空中自由落体的小球，在水中航行的轮船等等，使用 <code>b2World</code> 就可以创建这样一个世界。</p><p>在物理世界中首先需要的是重力，那么先定义一个有方向的力：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> gravity = <span class="keyword">new</span> b2Vec2(<span class="number">0</span>, <span class="number">9.8</span>);</span><br></pre></td></tr></table></figure><p>作为一个模拟物理环境的引擎，效率使我们需要考虑的问题，对于静止不动的对象，最好不进行模拟计算来节省CPU运算，这种静止的对象可以让他们在 Box2D 环境中睡觉。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> doSleep = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure></p><p>需要的参数都准备好了，这样可以new出一个Box2D世界了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> world = <span class="keyword">new</span> b2World(gravity, doSleep);</span><br></pre></td></tr></table></figure><h3 id="创建一个小球"><a href="#创建一个小球" class="headerlink" title="创建一个小球"></a>创建一个小球</h3><ol><li>先创建一个物体</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> bodydef = <span class="keyword">new</span> b2BodyDef();</span><br><span class="line"><span class="comment">// 物体类型定义，基本上常用的有两种定义：b2_staticBody 静态物体; b2_dynimacBod动态物体</span></span><br><span class="line">bodydef.type= b2Body.b2_staticBody;</span><br><span class="line"><span class="comment">// 定义物体位置</span></span><br><span class="line">bodydef.position.Set(<span class="number">0</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><ol><li>再创建一个材质</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fixDef = <span class="keyword">new</span> b2FixtureDef();</span><br><span class="line">fixDef.density = <span class="number">1.0</span>; <span class="comment">// desity 密度，如果密度为0或者null，该物体则为一个静止对象</span></span><br><span class="line">fixDef.friction = <span class="number">0.5</span>; <span class="comment">//摩擦力（0~1）</span></span><br><span class="line">fixDef.restitution = <span class="number">0.2</span>;<span class="comment">// 弹性（0~1）</span></span><br></pre></td></tr></table></figure><ol><li>为材质添加一个形状并创建小球</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fixDef.shape = <span class="keyword">new</span> b2CircleShape(<span class="number">0.5</span>);</span><br><span class="line"></span><br><span class="line">bodyDef.type = b2Body.b2_dynamicBody;</span><br><span class="line">bodyDef.position.Set(<span class="number">3</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bomb = world.CreateBody(bodyDef);</span><br><span class="line">bomb.userData = <span class="string">"iambomb"</span>;</span><br><span class="line">bomb.CreateFixture(fixDef)</span><br></pre></td></tr></table></figure><blockquote><ol><li>b2PolygonShape为多边形，设置形状大小时对应着SetAsBox(halfWidth, halfHeight)函数，参数半长和半宽，如果自定义多边形可以使用一个SetAsArray(vertexArray,vertexCount)，其中vertexArray为顶点矢量（b2Vec2）数组，vertexCount为顶点数，最多8个</li><li>b2CircleSharp为圆形，对应的设置属性为半径，函数为SetRadius(radius)</li><li>需要注意的是Box2d中的单位是米，1米是30像素，在绘制材质图片时需注意单位换算</li><li>使用 bomb.ApplyForce(force, point); 可以添加一个外力，force是一个b2Vec2的向量代表外力，point一个b2Vec2的向量代表物体的着力点。使用 bomb.SetMassFromShapes(); 可以根据形状计算质量</li></ol></blockquote><h3 id="创建背景刚体物理"><a href="#创建背景刚体物理" class="headerlink" title="创建背景刚体物理"></a>创建背景刚体物理</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> vertices = [</span><br><span class="line">    <span class="keyword">new</span> b2Vec2(<span class="number">0</span>, <span class="number">0</span>),</span><br><span class="line">    <span class="keyword">new</span> b2Vec2(<span class="number">20</span>, <span class="number">10</span>),</span><br><span class="line">    <span class="keyword">new</span> b2Vec2(<span class="number">0</span>, <span class="number">10</span>),</span><br><span class="line">]</span><br><span class="line">fixDef.shape = <span class="keyword">new</span> b2PolygonShape.AsArray(vertices, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//fixDef.shape = new b2PolygonShape();</span></span><br><span class="line"><span class="comment">//fixDef.shape.SetAsBox(30, 1);</span></span><br><span class="line"></span><br><span class="line">bodyDef.type = b2Body.b2_staticBody;</span><br><span class="line">bodyDef.position.Set(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">world.CreateBody(bodyDef).CreateFixture(fixDef);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> vertices2 = [</span><br><span class="line">    <span class="keyword">new</span> b2Vec2(<span class="number">19</span>, <span class="number">10</span>),</span><br><span class="line">    <span class="keyword">new</span> b2Vec2(<span class="number">40</span>, <span class="number">0</span>),</span><br><span class="line">    <span class="keyword">new</span> b2Vec2(<span class="number">40</span>, <span class="number">10</span>),</span><br><span class="line">]</span><br><span class="line">fixDef.shape = <span class="keyword">new</span> b2PolygonShape.AsArray(vertices2, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">bodyDef.type = b2Body.b2_staticBody;</span><br><span class="line">bodyDef.position.Set(<span class="number">0</span>, <span class="number">5</span>);</span><br><span class="line">world.CreateBody(bodyDef).CreateFixture(fixDef);</span><br></pre></td></tr></table></figure><p>参照小球创建的方式创建两个三角形物体，这里注意一个问题，三角形的坐标需要顺时针给出，否则两个刚体的碰撞会出现问题。</p><h3 id="创建调试环境"><a href="#创建调试环境" class="headerlink" title="创建调试环境"></a>创建调试环境</h3><p>实际上，Box2D只是集成了各种算法，对b2Body对象进行物理模拟计算，并将计算结果存储到这个对象中，但是它并不是DisplayObject的子类，也就意味着我们无法通过addChild()将它添加到舞台上，这时可以借助b2DebugDraw类，绑定一个Sprite对象，Box2D就能帮我们在这个Sprite中，用绘图API绘制出模拟图形，方便我们进行调试。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> debugDraw = <span class="keyword">new</span> b2DebugDraw();</span><br><span class="line">debugDraw.SetSprite(<span class="built_in">document</span>.getElementById(<span class="string">"mycanvas"</span>).getContext(<span class="string">"2d"</span>));</span><br><span class="line">debugDraw.SetDrawScale(<span class="number">30.0</span>);</span><br><span class="line">debugDraw.SetFillAlpha(<span class="number">0.5</span>);</span><br><span class="line">debugDraw.SetLineThickness(<span class="number">1.0</span>);</span><br><span class="line">debugDraw.SetFlags(</span><br><span class="line">    b2DebugDraw.e_shapeBit | b2DebugDraw.e_jointBit | b2DebugDraw.e_controllerBit | b2DebugDraw.e_pairBit);</span><br><span class="line">world.SetDebugDraw(debugDraw);</span><br></pre></td></tr></table></figure><h2 id="世界更新"><a href="#世界更新" class="headerlink" title="世界更新"></a>世界更新</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">update</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    world.Step(<span class="number">1</span> / <span class="number">60</span>,  <span class="comment">//frame-rate</span></span><br><span class="line">                   <span class="number">10</span>,  <span class="comment">//velocity iterations</span></span><br><span class="line">                   <span class="number">10</span>); <span class="comment">//position iterations</span></span><br><span class="line">    world.DrawDebugData();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> b = world.m_bodyList; b != <span class="literal">null</span>; b = b.m_next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b.GetUserData()) &#123;</span><br><span class="line">            context.save();</span><br><span class="line">            context.translate(b.GetPosition().x * <span class="number">30</span>, b.GetPosition().y * <span class="number">30</span>);</span><br><span class="line">            context.rotate(b.GetAngle());</span><br><span class="line">            context.drawImage(b.GetUserData(), -b.GetUserData().width / <span class="number">2</span>, -b.GetUserData().height / <span class="number">2</span>);</span><br><span class="line">            context.restore();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    world.ClearForces();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setInterval(update, <span class="number">1000</span> / <span class="number">60</span>);</span><br></pre></td></tr></table></figure><p>定义更新函数，注册定时器，用来定时更新。物理引擎的 <code>world.Step</code> 函数是整个 <code>Box2D</code> 引擎的核心, 它驱动了物理世界的运行。而上述代码中 <code>for</code> 循环的部分处理了材质跟随刚体运动的逻辑，可以自定义显示图片，这个已经实验成功，改天可以接着写一写。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li><code>Box2D</code> 是一个优秀易用的物理引擎，而 <code>box2dweb</code> 是一个js版本，可以很方便的在html引入使用</li><li><code>box2dweb</code> 不仅能模拟重力环境，还能模拟物体之间的碰撞，可以通过参数调整物体的密度、摩擦力和弹力</li><li>物体的形状可以多边形，可以通过给出顶点坐标的形式设置，不过要注意按照顺时针方向给出，否则碰撞失败，具体原因还不太清楚</li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/118886009" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>这个世界上，还有很多不被认可的梦想，不被祝福的感情，不被眷顾的孩子，他们不曾犯错，却只能颤颤巍巍，单薄地行走在路上。你我都一样 要承认 我们都很平凡 并且在负重~</p><p>2021-7-25 18:59:01</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;红球球~ 蓝球球~&lt;/p&gt;
&lt;p&gt;家里的宝宝就喜欢玩球球，特别是蓝色的，而最近正好找到了一个优秀的物理引擎，就拿它来做了一个下落的小球，宝宝玩的不亦乐乎~&lt;/p&gt;
&lt;p&gt;起初我是想模拟一个小球在不同曲线上的运动状态，一直在找一个简易的重力引擎，找了一段时间没有什么收获，也想过自己写个重力系统，可是仔细想想觉得有点太麻烦，后来玩了一些flash游戏，发现这类依靠重力的作为主要玩法的游戏还真不少，肯定有一个好的引擎可以直接拿来用，然后就发现了 &lt;code&gt;Box2D&lt;/code&gt; 这个物理引擎，不但带有重力系统，还支持碰撞。&lt;/p&gt;
    
    </summary>
    
      <category term="Game" scheme="http://AlbertGithubHome.github.io/blog/categories/Game/"/>
    
    
      <category term="Game" scheme="http://AlbertGithubHome.github.io/blog/tags/Game/"/>
    
      <category term="JS" scheme="http://AlbertGithubHome.github.io/blog/tags/JS/"/>
    
      <category term="物理引擎" scheme="http://AlbertGithubHome.github.io/blog/tags/%E7%89%A9%E7%90%86%E5%BC%95%E6%93%8E/"/>
    
      <category term="box2dweb" scheme="http://AlbertGithubHome.github.io/blog/tags/box2dweb/"/>
    
  </entry>
  
  <entry>
    <title>C/C++中的数据类型转换static_cast/dynamic_cast/const_cast/reinterpret_cast</title>
    <link href="http://AlbertGithubHome.github.io/blog/2021/07/10/C-C-%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"/>
    <id>http://AlbertGithubHome.github.io/blog/2021/07/10/C-C-中的数据类型转换/</id>
    <published>2021-07-10T09:06:15.000Z</published>
    <updated>2021-07-11T16:28:07.032Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>C/C++属于静态语言，也就是在编译时变量的数据类型即可确定的强类型语言。当不同的数据类型在一起运算或者相互赋值的时候，就需要进行数据类型转换。不同数据类型占用的内存空间不同，而各种数据类型的转换时有规则的，一种通用的规则就是“小转大”自动进行，“大转小”需要强制执行。这里的“大”和“小”指的是数据范围。</p><a id="more"></a><p>为什么会有数据范围大小的区别呢？这就和饭店里的盘子一样，不同的菜肴通常使用不同的盘子，盘子有大有小，如果把小盘子里的菜装到大盘子里没有问题，但是把大盘子里的菜放到小盘子中就会溢出来，假设都使用大盘子就不会产生溢出的问题，但是这样会产生空间的浪费。而C/C++中不同类型的变量占用的内存空间不同与这些盘子非常相似，当范围小的变量赋值给范围大的变量时没有问题，但是反过来也会出现溢出。</p><h1 id="数据类型自动转换"><a href="#数据类型自动转换" class="headerlink" title="数据类型自动转换"></a>数据类型自动转换</h1><p>当不同类型的变量同时运算时就会发生数据类型的自动转换，以常见的 <code>char</code>、<code>short</code>、<code>int</code>、<code>long</code>、<code>float</code>、<code>double</code> 这些类型为例，如果 <code>char</code> 和 <code>int</code> 两个类型的变量相加时，就会把 <code>char</code> 先转换成 <code>int</code> 再进行加法运算，如果是 <code>int</code> 和 <code>double</code> 类型的变量相乘就会把 <code>int</code> 转换成 <code>double</code> 再进行运算。</p><p>自动转换的行为如下图所示，方向是从左往右自动进行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">    A((char))--&gt;C(unsigned/int)</span><br><span class="line">    B((short))--&gt;C(unsigned/int)</span><br><span class="line">    C(unsigned/int)--&gt;D(unsigned/long)</span><br><span class="line">    D(unsigned/long)--&gt;F[double]</span><br><span class="line">    E(float)--&gt;F[double]</span><br></pre></td></tr></table></figure><h1 id="C语言中的强制类型转换"><a href="#C语言中的强制类型转换" class="headerlink" title="C语言中的强制类型转换"></a>C语言中的强制类型转换</h1><p>前面说了自动转换，从这里开始聊聊强制类型转换，需要强制类型转换往往程序不那么智能了，需要人工进行干预。比如把一个<code>int</code> 类型的变量赋值给 <code>char</code> 类型的变量，或者说把两个 <code>int</code> 相乘时可能会得到一个很大的数，所以需要先把 <code>int</code> 强制转换成 <code>double</code> 计算防止溢出。</p><p>强制类型转换的格式为：<code>(new_type_name) expression</code>，其中 <code>new_type_name</code> 为新类型名称，<code>expression</code>为表达式。例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">int</span> val = <span class="number">65535</span>;</span><br><span class="line"><span class="keyword">char</span> ch = (<span class="keyword">char</span>)val;</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> m = <span class="number">2147483647</span>, n = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">double</span> result = (<span class="keyword">double</span>)m * n;</span><br></pre></td></tr></table></figure><p>无论是自动的类型转换还是强制类型转换，都只是为了本次操作或运算而进行的临时转换，转换的结果也会保存到临时的内存空间内，不会改变数据本来的类型或者具体的值。</p><p>有些强制类型转换是对原有数据的重新解释，比如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">void</span>* p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>* buffer = (<span class="keyword">char</span>*)p;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>void*</code> 类型的变量p，经过强制类型转换以后变成了<code>char</code>类型的指针，此后就可以把这段内存空间当成字符数组来处理了。</p><h1 id="C-中的强制类型转换"><a href="#C-中的强制类型转换" class="headerlink" title="C++中的强制类型转换"></a>C++中的强制类型转换</h1><p>在C++语言中新增了四个用于强制类型转换的关键字，分别是 <code>static_cast</code>、 <code>dynamic_cast</code>, <code>const_cast</code>、 和 <code>reinterpret_cast</code>，使用语法为 <code>xxxx_cast&lt;new_type_name&gt;(expression)</code>。</p><p>相比于C语言中使用小括号<code>()</code>来完成强制类型转换，C++中这几个关键字的引入能更清晰的表明它要完成强制类型转换的意图，容易暴露出隐藏的问题。</p><p>其实很长一段时间以来，我对于这四种强转方式区分的不是很清晰，其中 <code>const_cast</code> 的功能还比较容易辨别，但是另外3种经常混作一团，所以才有了这篇总结，而仔细学习后才发现，这4种强转关键字的区别就在他们的名字上，下面逐个来看一下。</p><h2 id="static-cast"><a href="#static-cast" class="headerlink" title="static_cast"></a>static_cast</h2><p>这个关键字的作用主要表现在 <code>static</code> 上，是一种静态的转换，在编译期就能确定的转换，可以完成C语言中的强制类型转换中的大部分工作，但需要注意的是，它不能转换掉表达式的 <code>const</code>、<code>volitale</code> 或者 <code>__unaligned</code> 属性。</p><p>它主要有以下几种用法：</p><ol><li><p>用于基本数据类型之间的转换，如把<code>int</code>转换成<code>char</code>，把<code>int</code>转换成<code>double</code>等。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> val = <span class="number">110119</span>;</span><br><span class="line"><span class="keyword">char</span> c = <span class="keyword">static_cast</span>&lt;<span class="keyword">char</span>&gt;(val);</span><br><span class="line"><span class="keyword">double</span> d = <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(val);</span><br></pre></td></tr></table></figure></li><li><p>将表达式转换成<code>void</code>类型，并将转换后的结果丢弃</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> val = <span class="number">110119</span>;</span><br><span class="line"><span class="keyword">static_cast</span>&lt;<span class="keyword">void</span>&gt;(val);</span><br></pre></td></tr></table></figure></li><li><p>可以用于<code>void*</code> 和其他指针类类型之间的转换，但是不能用于两个无关指针类型的直接转换</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正常转换</span></span><br><span class="line"><span class="keyword">int</span> *p = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line"><span class="keyword">void</span>* p1 = <span class="keyword">static_cast</span>&lt;<span class="keyword">void</span>*&gt;(p);</span><br><span class="line"><span class="keyword">char</span>* p2 =  <span class="keyword">static_cast</span>&lt;<span class="keyword">char</span>*&gt;(p1);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译失败 //error: invalid static_cast from type ‘int*’ to type ‘char*’</span></span><br><span class="line"><span class="keyword">char</span>* p3 =  <span class="keyword">static_cast</span>&lt;<span class="keyword">char</span>*&gt;(p);</span><br></pre></td></tr></table></figure></li><li><p>可以用于类继承结构中基类和派生类之间指针或引用的转换，向上转型安全，向下转型由于没有动态类型检查，是不安全的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span> &#123;</span> &#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">D</span> :</span> B &#123; &#125;;</span><br><span class="line"></span><br><span class="line">D d;</span><br><span class="line">B&amp; rb = d;</span><br><span class="line">D&amp; rd = <span class="keyword">static_cast</span>&lt;D&amp;&gt;(rb);</span><br></pre></td></tr></table></figure></li><li><p>如果涉及左值到右值、数组到指针或函数到指针的转换，也可以通过static_cast显式执行。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">typename</span> <span class="built_in">std</span>::remove_reference&lt;_Tp&gt;::type&amp;&amp;</span><br><span class="line">move(_Tp&amp;&amp; <span class="keyword">__t</span>)</span><br><span class="line">&#123; <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">typename</span> <span class="built_in">std</span>::remove_reference&lt;_Tp&gt;::type&amp;&amp;&gt;(<span class="keyword">__t</span>); &#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="dynamic-cast"><a href="#dynamic-cast" class="headerlink" title="dynamic_cast"></a>dynamic_cast</h2><p>从名字上看，这个关键字与 <code>static_cast</code> 的静态转换是对立的，这是一个“动态”转换函数，只能对指针和引用的进行转换，并且只用于类继承结构中基类和派生类之间指针或引用的转换，可以进行向上、向下，或者横向的转换。</p><p>相比于 <code>static_cast</code> 的编译时转换， <code>dynamic_cast</code> 的转换还会在运行时进行类型检查，转换的条件也比较苛刻，必须有继承关系的类之间才能转换，并且在基类中有虚函数才可以，有一种特殊的情况就是可以把类指针转换成 <code>void*</code> 类型。</p><p>关于使用中的常见问题，参考以下几种情况：</p><ol><li><p>普通类型的指针无法转换</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> val = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> *p = &amp;val;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译失败 //error: cannot dynamic_cast ‘p’ (of type ‘int*’) to type ‘char*’ (target is not pointer or reference to class)</span></span><br><span class="line"><span class="keyword">char</span>* pc =  <span class="keyword">dynamic_cast</span>&lt;<span class="keyword">char</span>*&gt;(p);</span><br></pre></td></tr></table></figure></li><li><p>继承结构中基类里面没有虚函数无法转换</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span> &#123;</span> &#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">D</span> :</span> B &#123; &#125;;</span><br><span class="line"></span><br><span class="line">D d;</span><br><span class="line">B* pb = &amp;d;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译失败 //error: cannot dynamic_cast ‘pb’ (of type ‘struct test1()::B*’) to type ‘struct test1()::D*’ (source type is not polymorphic)</span></span><br><span class="line">D* pd = <span class="keyword">dynamic_cast</span>&lt;D*&gt;(pb)</span><br></pre></td></tr></table></figure></li><li><p>指针或引用转换的类型不是正确的类型，如果参数类型是指针会返回目标类型空指针，如果参数类型是引用则会抛出 <code>std::bad_cast</code> 异常。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span> &#123;</span> <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;&#125; &#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">D</span> :</span> B &#123; &#125;;</span><br><span class="line"></span><br><span class="line">B d;</span><br><span class="line">B* pb = &amp;d;</span><br><span class="line">D* pd = <span class="keyword">dynamic_cast</span>&lt;D*&gt;(pb);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译成功，但是pb指针指向的类型是 B，向下转型失败，输出结果是0，也就是空指针</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; pd &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure></li><li><p>一个正常转换的例子，包含向上、向下、横向转换</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span> &#123;</span> <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;&#125; &#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">D1</span> :</span> <span class="keyword">virtual</span> B &#123; &#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">D2</span> :</span> <span class="keyword">virtual</span> B &#123; &#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MD</span> :</span> D1, D2 &#123; &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">D1* pd1 = <span class="keyword">new</span> MD();</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; pd1 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向上转型</span></span><br><span class="line">B* pb = <span class="keyword">dynamic_cast</span>&lt;B*&gt;(pd1);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; pb &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向下转型</span></span><br><span class="line">MD* pmd = <span class="keyword">dynamic_cast</span>&lt;MD*&gt;(pd1);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; pmd &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 横向转型</span></span><br><span class="line">D2* pd2 = <span class="keyword">dynamic_cast</span>&lt;D2*&gt;(pd1);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; pd2 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>运行结果如下，在横向转换时指针发生了变化，可以看出 <code>dynamic_cast</code> 不是简单的数据强转，还进行了指针的偏移：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:/mnt/d/testconvert$ g++ cppconvert.cpp</span><br><span class="line">albert@home-pc:/mnt/d/testconvert$ ./a.out</span><br><span class="line">0x15c0c40</span><br><span class="line">0x15c0c40</span><br><span class="line">0x15c0c40</span><br><span class="line">0x15c0c48</span><br></pre></td></tr></table></figure></li></ol><h2 id="const-cast"><a href="#const-cast" class="headerlink" title="const_cast"></a>const_cast</h2><p>在C/C++中，const限定符通常被用来限定变量，用于表示该变量的值不能被修改，这种限定可以避免程序员犯一些初级错误，但同时也造成了一些不便，比如一些已有函数要求非常量指针，但是掉用这些函数的接口函数中都传递了常量指针，这时候就要对指针类型去常量化。</p><p>但需要特别注意的是 <code>const_cast</code> 不能去除变量的常量性，只能用来去除指向常数对象的指针或引用的常量性，且去除常量性的对象必须为指针或引用。</p><p>常量指针被转化成非常量指针，并且仍然指向原来的对象，常量引用被转换成非常量引用，并且仍然指向原来的对象；常量对象<strong>可能</strong>被转换成非常量对象。</p><ol><li><p>尝试去除非指针和引用的类型的常量性会编译失败</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> i = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译错误 //</span></span><br><span class="line"><span class="keyword">int</span> j = <span class="keyword">const_cast</span>&lt;<span class="keyword">int</span>&gt;(i);</span><br></pre></td></tr></table></figure></li><li><p>企图用一个指针来修改常量：</p></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> val = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//编译错误 //error: invalid conversion from ‘const int*’ to ‘int*’ [-fpermissive]</span></span><br><span class="line"><span class="keyword">int</span>* cp = &amp;val;</span><br></pre></td></tr></table></figure><ol><li><p>修改一个指针的常量性：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> val = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"&amp;val="</span> &lt;&lt; &amp;val &lt;&lt; <span class="string">", val="</span> &lt;&lt; val &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>* cp = &amp;val;</span><br><span class="line"><span class="keyword">int</span> *p = <span class="keyword">const_cast</span>&lt;<span class="keyword">int</span>*&gt;(cp);</span><br><span class="line">*p = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"&amp;val="</span> &lt;&lt; &amp;val &lt;&lt; <span class="string">", val="</span> &lt;&lt; val &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"p="</span> &lt;&lt; p &lt;&lt; <span class="string">", *p="</span> &lt;&lt; *p &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure></li></ol><p>运行结果如下：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&amp;val=0x7ffff7446bd4, val=6</span><br><span class="line">&amp;val=0x7ffff7446bd4, val=6</span><br><span class="line">p=0x7ffff7446bd4, *p=2</span><br></pre></td></tr></table></figure><p>运行之后，变量 <code>p</code> 指向了变量<code>val</code>地址，并改变了地址所指向的内存数据，但是打印 <code>val</code> 的值并没有发生变化，这是因为 <code>val</code> 作为常量在编译期使用它的地方就进行了替换，接下来再看另一种情况。</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> init = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> val = init;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"&amp;val="</span> &lt;&lt; &amp;val &lt;&lt; <span class="string">", val="</span> &lt;&lt; val &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>* cp = &amp;val;</span><br><span class="line"><span class="keyword">int</span> *p = <span class="keyword">const_cast</span>&lt;<span class="keyword">int</span>*&gt;(cp);</span><br><span class="line">*p = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"&amp;val="</span> &lt;&lt; &amp;val &lt;&lt; <span class="string">", val="</span> &lt;&lt; val &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"p="</span> &lt;&lt; p &lt;&lt; <span class="string">", *p="</span> &lt;&lt; *p &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>代码逻辑不变，只在开始的位置使用 <code>init</code> 这个变量来代替 <code>6</code> 这个常数，运行结果如下：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">val=0x7fffe8c71fa0, val=6</span><br><span class="line">&amp;val=0x7fffe8c71fa0, val=2</span><br><span class="line">p=0x7fffe8c71fa0, *p=2</span><br></pre></td></tr></table></figure><p>运行之后 <code>val</code> 本身的变化也应用到了使用它的地方，这里的编译器替换已经不起作用了。</p><p>实际上，使用const_cast通常是一种无奈之举，利用const_cast去掉指针或引用的常量性并且去修改原始变量的数值，这是一种非常不好的行为，如果可以的话，尽可能在程序设计阶段就规避这种情况。</p><h2 id="reinterpret-cast"><a href="#reinterpret-cast" class="headerlink" title="reinterpret_cast"></a>reinterpret_cast</h2><p>它被用于不同类型指针或引用之间的转换，或者指针和整数之间的转换，是对比特位的简单拷贝并重新解释，因此在使用过程中需要特别谨慎，比如前面提到的一个例子，<code>static_cast</code> 不能将 <code>int*</code> 直接强转成 <code>char*</code>，使用reinterpret_cast就可以办到。</p><ol><li><p>不同基础类型指针类型之间转换：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译失败 //error: invalid static_cast from type ‘int*’ to type ‘char*’</span></span><br><span class="line"><span class="keyword">char</span>* p1 =  <span class="keyword">static_cast</span>&lt;<span class="keyword">char</span>*&gt;(p);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译成功</span></span><br><span class="line"><span class="keyword">char</span>* p2 =  <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">char</span>*&gt;(p1);</span><br></pre></td></tr></table></figure></li><li><p>基础类型指针与类对象指针之间的转换：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span> &#123;</span> <span class="keyword">int</span> val;&#125;;</span><br><span class="line"></span><br><span class="line">B b&#123;<span class="number">100</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"b.val="</span> &lt;&lt; b.val &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>* p = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">int</span>*&gt;(&amp;b);</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"*p="</span> &lt;&lt; *p &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure></li></ol><p>运行之后可以得到 <code>*p</code> 的值为100，也就是重新解释了变量 <code>b</code> 的地址为整型指针。</p><ol><li><p>将地址值转换成整数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span> &#123;</span> <span class="keyword">int</span> val;&#125;;</span><br><span class="line"></span><br><span class="line">B b&#123;<span class="number">101</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"&amp;b="</span> &lt;&lt; &amp;b &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> addr = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">long</span>&gt;(&amp;b);</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"addr="</span> &lt;&lt; addr &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure></li></ol><p>运行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&amp;b=0x7ffffdc4f270</span><br><span class="line">addr=140737450930800</span><br></pre></td></tr></table></figure><p>这里的地址 <code>0x7ffffdc4f270</code> 被解释成了整数 <code>140737450930800</code>，因为涉及到字节序，这也是很多文章提到的 <code>reinterpret_cast</code> 不具备一致性的问题，我们需要知道这一个点，只要代码不依赖主机字节序就没有问题。</p><h2 id="强转关键字的选择"><a href="#强转关键字的选择" class="headerlink" title="强转关键字的选择"></a>强转关键字的选择</h2><p>好几个关键字，并且有些功能还是重复的，那么究竟该选哪一个呢？这个真得按照经验来选，我建议使用排除法，按照 <code>const_cast -&gt; dynamic_cast -&gt; reinterpret_cast -&gt; static_cast</code> 的顺序带入选择。</p><ol><li><p>先看是不是要去掉指针或引用的常量属性，如果是只能选择 <code>const_cast</code></p></li><li><p>再看转换的是不是继承体系下的多态结构，如果是这种结构下的指针和引用的转换最好使用 <code>dynamic_cast</code></p></li><li><p>接着看是不是偏底层的代码，需要将无关类型指针进行转换，或者指针与整数之间进行转换，如果是则选择 <code>reinterpret_cast</code></p></li><li><p>前三种情况都不满足，那就只能使用 <code>static_cast</code> 了</p></li></ol><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>C/C++中不同数据类型进行运算或者赋值的时候会发生数据转换，这种转换有些是自动进行的，有些需要进行显示的强制类型转换</li><li>在C语言中强制类型转换写成<code>(new_type_name) expression</code>的形式，<code>new_type_name</code> 是要转换的目标类型，<code>expression</code> 是待转换的表达式</li><li>在C++中强制类型转换通过更明显的关键字来完成，分别是<code>static_cast</code>、 <code>dynamic_cast</code>, <code>const_cast</code>、 和 <code>reinterpret_cast</code></li><li><code>static_cast</code> 是静态转换，在编译期完成完成转换，与C语言中的强制类型转换重合度最高</li><li><code>dynamic_cast</code> 是动态转换，在运行时转换会进行检查，必须用在有继承关系的多态结构中</li><li><code>const_cast</code> 是常量转换，用于取出指针或引用的常量属性，但是尽量通过设计杜绝它的使用场景</li><li><code>reinterpret_cast</code> 是一种内存数据的重新解释，比较原始，开发者使用它的时候应该明确的知道自己在做什么</li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/118470962" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>今夜的雨，好美~</p><p>2021-7-12 00:18:13</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;C/C++属于静态语言，也就是在编译时变量的数据类型即可确定的强类型语言。当不同的数据类型在一起运算或者相互赋值的时候，就需要进行数据类型转换。不同数据类型占用的内存空间不同，而各种数据类型的转换时有规则的，一种通用的规则就是“小转大”自动进行，“大转小”需要强制执行。这里的“大”和“小”指的是数据范围。&lt;/p&gt;
    
    </summary>
    
      <category term="C/C++" scheme="http://AlbertGithubHome.github.io/blog/categories/C-C/"/>
    
    
      <category term="C/C++" scheme="http://AlbertGithubHome.github.io/blog/tags/C-C/"/>
    
      <category term="数据转换" scheme="http://AlbertGithubHome.github.io/blog/tags/%E6%95%B0%E6%8D%AE%E8%BD%AC%E6%8D%A2/"/>
    
      <category term="自动" scheme="http://AlbertGithubHome.github.io/blog/tags/%E8%87%AA%E5%8A%A8/"/>
    
      <category term="强制类型转换" scheme="http://AlbertGithubHome.github.io/blog/tags/%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"/>
    
  </entry>
  
  <entry>
    <title>换个角度来看看C++中的左值、右值、左值引用、右值引用</title>
    <link href="http://AlbertGithubHome.github.io/blog/2021/07/04/%E6%8D%A2%E4%B8%AA%E8%A7%92%E5%BA%A6%E6%9D%A5%E7%9C%8B%E7%9C%8BC-%E4%B8%AD%E7%9A%84%E5%B7%A6%E5%80%BC%E3%80%81%E5%8F%B3%E5%80%BC%E3%80%81%E5%B7%A6%E5%80%BC%E5%BC%95%E7%94%A8%E3%80%81%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8/"/>
    <id>http://AlbertGithubHome.github.io/blog/2021/07/04/换个角度来看看C-中的左值、右值、左值引用、右值引用/</id>
    <published>2021-07-04T09:06:54.000Z</published>
    <updated>2021-07-04T16:37:51.353Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>对于左值和右值有一个不太严谨的定义——在赋值表达式 <code>=</code> 左侧是的左值，而在 <code>=</code> 右侧的是右值。通过不断学习和尝试，最近我发现一个新的说法更加贴切，那就是“左值是容器，右值是东西”。对于这个定义我们可以类比一下水杯和水，通过水杯可以操作水杯中的水，操作过程中的中间结果如果想要进一步操作，可以将其放入其他的水杯，如果没有水杯就无法找到曾经操作过的水了，也就无法继续操作了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">int</span> c = a + b;</span><br></pre></td></tr></table></figure><p>在这个例子中，变量 <code>a</code>，<code>b</code>, <code>c</code> 都是水杯，而 <code>2</code>、<code>6</code>、<code>a + b</code> 都是被用来操作的水，只有把这些“水”放到“水杯”中才能被找到，才可以进行下一步操作。</p><a id="more"></a><p>关于左值、右值、左值引用和右值引用的概念可以看看之前的总结：</p><ul><li><a href="https://blog.csdn.net/albertsh/article/details/105756674" target="_blank" rel="noopener">简单聊聊C/C++中的左值和右值</a></li><li><a href="https://blog.csdn.net/albertsh/article/details/105941232" target="_blank" rel="noopener">C++11在左值引用的基础上增加右值引用</a></li></ul><p>虽然温故不一定知新，但绝对可以增强记忆，参照着之前的理解，今天来换一种窥探本质的方式。</p><h1 id="汇编代码初探"><a href="#汇编代码初探" class="headerlink" title="汇编代码初探"></a>汇编代码初探</h1><p>为了熟悉一下汇编代码，我们先写个简单的例子，内容就是上述提到的那一段，新建一个文件 <code>main.cpp</code>，然后编写如下代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">6</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> c = a + b;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行 <code>g++ main.cpp --std=c++11 -S -o main.s</code> 编译这段代码，生成汇编文件 <code>main.s</code>，打开文件内容如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">    .file   <span class="string">"main.cpp"</span></span><br><span class="line">    .text</span><br><span class="line">    .globl  main</span><br><span class="line">    .type   main, @function</span><br><span class="line">main:</span><br><span class="line">.LFB0:</span><br><span class="line">    .cfi_startproc</span><br><span class="line">    pushq   %rbp</span><br><span class="line">    .cfi_def_cfa_offset <span class="number">16</span></span><br><span class="line">    .cfi_offset <span class="number">6</span>, <span class="number">-16</span></span><br><span class="line">    movq    %rsp, %rbp</span><br><span class="line">    .cfi_def_cfa_register <span class="number">6</span></span><br><span class="line">    movl    $<span class="number">6</span>, <span class="number">-12</span>(%rbp)</span><br><span class="line">    movl    $<span class="number">2</span>, <span class="number">-8</span>(%rbp)</span><br><span class="line">    movl    <span class="number">-12</span>(%rbp), %edx</span><br><span class="line">    movl    <span class="number">-8</span>(%rbp), %eax</span><br><span class="line">    addl    %edx, %eax</span><br><span class="line">    movl    %eax, <span class="number">-4</span>(%rbp)</span><br><span class="line">    movl    $<span class="number">0</span>, %eax</span><br><span class="line">    popq    %rbp</span><br><span class="line">    .cfi_def_cfa <span class="number">7</span>, <span class="number">8</span></span><br><span class="line">    ret</span><br><span class="line">    .cfi_endproc</span><br><span class="line">.LFE0:</span><br><span class="line">    .size   main, .-main</span><br><span class="line">    .ident  <span class="string">"GCC: (Ubuntu 5.4.0-6ubuntu1~16.04.12) 5.4.0 20160609"</span></span><br><span class="line">    .section        .note.GNU-<span class="built_in">stack</span>,<span class="string">""</span>,@progbits</span><br></pre></td></tr></table></figure><p>其中代表定义变量和做加法的语句转换成汇编代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">movl    $<span class="number">6</span>, <span class="number">-12</span>(%rbp)       <span class="comment">// 把立即数6放到内存地址为-12(%rbp)的位置，也就是变量a中</span></span><br><span class="line">movl    $<span class="number">2</span>, <span class="number">-8</span>(%rbp)        <span class="comment">// 把立即数2放到内存地址为-8(%rbp)的位置，也就是变量b中</span></span><br><span class="line">movl    <span class="number">-12</span>(%rbp), %edx     <span class="comment">// 把内存地址为-12(%rbp)的位置（变量a）的数据放到寄存器%edx中</span></span><br><span class="line">movl    <span class="number">-8</span>(%rbp), %eax      <span class="comment">// 把内存地址为-8(%rbp)的位置（变量b）的数据放到寄存器%eax中</span></span><br><span class="line">addl    %edx, %eax          <span class="comment">// 把寄存器%edx中的数据加到寄存器%eax中</span></span><br><span class="line">movl    %eax, <span class="number">-4</span>(%rbp)      <span class="comment">// 把寄存器%eax中的计算所得结果数据放到内存地址为-4(%rbp)的位置，也就是变量c中</span></span><br></pre></td></tr></table></figure><h1 id="指针变量"><a href="#指针变量" class="headerlink" title="指针变量"></a>指针变量</h1><p>首先来看看通过指针来修改变量值的过程，测试代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">int</span>* p = &amp;a;</span><br><span class="line">*p = <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>转换成汇编代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">movl    $<span class="number">6</span>, <span class="number">-20</span>(%rbp)       <span class="comment">// 把立即数6放到内存地址为-20(%rbp)的位置，也就是变量a中</span></span><br><span class="line">leaq    <span class="number">-20</span>(%rbp), %rax     <span class="comment">// 把这个内存地址-20(%rbp)，也就是变量a的地址保存在寄存器%rax中</span></span><br><span class="line">movq    %rax, <span class="number">-16</span>(%rbp)     <span class="comment">// 把寄存器%rax中的保存的变量a的地址，放到内存地址为-16(%rbp)的位置，也就是变量p中</span></span><br><span class="line">movq    <span class="number">-16</span>(%rbp), %rax     <span class="comment">// 把内存地址为-16(%rbp)的位置（变量p）的数据放到寄存器%rax中</span></span><br><span class="line">movl    $<span class="number">2</span>, (%rax)          <span class="comment">// 把立即数2放在寄存器%rax中保存的地址位置中，也就是p所指向的地址，即变量a中</span></span><br></pre></td></tr></table></figure><p>通过汇编代码可以发现，通过指针修改变量的值实际上是在指针变量中保存变量的地址值，修改变量时是通过指针变量直接找到变量所在内存，然后直接修改完成的。</p><h1 id="左值引用"><a href="#左值引用" class="headerlink" title="左值引用"></a>左值引用</h1><p>接着来看下通过引用来修改变量值的过程，测试代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">int</span>&amp; r = a;</span><br><span class="line">r = <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>转换成汇编代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">movl    $<span class="number">6</span>, <span class="number">-20</span>(%rbp)</span><br><span class="line">leaq    <span class="number">-20</span>(%rbp), %rax</span><br><span class="line">movq    %rax, <span class="number">-16</span>(%rbp)</span><br><span class="line">movq    <span class="number">-16</span>(%rbp), %rax</span><br><span class="line">movl    $<span class="number">2</span>, (%rax)</span><br></pre></td></tr></table></figure><p>看到这里是不是有点意思了，这几行通过引用修改变量值的代码转换成汇编代码以后，居然和之前通过指针修改变量值的汇编代码一模一样。咦？仿佛发现了引用的本质呀！</p><h1 id="常量引用"><a href="#常量引用" class="headerlink" title="常量引用"></a>常量引用</h1><p>在传统C++中我们知道，引用变量不能引用一个右值，但是常引用可以办到这一点，测试代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>&amp; a = <span class="number">6</span>;</span><br></pre></td></tr></table></figure><p>转换成汇编代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">movl    $<span class="number">6</span>, %eax            <span class="comment">//把立即数放到寄存器%eax中</span></span><br><span class="line">movl    %eax, <span class="number">-20</span>(%rbp)     <span class="comment">//把寄存器%eax中的数字6放到内存地址为-20(%rbp)的位置，一个临时变量中</span></span><br><span class="line">leaq    <span class="number">-20</span>(%rbp), %rax     <span class="comment">//把临时变量的内存地址-20(%rbp)放到寄存器%rax中</span></span><br><span class="line">movq    %rax, <span class="number">-16</span>(%rbp)     <span class="comment">//把寄存器%rax中存储的临时变量的内存地址-20(%rbp)放到内存地址为-16(%rbp)的位置</span></span><br></pre></td></tr></table></figure><p>这段代码的翻译结果与前面指针变量的例子很像，首先有一个变量（匿名变量）来存储值，然后是一个新的内存地址来保存之前变量的地址。</p><h1 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h1><p>右值引用需要C++11才能使用，与常引用对比的优点就是可以修改右值，实际上我认为还是修改的左值！测试代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>&amp;&amp; a = <span class="number">6</span>;</span><br><span class="line">a = <span class="number">2</span></span><br></pre></td></tr></table></figure><p>转换成汇编代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">movl    $<span class="number">6</span>, %eax            <span class="comment">//把立即数放到寄存器%eax中</span></span><br><span class="line">movl    %eax, <span class="number">-20</span>(%rbp)     <span class="comment">//把寄存器%eax中的数字6放到内存地址为-20(%rbp)的位置，一个临时变量中</span></span><br><span class="line">leaq    <span class="number">-20</span>(%rbp), %rax     <span class="comment">//把临时变量的内存地址-20(%rbp)放到寄存器%rax中</span></span><br><span class="line">movq    %rax, <span class="number">-16</span>(%rbp)     <span class="comment">//把寄存器%rax中存储的临时变量的内存地址-20(%rbp)放到内存地址为-16(%rbp)的位置</span></span><br><span class="line">movq    <span class="number">-16</span>(%rbp), %rax     <span class="comment">// 把内存地址为-16(%rbp)的位置（变量p）的数据放到寄存器%rax中</span></span><br><span class="line">movl    $<span class="number">2</span>, (%rax)          <span class="comment">// 把立即数2放在寄存器%rax中保存的地址位置中，也就是p所指向的地址，即变量a中</span></span><br></pre></td></tr></table></figure><p>这段汇编代码与常量引用相比只缺少赋值的部分，与左值引用相比几乎一样，只有在最开始立即数6的处理上有一点点差异，是不是感觉很神奇？</p><h1 id="一点点惊奇"><a href="#一点点惊奇" class="headerlink" title="一点点惊奇"></a>一点点惊奇</h1><p>对比了前面这些代码的汇编指令后有没有什么想法？什么常量引用，什么右值引用，这些不过都是“愚弄”程序员的把戏，但这些概念的出现并不是为了给程序员们带来麻烦，相反它们的出现使得程序编写更加可控，通过编译器帮助“粗心”的开发者们先暴露了一波问题。</p><p>通过汇编代码来看，常量引用其实引用的并非常量，而是引用了一个变量；右值引用引用的也并非右值，同样是一个保存了右值的变量。这年头常量都能变，还有什么不能变的呢？</p><p>来看看下面这段代码，仔细想想常量真的变了吗？运行之后各个变量的值是多少呢？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> a = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">int</span> *p = <span class="keyword">const_cast</span>&lt;<span class="keyword">int</span>*&gt;(&amp;a);</span><br><span class="line">*p = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> b = *p;</span><br><span class="line"><span class="keyword">int</span> c = a;</span><br></pre></td></tr></table></figure><p>这段代码运行之后的打印结果：a=6, b=2, c=6，变量a作为一个常量没有被改变，貌似常量还是有点用的，哈哈~</p><p>这段代码转换成汇编代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">movl    $<span class="number">6</span>, <span class="number">-28</span>(%rbp)</span><br><span class="line">leaq    <span class="number">-28</span>(%rbp), %rax</span><br><span class="line">movq    %rax, <span class="number">-16</span>(%rbp)</span><br><span class="line">movq    <span class="number">-16</span>(%rbp), %rax</span><br><span class="line">movl    $<span class="number">2</span>, (%rax)</span><br><span class="line">movq    <span class="number">-16</span>(%rbp), %rax</span><br><span class="line">movl    (%rax), %eax</span><br><span class="line">movl    %eax, <span class="number">-24</span>(%rbp)</span><br><span class="line">movl    $<span class="number">6</span>, <span class="number">-20</span>(%rbp)</span><br></pre></td></tr></table></figure><p>通过汇编来看你会发现，其实变量a的值已经通过指针 <code>p</code> 修改过了，只不过后面引用a变量的地方，因为它是常量，直接使用立即数6替换了。</p><p>改写一下代码，将常量6换成一个变量：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> a = i;</span><br><span class="line"><span class="keyword">int</span> *p = <span class="keyword">const_cast</span>&lt;<span class="keyword">int</span>*&gt;(&amp;a);</span><br><span class="line">*p = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> b = *p;</span><br><span class="line"><span class="keyword">int</span> c = a;</span><br></pre></td></tr></table></figure><p>转换成汇编代码为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">movl    $<span class="number">3</span>, <span class="number">-28</span>(%rbp)</span><br><span class="line">movl    <span class="number">-28</span>(%rbp), %eax</span><br><span class="line">movl    %eax, <span class="number">-32</span>(%rbp)</span><br><span class="line">leaq    <span class="number">-32</span>(%rbp), %rax</span><br><span class="line">movq    %rax, <span class="number">-16</span>(%rbp)</span><br><span class="line">movq    <span class="number">-16</span>(%rbp), %rax</span><br><span class="line">movl    $<span class="number">2</span>, (%rax)</span><br><span class="line">movq    <span class="number">-16</span>(%rbp), %rax</span><br><span class="line">movl    (%rax), %eax</span><br><span class="line">movl    %eax, <span class="number">-24</span>(%rbp)</span><br><span class="line">movl    <span class="number">-32</span>(%rbp), %eax</span><br><span class="line">movl    %eax, <span class="number">-20</span>(%rbp)</span><br></pre></td></tr></table></figure><p>这段代码运行的结果为：i=3, a=2, b=2, c=2，看来常量也禁不住我们这么折腾啊</p><p>所以从这一点可以看出C++代码中无常量，只要是定义出的变量都可以修改，而常量只是给编译器优化提供一份指导，比如可以把一些字面量在编译期间替换，但是运行时的常量还是能改的。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>左值和右值更像是容器与数据的关系，不过C++11提出的将亡值的概念又模糊这两者的界限，将亡值可以看成是即将失去容器的数据</li><li>在Ubuntu16.04、GCC5.4.0的环境下，通过左值引用和指针修改一个变量值生成的汇编代码完全一致</li><li>C++11中右值引用与常量引用生成的汇编代码一致，与左值引用生成的代码只在初始化时有一点差异</li><li>常量并非不可修改，它只是一种“君子协定”，你要知道什么情况下可以改，什么情况下绝对不可以改</li><li><code>const_cast</code> 目的并不是让你去修改一个本身被定义为const的值，这样修改后果是可能是无法预期的，它存在的目的是调整一些指针、引用的权限，比如在函数传递参数的时候</li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/118257275" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>身上若无千斤担，谁拿生命赌明天~<br>世间唯一不变的就是变化</p><p>2021-7-5 00:36:29</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;对于左值和右值有一个不太严谨的定义——在赋值表达式 &lt;code&gt;=&lt;/code&gt; 左侧是的左值，而在 &lt;code&gt;=&lt;/code&gt; 右侧的是右值。通过不断学习和尝试，最近我发现一个新的说法更加贴切，那就是“左值是容器，右值是东西”。对于这个定义我们可以类比一下水杯和水，通过水杯可以操作水杯中的水，操作过程中的中间结果如果想要进一步操作，可以将其放入其他的水杯，如果没有水杯就无法找到曾经操作过的水了，也就无法继续操作了。&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; a = &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; b = &lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; c = a + b;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在这个例子中，变量 &lt;code&gt;a&lt;/code&gt;，&lt;code&gt;b&lt;/code&gt;, &lt;code&gt;c&lt;/code&gt; 都是水杯，而 &lt;code&gt;2&lt;/code&gt;、&lt;code&gt;6&lt;/code&gt;、&lt;code&gt;a + b&lt;/code&gt; 都是被用来操作的水，只有把这些“水”放到“水杯”中才能被找到，才可以进行下一步操作。&lt;/p&gt;
    
    </summary>
    
      <category term="C/C++" scheme="http://AlbertGithubHome.github.io/blog/categories/C-C/"/>
    
    
      <category term="C++" scheme="http://AlbertGithubHome.github.io/blog/tags/C/"/>
    
      <category term="C++11" scheme="http://AlbertGithubHome.github.io/blog/tags/C-11/"/>
    
      <category term="左值" scheme="http://AlbertGithubHome.github.io/blog/tags/%E5%B7%A6%E5%80%BC/"/>
    
      <category term="右值" scheme="http://AlbertGithubHome.github.io/blog/tags/%E5%8F%B3%E5%80%BC/"/>
    
      <category term="右值引用" scheme="http://AlbertGithubHome.github.io/blog/tags/%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>C++11中std::move和std::forward到底干了啥</title>
    <link href="http://AlbertGithubHome.github.io/blog/2021/07/04/C-11%E4%B8%ADstd-move%E5%92%8Cstd-forward%E5%88%B0%E5%BA%95%E5%B9%B2%E4%BA%86%E5%95%A5/"/>
    <id>http://AlbertGithubHome.github.io/blog/2021/07/04/C-11中std-move和std-forward到底干了啥/</id>
    <published>2021-07-03T16:28:50.000Z</published>
    <updated>2021-07-21T15:37:58.987Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>C++11中的右值引用的出现，在特定情况下减少了对象的拷贝，提升了C++程序的效率，伴随而来的 <code>std::move</code> 和 <code>std::forward</code> 也大量出现在程序代码中，但是这两个函数究竟干了啥呢？其实他们的本质都是转换函数，也就是完成左值和右值之间的转换，需要注意的是左值可以转换成右值，但是右值无法转换成左值。</p><a id="more"></a><p>关于左值、右值、左值引用和右值引用的概念可以看看之前的总结：</p><ul><li><a href="https://blog.csdn.net/albertsh/article/details/105756674" target="_blank" rel="noopener">简单聊聊C/C++中的左值和右值</a></li><li><a href="https://blog.csdn.net/albertsh/article/details/105941232" target="_blank" rel="noopener">C++11在左值引用的基础上增加右值引用</a></li></ul><p>虽然温故不一定知新，但绝对可以增强记忆，本章的内容说起来很绕，我也是边学边总结，有不对的地方还请大佬们指出来。</p><h1 id="左值引用和右值引用"><a href="#左值引用和右值引用" class="headerlink" title="左值引用和右值引用"></a>左值引用和右值引用</h1><p>了解过基础的引用知识之后我们都知道左值引用的形式为 <code>T&amp; t</code>，一般会像成下面这样使用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(A&amp; obj)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">A obj;</span><br><span class="line">test(obj);</span><br></pre></td></tr></table></figure><p>而右值引用是在左值引用的基础上多加一个<code>&amp;</code>，形式变为 <code>T&amp;&amp; t</code>，使用方式如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(A&amp;&amp; obj)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test(A());</span><br></pre></td></tr></table></figure><p>这种通过 <code>&amp;</code> 的个数区分左值引用和右值引用的方法，在大多数的普通函数中没有问题，但是放到模板参数或者 <code>auto</code> 关键字之后的位置就不太灵了，因为这些地方会推导实际的类型，正是有了参数推导，才使得模板中出现了“万能引用”的说法，也就是下面这样：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(T&amp;&amp; val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; val &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> year = <span class="number">2020</span>;</span><br><span class="line">    func(year);</span><br><span class="line">    func(<span class="number">2020</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数 <code>func</code> 即能接受变量 <code>year</code> 这样的左值作为参数，也能接受 <code>2020</code> 这样的常数作为右值，简直太完美。那么这里是怎样推导的呢？这就要请出一个引用的“折叠”规则了，描述如下：</p><blockquote><p>A&amp; &amp; 折叠成 A&amp;<br>  A&amp; &amp;&amp; 折叠成 A&amp;<br>  A&amp;&amp; &amp; 折叠成 A&amp;<br>  A&amp;&amp; &amp;&amp; 折叠成 A&amp;&amp;</p></blockquote><p>根据这个规则，<code>func</code> 函数在接受 <code>year</code> 作为参数时应该是一个左值引用，那么模板参数 <code>T</code> 会被推到为 <code>A&amp;</code> 与后面的 <code>&amp;&amp;</code> 折叠为 <code>A&amp;</code>，接受 <code>year</code> 没问题。而这个函数在接受 <code>2020</code> 作为参数时应该是一个右值引用，那么模板参数 <code>T</code> 会被推导成 <code>A</code>，与后面的 <code>&amp;&amp;</code> 形成 <code>A&amp;&amp;</code>，可以接受右值，知道了这些基础知识我们接着往后看。</p><h1 id="std-move"><a href="#std-move" class="headerlink" title="std::move"></a>std::move</h1><p>这个函数听起来好像是一个小人移动时调用的函数，但它却是一个把左值转化成右值的转化函数，我们看一下 <code>std::move</code> 函数的实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  @brief  Convert a value to an rvalue.</span></span><br><span class="line"><span class="comment"> *  @param  __t  A thing of arbitrary type.</span></span><br><span class="line"><span class="comment"> *  @return The parameter cast to an rvalue-reference to allow moving it.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line">  <span class="keyword">constexpr</span> <span class="keyword">typename</span> <span class="built_in">std</span>::remove_reference&lt;_Tp&gt;::type&amp;&amp;</span><br><span class="line">  move(_Tp&amp;&amp; <span class="keyword">__t</span>) <span class="keyword">noexcept</span></span><br><span class="line">  &#123; <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">typename</span> <span class="built_in">std</span>::remove_reference&lt;_Tp&gt;::type&amp;&amp;&gt;(<span class="keyword">__t</span>); &#125;</span><br></pre></td></tr></table></figure><p>这是一个模板函数，一共才4行，好像最麻烦的就是这个 <code>std::remove_reference&lt;_Tp&gt;::type&amp;&amp;</code> 了，先来看看它是什么，其实它的作用就是，<strong>移除类型的引用，返回原始类型。</strong></p><h2 id="std-remove-reference"><a href="#std-remove-reference" class="headerlink" title="std::remove_reference"></a>std::remove_reference</h2><p>它的可能实现如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">remove_reference</span> &#123;</span></span><br><span class="line">    <span class="keyword">using</span> type = T;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="comment">// 模板特化</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">remove_reference</span>&lt;T&amp;&gt; &#123;</span></span><br><span class="line">    <span class="keyword">using</span> type = T;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="comment">// 模板特化</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">remove_reference</span>&lt;T&amp;&amp;&gt; &#123;</span></span><br><span class="line">    <span class="keyword">using</span> type = T;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>它的作用可以参考 <a href="https://en.cppreference.com/w/cpp/types/remove_reference" target="_blank" rel="noopener">cppreference.com - remove_reference</a>，示例如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt; // std::cout</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;type_traits&gt; // std::is_same</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="title">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">print_is_same</span>() &#123;</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::is_same&lt;T1, T2&gt;() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::boolalpha;</span><br><span class="line"></span><br><span class="line">  print_is_same&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;();</span><br><span class="line">  print_is_same&lt;<span class="keyword">int</span>, <span class="keyword">int</span> &amp;&gt;();</span><br><span class="line">  print_is_same&lt;<span class="keyword">int</span>, <span class="keyword">int</span> &amp;&amp;&gt;();</span><br><span class="line"></span><br><span class="line">  print_is_same&lt;<span class="keyword">int</span>, <span class="built_in">std</span>::remove_reference&lt;<span class="keyword">int</span>&gt;::type&gt;();</span><br><span class="line">  print_is_same&lt;<span class="keyword">int</span>, <span class="built_in">std</span>::remove_reference&lt;<span class="keyword">int</span> &amp;&gt;::type&gt;();</span><br><span class="line">  print_is_same&lt;<span class="keyword">int</span>, <span class="built_in">std</span>::remove_reference&lt;<span class="keyword">int</span> &amp;&amp;&gt;::type&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">true</span><br><span class="line">false</span><br><span class="line">false</span><br><span class="line">true</span><br><span class="line">true</span><br><span class="line">true</span><br></pre></td></tr></table></figure><p>从这个例子可以清晰的看出 <code>std::remove_reference</code> 就是返回去掉引用的原始类型。</p><h2 id="static-cast"><a href="#static-cast" class="headerlink" title="static_cast"></a>static_cast</h2><p>明白了上面 <code>std::remove_reference</code> 的作用，整个 <code>std::move</code> 函数就剩下一个 <code>static_cast</code> 函数了，其实到这里也就清晰了，<code>std::move</code> 函数的作用就先通过 <code>std::remove_reference</code> 函数得到传入参数的原始类型 <code>X</code>，然后再把参数强转成 <code>X&amp;&amp;</code> 返回即可，参数的 <code>_Tp</code> 的推导参考引用折叠规则。</p><h2 id="std-move-到底干了啥"><a href="#std-move-到底干了啥" class="headerlink" title="std::move 到底干了啥"></a>std::move 到底干了啥</h2><p>通过前面的一通分析我们发现，<code>std::move</code> 的内部只做了一个强制类型转换，除此之外啥也没干，其实就是对传入的参数重新解释了一下，并没有实质性的动作。</p><p>那么为什么要使用 <code>std::move</code> 这个名字呢？这个名字更多的是起到提醒的作用，告诉使用者这里可能进行了到右值的转化，相关的对象后续可能发生移动，“被掏空”了，如果你继续使用这个对象，行为是未定义的，后果自负。</p><h1 id="std-forward"><a href="#std-forward" class="headerlink" title="std::forward"></a>std::forward</h1><p><code>std::forward</code> 被称为完美转发，听起来和 “万能引用”一样厉害，使用的头文件为 <code>&lt;utility&gt;</code>，在 <code>/usr/include/c++/5/bits/move.h</code> 文件中的定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  @brief  Forward an lvalue.</span></span><br><span class="line"><span class="comment"> *  @return The parameter cast to the specified type.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  This function is used to implement "perfect forwarding".</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line">  <span class="keyword">constexpr</span> _Tp&amp;&amp;</span><br><span class="line">  forward(<span class="keyword">typename</span> <span class="built_in">std</span>::remove_reference&lt;_Tp&gt;::type&amp; <span class="keyword">__t</span>) <span class="keyword">noexcept</span></span><br><span class="line">  &#123; <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;_Tp&amp;&amp;&gt;(<span class="keyword">__t</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  @brief  Forward an rvalue.</span></span><br><span class="line"><span class="comment"> *  @return The parameter cast to the specified type.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  This function is used to implement "perfect forwarding".</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line">  <span class="keyword">constexpr</span> _Tp&amp;&amp;</span><br><span class="line">  forward(<span class="keyword">typename</span> <span class="built_in">std</span>::remove_reference&lt;_Tp&gt;::type&amp;&amp; <span class="keyword">__t</span>) <span class="keyword">noexcept</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">static_assert</span>(!<span class="built_in">std</span>::is_lvalue_reference&lt;_Tp&gt;::value, <span class="string">"template argument"</span></span><br><span class="line">          <span class="string">" substituting _Tp is an lvalue reference type"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;_Tp&amp;&amp;&gt;(<span class="keyword">__t</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><code>std::forward</code> 用于函数模板中完成参数转发任务，我们必须在相应实参为左值，该形参成为左值引用时把它转发成左值，在相应实参为右值，该形参成为右值引用时把它转发成右值。</p><p>有了前面的铺垫我们直接来分析代码吧，第一个版本接受参数苏为左值引用的情况，因为 <code>std::remove_reference&lt;_Tp&gt;::type</code> 是 <code>_Tp</code> 的原始类型，所以 <code>t</code> 就是左值引用类型，调用这个函数时，<code>_Tp</code> 为 <code>X&amp;</code> 类型，经过引用这的 <code>_Tp&amp;&amp; =&gt; X&amp; &amp;&amp; =&gt; X&amp;</code>，所以返回值也是左值引用。</p><p>同理，第二个版本接受右值引用参数，返回值也是一个右值引用。</p><p>从目前的情况来看，<code>std::forward</code> 好像什么也没做，只是将参数强转以后返回，如果不使用这个函数会有什么问题呢？</p><h2 id="必要性"><a href="#必要性" class="headerlink" title="必要性"></a>必要性</h2><p>为什么要使用 <code>std::forward</code> 我们可以通过一个例子来看一下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">(<span class="keyword">int</span>&amp; val)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"lvalue refrence: val="</span> &lt;&lt; val &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">(<span class="keyword">int</span>&amp;&amp; val)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"rvalue refrence: val="</span> &lt;&lt; val &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TPrint</span><span class="params">(T &amp;&amp;t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Print(t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> date = <span class="number">1021</span>;</span><br><span class="line">    TPrint(date);</span><br><span class="line">    TPrint(<span class="number">501</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到这个例子可以先思考一下，运行结果会是什么呢？可能和你想的有点不一样哦，看看下面的答案：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lvalue refrence: val=1021</span><br><span class="line">lvalue refrence: val=501</span><br></pre></td></tr></table></figure><p>有点出乎意料啊，为什么 <code>Print(int&amp;&amp; val)</code> 这个函数没有被调用呢？原因在于“右值引用是一个左值”，很懵对不对，接着往下看：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">101</span>;</span><br><span class="line"><span class="keyword">int</span>&amp; li = i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>&amp;&amp; ri = <span class="number">120</span>;</span><br></pre></td></tr></table></figure><p>这段代码中哪些是左值，哪些是右值呢？可以肯定的是 <code>i</code>、<code>li</code> 是左值， <code>101</code>、<code>120</code> 是右值，而<code>ri</code>也是左值，因为它也一个可以取地址并长期有效的变量啊，只不过这个左值引用了一个右值而已。</p><p>接着回到刚才的例子，<code>TPrint(501);</code> 调用模板函数时，T被推导为 <code>int</code>，所以模板被实例化为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TPrint</span><span class="params">(<span class="keyword">int</span>&amp;&amp; t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Print(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行到这里，<code>t</code> 实际上是一个左值，所以调用了 <code>void Print(int&amp; val)</code> 这个函数，那么怎样才能调用 <code>void Print(int&amp;&amp; val)</code> 这个版本呢？是时候请出 <code>std::forward</code> 函数了，将模板函数进行如下修改：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TPrint</span><span class="params">(T&amp;&amp; t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Print(<span class="built_in">std</span>::forward&lt;T&gt;(t));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改之后再来分析一下，<code>TPrint(501);</code> 调用模板函数时，T被推导为 <code>int</code>，所以模板被实例化为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TPrint</span><span class="params">(<span class="keyword">int</span>&amp;&amp; t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Print(<span class="built_in">std</span>::forward&lt;<span class="keyword">int</span>&gt;(t));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里会调用 <code>std::forward</code> 的这个版本：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line">  <span class="keyword">constexpr</span> _Tp&amp;&amp;</span><br><span class="line">  forward(<span class="keyword">typename</span> <span class="built_in">std</span>::remove_reference&lt;_Tp&gt;::type&amp;&amp; <span class="keyword">__t</span>) <span class="keyword">noexcept</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">static_assert</span>(!<span class="built_in">std</span>::is_lvalue_reference&lt;_Tp&gt;::value, <span class="string">"template argument"</span></span><br><span class="line">          <span class="string">" substituting _Tp is an lvalue reference type"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;_Tp&amp;&amp;&gt;(<span class="keyword">__t</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>函数的返回类型为 <code>int&amp;&amp;</code>，然后就调用了 <code>void Print(int&amp;&amp; val)</code> 这个版本的打印函数。</p><h2 id="疑惑"><a href="#疑惑" class="headerlink" title="疑惑"></a>疑惑</h2><p>可能有人会说，这不对啊，使用 <code>std::forward</code> 修改之前函数参数就是 <code>int&amp;&amp;</code> 类型，修改之后得到的返回值还是 <code>int&amp;&amp;</code> 类型，这有什么区别吗？</p><p>这里的区别就在于，使用 <code>std::forward</code> 之前的 <code>int&amp;&amp;</code> 是有名字的变量 <code>t</code>，它是一个左值，而使用 <code>std::forward</code> 之后的 <code>int&amp;&amp;</code> 是有个匿名变量，它是一个右值，真正的差距就在这里。</p><h2 id="std-forward-到底干了啥"><a href="#std-forward-到底干了啥" class="headerlink" title="std::forward 到底干了啥"></a>std::forward 到底干了啥</h2><p>它和 <code>std::move</code> 一样，<code>std::forward</code> 也是做了一个强制类型转换，当形参成为左值引用时把它转换成左值引用返回，当形参成为右值引用时把它转换成右值引用返回。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li><code>std::move</code> 并没有实际的“移动”操作，只是在内部进行了强制类型转换，返回一个相关类型的右值引用</li><li><code>std::move</code> 的名字主要标识它后续可能会被其他人“掏空”，调用它之后如果继续使用，行为未定义，后果自负</li><li><code>std::forward</code> 的本质也是进行强制类型转换，形参为左值时返回左值引用，形参为右值时返回右值引用</li><li>从定义入手可以理解很多花里胡哨的东西，透过现象看其本质。</li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/118663176" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>日拱一卒无有尽，功不唐捐终入海~</p><p>我们追求的样子：十分沉静，九分气质，八分资产，七分现实，三分颜值，二分糊涂，一份自知之明。</p><p>2021-7-18 21:23:01</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;C++11中的右值引用的出现，在特定情况下减少了对象的拷贝，提升了C++程序的效率，伴随而来的 &lt;code&gt;std::move&lt;/code&gt; 和 &lt;code&gt;std::forward&lt;/code&gt; 也大量出现在程序代码中，但是这两个函数究竟干了啥呢？其实他们的本质都是转换函数，也就是完成左值和右值之间的转换，需要注意的是左值可以转换成右值，但是右值无法转换成左值。&lt;/p&gt;
    
    </summary>
    
      <category term="C/C++" scheme="http://AlbertGithubHome.github.io/blog/categories/C-C/"/>
    
    
      <category term="C++" scheme="http://AlbertGithubHome.github.io/blog/tags/C/"/>
    
      <category term="C++11" scheme="http://AlbertGithubHome.github.io/blog/tags/C-11/"/>
    
      <category term="move" scheme="http://AlbertGithubHome.github.io/blog/tags/move/"/>
    
      <category term="forward" scheme="http://AlbertGithubHome.github.io/blog/tags/forward/"/>
    
      <category term="完美转发" scheme="http://AlbertGithubHome.github.io/blog/tags/%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91/"/>
    
  </entry>
  
</feed>
