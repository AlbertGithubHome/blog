<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Albert World</title>
  <icon>https://www.gravatar.com/avatar/8ccc6291d5bfd34e7aaf601c4ebec7e1</icon>
  
  <link href="/blog/atom.xml" rel="self"/>
  
  <link href="http://AlbertGithubHome.github.io/blog/"/>
  <updated>2021-04-04T16:36:26.329Z</updated>
  <id>http://AlbertGithubHome.github.io/blog/</id>
  
  <author>
    <name>Albert Shi</name>
    <email>347070901@qq.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>写给自己的KMP——C++版本</title>
    <link href="http://AlbertGithubHome.github.io/blog/2021/04/04/%E5%86%99%E7%BB%99%E8%87%AA%E5%B7%B1%E7%9A%84KMP%E2%80%94%E2%80%94C-%E7%89%88%E6%9C%AC/"/>
    <id>http://AlbertGithubHome.github.io/blog/2021/04/04/写给自己的KMP——C-版本/</id>
    <published>2021-04-04T15:03:12.000Z</published>
    <updated>2021-04-04T16:36:26.329Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h1><p>又翻到了这个算法，一个常用的子串（子数组）匹配算法，看一遍学一遍，学一遍忘一遍，反反复复，不过每次回忆起来所用的时间越来少了，其本质上就是在暴力搜索的基础上加上 next 数组加速匹配，算法的关键在于 next 数组的理解和求解方法。</p><p>不想画图，缺少图解的算法很难给初学者讲清楚，所以本文也仅仅是个人的笔记而已，用于记录算法中关键点、帮助回忆或者理解其中的一些关键因素，如果想从头学习 <code>KMP</code>，还是去搜索其他资料吧，相关的内容有很多，有些文章写的很详细的。</p><p>今天的示例代码用C++来写，上一版的自己写的KMP我查了一下是C语言版本的，初看起来已经有点费劲了，随着时间的推移，我决定根据理解再写一次，写完才发现，和之前的风格判若两人。</p><h1 id="二、暴力搜索"><a href="#二、暴力搜索" class="headerlink" title="二、暴力搜索"></a>二、暴力搜索</h1><p>在原字符串中搜索模式串，最容易想到的就是暴力搜索，匹配则向后移动，不匹配则原串回溯，模式串归0，代码很容易实现，列举如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">violence_find</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = s.size(), n = p.size(), i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt; m &amp;&amp; j &lt; n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == p[j]) &#123; <span class="comment">// match character</span></span><br><span class="line">            ++i;</span><br><span class="line">            ++j;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// mismatch</span></span><br><span class="line">            i -= j - <span class="number">1</span>;</span><br><span class="line">            j = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> j == n ? i - j : <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(<span class="string">"abdfdjfdkekfdaa5gsdsf"</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">p</span><span class="params">(<span class="string">"fdkekfd"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; violence_find(s, p) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>典型的 <code>O(MN)</code> 解法，这种解法慢就慢在原字符串的回溯上，也就是语句 <code>i -= j - 1;</code> 的效果，当出现失配时，原字符串之前的匹配几乎“白费”，每次最多移动一个字符，而 KMP 算法决定利用之前的“努力成果”。</p><h1 id="三、KMP算法"><a href="#三、KMP算法" class="headerlink" title="三、KMP算法"></a>三、KMP算法</h1><p>在 KMP 算法中先利用模式串构建一个 next 数组，当出现失配情况时根据模式串前缀和后缀情况，最大程序利用已经匹配的部分来达到加速查找的目的，只需要求一个 next 数组，其他部分和暴力匹配的代码很像：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kmp_tmp</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = s.size(), n = p.size(), i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; next = <span class="built_in">std</span>::move(gen_next(p));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt; m &amp;&amp; j &lt; n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == p[j]) &#123;</span><br><span class="line">            ++i;</span><br><span class="line">            ++j;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// mismatch</span></span><br><span class="line">            j = next[j];</span><br><span class="line">            <span class="keyword">if</span> (j == <span class="number">-1</span>) &#123;</span><br><span class="line">                ++i;</span><br><span class="line">                j = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> j == n ? i - j : <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和暴力搜索的代码对照下，只有 <code>else</code> 中语句块不太一样，这个 <code>i</code> 只前进不后退了，其实这个里的 <code>j == -1</code> 语句可以合并到判定相等的 <code>if</code> 语句块中，完成 KMP 代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; gen_next(<span class="built_in">string</span> p) &#123;</span><br><span class="line">    <span class="keyword">int</span> n = p.size(), i = <span class="number">0</span>, j = <span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; next(n, <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt; n - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">-1</span> || p[i] == p[j]) &#123;</span><br><span class="line">            ++i;</span><br><span class="line">            ++j;</span><br><span class="line">            next[i] = j;</span><br><span class="line">        &#125; <span class="keyword">else</span> j = next[j]; <span class="comment">// mismatch, move j</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kmp</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = s.size(), n = p.size(), i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; next = <span class="built_in">std</span>::move(gen_next(p));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt; m &amp;&amp; j &lt; n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">-1</span> || s[i] == p[j]) &#123;</span><br><span class="line">            ++i;</span><br><span class="line">            ++j;</span><br><span class="line">        &#125; <span class="keyword">else</span> j = next[j]; <span class="comment">// mismatch, move j</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> j == n ? i - j : <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(<span class="string">"abdfdjfdkekfdaa5gsdsf"</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">p</span><span class="params">(<span class="string">"fdkekfd"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; kmp(s, p) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="四、关键点记录"><a href="#四、关键点记录" class="headerlink" title="四、关键点记录"></a>四、关键点记录</h1><ol><li><p>next[i] 中记录的实际上是 <code>p[0,i-1]</code> 这个字符串中所有前缀和所有后缀交集中最长字符串的长度，比如<code>&#39;fdkekfd&#39;</code> 这个字符串所有前缀和所有后缀交集中最长字符串是 <code>&#39;fd&#39;</code>，其长度是2。</p></li><li><p>字符串的前缀和后缀不包括字符串本身。</p></li><li><p><code>next[0]</code> 初始化成-1仅仅是一个编程技巧，你可以初始化成任意值，只要你分辨出是失配的情况即可，这里初始成 -1 正好可以和 <code>s[i] == p[j]</code> 这种情况合并，所以初始化成 -1 会常用一点。</p></li><li><p>在 KMP 算法中原串索引 <code>i</code> 比较傲娇，它只前进不会回溯，这也是 KMP 速度快的一个主要原因。</p></li><li><p>当出现失配时，模式子串的前缀和后缀有重合，可以直接移动模式串的前缀到刚刚匹配的后缀部分，但要记住如果没有重合的前缀和后缀，失配时移动模式串的速度会更快，这里容易弄反。</p></li></ol><h1 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h1><ul><li>KMP 算法的关键是求解 next 数组，是一个被称为部分匹配表(Partial Match Table)的数组</li><li>KMP 算法相比暴力匹配时间复杂度提升到了O(N+M)，但是并不是最优秀的字符串匹配算法</li><li>想要更快或者选择更合适的算法可以了解下从模式串的尾部开始匹配的 <code>BM算法</code>，以及从模式串的头部开始匹配的 <code>Sunday算法</code></li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/115290419" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>想要看到更高的风景，除了让自己跳的更高以外，还可以选一个更高的平台站上去。找到一个2米高的平台并努力爬上去，远比你原地起跳2米要容易的多~</p><p>2021-4-5 00:22:35</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;一、前言&lt;/h1&gt;&lt;p&gt;又翻到了这个算法，一个常用的子串（子数组）匹配算法，看一遍学一遍，学一遍忘一遍，反反复复，不过每次回忆起来所用的时间越来少了
      
    
    </summary>
    
      <category term="C/C++" scheme="http://AlbertGithubHome.github.io/blog/categories/C-C/"/>
    
    
      <category term="C/C++" scheme="http://AlbertGithubHome.github.io/blog/tags/C-C/"/>
    
      <category term="find" scheme="http://AlbertGithubHome.github.io/blog/tags/find/"/>
    
      <category term="算法" scheme="http://AlbertGithubHome.github.io/blog/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="KMP" scheme="http://AlbertGithubHome.github.io/blog/tags/KMP/"/>
    
  </entry>
  
  <entry>
    <title>C++中常见的字符判断与处理方法</title>
    <link href="http://AlbertGithubHome.github.io/blog/2021/03/28/C-%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84%E5%AD%97%E7%AC%A6%E5%88%A4%E6%96%AD%E4%B8%8E%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95/"/>
    <id>http://AlbertGithubHome.github.io/blog/2021/03/28/C-中常见的字符判断与处理方法/</id>
    <published>2021-03-28T10:01:24.000Z</published>
    <updated>2021-03-28T15:34:08.874Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>字符串处理是编程世界中一项基础技能，特别是对于C/C++的程序员们，远没有那么多华丽的工具可以使用，大多数时候都需要一个个字符来判断和处理，甚至对于C语言来说都没有字符串类型，字符数组是其常见的等价结构，所以稳扎稳打的基本功尤其重要。</p><a id="more"></a><p>对于C++而言，确实有<code>string</code>这个字符串类型，在使用的时候有一些技巧和函数可以使用，比C语言要方便许多了，只是有些时候我们并不知道可以这样用，有时一些很朴素的写法会让程序更加简洁，而一些技巧的表达当明白之后也会感叹自己曾经的无知。</p><h1 id="ASCII-码"><a href="#ASCII-码" class="headerlink" title="ASCII 码"></a>ASCII 码</h1><p>作为字符编码的基础，ASCII码是需要先弄明白的，即使不能把所有的ASCII码对应的字符都记住，也要把常见的字母、数字、特殊字符记住，这样在处理字符问题时可以得心应手，常见的ASCII码对照表如下：</p><p>其中需要注意的知识点：</p><ul><li>前32个为非打印控制字符，后面的字符为打印字符</li><li>数字字符 <code>&#39;0&#39;-&#39;9&#39;</code> 对应的ASCII码范围是48-57</li><li>大写字母 <code>&#39;A&#39;-&#39;Z&#39;</code> 对应的ASCII码范围是65-90</li><li>小写字母 <code>&#39;a&#39;-&#39;z&#39;</code> 对应的ASCII码范围是97-122</li><li><code>NULL</code> 对应ASCII码0，回车的ASCII码是13，换行的ASCII码是10</li></ul><p>仔细观察这个ASCII表你会发现很多“秘密”，比如 windows 中的文件放到 linux 上打开时常常显示许多的 <code>^M</code>，其实这就是<code>\r</code> 的表现，因为在 windows 上用 <code>\r\n</code> 表示换行，而 linux 上使用 <code>\n</code> 换行，那么多余的 <code>\r</code> 在 linux 上就会显示成 <code>^M</code>。</p><p>再比如小写字母 <code>a</code> 和大写字母 <code>A</code> 中间差了32，为什么不是26呢？为什么要在中间插入几个别的字符，搞成连续的不好吗？之前没想过这个问题，但是前两天看了一个高手的代码后，我大概明白了，这个32的差距应该是一种“炫技”的表现，它可以使得许多代码逻辑变得简单。</p><h1 id="判断字符范围的函数"><a href="#判断字符范围的函数" class="headerlink" title="判断字符范围的函数"></a>判断字符范围的函数</h1><h2 id="C-语言"><a href="#C-语言" class="headerlink" title="C 语言"></a>C 语言</h2><p>C语言中判断的字符范围的函数都在头文件 <code>&lt;ctype.h&gt;</code> 中，常见的有下面这些</p><ul><li><code>int isalnum(int c)</code>：检查所传的字符是否是字母和数字</li><li><code>int isalpha(int c)</code>：检查所传的字符是否是字母</li><li><code>int isdigit(int c)</code>：检查所传的字符是否是十进制数字</li><li><code>int islower(int c)</code>：检查所传的字符是否是小写字母</li><li><code>int isupper(int c)</code>：检查所传的字符是否是大写字母</li><li><code>int ispunct(int c)</code>：检查所传的字符是否是标点符号字符</li></ul><h2 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h2><p>C++ 中其实大部分还是引用C语言里的这些函数，但是头文件的名字为 <code>&lt;cctype&gt;</code>，在C++11中加了一个 <code>int isblank(int c)</code> 函数。</p><h1 id="字符判断技巧"><a href="#字符判断技巧" class="headerlink" title="字符判断技巧"></a>字符判断技巧</h1><h2 id="判断两个字符互为大小写"><a href="#判断两个字符互为大小写" class="headerlink" title="判断两个字符互为大小写"></a>判断两个字符互为大小写</h2><p>看到这个问题第一直觉是什么？很简单的问题有木有？因为知道一个字母的大小写差了32，所以会写出下面的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isOk</span><span class="params">(<span class="keyword">char</span> x, <span class="keyword">char</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x - y == <span class="number">32</span> || y - x == <span class="number">32</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过我前两天看到一段代码，它是这样写的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(x ^ <span class="number">32</span>) == y;</span><br></pre></td></tr></table></figure><p>看到这里你还以为 <code>A</code> 和 <code>a</code> 之间差32而不是26感到迷惑吗？简单的字符编排透露着巨大的智慧。</p><h2 id="哨兵的使用"><a href="#哨兵的使用" class="headerlink" title="哨兵的使用"></a>哨兵的使用</h2><p>比如取出一个字符串 <code>string s</code> 中所有的数字，问题很简单，但是结尾字符的处理往往体现了编程的功底，加上一个哨兵字符可以使得编程逻辑简单许多，无须再对结尾字符特殊判断。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">find</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">    s = s + <span class="string">'A'</span>;</span><br><span class="line">    <span class="built_in">string</span> ans;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> c : s) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isdigit</span>(c)) ans += c;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            ans = <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li><code>&#39;0&#39;</code> 的ASCII码是48，<code>&#39;A&#39;</code> 的ASCII码是65，<code>&#39;a&#39;</code> 的ASCII码是97</li><li><code>isdigit</code> 可以判断字符是否是数字，<code>isalpha</code> 可以判断字符是否为字母</li><li>一个字母的大小写对应的ASCII码正好差32，判断互为大小写时可以使用异或符号 <code>(x ^ 32) == y</code></li><li>字符串结尾加哨兵字符可以使得处理逻辑更加简单统一，这种编程技巧在其他结构中也常常出现</li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/115059262" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>今天看到一个一直作为榜样的知识输出者宣布财富自由，满心羡慕，是真的羡慕！关键人家比我年轻，比我工作时间还短，已经依靠短短4、5年的努力达到了自由状态，不过了解他的经历会发现他确实付出了很多，而我们大多数作为普通人太安于现状了，有时候选择比努力重要，如果选择对了又付出了加倍的努力，那……</p><p>2021-3-28 23:27:32</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;字符串处理是编程世界中一项基础技能，特别是对于C/C++的程序员们，远没有那么多华丽的工具可以使用，大多数时候都需要一个个字符来判断和处理，甚至对于C语言来说都没有字符串类型，字符数组是其常见的等价结构，所以稳扎稳打的基本功尤其重要。&lt;/p&gt;
    
    </summary>
    
      <category term="C/C++" scheme="http://AlbertGithubHome.github.io/blog/categories/C-C/"/>
    
    
      <category term="C/C++" scheme="http://AlbertGithubHome.github.io/blog/tags/C-C/"/>
    
      <category term="string" scheme="http://AlbertGithubHome.github.io/blog/tags/string/"/>
    
      <category term="char" scheme="http://AlbertGithubHome.github.io/blog/tags/char/"/>
    
      <category term="判断" scheme="http://AlbertGithubHome.github.io/blog/tags/%E5%88%A4%E6%96%AD/"/>
    
      <category term="查询" scheme="http://AlbertGithubHome.github.io/blog/tags/%E6%9F%A5%E8%AF%A2/"/>
    
  </entry>
  
  <entry>
    <title>C++中反向遍历map时怎样删除元素</title>
    <link href="http://AlbertGithubHome.github.io/blog/2021/03/21/C-%E4%B8%AD%E5%8F%8D%E5%90%91%E9%81%8D%E5%8E%86map%E6%97%B6%E6%80%8E%E6%A0%B7%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0/"/>
    <id>http://AlbertGithubHome.github.io/blog/2021/03/21/C-中反向遍历map时怎样删除元素/</id>
    <published>2021-03-21T07:08:49.000Z</published>
    <updated>2021-03-21T12:02:17.918Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>今天在解决一个问题 <a href="https://leetcode-cn.com/problems/number-of-orders-in-the-backlog/" target="_blank" rel="noopener">《5710. 积压订单中的订单总数》</a> 时用到了map的反向遍历，看到问题时首先想到了优先队列，但是需要维护一个大根堆和一个小根堆，感觉操作起来比较麻烦，突发奇想使用map就能够解决。map本身就是有序的，正向遍历可以得到从小到大的序列，而反向遍历就可以得到从大到小的序列，这个思路本身没有错，但是解题时卡在了反向遍历时如何删除元素的知识点上，特此记录一下。</p><a id="more"></a><h1 id="map的正向遍历"><a href="#map的正向遍历" class="headerlink" title="map的正向遍历"></a>map的正向遍历</h1><p>map的正向遍历是一个基础知识点了，先简单复习一下，不管是用 for 还是 while，只要控制迭代器持续前进就可以了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt; mp&#123;&#123;<span class="number">1</span>, <span class="string">"A"</span>&#125;, &#123;<span class="number">2</span>, <span class="string">"E"</span>&#125;, &#123;<span class="number">3</span>, <span class="string">"I"</span>&#125;, &#123;<span class="number">4</span>, <span class="string">"O"</span>&#125;, &#123;<span class="number">6</span>, <span class="string">"U"</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;::iterator it = mp.begin(); it != mp.end(); ++it) &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">" "</span> &lt;&lt; it-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 输出内容</span></span><br><span class="line"><span class="comment">1 A</span></span><br><span class="line"><span class="comment">2 E</span></span><br><span class="line"><span class="comment">3 I</span></span><br><span class="line"><span class="comment">4 O</span></span><br><span class="line"><span class="comment">6 U</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>引入 <code>auto</code> 关键字以后，定义表示式的时候会更加方便一点</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt; mp&#123;&#123;<span class="number">1</span>, <span class="string">"A"</span>&#125;, &#123;<span class="number">2</span>, <span class="string">"E"</span>&#125;, &#123;<span class="number">3</span>, <span class="string">"I"</span>&#125;, &#123;<span class="number">4</span>, <span class="string">"O"</span>&#125;, &#123;<span class="number">6</span>, <span class="string">"U"</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = mp.begin(); it != mp.end(); ++it) &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">" "</span> &lt;&lt; it-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>引入冒号以后表达式更加简短，要注意的是这里的 <code>it</code> 已经不是指针了，而是 <code>value_type</code> 类型，所以需要是用 <code>.</code> 来访问</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt; mp&#123;&#123;<span class="number">1</span>, <span class="string">"A"</span>&#125;, &#123;<span class="number">2</span>, <span class="string">"E"</span>&#125;, &#123;<span class="number">3</span>, <span class="string">"I"</span>&#125;, &#123;<span class="number">4</span>, <span class="string">"O"</span>&#125;, &#123;<span class="number">6</span>, <span class="string">"U"</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it : mp) &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; it.first &lt;&lt; <span class="string">" "</span> &lt;&lt; it.second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>引入了结构化绑定声明之后，遍历方式还可以写成下面这样</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt; mp&#123;&#123;<span class="number">1</span>, <span class="string">"A"</span>&#125;, &#123;<span class="number">2</span>, <span class="string">"E"</span>&#125;, &#123;<span class="number">3</span>, <span class="string">"I"</span>&#125;, &#123;<span class="number">4</span>, <span class="string">"O"</span>&#125;, &#123;<span class="number">6</span>, <span class="string">"U"</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; [a, b] : mp) &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="string">" "</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="map-遍历时删除元素"><a href="#map-遍历时删除元素" class="headerlink" title="map 遍历时删除元素"></a>map 遍历时删除元素</h1><p>map 遍历时删除需要注意迭代器失效问题，常用的有下面两种写法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">it = mp.erase(it);</span><br></pre></td></tr></table></figure><p>或者<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mp.erase(it++);</span><br></pre></td></tr></table></figure></p><p>遍历删除时的例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt; mp&#123;&#123;<span class="number">1</span>, <span class="string">"A"</span>&#125;, &#123;<span class="number">2</span>, <span class="string">"E"</span>&#125;, &#123;<span class="number">3</span>, <span class="string">"I"</span>&#125;, &#123;<span class="number">4</span>, <span class="string">"O"</span>&#125;, &#123;<span class="number">6</span>, <span class="string">"U"</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = mp.begin(); it != mp.end();) &#123;</span><br><span class="line">    <span class="keyword">if</span> (it-&gt;second == <span class="string">"I"</span>)</span><br><span class="line">        mp.erase(it++);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        it++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it : mp) <span class="built_in">cout</span> &lt;&lt; it.first &lt;&lt; <span class="string">" "</span> &lt;&lt; it.second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 输出内容</span></span><br><span class="line"><span class="comment">1 A</span></span><br><span class="line"><span class="comment">2 E</span></span><br><span class="line"><span class="comment">4 O</span></span><br><span class="line"><span class="comment">6 U</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h1 id="map-的反向遍历"><a href="#map-的反向遍历" class="headerlink" title="map 的反向遍历"></a>map 的反向遍历</h1><p>map 反向遍历时可以使用 <a href="https://en.cppreference.com/w/cpp/iterator/reverse_iterator" target="_blank" rel="noopener">reverse_iterator</a> 迭代器，配合 <code>rbegin()</code> 和 <code>rend()</code> 方法就可以完成反向遍历</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt; mp&#123;&#123;<span class="number">1</span>, <span class="string">"A"</span>&#125;, &#123;<span class="number">2</span>, <span class="string">"E"</span>&#125;, &#123;<span class="number">3</span>, <span class="string">"I"</span>&#125;, &#123;<span class="number">4</span>, <span class="string">"O"</span>&#125;, &#123;<span class="number">6</span>, <span class="string">"U"</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = mp.rbegin(); it != mp.rend(); it++) &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">" "</span> &lt;&lt; it-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 输出内容</span></span><br><span class="line"><span class="comment">6 U</span></span><br><span class="line"><span class="comment">4 O</span></span><br><span class="line"><span class="comment">3 I</span></span><br><span class="line"><span class="comment">2 E</span></span><br><span class="line"><span class="comment">1 A</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h1 id="map-反向遍历时删除元素"><a href="#map-反向遍历时删除元素" class="headerlink" title="map 反向遍历时删除元素"></a>map 反向遍历时删除元素</h1><p>一开始也是用 <code>erase</code> 函数来删除元素，但是会报下面的编译错误</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">error: no matching function <span class="keyword">for</span> call to ‘<span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">std</span>::__cxx11::basic_string&lt;<span class="keyword">char</span>&gt; &gt;::erase(</span><br><span class="line">    <span class="built_in">std</span>::reverse_iterator&lt;<span class="built_in">std</span>::_Rb_tree_iterator&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">const</span> <span class="keyword">int</span>, <span class="built_in">std</span>::__cxx11::basic_string&lt;<span class="keyword">char</span>&gt; &gt; &gt; &gt;)’</span><br><span class="line">    mp.erase(it++);</span><br></pre></td></tr></table></figure><p>查询文档发现，<code>erase</code> 函数重载只有下面几种实现:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">erase</span><span class="params">( iterator pos )</span></span>;                                     (until C++<span class="number">11</span>)</span><br><span class="line"><span class="function">iterator <span class="title">erase</span><span class="params">( const_iterator pos )</span></span>;                           (since C++<span class="number">11</span>)</span><br><span class="line"><span class="function">iterator <span class="title">erase</span><span class="params">( iterator pos )</span></span>;                                 (since C++<span class="number">17</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">erase</span><span class="params">( iterator first, iterator last )</span></span>;                    (until C++<span class="number">11</span>)</span><br><span class="line"><span class="function">iterator <span class="title">erase</span><span class="params">( const_iterator first, const_iterator last )</span></span>;    (since C++<span class="number">11</span>)</span><br><span class="line"></span><br><span class="line"><span class="function">size_type <span class="title">erase</span><span class="params">( <span class="keyword">const</span> key_type&amp; key )</span></span>;</span><br></pre></td></tr></table></figure><p>参数是迭代器的函数并不支持 <code>reverse_iterator</code>，需要将 <code>reverse_iterator</code> 转化成 <code>iterator</code> 才可以，这时就需要用到 <code>base</code> 函数，对 <code>reverse_iterator</code> 类型的迭代器使用 <code>base</code> 函数得到的是上一个元素“原始指针”，这一点比较有意思，具体的解释可以参考 <a href="https://en.cppreference.com/w/cpp/iterator/reverse_iterator/base" target="_blank" rel="noopener">《std::reverse_iterator<iter>::base》</iter></a>，这种操作决定了我们遍历删除的写法，应该是先自增再调用 <code>base</code> 函数，代码如下；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt; mp&#123;&#123;<span class="number">1</span>, <span class="string">"A"</span>&#125;, &#123;<span class="number">2</span>, <span class="string">"E"</span>&#125;, &#123;<span class="number">3</span>, <span class="string">"I"</span>&#125;, &#123;<span class="number">4</span>, <span class="string">"O"</span>&#125;, &#123;<span class="number">6</span>, <span class="string">"U"</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = mp.rbegin(); it != mp.rend();) &#123;</span><br><span class="line">    <span class="keyword">if</span> (it-&gt;second == <span class="string">"I"</span>) mp.erase((++it).base());</span><br><span class="line">    <span class="keyword">else</span> it++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = mp.rbegin(); it != mp.rend(); it++)</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">" "</span> &lt;&lt; it-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 输出内容</span></span><br><span class="line"><span class="comment">6 U</span></span><br><span class="line"><span class="comment">4 O</span></span><br><span class="line"><span class="comment">2 E</span></span><br><span class="line"><span class="comment">1 A</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>map 默认会按照 key 排序，是一个常用的有序容器</li><li>配合使用 <code>rbegin()</code> 和 <code>rend()</code> 函数可以完成 map 的反向遍历</li><li>对 <code>reverse_iterator</code> 类型迭代器使用 <code>base()</code> 函数，可以转化成 <code>iterator</code> 相关类型，然后进行删除操作</li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/114806994" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>搬起砖，我抱不了你，放下砖 … 我尽力！</p><p>2021-3-21 19:44:27</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;今天在解决一个问题 &lt;a href=&quot;https://leetcode-cn.com/problems/number-of-orders-in-the-backlog/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《5710. 积压订单中的订单总数》&lt;/a&gt; 时用到了map的反向遍历，看到问题时首先想到了优先队列，但是需要维护一个大根堆和一个小根堆，感觉操作起来比较麻烦，突发奇想使用map就能够解决。map本身就是有序的，正向遍历可以得到从小到大的序列，而反向遍历就可以得到从大到小的序列，这个思路本身没有错，但是解题时卡在了反向遍历时如何删除元素的知识点上，特此记录一下。&lt;/p&gt;
    
    </summary>
    
      <category term="C/C++" scheme="http://AlbertGithubHome.github.io/blog/categories/C-C/"/>
    
    
      <category term="C/C++" scheme="http://AlbertGithubHome.github.io/blog/tags/C-C/"/>
    
      <category term="iterator" scheme="http://AlbertGithubHome.github.io/blog/tags/iterator/"/>
    
      <category term="reverse_iterator" scheme="http://AlbertGithubHome.github.io/blog/tags/reverse-iterator/"/>
    
      <category term="base" scheme="http://AlbertGithubHome.github.io/blog/tags/base/"/>
    
  </entry>
  
  <entry>
    <title>解决git命令会将结果输出到单独窗口必须按q才能退出的问题</title>
    <link href="http://AlbertGithubHome.github.io/blog/2021/03/14/%E8%A7%A3%E5%86%B3git%E5%91%BD%E4%BB%A4%E4%BC%9A%E5%B0%86%E7%BB%93%E6%9E%9C%E8%BE%93%E5%87%BA%E5%88%B0%E5%8D%95%E7%8B%AC%E7%AA%97%E5%8F%A3%E5%BF%85%E9%A1%BB%E6%8C%89q%E6%89%8D%E8%83%BD%E9%80%80%E5%87%BA%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://AlbertGithubHome.github.io/blog/2021/03/14/解决git命令会将结果输出到单独窗口必须按q才能退出的问题/</id>
    <published>2021-03-14T08:19:15.000Z</published>
    <updated>2021-03-14T14:26:22.534Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>平时会在 windows+linux 两种环境下进行开发，版本控制软件用 git 比较多，但是一直有个小问题，在 windows 下使用 <code>git Bash</code> 比较顺手，但是在 linux 使用 git 部分命令的时候，常常会打开一个新的窗口，按q键才能退出，比如 <code>git branch</code>、<code>git log</code>、<code>git show</code> 等等。</p><a id="more"></a><p>如果是使用 <code>git log</code> 查询日志后想进行合并或者回退等操作时，因为日志信息已经退出没有显示在当前窗口，这种情况会比较麻烦，有时候还需要额外再查询一次，还有就是 <code>git branch</code> 命显示内容常常较少，单独打开一个窗口也没有必要，所以想单独设置这种情况，后来查询资料发现，这与 git 的 pager 设置有关，特此记录一下。</p><h1 id="什么是-pager"><a href="#什么是-pager" class="headerlink" title="什么是 pager"></a>什么是 pager</h1><p>pager 其实就是分页器，也就是对一大段内容进行分页显示的工具，git 在一些版本中默认使用的是 less 工具，不同的版本默认设置会有差异，这也就是造成我在 windows 下没有自动分页，而在 linux 下会打开新窗口进行分页的原因。</p><p>git 的分页器可以通过 <code>core.pager</code> 来进行设置，他会被 git 命令行解释，影响分页器的变量有多个，他们起作用的顺序依次是 <code>$GIT_PAGER</code> 环境变量，<code>core.pager</code> git配置，<code>$PAGER</code> 环境变量，如果这些都没有设置，默认会选择编译时的选项（通常为less），具体细节可以参考官方文档 <a href="https://git-scm.com/docs/git-config#Documentation/git-config.txt-corepager" target="_blank" rel="noopener">git core.pager</a>。</p><h1 id="设置-core-pager"><a href="#设置-core-pager" class="headerlink" title="设置 core.pager"></a>设置 core.pager</h1><p>了解了上面的原理，我们就知道只要单独修改 git 配置就可以了，默认的分页器是 less，我们只要设置了 <code>core.pager</code> 就可以影响结果，所以在 git Bash 中执行下面的语句即可。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global core.pager <span class="string">''</span></span><br></pre></td></tr></table></figure><p>其实就是将分页器清空就行了，这样再执行 <code>git branch</code> 的时候就不会出现分页的情况了。</p><h1 id="更精细的设置"><a href="#更精细的设置" class="headerlink" title="更精细的设置"></a>更精细的设置</h1><p>设置 <code>core.pager</code> 这项配置后对 less 分页器进行了全局屏蔽，虽然 <code>git branch</code> 这种显示内容少的命令比较方便了，但是执行 <code>git show</code> 的时候不分页反而会显得混乱，有没有单独设置每个 git 命令的配置呢？</p><p>答案当然是肯定的，比如上面提到的这种情况，我们只想屏蔽 <code>git branch</code> 命令的分页，而想保留<code>git show</code> 和 <code>git log</code> 的分页显示，就可以单独执行下面的命令。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global pager.branch <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>这样就可以达到只屏蔽 <code>git branch</code> 命令的分页结果了。</p><h1 id="less-and-more"><a href="#less-and-more" class="headerlink" title="less and more"></a>less and more</h1><p>临时插播个知识点，less 和 more 都是 linux 的文本显示工具，那么它们谁更厉害一点呢？从名字上来看应该是 more 更厉害，但实际上是 less 更厉害，less 在 more 的基础上加上了后退功能（据说最初版本more不能后退，现在的常见版本已经支持后退功能了），支持上下键翻页，并且速度更快一点，所以在 linux 的世界一直流传着 “less is more” 这句话。另外 more 退出后会在 shell 上留下刚显示的内容，而 less 不会。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>使用 <code>git config --global core.pager &#39;&#39;</code> 命令可以屏蔽 git 默认的分页器 less</li><li>使用 <code>git config --global pager.branch false</code> 命令可以只关闭 <code>git branch</code> 命令的分页显示</li><li>less 命令比 more 命令更加强大，支持上下键翻页，退出后不会在 shell 显示刚才的内容</li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/114465098" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>学而不思则罔，思而不学则殆。动而不思则徒，思而不动则颓。</p><p>2021-3-14 17:14:55</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;平时会在 windows+linux 两种环境下进行开发，版本控制软件用 git 比较多，但是一直有个小问题，在 windows 下使用 &lt;code&gt;git Bash&lt;/code&gt; 比较顺手，但是在 linux 使用 git 部分命令的时候，常常会打开一个新的窗口，按q键才能退出，比如 &lt;code&gt;git branch&lt;/code&gt;、&lt;code&gt;git log&lt;/code&gt;、&lt;code&gt;git show&lt;/code&gt; 等等。&lt;/p&gt;
    
    </summary>
    
      <category term="Git" scheme="http://AlbertGithubHome.github.io/blog/categories/Git/"/>
    
    
      <category term="git" scheme="http://AlbertGithubHome.github.io/blog/tags/git/"/>
    
      <category term="log" scheme="http://AlbertGithubHome.github.io/blog/tags/log/"/>
    
      <category term="branch" scheme="http://AlbertGithubHome.github.io/blog/tags/branch/"/>
    
      <category term="pager" scheme="http://AlbertGithubHome.github.io/blog/tags/pager/"/>
    
      <category term="config" scheme="http://AlbertGithubHome.github.io/blog/tags/config/"/>
    
  </entry>
  
  <entry>
    <title>Python中int、str、bytes相互转化，还有2进制、16进制表示，你想要的都在这里了</title>
    <link href="http://AlbertGithubHome.github.io/blog/2021/03/05/Python%E4%B8%ADint%E3%80%81str%E3%80%81byte%E7%9B%B8%E4%BA%92%E8%BD%AC%E5%8C%96%EF%BC%8C%E8%BF%98%E6%9C%892%E8%BF%9B%E5%88%B6%E3%80%8116%E8%BF%9B%E5%88%B6%E8%A1%A8%E7%A4%BA%EF%BC%8C%E4%BD%A0%E6%83%B3%E8%A6%81%E7%9A%84%E9%83%BD%E5%9C%A8%E8%BF%99%E9%87%8C%E4%BA%86/"/>
    <id>http://AlbertGithubHome.github.io/blog/2021/03/05/Python中int、str、byte相互转化，还有2进制、16进制表示，你想要的都在这里了/</id>
    <published>2021-03-04T16:04:47.000Z</published>
    <updated>2021-03-06T16:25:58.861Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>数据类型转换是个很基础的操作，很多语言中都要做这些转换，例如前一段时间刚刚总结了<a href="https://blog.csdn.net/albertsh/article/details/113765130" target="_blank" rel="noopener">《C/C++中string和int相互转换的常用方法》</a>，python 自从分离出 python3 版本之后，<code>str</code> 和 <code>bytes</code> 两个类型弄蒙了一大票人，在这两种类型的转换上我可是花了不少时间，记住一点，别随随便便使用 <code>str()</code> 函数，很多数据使用 <code>str()</code> 变成字符串之后再想恢复可就难了。</p><a id="more"></a><p>本文所有示例均在 <code>Python 3.7.5</code> 上测试，<code>Python2</code> 已经被我抛弃了，我来试着把常见的转换都放到一起，把踩过的坑拿来开心一下，如果有些常用的类型转换这里没有的话，也欢迎小伙伴们提出来，我将持续补充，好了，可以开始了。</p><h1 id="数据类型转化"><a href="#数据类型转化" class="headerlink" title="数据类型转化"></a>数据类型转化</h1><p>数字中除了整数，还有浮点数、复数等，但是 <code>int</code> 是最常见的类型，所有转换中的数字只涉及 <code>int</code> 数字类型。</p><h2 id="int-gt-str"><a href="#int-gt-str" class="headerlink" title="int -&gt; str"></a>int -&gt; str</h2><h3 id="使用-str-函数"><a href="#使用-str-函数" class="headerlink" title="使用 str() 函数"></a>使用 str() 函数</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">num = <span class="number">10</span></span><br><span class="line">val = str(<span class="number">10</span>)</span><br><span class="line">print(type(val), val)</span><br><span class="line"></span><br><span class="line"><span class="comment">#&lt;class 'str'&gt; 10</span></span><br></pre></td></tr></table></figure><h3 id="使用-format-函数"><a href="#使用-format-函数" class="headerlink" title="使用 format() 函数"></a>使用 format() 函数</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">num = <span class="number">10</span></span><br><span class="line">val = <span class="string">'&#123;0&#125;'</span>.format(num)</span><br><span class="line">print(type(val), val)</span><br><span class="line"></span><br><span class="line"><span class="comment">#&lt;class 'str'&gt; 10</span></span><br></pre></td></tr></table></figure><h3 id="使用-hex-转换成16进制形式"><a href="#使用-hex-转换成16进制形式" class="headerlink" title="使用 hex() 转换成16进制形式"></a>使用 hex() 转换成16进制形式</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">num = <span class="number">10</span></span><br><span class="line">val = hex(num)</span><br><span class="line">print(type(val), val)</span><br><span class="line"></span><br><span class="line"><span class="comment">#&lt;class 'str'&gt; 0xa</span></span><br></pre></td></tr></table></figure><h3 id="使用-bin-转换成2进制形式"><a href="#使用-bin-转换成2进制形式" class="headerlink" title="使用 bin() 转换成2进制形式"></a>使用 bin() 转换成2进制形式</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">num = <span class="number">10</span></span><br><span class="line">val = bin(num).replace(<span class="string">'0b'</span>,<span class="string">''</span>)</span><br><span class="line">print(type(val), val)</span><br><span class="line"></span><br><span class="line"><span class="comment">#&lt;class 'str'&gt; 1010</span></span><br></pre></td></tr></table></figure><h2 id="str-gt-int"><a href="#str-gt-int" class="headerlink" title="str -&gt; int"></a>str -&gt; int</h2><p>这个转换比较专一，只使用 <code>int()</code> 函数就可以了，这个函数实际上有两个参数，第二个参数表示进制，默认是10进制，你可以改成2进制或者16进制，甚至是3进制、5进制等等</p><h3 id="使用-int-进行各进制数字转换"><a href="#使用-int-进行各进制数字转换" class="headerlink" title="使用 int() 进行各进制数字转换"></a>使用 int() 进行各进制数字转换</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">val = int(<span class="string">'10'</span>)</span><br><span class="line">print(type(val), val)</span><br><span class="line"></span><br><span class="line">val = int(<span class="string">'0xa'</span>, <span class="number">16</span>)</span><br><span class="line">print(type(val), val)</span><br><span class="line">val = int(<span class="string">'a'</span>, <span class="number">16</span>)</span><br><span class="line">print(type(val), val)</span><br><span class="line"></span><br><span class="line">val = int(<span class="string">'0b1010'</span>, <span class="number">2</span>)</span><br><span class="line">print(type(val), val)</span><br><span class="line">val = int(<span class="string">'1010'</span>, <span class="number">2</span>)</span><br><span class="line">print(type(val), val)</span><br><span class="line"></span><br><span class="line">val = int(<span class="string">'101'</span>, <span class="number">3</span>)</span><br><span class="line">print(type(val), val)</span><br><span class="line"></span><br><span class="line">val = int(<span class="string">'60'</span>, <span class="number">5</span>)</span><br><span class="line">print(type(val), val)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果均为 &lt;class 'int'&gt; 10</span></span><br></pre></td></tr></table></figure><p>使用 <code>int()</code> 函数的时候要主要注意一点，如果提供的字符串不能转换成指定进制的数字，那么会报异常，就像下面这样，所以在使用这个函数的时候最好放到 <code>try</code> 语句中。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">val = int(<span class="string">'128'</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">Traceback (most recent call last):</span></span><br><span class="line"><span class="string">  File "D:\python\convert\convert.py", line 41, in &lt;module&gt;</span></span><br><span class="line"><span class="string">    val = int('128', 2)</span></span><br><span class="line"><span class="string">ValueError: invalid literal for int() with base 2: '128'</span></span><br><span class="line"><span class="string">[Finished in 0.1s with exit code 1]</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><h2 id="什么是bytes"><a href="#什么是bytes" class="headerlink" title="什么是bytes"></a>什么是bytes</h2><p>在列举 bytes 相关的转化前，我们来先认识一下这个类型，在 Python3 中 <code>int</code>、<code>str</code>、<code>bytes</code> 类型的变量实际上都是一个 “类” 的对象，而 <code>bytes</code> 相比 <code>str</code> 而言更接近底层数据，也更接近存储的形式，它其实是一个字节的数组，类似于 <code>C</code> 语言中的 <code>char []</code>，每个字节是一个范围在 0-255 的数字。</p><p><code>bytes</code> 其实就是这样一连串的数字，计算机世界所有的信息都可以用这样一串数字表示，一幅画，一首歌，一部电影等等，如果对编码感兴趣可以看看这篇<a href="https://blog.csdn.net/albertsh/article/details/110357193" target="_blank" rel="noopener">《简单聊聊01世界中编码和解码这对磨人的小妖儿》</a>，现在清楚bytes是什么了，我们可以看看和它相关的转化了。</p><h2 id="int-gt-bytes"><a href="#int-gt-bytes" class="headerlink" title="int -&gt; bytes"></a>int -&gt; bytes</h2><h3 id="使用-to-bytes-转换成定长bytes"><a href="#使用-to-bytes-转换成定长bytes" class="headerlink" title="使用 to_bytes() 转换成定长bytes"></a>使用 to_bytes() 转换成定长bytes</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">num = <span class="number">4665</span></span><br><span class="line">val = num.to_bytes(length=<span class="number">4</span>, byteorder=<span class="string">'little'</span>, signed=<span class="keyword">False</span>)</span><br><span class="line">print(type(val), val)</span><br><span class="line"></span><br><span class="line"><span class="comment">#&lt;class 'bytes'&gt; b'9\x12\x00\x00'</span></span><br></pre></td></tr></table></figure><p>这段代码就是把数字 4665 转化成定长的4个字节，字节序为小端，我们来简单看一下是怎么转换的：</p><p>上面我们提到 <code>bytes</code> 类型一串 0-255 范围的数字，4665 肯定超出了这个范围，可以先转化成256进制，就变成了 <18><57>，也就是 4665 = 18 * 256 + 57，我们发现两个字节就能存储这个数字，一个18，一个57，要想组成4个字节的数组需要补充两个空位，也就是补充两个0，这时就涉及到一个排列顺序，是 [0,0,18,57] 还是 [57, 18, 0, 0] 呢，这就是函数参数中的字节序 <code>byteorder</code>，little 表示小端，big 表示大端，这里选择的小端 [57, 18, 0, 0] 的排列。</57></18></p><p>看到这里可能会迷糊，好像和结果不一样啊，其实这只是一个表示问题，57 的 ASCII 码对应这个字符 ‘9’，18 表示成16进制就是 ‘0x12’，这里写成 b’9\x12\x00\x00’ 只是便于识别而已，实际上内存存储的就是 [57, 18, 0, 0] 这一串数字对应的二进制编码 ‘00111001 00010010 00000000 00000000’。</p><h3 id="使用-bytes-函数把int数组转成bytes"><a href="#使用-bytes-函数把int数组转成bytes" class="headerlink" title="使用 bytes() 函数把int数组转成bytes"></a>使用 bytes() 函数把int数组转成bytes</h3><p>参考上面的生成的数组，可以通过数组生成相同的结果</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">num_array = [<span class="number">57</span>, <span class="number">18</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">val = bytes(num_array)</span><br><span class="line">print(type(val), val)</span><br><span class="line"></span><br><span class="line"><span class="comment">#&lt;class 'bytes'&gt; b'9\x12\x00\x00'</span></span><br></pre></td></tr></table></figure><h3 id="使用-struct-pack-函数把数字转化成bytes"><a href="#使用-struct-pack-函数把数字转化成bytes" class="headerlink" title="使用 struct.pack() 函数把数字转化成bytes"></a>使用 struct.pack() 函数把数字转化成bytes</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">num = <span class="number">4665</span></span><br><span class="line">val = struct.pack(<span class="string">"&lt;I"</span>, num)</span><br><span class="line">print(type(val), val)</span><br><span class="line"></span><br><span class="line"><span class="comment">#&lt;class 'bytes'&gt; b'9\x12\x00\x00'</span></span><br></pre></td></tr></table></figure><p>这里的 <code>&quot;&lt;I&quot;</code> 表示将一个整数转化成小端字节序的4字节数组，其他的类型还有：</p><table><thead><tr><th style="text-align:left">参数</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:left">&gt;</td><td style="text-align:center">大端序</td></tr><tr><td style="text-align:left">&lt;</td><td style="text-align:center">小端序</td></tr><tr><td style="text-align:left">B</td><td style="text-align:center">uint8类型</td></tr><tr><td style="text-align:left">b</td><td style="text-align:center">int8类型</td></tr><tr><td style="text-align:left">H</td><td style="text-align:center">uint16类型</td></tr><tr><td style="text-align:left">h</td><td style="text-align:center">int16类型</td></tr><tr><td style="text-align:left">I</td><td style="text-align:center">uint32类型</td></tr><tr><td style="text-align:left">i</td><td style="text-align:center">int32类型</td></tr><tr><td style="text-align:left">L</td><td style="text-align:center">uint64类型</td></tr><tr><td style="text-align:left">l</td><td style="text-align:center">int64类型</td></tr><tr><td style="text-align:left">s</td><td style="text-align:center">ascii码，s前带数字表示个数</td></tr></tbody></table><h2 id="bytes-gt-int"><a href="#bytes-gt-int" class="headerlink" title="bytes -&gt; int"></a>bytes -&gt; int</h2><p>明白了上面的转化过程，从 bytes 转化到 int 只需要反着来就行了</p><h3 id="使用-from-bytes-把-bytes-转化成int"><a href="#使用-from-bytes-把-bytes-转化成int" class="headerlink" title="使用 from_bytes() 把 bytes 转化成int"></a>使用 from_bytes() 把 bytes 转化成int</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">bys = <span class="string">b'9\x12\x00\x00'</span></span><br><span class="line">val = int.from_bytes(bys, byteorder=<span class="string">'little'</span>, signed=<span class="keyword">False</span>)</span><br><span class="line">print(type(val), val)</span><br><span class="line"></span><br><span class="line"><span class="comment">#&lt;class 'int'&gt; 4665</span></span><br></pre></td></tr></table></figure><h3 id="使用-struct-unpack-把-bytes-转化成int"><a href="#使用-struct-unpack-把-bytes-转化成int" class="headerlink" title="使用 struct.unpack() 把 bytes 转化成int"></a>使用 struct.unpack() 把 bytes 转化成int</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">bys = <span class="string">b'9\x12\x00\x00'</span></span><br><span class="line">val = struct.unpack(<span class="string">"&lt;I"</span>, bys)</span><br><span class="line">print(type(val), val)</span><br><span class="line"></span><br><span class="line"><span class="comment">#&lt;class 'tuple'&gt; (4665,)</span></span><br></pre></td></tr></table></figure><h2 id="str-和-bytes"><a href="#str-和-bytes" class="headerlink" title="str 和 bytes"></a>str 和 bytes</h2><p>前面的这些转化还算清晰，到了字符串str 和字节串 bytes，就开始进入了混沌的状态，这里会出现各种编码，各种乱码，各种报错，牢记一点 str 到 bytes 是编码过程，需要使用 <code>encode()</code> 函数， bytes 到 str 是解码过程，需要使用 <code>decode()</code> 函数，请勿使用 <code>str</code> 函数，否则后果自负。</p><h3 id="使用-encode-函数完成-str-gt-bytes"><a href="#使用-encode-函数完成-str-gt-bytes" class="headerlink" title="使用 encode() 函数完成  str -&gt; bytes"></a>使用 encode() 函数完成  str -&gt; bytes</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">'大漠孤烟直qaq'</span></span><br><span class="line">val = s.encode(<span class="string">'utf-8'</span>)</span><br><span class="line">print(type(val), val)</span><br><span class="line"></span><br><span class="line"><span class="comment"># &lt;class 'bytes'&gt; b'\xe5\xa4\xa7\xe6\xbc\xa0\xe5\xad\xa4\xe7\x83\x9f\xe7\x9b\xb4qaq'</span></span><br></pre></td></tr></table></figure><h3 id="使用-decode-函数完成-bytes-gt-str"><a href="#使用-decode-函数完成-bytes-gt-str" class="headerlink" title="使用 decode() 函数完成  bytes -&gt; str"></a>使用 decode() 函数完成  bytes -&gt; str</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">bys = <span class="string">b'\xe5\xa4\xa7\xe6\xbc\xa0\xe5\xad\xa4\xe7\x83\x9f\xe7\x9b\xb4qaq'</span></span><br><span class="line">val = bys.decode(<span class="string">'utf-8'</span>)</span><br><span class="line">print(type(val), val)</span><br><span class="line"></span><br><span class="line"><span class="comment"># &lt;class 'str'&gt; 大漠孤烟直qaq</span></span><br></pre></td></tr></table></figure><h2 id="假如使用了-str-函数"><a href="#假如使用了-str-函数" class="headerlink" title="假如使用了 str() 函数"></a>假如使用了 str() 函数</h2><p>从上面来看字符串和字节串的转化蛮简单的，甚至比整数的转化都要简单，但是你如果把一个 bytes 变量用 str() 转化成字符串，你就得手动来处理了，这个函数写过n次了，暂时还没找到好的处理办法。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">bys = <span class="string">b'\xe5\xa4\xa7\xe6\xbc\xa0\xe5\xad\xa4\xe7\x83\x9f\xe7\x9b\xb4qaq'</span></span><br><span class="line">s = str(bys)</span><br><span class="line">print(type(s), s)</span><br><span class="line"><span class="comment">#&lt;class 'str'&gt; b'\xe5\xa4\xa7\xe6\xbc\xa0\xe5\xad\xa4\xe7\x83\x9f\xe7\x9b\xb4qaq'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">str2bytes</span><span class="params">(str_content)</span>:</span></span><br><span class="line">    result_list = [];</span><br><span class="line">    pos = <span class="number">0</span></span><br><span class="line">    str_content = str_content.replace(<span class="string">"\\n"</span>, <span class="string">"\n"</span>).replace(<span class="string">"\\t"</span>, <span class="string">"\t"</span>).replace(<span class="string">"\\r"</span>, <span class="string">"\r"</span>)</span><br><span class="line">    content_len = len(str_content)</span><br><span class="line">    <span class="keyword">while</span> pos &lt; content_len:</span><br><span class="line">        <span class="keyword">if</span> str_content[pos] == <span class="string">'\\'</span> <span class="keyword">and</span> pos + <span class="number">3</span> &lt; content_len <span class="keyword">and</span> str_content[pos + <span class="number">1</span>] == <span class="string">'x'</span>:</span><br><span class="line">            sub_str = str_content[pos + <span class="number">2</span>: pos + <span class="number">4</span>]</span><br><span class="line">            result_list.append(int(sub_str, <span class="number">16</span>))</span><br><span class="line">            pos = pos + <span class="number">4</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            result_list.append(ord(str_content[pos]))</span><br><span class="line">            pos = pos + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> bytes(result_list)</span><br><span class="line"></span><br><span class="line">val = str2bytes(s[<span class="number">2</span>:<span class="number">-1</span>])</span><br><span class="line">print(type(val), val)</span><br><span class="line"></span><br><span class="line"><span class="comment"># &lt;class 'bytes'&gt; b'\xe5\xa4\xa7\xe6\xbc\xa0\xe5\xad\xa4\xe7\x83\x9f\xe7\x9b\xb4qaq'</span></span><br></pre></td></tr></table></figure><p>什么时候会遇到这种情况，就是有些数据是以 bytes 的形式给的，但是经过中间人复制转发变成了字节流形式的字符串，格式还不统一，有些已经翻译成了字符，有些还保留了0x或者\x形式，这时就要手工处理了。</p><h1 id="转化表格"><a href="#转化表格" class="headerlink" title="转化表格"></a>转化表格</h1><p>上面的转化方式和解释穿插在一起有些乱，这里总结一个表格，便于今后拿来就用</p><table><thead><tr><th style="text-align:left">源类型</th><th style="text-align:center">目标类型</th><th style="text-align:center">方式</th><th style="text-align:center">结果</th></tr></thead><tbody><tr><td style="text-align:left">int</td><td style="text-align:center">str</td><td style="text-align:center"><code>str(10)</code>、<code>&#39;{0}&#39;.format(10)</code></td><td style="text-align:center"><code>10</code> =&gt; <code>&#39;10&#39;</code></td></tr><tr><td style="text-align:left">int</td><td style="text-align:center">str（16进制）</td><td style="text-align:center"><code>hex(10)</code></td><td style="text-align:center"><code>10</code> =&gt; <code>&#39;0xa&#39;</code></td></tr><tr><td style="text-align:left">int</td><td style="text-align:center">str（2进制）</td><td style="text-align:center"><code>bin(10).replace(&#39;0b&#39;,&#39;&#39;)</code></td><td style="text-align:center"><code>10</code> =&gt; <code>&#39;1010&#39;</code></td></tr><tr><td style="text-align:left">str</td><td style="text-align:center">int</td><td style="text-align:center"><code>int(&#39;10&#39;)</code></td><td style="text-align:center"><code>&#39;10&#39;</code> =&gt; <code>10</code></td></tr><tr><td style="text-align:left">str（16进制）</td><td style="text-align:center">int</td><td style="text-align:center"><code>int(&#39;0xa&#39;, 16)</code></td><td style="text-align:center"><code>&#39;0xa&#39;</code> =&gt; <code>10</code></td></tr><tr><td style="text-align:left">str（2进制）</td><td style="text-align:center">int</td><td style="text-align:center"><code>int(&#39;1010&#39;, 2)</code></td><td style="text-align:center"><code>&#39;1010&#39;</code> =&gt; <code>10</code></td></tr><tr><td style="text-align:left">int</td><td style="text-align:center">bytes</td><td style="text-align:center"><code>num.to_bytes(length=4, byteorder=&#39;little&#39;, signed=False)</code></td><td style="text-align:center"><code>4665</code> =&gt; <code>b&#39;9\x12\x00\x00&#39;</code></td></tr><tr><td style="text-align:left">int</td><td style="text-align:center">bytes</td><td style="text-align:center"><code>struct.pack(&quot;&lt;I&quot;, 4665)</code></td><td style="text-align:center"><code>4665</code> =&gt; <code>b&#39;9\x12\x00\x00&#39;</code></td></tr><tr><td style="text-align:left">bytes</td><td style="text-align:center">int</td><td style="text-align:center"><code>int.from_bytes(b&#39;9\x12\x00\x00&#39;, byteorder=&#39;little&#39;, signed=False)</code></td><td style="text-align:center"><code>b&#39;9\x12\x00\x00&#39;</code> =&gt; <code>4665</code></td></tr><tr><td style="text-align:left">bytes</td><td style="text-align:center">int</td><td style="text-align:center"><code>struct.unpack(&quot;&lt;I&quot;, b&#39;9\x12\x00\x00&#39;)</code></td><td style="text-align:center"><code>b&#39;9\x12\x00\x00&#39;</code> =&gt; <code>4665</code></td></tr><tr><td style="text-align:left">int[]</td><td style="text-align:center">bytes</td><td style="text-align:center"><code>bytes([57, 18, 0, 0])</code></td><td style="text-align:center"><code>[57, 18, 0, 0]</code> =&gt; <code>b&#39;9\x12\x00\x00&#39;</code></td></tr><tr><td style="text-align:left">bytes</td><td style="text-align:center">int[]</td><td style="text-align:center"><code>[x for x in b&#39;9\x12\x00\x00&#39;]</code></td><td style="text-align:center"><code>b&#39;9\x12\x00\x00&#39;</code> =&gt; <code>[57, 18, 0, 0]</code></td></tr><tr><td style="text-align:left">str</td><td style="text-align:center">bytes</td><td style="text-align:center"><code>&#39;美好&#39;.encode(&#39;utf-8&#39;)</code></td><td style="text-align:center"><code>&#39;美好&#39;</code> =&gt; <code>b&#39;\xe7\xbe\x8e\xe5\xa5\xbd&#39;</code></td></tr><tr><td style="text-align:left">str</td><td style="text-align:center">bytes</td><td style="text-align:center"><code>bytes(&#39;美好&#39;, &#39;utf-8&#39;)</code></td><td style="text-align:center"><code>&#39;美好&#39;</code> =&gt; <code>b&#39;\xe7\xbe\x8e\xe5\xa5\xbd&#39;</code></td></tr><tr><td style="text-align:left">bytes</td><td style="text-align:center">str</td><td style="text-align:center"><code>b&#39;\xe7\xbe\x8e\xe5\xa5\xbd&#39;.decode(&#39;utf-8&#39;)</code></td><td style="text-align:center"><code>b&#39;\xe7\xbe\x8e\xe5\xa5\xbd&#39;</code> =&gt; <code>&#39;美好&#39;</code></td></tr><tr><td style="text-align:left">bytes</td><td style="text-align:center">bytes（无\x）</td><td style="text-align:center"><code>binascii.b2a_hex(b&#39;\xe7\xbe\x8eqaq&#39;)</code></td><td style="text-align:center"><code>b&#39;\xe7\xbe\x8eqaq&#39;</code> =&gt; <code>b&#39;e7be8e716171&#39;</code></td></tr><tr><td style="text-align:left">bytes</td><td style="text-align:center">bytes（有\x）</td><td style="text-align:center"><code>binascii.a2b_hex(b&#39;e7be8e716171&#39;)</code></td><td style="text-align:center"><code>b&#39;e7be8e716171&#39;</code> =&gt; <code>b&#39;\xe7\xbe\x8eqaq&#39;</code></td></tr><tr><td style="text-align:left">bytes</td><td style="text-align:center">str（hex）</td><td style="text-align:center"><code>b&#39;\xe7\xbe\x8eqaq&#39;.hex()</code></td><td style="text-align:center"><code>b&#39;\xe7\xbe\x8eqaq&#39;</code> =&gt; <code>&#39;e7be8e716171&#39;</code></td></tr><tr><td style="text-align:left">str（hex）</td><td style="text-align:center">bytes</td><td style="text-align:center"><code>bytes.fromhex(&#39;e7be8e716171&#39;)</code></td><td style="text-align:center"><code>&#39;e7be8e716171&#39;</code> =&gt; <code>b&#39;\xe7\xbe\x8eqaq&#39;</code></td></tr></tbody></table><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>Python3 对字符串和二进制数据流做了明确的区分，不会以任意隐式的方式混用 <code>str</code> 和 <code>bytes</code></li><li><code>bytes</code> 类型是一种比特流，它的存在形式是 01010001110 的形式，需要解码成字符才容易被人理解</li><li>struct 模块中的 <code>pack()</code> 和 <code>unpack()</code> 可以实现任意类型和 <code>bytes</code> 之间的转换</li><li><code>binascii.b2a_hex</code> 和 <code>binascii.a2b_hex</code> 可以实现16进制 bytes 的不同形式转换，不过转换前后长度发生了变化</li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/114199056" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>初识不知曲中意，再闻已是曲中人</p><p>2021-3-6 20:36:10</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;数据类型转换是个很基础的操作，很多语言中都要做这些转换，例如前一段时间刚刚总结了&lt;a href=&quot;https://blog.csdn.net/albertsh/article/details/113765130&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《C/C++中string和int相互转换的常用方法》&lt;/a&gt;，python 自从分离出 python3 版本之后，&lt;code&gt;str&lt;/code&gt; 和 &lt;code&gt;bytes&lt;/code&gt; 两个类型弄蒙了一大票人，在这两种类型的转换上我可是花了不少时间，记住一点，别随随便便使用 &lt;code&gt;str()&lt;/code&gt; 函数，很多数据使用 &lt;code&gt;str()&lt;/code&gt; 变成字符串之后再想恢复可就难了。&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="http://AlbertGithubHome.github.io/blog/categories/Python/"/>
    
    
      <category term="int" scheme="http://AlbertGithubHome.github.io/blog/tags/int/"/>
    
      <category term="Python" scheme="http://AlbertGithubHome.github.io/blog/tags/Python/"/>
    
      <category term="hex" scheme="http://AlbertGithubHome.github.io/blog/tags/hex/"/>
    
      <category term="str" scheme="http://AlbertGithubHome.github.io/blog/tags/str/"/>
    
      <category term="bytes" scheme="http://AlbertGithubHome.github.io/blog/tags/bytes/"/>
    
  </entry>
  
  <entry>
    <title>linux环境下的mount命令到底有什么玄机</title>
    <link href="http://AlbertGithubHome.github.io/blog/2021/02/22/linux%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%9A%84mount%E5%91%BD%E4%BB%A4%E5%88%B0%E5%BA%95%E6%9C%89%E4%BB%80%E4%B9%88%E7%8E%84%E6%9C%BA/"/>
    <id>http://AlbertGithubHome.github.io/blog/2021/02/22/linux环境下的mount命令到底有什么玄机/</id>
    <published>2021-02-22T14:54:42.000Z</published>
    <updated>2021-02-27T16:18:06.940Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>linux 环境下的 <code>mount</code> 命令可以挂载一个文件系统，这个命令目前是我所知命令中最陌生的一个，至今没有使用过，真的一次都没有挂载过，平时用的最多是的 Windwos 系统，完全不需要挂载，安装新硬盘自动就会出现盘符，稍微复杂点就是通过磁盘管理器来分区，或者使用魔术分区助手搞一点复杂的分区或格式化操作。</p><a id="more"></a><p>而 linux 系统下，无论是申请的开发机，还是购买的服务器，硬盘都是挂载好的，至今没有遇到需要手动挂载的情况，所以对这个命令并不是很熟悉，今天决定抽时间学一下，总结一下设备相关的知识，特别是磁盘相关的操作。</p><h1 id="文件类型"><a href="#文件类型" class="headerlink" title="文件类型"></a>文件类型</h1><p>“Everything is a file”（一切皆文件）是 linux 中的特点，所以在学习磁盘、设备之前先来看看文件类型，在 linux 并不通过后缀名来判断文件类型的，可以利用 <code>ll</code> （或 <code>ls -l</code>）命令可以列举指定目录下的内容，通过每一行的首个字母就可以判断出文件的大类型：</p><ul><li>-rw-r-r-：<code>-</code>开头的都普通文件</li><li>brw-r-r-：<code>b</code>开头的是块设备文件</li><li>crw-r-r-：<code>c</code>开头的是字符设备文件</li><li>drw-r-r-：<code>d</code>开头的是目录文件</li><li>lrw-r-r-：<code>l</code>开头的是软链接文件，也叫符号链接</li><li>prw-r-r-：<code>p</code>开头的是管道文件</li><li>srw-r-r-：<code>s</code>开头的是socket文件</li></ul><p>我们可以查一下CentOS系统设备目录 <code>dev</code>，这里的文件类型非常丰富，由于内容非常多，这里只展示一部分内容：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-0-3-centos ~]<span class="comment"># ll /dev</span></span><br><span class="line">total 0</span><br><span class="line">crw------- 1 root root     10, 235 Feb  9 11:13 autofs</span><br><span class="line">drwxr-xr-x 2 root root         120 Feb  9 11:13 block</span><br><span class="line">drwxr-xr-x 2 root root          60 Feb  9 11:13 bsg</span><br><span class="line">crw------- 1 root root     10, 234 Feb  9 11:13 btrfs-control</span><br><span class="line">drwxr-xr-x 3 root root          60 Feb  9 11:13 bus</span><br><span class="line">lrwxrwxrwx 1 root root           3 Feb  9 11:13 cdrom -&gt; sr0</span><br><span class="line">drwxr-xr-x 2 root root        2560 Feb  9 11:13 char</span><br><span class="line">crw------- 1 root root      5,   1 Feb  9 11:13 console</span><br><span class="line">lrwxrwxrwx 1 root root          11 Feb  9 11:13 core -&gt; /proc/kcore</span><br><span class="line">drwxr-xr-x 3 root root          60 Feb  9 11:13 cpu</span><br><span class="line">crw------- 1 root root     10,  61 Feb  9 11:13 cpu_dma_latency</span><br><span class="line">crw------- 1 root root     10,  62 Feb  9 11:13 crash</span><br><span class="line">drwxr-xr-x 6 root root         120 Feb  9 11:13 disk</span><br><span class="line">drwxr-xr-x 2 root root          60 Feb  9 11:13 dri</span><br><span class="line">crw-rw---- 1 root video    29,   0 Feb  9 11:13 fb0</span><br><span class="line">lrwxrwxrwx 1 root root          13 Feb  9 11:13 fd -&gt; /proc/self/fd</span><br><span class="line">crw-rw-rw- 1 root root      1,   7 Feb  9 11:13 full</span><br><span class="line">crw-rw-rw- 1 root root     10, 229 Feb  9 11:13 fuse</span><br><span class="line">crw------- 1 root root     10, 228 Feb  9 11:13 hpet</span><br><span class="line">drwxr-xr-x 2 root root           0 Feb  9 11:13 hugepages</span><br><span class="line">crw------- 1 root root     10, 183 Feb  9 11:13 hwrng</span><br><span class="line">lrwxrwxrwx 1 root root          25 Feb  9 11:13 initctl -&gt; /run/systemd/initctl/fifo</span><br><span class="line">drwxr-xr-x 3 root root         240 Feb  9 11:13 input</span><br><span class="line">crw-r--r-- 1 root root      1,  11 Feb  9 11:13 kmsg</span><br><span class="line">srw-rw-rw- 1 root root           0 Feb  9 11:13 <span class="built_in">log</span></span><br></pre></td></tr></table></figure><p>其实还有一个更精准的，专门用来查询文件类型的命令，那就是 <code>file</code> 命令，下面可以测试一下，执行后会输出关于文件类型的描述：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-0-3-centos ~]<span class="comment"># ll</span></span><br><span class="line">total 12</span><br><span class="line">-rwxr-xr-x 1 root root   67 Feb  9 13:44 connecttendis.sh</span><br><span class="line">drwxr-xr-x 2 root root 4096 Feb  9 13:44 tarlist</span><br><span class="line">drwxr-xr-x 4 root root 4096 Feb  9 13:40 tendis</span><br><span class="line">[root@VM-0-3-centos ~]<span class="comment"># file connecttendis.sh</span></span><br><span class="line">connecttendis.sh: Bourne-Again shell script, ASCII text executable</span><br><span class="line">[root@VM-0-3-centos ~]<span class="comment"># file tendis/</span></span><br><span class="line">tendis/: directory</span><br></pre></td></tr></table></figure><p>描述展示说明 connecttendis.sh 是一个 shell 脚本，而 tendis/ 是一个目录。</p><h1 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h1><p>说完文件类型还得说说文件系统，什么是文件系统，其实从名字就可以看出来，文件系统就是管文件的呗，不同的文件系统所支持的最大容量、对单个文件的大小限制、存取性能、是否可压缩、是否提供校验等都是不太一样的，当我们做系统或者烧制U盘、格式化硬盘时常常提到文件系统这个词。</p><p>在 Windows 中常用的文件系统有 <code>FAT16</code>、<code>FAT32</code>、<code>NTFS</code>、<code>exFAT</code> 等，而 Linux 中常用的文件系统有 <code>ext2</code>、<code>ext3</code>、<code>ext4</code>、<code>tmpfs</code>、<code>proc</code> 等，这些文件系统无需全部记住，在 Linux 上可以通过查看 <code>/proc/filesystems</code> 文件得知当前系统都支持哪些文件系统。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-0-3-centos ~]<span class="comment"># cat /proc/filesystems</span></span><br><span class="line">nodev   sysfs</span><br><span class="line">nodev   rootfs</span><br><span class="line">nodev   ramfs</span><br><span class="line">nodev   bdev</span><br><span class="line">nodev   proc</span><br><span class="line">nodev   cgroup</span><br><span class="line">nodev   cpuset</span><br><span class="line">nodev   tmpfs</span><br><span class="line">nodev   devtmpfs</span><br><span class="line">nodev   debugfs</span><br><span class="line">nodev   securityfs</span><br><span class="line">nodev   sockfs</span><br><span class="line">nodev   dax</span><br><span class="line">nodev   bpf</span><br><span class="line">nodev   pipefs</span><br><span class="line">nodev   configfs</span><br><span class="line">nodev   devpts</span><br><span class="line">nodev   hugetlbfs</span><br><span class="line">nodev   autofs</span><br><span class="line">nodev   pstore</span><br><span class="line">nodev   mqueue</span><br><span class="line">        ext3</span><br><span class="line">        ext2</span><br><span class="line">        ext4</span><br><span class="line">        iso9660</span><br><span class="line">nodev   binfmt_misc</span><br></pre></td></tr></table></figure><p>观察上述结果，第一列为空的文件系统需要挂载到块设备上才能访问其中的内容，之后才可以正常使用。</p><h1 id="挂载硬盘"><a href="#挂载硬盘" class="headerlink" title="挂载硬盘"></a>挂载硬盘</h1><p>Windows 中的目录是分盘符的，每个分区可以指定一个盘符，每个盘符就是这个分区的根，可以通过各个盘符依次向下访问其中的内容。在 Linux 中是没有盘符概念的，只有一个根目录 <code>/</code>，只存在一棵完整的目录树，硬盘设备需要挂载到这棵目录树上才能被正常使用。</p><p>我们知道 <code>/dev</code> 目录下存放着几乎所有的设备文件，从中就可以找到硬盘设备：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-0-3-centos ~]<span class="comment"># ll /dev/ | grep disk</span></span><br><span class="line">drwxr-xr-x 6 root root         120 Feb  9 11:13 disk</span><br><span class="line">brw-rw---- 1 root disk      7,   0 Feb  9 11:13 loop0</span><br><span class="line">crw-rw---- 1 root disk     10, 237 Feb  9 11:13 loop-control</span><br><span class="line">brw-rw---- 1 root disk    253,   0 Feb  9 11:13 vda</span><br><span class="line">brw-rw---- 1 root disk    253,   1 Feb  9 11:13 vda1</span><br></pre></td></tr></table></figure><p>从命令结果可以看出，这台计算机只有一块普通硬盘 <code>vda</code>，硬盘只有一个分区 <code>vda1</code>，这是目前一种通用的命名方式，<code>hd</code> 是指IDE接口的硬盘，<code>sd</code> 是指SATA接口的硬盘、<code>vd</code> 指 virtio 磁盘，现在的内核一般都会把硬盘，移动硬盘，U盘等识别为sdX的形式，第一块硬盘使用 <code>a</code> 作为后缀，例如 <code>sda</code>，后面的硬盘依次命名为 <code>sdb</code>、<code>sdc</code> 等，硬盘的第一个分区后缀为1，后面分区号依次递增。</p><h2 id="查硬盘分区"><a href="#查硬盘分区" class="headerlink" title="查硬盘分区"></a>查硬盘分区</h2><p>硬盘作为一种设备可以在 <code>/dev</code> 目录下查询，但是可以通过 <code>fdisk</code> 做更细致的查询</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-0-3-centos dev]<span class="comment"># fdisk -l</span></span><br><span class="line"></span><br><span class="line">Disk /dev/vda: 53.7 GB, 53687091200 bytes, 104857600 sectors</span><br><span class="line">Units = sectors of 1 * 512 = 512 bytes</span><br><span class="line">Sector size (logical/physical): 512 bytes / 512 bytes</span><br><span class="line">I/O size (minimum/optimal): 512 bytes / 512 bytes</span><br><span class="line">Disk label <span class="built_in">type</span>: dos</span><br><span class="line">Disk identifier: 0x000d64b4</span><br><span class="line"></span><br><span class="line">   Device Boot      Start         End      Blocks   Id  System</span><br><span class="line">/dev/vda1   *        2048   104857566    52427759+  83  Linux</span><br></pre></td></tr></table></figure><p>通过 <code>fdisk -l</code> 命令查询出的结果与 <code>/dev</code> 目录下查到的信息一致</p><h2 id="查看当前挂载的文件系统"><a href="#查看当前挂载的文件系统" class="headerlink" title="查看当前挂载的文件系统"></a>查看当前挂载的文件系统</h2><p>查看当前挂载的所有文件系统只需要一个 <code>mount</code> 命令就够了，也可以加 <code>-t tmpfs</code> 参数查看指定类型</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-0-3-centos ~]<span class="comment"># mount</span></span><br><span class="line">sysfs on /sys <span class="built_in">type</span> sysfs (rw,relatime)</span><br><span class="line">proc on /proc <span class="built_in">type</span> proc (rw,relatime)</span><br><span class="line">devtmpfs on /dev <span class="built_in">type</span> devtmpfs (rw,nosuid,size=930496k,nr_inodes=232624,mode=755)</span><br><span class="line">securityfs on /sys/kernel/security <span class="built_in">type</span> securityfs (rw,nosuid,nodev,noexec,relatime)</span><br><span class="line">tmpfs on /dev/shm <span class="built_in">type</span> tmpfs (rw,nosuid,nodev)</span><br><span class="line">devpts on /dev/pts <span class="built_in">type</span> devpts (rw,relatime,gid=5,mode=620,ptmxmode=000)</span><br><span class="line">tmpfs on /run <span class="built_in">type</span> tmpfs (rw,nosuid,nodev,mode=755)</span><br><span class="line">tmpfs on /sys/fs/cgroup <span class="built_in">type</span> tmpfs (ro,nosuid,nodev,noexec,mode=755)</span><br><span class="line">...</span><br><span class="line">cgroup on /sys/fs/cgroup/freezer <span class="built_in">type</span> cgroup (rw,nosuid,nodev,noexec,relatime,freezer)</span><br><span class="line">configfs on /sys/kernel/config <span class="built_in">type</span> configfs (rw,relatime)</span><br><span class="line">/dev/vda1 on / <span class="built_in">type</span> ext4 (rw,noatime,data=ordered)</span><br><span class="line">debugfs on /sys/kernel/debug <span class="built_in">type</span> debugfs (rw,relatime)</span><br><span class="line">hugetlbfs on /dev/hugepages <span class="built_in">type</span> hugetlbfs (rw,relatime)</span><br><span class="line">mqueue on /dev/mqueue <span class="built_in">type</span> mqueue (rw,relatime)</span><br><span class="line">tmpfs on /run/user/0 <span class="built_in">type</span> tmpfs (rw,nosuid,nodev,relatime,size=188204k,mode=700)</span><br><span class="line">binfmt_misc on /proc/sys/fs/binfmt_misc <span class="built_in">type</span> binfmt_misc (rw,relatime)</span><br></pre></td></tr></table></figure><p>输出每一行格式一致，均包含6列内容，通过空格来分割，具体形式为：</p><blockquote><p>&lt;块设备或者其他文件系统&gt; on &lt;挂载目录&gt; type &lt;文件系统类型&gt; &lt;(与文件系统内容相关的选项)&gt;</p></blockquote><p>以 ‘/dev/vda1 on / type ext4 (rw,noatime,data=ordered)’ 这一行为例，就表示 <code>/dev/vda</code> 这个硬盘的第一个分区挂载到了一个 类型为 <code>ext4</code> 的文件系统上，挂载点是根目录 <code>/</code>，括号中的 <code>rw</code> 表示可读写，<code>data=ordered</code> 表示有序，<code>relatime</code> 是一种更新文件访问时间属性的一种方式，此外还有 <code>noatime</code> 和 <code>lazytime</code> 类型，这一块内容也比较多，此处就不展开了，有兴趣可以转到 <a href="https://www.cnblogs.com/honpey/p/6637848.html" target="_blank" rel="noopener">《文件系统中 atime,lazytime,relatime 详聊》</a> 这篇文章中了解一下。</p><h2 id="格式化磁盘分区"><a href="#格式化磁盘分区" class="headerlink" title="格式化磁盘分区"></a>格式化磁盘分区</h2><p>使用 <code>mkfs</code> 可以格式化一个磁盘分区，格式化的同时可以修改文件系统的类型</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-0-3-centos ~]<span class="comment"># mkfs -t ext4 /dev/sda2</span></span><br></pre></td></tr></table></figure><h2 id="挂载新的磁盘分区"><a href="#挂载新的磁盘分区" class="headerlink" title="挂载新的磁盘分区"></a>挂载新的磁盘分区</h2><p>使用 <code>mount</code> 命令可以将新的磁盘分区挂载到目录树上</p><h3 id="普通挂载"><a href="#普通挂载" class="headerlink" title="普通挂载"></a>普通挂载</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-0-3-centos ~]<span class="comment"># mkdir -p /mnt/data</span></span><br><span class="line">[root@VM-0-3-centos ~]<span class="comment"># mount /dev/sda2 /mnt/data</span></span><br></pre></td></tr></table></figure><h3 id="以只读方式挂载"><a href="#以只读方式挂载" class="headerlink" title="以只读方式挂载"></a>以只读方式挂载</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-0-3-centos ~]<span class="comment"># mount -o ro /dev/sda2 /mnt/data</span></span><br></pre></td></tr></table></figure><h3 id="只读挂载改为读写模式"><a href="#只读挂载改为读写模式" class="headerlink" title="只读挂载改为读写模式"></a>只读挂载改为读写模式</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-0-3-centos ~]<span class="comment"># mount /mnt/data -o rw,remount</span></span><br></pre></td></tr></table></figure><h2 id="挂载光驱"><a href="#挂载光驱" class="headerlink" title="挂载光驱"></a>挂载光驱</h2><p>挂载光驱的方式与挂载硬盘是一样的，只不过光驱是单独的设备，对应着不同的文件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-0-3-centos ~]<span class="comment"># mount /dev/cdrom /media/cdrom</span></span><br></pre></td></tr></table></figure><h2 id="挂载-windows-共享文件"><a href="#挂载-windows-共享文件" class="headerlink" title="挂载 windows 共享文件"></a>挂载 windows 共享文件</h2><p>挂载 windows 共享文件时需要用到 windows 计算机的IP、用户名和密码</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-0-3-centos ~]<span class="comment"># mkdir -p /mnt/share</span></span><br><span class="line">[root@VM-0-3-centos ~]<span class="comment"># mount -t cifs -o username=admin,password=94741 //10.2.49.172/share /mnt/share</span></span><br></pre></td></tr></table></figure><h2 id="挂载-ios-文件"><a href="#挂载-ios-文件" class="headerlink" title="挂载 ios 文件"></a>挂载 ios 文件</h2><p>直接挂载 iso 文件就不需要光驱了，使用起来更加方便，先模拟创建一个 iso 文件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-0-3-centos ~]<span class="comment"># genisoimage -o test.iso tendis/</span></span><br><span class="line">I: -input-charset not specified, using utf-8 (detected <span class="keyword">in</span> locale settings)</span><br><span class="line">Using TENDI000.;1 <span class="keyword">for</span>  tendis/bin/tendisplus (tendisplus_static)</span><br><span class="line">  2.77% <span class="keyword">done</span>, estimate finish Sat Feb 27 23:03:08 2021</span><br><span class="line">  5.53% <span class="keyword">done</span>, estimate finish Sat Feb 27 23:03:08 2021</span><br><span class="line">  8.30% <span class="keyword">done</span>, estimate finish Sat Feb 27 23:03:08 2021</span><br><span class="line">...</span><br><span class="line"> 49.78% <span class="keyword">done</span>, estimate finish Sat Feb 27 23:03:10 2021</span><br><span class="line">...</span><br><span class="line"> 99.55% <span class="keyword">done</span>, estimate finish Sat Feb 27 23:03:11 2021</span><br><span class="line">Total translation table size: 0</span><br><span class="line">Total rockridge attributes bytes: 0</span><br><span class="line">Total directory bytes: 6144</span><br><span class="line">Path table size(bytes): 50</span><br><span class="line">Max brk space used 1a000</span><br><span class="line">180825 extents written (353 MB)</span><br></pre></td></tr></table></figure><p>把 iso 直接挂载到目录就可以了，之后就可以通过 <code>/mnt/iso</code> 目录访问 test.iso 文件中的内容了</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-0-3-centos ~]<span class="comment"># mkdir -p /mnt/iso</span></span><br><span class="line">[root@VM-0-3-centos ~]<span class="comment"># mount test.iso /mnt/iso</span></span><br><span class="line">mount: /dev/loop0 is write-protected, mounting <span class="built_in">read</span>-only</span><br></pre></td></tr></table></figure><h1 id="计算机设备中的概念"><a href="#计算机设备中的概念" class="headerlink" title="计算机设备中的概念"></a>计算机设备中的概念</h1><p>计算机科学中的概念有很多，常常记不清或者记混它们的内容，比如扇区、块、簇、页等，每次看完过后就忘记了，在此简单总结一下。</p><h2 id="扇区"><a href="#扇区" class="headerlink" title="扇区"></a>扇区</h2><p>硬盘的读写以扇区为基本单位，属于物理层面的概念，操作系统是不直接与扇区交互的，可以通过 <code>fdisk -l</code> 查看扇区大小</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-0-3-centos dev]<span class="comment"># fdisk -l</span></span><br><span class="line"></span><br><span class="line">Disk /dev/vda: 53.7 GB, 53687091200 bytes, 104857600 sectors</span><br><span class="line">Units = sectors of 1 * 512 = 512 bytes</span><br><span class="line">Sector size (logical/physical): 512 bytes / 512 bytes</span><br><span class="line">I/O size (minimum/optimal): 512 bytes / 512 bytes</span><br><span class="line">Disk label <span class="built_in">type</span>: dos</span><br><span class="line">Disk identifier: 0x000d64b4</span><br><span class="line"></span><br><span class="line">   Device Boot      Start         End      Blocks   Id  System</span><br><span class="line">/dev/vda1   *        2048   104857566    52427759+  83  Linux</span><br></pre></td></tr></table></figure><p>其中 Sector size，就表示扇区大小，从结果来看还分逻辑扇区和物理扇区，不过本例中为均为 512 bytes。</p><h2 id="块、簇"><a href="#块、簇" class="headerlink" title="块、簇"></a>块、簇</h2><p>块和簇其实是一种东西，通常 linux 系统叫做块，而 windows 系统叫做簇，它是文件系统读写数据的最小单位，每个磁盘块可以包括相邻的 2、4、8、16、32 或 64 个扇区，是操作系统所使用的逻辑概念，可以通过命令 <code>stat /boot</code> 来查看</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-0-3-centos mnt]<span class="comment"># stat /boot</span></span><br><span class="line">  File: ‘/boot’</span><br><span class="line">  Size: 4096        Blocks: 8          IO Block: 4096   directory</span><br><span class="line">Device: fd01h/64769d    Inode: 18          Links: 5</span><br><span class="line">Access: (0555/dr-xr-xr-x)  Uid: (    0/    root)   Gid: (    0/    root)</span><br><span class="line">Access: 2018-08-08 11:20:35.109000000 +0800</span><br><span class="line">Modify: 2021-02-09 11:14:21.799238058 +0800</span><br><span class="line">Change: 2021-02-09 11:14:21.799238058 +0800</span><br><span class="line"> Birth: -</span><br></pre></td></tr></table></figure><p>结果中 IO Block 就是磁盘块大小 4096 Bytes，也就是 4K，这样将相邻扇区合并为块来存取数据是为了更高效地、更好地管理磁盘空间。操作系统规定一个磁盘块中只能放置一个文件，这就会造成空间的浪费，那就意味着大多数情况会出现文件所占用的磁盘空间大于文件大小的情况。</p><h2 id="页"><a href="#页" class="headerlink" title="页"></a>页</h2><p>这是一个内存相关的概念，是内存的最小存储单位。它大小通常为磁盘块大小的 $2^n$ 倍，可以通过命令 <code>getconf PAGE_SIZE</code> 来获取页的大小</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-0-3-centos mnt]<span class="comment"># getconf PAGE_SIZE</span></span><br><span class="line">4096</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li><code>mount</code> 是 linux 系统中非常重要的一个命令，但是我感觉用的比较少</li><li>系统新挂载的硬盘关机后会被卸载，可以将挂载信息添加到 <code>/etc/fstab</code> 文件实现开机后自动挂载</li><li>可以把多个设备挂载到同一个目录，默认后面挂载的内容会隐藏前面挂载的内容，卸载后面的挂载，前面挂载的内容还会出现</li><li>可以把同一个设备挂载到不同的目录，并在挂载时可以指定不同的权限，这样在不同的目录中看到的是同样的内容，但是权限不同</li><li>扇区是硬盘的读写的基本单位，属于物理概念</li><li>块/簇是操作系统读写数据的基本单位，属于逻辑概念</li><li>页是内存的最小存储单位，通常为磁盘块大小的 $2^n$ 倍</li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/113907051" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>万里山河都踏过 天下又入谁手 分分合合 不过几十载春秋~</p><p>“你在教我做事啊”</p><p>2021-2-27 23:41:34</p></blockquote><!--https://www.cnblogs.com/sparkdev/p/9015312.htmlhttps://zhuanlan.zhihu.com/p/117375905 -->]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;linux 环境下的 &lt;code&gt;mount&lt;/code&gt; 命令可以挂载一个文件系统，这个命令目前是我所知命令中最陌生的一个，至今没有使用过，真的一次都没有挂载过，平时用的最多是的 Windwos 系统，完全不需要挂载，安装新硬盘自动就会出现盘符，稍微复杂点就是通过磁盘管理器来分区，或者使用魔术分区助手搞一点复杂的分区或格式化操作。&lt;/p&gt;
    
    </summary>
    
      <category term="linux" scheme="http://AlbertGithubHome.github.io/blog/categories/linux/"/>
    
    
      <category term="linux" scheme="http://AlbertGithubHome.github.io/blog/tags/linux/"/>
    
      <category term="mount" scheme="http://AlbertGithubHome.github.io/blog/tags/mount/"/>
    
      <category term="unmount" scheme="http://AlbertGithubHome.github.io/blog/tags/unmount/"/>
    
      <category term="挂载" scheme="http://AlbertGithubHome.github.io/blog/tags/%E6%8C%82%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>Go环境配置时遇到的GOPATH路径以及包管理问题</title>
    <link href="http://AlbertGithubHome.github.io/blog/2021/02/19/Go%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E6%97%B6%E9%81%87%E5%88%B0%E7%9A%84GOPATH%E8%B7%AF%E5%BE%84%E4%BB%A5%E5%8F%8A%E5%8C%85%E7%AE%A1%E7%90%86%E9%97%AE%E9%A2%98/"/>
    <id>http://AlbertGithubHome.github.io/blog/2021/02/19/Go环境配置时遇到的GOPATH路径以及包管理问题/</id>
    <published>2021-02-19T14:39:19.000Z</published>
    <updated>2021-02-21T15:29:58.021Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>过了个年回到工作岗位，发现之前好好的 <code>Go</code> 环境无法进行调试了，于是又重新配置了一次，弄好之后的新参数与原来有一些不一样的地方，甚至还有一些矛盾的地方，真搞不清楚原来的配置参数怎么能成功调试的，也是奇了怪了。配置过程中还遇到了一些问题，特别记录一下，防止今后遇到类似问题还要苦苦寻找。</p><a id="more"></a><h1 id="Go-的环境变量"><a href="#Go-的环境变量" class="headerlink" title="Go 的环境变量"></a>Go 的环境变量</h1><p>说起环境变量，写 <code>Java</code> 的时候倒是配置了不少，一般都需要配置 <code>JAVA_HOME</code> 和 <code>CLASSPATH</code>，后来 C/C++ 写的比较多，完全不需要这个东西，直接使用 <code>include</code> 把绝对路径或者相对路径引用进来就可以，或者使用VS的项目属性界面配置包含路径，也可以将包含路径写在 <code>CMakeLists.txt</code> 中。但是为了能找到和使用各种工具和软件，它们所在的路径一般会加到环境变量<code>Path</code>中。</p><p><code>Go</code> 中也有两个环境变量非常重要，它们分别是 <code>GOROOT</code> 和 <code>GOPATH</code>，其中 <code>GOROOT</code> 比较好理解，就是 <code>Go</code> 软件安装的目录，可以类比一下 <code>JAVA_HOME/bin</code>，而 <code>GOPATH</code> 就是一个神奇的存在，在go1.12版本之前，<code>Go</code> 语言编写的项目代码和下载的包都必须在 <code>GOPATH</code> 目录下，想像一下，在一个 <code>GOPATH</code> 目录下无数个项目go文件，那感觉真是酸爽。</p><h1 id="GOPATH-的设计"><a href="#GOPATH-的设计" class="headerlink" title="GOPATH 的设计"></a>GOPATH 的设计</h1><p><code>GOPATH</code>设计的出发点是好的，将代码包统一存储到一个目录下，直接引用包名就可以了，可是这样设计也缺少了自由，下载的第三方包和自己的项目文件混在一起虽然可以方便查看代码，但是结构看起来确实很乱。</p><p>什么？你说 <code>GOPATH</code> 可以指定多个目录，确实很多资料说 <code>GOPATH</code> 支持多个目录，下载的包会默认放在 <code>GOPATH</code> 指定的第一个目录下，需要注意的一个点是在windows下指定多个目录需要用分号分隔，而Linux下指定多个目录需要用冒号分隔，并且指定的目录需要是用绝对路径，如果指定的目录中包含相对路径，会报一个 <code>go: GOPATH entry is relative; must be absolute path: &quot;...</code> 错误，记得 <code>GOPATH</code> 变量末尾不要加 <code>:</code> 或者 <code>;</code>。</p><p>春节前我就是配置的多个目录，本来调试用的好好的，结果过完年现在不让用了，一调试就会报错 <code>unexpected directory layout:</code>，具体的报错内容结构如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">unexpected directory layout:</span><br><span class="line">        import path: _/go/src/firstgo</span><br><span class="line">        root: /go/src</span><br><span class="line">        dir: /go/src/firstgo</span><br><span class="line">        expand root: /go</span><br><span class="line">        expand dir: /go/src/firstgo</span><br><span class="line">        separator: /</span><br></pre></td></tr></table></figure><p>后来参考了下面两篇文章，把 <code>GOPATH</code> 改成单一目录就好了。</p><ul><li><a href="https://www.gitmemory.com/issue/golang/go/33752/523826861" target="_blank" rel="noopener">cmd/go: unexpected directory layout while building project</a></li><li><a href="https://www.jianshu.com/p/b226e1433bab" target="_blank" rel="noopener">go get 报错 unexpected directory layout</a></li></ul><p>也就是在linux下的 <code>~/.profile</code> 文件中把 <code>export GOPATH=/home/albert/go:/home/albert/WorkSpace/go</code> 改成 <code>export GOPATH=/home/albert/go</code> 就可以了。</p><h1 id="GOPATH-的发展"><a href="#GOPATH-的发展" class="headerlink" title="GOPATH 的发展"></a>GOPATH 的发展</h1><p>早期版本的 <code>GOPATH</code> 设计所有包下载到指定的目录，并且没有版本号，如果多个项目引用的同一个包的不同版本那就歇菜了，所以说这时的 <code>Go</code> 管理仅仅处于能用的状态，也就相当于一个下载器，达不到软件包管理器的及格水平，后来出现了一些例如 <code>dep</code>、<code>Godep</code> 的包管理工具，均属于官方推荐的第三方管理工具，都非 <code>Go</code> 语言自带。</p><p><code>Go</code> 的包管理工具并不像 Python 的 pip，或者 JS 的 npm 那样统一，本质上还是设计不同导致的，<code>Go</code> 想做的包管理是一种分布式的，没有Python 或者 JS 那种中心仓库，这样又带来了一个弊端，如果包的提供者频繁提交新版本怎么办，所以在包管理的工作中，版本号是必须要存在的。</p><p>关于之前GO项目为什么非要放在 <code>GOPATH</code> 下，以及 GO的包管理发展历程可以参考下面文章：</p><ul><li><a href="https://juejin.cn/post/6844903849916907534" target="_blank" rel="noopener">GO问答之为什么项目要在 GOPATH/src 目录下</a></li><li><a href="https://www.infoq.cn/article/history-go-package-management" target="_blank" rel="noopener">Go 包管理的前世今生</a></li></ul><p>直到 <code>go mod</code> 出现以后，在<code>Go</code> 中引入第三方模块算是方便了不少，参考<a href="https://segmentfault.com/a/1190000018690961" target="_blank" rel="noopener">《拜拜了，GOPATH君！新版本Golang的包管理入门教程》</a></p><ul><li><a href="https://www.jianshu.com/p/760c97ff644c" target="_blank" rel="noopener">go mod使用</a></li><li><a href="https://segmentfault.com/q/1010000020696591#" target="_blank" rel="noopener">go mod 怎么导入本地其它项目的包？</a></li><li><a href="https://studygolang.com/articles/25658" target="_blank" rel="noopener">谈谈go.sum</a></li></ul><h1 id="Go-的常用命令"><a href="#Go-的常用命令" class="headerlink" title="Go 的常用命令"></a>Go 的常用命令</h1><p><code>Go</code> 作为一种语言，同时也代表了一系列工具和生态环境，它的命令有不少，下面列举一些常见的：</p><ul><li><strong>go env</strong>: 打印go的环境信息</li><li><strong>go fmt</strong>: 运行gofmt对go代码进行格式化</li><li><strong>go build</strong>: 编译包和依赖</li><li><strong>go run</strong>: 编译并运行go程序</li><li><strong>go version</strong>: 显示go程序的版本</li><li><strong>go help</strong>: 打印命令的帮助信息</li><li><strong>go get</strong>: 下载并安装包和依赖（-v 显示操作流程的日志及信息；-u 下载丢失的包，但不会更新已经存在的包）</li></ul><p>其中 <code>go help</code> 不仅仅打印了这些命令的基本信息，还可以打印出一些概念的帮助信息， 例如 <code>go help gopath</code>，内容比较多，下面只列举一小部分:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">Here<span class="string">'s an example directory layout:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    GOPATH=/home/user/go</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    /home/user/go/</span></span><br><span class="line"><span class="string">        src/</span></span><br><span class="line"><span class="string">            foo/</span></span><br><span class="line"><span class="string">                bar/               (go code in package bar)</span></span><br><span class="line"><span class="string">                    x.go</span></span><br><span class="line"><span class="string">                quux/              (go code in package main)</span></span><br><span class="line"><span class="string">                    y.go</span></span><br><span class="line"><span class="string">        bin/</span></span><br><span class="line"><span class="string">            quux                   (installed command)</span></span><br><span class="line"><span class="string">        pkg/</span></span><br><span class="line"><span class="string">            linux_amd64/</span></span><br><span class="line"><span class="string">                foo/</span></span><br><span class="line"><span class="string">                    bar.a          (installed package object)</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="string">...</span></span><br></pre></td></tr></table></figure><p>运行 <code>go env</code> 展示一下当前使用的环境，方便以后做个对照：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">$ go env</span><br><span class="line">GO111MODULE=<span class="string">""</span></span><br><span class="line">GOARCH=<span class="string">"amd64"</span></span><br><span class="line">GOBIN=<span class="string">""</span></span><br><span class="line">GOCACHE=<span class="string">"/home/albert/.cache/go-build"</span></span><br><span class="line">GOENV=<span class="string">"/home/albert/.config/go/env"</span></span><br><span class="line">GOEXE=<span class="string">""</span></span><br><span class="line">GOFLAGS=<span class="string">""</span></span><br><span class="line">GOHOSTARCH=<span class="string">"amd64"</span></span><br><span class="line">GOHOSTOS=<span class="string">"linux"</span></span><br><span class="line">GOINSECURE=<span class="string">""</span></span><br><span class="line">GOMODCACHE=<span class="string">"/home/albert/WorkSpace/go1/pkg/mod"</span></span><br><span class="line">GONOPROXY=<span class="string">""</span></span><br><span class="line">GONOSUMDB=<span class="string">""</span></span><br><span class="line">GOOS=<span class="string">"linux"</span></span><br><span class="line">GOPATH=<span class="string">"/home/albert/WorkSpace/go1"</span></span><br><span class="line">GOPRIVATE=<span class="string">""</span></span><br><span class="line">GOPROXY=<span class="string">"https://proxy.golang.org,direct"</span></span><br><span class="line">GOROOT=<span class="string">"/usr/local/go"</span></span><br><span class="line">GOSUMDB=<span class="string">"sum.golang.org"</span></span><br><span class="line">GOTMPDIR=<span class="string">""</span></span><br><span class="line">GOTOOLDIR=<span class="string">"/usr/local/go/pkg/tool/linux_amd64"</span></span><br><span class="line">GCCGO=<span class="string">"gccgo"</span></span><br><span class="line">AR=<span class="string">"ar"</span></span><br><span class="line">CC=<span class="string">"gcc"</span></span><br><span class="line">CXX=<span class="string">"g++"</span></span><br><span class="line">CGO_ENABLED=<span class="string">"1"</span></span><br><span class="line">GOMOD=<span class="string">""</span></span><br><span class="line">CGO_CFLAGS=<span class="string">"-g -O2"</span></span><br><span class="line">CGO_CPPFLAGS=<span class="string">""</span></span><br><span class="line">CGO_CXXFLAGS=<span class="string">"-g -O2"</span></span><br><span class="line">CGO_FFLAGS=<span class="string">"-g -O2"</span></span><br><span class="line">CGO_LDFLAGS=<span class="string">"-g -O2"</span></span><br><span class="line">PKG_CONFIG=<span class="string">"pkg-config"</span></span><br><span class="line">GOGCCFLAGS=<span class="string">"-fPIC -m64 -pthread -fmessage-length=0</span></span><br><span class="line"><span class="string">    -fdebug-prefix-map=/tmp/go-build602227063=/tmp/go-build -gno-record-gcc-switches"</span></span><br></pre></td></tr></table></figure><h1 id="VSCode-Remote-时修改的环境变量不生效"><a href="#VSCode-Remote-时修改的环境变量不生效" class="headerlink" title="VSCode Remote 时修改的环境变量不生效"></a>VSCode Remote 时修改的环境变量不生效</h1><p>这个问题也是在这次配置 <code>Go</code> 调试环境时遇到的，我是在 <code>~/.profile</code> 文件中修改的 <code>GOPATH</code>的内容，但是在VSCode中调试时就是报错，其表现就跟修改的变量未生效一致，后来查资料发现，原来出现这种情况和配置文件的加载顺序有关，具体参考下列文章：</p><ul><li><a href="https://debug.fanzheng.org/post/vscode-remote-env-loading-sequel.html" target="_blank" rel="noopener">VSCode Remote环境变量加载——续</a></li><li><a href="https://github.com/microsoft/vscode-remote-release/issues/83" target="_blank" rel="noopener">remote-ssh: .profile not sourced for bash shells, only .bashrc? #83</a></li><li><a href="https://unix.stackexchange.com/questions/50665/what-is-the-difference-between-interactive-shells-login-shells-non-login-shell" target="_blank" rel="noopener">What is the difference between interactive shells, login shells, non-login shell and their use cases?</a></li></ul><p>其实在linux中的shell有 <code>interactive shell</code>、 <code>non-interactive shell</code>、 <code>login shell</code>、 <code>non-login shell</code> 的区分，每种情况下调用的初始化脚本不同，涉及到 <code>/etc/profile</code>、<code>~/.bash_profile</code> <code>~/.bash_login /</code> <code>~/.profile</code>等等，而在VSCode远程连接Linux时还会继承之前的环境，多次尝试之后还是不起效果，此时不得不高呼“重启大法好”，重启能解决80%的问题，剩下的20%只能靠重做系统来解决了。</p><p>在我这修改脚本内容不生效，脚本间调用还搞出了死循环的问题，不知道是不是因为我使用 <code>zsh</code> 这个 <code>shell</code>作为默认环境出的问题，但重启大法依然奏效，电脑重启后环境变量成功修改了。</p><h1 id="C-的包管理器"><a href="#C-的包管理器" class="headerlink" title="C++ 的包管理器"></a>C++ 的包管理器</h1><p>捣鼓这么久 <code>Go</code>，突然想到一个问题，<code>C++</code> 有没有包管理器呢？答案是有的，并且有很多，但是都存在着这样或那样的问题，可以重点看一下 <code>conan</code>，具体使用可以搜索官网，或者看看下面这些总结。</p><ul><li><a href="http://chu-studio.com/posts/2019/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84C++%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8CONAN%E4%B8%8A%E6%89%8B%E6%8C%87%E5%8D%97" target="_blank" rel="noopener">从零开始的C++包管理器CONAN上手指南</a></li><li><a href="https://www.cnblogs.com/xl2432/p/11873394.html" target="_blank" rel="noopener">conan使用(一)–安装和应用</a></li></ul><p><code>conan</code> 是一款使用 <code>python</code> 开发的包管理工具，所以需要依赖 <code>Python</code> 环境，CentOS 平台上安装 Python 环境可以参考 <a href="https://zhuanlan.zhihu.com/p/47508850" target="_blank" rel="noopener">Centos安装python3.6和pip步骤记录</a>，虽然CentOS即将被放弃，但是目前在各种云服务器上依旧是主流系统，安装 Python 环境时需要注意一步步跟着做，最好不要投机取巧，我就是因为少安装了一个依赖，导致我使用 <code>pip install conan</code>命令安装 <code>conan</code> 是报错 <code>ModuleNotFoundError: No module named &#39;_ctypes&#39;</code>，此时可以安装依赖，重新编译安装 ·conan· 就可以了，也就是运行 <code>yum install libffi-devel -y</code>，重新 <code>make clean &amp;&amp; make &amp;&amp; make install</code> 就可以了。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>Go 的项目在 1.12 版本之后不必放到 <code>GOPATH</code> 路径中了，灵活度大大提高</li><li>C++ 也是有包管理器的，其中 conan 排名比较靠前，它是由 Python 语言编写的</li><li><code>go get</code> 是安装依赖包常常要用到的 Go 命令， <code>go help</code> 会提供 Go 相关的许多知识</li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/113812016" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>有时正确的选择比刻苦努力更加重要，用战术上的勤奋来掩盖战略上的懒惰，其结果只是感动了自己，而不会带我们达到目标。将者，智信仁勇严也~</p><p>2021-2-21 01:19:01</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;过了个年回到工作岗位，发现之前好好的 &lt;code&gt;Go&lt;/code&gt; 环境无法进行调试了，于是又重新配置了一次，弄好之后的新参数与原来有一些不一样的地方，甚至还有一些矛盾的地方，真搞不清楚原来的配置参数怎么能成功调试的，也是奇了怪了。配置过程中还遇到了一些问题，特别记录一下，防止今后遇到类似问题还要苦苦寻找。&lt;/p&gt;
    
    </summary>
    
      <category term="Go" scheme="http://AlbertGithubHome.github.io/blog/categories/Go/"/>
    
    
      <category term="Go" scheme="http://AlbertGithubHome.github.io/blog/tags/Go/"/>
    
      <category term="GOPATH" scheme="http://AlbertGithubHome.github.io/blog/tags/GOPATH/"/>
    
      <category term="mod" scheme="http://AlbertGithubHome.github.io/blog/tags/mod/"/>
    
      <category term="包管理" scheme="http://AlbertGithubHome.github.io/blog/tags/%E5%8C%85%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>TCP/IP协议簇中的子网掩码有什么作用</title>
    <link href="http://AlbertGithubHome.github.io/blog/2021/02/14/TCP-IP%E5%8D%8F%E8%AE%AE%E7%B0%87%E4%B8%AD%E7%9A%84%E5%AD%90%E7%BD%91%E6%8E%A9%E7%A0%81%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8/"/>
    <id>http://AlbertGithubHome.github.io/blog/2021/02/14/TCP-IP协议簇中的子网掩码有什么作用/</id>
    <published>2021-02-14T15:55:30.000Z</published>
    <updated>2021-02-19T13:57:45.278Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>前几天在配置数据库主从结构时查询了一些IP配置，后来编写远程执行脚本时又配置了一些IP数据，在<code>linux</code>上使用 <code>ifconfig</code> 命令查询IP配置时发现子网掩码不是常用的3个255，而是 <code>255.255.254.0</code>，只是简单记得这样配置扩大了子网的范围，但是具体子网掩码怎么使用还是记不清楚了，所以查询了这些还给老师的知识，在此总结一下。</p><a id="more"></a><h1 id="IP地址分类"><a href="#IP地址分类" class="headerlink" title="IP地址分类"></a>IP地址分类</h1><p>关于IPv4的地址分类之前有专门的总结，可以参考这一篇<a href="https://blog.csdn.net/albertsh/article/details/88914811" target="_blank" rel="noopener">《IP地址常见分类：A类、B类、C类、D类、E类》</a>，其中常用到的也就是A类、B类、C类这三种，默认的子网掩码分别为 <code>255.0.0.0</code>、<code>255.255.0.0</code>、<code>255.255.255.0</code>，通过IP地址和子网掩码进行与运算可以得出IP地址所对应的网络地址。</p><h1 id="子网掩码"><a href="#子网掩码" class="headerlink" title="子网掩码"></a>子网掩码</h1><p>子网掩码通过它的名字来判断肯定和子网有关系，掩码又有遮遮掩掩之意，合在一起其实就是通过其作用来进行的命名，也就是对IP地址进行遮掩，然后得到子网地址的作用。</p><h2 id="掩码的作用"><a href="#掩码的作用" class="headerlink" title="掩码的作用"></a>掩码的作用</h2><p>刚刚说通过子网掩码和IP地址可以获得网络地址，那么没有子网掩码可不可以呢？实际上如果进行某些约定就可以不使用子网掩码来获得网络地址，比如IPv4是通过4个字节来表示一个IP地址的，分为网络号和主机号两部分，A类IP地址可以使用第一字节表示网络号，B类地址使用前两个字节表示网络号，C类地址使用前3个字节表示网络号，其实这也是默认的表示方法。</p><p>加入子网掩码只是为了更灵活的配置子网，如果都按照默认的“规矩”进行划分就太死板了，难以适应复杂的需求环境，比如一个A类地址 <code>10.0.48.36</code> 默认的子网 <code>10.0.0.0</code>，可以容纳16777214台主机，这样如果一个子网的所需IP数量远远小于这个数字就会产生巨大的浪费。</p><p>再比如一个C类地址 <code>192.168.0.1</code> 的默认子网是 <code>192.168.0.0</code>，可以容纳254台主机，如果一个公司或者组织有500人，那么一个C类的子网就无法满足要求，需要分配B类地址才能解决问题，所以才有了子网掩码的出现，可以使子网的划分更加合理。</p><h2 id="掩码表示"><a href="#掩码表示" class="headerlink" title="掩码表示"></a>掩码表示</h2><p>掩码的表示比较简单，它由四个字节构成，表示成二进制形式时为前1后0，可以像IP地址一样的格式来书写，也可以写出掩码中有多少个1，举个例子，下面表示一个IP和子网：</p><ul><li><code>192.168.1.1</code> 和 <code>255.255.254.0</code></li></ul><p>也可以将掩码中1的个数写在IP地址后面表示成：</p><ul><li><code>192.168.1.1/23</code></li></ul><h2 id="子网拆分"><a href="#子网拆分" class="headerlink" title="子网拆分"></a>子网拆分</h2><p>增加子网掩码中1的个数可以将子网进行拆分，比如地址 <code>192.168.1.1</code> 和 <code>192.168.1.130</code> 在子网掩码是 <code>255.255.255.0</code>时都属于 <code>192.168.1.0</code> 这个子网，但是将子网掩码换成 <code>255.255.255.128</code>， 那么这两个IP地址就分别属于 <code>192.168.1.0</code> 和 <code>192.168.1.128</code> 这两个子网。</p><h2 id="子网合并"><a href="#子网合并" class="headerlink" title="子网合并"></a>子网合并</h2><p>减少子网掩码中1的个数可以将子网进行合并，比如地址 <code>192.168.1.1</code> 和 <code>192.168.0.1</code> 在子网掩码是 <code>255.255.255.0</code>时分别属于 <code>192.168.1.0</code> 和 <code>192.168.0.0</code> 这两个子网，但是将子网掩码换成 <code>255.255.254.0</code>， 那么这两个IP地址就都属于 <code>192.168.0.0</code> 这个子网了。</p><h1 id="网络包的传播"><a href="#网络包的传播" class="headerlink" title="网络包的传播"></a>网络包的传播</h1><p>网络包在子网内是以广播的形式传播，靠的是MAC地址，通过ARP协议可以获得，但是子网间的传播依赖IP地址，需通过路由或者三层交换机才能实现。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>通过IP地址和子网掩码进行按位与运算可以计算出IP地址所在的网络地址</li><li>通过子网掩码可以更合理的划分子网，对默认子网进行拆分与合并，一定程度上减少浪费和拥堵</li><li>子网内通信需要MAC地址，广播的形式来传递消息，这就是为什么网卡设置为混合模式可以截获到发给他人的消息</li><li>子网间通信需要借助IP地址才能实现，不过MAC地址也是需要的，通常被设置为网管的MAC地址</li><li>平时使用的 <code>ping</code> 命令，其实是 <code>ICMP</code> 协议的一部分，它是TCP/IP协议族的一个子协议，用于在IP主机、路由器之间传递控制消息</li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/113765130" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>勤劳的人总能挤出时间来坚持自己的习惯，懒惰的人总能找到借口来逃避应该做的事情，认定的目标就要大胆的开始，无论什么想法只要迈出了第一步就不算晚~</p><p>2021-2-14 23:57:52</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;前几天在配置数据库主从结构时查询了一些IP配置，后来编写远程执行脚本时又配置了一些IP数据，在&lt;code&gt;linux&lt;/code&gt;上使用 &lt;code&gt;ifconfig&lt;/code&gt; 命令查询IP配置时发现子网掩码不是常用的3个255，而是 &lt;code&gt;255.255.254.0&lt;/code&gt;，只是简单记得这样配置扩大了子网的范围，但是具体子网掩码怎么使用还是记不清楚了，所以查询了这些还给老师的知识，在此总结一下。&lt;/p&gt;
    
    </summary>
    
      <category term="Network" scheme="http://AlbertGithubHome.github.io/blog/categories/Network/"/>
    
    
      <category term="network" scheme="http://AlbertGithubHome.github.io/blog/tags/network/"/>
    
      <category term="ip" scheme="http://AlbertGithubHome.github.io/blog/tags/ip/"/>
    
      <category term="ping" scheme="http://AlbertGithubHome.github.io/blog/tags/ping/"/>
    
      <category term="子网掩码" scheme="http://AlbertGithubHome.github.io/blog/tags/%E5%AD%90%E7%BD%91%E6%8E%A9%E7%A0%81/"/>
    
      <category term="MAC" scheme="http://AlbertGithubHome.github.io/blog/tags/MAC/"/>
    
  </entry>
  
  <entry>
    <title>C/C++中string和int相互转换的常用方法</title>
    <link href="http://AlbertGithubHome.github.io/blog/2021/02/08/C-C-%E4%B8%ADstring%E5%92%8Cint%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/"/>
    <id>http://AlbertGithubHome.github.io/blog/2021/02/08/C-C-中string和int相互转换的常用方法/</id>
    <published>2021-02-08T15:41:12.000Z</published>
    <updated>2021-02-08T16:49:27.058Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>字符串操作是各种算法题中的常客，很多数据常常以字符串形式给出，其中有的需要自己转化成整数，而一些整型数据有时转换成字符串处理起来更加方便，比如判断一个整数是否是回文数，所以字符串和整数的转换是一些问题处理的基础步骤，<code>C++</code> 在处理这类问题时并不像 <code>Python</code> 那样方便，但是也有许多方法能够实现，为了今后查找方便，整理如下。</p><a id="more"></a><h1 id="int-转-string"><a href="#int-转-string" class="headerlink" title="int 转 string"></a>int 转 string</h1><h2 id="通过-std-to-string-函数转换"><a href="#通过-std-to-string-函数转换" class="headerlink" title="通过 std::to_string() 函数转换"></a>通过 std::to_string() 函数转换</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">123</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::to_string(num);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方式在 C++11 中才能使用，编译时记得加上 <code>--std=c++11</code> 的选项</p><h2 id="通过-ostringstream-转换"><a href="#通过-ostringstream-转换" class="headerlink" title="通过 ostringstream 转换"></a>通过 ostringstream 转换</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">123</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">ostringstream</span> ss;</span><br><span class="line">    ss &lt;&lt; num;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ss.str();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一种通过字符流的方式将整数转换成字符串，这种方式在C++11之前也可以使用</p><h2 id="通过-sprintf-转换"><a href="#通过-sprintf-转换" class="headerlink" title="通过 sprintf 转换"></a>通过 sprintf 转换</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">123</span>;</span><br><span class="line">    <span class="keyword">char</span> buffer[<span class="number">256</span>];</span><br><span class="line">    <span class="built_in">sprintf</span>(buffer, <span class="string">"%d"</span>, num);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s"</span>, buffer);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一种C语言中的转换方式，<code>sprintf</code> 也可以换成更安全的 <code>snprintf</code> 函数</p><h1 id="string-转-int"><a href="#string-转-int" class="headerlink" title="string 转 int"></a>string 转 int</h1><h2 id="通过-istringstream-转换"><a href="#通过-istringstream-转换" class="headerlink" title="通过 istringstream 转换"></a>通过 istringstream 转换</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> str = <span class="string">"668"</span>;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="function"><span class="built_in">istringstream</span> <span class="title">ss</span><span class="params">(str)</span></span>;</span><br><span class="line">    ss &gt;&gt; num;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; num;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 <code>istringstream</code> 可以从字符流中读取整数，与 <code>ostringstream</code> 是一种相反的操作</p><h2 id="使用-sscanf-来转化"><a href="#使用-sscanf-来转化" class="headerlink" title="使用 sscanf 来转化"></a>使用 sscanf 来转化</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> str = <span class="string">"668"</span>;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sscanf</span>(str.c_str(), <span class="string">"%d"</span>, &amp;num);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; num;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意 <code>sscanf</code> 函数的第一个参数类型是 <code>const char *</code>，<code>string</code>类型的参数需要转换一下</p><h2 id="使用-atoi-转换"><a href="#使用-atoi-转换" class="headerlink" title="使用 atoi 转换"></a>使用 atoi 转换</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> str = <span class="string">"668"</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; atoi(str.c_str());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>atoi</code> 函数的头文件是 <code>stdlib.h</code>，同样是一个C语言中的函数</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li><code>itoa</code> 不是c语言标准函数，在跨平台的整数转字符串的代码中不要使用这个函数</li><li><code>atoi</code> 是一个标准函数，需要将它和 <code>itoa</code> 区别开来，这一点很容易记混的</li><li>如果是在C++环境中进行转换，推荐使用 <code>stringstream</code> 字符流的形式和 <code>to_string</code> 函数</li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/113487945" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>这个世界真的很有趣，只要活着，就会有无限可能~</p><p>2021-2-9 00:44:34</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;字符串操作是各种算法题中的常客，很多数据常常以字符串形式给出，其中有的需要自己转化成整数，而一些整型数据有时转换成字符串处理起来更加方便，比如判断一个整数是否是回文数，所以字符串和整数的转换是一些问题处理的基础步骤，&lt;code&gt;C++&lt;/code&gt; 在处理这类问题时并不像 &lt;code&gt;Python&lt;/code&gt; 那样方便，但是也有许多方法能够实现，为了今后查找方便，整理如下。&lt;/p&gt;
    
    </summary>
    
      <category term="C/C++" scheme="http://AlbertGithubHome.github.io/blog/categories/C-C/"/>
    
    
      <category term="C/C++" scheme="http://AlbertGithubHome.github.io/blog/tags/C-C/"/>
    
      <category term="string" scheme="http://AlbertGithubHome.github.io/blog/tags/string/"/>
    
      <category term="int" scheme="http://AlbertGithubHome.github.io/blog/tags/int/"/>
    
      <category term="相互转化" scheme="http://AlbertGithubHome.github.io/blog/tags/%E7%9B%B8%E4%BA%92%E8%BD%AC%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>C++中一些方便的算法函数和吃不够的语法糖</title>
    <link href="http://AlbertGithubHome.github.io/blog/2021/01/30/C-%E4%B8%AD%E4%B8%80%E4%BA%9B%E6%96%B9%E4%BE%BF%E7%9A%84%E7%AE%97%E6%B3%95%E5%87%BD%E6%95%B0%E5%92%8C%E5%90%83%E4%B8%8D%E5%A4%9F%E7%9A%84%E8%AF%AD%E6%B3%95%E7%B3%96/"/>
    <id>http://AlbertGithubHome.github.io/blog/2021/01/30/C-中一些方便的算法函数和吃不够的语法糖/</id>
    <published>2021-01-30T08:09:01.000Z</published>
    <updated>2021-01-31T15:53:29.537Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>C++由于其复杂性，学习成本很高。但是作为接近底层的语言，学会之后能做的事情相当多，C++给了开发者极大的自由，只要符合规范就可以尽情的折腾，不过对于日常使用来说确实不太“方便”，特别是相比于Python、JS这类脚本语言，处理一些小问题时前奏太长，很多常用操作都需要自己造轮子，这一点在刷题时感觉很明显，C++一碰到字符串分析就“头大”，Python用一行搞定，用C++则需要N行。</p><a id="more"></a><h1 id="变化"><a href="#变化" class="headerlink" title="变化"></a>变化</h1><p>其实很多人对C++的认识还停留在 <code>C++98</code> 或者 <code>C++03</code> 版本，然而从 <code>C++11</code> 版本开始C++就发生了翻天覆地的变化，近期在使用的过程中发现C++也有很多方便的函数，越高的版本越方便，语法糖也越多，今天先总结几个，后续再补充吧。</p><h1 id="优秀函数和语法糖"><a href="#优秀函数和语法糖" class="headerlink" title="优秀函数和语法糖"></a>优秀函数和语法糖</h1><h2 id="使用find系列实现trim函数"><a href="#使用find系列实现trim函数" class="headerlink" title="使用find系列实现trim函数"></a>使用find系列实现trim函数</h2><p><code>trim</code>函数在很多语言中都是内置函数，可以去除收尾两端的空格，在C++中是没有trim函数的，需要自己实现一下，需要用到的工具函数有下面两个：</p><ul><li><code>find_first_not_of</code>：在字符串s中找到第一个不等于指定字符序列<code>ACDE..</code>的位置</li><li><code>find_last_not_of</code>：在字符串s中找到最后一个不等于指定字符序列<code>ACDE..</code>的位置</li></ul><p><code>find_first_not_of(&quot;hello world&quot;, &quot;he&quot;)</code> 指的就是找到第一个不等于 <code>h</code> 且不等于 <code>e</code> 字母的字符位置，要想去除字符串首尾空格就需要找到第一个不等于空格的位置，和最后一个不等于空格的位置，保留这两个位置中的部分即可，实现如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="function"><span class="built_in">string</span>&amp; <span class="title">trim</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> &amp;s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s.empty()) <span class="keyword">return</span> s;</span><br><span class="line"></span><br><span class="line">    s.erase(<span class="number">0</span>, s.find_first_not_of(<span class="string">" "</span>));</span><br><span class="line">    <span class="keyword">return</span> s.erase(s.find_last_not_of(<span class="string">" "</span>) + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="function"><span class="built_in">string</span>&amp; <span class="title">trim</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> &amp;s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s.empty()) <span class="keyword">return</span> s;</span><br><span class="line"></span><br><span class="line">    s.erase(<span class="number">0</span>, s.find_first_not_of(<span class="string">" "</span>));</span><br><span class="line">    <span class="keyword">return</span> s.erase(s.find_last_not_of(<span class="string">" "</span>) + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(<span class="string">" Hello world  "</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"before trim ==&gt;"</span> &lt;&lt; s &lt;&lt; <span class="string">"&lt;&lt;=="</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"after trim ==&gt;"</span> &lt;&lt; trim(s) &lt;&lt; <span class="string">"&lt;&lt;=="</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:/mnt/d/data/cpp/cplusplusadvance$ g++ stringtrim.cpp -o stringtrim</span><br><span class="line">albert@home-pc:/mnt/d/data/cpp/cplusplusadvance$ ./stringtrim</span><br><span class="line">before trim ==&gt; Hello world  &lt;&lt;==</span><br><span class="line">after trim ==&gt;Hello world&lt;&lt;==</span><br></pre></td></tr></table></figure><h2 id="使用regex实现split函数"><a href="#使用regex实现split函数" class="headerlink" title="使用regex实现split函数"></a>使用regex实现split函数</h2><p><code>split</code> 也是一个常用但C++不提供的函数，在C语言和早期的C++中一般通过 <code>strtok</code> 函数来实现，但是从 <code>C++11</code> 开始可以通过 <code>regex</code> 来实现，可以看下面这个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;regex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(<span class="string">"c++11 test split"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">regex <span class="title">reg</span><span class="params">(<span class="string">" "</span>)</span></span>; <span class="comment">// "\\s+" for blank</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; v(sregex_token_iterator(s.begin(), s.end(), reg, <span class="number">-1</span>), sregex_token_iterator());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> str : v)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"==&gt;"</span> &lt;&lt; str &lt;&lt; <span class="string">"&lt;&lt;=="</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结构如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:/mnt/d/data/cpp/cplusplusadvance$ g++ stringsplit.cpp -o stringsplit --std=c++17</span><br><span class="line">albert@home-pc:/mnt/d/data/cpp/cplusplusadvance$ ./stringsplit</span><br><span class="line">==&gt;c++11&lt;&lt;==</span><br><span class="line">==&gt;<span class="built_in">test</span>&lt;&lt;==</span><br><span class="line">==&gt;split&lt;&lt;==</span><br></pre></td></tr></table></figure><h2 id="使用auto遍历map结构"><a href="#使用auto遍历map结构" class="headerlink" title="使用auto遍历map结构"></a>使用auto遍历map结构</h2><p>很早以前C++中遍历map、set等复杂结构的时候需要写很长的代码来定义迭代器，自从出现了auto之后这种遍历简单了许多，最近发现针对map的遍历还有更简单的方法，使用方法如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; m&#123;&#123;<span class="string">"tom"</span>, <span class="number">20</span>&#125;, &#123;<span class="string">"albert"</span>, <span class="number">18</span>&#125;, &#123;<span class="string">"bella"</span>, <span class="number">19</span>&#125;, &#123;<span class="string">"bily"</span>, <span class="number">30</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; [name, age] : m) &#123;</span><br><span class="line">        <span class="keyword">if</span> (age &gt; <span class="number">18</span>)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; name &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:/mnt/d/data/cpp/cplusplusadvance$ g++ autonew.cpp -o autonew --std=c++17</span><br><span class="line">albert@home-pc:/mnt/d/data/cpp/cplusplusadvance$ ./stringsplit</span><br><span class="line">bella</span><br><span class="line">bily</span><br><span class="line">tom</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li><code>find_first_not_of</code>、<code>find_last_not_of</code>、<code>find_first_of</code> 这系列函数功能虽简单，但是使用它们可以简化代码逻辑</li><li>正则表达式是处理字符串查找的强有力的工具，合理的使用正则表达式可以达到事半功倍的效果，C++中请使用 <code>std::regex</code></li><li><code>C++17</code>中引入了结构化绑定声明，可以使用auto来声明多个变量，所有变量都必须用中括号括起来</li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/113065257" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>做自己认为对的事情，剩下的交给时间~</p><p>2021-1-31 23:04:17</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;C++由于其复杂性，学习成本很高。但是作为接近底层的语言，学会之后能做的事情相当多，C++给了开发者极大的自由，只要符合规范就可以尽情的折腾，不过对于日常使用来说确实不太“方便”，特别是相比于Python、JS这类脚本语言，处理一些小问题时前奏太长，很多常用操作都需要自己造轮子，这一点在刷题时感觉很明显，C++一碰到字符串分析就“头大”，Python用一行搞定，用C++则需要N行。&lt;/p&gt;
    
    </summary>
    
      <category term="C/C++" scheme="http://AlbertGithubHome.github.io/blog/categories/C-C/"/>
    
    
      <category term="C/C++" scheme="http://AlbertGithubHome.github.io/blog/tags/C-C/"/>
    
      <category term="auto" scheme="http://AlbertGithubHome.github.io/blog/tags/auto/"/>
    
      <category term="algorithm" scheme="http://AlbertGithubHome.github.io/blog/tags/algorithm/"/>
    
      <category term="语法糖" scheme="http://AlbertGithubHome.github.io/blog/tags/%E8%AF%AD%E6%B3%95%E7%B3%96/"/>
    
  </entry>
  
  <entry>
    <title>启用make多任务参数让构建过程加速完成</title>
    <link href="http://AlbertGithubHome.github.io/blog/2021/01/23/%E5%90%AF%E7%94%A8make%E5%A4%9A%E4%BB%BB%E5%8A%A1%E5%8F%82%E6%95%B0%E8%AE%A9%E6%9E%84%E5%BB%BA%E8%BF%87%E7%A8%8B%E5%8A%A0%E9%80%9F%E5%AE%8C%E6%88%90/"/>
    <id>http://AlbertGithubHome.github.io/blog/2021/01/23/启用make多任务参数让构建过程加速完成/</id>
    <published>2021-01-23T06:23:05.000Z</published>
    <updated>2021-01-27T16:33:30.730Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>是不是有时候觉得使用make命令编译时太慢了，特别是紧急修改BUG的时候，恨不得钻进电脑里帮着编译器一起干活，其实make命令是可以加速的，使用 <code>-j</code> 选项即可指定make启动的任务数，它是 <code>--jobs[=jobs]</code> 的缩写形式，比如 <code>make -j4</code> 就表示同时启动4个任务并行构建，虽然达不到4倍的关系，但是要比原来快多了。</p><a id="more"></a><h1 id="寻找"><a href="#寻找" class="headerlink" title="寻找"></a>寻找</h1><p>寻找这样一个参数的原因还是觉得有时编译太慢了，特别是修改一个公共的头文件时，几乎要从头编译到尾，启用 <code>-j</code> 参数的过程异常顺利，没有任何报错，迅速的就构建完成，这让我想起了之前一个项目中遇到过的问题。</p><p>同样是编译过程比较慢，但是老大哥告诉我启用多线程编译会报错，作为新手小白的我就默默记住了，也没有过多的探究，毕竟编译的次数不是那么多，偶尔长时间编译一次也没有什么关系，但是现在突然想知道当时为什么使用多线程编译会报错呢？</p><h1 id="可能的原因"><a href="#可能的原因" class="headerlink" title="可能的原因"></a>可能的原因</h1><p>当知识渐渐丰富以后，面对这样的问题还是有些头绪的，启用 <code>make -jn</code>时被称为多任务并行构建，也有的文章会写多线程编译或者多进程编译，从表现来看至少是多进程的，因为在任务列表可以看到不同的进程id，不过这里的名字不是重点，重点是有多个任务在同时干活。</p><p>当启用多任务构建时原来的串行构建逻辑就变成了并行，那么此时构建失败多是由依赖关系指定不正确导致，这种依赖关系通常有两种：</p><ul><li>B模块编译需要用到A模块的函数</li><li>B模块构建过程中需要的临时数据由A模块构建时产生，两种共用临时数据，但是有序</li></ul><p>总结来说就是逻辑上需要A构建完了，才能开始构建B，如果此时先构建B任务就会导致出错，这就能解释为什么使用 <code>make</code> 可以成功，但是使用 <code>make -j4</code> 就构建失败，也能解释为什么失败之后，多次执行这个命令可能还会成功，因为多次执行以后可能会把A模块先构建完，这样后面再构建B就不会出错了。</p><h1 id="加速"><a href="#加速" class="headerlink" title="加速"></a>加速</h1><p>从上面的分析可以得知，模块间的依赖关系决定了多任务构建时应有的顺序，那么是不是所有的构建任务都可以通过 <code>-j</code> 来加速呢？答案当然是否定的，如果要构建项目的所有模块的依赖关系完全是线性的，那么就没有办法并行完成，比如下面这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">graph TB</span><br><span class="line">    A--&gt;B;</span><br><span class="line">    B--&gt;C;</span><br><span class="line">    C--&gt;D;</span><br><span class="line">    D--&gt;E;</span><br><span class="line">    E--&gt;F;</span><br></pre></td></tr></table></figure><p>但是整个任务如果可以进行拆分，整个依赖图中出现分叉，那么就可以通过这种方式来加速，比如像这样的依赖关系：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">graph TB</span><br><span class="line">    A--&gt;B;</span><br><span class="line">    A--&gt;C;</span><br><span class="line">    B--&gt;D;</span><br><span class="line">    B--&gt;E;</span><br><span class="line">    C--&gt;F;</span><br></pre></td></tr></table></figure><p>上面所表示的关系中，虽然 B 和 C 都需要依赖A完成，但是当 A 完成后，B 和 C 的构建就可以并行开始，这样就可以达到加速构建的目的。</p><h1 id="视网膜效应"><a href="#视网膜效应" class="headerlink" title="视网膜效应"></a>视网膜效应</h1><p>之前也没有注意到 <code>make</code> 命令这个 <code>-j</code> 的选项，自从在项目中使用了一次，我发现在很多项目说明中都看到了这个参数，比如安装 <code>global</code> 的时候，编译 <code>tendis</code> 的时候等等，之前也有这样的情况，就是当你刚接触一个事物，或者进入一个新领域的时候，发现其实周围很多人都在讨论这些事物，自己以前都没注意到，上网查了一下，原来这叫做视网膜效应。</p><p>视网膜效应这个学术名词用白话文来讲就是“心眼”，每一个人的眼睛，都是跟着心走！简单地说，这种效应的意思就是一个人的身心状况会影响他的视线，当他自己拥有一件东西或一项特征时，他就会比平常人更会注意到别人是否跟他一样具备这种特征，即越关注什么就越出现什么。</p><p>视网膜效应是一种狭隘视野与思维的反映，它会导致看问题不全面，甚至会出现牛走羊肠道、鼠钻牛角尖的极端现象。其实每个人的特质中，都有很多优点和缺点。当一个人只知道自己的缺点是什么，而不知发掘优点时，视网膜效应就会促使这个人发现他身边也有许多人拥有类似的缺点，进而使他的人际关系无法改善，生活也不会快乐。</p><h1 id="随便聊聊"><a href="#随便聊聊" class="headerlink" title="随便聊聊"></a>随便聊聊</h1><h2 id="make"><a href="#make" class="headerlink" title="make"></a>make</h2><p>从刚接触这个命令的时候就认为它是编译的意思，其实这是一种先入为主的思想，因为之前在linux安装软件时常需要下面这三步：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./configure</span><br><span class="line">./make</span><br><span class="line">./make install</span><br></pre></td></tr></table></figure><p>从源码安装软件就需要进行编译，所以一直认为这三步是配置、编译、安装的意思，其实 <code>make</code> 本身并不会编译，它只是编译命令的搬运工。</p><p>它的真实含义应该是构建，这个构建可不一定是编译，可以是任何逻辑化的事物，只不过常常用 <code>make</code> 来完成编译任务，所以把它和编译绑定到了一起，构建时需要图纸的，这个图纸就是 <code>Makefile</code> 文件，只要我们画好了Makefile图纸，那么 <code>make</code> 命令就可以根据它来完成任务。</p><p>所以当你运行 <code>make</code> 命令时，仿佛在说: “Here’s your drawing, go go go！”，又仿佛在说：“图纸搁这儿呢，可劲儿造吧”，以这个观点来看 <code>make</code> 的一系列命令就有意思了：</p><ul><li><code>make</code>：图纸搁这儿呢，可劲儿造吧</li><li><code>make clean</code>：把你弄得这堆破烂儿，拾掇拾掇</li><li><code>make install</code>：把你鼓捣出的那玩意，搬到旮旯去</li><li><code>make dist</code>：赶紧把那玩意打包拉走</li></ul><h2 id="cmake"><a href="#cmake" class="headerlink" title="cmake"></a>cmake</h2><p>既然 <code>make</code> 是编译命令的搬运工，那么 <code>cmake</code> 又是什么意思呢？大胆猜测他就是 <code>config make</code> 的意思，它的作用是生成 Makefile 文件，换句话来说就是给 <code>make</code> 造图纸的。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>使用 <code>make -j4</code> 命令可以开启4个任务并行构建，大大加快构建速度</li><li><code>make</code> 本身并不能进行编译，它只是各种编译命令的搬运工，需要Makefile图纸才能进行工作</li><li><code>cmake</code> 的作用是生成 <code>make</code> 所需的图纸，有了它可以更快更方便的生成一些规范的Makefile文件</li><li>视网膜效应指的是越关注什么就越出现什么的效应，是一种狭隘视野与思维的反映，会导致看问题不全面</li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/112727308" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>未经他人苦，莫劝他人善，世上总有一些你无法理解，但却真实存在的生活~</p><p>2021-1-23 17:24:15</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;是不是有时候觉得使用make命令编译时太慢了，特别是紧急修改BUG的时候，恨不得钻进电脑里帮着编译器一起干活，其实make命令是可以加速的，使用 &lt;code&gt;-j&lt;/code&gt; 选项即可指定make启动的任务数，它是 &lt;code&gt;--jobs[=jobs]&lt;/code&gt; 的缩写形式，比如 &lt;code&gt;make -j4&lt;/code&gt; 就表示同时启动4个任务并行构建，虽然达不到4倍的关系，但是要比原来快多了。&lt;/p&gt;
    
    </summary>
    
      <category term="linux" scheme="http://AlbertGithubHome.github.io/blog/categories/linux/"/>
    
    
      <category term="C++" scheme="http://AlbertGithubHome.github.io/blog/tags/C/"/>
    
      <category term="linux" scheme="http://AlbertGithubHome.github.io/blog/tags/linux/"/>
    
      <category term="编译" scheme="http://AlbertGithubHome.github.io/blog/tags/%E7%BC%96%E8%AF%91/"/>
    
      <category term="make" scheme="http://AlbertGithubHome.github.io/blog/tags/make/"/>
    
  </entry>
  
  <entry>
    <title>记一次解决Intel 9462无线网卡的笔记本安装Ubuntu16.04后无法连接WIFI问题的艰难历程</title>
    <link href="http://AlbertGithubHome.github.io/blog/2021/01/16/%E8%AE%B0%E4%B8%80%E6%AC%A1%E8%A7%A3%E5%86%B3Intel-9462%E6%97%A0%E7%BA%BF%E7%BD%91%E5%8D%A1%E7%9A%84%E7%AC%94%E8%AE%B0%E6%9C%AC%E5%AE%89%E8%A3%85Ubuntu16-04%E5%90%8E%E6%97%A0%E6%B3%95%E8%BF%9E%E6%8E%A5WIFI%E9%97%AE%E9%A2%98%E7%9A%84%E8%89%B0%E9%9A%BE%E5%8E%86%E7%A8%8B/"/>
    <id>http://AlbertGithubHome.github.io/blog/2021/01/16/记一次解决Intel-9462无线网卡的笔记本安装Ubuntu16-04后无法连接WIFI问题的艰难历程/</id>
    <published>2021-01-16T14:43:32.000Z</published>
    <updated>2021-01-23T11:21:46.708Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>一台新申请的ThinkPad-X390笔记本需要安装Ubuntu系统，为了统一工作开发环境，选择了大家一直都在使用Ubuntu16.04版本，虽然这个系统版本旧一点，不过同一个版本出现开发环境问题也好排查，但没想到的是这里埋下了一个坑，导致成功安装系统后却不能上网，足足折腾了一整天才搞定，记录一下，没事回来看看还能乐呵乐呵。</p><a id="more"></a><h1 id="安装环境"><a href="#安装环境" class="headerlink" title="安装环境"></a>安装环境</h1><ul><li>ThinkPad-X390 笔记本</li><li>Intel® Wireless-AC 9462 无线网卡</li><li>Ubuntu 16.04.7 系统</li></ul><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p>根本原因：Ubuntu 16.04内核版本太低，无法自动识别网卡，需要手动升级内核，安装无线网卡驱动。如果你遇到的情况也是新版本无线网卡，安装老版本系统时无法连接WIFI，请参考这个无私博主的解决方法，有这一篇足够了</p><p><a href="https://blog.csdn.net/dieju8330/article/details/101422743" target="_blank" rel="noopener">联想 Yoga C740：：关于Ubuntu16.04下无法识别Intel WIFI6 AX201无线网卡的解决方案，https://blog.csdn.net/dieju8330/article/details/101422743</a></p><h1 id="安装过程"><a href="#安装过程" class="headerlink" title="安装过程"></a>安装过程</h1><p>下面开始碎碎念内容，虽然现在看来只要是上面那一个链接就可以解决问题，但是这却是浏览了几百个网页后，不断尝试才证明它是有效的，所以我也简单记录一下这个过程，以下的内容可能对你解决问题可能没什么帮助了，不过你要是喜欢听故事倒是可以继续瞧瞧。</p><h2 id="初始环境"><a href="#初始环境" class="headerlink" title="初始环境"></a>初始环境</h2><p>一台预装了Win10系统的笔记本，连接WIFI可以正常上网，一开始是打算装双系统的，但是台式机是Win10，笔记本再保留一个Win10有些浪费空间，准备只安装一个Ubuntu算了。</p><p>又要装Ubuntu了，我在CSDN的第一篇文章的就是有关Ubuntu的，<a href="https://blog.csdn.net/albertsh/article/details/12302473" target="_blank" rel="noopener">《ubuntu 12.04系统黑屏，登录界面黑屏，命令行界面可用》</a>，当时靠着几个命令把问题解决了，这次解决问题同样需要几个命令，但是这个过程就复杂多了。</p><h2 id="安装Ubuntu16-04-2"><a href="#安装Ubuntu16-04-2" class="headerlink" title="安装Ubuntu16.04.2"></a>安装Ubuntu16.04.2</h2><p>本地找到了之前在虚拟机中安装使用过的 ubuntu-16.04.2-desktop-amd64.iso 镜像，使用UltraISO刻录U盘发现一直占用，遂改用rufus来刻录，发现这个软件操作也很方便，顺利完成启动盘制作，安装过程也比较顺利，网上很多大佬的教程都可以拿来参考，比如下面这几篇：</p><ul><li><a href="https://www.jb51.net/article/173277.htm" target="_blank" rel="noopener">《Win10 + Ubuntu 16.04双系统完美安装教程【详细】》</a></li><li><a href="https://www.cnblogs.com/masbay/p/10844857.html" target="_blank" rel="noopener">《Windows10安装ubuntu16.04双系统教程》</a></li><li><a href="https://blog.csdn.net/jeryjeryjery/article/details/80011447" target="_blank" rel="noopener">《卸载win10装Ubuntu笔记》</a></li></ul><p>注意，前两篇是装双系统的，和我们的只安装一个Ubuntu16.04的目标不太一致，但是绝大部分步骤都是一致的，网络上的知识就是这样，要想完全一样太难了，需要学会变通。</p><p>比较懒我就不截图了，去大佬文章里看吧，说一说其中的几个关键点：</p><ul><li>安装Ubuntu需要关闭BOIS中的Secure Boot 选项</li><li>注意一下安装双系统和单个系统时进行分区操作的差异，选对主分区和逻辑分区</li><li>烧制U盘和安装系统时涉及到分区表GPT和MBR的选择，烧制U盘与硬件分区模式一致就好，在windows通过命令或者“管理”都很容易查到</li><li>启动方式有Legacy和UEFI区别，记住UEFI是新的，能用它就用它，不行就换成Legacy，大不了重新装一次，当然你根据硬件情况能准确判断最好</li><li>安装过程中有一步是勾选“为图形或无线硬件…安装第三方软件”，看到很多教程都没勾选，我也没选（伏笔1），感觉我已经入坑了</li></ul><p>非常自信的干掉了Win10系统（伏笔2），干干净净的只安装了Ubuntu，安装很快完成，顺利进入系统，期间跳出来几行错误，我都没看清就闪过去了，应该是不重要，进去后准备部署开发环境，发现没有WIFI列表，这就奇怪了，网卡肯定没问题，之前Win10是可以上网的，肯定是设置的不对，上网查查为什么吧。</p><h2 id="硬件禁止问题"><a href="#硬件禁止问题" class="headerlink" title="硬件禁止问题"></a>硬件禁止问题</h2><p>这是我看到的第一个解决方案，需要改 <code>/etc/Network/NetworkManage.conf</code> 文件中的 <code>manage=false</code> 改成 <code>manage=true</code>, 参考下面这帖子</p><p><a href="https://blog.csdn.net/ye1391/article/details/83180774" target="_blank" rel="noopener">解决Ubuntu下的WiFi列表不显示问题（硬件禁止问题）</a></p><p>现在回过头来想想我根本就不是这个问题，很多特点都对不上，完全是病急乱投医的处理方式，使用 <code>rfkill list</code> 命令根本找不到我的网卡，这一点也是后来才发现的</p><h2 id="激活无线网卡"><a href="#激活无线网卡" class="headerlink" title="激活无线网卡"></a>激活无线网卡</h2><p>很多文章开局就是下面这两个命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install --reinstall bcmwl-kernel-source</span><br></pre></td></tr></table></figure><p>要知道使用 <code>sudo apt-get update</code> 是需要联网的，现在我连不上无线，不存在有线，所以上不去网，然后翻了N个页面之后找到了大神离线安装的方法，其实这个安装文件在镜像里就有，所以打开刚刚烧制的U盘就行了，但是直接安装会有依赖问题，解决这个问题就是一个个在镜像中找到，然后安装上。</p><ul><li><a href="https://blog.csdn.net/ifmvo/article/details/54023628" target="_blank" rel="noopener">《Ubuntu离线安装网卡驱动》</a></li><li><a href="https://www.jianshu.com/p/8b29954ab590" target="_blank" rel="noopener">《【菜鸟向】Ubuntu无法连接wifi问题的解决》</a></li></ul><p>一步步操作之后完全没有作用，现在来看如果能起作用还怪了，这是bcm博通网卡的处理方法，而我的网卡是Intel的，又是做了无用功</p><h2 id="更新软件列表附加驱动"><a href="#更新软件列表附加驱动" class="headerlink" title="更新软件列表附加驱动"></a>更新软件列表附加驱动</h2><p>这种解决方案网上流传的最多，其实就是依靠Ubuntu的软件仓库来解决</p><ul><li><a href="https://blog.csdn.net/weixin_41762173/article/details/79480609" target="_blank" rel="noopener">Ubuntu16.04无法连接Wifi解决方案 （绝对有效）</a></li><li><a href="https://www.cnblogs.com/oxspirt/p/10802163.html" target="_blank" rel="noopener">ubuntu16.04中不能连接无线网络</a></li></ul><p>解决这个问题的关键就是先联网，仿佛陷入了死循环，我现在就是要解决无线网卡连不上网的问题，你却让我先联网更新，其实对于可以连接有线网络的电脑来说没什么问题，但是我这里连不上有线网啊！</p><p>然后我就学到了一个逆天的操作，原来USB可以供网，可以通过USB线让笔记本使用手机的4G网络，瞬间打开了一扇大门，说干就干，先更新一下 Ubuntu 的软件源，可以参考下面这个文章，其实有很多源的，比如常用的清华源、阿里源等等，但是要注意版本，网上流传着一些错误版本的地址，需要自己甄别一下。</p><ul><li><a href="https://blog.csdn.net/Liangontheway/article/details/103509635" target="_blank" rel="noopener">Ubuntu16.04更换国内源</a></li></ul><p>这个软件源其实类似于应用商店的地址，换了软件源就相当于换了一个应用商店，还完源更新之后就可以从软件仓库中有哪些软件，下次再安装软件时就可以找到了，在这列举一个常用的Ubuntu16.04的软件源，替换 <code>/etc/apt/source.list</code> 文件内容就好了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial main</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ xenial main</span><br><span class="line"></span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial-updates main</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ xenial-updates main</span><br><span class="line"></span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial universe</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ xenial universe</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial-updates universe</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ xenial-updates universe</span><br><span class="line"></span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial-security main</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ xenial-security main</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial-security universe</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ xenial-security universe</span><br></pre></td></tr></table></figure><p>准备就绪，USB连接手机，然后共享网络，执行 <code>sudo apt-get update</code> 命令，照着教程操作一通，发现并没有在附加驱动选项卡中发现可用的驱动，失败了，同时耗费了1G流量导致手机网络报警。</p><p>还是回过头来看看，很多人说这种方式解决了问题，但我没有成功，看看成功的那些截图还是博通的网卡，而我这个Intel的网卡有点难搞啊</p><h2 id="更新内核1"><a href="#更新内核1" class="headerlink" title="更新内核1"></a>更新内核1</h2><p>从现在开始渐渐步入正确轨道了，因为我发现的网上各种设置网卡参数的命令在我这没有任何反应，比如执行 <code>rfkill list</code> 结果显示根本没有网卡，只有两个蓝牙，执行 <code>lshw -c network</code> 之后发现 <code>*-network UNCLAIMED</code> 内容，开始搜索相关内容，然后发现了下面的帖子：</p><ul><li><a href="https://askubuntu.com/questions/1052311/network-unclaimed-on-ubuntu" target="_blank" rel="noopener">Network unclaimed on Ubuntu</a></li></ul><p>提问者根据回答人提供的步骤一步步解决了自己的问题，而我在安装这个内核版本时提示已经最新无法继续安装，并且在回答中提到安装 <code>16.04.4</code> 版本的镜像不需要做任何设置就可以使用无线网了，想到自己安装的是 16.04.2，就怀疑是这里的问题，准备安装高版本镜像</p><h2 id="安装Ubuntu16-04-7"><a href="#安装Ubuntu16-04-7" class="headerlink" title="安装Ubuntu16.04.7"></a>安装Ubuntu16.04.7</h2><p>由于Ubuntu官网下载比较慢，所以找了国内的镜像网站下载了 16.04.7版本，刻录U盘启动盘，准备安装</p><ul><li><a href="http://mirrors.ustc.edu.cn/ubuntu-releases/" target="_blank" rel="noopener">中科大ubuntu镜像站</a></li><li><a href="https://blog.csdn.net/Miklechun/article/details/89742372" target="_blank" rel="noopener">几个ubuntu16.04镜像下载地址</a></li></ul><p>这次安装的熟练了一些，完成后进入系统并未有什么改变，依旧连不上网，尝试更新软件试试，于是再一次连接手机USB网络，执行下面命令</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get upgrade</span><br></pre></td></tr></table></figure><p>又是几百兆流量进去了，依然没有效果</p><h2 id="查找网卡版本"><a href="#查找网卡版本" class="headerlink" title="查找网卡版本"></a>查找网卡版本</h2><p>至此虽然已经连不上网，但是基本确定了问题的原因，不是网卡设置的问题，而是驱动版本不对，系统无法识别网卡型号，没有办法正常工作。</p><p>可是怎么才能知道网卡的型号呢？如果正常驱动的无线网卡可以使用 <code>lspci | grep Net</code> 这个命令，但是我这里不行，只显示Intel设备，无法显示设备类型和具体型号，倘若我的win10还在，直接在设备管理器中查就可以了，但是他已经被我自信的格式化了，此处捶胸顿足。</p><p>那怎么办呢？问问旁边的小伙伴？关键电脑型号不一样啊！撬开电脑后盖？估计无线网卡在哪我都找不到。对了，去联想官网看看配置，应该能找到的吧！</p><p>说干就干，打开联想官网居然找不到这个具体的型号，只能找到 ThinkPad-X390 系列，而我这个子系列是20SD，官网上有20SC、20SX、20Q0等等，就是没有20SD，没办法了，看看这个相似的这几个无线网卡都是什么型号吧，发现大多数都是 <code>Intel® 9560AC</code>，部分提到了 <code>Intel® Wi-Fi 6 AX200</code>，这两个网卡差的可是有点多，需求的Ubuntu内核版本差了一个大版本，他们的对应关系可以参考Intel提供的这个文档</p><p><a href="https://www.intel.com/content/www/us/en/support/articles/000005511/network-and-io/wireless.html" target="_blank" rel="noopener">Linux* Support for Intel® Wireless Adapters</a></p><p>联想的官网只提供Windows上的驱动下载，Linux版本只能自己去Intel上找了，现在需要确定网卡版本来下载相应的驱动，但是目前查不到这个网卡的具体型号，还能怎么办呢？去找联想客服吧！</p><p>在联想的官网上找到了联想的售前，说明问题后给出的答案是大概率是 <code>Intel® 9560AC</code> 型号，然后转接技术处理，等待N久之后查了SN码说应该是 <code>Intel® 9560AC</code>，但是我认为应该是网卡型号应该是 <code>Intel® Wi-Fi 6 AX200</code>，如果是 <code>Intel® 9560AC</code> 型号的网卡，需要 Ubuntu<br>的内核是 <code>4.14+</code>，而我安装的内核版本是 <code>4.15.7</code>，系统没理由不认识这个网卡。</p><p>想想还有什么办法查网卡型号呢？既然windows上可以看，那我省点事安装个WinPE进系统看一下。下载常用的微PE工具箱，烧制U盘后进了系统，点开设备管理器，一大串设备都带着问号，原来在WinPE里也没有这些设备的驱动，我又跑去联想官网下载了Windows上的网卡驱动，放到WinPE上安装，结果因缺少DLL而失败，这条路也行不通了。</p><p>只能重新做个win10的系统看看了，再次对删除win10前没看网卡型号而捶胸顿足，下载了5个多G的镜像文件，刻录Win10启动盘，然后安装发现引导不进去，也是醉了，应该是文件系统格式不正确，导致系统无法引导，算了，死马当活马医吧，我直接把无线网卡当成最高的版本，按照<code>Intel® Wi-Fi 6 AX200</code>进行处理，把内核升级了应该就可以了</p><h2 id="更新内核2"><a href="#更新内核2" class="headerlink" title="更新内核2"></a>更新内核2</h2><p>WinPE方式失败后决定升级内核，于是按照文章开头提供的那篇<a href="https://blog.csdn.net/dieju8330/article/details/101422743" target="_blank" rel="noopener">解决方案</a>来处理，但是内核文件安装失败了，无法升级，内心崩溃……</p><p><a href="https://blog.csdn.net/CGJustDoIT/article/details/103363622" target="_blank" rel="noopener">Ubuntu应用—安装 Intel Wireless-AC 9462 无线网卡驱动（无法连接wifi，完美解决）</a></p><p>这一篇也是类似的，同样无法成功更新。</p><h2 id="安装Ubuntu20-04-1"><a href="#安装Ubuntu20-04-1" class="headerlink" title="安装Ubuntu20.04.1"></a>安装Ubuntu20.04.1</h2><p>既然升级内核失败了，我干脆安装个自带高内核版本的系统算了，下载了 Ubuntu20.04.1 的镜像</p><p><a href="https://mirrors.tuna.tsinghua.edu.cn/ubuntu-releases/" target="_blank" rel="noopener">清华大学开源软件镜像站</a></p><p>经过漫长的等待下载完成，刻录Ubuntu启动盘，安装设置一气呵成，搞定了，无线网的小雨伞出现了，简直泪流满面…</p><p>然后通过 <code>lspci | grep Net</code> 来查看网卡型号，结果出现了 <code>Intel Corporation Wireless-AC 9462</code>，看到这里我都惊呆了，原来这个网卡比 <code>Intel® 9560AC</code> 版本还要低，联想客服的回答是错误的，Intel官方驱动的对应关系也不准确，真是没什么可信的了。</p><h2 id="安装Ubuntu18-04-5"><a href="#安装Ubuntu18-04-5" class="headerlink" title="安装Ubuntu18.04.5"></a>安装Ubuntu18.04.5</h2><p>既然无线网卡都可以识别了，为什么还要折腾呢？因为Ubuntu20.04.1这个版本跟周围小伙伴使用的系统版本差的有点多，并且之前出现过项目编译问题，所以换个低一点的版本试试。</p><p>下载镜像，刻录U盘，安装系统轻车熟路，真是越来越顺利了，安装完成后WIFI正常，果然是内核版本的事情，高版本的系统直接就可以使用，根本不需要任何设置。</p><h2 id="再次安装Ubuntu16-04-7"><a href="#再次安装Ubuntu16-04-7" class="headerlink" title="再次安装Ubuntu16.04.7"></a>再次安装Ubuntu16.04.7</h2><p>因为不服输，我又折腾回来了，既然是内核版本的问题，我就再试试在这个低版本系统上升级内核，这次安装时勾选了“为图形或无线硬件…安装第三方软件”，因为我突然意识到其他教程不让勾选都是台式机，而我是笔记本，我的个乖乖啊，感觉被坑了。</p><p>这次一步步操作，安装完系统就不再做任何设置，直接升级内核，访问<a href="https://kernel.ubuntu.com/~kernel-ppa/mainline/v5.2.16/" target="_blank" rel="noopener">内核软件网站</a>，下载下面4个包：</p><ul><li><a href="https://kernel.ubuntu.com/~kernel-ppa/mainline/v5.2.16/linux-headers-5.2.16-050216_5.2.16-050216.201909190832_all.deb" target="_blank" rel="noopener">linux-headers-5.2.16-050216_5.2.16-050216.201909190832_all.deb</a></li><li><a href="https://kernel.ubuntu.com/~kernel-ppa/mainline/v5.2.16/linux-headers-5.2.16-050216-generic_5.2.16-050216.201909190832_amd64.deb" target="_blank" rel="noopener">linux-headers-5.2.16-050216-generic_5.2.16-050216.201909190832_amd64.deb</a></li><li><a href="https://kernel.ubuntu.com/~kernel-ppa/mainline/v5.2.16/linux-image-unsigned-5.2.16-050216-generic_5.2.16-050216.201909190832_amd64.deb" target="_blank" rel="noopener">linux-image-unsigned-5.2.16-050216-generic_5.2.16-050216.201909190832_amd64.deb</a></li><li><a href="https://kernel.ubuntu.com/~kernel-ppa/mainline/v5.2.16/linux-modules-5.2.16-050216-generic_5.2.16-050216.201909190832_amd64.deb" target="_blank" rel="noopener">linux-modules-5.2.16-050216-generic_5.2.16-050216.201909190832_amd64.deb</a></li></ul><p>依次按照下面的命令安装，这次居然成功了</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo sudo dpkg -i linux-headers-5.2.16-050216_5.2.16-050216.201909190832_all.deb</span><br><span class="line">sudo sudo dpkg -i linux-headers-5.2.16-050216-generic_5.2.16-050216.201909190832_amd64.deb</span><br><span class="line">sudo sudo dpkg -i linux-modules-5.2.16-050216-generic_5.2.16-050216.201909190832_amd64.deb</span><br><span class="line">sudo sudo dpkg -i linux-image-unsigned-5.2.16-050216-generic_5.2.16-050216.201909190832_amd64.deb</span><br></pre></td></tr></table></figure><p>然后从<a href="http://ftp.sjtu.edu.cn/ubuntu/pool/main/l/linux-firmware/" target="_blank" rel="noopener">网站</a>下载linux固件版本</p><p><a href="http://ftp.sjtu.edu.cn/ubuntu/pool/main/l/linux-firmware/linux-firmware_1.190_all.deb" target="_blank" rel="noopener">linux-firmware_1.190_all.deb</a></p><p>使用如下命令安装成功</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo sudo dpkg -i linux-firmware_1.190_all.deb</span><br></pre></td></tr></table></figure><p>reboot重启系统，WIFI的小雨伞终于出现了，功夫不负有心人，彻底搞定了，至于WIFI可用却连不上公司的无线网，那就是另一个悲伤的故事了，和技术无关，就不在此展开了。</p><h2 id="踩过的其他坑"><a href="#踩过的其他坑" class="headerlink" title="踩过的其他坑"></a>踩过的其他坑</h2><p>其实整个过程远不止上面提到的这些，安装了10几次系统，至少翻了几百个页面，有一些处理方式尝试过但没有什么效果，也列举在这里，留个纪念</p><ul><li><a href="https://blog.csdn.net/qq_45252077/article/details/106541604" target="_blank" rel="noopener">Ubuntu16.04无附加驱动无法连接WiFi总结</a></li><li><a href="https://blog.csdn.net/vesper305/article/details/9324567" target="_blank" rel="noopener">Ubuntu-server 10.04.4查看无线网卡型号</a></li><li><a href="https://blog.csdn.net/weixin_42101286/article/details/89239105" target="_blank" rel="noopener">Ubuntu安装后未发现wifi适配器解决</a></li><li><a href="https://blog.csdn.net/weixin_40955254/article/details/87992051" target="_blank" rel="noopener">ubuntu16.04+intel无线网卡无法连接WiFi解决方法，下载驱动，升级内核（亲测有效）</a></li><li><a href="https://www.cnblogs.com/superxuezhazha/p/11989882.html" target="_blank" rel="noopener">ubuntu18.04 无法连接有线</a></li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>现在安装Ubuntu特别溜，刻录U盘启动盘+安装完系统也就10分钟</li><li>手机通过USB连接笔记本可以直接给笔记本提供网络，这波操作有点优秀</li><li>认识了一堆之前没用过的命令，特别是 <code>lspci</code> 显示设备信息和 <code>iwconfig</code> 管理无线网络</li><li>出现问题时还是要找到根本原因，不能病急乱投医，一些博通网卡的处理方式用到Intel上显然不合适</li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/112419216" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>当个人实力撑不起自己的野心时，需埋下头来刻苦修炼，当目前的能力无法满足自己的欲望时，需抑制一些不切实际的想法，但愿多年之后回想这些隐忍的瞬间能内心充满感恩而不是悔恨~</p><p>2021-1-16 22:48:02</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;一台新申请的ThinkPad-X390笔记本需要安装Ubuntu系统，为了统一工作开发环境，选择了大家一直都在使用Ubuntu16.04版本，虽然这个系统版本旧一点，不过同一个版本出现开发环境问题也好排查，但没想到的是这里埋下了一个坑，导致成功安装系统后却不能上网，足足折腾了一整天才搞定，记录一下，没事回来看看还能乐呵乐呵。&lt;/p&gt;
    
    </summary>
    
      <category term="linux" scheme="http://AlbertGithubHome.github.io/blog/categories/linux/"/>
    
    
      <category term="linux" scheme="http://AlbertGithubHome.github.io/blog/tags/linux/"/>
    
      <category term="ubuntu" scheme="http://AlbertGithubHome.github.io/blog/tags/ubuntu/"/>
    
      <category term="系统" scheme="http://AlbertGithubHome.github.io/blog/tags/%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="WIFI" scheme="http://AlbertGithubHome.github.io/blog/tags/WIFI/"/>
    
  </entry>
  
  <entry>
    <title>搬迁声明</title>
    <link href="http://AlbertGithubHome.github.io/blog/2021/01/12/%E6%90%AC%E8%BF%81%E5%A3%B0%E6%98%8E/"/>
    <id>http://AlbertGithubHome.github.io/blog/2021/01/12/搬迁声明/</id>
    <published>2021-01-12T14:52:21.000Z</published>
    <updated>2021-01-12T14:54:27.541Z</updated>
    
    <content type="html"><![CDATA[<p>我的博客即将同步至 OSCHINA 社区，这是我的 OSCHINA ID：osc_57262839，邀请大家一同入驻：<a href="https://www.oschina.net/sharing-plan/apply" target="_blank" rel="noopener">https://www.oschina.net/sharing-plan/apply</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我的博客即将同步至 OSCHINA 社区，这是我的 OSCHINA ID：osc_57262839，邀请大家一同入驻：&lt;a href=&quot;https://www.oschina.net/sharing-plan/apply&quot; target=&quot;_blank&quot; rel=&quot;noop
      
    
    </summary>
    
      <category term="Thinking" scheme="http://AlbertGithubHome.github.io/blog/categories/Thinking/"/>
    
    
      <category term="工作" scheme="http://AlbertGithubHome.github.io/blog/tags/%E5%B7%A5%E4%BD%9C/"/>
    
      <category term="学习" scheme="http://AlbertGithubHome.github.io/blog/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>在比较Linux和Windows命令差异时意外发现了Windows Terminal</title>
    <link href="http://AlbertGithubHome.github.io/blog/2021/01/05/%E5%9C%A8%E6%AF%94%E8%BE%83Linux%E5%92%8CWindows%E5%91%BD%E4%BB%A4%E5%B7%AE%E5%BC%82%E6%97%B6%E6%84%8F%E5%A4%96%E5%8F%91%E7%8E%B0%E4%BA%86Windows-Terminal/"/>
    <id>http://AlbertGithubHome.github.io/blog/2021/01/05/在比较Linux和Windows命令差异时意外发现了Windows-Terminal/</id>
    <published>2021-01-05T15:48:57.000Z</published>
    <updated>2021-01-27T15:18:11.653Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>目前工作时的开发环境是 <code>Windows</code> + <code>Linux</code>，常常需要切换测试环境，比如写一个脚本既要在 Windows 使用，同时也要在 Linux 下运行，命令的使用是 Linux 的强项，它自带了很多方便的命令程序，比如过滤字符串的 <code>grep</code>，统计文件行数的 <code>wc</code>，查看目录文件的 <code>ls</code> 等等，如果要在 Windows 中运行相同逻辑的脚本，那我们需要先找到这些命令在 Windows 上的等价写法。</p><a id="more"></a><h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><p>下面列举几个常见的命令，功能上基本等价，如果有更好的写法也欢迎小伙伴们留言补充呀，有些命令在命令框里执行感觉没有作用，但是放到脚本中就很方便了，比如下面第一个：</p><h2 id="显示当前目录"><a href="#显示当前目录" class="headerlink" title="显示当前目录"></a>显示当前目录</h2><ul><li>linux 中的 <code>pwd</code></li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:/mnt/d/app/ScreenToGif/Logs$ <span class="built_in">pwd</span></span><br><span class="line">/mnt/d/app/ScreenToGif/Logs</span><br></pre></td></tr></table></figure><ul><li>windows 中 <code>cd</code></li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">D:\app\ScreenToGif\Logs&gt;<span class="built_in">cd</span></span><br><span class="line">D:\app\ScreenToGif\Logs</span><br></pre></td></tr></table></figure><p>这个显示当前目录的命令在这来看确实没什么用，因为在命令提示框里已经显示的当前所在的目录，但是用到脚本中时就可以发挥作用了，windows 中的 <code>cd</code> 命令不仅可以切换目录，当命令后面不接任何参数时就可以显示当前所在的目录位置。</p><h2 id="显示目录下内容"><a href="#显示目录下内容" class="headerlink" title="显示目录下内容"></a>显示目录下内容</h2><ul><li>linux 中的 <code>ls</code></li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:/mnt/d/app/ScreenToGif/Logs$ ls</span><br><span class="line">20_04_06 11_09_57_942.txt  20_04_06 11_09_58_049.txt  20_04_06.txt</span><br></pre></td></tr></table></figure><ul><li>windows 中 <code>dir</code></li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">D:\app\ScreenToGif\Logs&gt;dir</span><br><span class="line"> 驱动器 D 中的卷没有标签。</span><br><span class="line"> 卷的序列号是 0E68-747E</span><br><span class="line"></span><br><span class="line"> D:\app\ScreenToGif\Logs 的目录</span><br><span class="line"></span><br><span class="line">2020/04/06  23:09    &lt;DIR&gt;          .</span><br><span class="line">2020/04/06  23:09    &lt;DIR&gt;          ..</span><br><span class="line">2020/04/06  23:09               507 20_04_06 11_09_57_942.txt</span><br><span class="line">2020/04/06  23:09               518 20_04_06 11_09_58_049.txt</span><br><span class="line">2020/04/06  23:10             2,754 20_04_06.txt</span><br><span class="line">               3 个文件          3,779 字节</span><br><span class="line">               2 个目录 56,929,013,760 可用字节</span><br></pre></td></tr></table></figure><p>这两个命令都可以显示当前目录下的内容，但是windows下的 <code>dir</code> 更详细一些，当然，linux 下的 <code>ls</code> 命令也可以附加一些参数来达到显示详细信息的目的。</p><h2 id="过滤文本"><a href="#过滤文本" class="headerlink" title="过滤文本"></a>过滤文本</h2><ul><li>linux 中的 <code>grep</code></li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:/mnt/d/app/ScreenToGif/Logs$ ls -l | grep 09_</span><br><span class="line">-rwxrwxrwx 1 albert albert  507 Apr  6  2020 20_04_06 11_09_57_942.txt</span><br><span class="line">-rwxrwxrwx 1 albert albert  518 Apr  6  2020 20_04_06 11_09_58_049.txt</span><br></pre></td></tr></table></figure><ul><li>windows 中 <code>findstr</code></li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">D:\app\ScreenToGif\Logs&gt;dir | findstr 09_</span><br><span class="line">2020/04/06  23:09               507 20_04_06 11_09_57_942.txt</span><br><span class="line">2020/04/06  23:09               518 20_04_06 11_09_58_049.txt</span><br></pre></td></tr></table></figure><p>这两个命令基本上是一样的，都是按行过滤文本，当不加参数时效果基本一致</p><h2 id="查看文件内容"><a href="#查看文件内容" class="headerlink" title="查看文件内容"></a>查看文件内容</h2><ul><li>linux 中的 <code>cat</code></li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:/mnt/d/app/ScreenToGif/Logs$ cat <span class="string">"20_04_06 11_09_57_942.txt"</span></span><br><span class="line">► Title -</span><br><span class="line">        Automatic feedback</span><br><span class="line">▬ Message -</span><br><span class="line">        Value cannot be null.</span><br><span class="line">Parameter name: path1</span><br><span class="line">○ Type -</span><br><span class="line">        System.ArgumentNullException</span><br><span class="line">♦ [Version] Date/Hour -</span><br><span class="line">        [2.14.1] 04/06/2020 23:09:57</span><br><span class="line">▲ Source -</span><br><span class="line">        mscorlib</span><br><span class="line">▼ TargetSite -</span><br><span class="line">        System.String Combine(System.String, System.String, System.String)</span><br><span class="line">♠ StackTrace -</span><br><span class="line">   at System.IO.Path.Combine(String path1, String path2, String path3)</span><br><span class="line">   at ScreenToGif.Model.ApplicationViewModel.SendFeedback()</span><br><span class="line"></span><br><span class="line">----------------------------------</span><br></pre></td></tr></table></figure><ul><li>windows 中 <code>type</code></li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">D:\app\ScreenToGif\Logs&gt;<span class="built_in">type</span> <span class="string">"20_04_06 11_09_57_942.txt"</span></span><br><span class="line">► Title -</span><br><span class="line">        Automatic feedback</span><br><span class="line">▬ Message -</span><br><span class="line">        Value cannot be null.</span><br><span class="line">Parameter name: path1</span><br><span class="line">○ Type -</span><br><span class="line">        System.ArgumentNullException</span><br><span class="line">♦ [Version] Date/Hour -</span><br><span class="line">        [2.14.1] 04/06/2020 23:09:57</span><br><span class="line">▲ Source -</span><br><span class="line">        mscorlib</span><br><span class="line">▼ TargetSite -</span><br><span class="line">        System.String Combine(System.String, System.String, System.String)</span><br><span class="line">♠ StackTrace -</span><br><span class="line">   at System.IO.Path.Combine(String path1, String path2, String path3)</span><br><span class="line">   at ScreenToGif.Model.ApplicationViewModel.SendFeedback()</span><br><span class="line"></span><br><span class="line">----------------------------------</span><br></pre></td></tr></table></figure><h2 id="统计文件行数"><a href="#统计文件行数" class="headerlink" title="统计文件行数"></a>统计文件行数</h2><ul><li>linux 中的 <code>wc -l</code></li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:/mnt/d/app/ScreenToGif/Logs$ cat <span class="string">"20_04_06 11_09_57_942.txt"</span> | wc -l</span><br><span class="line">19</span><br></pre></td></tr></table></figure><ul><li>windows 中 <code>find /c /v &quot;&quot;</code></li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">D:\app\ScreenToGif\Logs&gt;<span class="built_in">type</span> <span class="string">"20_04_06 11_09_57_942.txt"</span> | find /c /v <span class="string">""</span></span><br><span class="line">19</span><br></pre></td></tr></table></figure><p><code>wc</code> 这个命令没什么好说的，专门为统计字符数、字节数、行数而生的，而 windows 下的 <code>find</code> 命令通过 <code>/c</code> 显示匹配函数，<code>/v &quot;&quot;</code> 查找非空行这样的参数组合也能达到统计行数的目的。</p><h2 id="计算文件摘要"><a href="#计算文件摘要" class="headerlink" title="计算文件摘要"></a>计算文件摘要</h2><ul><li>linux 中的 <code>[md5sum|sha1sum|sha256] 文件名</code></li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:/mnt/d/data/cpp$ md5sum simple.cpp</span><br><span class="line">a00eba0276e396de58fabc92b325672a  simple.cpp</span><br><span class="line">albert@home-pc:/mnt/d/data/cpp$ sha1sum simple.cpp</span><br><span class="line">7acf1e59ca2608b7591ec526d48ce041cddf49d2  simple.cpp</span><br><span class="line">albert@home-pc:/mnt/d/data/cpp$ sha256sum simple.cpp</span><br><span class="line">f07bcd585fa7e49897676105797dd984c12f63411f0ba8db62a57f6ef03bbaec  simple.cpp</span><br><span class="line">albert@home-pc:/mnt/d/data/cpp$</span><br></pre></td></tr></table></figure><ul><li>windows 中 <code>certutil -hashfile 文件名 [MD5|SHA1|SHA256]</code></li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">d:\data\cpp&gt;certutil -hashfile simple.cpp MD5</span><br><span class="line">MD5 的 simple.cpp 哈希:</span><br><span class="line">a00eba0276e396de58fabc92b325672a</span><br><span class="line">CertUtil: -hashfile 命令成功完成。</span><br><span class="line"></span><br><span class="line">d:\data\cpp&gt;certutil -hashfile simple.cpp SHA1</span><br><span class="line">SHA1 的 simple.cpp 哈希:</span><br><span class="line">7acf1e59ca2608b7591ec526d48ce041cddf49d2</span><br><span class="line">CertUtil: -hashfile 命令成功完成。</span><br><span class="line"></span><br><span class="line">d:\data\cpp&gt;certutil -hashfile simple.cpp SHA256</span><br><span class="line">SHA256 的 simple.cpp 哈希:</span><br><span class="line">f07bcd585fa7e49897676105797dd984c12f63411f0ba8db62a57f6ef03bbaec</span><br><span class="line">CertUtil: -hashfile 命令成功完成。</span><br></pre></td></tr></table></figure><p>在 linux 上不同的摘要算法对应着不同的程序，但是在 windows 上是同一个程序有着不同的参数。</p><h2 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h2><table><thead><tr><th style="text-align:left">功能</th><th style="text-align:center">linux命令</th><th style="text-align:center">windows命令</th></tr></thead><tbody><tr><td style="text-align:left">拷贝</td><td style="text-align:center"><code>cp</code></td><td style="text-align:center"><code>copy</code>/<code>xcopy</code></td></tr><tr><td style="text-align:left">移动</td><td style="text-align:center"><code>mv</code></td><td style="text-align:center"><code>move</code>/<code>rename</code></td></tr><tr><td style="text-align:left">删除</td><td style="text-align:center"><code>rm</code></td><td style="text-align:center"><code>del</code>/<code>rd</code></td></tr><tr><td style="text-align:left">创建目录</td><td style="text-align:center"><code>mkdir</code></td><td style="text-align:center"><code>md</code>/<code>mkdir</code></td></tr></tbody></table><p>先整理这么多，后续用到新的等价命令再补充吧！</p><h1 id="半路杀出个PowerShell"><a href="#半路杀出个PowerShell" class="headerlink" title="半路杀出个PowerShell"></a>半路杀出个PowerShell</h1><p>一开始接触 PowerShell 把它认为是 cmd 的升级版，感觉就是原来的 cmd 太寒酸了，然后又搞出个 PowerShell 稍微好看了一点，功能又增加了一些而已，但是随着使用次数的增多，我发现之前的理解不太对，PowerShell 和 cmd 它俩完全没关系啊，唯一的相同点就是都被叫做命令行而已。</p><p>PowerShell 通常被描述成是面向对象的脚本语言，并且是在 .Net公共语言运行时(CLR-Common Language Runtime)和.Net Framework的基础上构建的，可以接受和返回.Net对象，引入了cmdlet的概念，是cmd的超集。</p><p>看到一些说法提到“cmd命令都可以在Powershell中执行”，但事实并非如此，比如我最近发现在cmd运行的 <code>type a.txt | find /c /v &quot;&quot;</code> 统计行数的命令在 PowerShell 中就不管用了，所以我认为把 PowerShell 作为 cmd 的升级不太准确。</p><p>PowerShell完全是一个新发明的东西，它里面有一些原来cmd中常用的命令，比如 <code>cd</code>、<code>dir</code>，同时它还兼容了一些 Linux 上的常用命令，比如 <code>ls</code>、<code>man</code> 等，关于这些可以简单看几个例子。</p><h2 id="显示目录下内容-1"><a href="#显示目录下内容-1" class="headerlink" title="显示目录下内容"></a>显示目录下内容</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc D:\app\ScreenToGif\Logs&gt; ls</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    目录: D:\app\ScreenToGif\Logs</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Mode                LastWriteTime         Length Name</span><br><span class="line">----                -------------         ------ ----</span><br><span class="line">-a----         2020/4/6     23:09            507 20_04_06 11_09_57_942.txt</span><br><span class="line">-a----         2020/4/6     23:09            518 20_04_06 11_09_58_049.txt</span><br><span class="line">-a----         2020/4/6     23:10           2754 20_04_06.txt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">albert@home-pc D:\app\ScreenToGif\Logs&gt; dir</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    目录: D:\app\ScreenToGif\Logs</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Mode                LastWriteTime         Length Name</span><br><span class="line">----                -------------         ------ ----</span><br><span class="line">-a----         2020/4/6     23:09            507 20_04_06 11_09_57_942.txt</span><br><span class="line">-a----         2020/4/6     23:09            518 20_04_06 11_09_58_049.txt</span><br><span class="line">-a----         2020/4/6     23:10           2754 20_04_06.txt</span><br></pre></td></tr></table></figure><p>我们可以看到这两个命令在 PowerShell 中执行之后结构完全一样，然后我们使用 <code>man</code> 命令来查看一下两个命令的帮助文档</p><h2 id="查看帮助文档"><a href="#查看帮助文档" class="headerlink" title="查看帮助文档"></a>查看帮助文档</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc D:\app\ScreenToGif\Logs&gt; man dir</span><br><span class="line"></span><br><span class="line">名称</span><br><span class="line">    Get-ChildItem</span><br><span class="line"></span><br><span class="line">语法</span><br><span class="line">    Get-ChildItem [[-Path] &lt;string[]&gt;] [[-Filter] &lt;string&gt;]  [&lt;CommonParameters&gt;]</span><br><span class="line"></span><br><span class="line">    Get-ChildItem [[-Filter] &lt;string&gt;]  [&lt;CommonParameters&gt;]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">别名</span><br><span class="line">    gci</span><br><span class="line">    ls</span><br><span class="line">    dir</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">备注</span><br><span class="line">    Get-Help 在此计算机上找不到该 cmdlet 的帮助文件。它仅显示部分帮助。</span><br><span class="line">        -- 若要下载并安装包含此 cmdlet 的模块的帮助文件，请使用 Update-Help。</span><br><span class="line">        -- 若要联机查看此 cmdlet 的帮助主题，请键入: <span class="string">"Get-Help Get-ChildItem -Online"</span> 或</span><br><span class="line">           转到 https://go.microsoft.com/fwlink/?LinkID=113308。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">albert@home-pc D:\app\ScreenToGif\Logs&gt; man ls</span><br><span class="line"></span><br><span class="line">名称</span><br><span class="line">    Get-ChildItem</span><br><span class="line"></span><br><span class="line">语法</span><br><span class="line">    Get-ChildItem [[-Path] &lt;string[]&gt;] [[-Filter] &lt;string&gt;]  [&lt;CommonParameters&gt;]</span><br><span class="line"></span><br><span class="line">    Get-ChildItem [[-Filter] &lt;string&gt;]  [&lt;CommonParameters&gt;]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">别名</span><br><span class="line">    gci</span><br><span class="line">    ls</span><br><span class="line">    dir</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">备注</span><br><span class="line">    Get-Help 在此计算机上找不到该 cmdlet 的帮助文件。它仅显示部分帮助。</span><br><span class="line">        -- 若要下载并安装包含此 cmdlet 的模块的帮助文件，请使用 Update-Help。</span><br><span class="line">        -- 若要联机查看此 cmdlet 的帮助主题，请键入: <span class="string">"Get-Help Get-ChildItem -Online"</span> 或</span><br><span class="line">           转到 https://go.microsoft.com/fwlink/?LinkID=113308。</span><br></pre></td></tr></table></figure><p>结果还是完全一样，原来在PowerShell中，<code>ls</code> 和 <code>dir</code> 都是命令 <code>Get-ChildItem</code> 的别名，这时我才发现，原来PowerShell自己的命令其实都是这种动宾短语的形式，原来 cmd 中的命令和一些扩展的 Linux 命令大多是以别名的形式存在的。</p><p>所以从这里来看，PowerShell是一款新产品，并不是cmd的简单升级，只是这个新的产物将原来大部分的cmd命令以别名的方式进行了兼容处理而已</p><h1 id="统一命令行的渴望"><a href="#统一命令行的渴望" class="headerlink" title="统一命令行的渴望"></a>统一命令行的渴望</h1><p>上面提到了 cmd、PowerShell、linux Shell 等等，每天使用这些工具时都要开很多窗口，比较麻烦，有没什么途径把它们统一一下呢？这里的统一只是想使用的更方便而已，语法上暂时没办法统一了，偶然间发现了 <code>Windows Terminal</code> 这个工具，一下子打开了新的世界。</p><h1 id="Windows-Terminal"><a href="#Windows-Terminal" class="headerlink" title="Windows Terminal"></a>Windows Terminal</h1><p>Windows Terminal 是一个全新的、功能强大的命令行终端工具。包含多 Tab 支持、富文本、多语言支持、可配置、主题和样式等诸多特性，并且属于微软的亲儿子，支持的力度你懂得。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>直接在 Windows 上打开应用商店安装即可，这时我第二次打开应用商店了，上一次是安装 WSL 的时候。</p><p><img src="https://cdn.jsdelivr.net/gh/albertgithubhome/cdn/img/tools/wt.png" alt="wt"></p><p>官方提供的截图也很炫酷：</p><p><img src="https://cdn.jsdelivr.net/gh/albertgithubhome/cdn/img/tools/wt2.png" alt="wt2"></p><p>我自己也尝试着美化了一下，效果还不错</p><p><img src="https://cdn.jsdelivr.net/gh/albertgithubhome/cdn/img/tools/powershell.png" alt="powershell"></p><h2 id="命令行窗口的统一"><a href="#命令行窗口的统一" class="headerlink" title="命令行窗口的统一"></a>命令行窗口的统一</h2><p>确实不想开很多个命令窗口，比如执行windows脚本命令的cmd、PowerShell，版本管理工具git bash，windows子系统WSL命令行，远程服务器命令行工具XShell等，要是把它们都放在一起就好了，使用Windows Terminal可以轻松实现这个愿望，其中cmd、PowerShell、WSL命令行都是Windows Terminal自带的，git bash 要想显示在 Windows Terminal 中需要手动配置下，运行效果如下：</p><p><img src="https://cdn.jsdelivr.net/gh/albertgithubhome/cdn/img/tools/multiwindow.png" alt="multiwindow"></p><p>配置和美化方法比较简单，网上搜索会有很多教程可以学习</p><h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><p>目前使用 Windows Terminal 替代各种命令行工具只遇到了一个问题，就是它不知道 Zmodem 协议，所以无法使用 <code>sz</code>、<code>rz</code>，对于我这种需要经常上传脚本文件到服务器的人来说不太方便。</p><p>好消息是在2019年的时候已经有人在 Windows Terminal 的 github 项目中提了<a href="https://github.com/microsoft/terminal/issues/1999" target="_blank" rel="noopener">issue</a>，据说会考虑这个功能，但是还得评估下，但是目前已经1年多过去了还没有反馈，焦急等待中，有了它就可以不使用XShell了。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li><code>cmd</code> 和 <code>PowerShell</code> 是两个不相同的命令行程序，有些cmd命令无法直接在PowerShell中运行</li><li><code>cmd</code> 能做的 <code>PowerShell</code> 几乎都能做，但是不能直接拿过来就运行，有时需要简单的改写才可以</li><li><code>PowerShell</code> 的命令采用动宾的格式，并且使用别名的形式兼容 <code>cmd</code> 命令和一些 Linux 命令</li><li><code>Windows Terminal</code> 目前来看很优秀，可以将cmd、PowerShell、WSL Shell等运行在同一个窗口中</li><li>由于 <code>Windows Terminal</code> 不支持 Zmodem 协议，所以暂时还不能使用 <code>sz</code>、<code>rz</code> 命令来传送文件</li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/112057093" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>不过是大梦一场空，不过是孤影照惊鸿，不过是白驹之过一场梦，梦里有一些相逢……歌词写的真好！</p><p>2021-1-10 00:33:11</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;目前工作时的开发环境是 &lt;code&gt;Windows&lt;/code&gt; + &lt;code&gt;Linux&lt;/code&gt;，常常需要切换测试环境，比如写一个脚本既要在 Windows 使用，同时也要在 Linux 下运行，命令的使用是 Linux 的强项，它自带了很多方便的命令程序，比如过滤字符串的 &lt;code&gt;grep&lt;/code&gt;，统计文件行数的 &lt;code&gt;wc&lt;/code&gt;，查看目录文件的 &lt;code&gt;ls&lt;/code&gt; 等等，如果要在 Windows 中运行相同逻辑的脚本，那我们需要先找到这些命令在 Windows 上的等价写法。&lt;/p&gt;
    
    </summary>
    
      <category term="windows" scheme="http://AlbertGithubHome.github.io/blog/categories/windows/"/>
    
    
      <category term="linux" scheme="http://AlbertGithubHome.github.io/blog/tags/linux/"/>
    
      <category term="windows" scheme="http://AlbertGithubHome.github.io/blog/tags/windows/"/>
    
      <category term="ternimal" scheme="http://AlbertGithubHome.github.io/blog/tags/ternimal/"/>
    
      <category term="powershell" scheme="http://AlbertGithubHome.github.io/blog/tags/powershell/"/>
    
  </entry>
  
  <entry>
    <title>2020年终总结！新的起航，新的征程</title>
    <link href="http://AlbertGithubHome.github.io/blog/2020/12/27/2020%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93%EF%BC%81%E6%96%B0%E7%9A%84%E8%B5%B7%E8%88%AA%EF%BC%8C%E6%96%B0%E7%9A%84%E5%BE%81%E7%A8%8B/"/>
    <id>http://AlbertGithubHome.github.io/blog/2020/12/27/2020年终总结！新的起航，新的征程/</id>
    <published>2020-12-27T12:25:12.000Z</published>
    <updated>2020-12-31T14:57:04.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>奇变偶不变，符号看象限，真正的知识就是这么朴实无华~</p></blockquote><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>从2019年开始意识到年终总结的意义，通过反思自己的得失进而确定今后的方向，既然去年开了头，今年也不能中断，依旧写写每天的流水账，细数最近一年发生的故事。</p><a id="more"></a><p>今年最直观的、印象最深的感受就是时间不够用，一首《时间都去哪了》旋律时常出现在脑海中，对比之前长久不变的工作环境，今年确实紧张了许多，习惯了原来的安逸，对各种可能发生的问题轻车熟路的就能解决掉，但来到新环境，一切变得不是那么轻松了。</p><h1 id="回顾2020"><a href="#回顾2020" class="headerlink" title="回顾2020"></a>回顾2020</h1><p>毕竟到了年终时刻，之前的flag可不能忘，依旧是从工作、学习、生活三个方面来回忆一下去年flag的完成情况。</p><h2 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h2><blockquote><p>2020 flag：新的一年不能再碌碌无为，真的需要去闯一闯了</p><p>完成度：95%</p></blockquote><p>年初如愿的换了一份新工作，之前的公司呆的时间太长了，工作内容单一，熟悉了安逸的环境，虽然每天也在学习，但是进步缓慢，在2019年末开始寻找新的发展环境，在2020初就成功找到了新的工作机会，提前完成flag内容。</p><p>与老东家分手过程可以说不太愉快，给不了梦想，撑不起现实，一味的拖着可不是解决问题的办法，不过事情已经过去，不想再提，毕竟也为之奋斗过，近2000个日日夜夜，梦开始的地方，也是认清现实的地方。</p><p>离开原公司来到新公司算是无缝衔接吧，中间在家只待了3天，如果能早点意识到离职流程这么狗血，我真应该在家躺一个月，不过新公司的入职流程还真是暖心，提前先网上入职，帮我把社保问题解决了，感谢流程中出现的每一个人。</p><p>新的工作内容刚开始肯定要吃力一些，首先是熟悉开发环境，大体和原来相同，不过复杂的申请制度较原来规范了许多，同时也麻烦了许多，版本控制是一个重要的改变，之前主要使用SVN，如今换成了 Git + SVN，以前经常使用的 git 三部曲——add、commit、push 已经不够用了，随着不断的使用学习，渐渐熟悉了 <code>checkout</code>、<code>merge</code>、<code>rebase</code>、<code>cherry-pick</code> <code>reset</code> 等等子命令，还是那句话多用才能学会，如果只停留在纸面上，只是眼睛学会了，闭上眼睛就忘记了。</p><p>选择这份新的工作也是想拓宽自己的知识面，之前一直在做分区分服的游戏，想学习一下分布式游戏的开发和一些需要需要注意的问题，所以说这份工作是用来补充我这方面知识短板的，从学习了一年的结果来看，确实达到了这个目的，虽然现在的规模还没有那么大，有些逻辑来不太完善，但是这已经给我做出了示范，在今后的一段时间内，将沿着这条路不断的前行，去探索自己未知的领域。</p><p>新的工作认识新的伙伴，大家相处起来还是很友好的，一年来的工作算是中规中矩，不过年底这俩月有点滑铁卢的味道，接连在同一个位置摔倒几次，还是老大给背了锅，内心愧疚不已，无以为报，愿以更饱满的热情投入工作中，实践当初并肩战斗的诺言，得一伙伴不易，愿共同进步。</p><p>今年的工作强度明显高于以往，倒不是工作时间长了，而是在新环境中，长时间聚精会神的盯在一件事上本来就很累，头发掉的明显比之前多了，眼睛的视力也下降的厉害，这两点要注意一下了，可以调整一下工作的节奏，注意劳逸结合，我可不想“聪明绝顶”。</p><div align="center"><br><img src="https://cdn.jsdelivr.net/gh/albertgithubhome/cdn/img/summary/2020/pressure.png" alt="pressure"><br></div><h2 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h2><blockquote><p>2020 flag：看两本有关分布式知识的图书，多看一些开源项目的代码</p><p>完成度：85%</p></blockquote><p>有关分布式架构的书今年只看了一本，另外基本都是和育儿知识相关，他们分别是：</p><ul><li>从零开始学架构 ——照着做，你也能称为架构师</li><li>你就是孩子最好的玩具</li><li>正面管教</li><li>小狗钱钱2</li></ul><p>今年的1本技术书籍对比去年的7本少了很多，一方面换了新工作后需要花很多时间来熟悉新的业务逻辑，用来读书的时间被侵占了一部分，另一方面宝宝一天天长大，需要花些时间去陪伴她，虽然技术书读的少了，可是故事书我可没少读，一年读了好几十本：</p><div align="center"><br><img src="https://cdn.jsdelivr.net/gh/albertgithubhome/cdn/img/summary/2020/story.jpg" alt="story"><br></div><p>这些故事书中描述的故事小时候没觉得有什么不妥，不过以现在成年人的身份来看，有些故事太离奇了，比如大灰狼和七只小羊的故事，山羊妈妈居然剪开狼的肚皮救出了被吃掉的六只小山羊，然后在狼的肚子里装满石头缝上了，整个过程大灰狼都没有醒，我感觉山羊妈妈可能是个麻醉科的护士。</p><p>虽然故事内容离奇，但是并不妨碍小娃娃听到津津有味，小孩子的世界还真是单纯，有故事听就老老实实的等着，而我化身为一个播报员，一遍一遍的重复着书中的故事。</p><p>博客总结今年也没有丢，一共写了45篇，比去年还要多几篇，总体来看类别很多，总结的内容并不难懂，写到博客中主要是为了方便日后的查找，这一年的总结绝大部分都是晚上和周末花时间写的，只有尝试过才明白，想写好一篇总结需要花费很多很多时间，今年的成长可以对比两年数据来看一下。</p><div align="center"><br><img src="https://cdn.jsdelivr.net/gh/albertgithubhome/cdn/img/20191231csdn.png" alt="20191231csdn"><br></div><br><div align="center"><br><img src="https://cdn.jsdelivr.net/gh/albertgithubhome/cdn/img/summary/2020/csdn.png" alt="csdn"><br></div><p>C++11的使用在这一年里变得更加熟练，之前的项目中无法使用C++11的特性，所以很多知识都是自己额外花时间来测试学习，来到新项目可以参考已有的代码，进一步巩固C++11的使用，知识还是越用掌握的越好。</p><p>语言方面还有Python今年用的比较多，得益于工作中的多次锻炼，一些常用的函数，类型可以很熟练的写出来了，虽然没有用来写过什么大的软件，但是也在不断尝试着使代码更规范，比如使用class、装饰器、继承、记录运行日志等等。</p><p>Go语言今年算是简单入门吧，之前只能算是听说过，今年快速的浏览了一遍Go语言的语法，编写了一些测试程序，但是对于Go语言的条条框框还是不太习惯，需要慢慢适应下。</p><p>刷题今年一直在坚持着，之前使用的国际账号一时找不到了，今年新注册了国内版LeetCode账号，本着刷简单冲中等的态度，一直在默默的洗刷刷，不过今年参加了几次竞赛，一直是两题选手，只有一次题比较简单全答出来了，当时还是很开心的，继续加油吧。</p><div align="center"><br><img src="https://cdn.jsdelivr.net/gh/albertgithubhome/cdn/img/summary/2020/leetcode.png" alt="leetcode"><br></div><p>阅读开源项目源码方面，今年也有了很大的进步，在新项目中接触了好几个之前没有使用过的开源库，虽然没有完全整明白，但最起码开阔了眼界，比如 <code>easyloging++</code>、<code>nolhmann json</code>库等等，另外今年还意外获得了 Github 的 <code>Arctic Code Vault Contributor</code> 勋章，看来我写的BUG要被雪藏千年了，哈哈。</p><h2 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h2><blockquote><p>2020 flag：尽最大可能陪陪家人、投资达到2019的水平</p><p>完成度：55%</p></blockquote><p>多陪陪家人这一项今年应该算完成了，因为疫情今年也没有出去疯，就是出门买买菜，其他的闲暇时间都和家人在一起，天气好的时候去附近的公园逛逛，对比2019年，每天晚上回家的时间晚了一点，但是多了每周多了一整天可以和家人一起度过。</p><p>现在每天还是很充实的，早上起来妈妈已经做好早饭，赶紧洗漱和家人一起吃个早饭，然后和宝宝告别去上班。晚上回来大多数情况宝宝已经睡了，不过有时候也能挺到我回家，和我玩一会再睡。周末陪宝宝出去玩，透透新鲜空气，等宝宝睡觉的时候对近期所学的知识做一个总结，基本上周末的时间陪娃、总结55开吧。</p><p>这个flag完成度不高主要是投资理财这块今天基本上是停滞了，未达到2019年水平，每天除了工作就是学习，账户情况没怎么看，整个一个过山车行情，所以基本上处于不赔不赚的情况。</p><p>节前的最后一天是大涨行情，算是一个好的结尾，全年放养的状态收益率3个多点，勉强跑赢余额宝的收益，估计跑不过今年的通货膨胀了！</p><div align="center"><br><img src="https://cdn.jsdelivr.net/gh/albertgithubhome/cdn/img/summary/2020/stock.jpg" alt="stock"><br></div><p>目前的生活状况就是每天都相似，但确实很满足，早上起床一家人吃早饭，和宝宝告别后送媳妇上班，然后自己骑个自行车来公司上班，努力完成一天的工作再骑个小车回家，如果宝宝没睡还可以陪她玩一会儿，等宝宝睡着开始一天的总结，温暖而又充实。</p><p>2020年初养了一年的栀子花开花了，正好在我过年回老家的时候开的花，之前我好好浇水通风的时候它却连个花骨朵都没有，好像再告诉我只要我不管它就能好好开花，可是在10月份的时候枯死了。还有一盆文竹在夏天涨势良好，修剪了几次，但没有熬过寒冷的冬天，在11月份左右干枯了。</p><p>在上两盆花相继离开之后，我赶紧又补充了新的生机，一盆栀子花和一盆茉莉花，目前长势良好，茉莉花已经开花了，希望它俩在新的一年里花香不断。</p><div align="center"><br><img src="https://cdn.jsdelivr.net/gh/albertgithubhome/cdn/img/summary/2020/flower.jpg" alt="flower"><br></div><h1 id="展望2021"><a href="#展望2021" class="headerlink" title="展望2021"></a>展望2021</h1><h2 id="工作-1"><a href="#工作-1" class="headerlink" title="工作"></a>工作</h2><ul><li>脚踏实地做好本职工作</li><li>额外挤出时间去尝试技术提升（优化、解决痛点）</li><li>在熟悉业务的同时更多参与设计的工作，拓宽自己的认知范围</li></ul><h2 id="学习-1"><a href="#学习-1" class="headerlink" title="学习"></a>学习</h2><ul><li>博客总结继续，基本保持在1周一篇，可以适当偷懒，一年懒10次可以产出40篇</li><li>开源代码还是要继续学习，libevent需要详细看一下，今年的出镜率太高</li><li>读2本技术类书籍，可以是开阔眼界的，也可以是现有技能提升的</li><li>读2本经济学、金融理财相关的书籍</li></ul><h2 id="生活-1"><a href="#生活-1" class="headerlink" title="生活"></a>生活</h2><ul><li>陪娃娃，陪家人，工作内容适应后可以多拿出一点时间和家人在一起（需要比2020多一些）</li><li>投资理财还是要多花一点时间研究下，目标7%（靠工资是不可能财富自由的，必须开源才行）</li><li>注重身体的保养，身体是本钱，可不能把身体搞垮了，愿丢掉体检时的小毛病~</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>2020年在工作上是一个新的开始，同时也面临着新的挑战</li><li>2020年的flag完成度大概70%，大部分愿望已经实现，未实现部分还需努力</li><li>2021年已经悄然开始，新的flag已经在路上，为了新的目标加油努力吧</li></ul><div align="center"><br><img src="https://cdn.jsdelivr.net/gh/albertgithubhome/cdn/img/summary/2020/fighting.gif" alt="fighting"><br></div><hr><center><a href="https://blog.csdn.net/albertsh/article/details/111148573" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>人生旅途中运气与实力都很重要，但是强大的实力可以帮助你提升运气，减少不确定性（记一次事故后提心吊胆的等待），比如买一注彩票中一千万很难，但是如果你的实力可以强大到买下大部分甚至是所有的组合，那么要中一千万只需要等到开奖就可以了~</p><p>凡是过去，皆为序幕</p><p>2020-12-27 00:32:07</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;奇变偶不变，符号看象限，真正的知识就是这么朴实无华~&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;从2019年开始意识到年终总结的意义，通过反思自己的得失进而确定今后的方向，既然去年开了头，今年也不能中断，依旧写写每天的流水账，细数最近一年发生的故事。&lt;/p&gt;
    
    </summary>
    
      <category term="Thinking" scheme="http://AlbertGithubHome.github.io/blog/categories/Thinking/"/>
    
    
      <category term="总结" scheme="http://AlbertGithubHome.github.io/blog/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="工作" scheme="http://AlbertGithubHome.github.io/blog/tags/%E5%B7%A5%E4%BD%9C/"/>
    
      <category term="学习" scheme="http://AlbertGithubHome.github.io/blog/tags/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="生活" scheme="http://AlbertGithubHome.github.io/blog/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>system_clock::now()和time()时间函数混用带来的踩坑经历</title>
    <link href="http://AlbertGithubHome.github.io/blog/2020/12/13/%E6%97%B6system-clock-now-%E5%92%8Ctime-%E6%97%B6%E9%97%B4%E5%87%BD%E6%95%B0%E6%B7%B7%E7%94%A8%E5%B8%A6%E6%9D%A5%E7%9A%84%E8%B8%A9%E5%9D%91%E7%BB%8F%E5%8E%86/"/>
    <id>http://AlbertGithubHome.github.io/blog/2020/12/13/时system-clock-now-和time-时间函数混用带来的踩坑经历/</id>
    <published>2020-12-13T15:16:17.000Z</published>
    <updated>2020-12-27T12:42:21.486Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>时间是一个可怕的东西，听说能用来杀猪。在编程世界中，时间也控制着一个维度，常常伴随着程序运行而流逝，有时也会影响着程序的运行的逻辑，所以在程序中处理时间时还是要仔细一些，最近连续踩坑，总结一下给自己提个醒，有些逻辑还是需要抱着怀疑的态度去看待。</p><a id="more"></a><h1 id="时间函数混用"><a href="#时间函数混用" class="headerlink" title="时间函数混用"></a>时间函数混用</h1><p>我们在写一个小程序时基本不会去混用时间函数，比如只用 <code>time(NULL)</code> 去控制时间，或者只使用 <code>chrono::system_clock::now()</code> 来记录时间消耗，关于 <code>chrono</code> 的用法，之前简单总结过，可传送至 <a href="https://blog.csdn.net/albertsh/article/details/105468687" target="_blank" rel="noopener">C++11中的时间库std::chrono</a>。</p><p>但是当程序变得复杂起来，这个时间函数混用的高压线还是有可能触碰到的，当程序逻辑对时间要求越发精确时，混用所带来的后果将越发严重。在此记录一个结果：连续调用 <code>time(NULL)</code> 和 <code>chrono::system_clock::now()</code> 两个函数得到的时间戳可能是不同的。</p><p>可能你会说，函数是先后调用的，肯定是不同的，后面的函数调用时的时间戳要比前面的大，但事实却是两个函数所取得的时间戳大小不确定，可能是第一个函数的时间戳比较大，也可能是第二个时间戳更大一些。</p><h1 id="测试的例子"><a href="#测试的例子" class="headerlink" title="测试的例子"></a>测试的例子</h1><p>下面展示一段代码，先后调用两个时间函数，打印所获得的时间戳，可以看看有什么特点：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int64_t</span> t1, t2;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        t1 = chrono::duration_cast&lt;chrono::milliseconds&gt;(chrono::system_clock::now().time_since_epoch()).count();</span><br><span class="line">        t2 = time(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (t1/<span class="number">1000</span> != t2) <span class="built_in">cout</span> &lt;&lt; t1 &lt;&lt; <span class="string">" "</span> &lt;&lt; t2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译运行结果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:testtime$ g++ testtime.cpp -std=c++11</span><br><span class="line">albert@home-pc:testtime$ ./a.out</span><br><span class="line">1607779917993 1607779918</span><br><span class="line">1607779957999 1607779958</span><br><span class="line">1607780080001 1607780079</span><br><span class="line">1607780103001 1607780102</span><br><span class="line">1607780150001 1607780149</span><br><span class="line">1607780202001 1607780201</span><br><span class="line">1607780327999 1607780328</span><br><span class="line">1607780440001 1607780439</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>运行之后很快就出现了一些不一致，对比可以发现，两个时间戳一个是毫秒，一个是秒，同时把单位转化成秒来比较时，两者大小不定，从仅有的这几行结果来看，最大的误差是7毫秒。</p><h1 id="再加一个时间函数"><a href="#再加一个时间函数" class="headerlink" title="再加一个时间函数"></a>再加一个时间函数</h1><p>除了上面提到的两个函数，还有一个 <code>gettimeofday()</code> 函数也是在获取时间时常常使用的，把它也放到测试函数中对比一下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int64_t</span> t1, t2, t = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>;</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        t1 = chrono::duration_cast&lt;chrono::milliseconds&gt;(chrono::system_clock::now().time_since_epoch()).count();</span><br><span class="line">        t2 = time(<span class="number">0</span>);</span><br><span class="line">        gettimeofday(&amp;tv, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (t1/<span class="number">1000</span> != t2 || t2 != tv.tv_sec)</span><br><span class="line">            <span class="keyword">if</span> (t != t1) <span class="built_in">cout</span> &lt;&lt; t1 &lt;&lt; <span class="string">" "</span> &lt;&lt; t2 &lt;&lt; <span class="string">" "</span> &lt;&lt; tv.tv_sec &lt;&lt; <span class="string">","</span> &lt;&lt; tv.tv_usec &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">        t = t1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行后查看结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">albert@DESKTOP-6746UC3:/mnt/d/data/cpp/testtime$ g++ testtime.cpp --std=c++11</span><br><span class="line">albert@DESKTOP-6746UC3:/mnt/d/data/cpp/testtime$ ./a.out</span><br><span class="line">1607876993000 1607876992 1607876993,2</span><br><span class="line">1607876994000 1607876993 1607876994,3</span><br><span class="line">1607876995000 1607876994 1607876995,3</span><br><span class="line">1607876996000 1607876995 1607876996,2</span><br><span class="line">1607876997000 1607876996 1607876997,1</span><br><span class="line">1607876998000 1607876997 1607876998,2</span><br><span class="line">1607876999000 1607876998 1607876999,2</span><br><span class="line">1607877000000 1607876999 1607877000,3</span><br><span class="line">1607877001000 1607877000 1607877001,1</span><br><span class="line">1607877002000 1607877001 1607877002,3</span><br><span class="line">1607877003000 1607877002 1607877003,2</span><br><span class="line">1607877004000 1607877003 1607877004,2</span><br><span class="line">1607877005000 1607877004 1607877005,1</span><br><span class="line">1607877006000 1607877005 1607877006,3</span><br><span class="line">1607877007000 1607877006 1607877007,2</span><br><span class="line">1607877008000 1607877007 1607877008,11</span><br><span class="line">1607877009000 1607877008 1607877009,3</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>真是各不相同，这要是在发射火箭时混用两个时间函数，那估计探月卫星就凉凉了……</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>常用来获取时间戳的函数有 <code>time()</code>、<code>chrono::system_clock::now()</code> 和 <code>gettimeofday()</code></li><li>时间函数不要混用，否则会给精密计算带来巨大的麻烦，造成计算结果的不可控</li><li>测试发现 <code>chrono::system_clock::now()</code> 和 <code>gettimeofday()</code> 时间非常接近，有微秒级别的误差，但也不建议混用</li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/109976348" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>有的人走了只留下一撮灰烬，有的人离开却千古留名，但在时间长河中就是那么一瞬，意义何在，有差吗？</p><p>2020-12-14 00:12:01</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;时间是一个可怕的东西，听说能用来杀猪。在编程世界中，时间也控制着一个维度，常常伴随着程序运行而流逝，有时也会影响着程序的运行的逻辑，所以在程序中处理时间时还是要仔细一些，最近连续踩坑，总结一下给自己提个醒，有些逻辑还是需要抱着怀疑的态度去看待。&lt;/p&gt;
    
    </summary>
    
    
      <category term="C++" scheme="http://AlbertGithubHome.github.io/blog/tags/C/"/>
    
      <category term="时间" scheme="http://AlbertGithubHome.github.io/blog/tags/%E6%97%B6%E9%97%B4/"/>
    
      <category term="time" scheme="http://AlbertGithubHome.github.io/blog/tags/time/"/>
    
      <category term="system_clock" scheme="http://AlbertGithubHome.github.io/blog/tags/system-clock/"/>
    
  </entry>
  
  <entry>
    <title>C/C++中有符号数隐式类型转换成无符号数需注意的问题</title>
    <link href="http://AlbertGithubHome.github.io/blog/2020/12/07/C-C-%E4%B8%AD%E6%9C%89%E7%AC%A6%E5%8F%B7%E6%95%B0%E9%9A%90%E5%BC%8F%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E6%88%90%E6%97%A0%E7%AC%A6%E5%8F%B7%E6%95%B0%E9%9C%80%E6%B3%A8%E6%84%8F%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://AlbertGithubHome.github.io/blog/2020/12/07/C-C-中有符号数隐式类型转换成无符号数需注意的问题/</id>
    <published>2020-12-07T15:11:16.000Z</published>
    <updated>2020-12-27T12:40:29.832Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>隐式类型转换转换是一个挺基础的概念，即使对于初学者来说都不会陌生，一般情况下是指数据类型的转换是由编译系统自动进行的，不需要人工干预的类型转换方式。与之相对的是强制类型转换，在进行转换时必须使用强制类型转换运算符进行转换，这种也被称为显式转换。</p><a id="more"></a><h1 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h1><h2 id="隐式转换"><a href="#隐式转换" class="headerlink" title="隐式转换"></a>隐式转换</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">short</span> sn = <span class="number">999</span>;</span><br><span class="line"><span class="keyword">int</span> n = sn;</span><br></pre></td></tr></table></figure><h2 id="显示转换"><a href="#显示转换" class="headerlink" title="显示转换"></a>显示转换</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> f = <span class="number">110.741f</span>;</span><br><span class="line"><span class="keyword">int</span> n = (<span class="keyword">int</span>)f;</span><br></pre></td></tr></table></figure><p>这两种转换方式平时经常用到，不管是函数传参时进行转换，还是数学计算时进行强转，一直也没有发现有什么问题，直到昨天遇到了一个有符号数隐式转换成无符号数时，才发现这里也是一个知识盲点，当时脑瓜儿嗡嗡的，怎么连隐式类型转换也这么陌生了呢？</p><p>其实隐式类型转换一般发生在小类型转换成大类型时，有个常用的关系链 <code>char -&gt; short -&gt; int -&gt; long -&gt; float -&gt; double</code>，当关系链条中出现无符号数字时，情况有些难以理解了（实际上是有符号数字的锅）。</p><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>看一下这几行代码，如果你能准确说出程序的输出值，那么你已经掌握了这个知识点，后面的内容可以不用看了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c = <span class="number">128</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> n = c;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码的输出值是 <code>4294967168</code>，发生了啥？也就是说老板给你发工资时，本来想发128块，但是发工资的函数参数是 <code>unsigned int</code> 类型的，结果就给你发了 4294967168，一下就实现了40多个小目标。</p><h1 id="查找原因"><a href="#查找原因" class="headerlink" title="查找原因"></a>查找原因</h1><p>针对上面的代码我们改写一下，把变量 c 换成无符号类型：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> c = <span class="number">128</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> n = c;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这次的输出值变成了 <code>128</code>, 符合我们的预期，回过头来再看看刚才出错的代码，区别就是变量c是否有符号，结果差了好几十亿。</p><p>这里导致结果差异的原因实际上是符号位引起的，如果是无符号数字，从小类型到大类型隐式类型转换的结果数字都不会变，但是如果是有符号的数字，在转换成大类型数字的时候就要考虑符号位了，就以第一段代码为例来解释这个现象。</p><p><code>char c = 128;</code> 这一句实际上已经超出了变量 c 的范围，因为变量c是有符号数字，所以它的范围是-128~127，这里赋值成128，实际在内存中的bit排列是 <code>10000000</code>，而有符号数的第一位bit表示正负号，这里是1表示这是一个负数，计算机存储负数是以补码的形式存储的，那么把这个数据按位取反再加1，得到 <code>1000000</code> 还是原来的数字，好神奇哦！</p><p>不过这里就可以计算出 c 实际上代表-128，那么它在隐式类型转换成更大的有符号数字时，需要保证值不变，一个int的-128怎么表示呢？根据补码的定义应该是<code>11111111 11111111 11111111 10000000</code>，这个数字再转换成 <code>unsigned int</code> 就是前面提到的 4294967168 啦。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>有符号数字在转换成范围更大的无符号数字时需要注意转换所得数值是否正确，失之毫厘差之千里。</li><li>总结一个规律，有符号的整形数字在进行隐式类型转换时实际上是在数字的二进制表示前面补充符号位。</li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/110357193" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>一个人不能做完所有的事情，但是所有人都可以做一些事情，怕什么真理无穷，进一寸有进有一寸的欢喜~</p><p>2020-12-8 00:04:05</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;隐式类型转换转换是一个挺基础的概念，即使对于初学者来说都不会陌生，一般情况下是指数据类型的转换是由编译系统自动进行的，不需要人工干预的类型转换方式。与之相对的是强制类型转换，在进行转换时必须使用强制类型转换运算符进行转换，这种也被称为显式转换。&lt;/p&gt;
    
    </summary>
    
      <category term="C/C++" scheme="http://AlbertGithubHome.github.io/blog/categories/C-C/"/>
    
    
      <category term="C/C++" scheme="http://AlbertGithubHome.github.io/blog/tags/C-C/"/>
    
      <category term="符号" scheme="http://AlbertGithubHome.github.io/blog/tags/%E7%AC%A6%E5%8F%B7/"/>
    
      <category term="隐式类型" scheme="http://AlbertGithubHome.github.io/blog/tags/%E9%9A%90%E5%BC%8F%E7%B1%BB%E5%9E%8B/"/>
    
      <category term="转换" scheme="http://AlbertGithubHome.github.io/blog/tags/%E8%BD%AC%E6%8D%A2/"/>
    
  </entry>
  
  <entry>
    <title>简单聊聊01世界中编码和解码这对磨人的小妖儿</title>
    <link href="http://AlbertGithubHome.github.io/blog/2020/11/28/%E7%AE%80%E5%8D%95%E8%81%8A%E8%81%8A01%E4%B8%96%E7%95%8C%E4%B8%AD%E7%BC%96%E7%A0%81%E5%92%8C%E8%A7%A3%E7%A0%81%E8%BF%99%E5%AF%B9%E7%A3%A8%E4%BA%BA%E7%9A%84%E5%B0%8F%E5%A6%96%E5%84%BF/"/>
    <id>http://AlbertGithubHome.github.io/blog/2020/11/28/简单聊聊01世界中编码和解码这对磨人的小妖儿/</id>
    <published>2020-11-28T11:28:30.000Z</published>
    <updated>2020-12-27T12:41:11.250Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在程序员生活的01世界中有两大Boss级难题，分别是缓存失效和命名问题，对比这两大难题来说，编码和解码只能算是小妖儿了，只不过这两个小妖儿出镜率很高，有时确实很磨人的，得多花些时间捋顺一下。</p><a id="more"></a><p>编码问题不仅仅出现在计算机中，广义的说，编码问题涉及到人类社会的方方面面，比如古人规定指定长度是一寸，然后规定十寸为一尺，其实就是当时人们对长度的一种编码，但是由于每个地方的编码不统一，导致人们在交流的时候出现了很多问题，直到秦始皇统一了文字、度量衡，相当于统一了描述当时社会的编码，使得知识和文明得以快速传播。</p><h1 id="计算机中的编码"><a href="#计算机中的编码" class="headerlink" title="计算机中的编码"></a>计算机中的编码</h1><p>今天想说的编码和解码特指计算中使用的编码和解码，通俗点说：编码是给计算机看的，解码是为了让人能看懂的。可能大家对这句话还不太理解，不过没关系，这个说法本身不太严谨，也可以举出一些反例，但是大部分情况下确实是这样的。</p><p>为什么要编码，想想谍战片里近代社会中的发电报过程，滴答、滴滴答、滴滴滴答答就这个样子，怎么来表达“敌人发动进攻了”，这时候就用到了编码，提前约定好“滴答”代表“敌”，“滴滴答”代表“人”，这样在收到“滴答、滴滴答”你就知道了“敌人”这个信息，那个密码本记录的内容和规则其实就是对所有电传信息的一种编码。</p><p>计算机中的编码也是一样的，从我们开始接触到计算机的时候就听说过计算机只认识0和1，虽然现代计算机技术发展迅速，但是计算机只认识0和1这一点一直未变，所以你想让他看懂你的信息，保存你的数据，就要把这些信息和数据编码成0和1，计算机才能进行处理和存储。</p><p>所以计算机中为什么要对数据进行编码，这里可以给一个狭义的理解：计算机编码是为了让数据便于传输、存储和处理。</p><p>那有为什么要进行解码呢？其实就是为了人能看懂，给你一串二进制 <code>01010111100011111111...</code>，相信你即使有最强大脑也不能迅速把所有数据解开，这可能是一篇优美的散文、一幅美丽的图画，或者是一部励志的电影，这一切都需要解码后才能知道。</p><p>本来想画一幅“编码”和“解码”这两个小妖的画像，但是作为灵魂画手的我还没构思好，此处留空，后面补充。。。</p><hr><p>补上了&gt;&gt;</p><p><img src="https://img-blog.csdnimg.cn/20201129230755158.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9hbGJlcnRnaXRodWJob21lLmdpdGh1Yi5pby9ibG9nL2Fib3V0,size_12,color_FFFFFF,t_70#pic_center" alt="encoding"></p><h1 id="初识编码问题"><a href="#初识编码问题" class="headerlink" title="初识编码问题"></a>初识编码问题</h1><p>自从接触计算机就开始接触编码问题，比如你抄同学发来的作业文档，打开后却发现是一堆乱码，那时仅仅知道是编码错了，但是不知道怎么解决，或者直接让同学再发一份算了，后来在工作中需要做游戏多语言版本时才真正开始处理编码问题。</p><p>解决第一个编码问题大概是14年，当时做上线游戏的多语言版本、配置文件中的中文保存为 <code>ANSI</code> 编码，相同的配置文件放到日韩的系统上居然变成了其他的含义，查询解决方案决定使用 <code>UTF-8</code> 编码来保存配置文件，所以当时利用工具将所有的配置文件转换成了UTF-8编码，也是那个时候第一次接触到了Python，转换之后将其中的中文翻译成日韩的语言，从此知道了 <code>UTF-8</code> 这个编码方式，也清楚了在中日韩、越南、缅甸这个圈做产品，千万要远离 <code>ANSI</code> 编码。</p><p>其实 <code>ANSI</code> 并不是某一种特定的字符编码，而是一个编码集合，在不同的系统中，可以表示不同的编码，比如英文系统中的 <code>ASCII</code>编码，简体中文系统中的 <code>GBK</code>编码，韩文系统中 <code>EUC-KR</code> 编码等等</p><h2 id="编码变迁小八卦"><a href="#编码变迁小八卦" class="headerlink" title="编码变迁小八卦"></a>编码变迁小八卦</h2><p>计算机是美国人发明用于科学计算的，所以他们也是第一批考虑编码的，而英文只有26个字母，所以他们发明了ASCII码，只使用了0-127这128个空间就表示了所有可能用的字符，但后来计算机技术飞速发展，已经不仅仅用于科学计算，已经融入到社会的方方面面，并且迅速在全球流行。</p><p>随着计算机火遍全球，其它国家发现自己国家经常使用的字符，在 ASCII 码中找不到啊，于是就有人想啊，ASCII 码中的一个字节中不是才用了一半吗，我们使用这个最高位来扩展把，于是很多国家就开始用最高位来扩展这个 ASCII 编码以便能够表示自己国家的一些字符，但是对于我博大精深的中国文化来说，这一个字节远远不够啊，我们的汉字那可就有好几万个，你就给我一个字节，我肯定不干。</p><p>既然一个字节搞不定，那我们就用两个字节好了，我们规定一个小于等于127的字符的意义与原来相同，此处为了兼容ASCII码，但两个大于127的字符连在一起时，就表示一个汉字，前一个字节从0xA1用到0xF7，后面一个字节从0xA1到0xFE，我们将常用的6000多汉字在这个范围内定义代码点，并将这种编码方式称为 <code>GB2312</code>。</p><p>在 GB2312 这种编码中我们考虑了数学符号、希腊字母、全角标点等等，但是只有简体字没有繁体字啊，这下对面海岸的同胞们不乐意了，自己搞了一套 <code>Big5</code> 编码，用来处理繁体字。</p><p>后来随着电脑深入各个领域，常用汉字已经不能满足使用需求了，所以又把 GB2312 编码中没有使用的位置拿出来又进行代码点定义，处理了20000多个汉字，发明了 <code>GBK</code> 编码，但没过多久（2000年）发现还是不够用，又提出了变长的 <code>GB18030</code> 编码，每个字符占用1、2、4个字节。</p><h1 id="大统一的Unicode"><a href="#大统一的Unicode" class="headerlink" title="大统一的Unicode"></a>大统一的Unicode</h1><p>刚刚简单提到了在中日韩这个圈里，每个国家都对 <code>ASCII</code>编码进行了扩充，也就是对 <code>ANSI</code> 编码进行了自己的定义，通常是用两个字节来表示一个文字和符号，这样就出现了一种情况，相同的两个字节在不同的系统上显示了不同的文字，如果每个国家的人只使用自己的语言也是没问题的，但是当中日韩文字混排的时候就出现了问题，这两个字节到底应该转换成中日韩哪个国家的符号呢？</p><p>为了解决这种混乱的局面，大佬们设计了一种名为 <code>Unicode</code> 的字符集，又称万国码或者统一码。Unicode 的诞生是为整合全世界的所有语言文字。理论上任何字符在Unicode中都对应一个值，这个值被称为代码点，通常写成 <code>\uABCD</code> 的格式。</p><h2 id="UCS-4-和-UCS-2"><a href="#UCS-4-和-UCS-2" class="headerlink" title="UCS-4 和 UCS-2"></a>UCS-4 和 UCS-2</h2><p>起初使用两个字节来表示代码点，其取值范围为 \u0000～\uFFFF，这种文字和代码点之间的对应关系被描述为UCS-2，也就是 Universal Character Set Coded in 2 octets 的缩写，最多可以记录65536个字符的代码点。</p><p>后来为了能表示更多的文字，人们又提出了UCS-4，即用四个字节表示代码点。它的范围为 \u00000000～\u7FFFFFFF，其中 \u00000000～\u0000FFFF和UCS-2是一样的。</p><p>从这里可以看出 UCS-4 与 UCS-2 只是一种扩展的关系，UCS-4 是兼容 UCS-2 的，在 UCS-2 的每个代码点加入两个值为0的字节就变成了 UCS-4。</p><h2 id="UCS-2-LE-和-UCS-2-BE"><a href="#UCS-2-LE-和-UCS-2-BE" class="headerlink" title="UCS-2 LE 和 UCS-2 BE"></a>UCS-2 LE 和 UCS-2 BE</h2><p>这里的 <code>LE</code> 和 <code>BE</code> 指的是计算机中常提到的小端字节序和大端字节序，因为 UCS-4 是 UCS-2 的扩展，所以 UCS-4 也存在大端和小端的问题。</p><p>小端字节序，是指数据的高字节保存在内存的高地址中，而数据的低字节保存在内存的低地址中，而大端字节序，是指数据的高字节保存在内存的低地址中，而数据的低字节保存在内存的高地址中，这和我们平时的阅读习惯一致。</p><p>如果没接触过大端和小端可能会有点懵，举个例子就明白了，C++中一个int类型的数字通常占4个字节，假如一个int类型的变量值是256，那么他再内存中是怎样表示的呢？我们知道计算机中除了1就是0，这在计算机中对应一个bit，而计算机中表示数据的单位是字节，每个字节有8个bit大小，那么int变量值 256 翻译成二进制是 <code>00000000 00000000 00000001 00000000</code> 一共占用4个字节。</p><p>对照前面大端和小端的定义，这4个字节在内存中如果从高到低排列，就是小端字节序，如果这4个字节在内存中如果从低到高排列，就是大端字节序。因为UCS-2是两个字节表示一个代码点，所以在表示的时候存在字节排列顺序问题，对于值为 256 的这个代码点，可以是0x0100，也可以是0x0001。</p><h2 id="Unicode-和-UCS-2"><a href="#Unicode-和-UCS-2" class="headerlink" title="Unicode 和 UCS-2"></a>Unicode 和 UCS-2</h2><p>Unicode 是一个字符集，这一点应该很好理解，它表示的是字符和代码点的对应关系，比如简体字“汉”对应的Unicode代码点是 <code>\u6C49</code>，而 UCS-2 究竟是一种字符集还是一种编码方式呢？</p><p>我个人偏向于它是一种编码方式，因为它存在大端、小端这种说法，如果是一种字符集只会考虑对应关系，不会考虑字节序，这只是我个人观点，有些软件上确实是这样标注的，但有些文章也会把UCS-2当成一种字符集，这样也能说的通，不用太纠结这里的区别。</p><p>其实 UCS-2 编码对应的字符集是UCS，这些是历史原因导致的，一方面国际标准化组织（ISO）于1984年创建ISO/IEC JTC1/SC2/WG2工作组，试图制定一份通用字符集（Universal Character Set，简称UCS），并最终制定了ISO 10646标准。<br>而另一方面统一码联盟，也很想做这个统一编码的武林盟主，由Xerox、Apple等软件制造商于1988年组成，并且开发了Unicode标准。</p><p>然后1991年左右，两个项目的参与者都认识到，世界不需要两个不兼容的字符集。于是，它们开始合并双方的工作成果，并为创立一个单一编码表而协同工作。从Unicode 2.0开始，Unicode采用了与ISO 10646-1相同的字库和字码。ISO也承诺，ISO 10646将不会替超出\u10FFFF的UCS-4编码赋值，以使得两者保持一致。两个项目仍都独立存在，并独立地公布各自的标准。不过由于Unicode这一名字名字起的好，比较好记，因而它使用更为广泛。</p><p>从这段历史我们可以看到，虽然 UCS-4 将 UCS-2 从2个字节扩展成了4个字节，但是范围并没到使用到 \u00000000～\uFFFFFFFF，而是将范围集中到 \u000000～\u10FFFF 内，保证了 UCS 和 Unicode 各个字符代码点的统一，也奠定了UTF-8实现标准Unicode时最多需要4个字节的基础。</p><h1 id="UTF-8-的诞生"><a href="#UTF-8-的诞生" class="headerlink" title="UTF-8 的诞生"></a>UTF-8 的诞生</h1><p>按理说 Unicode 已经给世界范围内的所有字符定义了代码点，无论是什么字符，使用4个字节都能表示出来，为什么要搞出一个UTF-8呢？是因为使用者发现，对于ASCII码范围内的字符，本来1个字节就能正确表示，现在居然要4个字节表示，即使使用 UCS-2编码，占用的空间也扩大了1倍，有些太浪费了。</p><p>为了解决这种空间浪费问题，就出现了一类变长的通用转换格式，即UTF（Universal Transformation Format），常见的UTF格式有：UTF-7，UTF-7.5，UTF-8，UTF-16 以及 UTF-32。</p><p>这类格式中最常见的就是 UTF-8 编码了，UTF-8 是针对于 Unicode 字符集中各个代码点的编码方式，是一种 Unicode 字符的实现方式，采用变长字节来表示Unicode编码，最长使用4个字节来表示标准的Unicode代码点，在有些资料中可能会看到5、6个字节的编码方式，这些都是非标准的Unicode代码点，根据规范，这些字节值将无法出现在合法 UTF-8序列中。</p><h2 id="Unicode-和-UTF-8"><a href="#Unicode-和-UTF-8" class="headerlink" title="Unicode 和 UTF-8"></a>Unicode 和 UTF-8</h2><p>UTF-8在对标准Unicode字符编码时最多使用4个字节，其代码点范围与UTF-8编码后的形式对应如下：</p><table><thead><tr><th style="text-align:center"><strong>Unicode/UCS-4</strong>（十六进制）</th><th style="text-align:center">字节数</th><th style="text-align:left">UTF-8编码格式（二进制）</th></tr></thead><tbody><tr><td style="text-align:center">000000-00007F</td><td style="text-align:center">1</td><td style="text-align:left">0xxxxxxx</td></tr><tr><td style="text-align:center">000080-0007FF</td><td style="text-align:center">2</td><td style="text-align:left">110xxxxx 10xxxxxx</td></tr><tr><td style="text-align:center">000800-00FFFF</td><td style="text-align:center">3</td><td style="text-align:left">1110xxxx 10xxxxxx 10xxxxxx</td></tr><tr><td style="text-align:center">010000-10FFFF</td><td style="text-align:center">4</td><td style="text-align:left">11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</td></tr></tbody></table><h2 id="UTF-8编码示例"><a href="#UTF-8编码示例" class="headerlink" title="UTF-8编码示例"></a>UTF-8编码示例</h2><p>只看上面这种对应关系，可能还不太清楚是怎样表示，接下来可以举一个例子试一下，比如一个常用的简体中文字——“好”，查询它的Unicode代码点是 <code>\u597D</code>，对照上面的表格发现在 000800-00FFFF 这个范围，应该采用3个字节的表现形式。</p><p>先把这个数值翻译成二进制为 <code>0101100101111101</code>，然后按照3个字节的形式分成3组，<code>0101</code>、<code>100101</code> 和 <code>111101</code>，把这些内容天填充到xxx这样的空位中就得到了“好”这个字的UTF-8编码—— <code>11100101 10100101 10111101</code>，表示成十六进制就是 <code>0xE5A5BD</code>。</p><p>这个过程还是比较简单的，其他编码要转换成UTF-8编码都要经过Unicode这一步中转，先通过转换表查到其他编码对应字符的Unicode编码，然后再转换成UTF-8的表示格式。</p><h2 id="优点和缺点"><a href="#优点和缺点" class="headerlink" title="优点和缺点"></a>优点和缺点</h2><p>根据 UTF-8 的编码规则，任何一个 byte 漏传，多传，传错只影响当前字符，前后字符都不受影响，而 Unicode 如果从一个字的中间截断会导致接下来所有的字符解析都是错的，这使得UTF-8编码的数据在不够可靠的网络传输中是有利的。</p><p>兼容ASCII，并且是字节顺序无关的。它的字节顺序在所有系统中都是一样的，因此它实际上并不需要BOM，不过在文件开头常常保存 0xEFBBBF 三个字节来表明文件编码是UTF-8。</p><p>缺点是因为UTF-8是一种变长编码，无法从直接从Unicode字符直接判断出UTF-8文本的字节数。除了ASCII字符集内的字符，其他情况实际上都增加了固定的头数据，占用了无效空间。</p><h1 id="编码和解码在编程中的应用"><a href="#编码和解码在编程中的应用" class="headerlink" title="编码和解码在编程中的应用"></a>编码和解码在编程中的应用</h1><p>编码和解码在网站页面和数据库存储时用的非常多，一不小心就搞出一堆乱码，这种编码和解码操作在Python3中很直观，Python2中 string 和 bytes 混合在一起，编码和解码操作不太明显，而在python3中 string 和 bytes 是完全不同的两个类型，string编码成bytes，而bytes解码成string。</p><p>相比于python3中的编码、解码对应两个类型，C++中的编码和解码操作的前后都是字符串，这在一定程度上会给人造成误解，接下来我们使用Python3来简单测试一下编码和解码操作。</p><h2 id="编码操作"><a href="#编码操作" class="headerlink" title="编码操作"></a>编码操作</h2><p>编码通常是把人类可以理解的字符转换成计算机可以认识二进制数据，这个过程在python3中对应的是把string转化成bytes，测试如下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">word = <span class="string">'好好'</span></span><br><span class="line">print(type(word), word)</span><br><span class="line"></span><br><span class="line">result = word.encode(<span class="string">'utf-8'</span>)</span><br><span class="line">print(type(result), result)</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;class &apos;str&apos;&gt; 好好</span><br><span class="line">&lt;class &apos;bytes&apos;&gt; b&apos;\xe5\xa5\xbd\xe5\xa5\xbd&apos;</span><br></pre></td></tr></table></figure><h2 id="解码操作"><a href="#解码操作" class="headerlink" title="解码操作"></a>解码操作</h2><p>解码操作通常是把计算机中存储和传输的数据转换成人类能看懂的字符，这个过程在python3中对应的是把bytes转化成string，测试如下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">data = <span class="string">b'\xe5\xa5\xbd\xe5\xa5\xbd'</span></span><br><span class="line">print(type(data), data)</span><br><span class="line"></span><br><span class="line">result = data.decode(<span class="string">'utf-8'</span>)</span><br><span class="line">print(type(result), result)</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;class &apos;bytes&apos;&gt; b&apos;\xe5\xa5\xbd\xe5\xa5\xbd&apos;</span><br><span class="line">&lt;class &apos;str&apos;&gt; 好好</span><br></pre></td></tr></table></figure><h2 id="乱码产生"><a href="#乱码产生" class="headerlink" title="乱码产生"></a>乱码产生</h2><p>从上面的两个例子来看编码和解码非常简单，那怎么还能出现乱码呢？计算机说到底还是一种工具，你在把可见字符编码后交给计算机存储和传输时，你要记住这些二进制的编码方式，在你想看这些数据时还要用相反的方式进行解码，否则就会出现乱码，比如下面这种使用 utf-8 编码，却使用 gbk 这种方式来解码，就得不到你想要的数据。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">word = <span class="string">'好好'</span></span><br><span class="line">print(type(word), word)</span><br><span class="line"></span><br><span class="line">result = word.encode(<span class="string">'utf-8'</span>)</span><br><span class="line">print(type(result), result)</span><br><span class="line"></span><br><span class="line">new_word = result.decode(<span class="string">'gbk'</span>)</span><br><span class="line">print(type(new_word), new_word)</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;class &apos;str&apos;&gt; 好好</span><br><span class="line">&lt;class &apos;bytes&apos;&gt; b&apos;\xe5\xa5\xbd\xe5\xa5\xbd&apos;</span><br><span class="line">&lt;class &apos;str&apos;&gt; 濂藉ソ</span><br></pre></td></tr></table></figure><p>虽然结果是可以看得见的字符，但是这不是我们想要的数据，所以 <code>濂藉ソ</code> 对于我们来说也是一种乱码，在处理字符编码时我们必须清楚知道要用什么方式来进行编码和解码，如果编码和解码的方式不一致，那么就会产生乱码现象。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li><code>Unicode</code> 是一种字符集，描述了人类范围内用于交流的所有字符的代码点，给与唯一的数字进行对应</li><li><code>Unicode</code> 规定的代码点范围是 \u000000-\u10FFFF，这与 UCS-4 规定的范围达成了统一，共定义了17个Plan</li><li><code>UTF-8</code> 是Unicode字符集的一种实现，采用变长的方式，标准规范最多使用4个字节表示一个Unicode字符</li><li>编码是为了把人类用来交流的字符转换成二进制数据便于存储和传输</li><li>解码是为了把存储在计算机中的二进制数据转换成人们能看得懂的字符</li><li>编码和解码不一致时就会造成乱码，比如使用UTF-8编码，使用GBK来解码就会造成乱码现象</li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/109976348" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>对未知的事物充满恐惧，过于保守的看待当下的一切，有时候太稳反而会失去很多~</p><p>2020-11-29 19:23:13</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;在程序员生活的01世界中有两大Boss级难题，分别是缓存失效和命名问题，对比这两大难题来说，编码和解码只能算是小妖儿了，只不过这两个小妖儿出镜率很高，有时确实很磨人的，得多花些时间捋顺一下。&lt;/p&gt;
    
    </summary>
    
      <category term="Thinking" scheme="http://AlbertGithubHome.github.io/blog/categories/Thinking/"/>
    
    
      <category term="Python" scheme="http://AlbertGithubHome.github.io/blog/tags/Python/"/>
    
      <category term="编码" scheme="http://AlbertGithubHome.github.io/blog/tags/%E7%BC%96%E7%A0%81/"/>
    
      <category term="解码" scheme="http://AlbertGithubHome.github.io/blog/tags/%E8%A7%A3%E7%A0%81/"/>
    
      <category term="encode" scheme="http://AlbertGithubHome.github.io/blog/tags/encode/"/>
    
      <category term="decode" scheme="http://AlbertGithubHome.github.io/blog/tags/decode/"/>
    
  </entry>
  
  <entry>
    <title>linux环境下使用netstat命令查看网络信息</title>
    <link href="http://AlbertGithubHome.github.io/blog/2020/11/22/linux%E7%8E%AF%E5%A2%83%E4%B8%8B%E4%BD%BF%E7%94%A8netstat%E5%91%BD%E4%BB%A4%E6%9F%A5%E7%9C%8B%E7%BD%91%E7%BB%9C%E4%BF%A1%E6%81%AF/"/>
    <id>http://AlbertGithubHome.github.io/blog/2020/11/22/linux环境下使用netstat命令查看网络信息/</id>
    <published>2020-11-22T15:05:55.000Z</published>
    <updated>2021-02-21T15:17:30.019Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><code>netstat</code> 这个命令一直以为是 net status 的缩写，今天一查发现并没有找到官方的这种说法，然后参考了 man 手册，发现这个词更像是 net statistics 的缩写，命令的作用是显示网络连接、路由表、接口连接、无效连接和多播成员关系的，man 手册中描述这个命令如下：</p><a id="more"></a><blockquote><p>netstat - Print network connections, routing tables, interface statistics, masquerade connections, and multicast memberships</p></blockquote><p>这个命令很强大，但是我经常使用的参数很简单，通常用来查询端口占用问题，命令为 <code>netstat -anp | grep xxxPORT</code>，因为在我测试自己项目程序的时候，总有一些进程企图占用我使用的端口，比如那个 被我 kill 了 n 次的 TIM 客户端，使用 netstat 可以方便的找到是哪个进程占用了你的端口。</p><p>虽然这个命令经常使用，但是其中的这些参数含义却不是很清楚，所以特地总结一下，综合其他常见的用法，记录下来以备后续查找使用。</p><h1 id="参数选项"><a href="#参数选项" class="headerlink" title="参数选项"></a>参数选项</h1><ul><li><strong>-a</strong>：显示所有连接，包括 LISTEN 状态的连接</li><li><strong>-l</strong>：仅显示 LISTEN 状态的连接</li><li><strong>-t</strong>：仅显示tcp相关选项</li><li><strong>-u</strong>：仅显示udp相关选项</li><li><strong>-n</strong>：拒绝显示别名，能显示数字的全部转化成数字</li><li><strong>-o</strong>：显示信息中包括与网络计时器相关的信息</li><li><strong>-e</strong>：显示扩展信息，例如uid等</li><li><strong>-p</strong>：显示建立相关链接的程序名</li><li><strong>-r</strong>：显示路由信息，路由表</li><li><strong>-s</strong>：按各个协议进行统计</li><li><strong>-c</strong>：每隔一个固定时间，执行该netstat命令。</li></ul><h1 id="无参数执行"><a href="#无参数执行" class="headerlink" title="无参数执行"></a>无参数执行</h1><p>该命令无参数执行时显示数据会少一些，便于我们看清命令执行的结果，内容如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[root@node1 ~]<span class="comment"># netstat</span></span><br><span class="line">Active Internet connections (w/o servers)</span><br><span class="line">Proto Recv-Q Send-Q Local Address           Foreign Address         State</span><br><span class="line">tcp        0      0 192.168.0.201:ssh       178.129.126.124.b:19450 ESTABLISHED</span><br><span class="line">tcp        0     52 192.168.0.201:ssh       178.129.126.124.b:17626 ESTABLISHED</span><br><span class="line">tcp        0      0 192.168.0.201:57784     101.200.35.175:https    TIME_WAIT</span><br><span class="line">tcp        0      0 192.168.0.201:42298     100.125.2.72:https      ESTABLISHED</span><br><span class="line">Active UNIX domain sockets (w/o servers)</span><br><span class="line">Proto RefCnt Flags       Type       State         I-Node   Path</span><br><span class="line">unix  2      [ ]         DGRAM                    11550    /run/systemd/shutdownd</span><br><span class="line">unix  2      [ ]         DGRAM                    13355412 /var/run/chrony/chronyd.sock</span><br><span class="line">unix  3      [ ]         DGRAM                    1228     /run/systemd/notify</span><br><span class="line">unix  2      [ ]         DGRAM                    1230     /run/systemd/cgroups-agent</span><br><span class="line">unix  5      [ ]         DGRAM                    1241     /run/systemd/journal/socket</span><br><span class="line">unix  16     [ ]         DGRAM                    1243     /dev/<span class="built_in">log</span></span><br><span class="line">unix  3      [ ]         STREAM     CONNECTED     15663</span><br><span class="line">unix  3      [ ]         STREAM     CONNECTED     15662</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>输出结果可以分为 <code>Active Internet connections</code> 和 <code>Active UNIX domain sockets</code> 两个部分：</p><p>Active Internet connections 指有效的网络连接，默认显示6列内容：</p><ul><li>Proto：协议名字，包括tcp, udp, udpl, raw等</li><li>Recv-Q：表示网络接收队列，表示收到的数据已经在本地接收缓冲，还有多少没有被应用程序取走</li><li>Send-Q：表示网络发送队列，表示存在本地缓冲区，但对方没有收到的数据或者没有 ACK 的</li><li>Local Address：本地IP地址和端口</li><li>Foreign Address：外部IP地址和端口</li><li>State：网络连接状态，包括 ESTABLISHED、SYN_SENT、SYN_RECV、FIN_WAIT1、FIN_WAIT2、TIME_WAIT、CLOSE、CLOSE_WAIT、LAST_ACK、LISTEN、CLOSING、UNKNOWN 等状态</li></ul><p>Active UNIX domain sockets 是指本地套接口，我们知道 socket 也可用于同一台主机的进程间（IPC）通讯，但是 socket 用于IPC更有效率：不需要经过网络协议栈，不需要打包拆包、计算校验和、维护序号和应答等，只是将应用层数据从一个进程拷贝到另一个进程<br>并且它是是全双工的，API接口语义丰富，相比其它进程间通信机制有明显的优越性。</p><h1 id="常用命令组合"><a href="#常用命令组合" class="headerlink" title="常用命令组合"></a>常用命令组合</h1><h2 id="查询端口占用"><a href="#查询端口占用" class="headerlink" title="查询端口占用"></a>查询端口占用</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@node1 /]<span class="comment"># netstat -anp | grep 8889</span></span><br><span class="line">tcp        0      0 0.0.0.0:8889            0.0.0.0:*               LISTEN      27584/tinyproxy</span><br></pre></td></tr></table></figure><p>这是我目前最常用的命令，在windows可以改为 <code>netstat -ano | findstr 8889</code></p><h2 id="显示tcp连接"><a href="#显示tcp连接" class="headerlink" title="显示tcp连接"></a>显示tcp连接</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@node1 /]<span class="comment"># netstat -at</span></span><br><span class="line">Active Internet connections (servers and established)</span><br><span class="line">Proto Recv-Q Send-Q Local Address           Foreign Address         State</span><br><span class="line">tcp        0      0 0.0.0.0:ddi-tcp-2       0.0.0.0:*               LISTEN</span><br><span class="line">tcp        0      0 localhost:smtp          0.0.0.0:*               LISTEN</span><br><span class="line">tcp        0      0 0.0.0.0:ssh             0.0.0.0:*               LISTEN</span><br><span class="line">tcp        0     52 192.168.0.201:ssh       178.129.126.124.b:19450 ESTABLISHED</span><br><span class="line">tcp        0      0 192.168.0.201:ssh       178.129.126.124.b:17626 ESTABLISHED</span><br><span class="line">tcp        0      0 192.168.0.201:42298     100.125.2.72:https      ESTABLISHED</span><br><span class="line">tcp6       0      0 [::]:squid              [::]:*                  LISTEN</span><br><span class="line">tcp6       0      0 localhost:smtp          [::]:*                  LISTEN</span><br><span class="line">tcp6       0      0 [::]:ssh                [::]:*                  LISTEN</span><br></pre></td></tr></table></figure><h2 id="显示处于-LISTEN-状态的端口"><a href="#显示处于-LISTEN-状态的端口" class="headerlink" title="显示处于 LISTEN 状态的端口"></a>显示处于 LISTEN 状态的端口</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[root@node1 /]<span class="comment"># netstat -l</span></span><br><span class="line">Active Internet connections (only servers)</span><br><span class="line">Proto Recv-Q Send-Q Local Address           Foreign Address         State</span><br><span class="line">tcp        0      0 0.0.0.0:ddi-tcp-2       0.0.0.0:*               LISTEN</span><br><span class="line">tcp        0      0 localhost:smtp          0.0.0.0:*               LISTEN</span><br><span class="line">tcp        0      0 0.0.0.0:ssh             0.0.0.0:*               LISTEN</span><br><span class="line">tcp6       0      0 [::]:squid              [::]:*                  LISTEN</span><br><span class="line">tcp6       0      0 localhost:smtp          [::]:*                  LISTEN</span><br><span class="line">tcp6       0      0 [::]:ssh                [::]:*                  LISTEN</span><br><span class="line">udp        0      0 0.0.0.0:bootpc          0.0.0.0:*</span><br><span class="line">udp        0      0 0.0.0.0:ntp             0.0.0.0:*</span><br><span class="line">udp        0      0 localhost:323           0.0.0.0:*</span><br><span class="line">udp        0      0 0.0.0.0:56034           0.0.0.0:*</span><br><span class="line">udp6       0      0 [::]:42035              [::]:*</span><br><span class="line">udp6       0      0 localhost:323           [::]:*</span><br><span class="line">Active UNIX domain sockets (only servers)</span><br><span class="line">Proto RefCnt Flags       Type       State         I-Node   Path</span><br><span class="line">unix  2      [ ACC ]     STREAM     LISTENING     11533    /run/lvm/lvmpolld.socket</span><br><span class="line">unix  2      [ ACC ]     STREAM     LISTENING     6848304  /var/run/rpcbind.sock</span><br><span class="line">unix  2      [ ACC ]     STREAM     LISTENING     11584    /run/lvm/lvmetad.socket</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h2 id="分类统计每种协议的信息"><a href="#分类统计每种协议的信息" class="headerlink" title="分类统计每种协议的信息"></a>分类统计每种协议的信息</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">[root@node1 /]<span class="comment"># netstat -s</span></span><br><span class="line">Ip:</span><br><span class="line">    7902622 total packets received</span><br><span class="line">    60675 forwarded</span><br><span class="line">    127 with unknown protocol</span><br><span class="line">    0 incoming packets discarded</span><br><span class="line">    7841813 incoming packets delivered</span><br><span class="line">    7270606 requests sent out</span><br><span class="line">    8 dropped because of missing route</span><br><span class="line">Icmp:</span><br><span class="line">    928210 ICMP messages received</span><br><span class="line">    25426 input ICMP message failed.</span><br><span class="line">    InCsumErrors: 8</span><br><span class="line">    ICMP input histogram:</span><br><span class="line">        destination unreachable: 71154</span><br><span class="line">        timeout <span class="keyword">in</span> transit: 484</span><br><span class="line">        <span class="built_in">echo</span> requests: 856165</span><br><span class="line">        <span class="built_in">echo</span> replies: 337</span><br><span class="line">        timestamp request: 54</span><br><span class="line">    896502 ICMP messages sent</span><br><span class="line">    0 ICMP messages failed</span><br><span class="line">    ICMP output histogram:</span><br><span class="line">        destination unreachable: 40039</span><br><span class="line">        <span class="built_in">echo</span> request: 244</span><br><span class="line">        <span class="built_in">echo</span> replies: 856165</span><br><span class="line">        timestamp replies: 54</span><br><span class="line">Tcp:</span><br><span class="line">    274517 active connections openings</span><br><span class="line">    66347 passive connection openings</span><br><span class="line">    187800 failed connection attempts</span><br><span class="line">    90950 connection resets received</span><br><span class="line">    3 connections established</span><br><span class="line">    6359177 segments received</span><br><span class="line">    5808198 segments send out</span><br><span class="line">    494062 segments retransmited</span><br><span class="line">    4 bad segments received.</span><br><span class="line">    452720 resets sent</span><br><span class="line">Udp:</span><br><span class="line">    539313 packets received</span><br><span class="line">    14902 packets to unknown port received.</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h2 id="每秒显示一次信息"><a href="#每秒显示一次信息" class="headerlink" title="每秒显示一次信息"></a>每秒显示一次信息</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@node1 /]<span class="comment"># netstat -c</span></span><br><span class="line">Active Internet connections (w/o servers)</span><br><span class="line">Proto Recv-Q Send-Q Local Address           Foreign Address         State</span><br><span class="line">tcp        0     52 192.168.0.201:ssh       178.129.126.124.b:19450 ESTABLISHED</span><br><span class="line">tcp        0      0 192.168.0.201:ssh       178.129.126.124.b:17626 ESTABLISHED</span><br><span class="line">tcp        0      0 192.168.0.201:42298     100.125.2.72:https      ESTABLISHED</span><br><span class="line">Active UNIX domain sockets (w/o servers)</span><br><span class="line">Proto RefCnt Flags       Type       State         I-Node   Path</span><br><span class="line">unix  2      [ ]         DGRAM                    11550    /run/systemd/shutdownd</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h2 id="显示核心路由信息"><a href="#显示核心路由信息" class="headerlink" title="显示核心路由信息"></a>显示核心路由信息</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@node1 /]<span class="comment"># netstat -r</span></span><br><span class="line">Kernel IP routing table</span><br><span class="line">Destination     Gateway         Genmask         Flags   MSS Window  irtt Iface</span><br><span class="line">default         192.168.0.1     0.0.0.0         UG        0 0          0 eth0</span><br><span class="line">169.254.169.254 192.168.0.254   255.255.255.255 UGH       0 0          0 eth0</span><br><span class="line">172.17.0.0      0.0.0.0         255.255.0.0     U         0 0          0 docker0</span><br><span class="line">192.168.0.0     0.0.0.0         255.255.255.0   U         0 0          0 eth0</span><br></pre></td></tr></table></figure><h2 id="显示网络接口列表"><a href="#显示网络接口列表" class="headerlink" title="显示网络接口列表"></a>显示网络接口列表</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@node1 /]<span class="comment"># netstat -i</span></span><br><span class="line">Kernel Interface table</span><br><span class="line">Iface             MTU    RX-OK RX-ERR RX-DRP RX-OVR    TX-OK TX-ERR TX-DRP TX-OVR Flg</span><br><span class="line">docker0          1500    36248      0      0 0         33647      0      0      0 BMU</span><br><span class="line">eth0             1500  9119246      0      0 0       8277212      0      0      0 BMRU</span><br><span class="line">lo              65536    27700      0      0 0         27700      0      0      0 LRU</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li><code>netstat -anp | grep 8889</code> 命令可用于查询8889端口被哪个进程占用了，在Windows上翻译为 <code>netstat -ano | findstr 8889</code></li><li>netstat 命令查询出的网络连接信息中，<code>Recv-Q</code> 和 <code>Send-Q</code> 通常应该为0，如果长时间不为0可能是有问题的，需要尽快排查</li><li>如果 <code>Recv-Q</code> 数值一直处于不为0的状态，可能是遭受了拒绝服务 DOS 攻击，导致本地消息处理过慢</li><li>如果 <code>Send-Q</code> 数值一直处于不为0的状态，可能是有应用向外发送数据包过快，或者是对方接收处理数据包不够快</li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/109712347" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>以史为鉴可以知兴替，以铜为鉴可以正衣冠，以人为鉴可以明得失。人的成长需要对比，总有人比你更加优秀~</p><p>2020-11-23 01:17:59</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&lt;code&gt;netstat&lt;/code&gt; 这个命令一直以为是 net status 的缩写，今天一查发现并没有找到官方的这种说法，然后参考了 man 手册，发现这个词更像是 net statistics 的缩写，命令的作用是显示网络连接、路由表、接口连接、无效连接和多播成员关系的，man 手册中描述这个命令如下：&lt;/p&gt;
    
    </summary>
    
      <category term="linux" scheme="http://AlbertGithubHome.github.io/blog/categories/linux/"/>
    
    
      <category term="排序" scheme="http://AlbertGithubHome.github.io/blog/tags/%E6%8E%92%E5%BA%8F/"/>
    
      <category term="linux" scheme="http://AlbertGithubHome.github.io/blog/tags/linux/"/>
    
      <category term="sort" scheme="http://AlbertGithubHome.github.io/blog/tags/sort/"/>
    
  </entry>
  
  <entry>
    <title>学习cmake从成功编译一个小程序开始</title>
    <link href="http://AlbertGithubHome.github.io/blog/2020/11/14/%E5%AD%A6%E4%B9%A0cmake%E4%BB%8E%E6%88%90%E5%8A%9F%E7%BC%96%E8%AF%91%E4%B8%80%E4%B8%AA%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%A7%8B/"/>
    <id>http://AlbertGithubHome.github.io/blog/2020/11/14/学习cmake从成功编译一个小程序开始/</id>
    <published>2020-11-14T15:59:17.000Z</published>
    <updated>2020-12-27T12:40:05.821Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在 Windows上开发我使用最多的IDE还是 Visual Studio，编写、编译一条龙服务，导致了不少编译流程知识的缺失，这种大型的IDE确实好用，诸多配置通过在界面上勾选一下就可以了，但是在编译细节的掌握上还是漏掉了一些知识。</p><a id="more"></a><p>在 linux 开发环境下通常会使用 gcc 或者 g++ 进行编译，可是编译选项有点多，当工程非常大的时候需要写的编译参数太多了，这时可以使用make命令来帮助我们编译 C++ 程序，编译时依赖一些规则，这些规则就写在一个叫 Makefile 的文件中。</p><p>后来发现写 Makefile 还是太麻烦了，这个文件也相当大。于是“懒惰”的程序员们又开发出了各种各样的工具用来生成 Makefile 文件，我使用过的目前就只有 <code>automake</code> 和 <code>cmake</code>。</p><h1 id="生成Makefile"><a href="#生成Makefile" class="headerlink" title="生成Makefile"></a>生成Makefile</h1><p>之前使用的生成 Makefile 文件的工具是 <code>automake</code>，被称为是“八股文”一样的操作，每次操作都是固定的几个步骤，比如每次都要运行 <code>autoscan</code>、<code>aclocal</code>、<code>autoconf</code>、<code>automake</code>、<code>./confiugre</code>等命令，需要个人发挥的地方并不多，之前使用的时候也不是完全从0开始一点点写的，往往是写一个项目模板之后，对照着在Makefile.am文件中修改几个参数就好了。</p><p>现在新的工作内容中使用 cmake 来生成 Makefile，这个 cmake 之前还确实接触过一些，大概是2012年的时候，那时在编译 OpenCV 库还有增强现实插件的时候用过几次，当时感觉安装起来太麻烦了，对那个红绿蓝的图标记忆犹新，感觉和当时的新闻联播的图标有些亲戚关系。</p><p>其实当时根本分不清什么是编译器，什么是 Makefile，对于各种库文件的编译完全是按照文档来操作，现在回过头来看看 cmake 生成 Makefile 还是比较简单的，最起码要比 automake 省了很多步骤，只要编写一个 CMakeLists.txt 文件就好了。</p><h1 id="编写CMakeLists-txt生成Makefile"><a href="#编写CMakeLists-txt生成Makefile" class="headerlink" title="编写CMakeLists.txt生成Makefile"></a>编写CMakeLists.txt生成Makefile</h1><p>为了练习使用编写CMakeLists.txt生成Makefile，进而编译C++项目，我们可以从头来实现一个小例子，目标是编写一个计算加法的静态库和一个计算减法静态库，然后实现一个测试工程来使用这两个函数库，整个工程使用 cmake 来生成 Makefile，然后使用 make 命令完成编译。</p><h2 id="实现简单的代码文件"><a href="#实现简单的代码文件" class="headerlink" title="实现简单的代码文件"></a>实现简单的代码文件</h2><p>加法和减法都是常用的简单计算，用来举例子很容易理解，接下来展示要用到的几个文件内容，每个文件只有几行，只为了说明问题，文件内容如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//myadd.h</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//myadd.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"myadd.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//mysub.h</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sub</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//mysub.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mysub.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sub</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a - b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//test.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"myadd.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mysub.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"happy birthday!"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"519 + 1 = "</span> &lt;&lt; add(<span class="number">519</span>, <span class="number">1</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"1320 - 6 = "</span> &lt;&lt; sub(<span class="number">1320</span>, <span class="number">6</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用常规方法编译"><a href="#使用常规方法编译" class="headerlink" title="使用常规方法编译"></a>使用常规方法编译</h2><p>首先使用最简单 g++ 命令来编译这个样例程序：</p><ol><li>查看目录下文件</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:testcmake$ ls</span><br><span class="line">myadd.cpp  myadd.h  mysub.cpp  mysub.h  test.cpp</span><br></pre></td></tr></table></figure><ol><li>将 <code>myadd.h</code> 和 <code>myadd.cpp</code> 编译成静态库 <code>libmyadd.a</code></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:testcmake$ g++ -c myadd.cpp</span><br><span class="line">albert@home-pc:testcmake$ ar crv libmyadd.a myadd.o</span><br><span class="line">a - myadd.o</span><br><span class="line">albert@home-pc:testcmake$ ls</span><br><span class="line">libmyadd.a  myadd.cpp  myadd.h  myadd.o  mysub.cpp  mysub.h  test.cpp</span><br></pre></td></tr></table></figure><ol><li>将 <code>mysub.h</code> 和 <code>mysub.cpp</code> 编译成静态库 <code>libmysub.so</code></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:testcmake$ g++ -c mysub.cpp</span><br><span class="line">albert@home-pc:testcmake$ g++ -shared -fPIC -o libmysub.so mysub.o</span><br><span class="line">albert@home-pc:testcmake$ ls</span><br><span class="line">libmyadd.a  libmysub.so  myadd.cpp  myadd.h  myadd.o  mysub.cpp  mysub.h  mysub.o  test.cpp</span><br></pre></td></tr></table></figure><ol><li>编译链接静态库 <code>libmyadd.a</code>、动态库 <code>libmysub.so</code> 和测试文件生成可执行程序 <code>test</code></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:testcmake$ g++ test.cpp libmyadd.a -L. -lmysub -o <span class="built_in">test</span> -Wl,-rpath=.</span><br><span class="line">albert@home-pc:testcmake$ ls</span><br><span class="line">libmyadd.a  libmysub.so  myadd.cpp  myadd.h  myadd.o  mysub.cpp  mysub.h  mysub.o  <span class="built_in">test</span>  test.cpp</span><br></pre></td></tr></table></figure><ol><li>运行查看结果，成功计算表达式的值</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:testcmake$ ./<span class="built_in">test</span></span><br><span class="line">happy birthday!</span><br><span class="line">519 + 1 = 520</span><br><span class="line">1320 - 6 = 1314</span><br></pre></td></tr></table></figure><h2 id="使用cmake方式"><a href="#使用cmake方式" class="headerlink" title="使用cmake方式"></a>使用cmake方式</h2><p>上面展示了最原始的编译方法，每次都要敲这些命令，接下来编写一个 CMakeLists 文件，使用 cmake 生成Makefile，以后只要运行 make 命令就可以完成编译了。</p><p>调整一下目录结构如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:testcmake$ tree</span><br><span class="line">.</span><br><span class="line">|-- myadd</span><br><span class="line">|   |-- myadd.cpp</span><br><span class="line">|   `-- myadd.h</span><br><span class="line">|-- mysub</span><br><span class="line">|   |-- mysub.cpp</span><br><span class="line">|   `-- mysub.h</span><br><span class="line">`-- test.cpp</span><br></pre></td></tr></table></figure><ol><li>进入 myadd 目录新建 CMakeLists.txt 编写内容如下：</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">aux_source_directory(. SRC_LIST)        <span class="comment">#将此目录的源文件集合设置为变量SRC_LIST</span></span><br><span class="line">add_library(myadd STATIC <span class="variable">$&#123;SRC_LIST&#125;</span>)   <span class="comment">#库的名称，库的类型，静态库的源文件列表</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span>(LIBRARY_OUTPUT_PATH <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/lib)  <span class="comment">#库的输出路径为根目录下的lib文件夹</span></span><br></pre></td></tr></table></figure><ol><li>进入 mysub 目录新建 CMakeLists.txt 编写内容如下：</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">aux_source_directory(. SRC_LIST)        <span class="comment">#将此目录的源文件集合设置为变量SRC_LIST</span></span><br><span class="line">add_library(mysub SHARED <span class="variable">$&#123;SRC_LIST&#125;</span>)   <span class="comment">#库的名称，库的类型，动态库的源文件列表</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span>(LIBRARY_OUTPUT_PATH <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/lib)  <span class="comment">#库的输出路径为根目录下的lib文件夹</span></span><br></pre></td></tr></table></figure><ol><li>在工程主目录下新建 CMakeLists.txt 编写内容如下：</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 指定cmake版本</span></span><br><span class="line">cmake_minimum_required(VERSION 3.5)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定项目的名称，一般和项目的文件夹名称对应</span></span><br><span class="line">project(testcmake)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定子目录</span></span><br><span class="line">add_subdirectory(myadd)</span><br><span class="line">add_subdirectory(mysub)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加c++ 11标准支持</span></span><br><span class="line"><span class="built_in">set</span>(CMAKE_CXX_FLAGS <span class="string">"-std=c++11"</span> )</span><br><span class="line"></span><br><span class="line"><span class="comment"># 特殊宏，之前编译mysqlcppconn8用到过</span></span><br><span class="line">add_definitions(-DGLIBCXX_USE_CXX11_ABI)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 头文件目录</span></span><br><span class="line">include_directories(myadd mysub)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 源文件目录</span></span><br><span class="line">aux_source_directory(. DIR_SRCS)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置环境变量，编译用到的源文件全部都要放到这</span></span><br><span class="line"><span class="built_in">set</span>(TEST_MATH <span class="variable">$&#123;DIR_SRCS&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 库文件目录</span></span><br><span class="line">link_directories(lib)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加要编译的可执行文件</span></span><br><span class="line">add_executable(<span class="variable">$&#123;PROJECT_NAME&#125;</span> <span class="variable">$&#123;TEST_MATH&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加可执行文件所需要的库</span></span><br><span class="line">target_link_libraries(<span class="variable">$&#123;PROJECT_NAME&#125;</span> myadd)</span><br><span class="line">target_link_libraries(<span class="variable">$&#123;PROJECT_NAME&#125;</span> mysub)</span><br></pre></td></tr></table></figure><ol><li>新建build目录和lib目录，整个工程目录关系如下：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:testcmake$ tree</span><br><span class="line">.</span><br><span class="line">|-- CMakeLists.txt</span><br><span class="line">|-- build</span><br><span class="line">|-- lib</span><br><span class="line">|-- myadd</span><br><span class="line">|   |-- CMakeLists.txt</span><br><span class="line">|   |-- myadd.cpp</span><br><span class="line">|   `-- myadd.h</span><br><span class="line">|-- mysub</span><br><span class="line">|   |-- CMakeLists.txt</span><br><span class="line">|   |-- mysub.cpp</span><br><span class="line">|   `-- mysub.h</span><br><span class="line">`-- test.cpp</span><br><span class="line"></span><br><span class="line">4 directories, 8 files</span><br></pre></td></tr></table></figure><ol><li>进入 build 目录下依次运行 <code>cmake ..</code> 和 <code>make</code> 命令</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:testcmake/build$ cmake ..</span><br><span class="line">-- The C compiler identification is GNU 5.4.0</span><br><span class="line">-- The CXX compiler identification is GNU 5.4.0</span><br><span class="line">-- Check <span class="keyword">for</span> working C compiler: /usr/bin/cc</span><br><span class="line">-- Check <span class="keyword">for</span> working C compiler: /usr/bin/cc -- works</span><br><span class="line">-- Detecting C compiler ABI info</span><br><span class="line">-- Detecting C compiler ABI info - <span class="keyword">done</span></span><br><span class="line">-- Detecting C compile features</span><br><span class="line">-- Detecting C compile features - <span class="keyword">done</span></span><br><span class="line">-- Check <span class="keyword">for</span> working CXX compiler: /usr/bin/c++</span><br><span class="line">-- Check <span class="keyword">for</span> working CXX compiler: /usr/bin/c++ -- works</span><br><span class="line">-- Detecting CXX compiler ABI info</span><br><span class="line">-- Detecting CXX compiler ABI info - <span class="keyword">done</span></span><br><span class="line">-- Detecting CXX compile features</span><br><span class="line">-- Detecting CXX compile features - <span class="keyword">done</span></span><br><span class="line">-- Configuring <span class="keyword">done</span></span><br><span class="line">-- Generating <span class="keyword">done</span></span><br><span class="line">-- Build files have been written to: testcmake/build</span><br><span class="line">albert@home-pc:testcmake/build$ make</span><br><span class="line">Scanning dependencies of target mysub</span><br><span class="line">[ 16%] Building CXX object mysub/CMakeFiles/mysub.dir/mysub.cpp.o</span><br><span class="line">[ 33%] Linking CXX shared library ../../lib/libmysub.so</span><br><span class="line">[ 33%] Built target mysub</span><br><span class="line">Scanning dependencies of target myadd</span><br><span class="line">[ 50%] Building CXX object myadd/CMakeFiles/myadd.dir/myadd.cpp.o</span><br><span class="line">[ 66%] Linking CXX static library ../../lib/libmyadd.a</span><br><span class="line">[ 66%] Built target myadd</span><br><span class="line">Scanning dependencies of target testcmake</span><br><span class="line">[ 83%] Building CXX object CMakeFiles/testcmake.dir/test.cpp.o</span><br><span class="line">[100%] Linking CXX executable testcmake</span><br><span class="line">[100%] Built target testcmake</span><br><span class="line">albert@home-pc:testcmake/build$ ./testcmake</span><br><span class="line">happy birthday!</span><br><span class="line">519 + 1 = 520</span><br><span class="line">1320 - 6 = 1314</span><br><span class="line">albert@home-pc:testcmake/build$</span><br></pre></td></tr></table></figure><p>至此，使用cmake方式编译工程的例子就写完了。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol><li><code>cmake</code> 和 <code>automake</code> 本身不提供编译功能，只是可以按照编写的 CMakeLists.txt 文件生成 Makefile</li><li><code>make</code> 可以根据 Makefile 文件调用 gcc/g++ 命令对源代码进行编译工作</li><li><code>-Wl,-rpath=.</code> 这个选项可以指定可执行文件查找动态库的路径，感觉比 <code>export LD_LIBRARY_PATH</code> 要方便一点</li><li><code>-DGLIBCXX_USE_CXX11_ABI</code> 这个宏可坑了我不少时间，编译使用libmysqlcppconn8的时候，如果不禁用会报编译错误</li></ol><hr><center><a href="https://blog.csdn.net/albertsh/article/details/109553923" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>有你，真好~</p><p>2020-11-15 23:55:35</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;在 Windows上开发我使用最多的IDE还是 Visual Studio，编写、编译一条龙服务，导致了不少编译流程知识的缺失，这种大型的IDE确实好用，诸多配置通过在界面上勾选一下就可以了，但是在编译细节的掌握上还是漏掉了一些知识。&lt;/p&gt;
    
    </summary>
    
      <category term="linux" scheme="http://AlbertGithubHome.github.io/blog/categories/linux/"/>
    
    
      <category term="C++" scheme="http://AlbertGithubHome.github.io/blog/tags/C/"/>
    
      <category term="linux" scheme="http://AlbertGithubHome.github.io/blog/tags/linux/"/>
    
      <category term="编译" scheme="http://AlbertGithubHome.github.io/blog/tags/%E7%BC%96%E8%AF%91/"/>
    
      <category term="cmake" scheme="http://AlbertGithubHome.github.io/blog/tags/cmake/"/>
    
  </entry>
  
</feed>
