<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Albert World</title>
  <icon>https://www.gravatar.com/avatar/8ccc6291d5bfd34e7aaf601c4ebec7e1</icon>
  
  <link href="/blog/atom.xml" rel="self"/>
  
  <link href="http://AlbertGithubHome.github.io/blog/"/>
  <updated>2024-07-20T14:29:10.315Z</updated>
  <id>http://AlbertGithubHome.github.io/blog/</id>
  
  <author>
    <name>Albert Shi</name>
    <email>347070901@qq.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>因为glibc版本不兼容不得已我重装了Dell R620的系统</title>
    <link href="http://AlbertGithubHome.github.io/blog/2024/07/20/%E5%9B%A0%E4%B8%BAglibc%E7%89%88%E6%9C%AC%E4%B8%8D%E5%85%BC%E5%AE%B9%E4%B8%8D%E5%BE%97%E5%B7%B2%E6%88%91%E9%87%8D%E8%A3%85%E4%BA%86Dell-R620%E7%9A%84%E7%B3%BB%E7%BB%9F/"/>
    <id>http://AlbertGithubHome.github.io/blog/2024/07/20/因为glibc版本不兼容不得已我重装了Dell-R620的系统/</id>
    <published>2024-07-19T16:30:00.000Z</published>
    <updated>2024-07-20T14:29:10.315Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我总以为这件事发生很久了，但刚刚去翻了聊天记录居然是上周发生的事情，趁着还没忘干净赶紧记录一下，对于服务器安装系统来说这还是第一次。</p><p>好久很久以前（大概是1个月前），我找运维装了一台服务器Dell PowerEdge R620，当时说好是Ubuntu20.04版本，但是装完后我也没注意，期间发生了很多事情，终于到上周的时候开始在这台机器上搭建Jenkins打包环境，整个过程还是比较顺利的，但是发现打包机上编译的程序版本无法在本地环境下运行，这时候仔细看才发现，原来运维安装的系统是 Ubuntu22.04，也不知道是因为粗心还是大意，不能运行的原因就是打包机上的glibc版本过高，本地环境无法支持，但这却引起了我的疑惑。</p><a id="more"></a><h1 id="glibc版本和常用命令"><a href="#glibc版本和常用命令" class="headerlink" title="glibc版本和常用命令"></a>glibc版本和常用命令</h1><p>先附一个Linux发行版本和默认glibc版本对应关系的图表</p><table><thead><tr><th style="text-align:center">Ubuntu</th><th style="text-align:center">Debian</th><th style="text-align:center">CentOS</th><th style="text-align:center">Glibc</th></tr></thead><tbody><tr><td style="text-align:center">22.04</td><td style="text-align:center">-</td><td style="text-align:center">-</td><td style="text-align:center">2.34</td></tr><tr><td style="text-align:center">20.04</td><td style="text-align:center">11</td><td style="text-align:center">-</td><td style="text-align:center">2.31</td></tr><tr><td style="text-align:center">-</td><td style="text-align:center">10</td><td style="text-align:center">8</td><td style="text-align:center">2.28</td></tr><tr><td style="text-align:center">18.04</td><td style="text-align:center">-</td><td style="text-align:center">-</td><td style="text-align:center">2.27</td></tr><tr><td style="text-align:center">-</td><td style="text-align:center">9</td><td style="text-align:center">-</td><td style="text-align:center">2.24</td></tr><tr><td style="text-align:center">16.04</td><td style="text-align:center">-</td><td style="text-align:center">-</td><td style="text-align:center">2.23</td></tr><tr><td style="text-align:center">14.04</td><td style="text-align:center">8</td><td style="text-align:center">-</td><td style="text-align:center">2.19</td></tr><tr><td style="text-align:center">13.04</td><td style="text-align:center">-</td><td style="text-align:center">7</td><td style="text-align:center">2.17</td></tr><tr><td style="text-align:center">12.04</td><td style="text-align:center">-</td><td style="text-align:center">-</td><td style="text-align:center">2.15</td></tr><tr><td style="text-align:center">-</td><td style="text-align:center">7</td><td style="text-align:center">-</td><td style="text-align:center">2.13</td></tr><tr><td style="text-align:center">-</td><td style="text-align:center">-</td><td style="text-align:center">6</td><td style="text-align:center">2.12</td></tr></tbody></table><p>查询glibc版本的命令为</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ldd --version</span><br></pre></td></tr></table></figure><p>查询动态库和可执行文件中的符号版本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">objdump -T my-program-or-so | grep GLIBC_</span><br><span class="line"></span><br><span class="line">strings /lib/x86_64-linux-gnu/libc.so.6 | grep GLIBC</span><br></pre></td></tr></table></figure><p>查询一个目录下所有动态库中使用符号的glibc版本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls | grep <span class="string">'.so'</span> | xargs objdump -T | grep GLIBC_ &gt; /tmp/symbol.log</span><br></pre></td></tr></table></figure><h1 id="glibc版本差异的疑问"><a href="#glibc版本差异的疑问" class="headerlink" title="glibc版本差异的疑问"></a>glibc版本差异的疑问</h1><p>目前我维护了两个项目，对于编译环境和运行环境不一样的问题，两个项目中都存在，但是A项目没问题，但是B项目有问题，具体的情况如下：</p><h2 id="A项目"><a href="#A项目" class="headerlink" title="A项目"></a>A项目</h2><p>C++11编写，打包机Ubuntu16.04，glibc版本2.23，运行环境有CentOS7和Ubuntu16.04，相同的系统大概率没问题，而CentOS7的glibc是2.17版本，也没有问题，这让我很奇怪</p><h3 id="打包机编译环境"><a href="#打包机编译环境" class="headerlink" title="打包机编译环境"></a>打包机编译环境</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">root@jenkins1604:~<span class="comment"># cat /etc/os-release</span></span><br><span class="line">NAME=<span class="string">"Ubuntu"</span></span><br><span class="line">VERSION=<span class="string">"16.04.2 LTS (Xenial Xerus)"</span></span><br><span class="line">ID=ubuntu</span><br><span class="line">ID_LIKE=debian</span><br><span class="line">PRETTY_NAME=<span class="string">"Ubuntu 16.04.2 LTS"</span></span><br><span class="line">VERSION_ID=<span class="string">"16.04"</span></span><br><span class="line">HOME_URL=<span class="string">"http://www.ubuntu.com/"</span></span><br><span class="line">SUPPORT_URL=<span class="string">"http://help.ubuntu.com/"</span></span><br><span class="line">BUG_REPORT_URL=<span class="string">"http://bugs.launchpad.net/ubuntu/"</span></span><br><span class="line">VERSION_CODENAME=xenial</span><br><span class="line">UBUNTU_CODENAME=xenial</span><br><span class="line">root@jenkins1604:~<span class="comment"># ldd --version</span></span><br><span class="line">ldd (Ubuntu GLIBC 2.23-0ubuntu5) 2.23</span><br><span class="line">Copyright (C) 2016 Free Software Foundation, Inc.</span><br><span class="line">This is free software; see the <span class="built_in">source</span> <span class="keyword">for</span> copying conditions.  There is NO</span><br><span class="line">warranty; not even <span class="keyword">for</span> MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</span><br><span class="line">Written by Roland McGrath and Ulrich Drepper.</span><br><span class="line">root@jenkins1604:~<span class="comment">#</span></span><br></pre></td></tr></table></figure><h3 id="运行环境1"><a href="#运行环境1" class="headerlink" title="运行环境1"></a>运行环境1</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$ cat /etc/os-release</span><br><span class="line">NAME=<span class="string">"Ubuntu"</span></span><br><span class="line">VERSION=<span class="string">"16.04.6 LTS (Xenial Xerus)"</span></span><br><span class="line">ID=ubuntu</span><br><span class="line">ID_LIKE=debian</span><br><span class="line">PRETTY_NAME=<span class="string">"Ubuntu 16.04.6 LTS"</span></span><br><span class="line">VERSION_ID=<span class="string">"16.04"</span></span><br><span class="line">HOME_URL=<span class="string">"http://www.ubuntu.com/"</span></span><br><span class="line">SUPPORT_URL=<span class="string">"http://help.ubuntu.com/"</span></span><br><span class="line">BUG_REPORT_URL=<span class="string">"http://bugs.launchpad.net/ubuntu/"</span></span><br><span class="line">VERSION_CODENAME=xenial</span><br><span class="line">UBUNTU_CODENAME=xenial</span><br><span class="line"></span><br><span class="line"><span class="comment"># shz @ 20200116GF in /mnt/e/linux on git:7bd9be2 x [9:47:34]</span></span><br><span class="line">$ ldd --version</span><br><span class="line">ldd (Ubuntu GLIBC 2.23-0ubuntu11) 2.23</span><br><span class="line">Copyright (C) 2016 Free Software Foundation, Inc.</span><br><span class="line">This is free software; see the <span class="built_in">source</span> <span class="keyword">for</span> copying conditions.  There is NO</span><br><span class="line">warranty; not even <span class="keyword">for</span> MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</span><br><span class="line">Written by Roland McGrath and Ulrich Drepper.</span><br></pre></td></tr></table></figure><h3 id="运行环境2"><a href="#运行环境2" class="headerlink" title="运行环境2"></a>运行环境2</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">[root@hk-dev Debug]<span class="comment"># cat /etc/os-release</span></span><br><span class="line">NAME=<span class="string">"CentOS Linux"</span></span><br><span class="line">VERSION=<span class="string">"7 (Core)"</span></span><br><span class="line">ID=<span class="string">"centos"</span></span><br><span class="line">ID_LIKE=<span class="string">"rhel fedora"</span></span><br><span class="line">VERSION_ID=<span class="string">"7"</span></span><br><span class="line">PRETTY_NAME=<span class="string">"CentOS Linux 7 (Core)"</span></span><br><span class="line">ANSI_COLOR=<span class="string">"0;31"</span></span><br><span class="line">CPE_NAME=<span class="string">"cpe:/o:centos:centos:7"</span></span><br><span class="line">HOME_URL=<span class="string">"https://www.centos.org/"</span></span><br><span class="line">BUG_REPORT_URL=<span class="string">"https://bugs.centos.org/"</span></span><br><span class="line"></span><br><span class="line">CENTOS_MANTISBT_PROJECT=<span class="string">"CentOS-7"</span></span><br><span class="line">CENTOS_MANTISBT_PROJECT_VERSION=<span class="string">"7"</span></span><br><span class="line">REDHAT_SUPPORT_PRODUCT=<span class="string">"centos"</span></span><br><span class="line">REDHAT_SUPPORT_PRODUCT_VERSION=<span class="string">"7"</span></span><br><span class="line"></span><br><span class="line">You have mail <span class="keyword">in</span> /var/spool/mail/root</span><br><span class="line">[root@hk-dev Debug]<span class="comment"># ldd --version</span></span><br><span class="line">ldd (GNU libc) 2.17</span><br><span class="line">Copyright (C) 2012 Free Software Foundation, Inc.</span><br><span class="line">This is free software; see the <span class="built_in">source</span> <span class="keyword">for</span> copying conditions.  There is NO</span><br><span class="line">warranty; not even <span class="keyword">for</span> MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</span><br><span class="line">Written by Roland McGrath and Ulrich Drepper.</span><br></pre></td></tr></table></figure><h2 id="B项目"><a href="#B项目" class="headerlink" title="B项目"></a>B项目</h2><p>C++20编写，原打包机Ubuntu20.04，glibc版本2.31，运行环境有Ubuntu20.04，相同的系统没出问题，后来因打包机替换系统升到Ubuntu22.04后，glibc版本为2.34，再到Ubuntu20.04系统上运行就报错了</p><blockquote><p>./server: /lib/x86_64-linux-gnu/libc.so.6: version <code>GLIBC_2.34&#39; not found (required by ./server)</code></p></blockquote><p>看起来是glibc版本问题导致的</p><h3 id="原打包机编译环境"><a href="#原打包机编译环境" class="headerlink" title="原打包机编译环境"></a>原打包机编译环境</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu2004:~<span class="comment"># cat /etc/os-release</span></span><br><span class="line">NAME=<span class="string">"Ubuntu"</span></span><br><span class="line">VERSION=<span class="string">"20.04.2 LTS (Focal Fossa)"</span></span><br><span class="line">ID=ubuntu</span><br><span class="line">ID_LIKE=debian</span><br><span class="line">PRETTY_NAME=<span class="string">"Ubuntu 20.04.2 LTS"</span></span><br><span class="line">VERSION_ID=<span class="string">"20.04"</span></span><br><span class="line">HOME_URL=<span class="string">"https://www.ubuntu.com/"</span></span><br><span class="line">SUPPORT_URL=<span class="string">"https://help.ubuntu.com/"</span></span><br><span class="line">BUG_REPORT_URL=<span class="string">"https://bugs.launchpad.net/ubuntu/"</span></span><br><span class="line">PRIVACY_POLICY_URL=<span class="string">"https://www.ubuntu.com/legal/terms-and-policies/privacy-policy"</span></span><br><span class="line">VERSION_CODENAME=focal</span><br><span class="line">UBUNTU_CODENAME=focal</span><br><span class="line">root@ubuntu2004:~<span class="comment"># ldd --version</span></span><br><span class="line">ldd (Ubuntu GLIBC 2.31-0ubuntu9.16) 2.31</span><br><span class="line">Copyright (C) 2020 Free Software Foundation, Inc.</span><br><span class="line">This is free software; see the <span class="built_in">source</span> <span class="keyword">for</span> copying conditions.  There is NO</span><br><span class="line">warranty; not even <span class="keyword">for</span> MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</span><br><span class="line">Written by Roland McGrath and Ulrich Drepper.</span><br></pre></td></tr></table></figure><h3 id="新打包编译环境环境"><a href="#新打包编译环境环境" class="headerlink" title="新打包编译环境环境"></a>新打包编译环境环境</h3><ul><li>Ubuntu22.04</li><li>glibc 2.34</li></ul><h3 id="运行环境"><a href="#运行环境" class="headerlink" title="运行环境"></a>运行环境</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$ cat /etc/os-release</span><br><span class="line">NAME=<span class="string">"Ubuntu"</span></span><br><span class="line">VERSION=<span class="string">"20.04.2 LTS (Focal Fossa)"</span></span><br><span class="line">ID=ubuntu</span><br><span class="line">ID_LIKE=debian</span><br><span class="line">PRETTY_NAME=<span class="string">"Ubuntu 20.04.2 LTS"</span></span><br><span class="line">VERSION_ID=<span class="string">"20.04"</span></span><br><span class="line">HOME_URL=<span class="string">"https://www.ubuntu.com/"</span></span><br><span class="line">SUPPORT_URL=<span class="string">"https://help.ubuntu.com/"</span></span><br><span class="line">BUG_REPORT_URL=<span class="string">"https://bugs.launchpad.net/ubuntu/"</span></span><br><span class="line">PRIVACY_POLICY_URL=<span class="string">"https://www.ubuntu.com/legal/terms-and-policies/privacy-policy"</span></span><br><span class="line">VERSION_CODENAME=focal</span><br><span class="line">UBUNTU_CODENAME=focal</span><br><span class="line"></span><br><span class="line"><span class="comment"># shzhen @ 20200116GF in /mnt/c/Users/Administrator [20:42:28]</span></span><br><span class="line">$ ldd --version</span><br><span class="line">ldd (Ubuntu GLIBC 2.31-0ubuntu9.2) 2.31</span><br><span class="line">Copyright (C) 2020 Free Software Foundation, Inc.</span><br><span class="line">This is free software; see the <span class="built_in">source</span> <span class="keyword">for</span> copying conditions.  There is NO</span><br><span class="line">warranty; not even <span class="keyword">for</span> MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</span><br><span class="line">Written by Roland McGrath and Ulrich Drepper.</span><br></pre></td></tr></table></figure><h2 id="问题疑惑"><a href="#问题疑惑" class="headerlink" title="问题疑惑"></a>问题疑惑</h2><p>同样是高版本glibc的机器上编译，在低版本的glibc上运行，为什么A项目没问题，但是B项目出了问题呢，而且A项目的glibc版本2.23–&gt;2.17相差的还多，B项目的glibc版本2.34–&gt;2.31相差的还少，出问题的却是B项目，分析原因glibc应该是向下兼容的，高编译低运行本就不可行，属于正常现象，如果想实现这样运行，就要保证调用的符号在两个版本的库中没有变化，所以我查了A项目和B项目的符号表，发现：</p><ul><li>A项目中符号最高的版本是GLIBC_2.17，所以即使“高编译低运行”也是满足条件的</li><li>B项目中符号最高的版本是GLIBC_2.34，所以不能在glibc.2.31的Ubuntu20.04上运行</li></ul><p>但B项目中使用高版本符号的就有几个，剩下的都低于2.29版本，理论上只要去掉这几个符号的引用就可以在Ubuntu20.04上运行，但是为了避免后续的麻烦，我还是把打包编译的机器重新做了系统Ubuntu20.04</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">0000000000000000      DF *UND*        0000000000000000 (GLIBC_2.33) <span class="built_in">stat</span></span><br><span class="line">0000000000000000  w   DF *UND*        0000000000000000 (GLIBC_2.34) pthread_once</span><br><span class="line">0000000000000000  w   DF *UND*        0000000000000000 (GLIBC_2.34) __pthread_key_create</span><br><span class="line">0000000000000000      DF *UND*        0000000000000000 (GLIBC_2.34) sem_trywait</span><br><span class="line">0000000000000000      DF *UND*        0000000000000000 (GLIBC_2.34) dladdr</span><br><span class="line">0000000000000000      DF *UND*        0000000000000000 (GLIBC_2.34) sem_wait</span><br><span class="line">0000000000000000      DF *UND*        0000000000000000 (GLIBC_2.34) sem_init</span><br><span class="line">0000000000000000      DF *UND*        0000000000000000 (GLIBC_2.34) sem_timedwait</span><br><span class="line">0000000000000000      DF *UND*        0000000000000000 (GLIBC_2.34) sem_destroy</span><br><span class="line">0000000000000000      DF *UND*        0000000000000000 (GLIBC_2.34) dlclose</span><br><span class="line">0000000000000000      DF *UND*        0000000000000000 (GLIBC_2.34) dlsym</span><br><span class="line">0000000000000000      DF *UND*        0000000000000000 (GLIBC_2.34) dlerror</span><br><span class="line">0000000000000000      DF *UND*        0000000000000000 (GLIBC_2.34) dlopen</span><br><span class="line">0000000000000000  w   DF *UND*        0000000000000000 (GLIBC_2.34) pthread_once</span><br><span class="line">0000000000000000  w   DF *UND*        0000000000000000 (GLIBC_2.34) __pthread_key_create</span><br><span class="line">0000000000000000      DF *UND*        0000000000000000 (GLIBC_2.34) dladdr</span><br></pre></td></tr></table></figure><h1 id="将服务器系统改为Ubuntu20-04"><a href="#将服务器系统改为Ubuntu20-04" class="headerlink" title="将服务器系统改为Ubuntu20.04"></a>将服务器系统改为Ubuntu20.04</h1><p>对于重装系统我内心是拒绝的，前两天刚安装了一个PC电脑的windows系统，再往前推都好几年没装过了，不想来回折腾，再者说PC电脑安装Windows很熟悉，即使有问题网上搜一下也解决了，但是服务器安装系统之前确实没做过，并且还有一个我不愿意安装服务器系统的原因，就是这些服务器的硬盘配置的是Raid5磁盘阵列，因为不熟悉我真怕给它做坏了。</p><p>所以对于改为Ubuntu20.04系统这件事，我首先想到的就是将系统降级，但是尝试了一圈没有成功之后，我不得不硬着头皮重装系统了，当然在重装之前还查了Raid5相关信息，发现硬盘配置有专门的Raid卡控制，与操作系统没有关系，只要安装的时候不要把系统安装到原来的数据盘就不会影响原来的数据信息，单纯对做系统来说，硬盘可以当成普通的硬盘来看待，安装时选对盘符就行了。</p><h2 id="开始安装"><a href="#开始安装" class="headerlink" title="开始安装"></a>开始安装</h2><p>安装教程可以参考<a href="https://blog.csdn.net/zjy660358/article/details/131068796" target="_blank" rel="noopener">《Dell服务器安装Ubuntu系统》</a>、<a href="https://www.ikaros.love/?p=340" target="_blank" rel="noopener">《dell r620安装Ubuntu全过程》</a></p><p>镜像地址参考 <a href="https://old-releases.ubuntu.com/releases/" target="_blank" rel="noopener">官方镜像下载</a>、<a href="https://mirrors.tuna.tsinghua.edu.cn/ubuntu-releases/releases/releases/" target="_blank" rel="noopener">清华镜像</a>，注意要选择服务器版本的，不需要带桌面那一套东西，体积会小一点，性能会好一点</p><p>首先是做系统启动盘，按照教程选择了UltraISO，之前用这个比较多，本来一直点下一步就行了，但是无论选择官方镜像还是清华的镜像，在制作的时候都会提示一个可能无法引导系统的警告，但最后是成功的，我就用它试了试</p><p>把U盘插到服务器上，开机按F11进入System BOIS设置，把U盘调到第一启动项，重启后进入U盘拷贝的进度条，但总是无法正确安装，还多次进入了 Emergency mode，重启关机都不好使，最后不得不强行关机了</p><p>然后我换成了使用Rufus来烧制启动U盘，这里涉及到几种选项，比如选BOIS还是UEFI，文件系统选GPT还是MBR，提供一个详细的步骤</p><ol><li><strong>运行 Rufus</strong>：打开 Rufus 应用程序（无需安装）。</li><li><strong>选择设备</strong>：在 “Device” 下拉菜单中选择你的 U 盘。</li><li><strong>选择引导类型</strong>：点击 “Boot selection” 旁边的 “Select” 按钮，选择你下载的 Ubuntu ISO 文件。</li><li><strong>分区方案</strong>：<ul><li>如果 Dell R620 使用 UEFI 固件模式，选择 “GPT” 作为分区方案。</li><li>如果你希望使用传统的 BIOS 模式，选择 “MBR” 作为分区方案。</li></ul></li><li><strong>目标系统</strong>：<ul><li>如果选择 “GPT” 分区方案，目标系统应自动设置为 “UEFI (non CSM)”。</li><li>如果选择 “MBR” 分区方案，目标系统应自动设置为 “BIOS or UEFI”.</li></ul></li><li><strong>文件系统</strong>：选择 “FAT32”。</li><li><strong>卷标</strong>：可以给你的 U 盘设置一个名称，比如 “Ubuntu_Install”。</li><li><strong>启动创建</strong>：点击 “Start” 按钮，Rufus 会开始创建启动盘。过程大约需要几分钟。</li></ol><h3 id="BOIS-和-UEFI的区别"><a href="#BOIS-和-UEFI的区别" class="headerlink" title="BOIS 和 UEFI的区别"></a>BOIS 和 UEFI的区别</h3><p>BIOS（Basic Input/Output System）和UEFI（Unified Extensible Firmware Interface）是两种计算机固件接口，用于在操作系统启动之前初始化硬件和加载操作系统。它们在功能、性能和设计上有一些显著的区别。</p><h4 id="BIOS，Basic-Input-Output-System"><a href="#BIOS，Basic-Input-Output-System" class="headerlink" title="BIOS，Basic Input/Output System"></a>BIOS，Basic Input/Output System</h4><ol><li><strong>传统固件接口</strong>：BIOS是较早的固件接口，起源于20世纪80年代。</li><li><strong>16位模式</strong>：运行在16位处理器模式下，具有1MB的地址空间限制。</li><li><strong>MBR分区表</strong>：使用主引导记录（MBR）分区表，最多支持4个主分区，每个分区最大支持2TB。</li><li><strong>启动速度较慢</strong>：由于初始化硬件的方式较为低效，启动速度较慢。</li><li><strong>用户界面</strong>：通常是文本模式的界面，操作较为复杂。</li><li><strong>扩展性差</strong>：扩展性和灵活性较差，难以适应现代硬件和软件的需求。</li></ol><h4 id="UEFI，Unified-Extensible-Firmware-Interface"><a href="#UEFI，Unified-Extensible-Firmware-Interface" class="headerlink" title="UEFI，Unified Extensible Firmware Interface"></a>UEFI，Unified Extensible Firmware Interface</h4><ol><li><strong>现代固件接口</strong>：UEFI是BIOS的继任者，设计初衷是替代BIOS，提供更丰富的功能和更好的性能。</li><li><strong>32位或64位模式</strong>：运行在32位或64位处理器模式下，具有更大的地址空间。</li><li><strong>GPT分区表</strong>：使用GUID分区表（GPT），支持更多的分区（最多128个），且每个分区可以超过2TB。</li><li><strong>启动速度较快</strong>：初始化硬件的方式更高效，启动速度更快。</li><li><strong>用户界面</strong>：支持图形用户界面（GUI），操作更加直观和友好。</li><li><strong>扩展性强</strong>：具有更好的扩展性和灵活性，支持网络启动、远程诊断和修复等现代功能。</li></ol><h4 id="具体区别"><a href="#具体区别" class="headerlink" title="具体区别"></a>具体区别</h4><ol><li><p><strong>启动过程</strong>：</p><ul><li><strong>BIOS</strong>：在启动过程中，BIOS执行一系列的POST（Power-On Self Test）检查，然后查找并加载MBR中的引导代码。</li><li><strong>UEFI</strong>：在启动过程中，UEFI固件会查找并执行EFI系统分区（ESP）中的引导管理程序，可以直接加载操作系统。</li></ul></li><li><p><strong>分区表支持</strong>：</p><ul><li><strong>BIOS</strong>：仅支持MBR分区表，存在4个主分区的限制。</li><li><strong>UEFI</strong>：支持GPT分区表，可以有更多的分区，且每个分区大小不受2TB限制。</li></ul></li><li><p><strong>硬件支持</strong>：</p><ul><li><strong>BIOS</strong>：对现代硬件的支持有限，尤其在大容量存储设备和新型设备的支持上存在不足。</li><li><strong>UEFI</strong>：设计时考虑了现代硬件的需求，支持更大容量的存储设备和多种新型设备。</li></ul></li><li><p><strong>安全性</strong>：</p><ul><li><strong>BIOS</strong>：安全性较低，缺乏现代安全特性。</li><li><strong>UEFI</strong>：支持Secure Boot等安全特性，防止恶意软件和未授权操作系统的启动。</li></ul></li></ol><p>BIOS和UEFI是两种不同的固件接口，UEFI是BIOS的继任者，提供了更丰富的功能、更好的性能和更强的扩展性。随着计算机技术的发展，UEFI已经成为现代计算机系统中广泛采用的固件接口，逐渐取代了传统的BIOS。</p><p>之前我不太关心这些，这次我听了ChatGPT的建议选择了UEFI、GPT、FAT32的选项，这也为我后面启动埋下了一个坑</p><h2 id="再次安装"><a href="#再次安装" class="headerlink" title="再次安装"></a>再次安装</h2><p>这次无比顺利，将U盘设置为启动盘</p><ul><li>选择语言</li><li>选择键盘</li><li>选择服务器类型Ubuntu Server</li><li>手动配置IP和网关</li><li>跳过代理设置</li><li>选择安装的盘符，注意别选错了，我这里是小心再小心，这是我最担心的一步了</li><li>输入主机名、用户名和密码</li><li>跳过升级Ubuntu Pro</li><li>安装OpenSSH Server</li><li>不勾选其他Feature安装</li><li>然后就等着安装完、更新完重启就行了</li></ul><p>然后等它安装完我就等不及了，没等更新我就重启了，因为从早上捣鼓到下午了，然后电脑就打不开了，一直卡在开机界面，启动项也重新调整了，就是不起作用</p><h2 id="解决开机问题"><a href="#解决开机问题" class="headerlink" title="解决开机问题"></a>解决开机问题</h2><p>每次开机屏幕就卡在下面这些信息上：</p><blockquote><p>No boot device avaiable<br>Current boot node is set to BIOS<br>Please ensure aompatible bootable dedia is available<br>Use the system setup pargram to chaneg the boot mode as needed</p><p>strlke F1 to retry boot, F2 for system setup, F11 for BIOS boot manager</p></blockquote><p>一开始我总是把注意力放在最后一句，每个选项都尝试了也不行，找到两篇相关问题的解答，但是没解决问题</p><ul><li><a href="https://blog.csdn.net/2301_78006725/article/details/131871579" target="_blank" rel="noopener">戴尔服务器安装Ubuntu系统时跳过strlke F1 to retry boot, F2 for system setup,F11 for BIOS boot manager解决方法</a></li><li><a href="https://blog.csdn.net/zbx199110/article/details/80005077" target="_blank" rel="noopener">windowsServer2008开机出现strike f1 to retry boot，f2 for system setup ，f11 for BIOS boot manager</a></li></ul><p>于是仔细看到这一句 “Use the system setup pargram to chaneg the boot mode as needed”</p><p>按F2 进入 System BOIS，将Boot Mode改为 UEFI 模式，成功进入系统，因为之前是BIOS，我制作的引导盘采用的是UEFI模式，后续买云服务器用的也是 Ubuntu 20.04 64位 UEFI版，保持统一吧</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>保证开发环境、打包环境、运行环境一致，可以避免很多坑，这或许就是docker火起来的意义</li><li>使用系统自带的glibc版本，千万不要自己升级或降级，会引起连锁反应，这是很多前人给出的忠告</li><li>glibc的特点，兼容低版本的内容，所以理论上“低版本编译高版本运行”没问题，反过来一般不行，但存在特例</li><li>BIOS（Basic Input/Output System）和UEFI（Unified Extensible Firmware Interface）是两种计算机固件接口</li><li>UEFI是BIOS的继任者，提供了更丰富的功能、更好的性能和更强的扩展性，使用GUID分区表（GPT），支持更多的分区</li><li><code>Use the system setup pargram to chaneg the boot mode as needed</code></li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/140083813" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>是你一直坚持走熟悉舒服的老路，过一眼望到头的人生，那看不见新的风景，遇不到新的经历也就怨不得别人了~</p><p>2024-7-19 19:56:16</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;我总以为这件事发生很久了，但刚刚去翻了聊天记录居然是上周发生的事情，趁着还没忘干净赶紧记录一下，对于服务器安装系统来说这还是第一次。&lt;/p&gt;
&lt;p&gt;好久很久以前（大概是1个月前），我找运维装了一台服务器Dell PowerEdge R620，当时说好是Ubuntu20.04版本，但是装完后我也没注意，期间发生了很多事情，终于到上周的时候开始在这台机器上搭建Jenkins打包环境，整个过程还是比较顺利的，但是发现打包机上编译的程序版本无法在本地环境下运行，这时候仔细看才发现，原来运维安装的系统是 Ubuntu22.04，也不知道是因为粗心还是大意，不能运行的原因就是打包机上的glibc版本过高，本地环境无法支持，但这却引起了我的疑惑。&lt;/p&gt;
    
    </summary>
    
      <category term="linux" scheme="http://AlbertGithubHome.github.io/blog/categories/linux/"/>
    
    
      <category term="linux" scheme="http://AlbertGithubHome.github.io/blog/tags/linux/"/>
    
      <category term="Dell" scheme="http://AlbertGithubHome.github.io/blog/tags/Dell/"/>
    
      <category term="R620" scheme="http://AlbertGithubHome.github.io/blog/tags/R620/"/>
    
      <category term="glibc" scheme="http://AlbertGithubHome.github.io/blog/tags/glibc/"/>
    
      <category term="BIOS" scheme="http://AlbertGithubHome.github.io/blog/tags/BIOS/"/>
    
      <category term="UEFI" scheme="http://AlbertGithubHome.github.io/blog/tags/UEFI/"/>
    
  </entry>
  
  <entry>
    <title>忙忙碌碌的混沌之中差点扑了个空而错过年中这条线</title>
    <link href="http://AlbertGithubHome.github.io/blog/2024/06/30/%E5%BF%99%E5%BF%99%E7%A2%8C%E7%A2%8C%E7%9A%84%E6%B7%B7%E6%B2%8C%E4%B9%8B%E4%B8%AD%E5%B7%AE%E7%82%B9%E6%89%91%E4%BA%86%E4%B8%AA%E7%A9%BA%E8%80%8C%E9%94%99%E8%BF%87%E5%B9%B4%E4%B8%AD%E8%BF%99%E6%9D%A1%E7%BA%BF/"/>
    <id>http://AlbertGithubHome.github.io/blog/2024/06/30/忙忙碌碌的混沌之中差点扑了个空而错过年中这条线/</id>
    <published>2024-06-30T14:54:44.000Z</published>
    <updated>2024-07-20T14:26:08.023Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>突然意识到过完这个周末已经7月份了，他预示着我的2024年已经过半了，过年回家仿佛还是昨天的事情，怎么转眼间已经到了年中了。心里还是不愿承认这件事，翻开自己2024年的打卡清单，列表显示已经到了26周，从另一方面证明了年中这条线已经到来，再看看打卡清单上这惨不忍睹的“成果”，真的有点难以接受。</p><a id="more"></a><p>2024打卡清单是2023年终总结的产物，为的是将时间周期细化，每周记录自己的变化，分别从总结、刷题、跑步、读书来简单记录自己完成了哪些，如今看看这清单，已经有一个月没总结了、一个月没刷题了、2个半月没有读书了，跑步属于硬蹭，每周忙忙碌碌的奔跑我暂且将其归为跑步，否则这一两个月的打卡就是0蛋了。</p><p>一个规律行进的人突然出现了一两个月的空白一定是遇到了什么问题，也不算是找借口，我也来回忆一下这两个月究竟发生了什么，借口也罢、困难也罢，这些暂时都过去了。</p><h1 id="初见端倪"><a href="#初见端倪" class="headerlink" title="初见端倪"></a>初见端倪</h1><p>面对周围环境的不景气，同学们即将被毕业的传闻在2023年底传了出来，在真真假假的传闻过后，同组一位同学不得不离开去寻找新的出路，剩下的伙伴报团取暖，也在努力探索着的新的途径，忙忙碌碌工作到年底，随着新年的喜气洋洋的气息，毕业的寒风好像被冲淡了很多，但是新年回来后的工作热情并没有持续多久，就有更多悲观的信息陆续流传出来。</p><p>话说无风不起浪，这种环境下大家还是宁可信其有，不可信其无，也有不少人早早的开始做了准备，平时我也是会和大家聊聊做好总结，寻找新机会的话题，但接下来这次的毕业信息雷厉风行，4月中旬组内另一小伙伴在3天内毕业离开了，从此也拉开了我这最近两个月的混沌经历。</p><h1 id="混沌初始"><a href="#混沌初始" class="headerlink" title="混沌初始"></a>混沌初始</h1><p>随着并肩战斗的小伙伴被迫依次离开，其实剩下的人都如履薄冰，好在这股风已经刮了很久，大家在心里上没有很意外，无非是对未来出路的迷茫，虽然不知道自己什么时候离开，但是基本默认自己离开只是时间早晚的事。</p><p>而这段时间我在做什么呢？简单来说就是总结加准备吧，因为项目组是有游戏在线上运行的，不管后续项目组的人要怎样处理，必然涉及到项目的整理和交接，所以提早做准备免得最后被毕业时手忙脚乱吧。</p><p>当然这段时间还没到真正混乱时刻，我还在接触新的知识，比如Go的语法、新的框架、帧同步，k8s，AI应用等等，就这样在边总结、边准备的情况下，我的时间来到了五一劳动节，平稳的度过了这个节日，而混沌的经历也从此开始。</p><h1 id="力不从心"><a href="#力不从心" class="headerlink" title="力不从心"></a>力不从心</h1><p>自劳动节过完从河北回京，到端午结束从天津回京，这一个月的时间，真正的体会了一次力不从心的感觉，老人生病，带着挂号、看病、预约检查、手术排期、住院，最多一天跑3家医院。而我也迎来了毕业通知，准备办理离职、项目交接、指定方案、反复沟通、新工作的寻找，办卡。小孩子看病、挂号、运动会的参加、儿童节参与、跟老师的互动和沟通。租住的出租屋要换上下水管道，要有人盯着。老家的麦收，农忙，播种，全家人多地的来回奔波。其中很多事情我并没有参与多少，这都是一家人一起挺过来的，但是真的心累，累的不行，每天歇下来时只想睡觉，好在事情一件一件地解决了。</p><p>这也是为什么最近这段时间的生活打卡清单上只有“跑步”这一项了，每天都是风风火火的奔跑忙碌。</p><h1 id="心力交瘁"><a href="#心力交瘁" class="headerlink" title="心力交瘁"></a>心力交瘁</h1><p>因为之前意识到要做项目交接，所以上文提到我已经做了准备，对于数据的交接基本没什么问题，但是数据量巨大，每次同步得10个小时左右，只要有一点问题那便是再花费个10小时，另外工作流程的移交才是交接工作的难点。</p><p>时间来到了6月初，已经完成了数据交接，并在月初按预定计划申请了交接的各类账号和权限，其中各种求爷爷告奶奶的心酸只有自己才懂，最后一天因数据同步验证问题忙到了很晚，没有拿到离职证明，不得不第二周星期一办完最后手续，本来以为在入职新公司前这段时间可以好好休息一下了，不曾想去拿离职证明那天却是我接下来一个月最轻松的一天。</p><p>6月份这将近一个月对我的洗礼不仅是知识层面的，更多的是精神上的，作为游戏服务端的主程，对比之前的执行大兵，免不了要处理团队内外沟通的事情，相比之前闷头开发时的纯粹真的是累了很多，但是这一个月的洗礼让我认识到，跟人打交道真的必跟计算机打交道累的太多了。</p><p>很多流程只能按照规章制度办，但是如果你的权限足够高，或者你有一个可以说得上话的领导，那么这些规章制度就可以靠边站，流程也可以特批特办，倒不是说去做违规的事，比如半夜12点让流程线上的人帮你审批多少有点不近人情，并且大半夜的你也找不到人，但是在紧急情况下，你如果可以联系到对方的领导，还是可以紧急特批特办的，毕竟是合规的事情，也不需要担什么风险，只是一个大头兵对于半夜卡流程这件事一般还是推不动的，只能向上反映。</p><p>这一个月说了太多的好话，请了太多的人帮忙，走了太多的审批流，特批了太多的紧急状况，吃了太多的外卖，过去几年我都没吃这么多外卖，回望上周的工作总结，我觉得自己就是个超人，这工作强度已经赶上前年出版本，以及去年上线测试时的强度了，这种活真的挺难干的，一方面是专业技能的掌握，而另一方面也考验着人际关系。</p><h1 id="拾遗补缺"><a href="#拾遗补缺" class="headerlink" title="拾遗补缺"></a>拾遗补缺</h1><p>最近这一个月的工作环境错综复杂，工作地点就换了好几次，有过忍饥挨饿，也有过通宵处理，有时连最基本的网络都保证不了，原本一个月都用不了3个G流量的我，这个月竟然破天荒的使用了20多个G，虽然有很多需要靠人际关系才能解决的问题，但是也有很多专业性的问题，即使不是第一次遇到，也有了新的认知和理解，所以简单罗列下，作为后续深入理解的源头吧。</p><p>首先是网络Vlan的搭建，重温了子网的划分与设计，网络拓扑查看，无线网与有线网的连通，3层路由器与二层交换机的数据转发，IP与MAC地址的绑定，DHCP的配置与地址池的设定，CentOS和Ubuntu静态IP的配置，WiFi6对老旧网卡的不兼容性。</p><p>Dell R620服务器的基本硬件构成，iDrac接口的IP配置和用户信息配置，通过iDrac对机器的功率、温度、硬盘的监控，服务器硬盘的保护，服务器周围环境注意的问题，温度的控制，UPS电源的选择等等。</p><p>Raid的构成和分类，独立硬盘冗余阵列 Raid0、Raid1、Raid2、Raid3、Raid4、Raid5、Raid6、Raid10、Raid50、Raid100等，根据情况不同，选择不同的配置，但是2、4、6好像很少用，而比较中庸的Raid5是常常出现的选择，可以容忍一块硬盘损坏，出现问题后，将损坏的硬盘取下，换上Dell原装硬盘可以自动重建。</p><p>gitlab备份和还原，解决git库迁移是lfs check出错的问题，svn服务器备份，svn在linux环境下保存密码，Linux查看硬件配置dmidecode，查看硬盘信息，第一次完成硬盘挂载，虚拟机向物理机同步数据，rysnc-daemon模式的配置。</p><p>docker环境下搭建jenkins，gitlab，svn等，docker虽然可以挂在硬盘保证数据不丢失，但是如果出现镜像内访问外部服务实现起来会比较麻烦，如果访问镜像内原本没有的程序也比较麻烦，举个例子，用docker搭建gitlab，只对外提供访问，可以很方便的实现，也能快速升级，但是docker搭建jenkins就很麻烦了，单独的jenkins镜像缺少某些特定工具，并且作为打包环境需要经常访问其他的服务，放在容器中我感觉不太方便。</p><p>在一天之内接触了4种苹果类型的设备，这是之前都没碰过的，iMac、Mac Studio、Mac Mini、黑苹果，了解了Darwin名字的来源，Mac Os系统的变迁，我觉的“访达”这个对Finder的翻译非常棒，苹果打包所需的Unity和XCode的安装，jenkins-lts的安装，MacOs的开机启动程序，jenkins版本的替换，Java11的安装，Grooxy语法等。</p><p>服务器的迁移，注意应用程序目录的数据迁移，还有用户目录下各个隐藏文件的迁移，比如<code>.ssh</code>、<code>.subversion</code>、<code>.gitconfig</code> 等等，这决定你是否可以用新机器完全替代旧机器。</p><p>Microsoft  Intune的认证、Mac系统公司门户的认证，VPN远程访问，办公网、研发网，解决WOA无法登录问题，网络验证授权等。</p><!--go的更新最近两个月没有读书流量用了20多个G新知识，网络，raid，年中总结，2个月的忙碌gitlab备份svn备份raid5linux svn密码保存机器迁移，更新配置申请账号rysnc-daemonmacmini mac studio iMac 黑苹果Unity xcode groovywifi6虚拟机数据同步到物理机VPN远程访问，办公网、研发网解决WOA无法登录问题邮件确认，外网IP推包网络拓扑网络验证Microsoft  IntunelfsSSD访达VLANIDracSmartBI--><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>2024年已经过半，突然间才发现今年已经过了26周，而最近的打卡清单缺惨不忍睹</li><li>辛苦奔忙的一个月让自己感觉力不从心，而最近过渡的一个月仿佛让自己又回到了备战上线时的强度</li><li>程序员的工作本来只费身体和脑子，最近接触的人有点多，感觉心也跟着累了</li><li>人际关系的积累不是一朝一夕能实现的，而技术知识的学习却可以速成，多总结吧</li></ul><p><img src="https://img-blog.csdnimg.cn/direct/4d3129f10247443f8e1aee3b2348362c.jpeg" alt="PerfecWorld"></p><hr><center><a href="https://blog.csdn.net/albertsh/article/details/139248122" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>但凡是由人操作的流程，都可以有一些例外，当你被告知仅能等待流程审批时，说明你还不够硬，起码没有硬到可以帮你特批的地步~</p><p>2024-6-30 22:45:56</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;突然意识到过完这个周末已经7月份了，他预示着我的2024年已经过半了，过年回家仿佛还是昨天的事情，怎么转眼间已经到了年中了。心里还是不愿承认这件事，翻开自己2024年的打卡清单，列表显示已经到了26周，从另一方面证明了年中这条线已经到来，再看看打卡清单上这惨不忍睹的“成果”，真的有点难以接受。&lt;/p&gt;
    
    </summary>
    
      <category term="Thinking" scheme="http://AlbertGithubHome.github.io/blog/categories/Thinking/"/>
    
    
      <category term="年中" scheme="http://AlbertGithubHome.github.io/blog/tags/%E5%B9%B4%E4%B8%AD/"/>
    
      <category term="2024" scheme="http://AlbertGithubHome.github.io/blog/tags/2024/"/>
    
      <category term="离职" scheme="http://AlbertGithubHome.github.io/blog/tags/%E7%A6%BB%E8%81%8C/"/>
    
      <category term="新起点" scheme="http://AlbertGithubHome.github.io/blog/tags/%E6%96%B0%E8%B5%B7%E7%82%B9/"/>
    
      <category term="人际关系" scheme="http://AlbertGithubHome.github.io/blog/tags/%E4%BA%BA%E9%99%85%E5%85%B3%E7%B3%BB/"/>
    
  </entry>
  
  <entry>
    <title>有关服务器安全的反思</title>
    <link href="http://AlbertGithubHome.github.io/blog/2024/05/28/%E6%9C%89%E5%85%B3%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%89%E5%85%A8%E7%9A%84%E5%8F%8D%E6%80%9D/"/>
    <id>http://AlbertGithubHome.github.io/blog/2024/05/28/有关服务器安全的反思/</id>
    <published>2024-05-27T17:30:00.000Z</published>
    <updated>2024-07-20T14:20:44.102Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>人都说学的越多，不懂的东西也就越多，很多人都会有这个感受，面对信息爆炸的互联网时代，有种“学不完，根本学不完”沧桑无力感，最近有关服务器安全的了解又扩展了我的知识面，填补了部分认知盲区，究竟什么是服务器安全？</p><a id="more"></a><h1 id="MySQL数据库的安全"><a href="#MySQL数据库的安全" class="headerlink" title="MySQL数据库的安全"></a>MySQL数据库的安全</h1><p>这是前段时间的疑问，<a href="https://blog.csdn.net/albertsh/article/details/133655454" target="_blank" rel="noopener">《linux环境下如果掌控了系统root账户就能对上面安装的MySQL数据为所欲为了吗》</a>，当时出现这个疑问是因为安装完MySQL数据库，提示我有这样一样配置文件 /etc/mysql/debian.cnf，打开文件内容展示如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># Automatically generated for Debian scripts. DO NOT TOUCH!</span><br><span class="line">[client]</span><br><span class="line">host     = localhost</span><br><span class="line">user     = debian-sys-maint</span><br><span class="line">password = xg9vyvjNly3vUSsm</span><br><span class="line">socket   = /var/run/mysqld/mysqld.sock</span><br><span class="line">[mysql_upgrade]</span><br><span class="line">host     = localhost</span><br><span class="line">user     = debian-sys-maint</span><br><span class="line">password = xg9vyvjNly3vUSsm</span><br><span class="line">socket   = /var/run/mysqld/mysqld.sock</span><br></pre></td></tr></table></figure><p>明明白白的写着用户名和密码，当时感觉不可思议，这数据库不是轻松就被破解了吗？事实确实如此，因为你是root用户，即便没有这个配置文件，你也可以通过修改MySQL配置重启服务来跳过密码，所以如果你拿到root密码，那么你就是这服务器世界的主宰，你就可以为所欲为。</p><h1 id="物理服务器"><a href="#物理服务器" class="headerlink" title="物理服务器"></a>物理服务器</h1><p>假设你没有服务器root用户密码，或者忘记了服务器root密码要怎么办呢？你可以在开机的时候按e修改grub的kernel行到single模式下，就可以轻易获得root权限，并且能够改root密码，有没有颠覆你的认知。什么？任何人只要重启下服务器就把我的root密码改了？这是真的吗？这确实是真的。</p><p>下面我摘录了一些网友的回复，挺逗的，但仔细想想说的很有道理</p><blockquote><p>能接触到物理机的，都别说什么安全</p><p>这个事吧，放在机房的玩意有个不成文的规矩：能物理摸到的设备都允许你重置密码。</p><p>90年代的一句老话：能物理摸到设备的人，都可以看作是这台设备的主人。</p><p>Linux：我就是一个软件，你搞物理袭击，讲武德吗？</p><p>退一万步说，就算在机器旁边也不能重设密码，那把硬盘拆了拿回去不也一样？</p><p>物理安全是信息安全的基础。摸到你机器了，还谈什么安全。</p><p>日常运维或者使用当中需要面临的更大的挑战是丢失了，改错了密码。从我的经验来看，丢失密码的机会比丢失硬件的机会大至少100倍</p><p>比如海底电缆可以被剪断，怎么保证安全性？</p></blockquote><p>为什么要这样设计呢？仔细想想也能明白个大概，就是能触碰到物理机的人一定默认拥有所有权，他去改密码一定是到了不得不改的情况，如果你非说改密码的人是偷偷进去的，那是保安的责任，Linux系统不背这个锅！</p><blockquote><p>机器设计有一个规矩就是机器的物理持有者对机器拥有事实上的超管理员权限。比如说路由器背后的reset。比如说主板cmos清除针。因为事实上，管理员忘记密码往往比密码受到黑客攻击更常见，造成的损失也更大。至于提数据加密的，那是另一个话题，我们这里说的是操作权。黑客无法窃取你用bitlocker加密的数据，但这不妨碍他把你数据删光，所以从这个角度上，bitlocker不能保证你的数据安全，它保证的只是不泄密。</p></blockquote><p>所以看到这些是不是就释然了，系统保证的安全是建立在物理机安全的基础之上的，连机器都在人家手里，还谈什么安全呢？</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>在Linux系统上如果登录了root用户就可以为所欲为进入任何一个MySQL数据库</li><li>如果摸到了物理服务器默认你就是它的主人，你可以通过很便捷的方式来修改它的密码</li><li>物理安全是信息安全基础，Linux就是一个软件，你搞物理偷袭它可扛不住</li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/138507927" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>凡是人总有取舍，你取了你认为重要的东西，舍弃了我，这只是你的选择而已，若是我因为没有被选择，就心生怨恨，那这世界岂不是有太多不可原谅之处，毕竟谁也没有责任要以我为先，以我为重，无论我如何希望也不能强求。</p><p>2024-5-27 21:16:17</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;人都说学的越多，不懂的东西也就越多，很多人都会有这个感受，面对信息爆炸的互联网时代，有种“学不完，根本学不完”沧桑无力感，最近有关服务器安全的了解又扩展了我的知识面，填补了部分认知盲区，究竟什么是服务器安全？&lt;/p&gt;
    
    </summary>
    
      <category term="Thinking" scheme="http://AlbertGithubHome.github.io/blog/categories/Thinking/"/>
    
    
      <category term="linux" scheme="http://AlbertGithubHome.github.io/blog/tags/linux/"/>
    
      <category term="root" scheme="http://AlbertGithubHome.github.io/blog/tags/root/"/>
    
      <category term="安全" scheme="http://AlbertGithubHome.github.io/blog/tags/%E5%AE%89%E5%85%A8/"/>
    
      <category term="密码" scheme="http://AlbertGithubHome.github.io/blog/tags/%E5%AF%86%E7%A0%81/"/>
    
      <category term="物理机" scheme="http://AlbertGithubHome.github.io/blog/tags/%E7%89%A9%E7%90%86%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>面对AI你到底能做什么？怎样能让其为我所用</title>
    <link href="http://AlbertGithubHome.github.io/blog/2024/05/07/%E9%9D%A2%E5%AF%B9AI%E4%BD%A0%E5%88%B0%E5%BA%95%E8%83%BD%E5%81%9A%E4%BB%80%E4%B9%88%EF%BC%9F%E6%80%8E%E6%A0%B7%E8%83%BD%E8%AE%A9%E5%85%B6%E4%B8%BA%E6%88%91%E6%89%80%E7%94%A8/"/>
    <id>http://AlbertGithubHome.github.io/blog/2024/05/07/面对AI你到底能做什么？怎样能让其为我所用/</id>
    <published>2024-05-06T18:15:00.000Z</published>
    <updated>2024-07-20T14:17:20.284Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>面对AI铺天盖地的新闻，大有替代万事万物的之势，但如果要问AI能做什么？你是否会在心里打个问号？它好像只能用来聊天，又好像什么都能做，ChatGPT现在是我每天都要使用的工具，每天只是对话问问题，特定领域的问题确实比搜索引擎更精准一些，但是对AI的使用也就仅限于此，难道AI只有这么大点能力吗？</p><a id="more"></a><p>仔细想想不是的，起码还有Midjourney这个生成图的应用，还有Sora 这个文本转视频的工具，但是在这些工具出现之前我怎么就没想到呢？我们是不是可以抛弃这种被动使用的局面，自动动手做一些AI方面的应用呢？答案是肯定的，之前没做出来是因为我们没有这样想过，一旦开了这个头，你会发现AI真的可以做很多东西！</p><h1 id="思路引导"><a href="#思路引导" class="headerlink" title="思路引导"></a>思路引导</h1><p>究竟怎么开始呢？先得找到需求，然后实现需求。作为一个程序员我们就从程序编码的例子出手，我们都会算两个数的加法，一开始数据比较小，需求计算的总量也比较小，所以口算、笔算都能满足需求，随着应用场景的增加，数据量也越来越大，那么人工计算就有些力不从心了。</p><p>这时作为以懒著称的程序员转了转脑筋，干脆实现一个加法计算器吧，需要计算时我把两个数字输入进去，直接就能得到结果，大大加快了计算速度</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num1, num2;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"请输入两个整数："</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; num1 &gt;&gt; num2;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"两数之和为："</span> &lt;&lt; add(num1, num2) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们使用已经掌握的代码知识，解决了现有的需求，提高了工作效率，那么AI相关的应用要怎么样实现呢？</p><h1 id="为AI找活干"><a href="#为AI找活干" class="headerlink" title="为AI找活干"></a>为AI找活干</h1><p>在创建AI应用之前，我们先来想想AI的特点，或者局限一点，想想ChatGPT的特点：语言理解与知识问答、逻辑推理与数学问题解答、编程代码的理解与编写、智能教育产品、儿童英语教育等等，我们抓住其中一点，来完成我们的工作，比如语言理解。</p><p>想想在学校时是否经常需要总结文章大意？看材料时是否经常需要概括全文思想？这些事不正是AI所擅长的吗，如果我们偷懒会把要总结的内容告诉ChatGPT，让它帮我们总结一下，第二天又有这个题目，再次告诉ChatGPT，让它帮我们总结一下，有没有发现？我们又陷入了经常做重复工作的情景，怎么抽象出一个需求呢？</p><p>需求就是：实现一个应用，接受输入一段文字，20个字概括文字内容的大意，要求总结文字通俗易懂、言简意赅</p><p>这仿佛变成了我们上面的<code>add</code>函数，只是总结的过程是调用AI来完成的，我们只需要输入一段文字就能得到总结性输出，去除了中间多余的人工步骤</p><h1 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h1><p>面对这个AI需求，我们可以利用ChatGPT的API接口从头搭建一个接受输入和返回输出的应用，类似实现一个 <code>add</code> 函数，也可以利用一些开放平台的能力，比如 <a href="https://www.xfyun.cn/" target="_blank" rel="noopener">讯飞开放平台</a>，通过低代码的形式来快速搭建AI应用。</p><ul><li>登录讯飞星火SparkDesk产品<a href="https://xinghuo.xfyun.cn/desk" target="_blank" rel="noopener">首页</a>，在左上角，点击进入“助手中心”<br><img src="https://img-blog.csdnimg.cn/direct/6ee9cfa8ba7546aba337f0da93e90c2b.png#pic_center" alt="xunfei1"></li><li><p>在星火助手中心页面，点击右上方“助手创作中心”<br><img src="https://img-blog.csdnimg.cn/direct/95919ca5bc2645abbb784a21342ace3c.png#pic_center" alt="xunfei2"></p></li><li><p>在助手创作中心，点击“立即创建”，进入新建助手页面，开始创建助手的创建之旅<br><img src="https://img-blog.csdnimg.cn/direct/a869dad0b7e8400d8bb806c067c11fcf.png#pic_center" alt="xunfei3"><br><img src="https://img-blog.csdnimg.cn/direct/ed5d089212be432c8fd4c0addce29dde.png#pic_center" alt="xunfei4"></p></li><li>接下来的内容就自己探索吧，根据需求在左侧填写内容，右侧可以进行调试，觉得运行还不错的话可以点击创建按钮，也可以上架后给更多人使用<img src="https://img-blog.csdnimg.cn/direct/9aa164798c26477e957f4ec970ce316d.png#pic_center" alt="xunfei5"><br>至此，一个利用AI特点制作的应用就完成了，虽然很简单，但是开启了一个怎样使用AI的时代，话说我之前真不知道怎么用AI，做平台的这些人脑子真是太灵光了</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>AI不是万能的，要学会利用AI，合理掌控AI为我所用</li><li>利用AI庞大知识库的特点，进一步封装成特定的应用，可以更好的满足需求</li><li>完事开头难，有时不是你不会，只是你不知，一旦开了头便打开了一扇窗</li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/138169455" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>面对未知的状况，每个人心里都会有些小九九，根据自己的状况做出合适的选择，一旦选了便不需再回头，水有舟可渡，山有路可行~</p><p>2024-5-6 21:41:21</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;面对AI铺天盖地的新闻，大有替代万事万物的之势，但如果要问AI能做什么？你是否会在心里打个问号？它好像只能用来聊天，又好像什么都能做，ChatGPT现在是我每天都要使用的工具，每天只是对话问问题，特定领域的问题确实比搜索引擎更精准一些，但是对AI的使用也就仅限于此，难道AI只有这么大点能力吗？&lt;/p&gt;
    
    </summary>
    
      <category term="AI" scheme="http://AlbertGithubHome.github.io/blog/categories/AI/"/>
    
    
      <category term="人工智能" scheme="http://AlbertGithubHome.github.io/blog/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
      <category term="AI" scheme="http://AlbertGithubHome.github.io/blog/tags/AI/"/>
    
      <category term="Thinking" scheme="http://AlbertGithubHome.github.io/blog/tags/Thinking/"/>
    
      <category term="卖铲子" scheme="http://AlbertGithubHome.github.io/blog/tags/%E5%8D%96%E9%93%B2%E5%AD%90/"/>
    
  </entry>
  
  <entry>
    <title>帧同步入门项目LockstepDemo的初步学习</title>
    <link href="http://AlbertGithubHome.github.io/blog/2024/04/25/%E5%B8%A7%E5%90%8C%E6%AD%A5%E5%85%A5%E9%97%A8%E9%A1%B9%E7%9B%AELockstepDemo%E7%9A%84%E5%88%9D%E6%AD%A5%E5%AD%A6%E4%B9%A0/"/>
    <id>http://AlbertGithubHome.github.io/blog/2024/04/25/帧同步入门项目LockstepDemo的初步学习/</id>
    <published>2024-04-24T17:00:00.000Z</published>
    <updated>2024-04-29T14:56:38.580Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>上一篇文章介绍了 <a href="https://github.com/ookcode/LockstepDemo" target="_blank" rel="noopener">LockstepDemo</a> 这个项目可以作为帧同步入门读物，解决了跨域限制的问题以后，这个开源项目就可以运行起来啦，虽然我没有使用js写过实际的项目，但看的多了自然也能看懂大部分的js代码了，作为一个帧同步领域的小白，我开始了阅读这个项目代码的旅程，看过之后确实解开了我之前的迷惑，所以简单记录一下学习心得。</p><ul><li>基础的帧同步模式，每个客户端必须回报给服务器收到帧数，服务器再次发送确认包才执行帧数据，否则所有人等待，也就是一卡全卡。</li><li>基于现在手游的流行程度和弱网环境，手游一般都采取乐观锁模式。即收到服务器推帧后，客户端立即执行，不等待其他人。这样卡顿的人自己卡，不影响其他人的游戏体验。同时卡顿的人在收到数据后，自行加速补帧来追赶上正确的游戏速度。</li></ul><a id="more"></a><h2 id="连帧同步都出SDK了"><a href="#连帧同步都出SDK了" class="headerlink" title="连帧同步都出SDK了"></a>连帧同步都出SDK了</h2><p>插播一条消息，今天在搜索帧同步资料的时候，无意间发现了游戏巨头——腾讯居然发布了<a href="https://gcloud.tencent.com/pages/documents/details.html?projectId=208&amp;docId=3013" target="_blank" rel="noopener">帧同步SDK-LockStep</a>，简直“丧心病狂”，真的是盘子大了什么都做啊，不过也挺好，我可以从中学到不少问题的处理方案，我摘抄官方文档部分内容，感兴趣的可以去看看</p><blockquote><p>帧同步（LockStep）服务为手游开发提供一套快速、可靠的帧同步游戏开发框架。基于GCloud云服务<br>进行快速部署，同时支持TCP、UDP、RUDP三种通道。帧同步开发框架提供一致性数学库与一致性检测工具，并且针对弱网设计具有高可靠、低延时的特性。</p><p>帧同步与更为传统的状态同步均为游戏常见同步方案，主要区别在于：状态同步主要逻辑计算放在服务器端，将计算结果下发给客户端；而帧同步服务器仅仅起到收集客户端输入并广播的作用。基于帧同步相对状态同步流量消耗更低、开发效率更高、打击感更好等优点，《王者荣耀》选择了帧同步方案。</p><p>《拳皇命运》项目从完全不熟悉帧同步技术的情况下，接入SDK仅用了两个月时间，将原有状态同步游戏，改造成为帧同步游戏；项目仅需编写游戏逻辑，无需关心同步、网络品质、录像回放等核心功能。</p></blockquote><p>专业的事情交给专业的人来做，如果之前没有积累，将这套SDK直接拿过来用也是不错的，我看到支持C++和C#两种语言，其他的语言就得自己去沟通了</p><h1 id="LockstepDemo"><a href="#LockstepDemo" class="headerlink" title="LockstepDemo"></a>LockstepDemo</h1><p>言归正传，开始阅读LockstepDemo这个项目的源码，服务端app.js使用node运行，前端main.js+main.css+index.html，在浏览器中运行，其实主要的逻辑代码就在main.js中，后端就只有app.js一个文件，总共166行，前端还引用了jquery.min.js和socket.io.js两个库文件，但包含主要逻辑代码的main.js文件仅有328行。</p><p>在开始阅读自定义逻辑代码之前先来看看引用的这两个库：</p><h2 id="socket-io-js"><a href="#socket-io-js" class="headerlink" title="socket.io.js"></a>socket.io.js</h2><p>负责网络的建立、管理，消息的发送等等，看了逻辑中的调用真的是挺方便的</p><ul><li><code>var io = require(&quot;socket.io&quot;)(server）</code>: 创建基于 Node.js 的 WebSocket 服务器，并将其绑定到了一个 HTTP 服务器实例 server 上</li><li><code>io.on(&#39;connection&#39;, function (socket) {...])</code>: 使用Socket.IO 的服务器实例的 on 方法来监听客户端与服务器建立连接的事件</li><li><code>socket.on(&#39;join&#39;, function(account) {...})</code>: 使用与客户端建立的连接的对象 socket 的 on 方法来监听客户端发送的 ‘join’ 事件</li><li><code>socket.emit(&quot;open&quot;, {...})</code>: 使用了 Socket.IO 库的 emit 方法来向当前客户端发送一个名为 “open” 的自定义事件，并附带自定义对象作为数据</li><li><code>socket.broadcast.emit(&#39;system&#39;, ...)</code>: 用于向除当前连接的客户端之外的所有客户端发送消息</li><li><code>io.sockets.emit(&#39;start&#39;, {...})</code>: 用于向所有连接的客户端发送消息</li></ul><h2 id="jquery-min-js"><a href="#jquery-min-js" class="headerlink" title="jquery.min.js"></a>jquery.min.js</h2><p>即使没有做过前端，jQuery这个库的大名也应该听过，它是一个流行的 JavaScript 库，简化了在网页开发中的 JavaScript 编程。它提供了一系列功能强大且易于使用的 API，使得诸如 DOM 操作、事件处理、动画效果、AJAX 请求等任务变得更加简单和高效，主要特点如下：</p><ul><li>简化 DOM 操作：提供了简洁而强大的 DOM 操作方法，使得选择元素、修改元素属性、添加/删除元素等操作变得更加便捷</li><li>事件处理：提供了简单易用的事件处理方法，可以方便地为元素绑定事件、移除事件、触发事件等，大大简化了事件处理的代码编写</li><li>动画效果：提供了丰富的动画效果和特效，可以通过简单的方法实现页面元素的平滑过渡、淡入淡出、滑动等效果，为用户提供更流畅的交互体验</li><li>AJAX 请求：提供了简洁的 AJAX 方法，可以方便地进行异步数据加载和交互，从而实现更灵活和动态的网页内容加载和更新</li><li>跨浏览器兼容性：封装了复杂的跨浏览器兼容性处理，使得开发者可以更加轻松地编写跨浏览器兼容的代码</li></ul><p>简单来说它就是一个封装了常用操作的库，稍后会在main.js发现它的使用方法，简单摘录如下：</p><ul><li><strong>文档加载完成事件</strong>：<code>$(function () {...})</code> 用于在文档加载完成后执行的函数，这是 jQuery 的快捷方式，等同于 <code>$(document).ready(function() {...})</code>，表示在 DOM 树构建完成后执行指定的函数</li><li><strong>元素选择</strong>：<code>$(&#39;body&#39;)</code>、<code>$(&#39;#start_btn&#39;)</code>、<code>$(&#39;#reconnect_btn&#39;)</code> 等通过 jQuery 选择器选择了 HTML 元素。这些选择器能够基于元素的标签名、ID、类名等来选择元素，返回 jQuery 对象，以便进行后续的操作</li><li><strong>事件处理</strong>：<code>$(&#39;body&#39;).keydown(function(e) {...})</code> 注册了键盘事件处理函数，当键盘按键按下时执行相应的操作</li><li><strong>动画效果</strong>：<code>$(&quot;#tips&quot;).animate({...})</code> 使用了 jQuery 的动画效果，在提示框显示时执行动画效果，让提示框从屏幕中间上方滑动到屏幕中间</li><li><strong>样式操作</strong>：<code>$(&quot;#tips&quot;).show()</code>、<code>$(&quot;#tips&quot;).fadeOut()</code> 等使用了 jQuery 提供的方法来控制元素的显示和隐藏</li></ul><p>在阅读app.js和main.js之前还是得说明一下，今天只介绍核心逻辑，像断线重连、消息提示、显示网络延迟等功能，都是在核心逻辑上的补充和优化，可以先忽略不看，并且这次看代码发现，整个运动的表现和实现逻辑是符合牛顿第一定律的，真的挺有意思：</p><blockquote><p>一切物体总保持匀速直线运动状态或静止状态，直到有外力迫使它改变这种状态为止</p></blockquote><p>这只是这个项目的特点，并不是所有的游戏都是这样的，有些游戏的实现就是和这惯性定律相违背的，比如很多游戏必须一直拖动摇杆才会移动，否则就会停住静止，它们所表达出来的就是，“力是维持物体运动的关键”，好了，扯得有点远了，一起看看代码实现吧</p><h2 id="服务器app-js"><a href="#服务器app-js" class="headerlink" title="服务器app.js"></a>服务器app.js</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> server = <span class="built_in">require</span>(<span class="string">'http'</span>).Server()</span><br><span class="line"><span class="keyword">var</span> io = <span class="built_in">require</span>(<span class="string">"socket.io"</span>)(server, &#123;</span><br><span class="line">    allowEIO3: <span class="literal">true</span>,</span><br><span class="line">    cors: &#123;</span><br><span class="line">      origin: [<span class="string">"http://127.0.0.1:8080"</span>, <span class="string">"null"</span>],</span><br><span class="line">      methods: [<span class="string">"GET"</span>, <span class="string">"POST"</span>],</span><br><span class="line">      credentials: <span class="literal">true</span> <span class="comment">// 设置为true以允许使用凭据</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听3000端口</span></span><br><span class="line">server.listen(<span class="number">3000</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">"服务器启动成功，监听端口3000"</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>定义服务器实例，启动并监听3000端口，这里已经做了跨域允许访问的配置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> g_onlines = &#123;&#125; <span class="comment">// 所有在线玩家</span></span><br><span class="line"><span class="keyword">var</span> g_commands = <span class="keyword">new</span> <span class="built_in">Array</span>() <span class="comment">// 指令数组</span></span><br><span class="line"><span class="keyword">var</span> g_commands_histroy = <span class="keyword">new</span> <span class="built_in">Array</span>() <span class="comment">// 历史指令，用于断线重连</span></span><br><span class="line"><span class="keyword">var</span> g_joinCount = <span class="number">0</span> <span class="comment">// 已准备的人数</span></span><br><span class="line"><span class="keyword">var</span> g_maxJoinCount = <span class="number">2</span> <span class="comment">// 最大人数</span></span><br><span class="line"><span class="keyword">var</span> g_stepTime = <span class="number">0</span> <span class="comment">// 当前step时间戳</span></span><br><span class="line"><span class="keyword">var</span> g_stepInterval = <span class="number">100</span> <span class="comment">// 每个step的间隔ms</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 游戏状态枚举</span></span><br><span class="line"><span class="keyword">var</span> STATUS = &#123;</span><br><span class="line">   WAIT:<span class="number">1</span>,</span><br><span class="line">   START:<span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> g_gameStatus = STATUS.WAIT</span><br></pre></td></tr></table></figure><p>一些游戏全局变量和游戏状态枚举的定义，注释写的很详细，记一遍看下面的逻辑时能想起来就行</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// frame定时器</span></span><br><span class="line"><span class="keyword">var</span> stepUpdateCounter = <span class="number">0</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">update</span>(<span class="params">dt</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">var</span> now = <span class="built_in">Date</span>.now()</span><br><span class="line">   <span class="keyword">if</span>(g_gameStatus == STATUS.START) &#123;</span><br><span class="line">      stepUpdateCounter += dt</span><br><span class="line">      <span class="keyword">if</span>(stepUpdateCounter &gt;= g_stepInterval) &#123;</span><br><span class="line">         g_stepTime++</span><br><span class="line">         stepUpdate()</span><br><span class="line">         stepUpdateCounter -= g_stepInterval</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动定时器</span></span><br><span class="line"><span class="keyword">var</span> lastUpdate = <span class="built_in">Date</span>.now()</span><br><span class="line">setInterval(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="keyword">var</span> now = <span class="built_in">Date</span>.now()</span><br><span class="line">   <span class="keyword">var</span> dt = now - lastUpdate</span><br><span class="line">   lastUpdate = now</span><br><span class="line">   update(dt)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>开始进入主要逻辑，lastUpdate是上次走过的时间，在游戏开始<code>g_gameStatus == STATUS.START</code>后不断将 <code>dt</code> 积累到变量 <code>stepUpdateCounter</code>，超过一帧的间隔后执行一帧逻辑 <code>stepUpdate()</code>，<code>setInterval</code> 是内部函数，第二个参数表示调用的时间间隔，默认为0，可以可以认为是游戏中常用的 <code>tick()</code> 函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// step定时器</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">stepUpdate</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="comment">// 过滤同帧多次指令</span></span><br><span class="line">   <span class="keyword">var</span> message = &#123;&#125;</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> g_onlines) &#123;</span><br><span class="line">      message[key] = &#123;<span class="attr">step</span>:g_stepTime, <span class="attr">id</span>:key&#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; g_commands.length; ++i) &#123;</span><br><span class="line">      <span class="keyword">var</span> command = g_commands[i]</span><br><span class="line">      command.step = g_stepTime</span><br><span class="line">      message[command.id] = command</span><br><span class="line">   &#125;</span><br><span class="line">   g_commands = <span class="keyword">new</span> <span class="built_in">Array</span>()</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 发送指令</span></span><br><span class="line">   <span class="keyword">var</span> commands = <span class="keyword">new</span> <span class="built_in">Array</span>()</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> message) &#123;</span><br><span class="line">      commands.push(message[key])</span><br><span class="line">   &#125;</span><br><span class="line">   g_commands_histroy.push(commands)</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> g_onlines) &#123;</span><br><span class="line">      g_onlines[key].socket.emit(<span class="string">'message'</span>, <span class="keyword">new</span> <span class="built_in">Array</span>(commands))</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是转发客户端操作的核心函数，首先是遍历所有玩家 <code>g_onlines</code>，执行 <code>message[key] = {step:g_stepTime, id:key}</code> 为每个玩家构建一个空指令，然后遍历当前收到的所有命令 <code>g_commands</code>，将命令的帧值设置为当前帧，并且过掉一帧中的多个指令，保证一帧只能朝一个方向运动，将收集到的所有指令 <code>commands</code> 通过 <code>socket.emit()</code> 函数发送给所有玩家 <code>g_onlines</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">io.on(<span class="string">'connection'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">socket</span>) </span>&#123;</span><br><span class="line">   socket.emit(<span class="string">"open"</span>, &#123;<span class="attr">id</span>:socket.id, <span class="attr">stepInterval</span>:g_stepInterval&#125;)</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 获取用户账户</span></span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">getAccount</span>(<span class="params">socketId</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> g_onlines) &#123;</span><br><span class="line">         <span class="keyword">if</span>(socketId == g_onlines[key].socket.id) &#123;</span><br><span class="line">            <span class="keyword">return</span> key</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这是服务器上所有事件监听的基础，<code>io</code> 监听新玩家连接事件，建立连接后向客户端发送一个名为 “open” 的自定义事件，并附带了一个包含 id 和 stepInterval 属性的对象作为数据，id的值是 <code>socket.id</code>，<code>stepInterval</code>表示每帧的时间间隔，<code>getAccount()</code> 函数的作用通过<code>socket.id</code>获取账号名</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">socket.on(<span class="string">'join'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">account</span>) </span>&#123;</span><br><span class="line">   <span class="comment">// 顶号/断线重连</span></span><br><span class="line">   <span class="keyword">if</span>(g_onlines[account]) &#123;</span><br><span class="line">      g_onlines[account].socket.emit(<span class="string">'system'</span>, <span class="string">"被顶号了"</span>)</span><br><span class="line">      g_onlines[account].socket.disconnect()</span><br><span class="line">      <span class="keyword">if</span>(g_gameStatus == STATUS.START) &#123;</span><br><span class="line">         g_onlines[account] = &#123;<span class="attr">socket</span>: socket, <span class="attr">online</span>: <span class="literal">true</span>&#125;</span><br><span class="line">         socket.emit(<span class="string">'join'</span>, &#123;<span class="attr">result</span>:<span class="literal">true</span>, <span class="attr">message</span>:<span class="string">"正在断线重连..."</span>&#125;)</span><br><span class="line">         <span class="built_in">console</span>.log(account, <span class="string">"重连游戏"</span>)</span><br><span class="line">         socket.broadcast.emit(<span class="string">'system'</span>, account + <span class="string">"重新连接！"</span>)</span><br><span class="line">         socket.emit(<span class="string">'start'</span>, &#123;<span class="attr">player</span>:<span class="built_in">Object</span>.keys(g_onlines)&#125;)</span><br><span class="line">         socket.emit(<span class="string">'message'</span>, g_commands_histroy)</span><br><span class="line">         <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 房间已满</span></span><br><span class="line">   <span class="keyword">if</span>(g_joinCount == g_maxJoinCount) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"房间已满"</span>, account, <span class="string">"加入失败"</span>)</span><br><span class="line">      socket.emit(<span class="string">'system'</span>, <span class="string">"房间已满"</span>)</span><br><span class="line">      socket.disconnect()</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 加入游戏</span></span><br><span class="line">   <span class="keyword">if</span>(g_joinCount &lt; g_maxJoinCount) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(account, <span class="string">"加入游戏"</span>)</span><br><span class="line">      socket.emit(<span class="string">'join'</span>, &#123;<span class="attr">result</span>:<span class="literal">true</span>, <span class="attr">message</span>:<span class="string">"匹配中..."</span>&#125;)</span><br><span class="line">      g_onlines[account] = &#123;<span class="attr">socket</span>: socket, <span class="attr">online</span>: <span class="literal">true</span>&#125;</span><br><span class="line">      g_joinCount++</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 开始游戏</span></span><br><span class="line">   <span class="keyword">if</span>(g_joinCount == g_maxJoinCount) &#123;</span><br><span class="line">      g_commands = <span class="keyword">new</span> <span class="built_in">Array</span>()</span><br><span class="line">      g_commands_histroy = <span class="keyword">new</span> <span class="built_in">Array</span>()</span><br><span class="line">      g_gameStatus = STATUS.START</span><br><span class="line">      io.sockets.emit(<span class="string">'start'</span>, &#123;<span class="attr">player</span>:<span class="built_in">Object</span>.keys(g_onlines)&#125;)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这是监听socket收到 <code>&#39;join&#39;</code> 事件的处理函数，实现逻辑有些技巧，通过查询账号是否已经登录过服务器，来判定是否为重连，如果为重连则一次发送 <code>&#39;join&#39;</code>、<code>&#39;start&#39;</code>、<code>&#39;message&#39;</code>事件和数据，其中 <code>&#39;message&#39;</code> 事件中的数据是从游戏开始以来的所有指令</p><p>如果不是重连就要判断匹配人数，超过到 <code>g_maxJoinCount</code> 不允许进入，达到<code>g_maxJoinCount</code>游戏开始，通知客户开始游戏，否则通知客户端正在匹配中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">socket.on(<span class="string">'timeSync'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">time</span>) </span>&#123;</span><br><span class="line">   socket.emit(<span class="string">'timeSync'</span>, &#123;<span class="attr">client</span>:time, <span class="attr">server</span>:<span class="built_in">Date</span>.now()&#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">socket.on(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">json</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(g_gameStatus == STATUS.START) &#123;</span><br><span class="line">      <span class="comment">// <span class="doctag">TODO:</span>过滤高延迟的包 (json.step)</span></span><br><span class="line">      json.id = getAccount(socket.id)</span><br><span class="line">      <span class="keyword">if</span>(json.id) &#123;</span><br><span class="line">         g_commands.push(json)</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><code>socket.on(&#39;timeSync&#39;, function(time) {...})</code> 收到后立即返回，用于客户端计算延迟，<code>socket.on(&#39;message&#39;, function(json) {...})</code>，收到客户端指令后将其放入全局缓存指令，等待每帧处理</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">socket.on(<span class="string">'disconnect'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="keyword">var</span> account = getAccount(socket.id)</span><br><span class="line">   <span class="keyword">if</span>(account) &#123;</span><br><span class="line">      g_onlines[account].online = <span class="literal">false</span></span><br><span class="line">      <span class="built_in">console</span>.log(account, <span class="string">"离开游戏"</span>)</span><br><span class="line">      <span class="keyword">var</span> isGameOver = <span class="literal">true</span></span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> g_onlines) &#123;</span><br><span class="line">         <span class="keyword">if</span>(g_onlines[key].online) &#123;</span><br><span class="line">            isGameOver = <span class="literal">false</span></span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(isGameOver) &#123;</span><br><span class="line">         io.sockets.emit(<span class="string">'system'</span>, <span class="string">"游戏结束"</span>)</span><br><span class="line">         g_joinCount = <span class="number">0</span></span><br><span class="line">         g_stepTime = <span class="number">0</span></span><br><span class="line">         g_gameStatus = STATUS.WAIT</span><br><span class="line">         g_onlines = &#123;&#125;</span><br><span class="line">         <span class="built_in">console</span>.log(<span class="string">"游戏结束"</span>)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         io.sockets.emit(<span class="string">'system'</span>, account + <span class="string">"离开了游戏！"</span>)</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><code>socket.on(&#39;disconnect&#39;, function () {...})</code> 断开连接是否要结束游戏的处理逻辑，如果在玩家断开后还有其他玩家在线，则游戏继续，等待玩家重连回来，否则有些结束</p><p>完整的游戏代码就这么多，还是比较清晰的，记住服务器上监听和发送的各种事件，比如 <code>&#39;join&#39;</code>、<code>&#39;start&#39;</code>、<code>&#39;message&#39;</code>、<code>&#39;disconnect&#39;</code> 等，一会再客户端代码分析的时候也会出现，对照着分析逻辑就串起来了</p><h2 id="客户端main-js"><a href="#客户端main-js" class="headerlink" title="客户端main.js"></a>客户端main.js</h2><p>客户端的代码行数相对多一些，我只把重要的部分列举出来：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 游戏对象</span></span><br><span class="line"><span class="keyword">var</span> GameObject = <span class="function"><span class="keyword">function</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">this</span>.id = id</span><br><span class="line">   <span class="keyword">this</span>.x = <span class="number">0</span></span><br><span class="line">   <span class="keyword">this</span>.y = <span class="number">0</span></span><br><span class="line">   <span class="keyword">this</span>.direction = DIRECTION.STOP</span><br><span class="line">   <span class="keyword">this</span>.speed = <span class="number">100</span></span><br><span class="line">   <span class="keyword">this</span>.move = <span class="function"><span class="keyword">function</span> (<span class="params">dt</span>) </span>&#123;</span><br><span class="line">      dt = dt / <span class="number">1000</span></span><br><span class="line">      <span class="keyword">var</span> x = <span class="keyword">this</span>.x</span><br><span class="line">      <span class="keyword">var</span> y = <span class="keyword">this</span>.y</span><br><span class="line">      <span class="keyword">switch</span>(<span class="keyword">this</span>.direction) &#123;</span><br><span class="line">         <span class="keyword">case</span> DIRECTION.UP:</span><br><span class="line">         &#123;</span><br><span class="line">            y -= <span class="keyword">this</span>.speed * dt</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">case</span> DIRECTION.DOWN:</span><br><span class="line">         &#123;</span><br><span class="line">            y += <span class="keyword">this</span>.speed * dt</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">case</span> DIRECTION.LEFT:</span><br><span class="line">         &#123;</span><br><span class="line">            x -= <span class="keyword">this</span>.speed * dt</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">case</span> DIRECTION.RIGHT:</span><br><span class="line">         &#123;</span><br><span class="line">            x += <span class="keyword">this</span>.speed * dt</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(x &lt;= (WIDTH - BOX_SIZE) &amp;&amp; x &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">         <span class="keyword">this</span>.x = x</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(y &lt;= (HEIGHT - BOX_SIZE) &amp;&amp; y &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">         <span class="keyword">this</span>.y = y</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码定义了一个函数，该函数可以用来创建游戏对象（Game Objects）的实例，在 JavaScript 中，函数也可以用来定义对象的构造函数。在这个例子中，函数 <code>GameObject</code> 就是一个构造函数，用于创建具有特定属性和方法的游戏对象。当你使用 <code>new GameObject(id)</code> 来调用这个函数时，它会返回一个新的对象实例，该实例拥有指定的 <code>id</code>、<code>x</code>、<code>y</code>、<code>direction</code>、<code>speed</code> 属性以及 <code>move()</code> 方法，尽管这段代码中的 <code>GameObject</code> 是一个函数，但它被设计用来创建具有特定属性和行为的对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="comment">// 画布</span></span><br><span class="line">   <span class="keyword">var</span> context = <span class="built_in">document</span>.getElementById(<span class="string">"canvas"</span>).getContext(<span class="string">"2d"</span>)</span><br><span class="line">   <span class="comment">// 每个step的间隔ms，服务器返回</span></span><br><span class="line">   <span class="keyword">var</span> stepInterval = <span class="number">0</span></span><br><span class="line">   <span class="comment">// 当前step时间戳</span></span><br><span class="line">   <span class="keyword">var</span> stepTime = <span class="number">0</span></span><br><span class="line">   <span class="comment">// 输入方向</span></span><br><span class="line">   <span class="keyword">var</span> inputDirection = <span class="literal">null</span></span><br><span class="line">   <span class="comment">// 游戏状态</span></span><br><span class="line">   <span class="keyword">var</span> gameStatus = STATUS.WAIT</span><br><span class="line">   <span class="comment">// 接受指令</span></span><br><span class="line">   <span class="keyword">var</span> recvCommands = <span class="keyword">new</span> <span class="built_in">Array</span>()</span><br><span class="line">   <span class="comment">// 所有游戏对象</span></span><br><span class="line">   <span class="keyword">var</span> gameObjects = &#123;&#125;</span><br><span class="line">   <span class="comment">// 是否连接socket</span></span><br><span class="line">   <span class="keyword">var</span> isConnected = <span class="literal">false</span></span><br><span class="line">   <span class="comment">// 当前执行中的指令</span></span><br><span class="line">   <span class="keyword">var</span> runningCommands = <span class="literal">null</span></span><br><span class="line">   <span class="comment">// 当前用户</span></span><br><span class="line">   <span class="keyword">var</span> currentAccount = <span class="literal">null</span></span><br><span class="line">   <span class="comment">// 是否正在加速运行延迟到达的包</span></span><br><span class="line">   <span class="keyword">var</span> isFastRunning = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 初始化UI显示</span></span><br><span class="line">   $(<span class="string">"#content"</span>).hide()</span><br><span class="line">   $(<span class="string">"#login"</span>).show()</span><br><span class="line">   $(<span class="string">"#tips"</span>).hide()</span><br><span class="line"></span><br><span class="line">   <span class="comment">//...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这是利用jQuery库的写法，等同于 <code>$(document).ready(function() {...})</code>，表示在 DOM 树构建完成后执行指定的函数，也就是每次加载完页面都会执行这个函数，这个函数里包含了客户端绝大部分逻辑，函数的开始定义了一些变量，用于记录游戏数据，具体含义参考注释即可，之后便初始化了界面显示</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 连接socket</span></span><br><span class="line">socket = io.connect(<span class="string">'http://127.0.0.1:3000'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// socket连接成功</span></span><br><span class="line">socket.on(<span class="string">'open'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">json</span>) </span>&#123;</span><br><span class="line">   isConnected = <span class="literal">true</span></span><br><span class="line">   stepInterval = json.stepInterval</span><br><span class="line">   id = json.id</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">"Socket连接成功："</span>, id)</span><br><span class="line">   <span class="comment">// 断线重连自动登录</span></span><br><span class="line">   <span class="keyword">if</span>(localStorage.account) &#123;</span><br><span class="line">      setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">         $(<span class="string">"#account"</span>).val(localStorage.account)</span><br><span class="line">         localStorage.account = <span class="string">""</span></span><br><span class="line">         $(<span class="string">'#start_btn'</span>).click()</span><br><span class="line">      &#125;, <span class="number">0</span>)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>使用 <code>socket = io.connect(&#39;http://127.0.0.1:3000&#39;)</code> 语句连接服务器，再接收到 <code>&#39;open&#39;</code> 事件之后，使用服务器同步数据给客户端变量赋值，函数末尾是根据本地存储情况决定是否需要重连，这部分逻辑可以先不看</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 收到游戏开始事件</span></span><br><span class="line">socket.on(<span class="string">'start'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">json</span>) </span>&#123;</span><br><span class="line">   <span class="comment">// 初始化GameObject</span></span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; json.player.length; ++i) &#123;</span><br><span class="line">      <span class="keyword">var</span> id = json.player[i]</span><br><span class="line">      gameObjects[id] = <span class="keyword">new</span> GameObject(id)</span><br><span class="line">   &#125;</span><br><span class="line">   gameStatus = STATUS.START</span><br><span class="line">   stepTime = <span class="number">0</span></span><br><span class="line">   showTips(<span class="string">"游戏开始"</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 收到指令</span></span><br><span class="line">socket.on(<span class="string">'message'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">json</span>)</span>&#123;</span><br><span class="line">   <span class="comment">// 储存收到的指令</span></span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; json.length; ++i) &#123;</span><br><span class="line">      <span class="keyword">var</span> command = json[i]</span><br><span class="line">      recvCommands.push(command)</span><br><span class="line">      stepTime = command[command.length - <span class="number">1</span>].step</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"**** recv "</span> + stepTime + <span class="string">" ****"</span>)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>收到游戏开始事件<code>&#39;start&#39;</code>之后，根据服务器下发的数据创建游戏对象 <code>gameObjects[id] = new GameObject(id)</code>， 收到<code>&#39;message&#39;</code>缓存服务器发送的指令到 <code>recvCommands</code> 中，后续在tick函数中处理</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发送指令</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sendCommand</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(isFastRunning) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"正在加速执行延迟包，无法发送指令！"</span>)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">var</span> direction = inputDirection</span><br><span class="line">   socket.emit(<span class="string">"message"</span>, &#123;</span><br><span class="line">      direction: direction,</span><br><span class="line">      step:stepTime,</span><br><span class="line">   &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 键盘事件</span></span><br><span class="line">$(<span class="string">'body'</span>).keydown(<span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(gameStatus != STATUS.START) <span class="keyword">return</span></span><br><span class="line">   <span class="keyword">switch</span>(e.keyCode) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">38</span>:</span><br><span class="line">      &#123;</span><br><span class="line">         inputDirection = DIRECTION.UP</span><br><span class="line">         <span class="keyword">break</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">40</span>:</span><br><span class="line">      &#123;</span><br><span class="line">         inputDirection = DIRECTION.DOWN</span><br><span class="line">         <span class="keyword">break</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">37</span>:</span><br><span class="line">      &#123;</span><br><span class="line">         inputDirection = DIRECTION.LEFT</span><br><span class="line">         <span class="keyword">break</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">39</span>:</span><br><span class="line">      &#123;</span><br><span class="line">         inputDirection = DIRECTION.RIGHT</span><br><span class="line">         <span class="keyword">break</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">13</span>:</span><br><span class="line">      &#123;</span><br><span class="line">         inputDirection = DIRECTION.STOP</span><br><span class="line">         <span class="keyword">break</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   sendCommand()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>监听键盘按键，键盘上下左右键移动方块，回车键停止方块，每次将按键指令发送给服务器，重点看下这段实现，这就涉及到我们前边提到的牛顿第一定律，也就是每次按键时向服务器发送一次，可以改变物体的运动方向或者停止，之后便不再向服务器发消息了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// frame定时器</span></span><br><span class="line"><span class="keyword">var</span> stepUpdateCounter = <span class="number">0</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">update</span>(<span class="params">dt</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(gameStatus == STATUS.START) &#123;</span><br><span class="line">      <span class="comment">// <span class="doctag">TODO:</span> 逻辑/UI分离</span></span><br><span class="line">      stepUpdateCounter += dt</span><br><span class="line">      <span class="keyword">if</span>(stepUpdateCounter &gt;= stepInterval) &#123;</span><br><span class="line">         stepUpdate()</span><br><span class="line">         stepUpdateCounter -= stepInterval</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 积攒的包过多时要加速运行</span></span><br><span class="line">      <span class="keyword">var</span> scale = <span class="built_in">Math</span>.ceil(recvCommands.length / <span class="number">3</span>)</span><br><span class="line">      <span class="keyword">if</span>(scale &gt; <span class="number">10</span>) scale = <span class="number">10</span></span><br><span class="line">      isFastRunning = (scale &gt; <span class="number">1</span>)</span><br><span class="line">      <span class="comment">// 执行指令</span></span><br><span class="line">      <span class="keyword">if</span>(recvCommands.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">         <span class="keyword">var</span> ms = dt * scale</span><br><span class="line">         <span class="keyword">if</span>(runningCommands == <span class="literal">null</span>) &#123;</span><br><span class="line">            runningCommands = recvCommands[<span class="number">0</span>]</span><br><span class="line">            runningCommands.ms = stepInterval</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span>(runningCommands.ms &lt; ms) &#123;</span><br><span class="line">            ms = runningCommands.ms</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; runningCommands.length; i++) &#123;</span><br><span class="line">            <span class="keyword">var</span> command = runningCommands[i]</span><br><span class="line">            <span class="keyword">if</span>(runningCommands.ms == stepInterval) <span class="built_in">console</span>.log(command)</span><br><span class="line">            <span class="keyword">var</span> obj = gameObjects[command.id]</span><br><span class="line">            <span class="keyword">if</span>(command.direction) &#123;</span><br><span class="line">               obj.direction = command.direction</span><br><span class="line">            &#125;</span><br><span class="line">            obj.move(ms)</span><br><span class="line">         &#125;</span><br><span class="line">         runningCommands.ms = runningCommands.ms - ms</span><br><span class="line">         <span class="keyword">if</span>(runningCommands.ms == <span class="number">0</span>) &#123;</span><br><span class="line">            recvCommands.shift()</span><br><span class="line">            runningCommands = <span class="literal">null</span></span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 绘制</span></span><br><span class="line">      context.clearRect(<span class="number">0</span>, <span class="number">0</span>, WIDTH, HEIGHT)</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> gameObjects) &#123;</span><br><span class="line">         <span class="keyword">var</span> obj = gameObjects[key]</span><br><span class="line">         context.fillStyle = <span class="string">"#000000"</span></span><br><span class="line">         context.fillRect(obj.x, obj.y, BOX_SIZE, BOX_SIZE)</span><br><span class="line">         context.font = <span class="string">"15px Courier New"</span>;</span><br><span class="line">         context.fillStyle = <span class="string">"#FFFFFF"</span>;</span><br><span class="line">         context.fillText(key, obj.x, obj.y + BOX_SIZE, BOX_SIZE);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动定时器</span></span><br><span class="line"><span class="keyword">var</span> lastUpdate = <span class="built_in">Date</span>.now()</span><br><span class="line">setInterval(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="keyword">var</span> now = <span class="built_in">Date</span>.now()</span><br><span class="line">   <span class="keyword">var</span> dt = now - lastUpdate</span><br><span class="line">   lastUpdate = now</span><br><span class="line">   update(dt)</span><br><span class="line">   <span class="keyword">if</span>(isConnected == <span class="literal">true</span>) &#123;</span><br><span class="line">      socket.emit(<span class="string">"timeSync"</span>, now)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这段代码是客户端的核心逻辑，需要多看几遍，看懂了这一段，帧同步的思想也就基本算掌握了，调用 <code>setInterval</code> 的逻辑比较好理解，之前在服务器代码中也存在，就是启动tick函数，不断积累 <code>dt</code>，用于做客户端物体移动的表现</p><p>重点在 <code>setInterval</code> 我们化繁为简，不用看函数末尾的绘制部分，这一段就是根据GameObject的坐标绘制图形，因为这个项目没有实现UI表现和逻辑分离，所以函数开始更新变量 <code>stepUpdateCounter</code>的逻辑也没有用，简化完成后函数逻辑就剩下这些：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">update</span>(<span class="params">dt</span>) </span>&#123;</span><br><span class="line">   <span class="comment">// 积攒的包过多时要加速运行</span></span><br><span class="line">   <span class="keyword">var</span> scale = <span class="built_in">Math</span>.ceil(recvCommands.length / <span class="number">3</span>)</span><br><span class="line">   <span class="keyword">if</span>(scale &gt; <span class="number">10</span>) scale = <span class="number">10</span></span><br><span class="line">   isFastRunning = (scale &gt; <span class="number">1</span>)</span><br><span class="line">   <span class="comment">// 执行指令</span></span><br><span class="line">   <span class="keyword">if</span>(recvCommands.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">var</span> ms = dt * scale</span><br><span class="line">      <span class="keyword">if</span>(runningCommands == <span class="literal">null</span>) &#123;</span><br><span class="line">         runningCommands = recvCommands[<span class="number">0</span>]</span><br><span class="line">         runningCommands.ms = stepInterval</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(runningCommands.ms &lt; ms) &#123;</span><br><span class="line">         ms = runningCommands.ms</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; runningCommands.length; i++) &#123;</span><br><span class="line">         <span class="keyword">var</span> command = runningCommands[i]</span><br><span class="line">         <span class="keyword">if</span>(runningCommands.ms == stepInterval) <span class="built_in">console</span>.log(command)</span><br><span class="line">         <span class="keyword">var</span> obj = gameObjects[command.id]</span><br><span class="line">         <span class="keyword">if</span>(command.direction) &#123;</span><br><span class="line">            obj.direction = command.direction</span><br><span class="line">         &#125;</span><br><span class="line">         obj.move(ms)</span><br><span class="line">      &#125;</span><br><span class="line">      runningCommands.ms = runningCommands.ms - ms</span><br><span class="line">      <span class="keyword">if</span>(runningCommands.ms == <span class="number">0</span>) &#123;</span><br><span class="line">         recvCommands.shift()</span><br><span class="line">         runningCommands = <span class="literal">null</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意这个参数 <code>dt</code> 很微妙，虽然传入的值是tick实际的时间间隔，但分析完代码你会发现这个dt传入任意值，因为真正调用<code>obj.move</code>函数进行移动出入的参数是 <code>ms</code>，当 <code>ms</code> 等于 <code>dt</code> 时，是正常播放，当 <code>ms</code> &gt; <code>dt</code> 时，是加速播放，当 <code>ms</code> &lt; <code>dt</code> 时是减速播放，这里的代码只存在加速和正常两种情况</p><p>看到没有，你可以通过 <code>scale</code> 变量人为的改变时间的快慢，是不是很神奇，所以在帧同步中绝对顺序是靠帧数来决定的，而物理时间只是一个数字，想快就快，想慢就慢</p><p>思考下为什么会有这个判断 <code>if(runningCommands.ms &lt; ms) { ms = runningCommands.ms }</code>, 它的含义是无论你怎么加速，每个指令执行时间不能超过一帧的时间间隔，不然就和正常播放的逻辑数据不一致了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(command.direction) &#123;</span><br><span class="line">   obj.direction = command.direction</span><br><span class="line">&#125;</span><br><span class="line">obj.move(ms)</span><br></pre></td></tr></table></figure><p>这几句比较有意思，翻译过来就是如果命令我改变方向，那么我就改变方向后移动，否则我按照原来的方向移动或者保持静止，再想想是不是惯性定律？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">runningCommands.ms = runningCommands.ms - ms</span><br><span class="line"><span class="keyword">if</span>(runningCommands.ms == <span class="number">0</span>) &#123;</span><br><span class="line">   recvCommands.shift()</span><br><span class="line">   runningCommands = <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后这几句处理的是一个tick跑不完一帧时间间隔的情况，逐个tick改变物体坐标，其实就是一个指令运行一帧的分段表现</p><p>好了，写到这里基本上也讲完了，有什么疑问欢迎交流哈，我要睡觉去了</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>严格的帧同步，服务器必须等待所有客户端上报帧数才会下发当前帧命令，会造成一卡全卡</li><li>乐观锁模式，服务器不等，会定时推帧，卡顿的人在收到数据后，自行加速补帧来追赶上正确的游戏速度</li><li>一切物体总保持匀速直线运动状态或静止状态，直到有外力迫使它改变这种状态为止</li><li>在帧同步中绝对顺序是靠帧数来决定的，而物理时间只是一个数字，想快就快，想慢就慢</li><li>对于UDP丢包问题，上行采用重发3次，下行采用根据网络情况在2次到9次范围内调整</li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/138139329" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>纵有千古，横有八荒，沧海一粟，还妄图超脱三界吗？</p><p>2024-4-24 20:47:44</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;上一篇文章介绍了 &lt;a href=&quot;https://github.com/ookcode/LockstepDemo&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LockstepDemo&lt;/a&gt; 这个项目可以作为帧同步入门读物，解决了跨域限制的问题以后，这个开源项目就可以运行起来啦，虽然我没有使用js写过实际的项目，但看的多了自然也能看懂大部分的js代码了，作为一个帧同步领域的小白，我开始了阅读这个项目代码的旅程，看过之后确实解开了我之前的迷惑，所以简单记录一下学习心得。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;基础的帧同步模式，每个客户端必须回报给服务器收到帧数，服务器再次发送确认包才执行帧数据，否则所有人等待，也就是一卡全卡。&lt;/li&gt;
&lt;li&gt;基于现在手游的流行程度和弱网环境，手游一般都采取乐观锁模式。即收到服务器推帧后，客户端立即执行，不等待其他人。这样卡顿的人自己卡，不影响其他人的游戏体验。同时卡顿的人在收到数据后，自行加速补帧来追赶上正确的游戏速度。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="LockStep" scheme="http://AlbertGithubHome.github.io/blog/categories/LockStep/"/>
    
    
      <category term="Lockstep" scheme="http://AlbertGithubHome.github.io/blog/tags/Lockstep/"/>
    
      <category term="帧同步" scheme="http://AlbertGithubHome.github.io/blog/tags/%E5%B8%A7%E5%90%8C%E6%AD%A5/"/>
    
      <category term="js" scheme="http://AlbertGithubHome.github.io/blog/tags/js/"/>
    
      <category term="demo" scheme="http://AlbertGithubHome.github.io/blog/tags/demo/"/>
    
      <category term="源码分析" scheme="http://AlbertGithubHome.github.io/blog/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>帧同步入门之日遭遇CORS（跨域资源共享）问题的暴击</title>
    <link href="http://AlbertGithubHome.github.io/blog/2024/04/24/%E5%B8%A7%E5%90%8C%E6%AD%A5%E5%85%A5%E9%97%A8%E4%B9%8B%E6%97%A5%E9%81%AD%E9%81%87CORS%EF%BC%88%E8%B7%A8%E5%9F%9F%E8%B5%84%E6%BA%90%E5%85%B1%E4%BA%AB%EF%BC%89%E9%97%AE%E9%A2%98%E7%9A%84%E6%9A%B4%E5%87%BB/"/>
    <id>http://AlbertGithubHome.github.io/blog/2024/04/24/帧同步入门之日遭遇CORS（跨域资源共享）问题的暴击/</id>
    <published>2024-04-24T12:55:59.000Z</published>
    <updated>2024-04-29T14:56:41.451Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>工作以来的每个游戏项目都是用的状态同步，所以一直想找时间看一下帧同步的实现细节，网上搜到了一些开源项目，有cocos的、有Unity的，有原生C#的，大多数项目作为入门资料来看都比较重，虽然定点数计算、UDP加速这些已经成为了帧同步策略的标配，但是对于一个初学者来说，这些内容的引入无疑增加了学习成本，所以我还是想找一款帧同步纯逻辑实现的代码，后来发现 <a href="https://github.com/ookcode/LockstepDemo" target="_blank" rel="noopener">LockstepDemo</a> 这个项目还不错，那就从它开始学吧。</p><a id="more"></a><h2 id="可以学习的帧同步项目"><a href="#可以学习的帧同步项目" class="headerlink" title="可以学习的帧同步项目"></a>可以学习的帧同步项目</h2><ul><li><a href="https://github.com/ahuangege/lockstep" target="_blank" rel="noopener">ahuangege/lockstep</a> ：cocos creator客户端demo</li><li><a href="https://github.com/dudu502/LittleBee" target="_blank" rel="noopener">dudu502/LittleBee</a> ：Unity客户端，相当绚丽的演示demo</li><li><a href="https://github.com/Zealous-w/LockStep" target="_blank" rel="noopener">Zealous-w/LockStep</a> ：C++实现，内容较少</li><li><a href="https://github.com/JiepengTan/Lockstep-Tutorial" target="_blank" rel="noopener">JiepengTan/Lockstep-Tutorial</a> ：Unity客户端，较为复杂，太重度</li><li><a href="https://github.com/wechat-miniprogram/minigame-lockstep-demo" target="_blank" rel="noopener">minigame-lockstep-demo</a> ：小游戏帧同步服务配套示例，js实现</li><li><a href="https://github.com/ookcode/LockstepDemo" target="_blank" rel="noopener">ookcode/LockstepDemo</a> ：js+html实现，网页作为前端，浏览器就可运行，个人认为很适合初学者</li></ul><h1 id="LockstepDemo"><a href="#LockstepDemo" class="headerlink" title="LockstepDemo"></a>LockstepDemo</h1><p>这个项目比较轻量，如何运行Readme中写的很清楚：</p><ul><li><p>服务端</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> server</span><br><span class="line">$ npm install</span><br><span class="line">$ node app.js</span><br></pre></td></tr></table></figure></li><li><p>客户端（也可使用任意方法启动一个web服务）</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> client</span><br><span class="line">$ python3 -m http.server 8080</span><br></pre></td></tr></table></figure></li><li><p>启动完成后访问：<a href="http://127.0.0.1:8080/" target="_blank" rel="noopener">http://127.0.0.1:8080/</a></p></li></ul><h2 id="大概的原理"><a href="#大概的原理" class="headerlink" title="大概的原理"></a>大概的原理</h2><p>利用node运行app.js监听3000作为服务器，然后启动监听8080端口的web服务，浏览器访问web页面作为客户端，来展示CS架构下的帧同步</p><p>打开两个浏览器都访问这个页面，登录后就匹配成功了，操作简单，演示方便，真是入门必备读物，但是到这里不出意外的情况下，要出意外了</p><p>我打开界面输入用户名之后提示我“连接服务器失败！”，真是醉了</p><h2 id="查找问题"><a href="#查找问题" class="headerlink" title="查找问题"></a>查找问题</h2><p>幸好我还有一段网站开发的经历，所以熟练的按下F12打开了浏览器的调试页面，看到了如下报错</p><blockquote><p>Access to XMLHttpRequest at ‘<a href="http://127.0.0.1:3000/socket.io/?EIO=3&amp;transport=polling&amp;t=OyAd7iL" target="_blank" rel="noopener">http://127.0.0.1:3000/socket.io/?EIO=3&amp;transport=polling&amp;t=OyAd7iL</a>‘ from origin ‘<a href="http://127.0.0.1:8080" target="_blank" rel="noopener">http://127.0.0.1:8080</a>‘ has been blocked by CORS policy: No ‘Access-Control-Allow-Origin’ header is present on the requested resource.<br>GET <a href="http://127.0.0.1:3000/socket.io/?EIO=3&amp;transport=polling&amp;t=OyAd7iL" target="_blank" rel="noopener">http://127.0.0.1:3000/socket.io/?EIO=3&amp;transport=polling&amp;t=OyAd7iL</a> net::ERR_FAILED 400 (Bad Request)</p></blockquote><p>这个报错什么意思呢？就是说从’<a href="http://127.0.0.1:8080" target="_blank" rel="noopener">http://127.0.0.1:8080</a>‘ 发起的原始请求在访问’<a href="http://127.0.0.1:3000" target="_blank" rel="noopener">http://127.0.0.1:3000</a>‘ 时，其地址并不在访问资源允许的地址范围内，这个问题有个很常见的名字——跨域问题</p><p>好在前段时间做小游戏解决过跨域问题（其实第一次遇到这个问题在小游戏之前，先积累了经验才在小游戏中解决了这个问题），基本上知道朝哪个方向修改，所以一切还在可控范围之内，不过为了记录的全面一点，还是单独解释下跨域问题</p><h1 id="CORS跨域问题"><a href="#CORS跨域问题" class="headerlink" title="CORS跨域问题"></a>CORS跨域问题</h1><p>跨域问题的英文简写是 “CORS”，全称是 “Cross-Origin Resource Sharing”，是一种用于在不同源之间共享资源的机制。”源”是由协议（如 http 或 https）、主机名和端口号组成的组合，如果两个 URL 的这三个部分都相同，那么它们属于相同的源。</p><p>在 Web 开发中，浏览器会实施同源策略，这是一种安全机制，用于防止在一个网页的上下文中加载的资源（例如 JavaScript、CSS、图像等）去访问另一个不同源的资源。换句话说，网页只能访问与其自身相同源的资源，不能直接访问其他源的资源。</p><p>CORS 提供了一种机制，允许服务器声明哪些源的请求是被允许的，以及允许在响应中附加一些特定的头信息来告诉浏览器是否允许跨源请求。如果服务器允许跨源请求，浏览器将允许网页访问该资源，并将响应头中包含的额外信息传递给网页的 JavaScript。</p><p><strong>跨域限制是浏览器行为，不是服务器行为</strong>（看你个人理解，服务器只是配合，可以什么都不做），通过代理服务器，或者其他工具发送请求就能轻松绕过。</p><p>因为浏览器使用门槛非常低，为了防止别有用心的人攻击普通用户，所以引入同源策略。服务器间没有跨域这种说法，使用和破解难度较大，就交给用户自己防备了。</p><p>浏览器的同源策略，对于不同源的站点之间的相互请求会做限制，具体限制了以下行为：</p><ul><li>Cookie、LocalStorage 和 IndexDB 无法读取</li><li>DOM 和 JS 对象无法获取</li><li>Ajax请求发送不出去</li></ul><p>跨域资源共享（CORS）的目的之一就是在允许跨源资源共享的同时保证安全性。如果不限制跨域，可能会引发以下安全问题：</p><ul><li>跨站脚本攻击（XSS）： 恶意网站可以在用户访问时向另一个网站发送请求，并执行在受害者浏览器中执行恶意脚本，从而窃取用户的敏感信息、篡改页面内容或执行其他恶意操作。</li><li>跨站请求伪造（CSRF）： 恶意网站可以伪造请求，利用用户在其他网站上的登录状态，发送未经用户授权的请求，例如修改用户信息、发起转账等。</li><li>信息泄露： 恶意网站可以发送跨域请求，并读取其他网站的敏感信息，例如 Cookie、本地存储、IndexedDB 中的数据，从而获取用户的个人信息或其他敏感数据。</li><li>点击劫持： 恶意网站可以通过嵌入透明的 iframe 将另一个网站的页面覆盖在自己的页面上，并诱使用户在不知情的情况下点击覆盖的页面上的按钮或链接，执行未经用户授权的操作。</li><li>缓存投毒： 恶意网站可以通过发送恶意请求并利用缓存投毒技术来污染浏览器的缓存，从而在用户之后访问相同资源时执行恶意代码。</li><li>数据冒充和篡改： 恶意网站可以发送伪造的请求，并篡改或冒充其他网站的数据，例如修改在线购物网站的购物车内容。</li></ul><p>说到这里可能还迷迷糊糊的，举个具体点的例子吧，如果觉得不对尽可以来喷，我改就是了：</p><p>假如你访问了一个恶意网站，如果没有同源策略，恶意网站可以向一个你已经登录的敏感信息上网站发送http请求，因为带着你的cookie信息，可以直接获取敏感数据，但有同源策略，这种行为就被浏览器限制住了，在服务器端不需要做任何设置就能实现。</p><p>但是如果A网站和B网站是兄弟网站，B网站的资源允许A网站访问，那么就可以在B网站的服务器上将A网站域名配置成可以跨域访问的origin，这样就可以了</p><h1 id="解决跨域问题"><a href="#解决跨域问题" class="headerlink" title="解决跨域问题"></a>解决跨域问题</h1><p>说了这么多，下面要开始解决问题了，从前面解释来看，这个问题应该在服务器上处理，也就是在 <code>http://127.0.0.1:3000</code> 上允许 <code>http://127.0.0.1:8080</code> 就行了</p><p>找到 <code>LockstepDemo/server/app.js</code> 文件，其中服务器部分是这样定义的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> server = <span class="built_in">require</span>(<span class="string">'http'</span>).Server()</span><br><span class="line"><span class="keyword">var</span> io = <span class="built_in">require</span>(<span class="string">'socket.io'</span>)(server)</span><br></pre></td></tr></table></figure><p>改为如下写法，允许所有跨域请求，注意 <code>origin</code> 字段的值：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> server = <span class="built_in">require</span>(<span class="string">'http'</span>).Server()</span><br><span class="line"><span class="keyword">var</span> io = <span class="built_in">require</span>(<span class="string">"socket.io"</span>)(server, &#123;</span><br><span class="line">    allowEIO3: <span class="literal">true</span>,</span><br><span class="line">    cors: &#123;</span><br><span class="line">      origin: <span class="string">"*"</span>,</span><br><span class="line">      methods: [<span class="string">"GET"</span>, <span class="string">"POST"</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>依旧报错</p><blockquote><p>Access to XMLHttpRequest at ‘<a href="http://127.0.0.1:3000/socket.io/?EIO=3&amp;transport=polling&amp;t=OyAeQnU" target="_blank" rel="noopener">http://127.0.0.1:3000/socket.io/?EIO=3&amp;transport=polling&amp;t=OyAeQnU</a>‘ from origin ‘<a href="http://127.0.0.1:8080" target="_blank" rel="noopener">http://127.0.0.1:8080</a>‘ has been blocked by CORS policy: The value of the ‘Access-Control-Allow-Origin’ header in the response must not be the wildcard ‘*‘ when the request’s credentials mode is ‘include’. The credentials mode of requests initiated by the XMLHttpRequest is controlled by the withCredentials attribute.<br>GET <a href="http://127.0.0.1:3000/socket.io/?EIO=3&amp;transport=polling&amp;t=OyAeQnU" target="_blank" rel="noopener">http://127.0.0.1:3000/socket.io/?EIO=3&amp;transport=polling&amp;t=OyAeQnU</a> net::ERR_FAILED 200 (OK)</p></blockquote><p>根据CORS规范，当请求中包含凭据时，响应中的Access-Control-Allow-Origin头不能设置为通配符*，而必须指定允许请求的具体来源。</p><p>换句话说，如果你在客户端发起了带有凭据的请求（例如cookies或HTTP认证信息），服务器在响应中必须指定确切的来源，而不能使用通配符。</p><p>要解决这个问题，你需要在服务器端设置Access-Control-Allow-Origin头，将其设置为允许请求的确切来源。如果你的请求是来自特定的域（例如<a href="http://127.0.0.1:8080）" target="_blank" rel="noopener">http://127.0.0.1:8080）</a> ，那么你的服务器应该将Access-Control-Allow-Origin头设置为该域，修改如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> server = <span class="built_in">require</span>(<span class="string">'http'</span>).Server()</span><br><span class="line"><span class="keyword">var</span> io = <span class="built_in">require</span>(<span class="string">"socket.io"</span>)(server, &#123;</span><br><span class="line">    allowEIO3: <span class="literal">true</span>,</span><br><span class="line">    cors: &#123;</span><br><span class="line">      origin: <span class="string">"http://127.0.0.1:8080"</span>,</span><br><span class="line">      methods: [<span class="string">"GET"</span>, <span class="string">"POST"</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>还是报错</p><blockquote><p>Access to XMLHttpRequest at ‘<a href="http://127.0.0.1:3000/socket.io/?EIO=3&amp;transport=polling&amp;t=OyAgWOx" target="_blank" rel="noopener">http://127.0.0.1:3000/socket.io/?EIO=3&amp;transport=polling&amp;t=OyAgWOx</a>‘ from origin ‘<a href="http://127.0.0.1:8080" target="_blank" rel="noopener">http://127.0.0.1:8080</a>‘ has been blocked by CORS policy: The value of the ‘Access-Control-Allow-Credentials’ header in the response is ‘’ which must be ‘true’ when the request’s credentials mode is ‘include’. The credentials mode of requests initiated by the XMLHttpRequest is controlled by the withCredentials attribute.<br>socket.io.js:1456<br>GET <a href="http://127.0.0.1:3000/socket.io/?EIO=3&amp;transport=polling&amp;t=OyAgWOx" target="_blank" rel="noopener">http://127.0.0.1:3000/socket.io/?EIO=3&amp;transport=polling&amp;t=OyAgWOx</a> net::ERR_FAILED 200 (OK)</p></blockquote><p>这个错误表明在响应的Access-Control-Allow-Credentials头中设置了空字符串，而应该设置为true。这是因为当请求中包含凭据（例如使用了withCredentials属性），并且服务器允许使用凭据时，响应的Access-Control-Allow-Credentials头必须设置为true，修改如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> server = <span class="built_in">require</span>(<span class="string">'http'</span>).Server()</span><br><span class="line"><span class="keyword">var</span> io = <span class="built_in">require</span>(<span class="string">"socket.io"</span>)(server, &#123;</span><br><span class="line">    allowEIO3: <span class="literal">true</span>,</span><br><span class="line">    cors: &#123;</span><br><span class="line">      origin: <span class="string">"http://127.0.0.1:8080"</span>,</span><br><span class="line">      methods: [<span class="string">"GET"</span>, <span class="string">"POST"</span>],</span><br><span class="line">      credentials: <span class="literal">true</span> <span class="comment">// 设置为true以允许使用凭据</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这次再刷新页面，控制台打印信息“Socket连接成功： 0LLd8Rm9mO3zbOkZAAAD”</p><p>这个问题算解决了，这里指定了 <code>http://127.0.0.1:8080</code> 可以跨域访问，如果不是通过web服务，而是使用浏览器直接打开index.html文件，地址为 <code>file:///E:/WorkSpace/opensource/LockstepDemo/client/index.html</code>，还会出现以下错误：</p><blockquote><p>Access to XMLHttpRequest at ‘<a href="http://127.0.0.1:3000/socket.io/?EIO=3&amp;transport=polling&amp;t=OyAg_nn" target="_blank" rel="noopener">http://127.0.0.1:3000/socket.io/?EIO=3&amp;transport=polling&amp;t=OyAg_nn</a>‘ from origin ‘null’ has been blocked by CORS policy: The ‘Access-Control-Allow-Origin’ header has a value ‘<a href="http://127.0.0.1:8080" target="_blank" rel="noopener">http://127.0.0.1:8080</a>‘ that is not equal to the supplied origin.</p></blockquote><p>相信你也知道怎么改了，把 “null” 加到允许列表就行了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> server = <span class="built_in">require</span>(<span class="string">'http'</span>).Server()</span><br><span class="line"><span class="keyword">var</span> io = <span class="built_in">require</span>(<span class="string">"socket.io"</span>)(server, &#123;</span><br><span class="line">    allowEIO3: <span class="literal">true</span>,</span><br><span class="line">    cors: &#123;</span><br><span class="line">      origin: [<span class="string">"http://127.0.0.1:8080"</span>, <span class="string">"null"</span>],,</span><br><span class="line">      methods: [<span class="string">"GET"</span>, <span class="string">"POST"</span>],</span><br><span class="line">      credentials: <span class="literal">true</span> <span class="comment">// 设置为true以允许使用凭据</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>演示界面如下，还挺不错的，今天就先写到这，以后抽时间再分析代码</p><p><img src="https://img-blog.csdnimg.cn/direct/77db3d08faf34984aed51275184b2aca.png#pic_center" alt="demo"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li><a href="https://github.com/ookcode/LockstepDemo" target="_blank" rel="noopener">ookcode/LockstepDemo</a> 项目可作为帧同步入门教程</li><li>跨域限制是浏览器行为，不是服务器行为，服务器只是配合，可以什么都不做，想实现跨域可以让服务器参与配置</li><li><code>Access-Control-Allow-Origin</code> 和 <code>Access-Control-Allow-Origin</code> 都是跨域问题处理中常见字段，但不同语言中字段赋值形式不同</li><li>浏览器的同源策略是保护小白使用者的，在服务器间访问资源并不用遵守同源策略</li><li>这次尝试有一个问题没解决，就是怎样允许所有的跨域行为，origin配置成 <code>*</code>不行，说是客户端带有认证信息，但是我没找到在哪</li><li>客户端请求连接很简单 <code>socket = io.connect(&#39;http://127.0.0.1:3000&#39;)</code>，并未发现认证信息，有知道的大佬欢迎指出</li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/137091129" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>不同的维度品不同的人生，你认为你还在，我看你已经无了~</p><p>2024-4-23 21:33:52</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;工作以来的每个游戏项目都是用的状态同步，所以一直想找时间看一下帧同步的实现细节，网上搜到了一些开源项目，有cocos的、有Unity的，有原生C#的，大多数项目作为入门资料来看都比较重，虽然定点数计算、UDP加速这些已经成为了帧同步策略的标配，但是对于一个初学者来说，这些内容的引入无疑增加了学习成本，所以我还是想找一款帧同步纯逻辑实现的代码，后来发现 &lt;a href=&quot;https://github.com/ookcode/LockstepDemo&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LockstepDemo&lt;/a&gt; 这个项目还不错，那就从它开始学吧。&lt;/p&gt;
    
    </summary>
    
      <category term="LockStep" scheme="http://AlbertGithubHome.github.io/blog/categories/LockStep/"/>
    
    
      <category term="Lockstep" scheme="http://AlbertGithubHome.github.io/blog/tags/Lockstep/"/>
    
      <category term="CORS" scheme="http://AlbertGithubHome.github.io/blog/tags/CORS/"/>
    
      <category term="跨域" scheme="http://AlbertGithubHome.github.io/blog/tags/%E8%B7%A8%E5%9F%9F/"/>
    
      <category term="帧同步" scheme="http://AlbertGithubHome.github.io/blog/tags/%E5%B8%A7%E5%90%8C%E6%AD%A5/"/>
    
      <category term="js" scheme="http://AlbertGithubHome.github.io/blog/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>k8s小白的学习初体验</title>
    <link href="http://AlbertGithubHome.github.io/blog/2024/03/29/k8s%E5%B0%8F%E7%99%BD%E7%9A%84%E5%AD%A6%E4%B9%A0%E5%88%9D%E4%BD%93%E9%AA%8C/"/>
    <id>http://AlbertGithubHome.github.io/blog/2024/03/29/k8s小白的学习初体验/</id>
    <published>2024-03-29T02:04:18.000Z</published>
    <updated>2024-04-29T15:06:36.360Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>有些时候的巧合让人匪夷所思，前两周刚刚尝试了一遍Docker操作，紧接着就收到好朋友说要学习k8s容器部署的建议，最近两周抽空看了一些关于k8s的知识，相关概念真的是太多了，概念本身是枯燥的，但是当概念运行起来就有意思多了，这时候取出费曼学习大法，尝试着用自己的话来描述这些概念，看看自己是不是真的学会了。本文k8s相关概念均来自个人理解，后续随着学习深入可能会有改正，勿喷。</p><a id="more"></a><h1 id="学习资料"><a href="#学习资料" class="headerlink" title="学习资料"></a>学习资料</h1><p>找到一些官方文档和一些写的比较通俗的教程，再有疑问直接去官网查吧</p><ul><li><a href="https://kubernetes.io/zh-cn/docs/tutorials/kubernetes-basics/" target="_blank" rel="noopener">学习 Kubernetes 基础知识</a></li><li><a href="https://ranchermanager.docs.rancher.com/zh/" target="_blank" rel="noopener">什么是 Rancher？</a></li><li><a href="https://k8s.easydoc.net/docs/dRiQjyTY/28366845/6GiNOzyZ/9EX8Cp45" target="_blank" rel="noopener">Kubernetes（K8S）简介</a></li><li><a href="https://juejin.cn/column/6962026171823292452" target="_blank" rel="noopener">K8S学习教程</a></li></ul><h1 id="学到了什么"><a href="#学到了什么" class="headerlink" title="学到了什么"></a>学到了什么</h1><p>我就尝试用直白的语言来描述一下，不一定准确，听听看</p><p>ks8是<code>Kubernetes</code>的简称，<code>Rancher</code>是一个管理k8s的工具，可以操作k8s定义 <code>Deployment</code> 在 <code>Node</code> 上创建一系列包含若干 <code>Container</code> 的 <code>Pod</code>，也可以操作k8定义 <code>Service</code> 在指定 <code>Pod</code> 上建立统一对外的服务，<code>Deployment</code>、<code>Service</code>、<code>Node</code>、<code>Pod</code> 这些在k8s中被称为资源，为了便于管理可以划分到不同的 <code>Namespace</code> 中。</p><p>单单就这两句话包含了7、8个名词概念，要是把他们的定义列出来，保准得晕晕乎乎的，并且有些名词在不同的语境下有不同的含义，比如Docker是一个工具、是一个运行时、是一个平台等等，所以有些概念不结合具体的情景还真是说不清楚，我们还是来想想为什么出现这些东西吧。</p><p>当项目规模还小的时候，我们把程序放到服务器上运行起来就行了，简单方便，后来随着规模的扩大，部署的机器越来越多，发现机器资源分配不好控制，可能机器的大部分资源被某个应用占用，导致其他应用无法正常运行，无法做到应用隔离。</p><p>后来引入了虚拟机，虽然解决了资源控制问题，但在单个物理机上运行多个虚拟机，每个虚拟机都是完整独立的系统，性能损耗大，还有一个之前遗留的问题，就是运行环境的差异引发的问题常常使人焦头烂额，所以容器部署应运而生。</p><p>将运行程序和所依赖的环境打包成镜像，放到容器运行时上运行，可以保证所有程序的运行环境都一样，容器相比虚拟机性能损耗小，可实现资源隔离，CPU和内存可按需分配，所有容器共享主机的系统，最有名的要数Docker了</p><p>从这个角度来看docker或者容器运行时很像JVM，当年Java号称一次编写处处运行，靠的就是Java虚拟机，所有的Java源码会被编译成字节码，在不同平台上的JVM中被翻译中对应平台的指令，而Docker的身份和地位很像这个JVM，容器运行时可以在运行之前打包好的镜像，并且在不同的系统平台上模拟出目标平台的环境，来保证“一次打包处处运行”</p><p>现在知道了，我把应用程序和它依赖的运行环境打包成镜像，就可以在任何安装了Docker的机器上运行，不管这台机器是什么系统，这样就可以快速扩展程序规模了，但是新的问题还是会出现的</p><p>因为程序员太懒了，让他部署几个服务器还没啥问题，要是成百上千台服务器，每次扩展或更新都需要逐个拉取镜像、版本回滚、逐个启动，简直痛不欲生，在半夜被薅起来更新维护时还容易出错，所以这时候 Kubernetes 就诞生了，因其K和s中间有8个字母简称为k8s，它可以让你管理让你轻松管理成千上万台机器的集群，这些机器上的容器都归它管，一个命令就可以搞定版本升级、版本回滚等操作，还可以不停机的灰度更新，确保高可用、高性能、高扩展。</p><p>我的天，k8s都这么牛了，那 Rancher 又是啥？难道他比 k8s 还厉害，人类的懒惰是无极限的，k8s 虽然一个命令可以完成很多需求，但有些人就是一个命令也不想输啊，哈哈！</p><p>尽管 k8s 是一个强大的容器编排平台，可以同时管理集群中数以万计的机器，但人们为了方便还是开发了Rancher吗，它提供了用户友好的图形用户界面、RBAC（基于角色的访问控制）、日志和监控、多集群管理等，同时它还提供了一个集成的应用商店，其中包含了许多常用的容器化应用程序和工具，如数据库、监控、日志、CI/CD 等，通过 Rancher 的界面轻松部署这些应用程序，并与 Kubernetes 集群集成。</p><p>有些人用k8s为了方便部署和管理容器，而有些人只想更方便，选择了 Rancher 来管理看 k8s，之后会不会有人开发的新东西来管理 Rancher 呢，这有什么不可能的呢？</p><h1 id="概念白话文"><a href="#概念白话文" class="headerlink" title="概念白话文"></a>概念白话文</h1><p>前面提到了很多概念，也讲了一些有关这些东西的来历，接下来让我用自己的理解来说说这些名词到底指什么。</p><p><strong>镜像</strong>：最早听说这个词是系统镜像，将后缀为 <code>.iso</code> 的系统镜像文件刻录成光盘，或者烧制成U盘启动盘来安装系统，容器化中的镜像含义和系统镜像类似，就是用过用程序以及用于运行应用程序所需的所有依赖项打个包，称为镜像，它可以放到容器运行时中运行，相同的镜像可以重现相同的环境，就像相同的ISO文件会安装出相同的系统一样</p><p><strong>Docker</strong>：往大点说这是指一个容器化平台，当然也可以是一个软件，或者是一项技术规范，用它可以开发、打包、部署和运行应用程序。通过使用 Docker，开发人员可以将应用程序及其依赖项（如库、运行时环境等）打包成一个轻量级的容器，然后在任何支持 Docker 的环境中运行这个容器，而不用担心环境的差异性。简单点说，它是一个工具，可以打包一个镜像，也可以运行一个镜像</p><p><strong>Dockerfile</strong>：用来说明怎么打包镜像的，使用特定的描述性语言，告诉Docker怎么打包出一个镜像</p><p><strong>容器化</strong>：将引用程序和运行环境打包成镜像，并批量运行到其他容器运行时上的过程</p><p>镜像和容器的关系：镜像是 Docker 中用于打包应用程序及其依赖项的静态文件，是只读的，一旦构建完成就不能修改，容器是镜像的一个运行时实例，它可以被启动、停止、暂停、删除等操作。可以简单类比下 class 和 object 的关系</p><p><strong>k8s</strong>：为了管理和编排大量的容器而开发出来的工具，可以批量自动化的完成一些容器的操作，由他又引出了大量新的概念</p><p><strong>k3s</strong>：一个轻量级的 Kubernetes 发行版，体积小、资源消耗低，采用了更少的组件和依赖项，并且对 Kubernetes 的安装和配置进行了简化，使得部署和管理更加容易</p><p><strong>Pod</strong>：k8s调度、管理的最小单位，它包含一个或多个紧密关联的容器</p><p><strong>Node</strong>：是集群中的计算节点，有master主节点和worker工作节点之分，负责提供计算资源、网络和存储服务，可以是真实的物理机，也可以是运行在物理机上的虚拟机。</p><p><strong>Deployment</strong>: 是 k8s 中用于声明式管理 Pod 和 ReplicaSet 的控制器，可以认为是一个描述怎样使用 Pod 资源的规则，应用一个Deployment就是按照它的描述来组织和使用Pod</p><p><strong>Service</strong>：是 k8s 中用于提供对一组 Pod 的网络访问的抽象，可以将一组 Pod 绑定统一对外提供服务</p><p><strong>Namespace</strong>：k8s 中用于将资源分类的一个逻辑概念，类似于编程语言中的命名空间</p><p><strong>Docker Compose</strong>：与k8s同类，也是用于管理容器化应用程序的工具，但规模较小适用于小型项目和开发环境</p><p><strong>Rancher</strong>：一个开源的容器管理平台，拥有统一的可视化界面，可以同时管理多个k8s，括本地、云端或混合部署的集群</p><p><strong>Rancher Desktop</strong>：是一款用于本地开发的工具，基于K3s构建，旨在提供轻量级的开发环境，使开发人员能够轻松地在自己的计算机上进行容器化应用的开发和测试</p><p><strong>Workloads</strong>：工作负载，有哪些类型的活，包括Deployment（部署无状态Pod），StatefulSet（部署有状态Pod），DaemonSet（节点监控和日志收集），Job（一次性任务），CronJob（定时重复任务）</p><p><strong>组件</strong>：每个角色要干指定活所以需要配备的一些功能模块，比如每个 Node 都有Kubelet组件，会与k8s控制平面进行通信，接收指令来管理此Node 上的 Pod</p><p><strong>控制平面</strong>：运行在主节点上的集群的核心组件之一，负责管理集群的各种操作、监控集群状态，并确保集群的稳定运行，通常包含 <code>kube-apiserver</code>、<code>etcd</code>、<code>kube-controller-manager</code>、<code>kube-scheduler</code>、<code>cloud-controller-manager</code> 等</p><h1 id="一些疑问"><a href="#一些疑问" class="headerlink" title="一些疑问"></a>一些疑问</h1><ul><li><p>容器化是不是只能用Docker?</p><p>不是的，Docker只是实现容器化的一种可选的途径，只要实现了容器化标准的工具都可以实现容器化，作为容器运行时，比如 k8s 为了提高效率，减少不必要的开销，已经将默认的容器运行时从 Docker 改成了 containerd，其他类似于Docker的运行时还有 <code>Podman</code>、<code>rkt（Rocket）</code>、<code>LXC（Linux Containers</code>、<code>CRI-O</code>等</p></li><li><p>k8s 是唯一的容器编排工具吗？</p><p>不是的，就像前文提到的 Docker Compose 也能管理容器的使用，只是适用规模较小，除此之外类似的工具还有 <code>Docker Swarm</code>、<code>Apache Mesos</code>、<code>Nomad</code>、<code>OpenShift</code>等</p></li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>Docker 生成和运行镜像，k8s 管理这些被Pod包装并运行在Node上的容器，Rancher 管理 k8s 集群</li><li>部署无状态Pod使用 Deployment，部署有状态Pod使用 StatefulSet，StatefulSet 会固定每个 Pod 的名字</li><li>k8s不会为你处理数据的存储，我们可以为运行数据库的Pod挂载一个磁盘来确保数据的安全，云存储、本地磁盘、NFS都是可以选择的对象</li><li><code>kubectl get all</code> 可用于查看常用资源，包括Pod、Service、Deployment、ReplicaSet等</li><li>也可以单独查询某项信息 <code>kubectl get namespace</code>、<code>kubectl get pod</code>、<code>kubectl get node</code>、<code>kubectl get deployment</code></li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/136572038" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>惟愿吾儿愚且鲁，无灾无难到公卿，可能不是东坡的心里话吧，但一定是受到刺激以后才有的感想~</p><p>2024-3-28 20:34:05</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;有些时候的巧合让人匪夷所思，前两周刚刚尝试了一遍Docker操作，紧接着就收到好朋友说要学习k8s容器部署的建议，最近两周抽空看了一些关于k8s的知识，相关概念真的是太多了，概念本身是枯燥的，但是当概念运行起来就有意思多了，这时候取出费曼学习大法，尝试着用自己的话来描述这些概念，看看自己是不是真的学会了。本文k8s相关概念均来自个人理解，后续随着学习深入可能会有改正，勿喷。&lt;/p&gt;
    
    </summary>
    
      <category term="k8s" scheme="http://AlbertGithubHome.github.io/blog/categories/k8s/"/>
    
    
      <category term="k8s" scheme="http://AlbertGithubHome.github.io/blog/tags/k8s/"/>
    
      <category term="Kubernetes" scheme="http://AlbertGithubHome.github.io/blog/tags/Kubernetes/"/>
    
      <category term="docker" scheme="http://AlbertGithubHome.github.io/blog/tags/docker/"/>
    
      <category term="概念" scheme="http://AlbertGithubHome.github.io/blog/tags/%E6%A6%82%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>将python编写的网站制作成docker镜像并上传到Github Packages上</title>
    <link href="http://AlbertGithubHome.github.io/blog/2024/03/09/%E5%B0%86python%E7%BC%96%E5%86%99%E7%9A%84%E7%BD%91%E7%AB%99%E5%88%B6%E4%BD%9C%E6%88%90docker%E9%95%9C%E5%83%8F%E5%B9%B6%E4%B8%8A%E4%BC%A0%E5%88%B0Github-Packages%E4%B8%8A/"/>
    <id>http://AlbertGithubHome.github.io/blog/2024/03/09/将python编写的网站制作成docker镜像并上传到Github-Packages上/</id>
    <published>2024-03-08T18:00:00.000Z</published>
    <updated>2024-04-29T14:44:17.003Z</updated>
    
    <content type="html"><![CDATA[<p>@[toc]</p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>还记得上一篇<a href="https://blog.csdn.net/albertsh/article/details/136406152" target="_blank" rel="noopener">《借助ChatGPT使用Python搭建一个工具网站》</a>总结中我利用ChatGPT写了一个网站，最终它运行良好，就在昨天我看到了Github Packages，不久前刚刚使用了GitHub Actions，我发现Github在被微软收购后，并没有变的更“闭源”，之前广大网友还在调侃，最大的闭源软件公司收购了最大的开源平台，看来一切还在向好的方向发展，简单介绍下前面提到的这两个都是什么东西。</p><a id="more"></a><p><a href="https://github.com/features/actions" target="_blank" rel="noopener">GitHub Actions</a> 是一个Github原生的持续集成和部署的工作流组件。通俗来说就是Github免费给你提供虚拟主机，由你编写工作流脚本来进行源码的检出，编译，测试，和发布。类似的我们可以想象成Github给每个仓库都免费绑定了一个Jenkins服务，编写pipeline脚本即可进行源码的集成和发布。</p><p><a href="https://github.com/features/packages" target="_blank" rel="noopener">GitHub Packages</a> 是一个和每一个代码仓库关联的软件包仓库。通俗来说就是代码仓库中存放的是源码，软件包仓库中存放的是编译输出后的可以被各个语言生态的依赖管理工具直接依赖的lib，类似的我们熟知的有maven中央仓库和nmp仓库。</p><p>今天我们只看GitHub Packages这部分，并且将范围缩小到制作一个Docker镜像并上传到GitHub Packages，用来制作的项目就是前文中我们在ChatGPT辅助下编写的网站，本文只写流程，对于其中的概念不会过多解释，大家可以借助网络来解决概念性问题，但是我在完成目标过程中遇到的坑会列举出来，希望能帮助有相同经历的人，同时自己记录一下防止忘记。</p><h1 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h1><p>既然要制作docker镜像，那先简单了解下docker是什么</p><blockquote><p>Docker 使用 Google 公司推出的 Go 语言 进行开发实现，基于 Linux 内核的 cgroup，namespace，以及 OverlayFS 类的 Union FS 等技术，对进程进行封装隔离，属于 操作系统层面的虚拟化技术。由于隔离的进程独立于宿主和其它的隔离的进程，因此也称其为容器。最初实现是基于 LXC，从 0.7 版本以后开始去除 LXC，转而使用自行开发的 libcontainer，从 1.11 版本开始，则进一步演进为使用 runC 和 containerd</p><p>Docker 可以通过定制应用镜像来实现持续集成、持续交付、部署。开发人员可以通过 Dockerfile 来进行镜像构建，并结合 持续集成(Continuous Integration) 系统进行集成测试，而运维人员则可以直接在生产环境中快速部署该镜像，甚至结合 持续部署(Continuous Delivery/Deployment) 系统进行自动部署。而且使用 Dockerfile 使镜像构建透明化，不仅仅开发团队可以理解应用运行环境，也方便运维团队理解应用运行所需条件，帮助更好的生产环境中部署该镜像。</p></blockquote><p>以上我只是摘抄了一部分，想要看更详细的解释请跳转至 <a href="https://yeasy.gitbook.io/docker_practice/" target="_blank" rel="noopener">《Docker 技术入门与实战》</a>，总的来说就是能解决环境一致性问题，并且可以方便部署的，把你的软件及运行环境打个包，在目标机器上直接运行，最大程度的去除环境差异，被打成的这个包就是docker镜像，我们可以把这个镜像丢到“任何”一台机器上去执行，不用再操心安装繁琐的运行环境。</p><p>但是无论是制作docker镜像还是运行docker镜像都需要先安装docker环境，相当于它来做软件和机器之间的代理，是不是听起来像虚拟机，他俩常常被拿来比较，而docker更加轻量级，目前应用广泛，我们来列举下安装步骤，事先说明操作系统是Ubuntu20.04，项目是<a href="https://github.com/AlbertGithubHome/minimalist-tool-web" target="_blank" rel="noopener">minimalist-tool-web</a>，未特殊说明时则是在项目根目录下执行命令。</p><h2 id="安装docker"><a href="#安装docker" class="headerlink" title="安装docker"></a>安装docker</h2><ul><li><p>更新apt包列表</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br></pre></td></tr></table></figure></li><li><p>安装依赖包，以允许apt通过HTTPS使用存储库</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install -y apt-transport-https ca-certificates curl gnupg2 software-properties-common</span><br></pre></td></tr></table></figure></li><li><p>添加Docker的官方GPG密钥</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -</span><br></pre></td></tr></table></figure></li><li><p>添加Docker的APT存储库</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo add-apt-repository <span class="string">"deb [arch=amd64] https://download.docker.com/linux/ubuntu <span class="variable">$(lsb_release -cs)</span> stable"</span></span><br></pre></td></tr></table></figure></li><li><p>再次更新apt包列表</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br></pre></td></tr></table></figure></li><li><p>安装Docker</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install -y docker-ce</span><br></pre></td></tr></table></figure></li><li><p>验证Docker是否安装成功：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker --version</span><br></pre></td></tr></table></figure></li></ul><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ol><li><p>添加GPG密钥的时候有可能报错 <code>curl: (35) OpenSSL SSL_connect: SSL_ERROR_SYSCALL in connection to download.docker.com:443</code>，相同命令多尝试几次就能看见 <code>OK</code></p></li><li><p>我在 <code>sudo apt update</code> 的时候报错 <code>Failed to fetch https://dl.google.com/linux/chrome/deb/dists/stable/InRelease The following signatures couldn&#39;t be verified because the public key is not available: NO_PUBKEY E88979FB9B30ACF2</code>，通过执行 <code>wget -q -O - https://dl.google.com/linux/linux_signing_key.pub | sudo apt-key add -</code> 修复好的，不过这可能是个例，你们不一定遇到</p></li></ol><h2 id="创建Dockerfile"><a href="#创建Dockerfile" class="headerlink" title="创建Dockerfile"></a>创建Dockerfile</h2><p>在项目根目录下创建一个名为 <code>Dockerfile</code> 的文件，并编写 Docker 镜像的构建指令，以下是一个示例的 <code>Dockerfile</code> 文件，它是在初始命令模板下精简而成，目的是缩小镜像大小，调整命令后镜像从1.1G缩小到65M</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用 Alpine Linux 作为基础镜像</span></span><br><span class="line"><span class="keyword">FROM</span> python:<span class="number">3.8</span>-alpine</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置工作目录</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /app</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash"><span class="comment"># 将当前目录下的所有文件复制到工作目录</span></span></span><br><span class="line"><span class="bash">COPY . .</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash"><span class="comment"># 安装项目依赖</span></span></span><br><span class="line"><span class="bash">RUN pip install --no-cache-dir -r requirements.txt</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash"><span class="comment"># 清理不必要的缓存</span></span></span><br><span class="line"><span class="bash">RUN rm -rf /var/cache/apk/*</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash"><span class="comment"># 暴露应用端口</span></span></span><br><span class="line"><span class="bash">EXPOSE 9206</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash"><span class="comment"># 运行应用</span></span></span><br><span class="line"><span class="bash">CMD [<span class="string">"python3"</span>, <span class="string">"main.py"</span>]</span></span><br></pre></td></tr></table></figure><h3 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li><code>WORKDIR /app</code> 是指镜像中的目录，在当前操作系统中可能并不存在</li><li><code>COPY . .</code> 很奇怪的写法，但是两个<code>.</code>含义是不同的，第一个只当前目录，第二个指镜像中的当前目录，也就是 <code>/app</code></li></ul><h2 id="构建-Docker-镜像"><a href="#构建-Docker-镜像" class="headerlink" title="构建 Docker 镜像"></a>构建 Docker 镜像</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker build -t minimalist-tool-web .</span><br></pre></td></tr></table></figure><p>其中 <code>-t minimalist-tool-web</code> 指定了镜像的名称为 <code>minimalist-tool-web</code>，构建完成后，可以查看当前镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker images</span><br><span class="line">REPOSITORY            TAG       IMAGE ID       CREATED          SIZE</span><br><span class="line">minimalist-web-tool   latest    f11497961379   5 minutes ago    65.6MB</span><br><span class="line">hello-world           latest    d2c94e258dcb   10 months ago    13.3kB</span><br></pre></td></tr></table></figure><h2 id="运行-Docker-镜像"><a href="#运行-Docker-镜像" class="headerlink" title="运行 Docker 镜像"></a>运行 Docker 镜像</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 9206:9205 minimalist-tool-web</span><br></pre></td></tr></table></figure><p>其中 <code>-d</code>参数表示在后台运行容器，<code>-p 9206:9205</code> 将容器内部的 9205 端口映射到宿主机的 9206 端口，这样就可以通过 <code>http://localhost:9206</code> 访问应用程序，至此，我的项目就已经制作成了 Docker 镜像，并且可以在 Docker 容器中运行了。</p><h1 id="发布到Github-Packages"><a href="#发布到Github-Packages" class="headerlink" title="发布到Github Packages"></a>发布到Github Packages</h1><p>这部分确实花了我不少时间，我先把正确的流程描述完，然后再说一下我遇到的问题。</p><ol><li><p>到<a href="https://github.com/settings/tokens" target="_blank" rel="noopener">Developer Settings (classic)</a> 申请一个token，记得至少勾选 <code>read:packages</code> 和 <code>write:packages</code> 权限</p></li><li><p>登录docker，使用上一步申请的token</p></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker login ghcr.io --username your-github-username --password-stdin your-personal-access-token</span><br></pre></td></tr></table></figure><ol><li>给镜像添加标签</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker tag your-image-id ghcr.io/your-github-username/your-image-name:1.0.0</span><br></pre></td></tr></table></figure><ol><li>将docker镜像推送到Github Packages上</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker push ghcr.io/your-github-username/your-image-name:1.0.0</span><br></pre></td></tr></table></figure><h2 id="坑坑到位"><a href="#坑坑到位" class="headerlink" title="坑坑到位"></a>坑坑到位</h2><h3 id="申请token的坑"><a href="#申请token的坑" class="headerlink" title="申请token的坑"></a>申请token的坑</h3><p>许多教程上申请token截图还是只有一个页面，但是现在（2024-3-8）的Github上申请的token的页面已经分成了两类，具体导航路径在<code>『Github头像』</code>-&gt;<code>『Settings』</code>-&gt;<code>『Developer Settings』</code>-&gt;<code>『Personal access tokens』</code>，到此处申请token页面分成了两个，分别是 <code>Fine-grained tokens</code>和 <code>Tokens (classic)</code>，最近几次其他的访问权限分配我都是用的前面这种<code>Fine-grained tokens</code>，虽然标记着 <code>Beta</code>，但这是官方推荐的形式。</p><p>但这一次我却遇到了 <code>unauthorized: unauthenticated: User cannot be authenticated with the token provided.</code> 这个问题，后来改成Tokens (classic)这种类型的token才解决，可以看到的是第一个Fine-grained tokens中我没有找到<code>read:packages</code> 和 <code>write:packages</code> 权限，不知道是不是和这个有关，我还在尝试。</p><p>那么在申请 <code>Tokens (classic)</code> 时要记得勾选<code>read:packages</code> 和 <code>write:packages</code> 权限，最好把 <code>delete:packages</code> 和 <code>repo</code> 也勾选上，如果想通过token更新Github Actions，最好也要勾选上 <code>workflow</code></p><p><code>Fine-grained tokens</code>：这种token形如 <code>github_pat_xxx</code>，位数较长</p><p><code>Tokens (classic)</code>：这种token形如 <code>ghp_xxx</code>，位数较短</p><h3 id="docker登录的坑"><a href="#docker登录的坑" class="headerlink" title="docker登录的坑"></a>docker登录的坑</h3><p>很多帖子可能是时间太久远了，里面提到的地址都是 <code>docker.pkg.github.com</code>，我这里倒是都显示登录成功，但是每次推送都会提示 <code>no basic auth credentials</code>，就像下面这样</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$ cat ~/TOKEN.txt | docker login https://docker.pkg.github.com -u AlbertGithubHome --password-stdin</span><br><span class="line">WARNING! Your password will be stored unencrypted <span class="keyword">in</span> /home/shz/.docker/config.json.</span><br><span class="line">Configure a credential helper to remove this warning. See</span><br><span class="line">https://docs.docker.com/engine/reference/commandline/login/<span class="comment">#credentials-store</span></span><br><span class="line"></span><br><span class="line">Login Succeeded</span><br><span class="line"></span><br><span class="line">$ sudo docker push docker.pkg.github.com/albertgithubhome/minimalist-tool-web/tools-web:1.0.0</span><br><span class="line">The push refers to repository [docker.pkg.github.com/albertgithubhome/minimalist-tool-web/tools-web]</span><br><span class="line">c0f047bfac29: Preparing</span><br><span class="line">87174263225b: Preparing</span><br><span class="line">5462d39b06ad: Preparing</span><br><span class="line">2c604764da2f: Preparing</span><br><span class="line">a469c5a79f90: Preparing</span><br><span class="line">7402639a4746: Waiting</span><br><span class="line">42672d5bf49e: Waiting</span><br><span class="line">678cac8b069e: Waiting</span><br><span class="line">d4fc045c9e3a: Waiting</span><br><span class="line">no basic auth credentials</span><br></pre></td></tr></table></figure><p>后来在 Stack Overflow 上找到一个问题，里面用的是 <code>ghcr.io</code> 修改之后发现才可以</p><h3 id="给镜像添加标签的坑"><a href="#给镜像添加标签的坑" class="headerlink" title="给镜像添加标签的坑"></a>给镜像添加标签的坑</h3><p>这个需要注意的点是整个标签的字母必须都是小写的，而我的用户名是大写，所以我按照老版本的教程创建了类似 <code>docker tag f11497961379 docker.pkg.github.com/albertgithubhome/minimalist-tool-web/tools-web:1.0.0</code> 的标签，但是我的用户名是大写的，每次推送失败告诉我未验证时，我无法确定是哪类的问题:</p><ol><li>token类型有问题</li><li>权限有问题，登录没有用sudo</li><li>登录地址有问题，<a href="https://docker.pkg.github.com地址打不开" target="_blank" rel="noopener">https://docker.pkg.github.com地址打不开</a></li><li>我的用户名有大写字母，与推送的镜像名中的用户名不匹配</li></ol><p>反正费了九牛二虎之力吧，把这些原因一一排除掉，总算能推送上去了</p><p>还有一点，之前老版本的教程标签格式要求是 <code>docker.pkg.github.com/your-github-username/your-repository/your-image-name:1.0.0</code>，在新版的教程中改为了 <code>ghcr.io/your-github-username/your-image-name:1.0.0</code>，不要求添加库的名称了</p><h3 id="docker推送的坑"><a href="#docker推送的坑" class="headerlink" title="docker推送的坑"></a>docker推送的坑</h3><p>这一步的坑都是前面几步积累得来的，因为这一步的失败根本不知道前边哪一步出错了，更离谱的是在登录这一步，无论用户名是什么，token是什么都显示登录成功，导致后面查找原因浪费了不少时间</p><p>推送时直接填写前面的标签名即可</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker push ghcr.io/albertgithubhome/minimalist-tool-web:1.0.0</span><br><span class="line">The push refers to repository [ghcr.io/albertgithubhome/minimalist-tool-web]</span><br><span class="line">c0f047bfac29: Pushed</span><br><span class="line">87174263225b: Pushed</span><br><span class="line">5462d39b06ad: Pushed</span><br><span class="line">2c604764da2f: Pushed</span><br><span class="line">a469c5a79f90: Pushed</span><br><span class="line">7402639a4746: Pushed</span><br><span class="line">42672d5bf49e: Pushed</span><br><span class="line">678cac8b069e: Pushed</span><br><span class="line">d4fc045c9e3a: Pushed</span><br><span class="line">1.0.0: digest: sha256:f749fd2eba021248c97c8a44374772165372354b9d48f4f6b845bbce46d02402 size: 2201</span><br></pre></td></tr></table></figure><p>这些参数可以在 <a href="https://ghcr.io" target="_blank" rel="noopener">ghcr.io</a> 查看，页面上有一个示例</p><p><img src="https://img-blog.csdnimg.cn/direct/14a5633c75174979a6d8da967063fac5.png#pic_center" alt="ghcr.io"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$PAT</span> | docker login ghcr.io --username phanatic --password-stdin</span><br><span class="line">docker tag app ghcr.io/phanatic/app:1.0.0</span><br><span class="line">docker push ghcr.io/phanatic/app:1.0.0</span><br></pre></td></tr></table></figure><h1 id="在Github-Packages上查看"><a href="#在Github-Packages上查看" class="headerlink" title="在Github Packages上查看"></a>在Github Packages上查看</h1><p>打开你账号下的Packages页签就能看到了，点击进去可以将这个 package 关联到指定项目，这样在项目的首页右侧的packages区域就能看到这个package，在package的介绍页面会教你怎么使用这个镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull ghcr.io/albertgithubhome/minimalist-tool-web:1.0.0</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/direct/885fb2900d52414b961e562e9b9131c4.png#pic_center" alt="minimalist-tool-web"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li><code>GitHub Actions</code> 是一个Github原生的持续集成和部署的工作流组件，相当免费绑定了一个Jenkins服务</li><li><code>GitHub Packages</code> 是和每一个代码仓库关联的软件包仓库，类似我们熟知的maven中央仓库和nmp仓库</li><li>运行docker命令 <code>docker run -d -p 9206:9205 minimalist-tool-web</code>，其中minimalist-tool-web是镜像名</li><li>停止docker命令 <code>sudo docker stop af98cf2f93bf</code>，其中af98cf2f93bf是容器ID</li><li>推送docker命令 <code>sudo docker push ghcr.io/albertgithubhome/minimalist-tool-web:1.0.0</code></li><li>拉取docker命令 <code>sudo docker pull ghcr.io/albertgithubhome/minimalist-tool-web:1.0.0</code></li><li>最终<code>Fine-grained tokens</code>应该会替换到<code>Tokens (classic)</code>，但现在感觉还不能完全代替</li><li>接下来会尝试用.yml编写一个<code>GitHub Action</code>控制项目更新时自动创建镜像和发布</li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/136406152" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>从秦灭六国、焚书坑儒开始，从罢黜百家、独尊儒术开始，洗脑便已经登峰造极了~</p><p>2024-3-8 20:59:13</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;@[toc]&lt;/p&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;还记得上一篇&lt;a href=&quot;https://blog.csdn.net/albertsh/article/details/136406152&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《借助ChatGPT使用Python搭建一个工具网站》&lt;/a&gt;总结中我利用ChatGPT写了一个网站，最终它运行良好，就在昨天我看到了Github Packages，不久前刚刚使用了GitHub Actions，我发现Github在被微软收购后，并没有变的更“闭源”，之前广大网友还在调侃，最大的闭源软件公司收购了最大的开源平台，看来一切还在向好的方向发展，简单介绍下前面提到的这两个都是什么东西。&lt;/p&gt;
    
    </summary>
    
      <category term="docker" scheme="http://AlbertGithubHome.github.io/blog/categories/docker/"/>
    
    
      <category term="docker" scheme="http://AlbertGithubHome.github.io/blog/tags/docker/"/>
    
      <category term="容器" scheme="http://AlbertGithubHome.github.io/blog/tags/%E5%AE%B9%E5%99%A8/"/>
    
      <category term="python" scheme="http://AlbertGithubHome.github.io/blog/tags/python/"/>
    
      <category term="GithubPackages" scheme="http://AlbertGithubHome.github.io/blog/tags/GithubPackages/"/>
    
  </entry>
  
  <entry>
    <title>借助ChatGPT使用Python搭建一个工具网站</title>
    <link href="http://AlbertGithubHome.github.io/blog/2024/03/02/%E5%80%9F%E5%8A%A9ChatGPT%E4%BD%BF%E7%94%A8Python%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%B7%A5%E5%85%B7%E7%BD%91%E7%AB%99/"/>
    <id>http://AlbertGithubHome.github.io/blog/2024/03/02/借助ChatGPT使用Python搭建一个工具网站/</id>
    <published>2024-03-01T18:00:00.000Z</published>
    <updated>2024-04-29T15:06:43.236Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>不知不觉ChatGPT已经风靡一年多了，现在基本每天工作时都会用到，相比于传统的搜索引擎它究竟强在哪呢？我觉得以往的搜索引擎是一个机器，你给它关键信息它能返回匹配关键词的内容数据，而ChatGPT更像是一个机器“人”，它同样可以返回给你匹配关键信息的数据，同时可以按照你的指令进行加工，更优秀的是它还记得你跟它说过的每一句话，就像拥有一个可以存储交流记录的大脑一样，你可以赋予它一些性格和规则，让它来帮你做事情，交流的多了它就能变成一个性格鲜明的“生物”，并且可以无条件接受你的命令，所以最近突发奇想让它帮我搭一个网站怎么样，说干就干起来了。</p><a id="more"></a><h1 id="网站搭建过程"><a href="#网站搭建过程" class="headerlink" title="网站搭建过程"></a>网站搭建过程</h1><p>怀着期望的心情我给了它一个比较简单的任务</p><p><img src="https://img-blog.csdnimg.cn/direct/5a266ee4f4144cd1a8f6c441920767fb.png#pic_center" alt="chatgpt1"><br>完成的还不错，按照他的代码和步骤确实得到了一个可以转换文字编码的单页面网站，但是flask有点陌生，我想了解更多，于是它给了我解答</p><p><img src="https://img-blog.csdnimg.cn/direct/8c97b97eb08b47b5b42e366c972d1d4e.png#pic_center" alt="chatgpt2"><br>但是这个网站在运行过程中控制台输出了一些警告，我让它帮我解决一下</p><p><img src="https://img-blog.csdnimg.cn/direct/d76e79a0dfd44f558aaf5343a997cdef.png#pic_center" alt="chatgpt3"><br>虽然没解决，但我知道了警告的含义，于是我想改善一下页面工具使用体验</p><p><img src="https://img-blog.csdnimg.cn/direct/0966bf50ecee435496bfbe556c6e8d71.png#pic_center" alt="chatgpt4"><br>目前这个网站只能在本机访问，在其他机器访问时被拒绝，我又找它想办法</p><p><img src="https://img-blog.csdnimg.cn/direct/a1ac560c90a04c748f47a36544d5021d.png#pic_center" alt="chatgpt5"><br>此时我发现了一个错误，不知什么时候它不能转base64了，通知它修正一下</p><p><img src="https://img-blog.csdnimg.cn/direct/6e800ad9f7724d67b68462ddeca22355.png#pic_center" alt="chatgpt6"><br>现在是在控制台启动的，把它变成一个真正的后台网站</p><p><img src="https://img-blog.csdnimg.cn/direct/a2f4706a9b3247a1a0673733e4de591a.png#pic_center" alt="chatgpt7"><br>继续优化，将页面拆分，各司其职</p><p><img src="https://img-blog.csdnimg.cn/direct/62a8eb7cadf74d82a80693fe199f78c1.png#pic_center" alt="chatgpt8"><br><img src="https://img-blog.csdnimg.cn/direct/9cf71e59d3aa4e4c9f7110fa9bbac89a.png#pic_center" alt="chatgpt9"><br>页面分离后报了错误找它解决<br><img src="https://img-blog.csdnimg.cn/direct/9248028a53664b9a9332b02500020156.png#pic_center" alt="chatgpt10"><br>更改页面跳转样式<br><img src="https://img-blog.csdnimg.cn/direct/b43c4dfa74464609b6484f24c24428d2.png#pic_center" alt="chatgpt11"></p><p>即使你说第一版最好它也不会发脾气</p><p><img src="https://img-blog.csdnimg.cn/direct/0a1852352fb446d28735c59d41968f14.png#pic_center" alt="chatgpt12"><br>让它帮你记录当前项目以备后续扩展<br><img src="https://img-blog.csdnimg.cn/direct/ab5d830be2a34010a4f2ceedc02f7dbd.png#pic_center" alt="chatgpt13"></p><p>就这样一步一步的，我又加了新的需求，网站出来后效果还不错，以下是展示页</p><p><img src="https://img-blog.csdnimg.cn/direct/7288aee4ece34a449fa10950dc15e02d.png#pic_center" alt="page1"><br>这是主页面，点击卡片会进行跳转</p><p><img src="https://img-blog.csdnimg.cn/direct/d136f750155c43928ed334a28d88a332.png#pic_center" alt="page2">)</p><p>功能都可以正常使用，基本实现了我想要做一个极简工具网站的需求</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li><code>ChatGPT</code> 是真的强，可以按照你的指令一步步思考和总结，再也不是搜索引擎的匹配规则了</li><li>强大的工具要学着使用，每一波新生代的工具都会带来一些变革，别再只把它当成搜索引擎了</li><li>这周参加了一堂课，讲解ChatGPT的一些实际应用，其实已经遍地开花了，很多项目组都已经玩出花了</li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/136154906" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>想要逃却逃不掉，只能转身面对~</p><p>2024-3-1 21:49:59</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;不知不觉ChatGPT已经风靡一年多了，现在基本每天工作时都会用到，相比于传统的搜索引擎它究竟强在哪呢？我觉得以往的搜索引擎是一个机器，你给它关键信息它能返回匹配关键词的内容数据，而ChatGPT更像是一个机器“人”，它同样可以返回给你匹配关键信息的数据，同时可以按照你的指令进行加工，更优秀的是它还记得你跟它说过的每一句话，就像拥有一个可以存储交流记录的大脑一样，你可以赋予它一些性格和规则，让它来帮你做事情，交流的多了它就能变成一个性格鲜明的“生物”，并且可以无条件接受你的命令，所以最近突发奇想让它帮我搭一个网站怎么样，说干就干起来了。&lt;/p&gt;
    
    </summary>
    
      <category term="ChatGPT" scheme="http://AlbertGithubHome.github.io/blog/categories/ChatGPT/"/>
    
    
      <category term="Python" scheme="http://AlbertGithubHome.github.io/blog/tags/Python/"/>
    
      <category term="工具" scheme="http://AlbertGithubHome.github.io/blog/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="ChatGPT" scheme="http://AlbertGithubHome.github.io/blog/tags/ChatGPT/"/>
    
      <category term="web" scheme="http://AlbertGithubHome.github.io/blog/tags/web/"/>
    
      <category term="tools" scheme="http://AlbertGithubHome.github.io/blog/tags/tools/"/>
    
  </entry>
  
  <entry>
    <title>在golang语言中简单使用protobuf时遭遇go_package困难重重</title>
    <link href="http://AlbertGithubHome.github.io/blog/2024/02/18/%E5%9C%A8golang%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8protobuf%E6%97%B6%E9%81%AD%E9%81%87go-package%E5%9B%B0%E9%9A%BE%E9%87%8D%E9%87%8D/"/>
    <id>http://AlbertGithubHome.github.io/blog/2024/02/18/在golang语言中简单使用protobuf时遭遇go-package困难重重/</id>
    <published>2024-02-18T13:00:00.000Z</published>
    <updated>2024-02-19T15:27:44.989Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Protobuf，全称Protocol Buffers，是一种由Google开发的用于序列化结构化数据的开源数据交换格式，Golang作为一种后端语言，免不了使用protobuf这种数据交换格式，本来打算写个小例子展示一下怎样在go语言中使用protobuf，结果遇到的问题到不少，特别是这个go_package的要求，也是之前在项目开发过程中遇到的，这次就查找一下具体原因以及怎么使用吧。</p><a id="more"></a><h1 id="编写示例"><a href="#编写示例" class="headerlink" title="编写示例"></a>编写示例</h1><p>为了能对这个示例有一个整体的轮廓，我先把编写好的目录结构展示一下，后面再逐步实现</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ tree lib_protobuf</span><br><span class="line">lib_protobuf</span><br><span class="line">├── go.mod</span><br><span class="line">├── go.sum</span><br><span class="line">├── lib_protobuf.go</span><br><span class="line">├── msgproto</span><br><span class="line">│   └── examplemsg.pb.go</span><br><span class="line">└── srcproto</span><br><span class="line">    └── examplemsg.proto</span><br></pre></td></tr></table></figure><p>简单解释下，<code>examplemsg.proto</code> proto源文件，<code>examplemsg.pb.go</code> 是proto导出文件，<code>lib_protobuf.go</code> 是proto协议使用和测试文件</p><h2 id="示例初始化"><a href="#示例初始化" class="headerlink" title="示例初始化"></a>示例初始化</h2><p>执行下面的命令，创建示例基础目录文件结构</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir lib_protobuf</span><br><span class="line">$ <span class="built_in">cd</span> lib_protobuf</span><br><span class="line">$ mkdir srcproto</span><br><span class="line">$ touch srcproto/examplremsg.proto</span><br><span class="line">$ touch lib_protobuf.go</span><br><span class="line">$ go mod init lib_protobuf</span><br><span class="line">go: creating new go.mod: module lib_protobuf</span><br><span class="line">go: to add module requirements and sums:</span><br><span class="line">        go mod tidy</span><br><span class="line"></span><br><span class="line">$ go mod tidy</span><br><span class="line">$ ls</span><br><span class="line">go.mod  lib_protobuf.go  srcproto</span><br></pre></td></tr></table></figure><h2 id="编写协议文件内容"><a href="#编写协议文件内容" class="headerlink" title="编写协议文件内容"></a>编写协议文件内容</h2><p>先编写proto文件，文件内容如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">"proto3"</span>;</span><br><span class="line"></span><br><span class="line">message Person &#123;</span><br><span class="line">    <span class="keyword">string</span> name = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int32</span> age = <span class="number">2</span>;</span><br><span class="line">    repeated <span class="keyword">string</span> hobbies = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个协议文件只定义了一个名为 <code>Person</code> 的结构，其中包括 <code>name</code> 、<code>age</code>、<code>hobbies</code> 三个字段</p><h2 id="导出协议文件"><a href="#导出协议文件" class="headerlink" title="导出协议文件"></a>导出协议文件</h2><p>这是本文的重点，至于怎么用proto文件定义结构，各个语言都是相通的，但是在导出时遇到 <code>go_package</code> 文件却是 golang 语言特有的，所以本文重点在这部分多花些篇幅，解释一下遇到的各种问题</p><h3 id="protoc-和-protoc-gen-go"><a href="#protoc-和-protoc-gen-go" class="headerlink" title="protoc 和 protoc-gen-go"></a>protoc 和 protoc-gen-go</h3><p>导出时需要是使用工具 <code>protoc</code>，而平时你可能听说过或者在.pb.go文件中看到过 <code>protoc-gen-go</code> 这个工具的名字，其实 <code>protoc-gen-go</code> 是一个用于生成 Go 代码的插件，它是 Protocol Buffers 编译器 <code>protoc</code> 的一部分。当您使用 <code>protoc</code> 编译 <code>.proto</code> 文件时，可以通过指定 <code>--go_out</code> 标志来指定要使用的 <code>protoc-gen-go</code> 插件，从而生成对应的 Go 代码文件。这个插件会根据 <code>.proto</code> 文件中定义的消息和服务等内容，生成与之对应的 Go 结构体、接口和方法等代码。因此，<code>protoc-gen-go</code> 和 <code>protoc</code> 是紧密相关的，它们共同用于将 Protocol Buffers 文件编译为 Go 语言中的数据结构和服务定义。</p><h3 id="执行导出命令"><a href="#执行导出命令" class="headerlink" title="执行导出命令"></a>执行导出命令</h3><p>使用<code>protoc</code>将proto文件导出golang可用的文件最重要的两个参数如下：</p><p><code>--proto_path</code>：proto源文件所在文件夹<br><code>--go_out</code>：proto文件导出的目标文件夹</p><p>执行命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> lib_protobuf</span><br><span class="line">$ protoc --proto_path=srcproto --go_out=. examplemsg.proto</span><br><span class="line">protoc-gen-go: unable to determine Go import path <span class="keyword">for</span> <span class="string">"examplemsg.proto"</span></span><br><span class="line"></span><br><span class="line">Please specify either:</span><br><span class="line">        • a <span class="string">"go_package"</span> option <span class="keyword">in</span> the .proto <span class="built_in">source</span> file, or</span><br><span class="line">        • a <span class="string">"M"</span> argument on the <span class="built_in">command</span> line.</span><br><span class="line"></span><br><span class="line">See https://developers.google.com/protocol-buffers/docs/reference/go-generated<span class="comment">#package for more information.</span></span><br><span class="line"></span><br><span class="line">--go_out: protoc-gen-go: Plugin failed with status code 1.</span><br></pre></td></tr></table></figure><p>不出意外的果然出意外了，告诉我不能确定 <code>examplemsg.proto</code> 文件的导入路径，换句话说就是现在这样不能导出一个可以被正常导入的包，有两种解决办法，第一种就是在.proto文件中添加 <code>go_package</code> 选项，第二种是在执行导出的命令行中添加<code>M</code>参数，详细的解释参考链接 <a href="https://developers.google.com/protocol-buffers/docs/reference/go-generated#package" target="_blank" rel="noopener">https://developers.google.com/protocol-buffers/docs/reference/go-generated#package</a></p><p>官方推荐是用第一种方式，也就是直接在.proto文件中添加 <code>go_package</code> 选项，假如我们这样写：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">option go_package = <span class="string">"msgproto"</span>;</span><br></pre></td></tr></table></figure><p>然后直接导出会遇到新的错误，提示”msgproto”并不是文件”examplemsg.proto”的一个有效的导入路径</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ protoc --proto_path=srcproto --go_out=. examplemsg.proto</span><br><span class="line">protoc-gen-go: invalid Go import path <span class="string">"msgproto"</span> <span class="keyword">for</span> <span class="string">"examplemsg.proto"</span></span><br><span class="line"></span><br><span class="line">The import path must contain at least one period (<span class="string">'.'</span>) or forward slash (<span class="string">'/'</span>) character.</span><br><span class="line"></span><br><span class="line">See https://developers.google.com/protocol-buffers/docs/reference/go-generated<span class="comment">#package for more information.</span></span><br><span class="line"></span><br><span class="line">--go_out: protoc-gen-go: Plugin failed with status code 1.</span><br></pre></td></tr></table></figure><p>要求必须至少包含一个 <code>.</code> 或者 <code>/</code>，那么把选项改成下面这样就可以了</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">option go_package = <span class="string">"./msgproto"</span>;</span><br></pre></td></tr></table></figure><p>有时为了在当前目录下生成，又要指定包名，可以写成这样：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">option go_package = <span class="string">"./;msgproto"</span>;</span><br></pre></td></tr></table></figure><p>使用分号将包路径和包名分开，但这种方法官方并不推荐，因为按照golang的包管理习惯，文件夹下的所有文件包名应该与文件名相同，通过包的路径能够推测是包名才对，否则写成 <code>option go_package = &quot;./msgprotoA;msgprotoB&quot;;</code> 就很奇怪了</p><p>关于go_package至少包含一个 <code>.</code> 或者 <code>/</code>的要求，据说v1.4.0以上的版本就要求必须加<code>/</code>了，最近查了一些资料，解释如下：</p><blockquote><p>在 Protocol Buffers（Protobuf）中，go_package 选项用于指定生成的 Go 代码的包名和导入路径。要求导入路径（import path）必须包含至少一个点（.）或正斜杠（/）的原因与 Go 语言的模块系统和包导入机制有关</p><p>这个要求是因为在导出时，<code>protoc</code> 需要能够将生成的代码文件放置在文件系统的适当位置，并且需要能够以合适的包路径来导入这些生成的代码。在大多数情况下，包路径应该具有与文件系统路径相对应的结构，因此至少需要包含一个句点（<code>.</code>）或正斜杠（<code>/</code>）字符来指示层次结构。</p><p>如果导入路径不包含这些字符，那么生成的代码文件将无法以合适的方式组织和导入，可能会导致编译器无法正确识别代码的位置和包结构。因此，为了确保生成的代码能够被正确导入和使用，<code>protoc</code> 对导入路径设置了这个最低要求。</p></blockquote><p>但是我觉得这个解释不能让人信服，我把go_package的值写成 <code>.msgproto</code>、<code>msgproto.</code> 或者 <code>..msgproto</code> 都是能正常导出的，并没有看到这种限制的好处，其中深层次的原因还得在今后的使用过程中慢慢体会了</p><h2 id="编写协议使用文件"><a href="#编写协议使用文件" class="headerlink" title="编写协议使用文件"></a>编写协议使用文件</h2><p>在文件 lib_protobuf.go 中编写如下内容，执行 <code>go mod tidy</code> 和 <code>go run .</code> 查看输出结果</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">"fmt"</span></span><br><span class="line">   <span class="string">"log"</span></span><br><span class="line"></span><br><span class="line">   msg <span class="string">"lib_protobuf/msgproto"</span></span><br><span class="line"></span><br><span class="line">   <span class="string">"google.golang.org/protobuf/proto"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   p := &amp;msg.Person&#123;</span><br><span class="line">      Name:    <span class="string">"Alice"</span>,</span><br><span class="line">      Age:     <span class="number">30</span>,</span><br><span class="line">      Hobbies: []<span class="keyword">string</span>&#123;<span class="string">"reading"</span>, <span class="string">"running"</span>&#125;,</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 序列化</span></span><br><span class="line">   data, err := proto.Marshal(p)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      log.Fatalf(<span class="string">"Failed to encode person: %v"</span>, err)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 反序列化</span></span><br><span class="line">   newP := &amp;msg.Person&#123;&#125;</span><br><span class="line">   err = proto.Unmarshal(data, newP)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      log.Fatalf(<span class="string">"Failed to decode person: %v"</span>, err)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   fmt.Println(<span class="string">"Original Person:"</span>, p)</span><br><span class="line">   fmt.Println(<span class="string">"Decoded Person:"</span>, newP)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ go run .</span><br><span class="line">Original Person: name:<span class="string">"Alice"</span>  age:30  hobbies:<span class="string">"reading"</span>  hobbies:<span class="string">"running"</span></span><br><span class="line">Decoded Person: name:<span class="string">"Alice"</span>  age:30  hobbies:<span class="string">"reading"</span>  hobbies:<span class="string">"running"</span></span><br></pre></td></tr></table></figure><h1 id="体会"><a href="#体会" class="headerlink" title="体会"></a>体会</h1><p>有关 <code>go_package</code> 值官方给出的示例是这种 <code>example.com/project/protos/fizz</code>，这就跟go.mod文件中的module定义一样，比如 <code>module github.com/tealeg/xlsx</code> 或 <code>module github.com/peterbourgon/diskv/v3</code>，提供的是一种导出之后的引用写法</p><p>但是 <code>go_package</code> 和 <code>module</code> 还确实有一些不同，因为它在导出时真的会根据 <code>go_package</code> 生成相应的路径，所以针对这些去情况我觉得一种比较好的写法是从项目根目录开始写，导出的目录也是根目录，这样在引用时直接写 <code>go_package</code> 就可以了，但是具体情况还需灵活应对</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">option go_package = <span class="string">"lib_protobuf/msgproto"</span>;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ lib_protobuf</span><br><span class="line">$ protoc --proto_path=srcproto --go_out=.. examplemsg.proto</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">"fmt"</span></span><br><span class="line">   <span class="string">"log"</span></span><br><span class="line"></span><br><span class="line">   msg <span class="string">"lib_protobuf/msgproto"</span></span><br><span class="line"></span><br><span class="line">   <span class="string">"google.golang.org/protobuf/proto"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>Protobuf是一种由Google开发的用于序列化结构化数据的开源数据交换格式</li><li>使用<code>protoc</code> 工具可以将 <code>.proto</code> 文件导出成golang可用的数据交换文件</li><li><code>protoc-gen-go</code> 是一个用于生成 Go 代码的插件，它是 Protocol Buffers 编译器 <code>protoc</code> 的一部分</li><li>.proto文件中的<code>go_package</code>选项的值至少需要包含一个 <code>.</code> 或者 <code>/</code></li><li><code>go_package</code> 的值官方给出的示例是这种类似module名的写法 <code>example.com/project/protos/fizz</code></li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/136074333" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>仰天大笑出门去，我辈岂是蓬蒿人。不好意思，我们绝大多数都是蓬蒿人，都是陪跑的NPC，只是在穷尽一生的努力想做一颗稍微不那么矮的蓬蒿而已~</p><p>2024-2-18 16:44:18</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;Protobuf，全称Protocol Buffers，是一种由Google开发的用于序列化结构化数据的开源数据交换格式，Golang作为一种后端语言，免不了使用protobuf这种数据交换格式，本来打算写个小例子展示一下怎样在go语言中使用protobuf，结果遇到的问题到不少，特别是这个go_package的要求，也是之前在项目开发过程中遇到的，这次就查找一下具体原因以及怎么使用吧。&lt;/p&gt;
    
    </summary>
    
      <category term="Go" scheme="http://AlbertGithubHome.github.io/blog/categories/Go/"/>
    
    
      <category term="开发语言" scheme="http://AlbertGithubHome.github.io/blog/tags/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/"/>
    
      <category term="protobuf" scheme="http://AlbertGithubHome.github.io/blog/tags/protobuf/"/>
    
      <category term="golang" scheme="http://AlbertGithubHome.github.io/blog/tags/golang/"/>
    
      <category term="protoc" scheme="http://AlbertGithubHome.github.io/blog/tags/protoc/"/>
    
      <category term="go_package" scheme="http://AlbertGithubHome.github.io/blog/tags/go-package/"/>
    
  </entry>
  
  <entry>
    <title>简单聊聊go语言中引用模块的版本控制以及invalid: should be v0 or v1, not v2问题的解决</title>
    <link href="http://AlbertGithubHome.github.io/blog/2024/02/09/%E7%AE%80%E5%8D%95%E8%81%8A%E8%81%8Ago%E8%AF%AD%E8%A8%80%E4%B8%AD%E5%BC%95%E7%94%A8%E6%A8%A1%E5%9D%97%E7%9A%84%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E4%BB%A5%E5%8F%8Ainvalid-should-be-v0-or-v1-not-v2%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3/"/>
    <id>http://AlbertGithubHome.github.io/blog/2024/02/09/简单聊聊go语言中引用模块的版本控制以及invalid-should-be-v0-or-v1-not-v2问题的解决/</id>
    <published>2024-02-08T16:45:00.000Z</published>
    <updated>2024-02-19T15:48:12.961Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>如果你接触go语言比较早，一定有过当年所有go源码全部放入 <code>GOPATH</code> 下的混乱经历，不过发展到今天，go的包管理使用 <code>go.mod</code> 和 <code>go.work</code> 已经能得心应手，满足绝大多数的开发不成问题，其实在 <code>go.mod</code> 引入之后，go的包管理就有了明显的改善，再也不像原来那样好似闹着玩一样了，关于go.mod使用和管理我也是一知半解，想要教程可去官网或者查找各种详解资料，只是最近有点疑惑，这个go.mod以及go.sum要不要自己手动管理，带着这个疑问我做了一些测试可以得出，go.mod 的最初不需要手动管理，如果后来需要调整引入包的版本，可以手动调整。</p><a id="more"></a><p>以下是来自ChatGPT的关于 <code>go.mod</code> 和 <code>go.sum</code> 作用的回答，还是比较清晰的，如果还不太明白可以看看后面的例子感受一下</p><blockquote><p><code>go.mod</code> 和 <code>go.sum</code> 文件是 Go Modules 的重要组成部分，用于管理项目的依赖关系。共同为 Go 项目提供了依赖管理的基础，确保了项目的稳定性和可维护性：</p><ol><li><p><strong>go.mod</strong>：</p><ul><li>定义了项目的模块信息，包括模块名称、版本和依赖项等。</li><li>确定了项目的模块根目录。</li><li>记录了项目所依赖的其他模块及其版本信息。</li><li>提供了一种清晰的方式来管理项目的依赖关系，使得项目的构建和维护更加可靠和可控。</li></ul></li><li><p><strong>go.sum</strong>：</p><ul><li>记录了每个依赖模块的哈希值，以保证项目的构建是可复现的。</li><li>确保了项目依赖项的完整性，防止恶意篡改或不完整的依赖项被用于构建项目。</li><li>当使用 <code>go mod verify</code> 命令时，<code>go.sum</code> 文件会被用来验证依赖项的完整性。</li></ul></li></ol></blockquote><p>&gt;</p><blockquote><p>通常情况下，<code>go.mod</code> 文件是由 <code>go</code> 工具自动生成和管理的，不需要手动修改。当你执行一些与模块相关的操作时（例如使用 <code>go get</code> 安装新的依赖、使用 <code>go mod tidy</code> 整理依赖、或者更新依赖版本等），<code>go</code> 工具会自动更新 <code>go.mod</code> 文件以反映这些变化，但是，在某些特定情况下，你可能需要手动编辑 <code>go.mod</code> 文件，例如：</p><ol><li><p>手动添加或删除依赖项：你可能希望手动添加新的依赖项，或者删除不再需要的依赖项。在这种情况下，你需要手动编辑 <code>go.mod</code> 文件，并执行 <code>go mod tidy</code> 命令以确保依赖关系的一致性。</p></li><li><p>手动指定依赖版本：有时你可能希望显式地指定某个依赖项的特定版本。在这种情况下，你需要编辑 <code>go.mod</code> 文件，并指定对应的版本号。</p></li></ol><p>总的来说，虽然 <code>go.mod</code> 文件通常是由 <code>go</code> 工具自动维护的，但在某些情况下手动编辑是必要的。在编辑 <code>go.mod</code> 文件时，确保遵循 Go 模块的规范，并注意保持文件的格式正确和依赖关系的一致性。</p></blockquote><h1 id="具体示例"><a href="#具体示例" class="headerlink" title="具体示例"></a>具体示例</h1><p>假设有一个需求，要读取 <code>.xlsx</code> 格式表格文件的所有页签名，解析Excel文件这么基础的工作肯定有人写好了，我们直接引入module不需要重新再写一遍了，我们新建一个包含go.mod的工程来使用它</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir lib_xlsx</span><br><span class="line">$ <span class="built_in">cd</span> lib_xlsx</span><br><span class="line">$ go mod init lib_xlsx</span><br><span class="line">go: creating new go.mod: module lib_xlsx</span><br><span class="line"></span><br><span class="line">$ touch lib_xlsx.go</span><br><span class="line">$ ls</span><br><span class="line">go.mod  lib_xlsx.go</span><br></pre></td></tr></table></figure><p>go.mod的初始文件内容为</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">module lib_xlsx</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="number">1.19</span></span><br></pre></td></tr></table></figure><p>打开 <code>lib_xlsx.go</code> 文件编写如下代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">"fmt"</span></span><br><span class="line">   <span class="string">"log"</span></span><br><span class="line"></span><br><span class="line">   <span class="string">"github.com/tealeg/xlsx"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">   xlFile, err := xlsx.OpenFile(<span class="string">"example.xlsx"</span>)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      log.Fatalf(<span class="string">"Error opening file: %s"</span>, err)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> _, sheet := <span class="keyword">range</span> xlFile.Sheets &#123;</span><br><span class="line">      fmt.Println(<span class="string">"Sheet Name:"</span>, sheet.Name)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码是不是很简单，此时不出意外IDE会提醒你 <code>could not import github.com/tealeg/xlsx</code> 的错误，因为我们还没下载这个包，只需要在命令行执行 <code>go get github.com/tealeg/xlsx</code> 既可下载，同时会自动更新 <code>go.mod</code> 和 <code>go.sum</code> 文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ go get github.com/tealeg/xlsx</span><br><span class="line">go: added github.com/tealeg/xlsx v1.0.5</span><br></pre></td></tr></table></figure><p>自动更新后的 go.mod 文件内容，引用了 <code>github.com/tealeg/xlsx</code> 库的 <code>v1.0.5</code> 版本</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">module lib_xlsx</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="number">1.19</span></span><br><span class="line"></span><br><span class="line">require github.com/tealeg/xlsx v1<span class="number">.0</span><span class="number">.5</span></span><br></pre></td></tr></table></figure><p>自动更新后的 go.sum 文件内容，记录了各个依赖库、间接依赖库以及项目go.mod文件的hash值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">github.com/kr/pretty v0<span class="number">.1</span><span class="number">.0</span> h1:L/CwN0zerZDmRFUapSPitk6f+Q3+<span class="number">0</span>za1rQkzVuMiMFI=</span><br><span class="line">github.com/kr/pretty v0<span class="number">.1</span><span class="number">.0</span>/<span class="keyword">go</span>.mod h1:dAy3ld7l9f0ibDNOQOHHMYYIIbhfbHSm3C4ZsoJORNo=</span><br><span class="line">github.com/kr/pty v1<span class="number">.1</span><span class="number">.1</span>/<span class="keyword">go</span>.mod h1:pFQYn66WHrOpPYNljwOMqo10TkYh1fy3cYio2l3bCsQ=</span><br><span class="line">github.com/kr/text v0<span class="number">.1</span><span class="number">.0</span> h1:<span class="number">45s</span>CR5RtlFHMR4UwH9sdQ5TC8v0qDQCHnXt+kaKSTVE=</span><br><span class="line">github.com/kr/text v0<span class="number">.1</span><span class="number">.0</span>/<span class="keyword">go</span>.mod h1:<span class="number">4</span>Jbv+DJW3UT/LiOwJeYQe1efqtUx/iVham/<span class="number">4</span>vfdArNI=</span><br><span class="line">github.com/tealeg/xlsx v1<span class="number">.0</span><span class="number">.5</span> h1:+f8oFmvY8Gw1iUXzPk+kz+<span class="number">4</span>GpbDZPK1FhPiQRd+ypgE=</span><br><span class="line">github.com/tealeg/xlsx v1<span class="number">.0</span><span class="number">.5</span>/<span class="keyword">go</span>.mod h1:btRS8dz54TDnvKNosuAqxrM1QgN1udgk9O34bDCnORM=</span><br><span class="line">gopkg.in/check.v1 v1<span class="number">.0</span><span class="number">.0</span><span class="number">-20190902080502</span><span class="number">-41f</span>04d3bba15 h1:YR8cESwS4TdDjEe65xsg0ogRM/Nc3DYOhEAlW+xobZo=</span><br><span class="line">gopkg.in/check.v1 v1<span class="number">.0</span><span class="number">.0</span><span class="number">-20190902080502</span><span class="number">-41f</span>04d3bba15/<span class="keyword">go</span>.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=</span><br></pre></td></tr></table></figure><p>此时程序已经写完，依赖关系也已经下载好了，直接运行就可以</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ go run .</span><br><span class="line">Sheet Name: Sheet1</span><br><span class="line">Sheet Name: Sheet2</span><br><span class="line">Sheet Name: Sheet3</span><br></pre></td></tr></table></figure><p>因为 <code>go.mod</code> 和 <code>go.sum</code> 文件共同为这个项目提供了依赖管理，别人在下载你这份<a href="https://github.com/AlbertGithubHome/go/tree/master/lib_xlsx" target="_blank" rel="noopener">源码</a>时，先执行 <code>go mod tidy</code> 根据依赖关系下载正确的版本库，之后就可以直接编译运行了</p><h1 id="手动升级依赖库"><a href="#手动升级依赖库" class="headerlink" title="手动升级依赖库"></a>手动升级依赖库</h1><p>到目前为止，我们并没有手动编辑过 go.mod 文件，只是在使用 <code>go get github.com/tealeg/xlsx</code> 自动更新了这个文件，假设这个例子的需求要扩展，引用的 <code>github.com/tealeg/xlsx</code> 功能是在<code>v1.0.6</code> 版本新加的，那么我么只需要将 <code>go.mod</code> 文件中的 <code>v1.0.5</code> 替换成 <code>v1.0.6</code>，然后执行 <code>go mod tidy</code> 即可下载正确的依赖库。</p><p>但如果要引用的依赖库版本不是 <code>v0</code> 或者 <code>v1</code> 版本的就不能这么处理了，具体做法看下面的问题。</p><h1 id="should-be-v0-or-v1-not-v2"><a href="#should-be-v0-or-v1-not-v2" class="headerlink" title="should be v0 or v1, not v2"></a>should be v0 or v1, not v2</h1><p>当你手动把 <code>go.mod</code> 文件中的 <code>v1.0.5</code> 替换成 <code>v2.x.x</code> 执行 <code>go mod tidy</code> 时就会报一个错误</p><blockquote><p>errors parsing go.mod: /xxx/lib_xlsx/go.mod:5: require github.com/tealeg/xlsx: version “v2.0.0” invalid: should be v0 or v1, not v2</p></blockquote><p>问题的原因及细节可以参考这篇文档<a href="https://mileslin.github.io/2020/08/Golang/%E5%88%B0%E5%BA%95-go-get-%E7%9A%84%E7%89%88%E8%99%9F%E6%80%8E%E9%BA%BC%E9%81%8B%E4%BD%9C%E7%9A%84/" target="_blank" rel="noopener">《[Go] 到底 go get 的版號怎麼運作的?》</a>中关于“Semantic import version”的描述</p><p>复杂的原因简单说：Go有一个规范，就是在启用了Go Module的仓库上如果想使用 v2 及以上版本，需要在原引用库上添加版本标识简写，比如这个例子中，我们需要将 <code>lib_xlsx.go</code> 文件中引用包的代码改成下面这样</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">"fmt"</span></span><br><span class="line">   <span class="string">"log"</span></span><br><span class="line"></span><br><span class="line">   <span class="string">"github.com/tealeg/xlsx/v3"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>执行 <code>go mod tidy</code> 命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ go mod tidy</span><br><span class="line">go: finding module <span class="keyword">for</span> package github.com/tealeg/xlsx/v3</span><br><span class="line">go: found github.com/tealeg/xlsx/v3 <span class="keyword">in</span> github.com/tealeg/xlsx/v3 v3.3.5</span><br></pre></td></tr></table></figure><p>如果遇到下面这个问题，确认修改无误的话多尝试几次</p><blockquote><p>$ go mod tidy<br>go: finding module for package github.com/tealeg/xlsx/v3<br>lib_xlsx imports<br>       github.com/tealeg/xlsx/v3: module github.com/tealeg/xlsx/v3: Get “<a href="https://proxy.golang.org/github.com/tealeg/xlsx/v3/@v/list" target="_blank" rel="noopener">https://proxy.golang.org/github.com/tealeg/xlsx/v3/@v/list</a>“: EOF</p></blockquote><p>执行过后 go.mod 和 go.sum 两个文件改变后的内容如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">module lib_xlsx</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="number">1.19</span></span><br><span class="line"></span><br><span class="line">require github.com/tealeg/xlsx/v3 v3<span class="number">.3</span><span class="number">.5</span></span><br><span class="line"></span><br><span class="line">require (</span><br><span class="line">   github.com/frankban/quicktest v1<span class="number">.14</span><span class="number">.6</span> <span class="comment">// indirect</span></span><br><span class="line">   github.com/google/btree v1<span class="number">.0</span><span class="number">.0</span> <span class="comment">// indirect</span></span><br><span class="line">   github.com/google/<span class="keyword">go</span>-cmp v0<span class="number">.5</span><span class="number">.9</span> <span class="comment">// indirect</span></span><br><span class="line">   github.com/kr/pretty v0<span class="number">.3</span><span class="number">.1</span> <span class="comment">// indirect</span></span><br><span class="line">   github.com/kr/text v0<span class="number">.2</span><span class="number">.0</span> <span class="comment">// indirect</span></span><br><span class="line">   github.com/peterbourgon/diskv/v3 v3<span class="number">.0</span><span class="number">.1</span> <span class="comment">// indirect</span></span><br><span class="line">   github.com/rogpeppe/fastuuid v1<span class="number">.2</span><span class="number">.0</span> <span class="comment">// indirect</span></span><br><span class="line">   github.com/rogpeppe/<span class="keyword">go</span>-internal v1<span class="number">.9</span><span class="number">.0</span> <span class="comment">// indirect</span></span><br><span class="line">   github.com/shabbyrobe/xmlwriter v0<span class="number">.0</span><span class="number">.0</span><span class="number">-20200208144257</span><span class="number">-9f</span>ca06d00ffa <span class="comment">// indirect</span></span><br><span class="line">   golang.org/x/text v0<span class="number">.3</span><span class="number">.8</span> <span class="comment">// indirect</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">github.com/creack/pty v1<span class="number">.1</span><span class="number">.9</span>/<span class="keyword">go</span>.mod h1:oKZEueFk5CKHvIhNR5MUki03XCEU+Q6VDXinZuGJ33E=</span><br><span class="line">github.com/frankban/quicktest v1<span class="number">.14</span><span class="number">.6</span> h1:<span class="number">7</span>Xjx+VpznH+oBnejlPUj8oUpdxnVs4f8XU8WnHkI4W8=</span><br><span class="line">github.com/frankban/quicktest v1<span class="number">.14</span><span class="number">.6</span>/<span class="keyword">go</span>.mod h1:<span class="number">4</span>ptaffx2x8+WTWXmUCuVU6aPUX1/Mz7zb5vbUoiM6w0=</span><br><span class="line">github.com/google/btree v1<span class="number">.0</span><span class="number">.0</span> h1:<span class="number">0</span>udJVsspx3VBr5FwtLhQQtuAsVc79tTq0ocGIPAU6qo=</span><br><span class="line">github.com/google/btree v1<span class="number">.0</span><span class="number">.0</span>/<span class="keyword">go</span>.mod h1:lNA+<span class="number">9</span>X1NB3Zf8V7Ke586lFgjr2dZNuvo3lPJSGZ5JPQ=</span><br><span class="line">github.com/google/<span class="keyword">go</span>-cmp v0<span class="number">.5</span><span class="number">.9</span> h1:O2Tfq5qg4qc4AmwVlvv0oLiVAGB7enBSJ2x2DqQFi38=</span><br><span class="line">github.com/google/<span class="keyword">go</span>-cmp v0<span class="number">.5</span><span class="number">.9</span>/<span class="keyword">go</span>.mod h1:<span class="number">17d</span>UlkBOakJ0+DkrSSNjCkIjxS6bF9zb3elmeNGIjoY=</span><br><span class="line">github.com/kr/pretty v0<span class="number">.3</span><span class="number">.1</span> h1:flRD4NNwYAUpkphVc1HcthR4KEIFJ65n8Mw5qdRn3LE=</span><br><span class="line">github.com/kr/pretty v0<span class="number">.3</span><span class="number">.1</span>/<span class="keyword">go</span>.mod h1:hoEshYVHaxMs3cyo3Yncou5ZscifuDolrwPKZanG3xk=</span><br><span class="line">github.com/kr/text v0<span class="number">.2</span><span class="number">.0</span> h1:<span class="number">5</span>Nx0Ya0ZqY2ygV366QzturHI13Jq95ApcVaJBhpS+AY=</span><br><span class="line">github.com/kr/text v0<span class="number">.2</span><span class="number">.0</span>/<span class="keyword">go</span>.mod h1:eLer722TekiGuMkidMxC/pM04lWEeraHUUmBw8l2grE=</span><br><span class="line">github.com/niemeyer/pretty v0<span class="number">.0</span><span class="number">.0</span><span class="number">-20200227124842</span>-a10e7caefd8e h1:fD57ERR4JtEqsWbfPhv4DMiApHyliiK5xCTNVSPiaAs=</span><br><span class="line">github.com/peterbourgon/diskv/v3 v3<span class="number">.0</span><span class="number">.1</span> h1:x06SQA46+PKIUftmEujdwSEpIx8kR+M9eLYsUxeYveU=</span><br><span class="line">github.com/peterbourgon/diskv/v3 v3<span class="number">.0</span><span class="number">.1</span>/<span class="keyword">go</span>.mod h1:kJ5Ny7vLdARGU3WUuy6uzO6T0nb/<span class="number">2</span>gWcT1JiBvRmb5o=</span><br><span class="line">github.com/pkg/diff v0<span class="number">.0</span><span class="number">.0</span><span class="number">-20210226163009</span><span class="number">-20</span>ebb0f2a09e/<span class="keyword">go</span>.mod h1:pJLUxLENpZxwdsKMEsNbx1VGcRFpLqf3715MtcvvzbA=</span><br><span class="line">github.com/pkg/profile v1<span class="number">.5</span><span class="number">.0</span> h1:<span class="number">042</span>Buzk+NhDI+DeSAA62RwJL8VAuZUMQZUjCsRz1Mug=</span><br><span class="line">github.com/rogpeppe/fastuuid v1<span class="number">.2</span><span class="number">.0</span> h1:Ppwyp6VYCF1nvBTXL3trRso7mXMlRrw9ooo375wvi2s=</span><br><span class="line">github.com/rogpeppe/fastuuid v1<span class="number">.2</span><span class="number">.0</span>/<span class="keyword">go</span>.mod h1:jVj6XXZzXRy/MSR5jhDC/<span class="number">2</span>q6DgLz+nrA6LYCDYWNEvQ=</span><br><span class="line">github.com/rogpeppe/<span class="keyword">go</span>-internal v1<span class="number">.9</span><span class="number">.0</span> h1:<span class="number">73</span>kH8U+JUqXU8lRuOHeVHaa/SZPifC7BkcraZVejAe8=</span><br><span class="line">github.com/rogpeppe/<span class="keyword">go</span>-internal v1<span class="number">.9</span><span class="number">.0</span>/<span class="keyword">go</span>.mod h1:WtVeX8xhTBvf0smdhujwtBcq4Qrzq/fJaraNFVN+nFs=</span><br><span class="line">github.com/shabbyrobe/xmlwriter v0<span class="number">.0</span><span class="number">.0</span><span class="number">-20200208144257</span><span class="number">-9f</span>ca06d00ffa h1:<span class="number">2</span>cO3RojjYl3hVTbEvJVqrMaFmORhL6O06qdW42toftk=</span><br><span class="line">github.com/shabbyrobe/xmlwriter v0<span class="number">.0</span><span class="number">.0</span><span class="number">-20200208144257</span><span class="number">-9f</span>ca06d00ffa/<span class="keyword">go</span>.mod h1:Yjr3bdWaVWyME1kha7X0jsz3k2DgXNa1Pj3XGyUAbx8=</span><br><span class="line">github.com/tealeg/xlsx/v3 v3<span class="number">.3</span><span class="number">.5</span> h1:dzmns01jRf0SveBe7VqkcO2LCLOcypcDI6H66PiZycQ=</span><br><span class="line">github.com/tealeg/xlsx/v3 v3<span class="number">.3</span><span class="number">.5</span>/<span class="keyword">go</span>.mod h1:KV4FTFtvGy0TBlOivJLZu/YNZk6e0Qtk7eOSglWksuA=</span><br><span class="line">golang.org/x/text v0<span class="number">.3</span><span class="number">.2</span>/<span class="keyword">go</span>.mod h1:bEr9sfX3Q8Zfm5fL9x+<span class="number">3i</span>togRgK3+ptLWKqgva+<span class="number">5d</span>Ak=</span><br><span class="line">golang.org/x/text v0<span class="number">.3</span><span class="number">.8</span> h1:nAL+RVCQ9uMn3vJZbV+MRnydTJFPf8qqY42YiA6MrqY=</span><br><span class="line">golang.org/x/text v0<span class="number">.3</span><span class="number">.8</span>/<span class="keyword">go</span>.mod h1:E6s5w1FMmriuDzIBO73fBruAKo1PCIq6d2Q6DHfQ8WQ=</span><br><span class="line">golang.org/x/tools v0<span class="number">.0</span><span class="number">.0</span><span class="number">-20180917221912</span><span class="number">-90f</span>a682c2a6e/<span class="keyword">go</span>.mod h1:n7NCudcB/nEzxVGmLbDWY5pfWTLqBcC2KZ6jyYvM4mQ=</span><br><span class="line">gopkg.in/check.v1 v1<span class="number">.0</span><span class="number">.0</span><span class="number">-20200902074654</span><span class="number">-038f</span>dea0a05b h1:QRR6H1YWRnHb4Y/HeNFCTJLFVxaq6wH4YuVdsUOr75U=</span><br></pre></td></tr></table></figure><p>将 github.com/tealeg/xlsx 从 <code>v1.0.5</code> 升级到 <code>v3.3.5</code> 真是加了不少间接依赖库啊</p><p>至此 go.mod 文件的自动更新和手动维护我们就都尝试过了</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li><code>go.mod</code> 和 <code>go.sum</code> 文件是 Go Modules 的重要组成部分，用于管理项目的依赖关系</li><li><code>go.mod</code> 文件是由 <code>go</code> 工具自动生成和管理的，不需要手动修改，常用命令 <code>go get xxx</code> 和 <code>go mod tidy</code></li><li>如果想显式地指定某个依赖项的特定版本才需要手动编辑 <code>go.mod</code> 文件</li><li><code>go.sum</code> 文件记录了每个依赖模块的哈希值，以保证项目的构建是可复现的</li><li>如果在启用了Go Module的仓库想使用 v2 及以上版本，需要在原引用库路径末尾添加版本标识简写，比如v2、v3等</li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/135922149" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>穷则独善其身，达则兼济天下，如今在这纷繁的世间，独善其身已实属不易，天下交给你们，我自顺其自然吧~</p><p>2024-2-8 15:59:19</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;如果你接触go语言比较早，一定有过当年所有go源码全部放入 &lt;code&gt;GOPATH&lt;/code&gt; 下的混乱经历，不过发展到今天，go的包管理使用 &lt;code&gt;go.mod&lt;/code&gt; 和 &lt;code&gt;go.work&lt;/code&gt; 已经能得心应手，满足绝大多数的开发不成问题，其实在 &lt;code&gt;go.mod&lt;/code&gt; 引入之后，go的包管理就有了明显的改善，再也不像原来那样好似闹着玩一样了，关于go.mod使用和管理我也是一知半解，想要教程可去官网或者查找各种详解资料，只是最近有点疑惑，这个go.mod以及go.sum要不要自己手动管理，带着这个疑问我做了一些测试可以得出，go.mod 的最初不需要手动管理，如果后来需要调整引入包的版本，可以手动调整。&lt;/p&gt;
    
    </summary>
    
      <category term="Go" scheme="http://AlbertGithubHome.github.io/blog/categories/Go/"/>
    
    
      <category term="Go" scheme="http://AlbertGithubHome.github.io/blog/tags/Go/"/>
    
      <category term="mod" scheme="http://AlbertGithubHome.github.io/blog/tags/mod/"/>
    
      <category term="import" scheme="http://AlbertGithubHome.github.io/blog/tags/import/"/>
    
      <category term="xlsx" scheme="http://AlbertGithubHome.github.io/blog/tags/xlsx/"/>
    
      <category term="依赖库版本" scheme="http://AlbertGithubHome.github.io/blog/tags/%E4%BE%9D%E8%B5%96%E5%BA%93%E7%89%88%E6%9C%AC/"/>
    
  </entry>
  
  <entry>
    <title>使用nslookup命令查询域名系统的信息</title>
    <link href="http://AlbertGithubHome.github.io/blog/2024/01/29/%E4%BD%BF%E7%94%A8nslookup%E5%91%BD%E4%BB%A4%E6%9F%A5%E8%AF%A2%E5%9F%9F%E5%90%8D%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BF%A1%E6%81%AF/"/>
    <id>http://AlbertGithubHome.github.io/blog/2024/01/29/使用nslookup命令查询域名系统的信息/</id>
    <published>2024-01-29T14:11:51.000Z</published>
    <updated>2024-02-19T15:22:29.280Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这个命令出现在与运维同学沟通过程中，在此之前要是问我一个域名对应的服务器是IP地址是什么，我肯定优先想到的是 <code>ping</code> 这个命令，这个命令确实可以在回复的信息中看到IP地址，但是不全面，有时一个域名对应不止一个IP地址，这时就要用到 nslookup 命令了，这也是在沟通中学到的新知识点。</p><a id="more"></a><h1 id="常规使用"><a href="#常规使用" class="headerlink" title="常规使用"></a>常规使用</h1><p>学这个命令就是拿来用的，最常见的用法就是 <code>nslookup 域名</code> 来查询域名对应的IP，并且这个用法在Windows(cmd)、Mac、Linux下都是通用的，算是一个不错的跨平台命令，对比一下 <code>ping</code> 看看有什么区别：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\Administrator&gt;ping a1.easemob.com</span><br><span class="line"></span><br><span class="line">正在 Ping a1-v2.easemob.com.x.easeslb.com [47.93.162.59] 具有 32 字节的数据:</span><br><span class="line">来自 47.93.162.59 的回复: 字节=32 时间=7ms TTL=88</span><br><span class="line">来自 47.93.162.59 的回复: 字节=32 时间=7ms TTL=88</span><br><span class="line">来自 47.93.162.59 的回复: 字节=32 时间=6ms TTL=88</span><br><span class="line">来自 47.93.162.59 的回复: 字节=32 时间=6ms TTL=88</span><br><span class="line"></span><br><span class="line">47.93.162.59 的 Ping 统计信息:</span><br><span class="line">    数据包: 已发送 = 4，已接收 = 4，丢失 = 0 (0% 丢失)，</span><br><span class="line">往返行程的估计时间(以毫秒为单位):</span><br><span class="line">    最短 = 6ms，最长 = 7ms，平均 = 6ms</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\Administrator&gt;nslookup a1.easemob.com</span><br><span class="line">服务器:  UnKnown</span><br><span class="line">Address:  10.20.30.40</span><br><span class="line"></span><br><span class="line">名称:    a1-v2.easemob.com.x.easeslb.com</span><br><span class="line">Addresses:  2408:4000:200::c5</span><br><span class="line">          2408:4000:200::17</span><br><span class="line">          47.93.162.59</span><br><span class="line">          39.97.9.52</span><br><span class="line">Aliases:  a1.easemob.com</span><br></pre></td></tr></table></figure><p>以上都是在cmd下执行的，如果在PowerShell中有一个名叫 <code>Resolve-DnsName</code> 的替代命令，执行结果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\Administrator&gt; Resolve-DnsName a1.easemob.com</span><br><span class="line"></span><br><span class="line">Name                           Type   TTL   Section    NameHost</span><br><span class="line">----                           ----   ---   -------    --------</span><br><span class="line">a1.easemob.com                 CNAME  0     Answer     a1-v2.easemob.com.x.easeslb.com</span><br><span class="line"></span><br><span class="line">Name       : a1-v2.easemob.com.x.easeslb.com</span><br><span class="line">QueryType  : AAAA</span><br><span class="line">TTL        : 0</span><br><span class="line">IP6Address : 2408:4000:200::17</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Name       : a1-v2.easemob.com.x.easeslb.com</span><br><span class="line">QueryType  : AAAA</span><br><span class="line">TTL        : 0</span><br><span class="line">Section    : Answer</span><br><span class="line">IP6Address : 2408:4000:200::c5</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">QueryType  : A</span><br><span class="line">TTL        : 0</span><br><span class="line">Section    : Answer</span><br><span class="line">IP4Address : 47.93.162.59</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Name       : a1-v2.easemob.com.x.easeslb.com</span><br><span class="line">QueryType  : A</span><br><span class="line">TTL        : 0</span><br><span class="line">Section    : Answer</span><br><span class="line">IP4Address : 39.97.9.213</span><br></pre></td></tr></table></figure><p>对于上述 <code>Resolve-DnsName</code> 命令的输出的结果解释如下：</p><ol><li><p><strong>CNAME 记录：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a1.easemob.com                 CNAME  0     Answer     a1-v2.easemob.com.x.easeslb.com</span><br></pre></td></tr></table></figure><p>这一行表示 <code>a1.easemob.com</code> 是一个别名（CNAME）记录，指向了 <code>a1-v2.easemob.com.x.easeslb.com</code>。</p></li><li><p><strong>AAAA 记录（IPv6 地址）：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Name       : a1-v2.easemob.com.x.easeslb.com</span><br><span class="line">QueryType  : AAAA</span><br><span class="line">TTL        : 0</span><br><span class="line">Section    : Answer</span><br><span class="line">IP6Address : 2408:4000:200::17</span><br></pre></td></tr></table></figure><p>这一行表示 <code>a1-v2.easemob.com.x.easeslb.com</code> 对应的 IPv6 地址是 <code>2408:4000:200::17</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Name       : a1-v2.easemob.com.x.easeslb.com</span><br><span class="line">QueryType  : AAAA</span><br><span class="line">TTL        : 0</span><br><span class="line">Section    : Answer</span><br><span class="line">IP6Address : 2408:4000:200::c5</span><br></pre></td></tr></table></figure><p>这一行表示 <code>a1-v2.easemob.com.x.easeslb.com</code> 对应的另一个 IPv6 地址是 <code>2408:4000:200::c5</code>。</p></li><li><p><strong>A 记录（IPv4 地址）：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Name       : a1-v2.easemob.com.x.easeslb.com</span><br><span class="line">QueryType  : A</span><br><span class="line">TTL        : 0</span><br><span class="line">Section    : Answer</span><br><span class="line">IP4Address : 47.93.162.59</span><br></pre></td></tr></table></figure><p>这一行表示 <code>a1-v2.easemob.com.x.easeslb.com</code> 对应的 IPv4 地址是 <code>47.93.162.59</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Name       : a1-v2.easemob.com.x.easeslb.com</span><br><span class="line">QueryType  : A</span><br><span class="line">TTL        : 0</span><br><span class="line">Section    : Answer</span><br><span class="line">IP4Address : 39.97.9.213</span><br></pre></td></tr></table></figure><p>这一行表示 <code>a1-v2.easemob.com.x.easeslb.com</code> 对应的另一个 IPv4 地址是 <code>39.97.9.213</code>。</p></li></ol><p>综上所述，查询结果显示了域名 <code>a1.easemob.com</code> 的别名记录（CNAME）以及对应的IPv6和IPv4地址。IPv6地址有两个，分别是 <code>2408:4000:200::17</code> 和 <code>2408:4000:200::c5</code>，而IPv4地址有两个，分别是 <code>47.93.162.59</code> 和 <code>39.97.9.213</code>。</p><h1 id="再从linux环境下学点不一样的"><a href="#再从linux环境下学点不一样的" class="headerlink" title="再从linux环境下学点不一样的"></a>再从linux环境下学点不一样的</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ nslookup a1.easemob.com</span><br><span class="line">Server:         127.0.0.53</span><br><span class="line">Address:        127.0.0.53<span class="comment">#53</span></span><br><span class="line"></span><br><span class="line">Non-authoritative answer:</span><br><span class="line">a1.easemob.com  canonical name = a1-v2.easemob.com.x.easeslb.com.</span><br><span class="line">Name:   a1-v2.easemob.com.x.easeslb.com</span><br><span class="line">Address: 39.97.9.213</span><br><span class="line">Name:   a1-v2.easemob.com.x.easeslb.com</span><br><span class="line">Address: 47.93.162.59</span><br><span class="line">Name:   a1-v2.easemob.com.x.easeslb.com</span><br><span class="line">Address: 2408:4000:200::17</span><br><span class="line">Name:   a1-v2.easemob.com.x.easeslb.com</span><br><span class="line">Address: 2408:4000:200::c5</span><br></pre></td></tr></table></figure><p>在linux环境下使用基础命令，还在cmd环境下的输出结果类似，但是比<code>Resolve-DnsName</code>命令输出的结果要简陋许多，但是可以通过添加参数来扩展命令。</p><h2 id="type选项"><a href="#type选项" class="headerlink" title="type选项"></a>type选项</h2><p><code>nslookup</code> 命令中的 <code>type</code> 参数用于指定查询的记录类型，即你想要获取的特定 DNS 记录的类型。以下是一些常见的 <code>type</code> 参数及其解释：</p><ul><li><p><strong>A (Address Record):</strong><code>nslookup example.com type=A</code> 查询域名 <code>example.com</code> 的 IPv4 地址</p></li><li><p><strong>AAAA (IPv6 Address Record):</strong><code>nslookup example.com type=AAAA</code> 查询域名 <code>example.com</code> 的 IPv6 地址</p></li><li><p><strong>CNAME (Canonical Name Record):</strong><code>nslookup example.com type=CNAME</code> 查询域名 <code>example.com</code> 的别名记录</p></li><li><p><strong>MX (Mail Exchange Record):</strong><code>nslookup example.com type=MX</code> 查询域名 <code>example.com</code> 的邮件交换记录</p></li><li><p><strong>NS (Name Server Record):</strong><code>nslookup example.com type=NS</code> 查询域名 <code>example.com</code> 的域名服务器记录</p></li><li><p><strong>PTR (Pointer Record):</strong><code>nslookup 192.168.1.1 type=PTR</code> 查询 IP 地址 <code>192.168.1.1</code> 对应的域名</p></li><li><p><strong>SOA (Start of Authority Record):</strong><code>nslookup example.com type=SOA</code> 查询域名 <code>example.com</code> 的权威区域起始记录</p></li><li><p><strong>TXT (Text Record):</strong><code>nslookup example.com type=TXT</code> 查询域名 <code>example.com</code> 的文本记录</p></li><li><p><strong>SRV (Service Record):</strong><code>nslookup _ldap._tcp.example.com type=SRV</code> 查询服务记录，例如 LDAP 服务</p></li><li><p><strong>ANY (Any Record):</strong><code>nslookup example.com type=ANY</code>   查询域名 <code>example.com</code> 的所有记录类型</p></li></ul><p>这些是常见的 <code>type</code> 参数，可以根据需要选择合适的类型来获取特定类型的 DNS 记录信息。在命令中，<code>type</code> 参数通常是可选的，如果不指定，默认为 <code>A</code> 记录</p><h2 id="retry选项"><a href="#retry选项" class="headerlink" title="retry选项"></a>retry选项</h2><p>该参数用于设置在没有收到响应时的重试次数。如果发送的 DNS 查询请求没有得到响应，<code>nslookup</code> 将会尝试重新发送请求，次数由 <code>-retry</code> 指定</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nslookup -retry=3 example.com</span><br></pre></td></tr></table></figure><p>  这个示例中，<code>-retry=3</code> 表示设置重试次数为3次。如果第一次查询没有得到响应，<code>nslookup</code> 将尝试再次发送查询请求，最多重试3次</p><h2 id="timeout选项"><a href="#timeout选项" class="headerlink" title="timeout选项"></a>timeout选项</h2><p>该参数用于设置等待响应的超时时间，以秒为单位。如果在指定的超时时间内没有收到响应，<code>nslookup</code> 将认为查询失败</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nslookup -timeout=5 example.com</span><br></pre></td></tr></table></figure><p>  这个示例中，<code>-timeout=5</code> 表示设置超时时间为5秒。如果在5秒内没有收到查询响应，<code>nslookup</code> 将认为查询失败</p><h1 id="使用更强大的dig命令"><a href="#使用更强大的dig命令" class="headerlink" title="使用更强大的dig命令"></a>使用更强大的dig命令</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">$ dig a1.easemob.com</span><br><span class="line"></span><br><span class="line">; &lt;&lt;&gt;&gt; DiG 9.16.1-Ubuntu &lt;&lt;&gt;&gt; a1.easemob.com</span><br><span class="line">;; global options: +cmd</span><br><span class="line">;; Got answer:</span><br><span class="line">;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 1464</span><br><span class="line">;; flags: qr rd ra; QUERY: 1, ANSWER: 3, AUTHORITY: 0, ADDITIONAL: 1</span><br><span class="line"></span><br><span class="line">;; OPT PSEUDOSECTION:</span><br><span class="line">; EDNS: version: 0, flags:; udp: 65494</span><br><span class="line">;; QUESTION SECTION:</span><br><span class="line">;a1.easemob.com.                        IN      A</span><br><span class="line"></span><br><span class="line">;; ANSWER SECTION:</span><br><span class="line">a1.easemob.com.         0       IN      CNAME   a1-v2.easemob.com.x.easeslb.com.</span><br><span class="line">a1-v2.easemob.com.x.easeslb.com. 0 IN   A       47.93.162.59</span><br><span class="line">a1-v2.easemob.com.x.easeslb.com. 0 IN   A       39.97.9.213</span><br><span class="line"></span><br><span class="line">;; Query time: 0 msec</span><br><span class="line">;; SERVER: 127.0.0.53<span class="comment">#53(127.0.0.53)</span></span><br><span class="line">;; WHEN: 一 1月 29 21:53:40 CST 2024</span><br><span class="line">;; MSG SIZE  rcvd: 117</span><br></pre></td></tr></table></figure><p>上述 <code>dig</code> 命令对域名 <code>a1.easemob.com</code> 进行查询的输出结构的含义解释如下：</p><ol><li><p><strong>头部信息 (<code>HEADER</code> 部分):</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 1464</span><br></pre></td></tr></table></figure><ul><li><code>opcode</code>: 查询操作的类型，这里是 <code>QUERY</code> 表示标准查询。</li><li><code>status</code>: 查询的状态，<code>NOERROR</code> 表示没有错误。</li><li><code>id</code>: 查询的唯一标识符，这里是 1464。</li></ul></li><li><p><strong>标志部分 (<code>flags</code> 部分):</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">;; flags: qr rd ra; QUERY: 1, ANSWER: 3, AUTHORITY: 0, ADDITIONAL: 1</span><br></pre></td></tr></table></figure><ul><li><code>qr</code>: 查询响应标志位，这里是 <code>qr</code> 表示响应。</li><li><code>rd</code>: 递归查询标志位，这里是 <code>rd</code> 表示递归查询。</li><li><code>ra</code>: 递归可用标志位，这里是 <code>ra</code> 表示递归可用。</li><li><code>QUERY: 1</code>: 查询的问题部分包含1个查询。</li><li><code>ANSWER: 3</code>: 响应部分包含3个回答。</li><li><code>AUTHORITY: 0</code>: 授权部分不包含任何信息。</li><li><code>ADDITIONAL: 1</code>: 附加部分包含1个附加记录。</li></ul></li><li><p><strong>OPT PSEUDOSECTION 部分:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">; EDNS: version: 0, flags:; udp: 65494</span><br></pre></td></tr></table></figure><ul><li><code>EDNS</code>: 扩展域名系统 (Extended DNS) 的信息。</li><li><code>version: 0</code>: EDNS 的版本。</li><li><code>flags:;</code>: EDNS 标志，这里为空。</li><li><code>udp: 65494</code>: 用于 DNS 查询和响应的最大 UDP 数据包大小。</li></ul></li><li><p><strong>请求部分 (<code>QUESTION SECTION</code>):</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">;; QUESTION SECTION:</span><br><span class="line">;a1.easemob.com.                        IN      A</span><br></pre></td></tr></table></figure><ul><li>查询的问题部分，这里是查询域名 <code>a1.easemob.com</code> 的 <code>A</code> 记录。</li></ul></li><li><p><strong>应答部分 (<code>ANSWER SECTION</code>):</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">;; ANSWER SECTION:</span><br><span class="line">a1.easemob.com.         0       IN      CNAME   a1-v2.easemob.com.x.easeslb.com.</span><br><span class="line">a1-v2.easemob.com.x.easeslb.com. 0 IN   A       47.93.162.59</span><br><span class="line">a1-v2.easemob.com.x.easeslb.com. 0 IN   A       39.97.9.213</span><br></pre></td></tr></table></figure><ul><li>响应部分包含了查询的回答，这里包含了3个记录。</li><li><code>CNAME</code> 记录：<code>a1.easemob.com</code> 是一个别名，指向 <code>a1-v2.easemob.com.x.easeslb.com</code>。</li><li><code>A</code> 记录：<code>a1-v2.easemob.com.x.easeslb.com</code> 对应两个IPv4地址，分别是 <code>47.93.162.59</code> 和 <code>39.97.9.213</code>。</li></ul></li><li><p><strong>查询时间 (<code>Query time</code>):</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">;; Query time: 0 msec</span><br></pre></td></tr></table></figure><ul><li>响应的查询时间，这里是 0 毫秒。</li></ul></li><li><p><strong>DNS 服务器信息 (<code>SERVER</code> 和 <code>WHEN</code> 部分):</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">;; SERVER: 127.0.0.53#53(127.0.0.53)</span><br><span class="line">;; WHEN: 一 1月 29 21:53:40 CST 2024</span><br></pre></td></tr></table></figure><ul><li><code>SERVER</code>: 显示响应的 DNS 服务器的IP地址和端口号。</li><li><code>WHEN</code>: 显示响应的时间戳。</li></ul></li><li><p><strong>消息大小 (<code>MSG SIZE</code>):</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">;; MSG SIZE  rcvd: 117</span><br></pre></td></tr></table></figure><ul><li>响应消息的大小，这里是 117 字节。</li></ul></li></ol><p>综上所述，这个 <code>dig</code> 查询输出提供了关于域名 <code>a1.easemob.com</code> 的详细信息，包括查询问题、响应部分（包括 CNAME 和 A 记录）、查询时间、DNS 服务器信息以及响应消息的大小。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>使用 <code>nslookup</code> 命令可以用来查询域名对应的IP <code>nslookup a1.easemob.com</code></li><li>使用 <code>nslookup</code> 命令也可以用来查询IP对应的域名 <code>nslookup 8.8.8.8 -ty=PTR 1.1.1.1</code></li><li><code>nslookup</code> 是一个跨平台的命令，Windows(cmd)、Mac、Linux都可以使用</li><li>在PowerShell中等价的命令是 <code>Resolve-DnsName</code>，默认输出信息较为详细</li><li><code>dig</code> 命令也可用于查询域名的详细信息 <code>dig a1.easemob.com</code></li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/135734670" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>曾经沧海难为水，除却巫山不是云，可以被压缩的时间才是生活，不得不花费的时间只是为了活着~</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;这个命令出现在与运维同学沟通过程中，在此之前要是问我一个域名对应的服务器是IP地址是什么，我肯定优先想到的是 &lt;code&gt;ping&lt;/code&gt; 这个命令，这个命令确实可以在回复的信息中看到IP地址，但是不全面，有时一个域名对应不止一个IP地址，这时就要用到 nslookup 命令了，这也是在沟通中学到的新知识点。&lt;/p&gt;
    
    </summary>
    
      <category term="Network" scheme="http://AlbertGithubHome.github.io/blog/categories/Network/"/>
    
    
      <category term="linux" scheme="http://AlbertGithubHome.github.io/blog/tags/linux/"/>
    
      <category term="Tools" scheme="http://AlbertGithubHome.github.io/blog/tags/Tools/"/>
    
      <category term="nslookup" scheme="http://AlbertGithubHome.github.io/blog/tags/nslookup/"/>
    
  </entry>
  
  <entry>
    <title>一个golang小白使用vscode搭建Ununtu20.04下的go开发环境</title>
    <link href="http://AlbertGithubHome.github.io/blog/2024/01/21/%E4%B8%80%E4%B8%AAgolang%E5%B0%8F%E7%99%BD%E4%BD%BF%E7%94%A8vscode%E6%90%AD%E5%BB%BAgo%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"/>
    <id>http://AlbertGithubHome.github.io/blog/2024/01/21/一个golang小白使用vscode搭建go开发环境/</id>
    <published>2024-01-21T05:13:55.000Z</published>
    <updated>2024-04-29T14:46:14.847Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>先交代一下背景，距离正式接触golang这门语言已经有5年时间，平时偶尔也会用go写写工具和功能，但其实充其量就是语言小白，基本上就是按照教程配置好环境，按照需求写写逻辑，能跑起来就行了。golang随着这几年的变化，这门语言的变化还是非常大的，之前写过一篇<a href="https://blog.csdn.net/albertsh/article/details/113907051" target="_blank" rel="noopener">《Go环境配置时遇到的GOPATH路径以及包管理问题》</a>，可以看出之前配置的变量很像Java早期的配置环境，从1.11 版本之后go工程不必放到 <code>GOPATH</code> 路径中了，通过go.mod文件来标记并跟踪每个软件包的版本，灵活度大大提高，从此 <code>GOPATH</code> 概念逐渐淡化，在1.18版本新引入一个新功能<code>go.work</code>，它被设计为解决在同一工作空间中处理多个模块的问题，使得go工程的模块管理更加方便。</p><a id="more"></a><p>简单描述下我的开发环境，<code>Windows10</code> + <code>VSCode1.58.0</code> + <code>WLS1.0 - Ubuntu20.04</code>，平时工作都是在Ubuntu上，习惯了在Linux上的开发，所以即使是自己家的电脑也安装了子系统，就当成<code>Ubuntu</code> 来用就行了，Vscode安装在Windows上，直接连接到子系统上进行代码编写，以上是前提，本文的重点是在Ubuntu20.04系统上安装go的编译和运行环境。</p><h1 id="搭建go环境"><a href="#搭建go环境" class="headerlink" title="搭建go环境"></a>搭建go环境</h1><p>我选择的go版本是1.19，已经支持 <code>go.sum</code> 和 <code>go.work</code>，同时也为了和工作开发保持一致，没必要用太新的特性，现在的go包管理已经不想早期的Java，不再依赖 <code>GOPATH</code>，和 Python3.x 更像了，只管下载包然后在各自的工程目录下使用就行了，必要时需要指定使用库的版本。</p><h2 id="下载go安装包"><a href="#下载go安装包" class="headerlink" title="下载go安装包"></a>下载go安装包</h2><p>go语言的官网是 <a href="https://golang.google.cn/dl/" target="_blank" rel="noopener">https://golang.google.cn/dl/</a>，下载1.19版本的Linux包<a href="https://golang.google.cn/dl/go1.19.linux-amd64.tar.gz" target="_blank" rel="noopener">go1.19.linux-amd64.tar.gz</a>，这个网址通常下载很慢，可以改为go语言中文网<a href="https://studygolang.com/dl" target="_blank" rel="noopener">https://studygolang.com/dl</a>来下载1.19版本<a href="https://studygolang.com/dl/golang/go1.19.linux-amd64.tar.gz" target="_blank" rel="noopener">go1.19.linux-amd64.tar.gz</a></p><p>可以通过浏览器下载拷贝到指定位置，也可以通过<code>wget</code>命令下载</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">alberts@home-pc:~$ wget https://golang.google.cn/dl/go1.19.linux-amd64.tar.gz</span><br><span class="line">--2024-01-21 17:22:11--  https://golang.google.cn/dl/go1.19.linux-amd64.tar.gz</span><br><span class="line">Resolving golang.google.cn (golang.google.cn)... 203.208.50.34</span><br><span class="line">Connecting to golang.google.cn (golang.google.cn)|203.208.50.34|:443... connected.</span><br><span class="line">HTTP request sent, awaiting response... 302 Found</span><br><span class="line">Location: https://dl.google.com/go/go1.19.linux-amd64.tar.gz [following]</span><br><span class="line">--2024-01-21 17:22:12--  https://dl.google.com/go/go1.19.linux-amd64.tar.gz</span><br><span class="line">Resolving dl.google.com (dl.google.com)... 220.181.174.161, 2401:3800:4001:807::1001</span><br><span class="line">Connecting to dl.google.com (dl.google.com)|220.181.174.161|:443... connected.</span><br><span class="line">HTTP request sent, awaiting response... 200 OK</span><br><span class="line">Length: 148796421 (142M) [application/x-gzip]</span><br><span class="line">Saving to: ‘go1.19.linux-amd64.tar.gz’</span><br><span class="line"></span><br><span class="line">go1.19.linux-amd64.tar.gz      100%[==============================&gt;] 141.90M  3.62MB/s    <span class="keyword">in</span> 31s</span><br><span class="line"></span><br><span class="line">2024-01-21 17:22:43 (4.54 MB/s) - ‘go1.19.linux-amd64.tar.gz’ saved [148796421/148796421]</span><br></pre></td></tr></table></figure><h2 id="解压go压缩包完成安装"><a href="#解压go压缩包完成安装" class="headerlink" title="解压go压缩包完成安装"></a>解压go压缩包完成安装</h2><p>go的运行环境直接解压拷贝到指定位置就可以了，我把go解压安装到了 <code>/usr/local/go</code> 目录，解压之前也清理掉老的目录，如果之前没安装过，<code>rm</code>这条命令可以不使用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo su</span><br><span class="line">rm -rf /usr/<span class="built_in">local</span>/go</span><br><span class="line">tar -C /usr/<span class="built_in">local</span> -xzf go1.19.linux-amd64.tar.gz</span><br></pre></td></tr></table></figure><h2 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h2><p>这一步有点类似Windows中的修改注册表，我安装了新的程序，需要通知系统当使用 <code>go</code> 命令时需要去哪个目录下寻找可执行程序，具体操作如下</p><ul><li><p>使用vim编辑.bashrc文件</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alberts@home-pc:~$ vim ~/.bashrc</span><br></pre></td></tr></table></figure></li><li><p>到文件的末尾添加以下代码</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alberts@home-pc:~$ <span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:/usr/<span class="built_in">local</span>/go/bin</span><br></pre></td></tr></table></figure></li><li><p>重新加载配置文件</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alberts@home-pc:~$ <span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure></li><li><p>查看版本是否安装成功</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alberts@home-pc:~$ go version</span><br><span class="line">go version go1.19 linux/amd64</span><br></pre></td></tr></table></figure></li></ul><p>查看版本显示出 <code>go1.19 linux/amd64</code>, 至此go语言的基础开发环境就配置好了</p><h2 id="编写一个helloword程序"><a href="#编写一个helloword程序" class="headerlink" title="编写一个helloword程序"></a>编写一个helloword程序</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">alberts@home-pc:/mnt/g$ mkdir wlsworkspace</span><br><span class="line">alberts@home-pc:/mnt/g$ <span class="built_in">cd</span> wlsworkspace</span><br><span class="line">alberts@home-pc:/mnt/g/wlsworkspace$ mkdir hello</span><br><span class="line">alberts@home-pc:/mnt/g/wlsworkspace$ <span class="built_in">cd</span> hello/</span><br><span class="line">alberts@home-pc:/mnt/g/wlsworkspace/hello$ go mod init github.com/alberts/go/hello</span><br><span class="line">go: creating new go.mod: module github.com/alberts/go/hello</span><br><span class="line">alberts@home-pc:/mnt/g/wlsworkspace/hello$ touch hello.go</span><br><span class="line">alberts@home-pc:/mnt/g/wlsworkspace/hello$ ls</span><br><span class="line">go.mod  hello.go</span><br></pre></td></tr></table></figure><p>打开 <code>hello.go</code> 文件编写以下内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line">func <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">    fmt.Println(<span class="string">"Hello,World!"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>保存文件后使用 <code>go run</code> 命令运行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alberts@home-pc:/mnt/g/wlsworkspace/hello$ go run hello.go</span><br><span class="line">Hello,World!</span><br></pre></td></tr></table></figure><h1 id="安装VSCode插件"><a href="#安装VSCode插件" class="headerlink" title="安装VSCode插件"></a>安装VSCode插件</h1><h2 id="安装智能提示插件"><a href="#安装智能提示插件" class="headerlink" title="安装智能提示插件"></a>安装智能提示插件</h2><p>为了编写go代码方便，可以安装这个名为<code>Go</code>的插件，这个插件不是必须安装的，但是你在写go代码时VSCode会自动提示你安装这个插件，为了实现Go语法只能提醒，我们可以直接点击提示安装，或者在插件市场里搜索安装</p><p>go插件</p><p>插件安装完成后会提示下面的报错</p><blockquote><p>The “gopls” command is not available. Run “go get -v golang.org/x/tools/gopls” to install.</p></blockquote><p>说明安装这个插件需要依赖 <code>golang.org/x/tools/gopls</code> 这个包，我们可以根据提示安装</p><h2 id="安装go依赖包"><a href="#安装go依赖包" class="headerlink" title="安装go依赖包"></a>安装go依赖包</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alberts@home-pc:/mnt/g/wlsworkspace/hello$ go get -v golang.org/x/tools/gopls</span><br><span class="line">go: module golang.org/x/tools/gopls: Get <span class="string">"https://proxy.golang.org/golang.org/x/tools/gopls/@v/list"</span>: dial tcp 142.251.42.241:443: connect: connection refused</span><br></pre></td></tr></table></figure><p>直接安装通常会因无法下载而失败，需要修改代理来改变下载地址</p><h2 id="修改代理并重新安装依赖包"><a href="#修改代理并重新安装依赖包" class="headerlink" title="修改代理并重新安装依赖包"></a>修改代理并重新安装依赖包</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">alberts@home-pc:/mnt/g/wlsworkspace/hello$ go env -w GO111MODULE=on</span><br><span class="line">alberts@home-pc:/mnt/g/wlsworkspace/hello$ go env -w GOPROXY=https://goproxy.cn,direct</span><br><span class="line">alberts@home-pc:/mnt/g/wlsworkspace/hello$ go env -w GOSUMDB=<span class="string">"sum.golang.org"</span></span><br></pre></td></tr></table></figure><p>安装依赖包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">alberts@home-pc:/mnt/g/wlsworkspace/hello$ go get -v golang.org/x/tools/gopls</span><br><span class="line">go: downloading golang.org/x/tools v0.17.0</span><br><span class="line">go: downloading golang.org/x/tools/gopls v0.14.2</span><br><span class="line">go: downloading golang.org/x/tools v0.14.1-0.20231114185516-c9d3e7de13fd</span><br><span class="line">go: downloading golang.org/x/telemetry v0.0.0-20231114163143-69313e640400</span><br><span class="line">go: downloading github.com/sergi/go-diff v1.1.0</span><br><span class="line">go: downloading honnef.co/go/tools v0.4.5</span><br><span class="line">go: downloading mvdan.cc/gofumpt v0.4.0</span><br><span class="line">go: downloading mvdan.cc/xurls/v2 v2.4.0</span><br><span class="line">go: downloading golang.org/x/mod v0.14.0</span><br><span class="line">go: downloading golang.org/x/sync v0.4.0</span><br><span class="line">go: downloading golang.org/x/text v0.13.0</span><br><span class="line">go: downloading golang.org/x/exp/typeparams v0.0.0-20221212164502-fae10dda9338</span><br><span class="line">go: downloading golang.org/x/sys v0.14.0</span><br><span class="line">go: downloading golang.org/x/vuln v1.0.1</span><br><span class="line">go: downloading github.com/google/go-cmp v0.5.9</span><br><span class="line">go: downloading github.com/BurntSushi/toml v1.2.1</span><br><span class="line">go: added github.com/BurntSushi/toml v1.2.1</span><br><span class="line">go: added github.com/google/go-cmp v0.5.9</span><br><span class="line">go: added github.com/sergi/go-diff v1.1.0</span><br><span class="line">go: added golang.org/x/exp/typeparams v0.0.0-20221212164502-fae10dda9338</span><br><span class="line">go: added golang.org/x/mod v0.14.0</span><br><span class="line">go: added golang.org/x/sync v0.4.0</span><br><span class="line">go: added golang.org/x/sys v0.14.0</span><br><span class="line">go: added golang.org/x/telemetry v0.0.0-20231114163143-69313e640400</span><br><span class="line">go: added golang.org/x/text v0.13.0</span><br><span class="line">go: added golang.org/x/tools v0.14.1-0.20231114185516-c9d3e7de13fd</span><br><span class="line">go: added golang.org/x/tools/gopls v0.14.2</span><br><span class="line">go: added golang.org/x/vuln v1.0.1</span><br><span class="line">go: added honnef.co/go/tools v0.4.5</span><br><span class="line">go: added mvdan.cc/gofumpt v0.4.0</span><br><span class="line">go: added mvdan.cc/xurls/v2 v2.4.0</span><br></pre></td></tr></table></figure><p>这次安装成功了，这些依赖包默认安装到了 <code>~/go/pkg</code>目录下，使用时直接在go文件中引用就行了 <code>import golang.org/x/sys</code></p><p>以上这些包是Go语言的依赖管理工具，它们的作用如下：</p><ul><li>golang.org/x/tools: 提供了一系列用于开发Go语言的工具，如gopls等</li><li>golang.org/x/tools/gopls: 是一个基于Go语言的代码补全和导航工具，它可以帮助开发者更高效地编写和调试Go代码</li><li>golang.org/x/telemetry: 提供了一套用于收集和分析应用程序性能数据的库</li><li>github.com/sergi/go-diff: 是一个用于比较两个Go源代码文件差异的工具</li><li>honnef.co/go/tools: 提供了一些用于处理Go源代码的工具，如goimports（自动导入缺失的包）等</li><li>mvdan.cc/gofumpt: 是一个用于格式化Go源代码的工具，它可以自动调整代码格式以符合Go语言的最佳实践</li><li>mvdan.cc/xurls/v2: 是一个用于解析URL的库，它可以将URL分解为各个组成部分，方便开发者处理</li><li>golang.org/x/mod: 是一个用于管理Go模块的库，它可以帮助你更好地组织和管理项目的依赖关系</li><li>golang.org/x/sync: 提供了一组同步原语，如互斥锁、条件变量等，用于实现多线程编程中的同步机制</li><li>golang.org/x/text: 提供了一个用于处理Unicode文本的库，它可以帮助你更方便地处理和操作文本数据</li><li>golang.org/x/exp/typeparams: 提供了一个用于处理类型参数的库，它可以帮助你更方便地处理泛型编程中的类型参数问题</li><li>golang.org/x/sys: 提供了一个用于访问操作系统功能的库，它可以帮助你更方便地处理操作系统相关的任务</li><li>golang.org/x/vuln: 提供了一个用于管理已知安全漏洞的库，它可以帮助你更容易地识别和修复项目中的安全漏洞</li><li>github.com/stamblerre/gocode: 提供Go语言的代码自动补全功能，用于IDEs和编辑器</li><li>github.com/uudashr/gopkgs/v2/cmd/gopkgs: 命令行工具，帮助发现和使用Go语言软件包</li><li>github.com/ramya-rao-a/go-outline: VSCode插件，为Go源代码文件生成结构大纲以便于导航</li></ul><p>总结一下需要安装的依赖包</p><blockquote><p>go get -v golang.org/x/tools/gopls<br>go get -v github.com/stamblerre/gocode<br>go get -v github.com/uudashr/gopkgs/v2/cmd/gopkgs<br>go get -v github.com/ramya-rao-a/go-outline</p></blockquote><p>根据VSCode提示安装后续的Tools，得到的控制台输出信息如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Tools environment: GOPATH=/home/alberts/go</span><br><span class="line">Installing 6 tools at /home/alberts/go/bin <span class="keyword">in</span> module mode.</span><br><span class="line">  gopkgs</span><br><span class="line">  go-outline</span><br><span class="line">  dlv</span><br><span class="line">  dlv-dap</span><br><span class="line">  staticcheck</span><br><span class="line">  gopls</span><br><span class="line"></span><br><span class="line">Installing github.com/uudashr/gopkgs/v2/cmd/gopkgs (gopkgs) SUCCEEDED</span><br><span class="line">Installing github.com/ramya-rao<span class="_">-a</span>/go-outline (go-outline) SUCCEEDED</span><br><span class="line">Installing github.com/go-delve/delve/cmd/dlv (dlv) SUCCEEDED</span><br><span class="line">Installing github.com/go-delve/delve/cmd/dlv@master (/home/alberts/go/bin/dlv-dap) SUCCEEDED</span><br><span class="line">Installing honnef.co/go/tools/cmd/staticcheck (staticcheck) SUCCEEDED</span><br><span class="line">Installing golang.org/x/tools/gopls (gopls) SUCCEEDED</span><br><span class="line"></span><br><span class="line">All tools successfully installed. You are ready to Go :).</span><br></pre></td></tr></table></figure><h1 id="go-mod-和-go-work"><a href="#go-mod-和-go-work" class="headerlink" title="go.mod 和 go.work"></a>go.mod 和 go.work</h1><h2 id="go-mod"><a href="#go-mod" class="headerlink" title="go.mod"></a>go.mod</h2><p><strong>Go语言从1.11版本开始引入了Go Modules，这个版本之后不再需要将项目放到GOPATH中</strong>。</p><p>Go Modules是Go语言的依赖管理工具，它改变了之前必须使用GOPATH来管理依赖的模式。在Go 1.11及之后的版本中，通过go.mod文件来标记并跟踪每个软件包的版本，这意味着开发者可以在任何地方创建项目，而不必遵循GOPATH目录结构。</p><p>此外，Go团队还增加了一个环境变量<code>GO111MODULE</code>来控制模块支持的启用和禁用。这个环境变量的命名中的”111”象征着它是在Go 1.11版本中引入的。</p><p>总的来说，Go语言自1.11版本起，通过引入Go Modules，使得开发者不再受限于GOPATH，可以更加灵活地管理项目和依赖。这一变化被广泛认为是Go语言发展中的一个重大改进。</p><h2 id="go-work"><a href="#go-work" class="headerlink" title="go.work"></a>go.work</h2><p>“go.work” 是Go 1.18版本新引入的一个功能，它被设计为解决在同一工作空间中处理多个模块的问题。在之前的版本中，开发者常常会遇到路径问题、版本冲突问题等挑战。为了应对这些情况，他们可能需要对每个模块的go.mod文件进行手动修改，过程繁琐且容易出错。</p><p>“go.work”文件的主要作用就是来解决这些问题。它是一个特殊的文件，其中包含了use和replace指令，这些指令会覆盖工作区目录下的每个Go Module的go.mod文件中的内容。因此，开发者无需再对每个Go Module的go.mod文件进行手动修改，极大地简化了操作流程并提高了效率。</p><p>此外，”go.work”文件的优先级高于go.mod文件中的定义。也就是说，如果在go.work和go.mod中同时指定了不同的代码仓库路径，那么go.work中的设置将会被优先采用。这一特性进一步加强了”go.work”文件在依赖管理中的重要性。</p><h2 id="小试一下go-work"><a href="#小试一下go-work" class="headerlink" title="小试一下go.work"></a>小试一下go.work</h2><p>当前工作目录下有 <code>base</code> 和 <code>hello</code> 两个包含go.mod的工程，使用 <code>go work init</code> 命令可以初始化一个工作空间</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">alberts@home-pc:/mnt/g/wlsworkspace$ ls</span><br><span class="line">base  hello</span><br><span class="line">alberts@home-pc:/mnt/g/wlsworkspace$ go work init base hello</span><br><span class="line">alberts@home-pc:/mnt/g/wlsworkspace$ cat go.work</span><br><span class="line">go 1.19</span><br><span class="line"></span><br><span class="line">use (</span><br><span class="line">        ./base</span><br><span class="line">        ./hello</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>初始化之后工程之间就可以相互引用彼此对外的包内容了</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>下载go压缩包 <code>wget https://golang.google.cn/dl/go1.19.linux-amd64.tar.gz</code></li><li>初始化工程目录hello <code>go mod init github.com/alberts/go/hello</code>，包名通常是支持https访问的网络地址</li><li>初始化工作空间 <code>go work init base hello</code>，base 和 hello 都是包含go.mod文件的go工程</li><li>安装依赖包 <code>go get -v golang.org/x/tools/gopls</code></li><li>安装依赖包 <code>github.com/stamblerre/gocode</code></li><li>安装依赖包 <code>github.com/uudashr/gopkgs/v2/cmd/gopkgs</code></li><li>安装依赖包 <code>github.com/ramya-rao-a/go-outline</code></li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/135586502" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>放下助人情节，尊重他人命运~</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;先交代一下背景，距离正式接触golang这门语言已经有5年时间，平时偶尔也会用go写写工具和功能，但其实充其量就是语言小白，基本上就是按照教程配置好环境，按照需求写写逻辑，能跑起来就行了。golang随着这几年的变化，这门语言的变化还是非常大的，之前写过一篇&lt;a href=&quot;https://blog.csdn.net/albertsh/article/details/113907051&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《Go环境配置时遇到的GOPATH路径以及包管理问题》&lt;/a&gt;，可以看出之前配置的变量很像Java早期的配置环境，从1.11 版本之后go工程不必放到 &lt;code&gt;GOPATH&lt;/code&gt; 路径中了，通过go.mod文件来标记并跟踪每个软件包的版本，灵活度大大提高，从此 &lt;code&gt;GOPATH&lt;/code&gt; 概念逐渐淡化，在1.18版本新引入一个新功能&lt;code&gt;go.work&lt;/code&gt;，它被设计为解决在同一工作空间中处理多个模块的问题，使得go工程的模块管理更加方便。&lt;/p&gt;
    
    </summary>
    
      <category term="Go" scheme="http://AlbertGithubHome.github.io/blog/categories/Go/"/>
    
    
      <category term="Go" scheme="http://AlbertGithubHome.github.io/blog/tags/Go/"/>
    
      <category term="golang" scheme="http://AlbertGithubHome.github.io/blog/tags/golang/"/>
    
      <category term="vscode" scheme="http://AlbertGithubHome.github.io/blog/tags/vscode/"/>
    
      <category term="proxy" scheme="http://AlbertGithubHome.github.io/blog/tags/proxy/"/>
    
  </entry>
  
  <entry>
    <title>推荐一款通过ssh连接linux服务的开源工具WindTerm</title>
    <link href="http://AlbertGithubHome.github.io/blog/2024/01/14/%E6%8E%A8%E8%8D%90%E4%B8%80%E6%AC%BE%E9%80%9A%E8%BF%87ssh%E8%BF%9E%E6%8E%A5linux%E6%9C%8D%E5%8A%A1%E7%9A%84%E5%BC%80%E6%BA%90%E5%B7%A5%E5%85%B7WindTerm/"/>
    <id>http://AlbertGithubHome.github.io/blog/2024/01/14/推荐一款通过ssh连接linux服务的开源工具WindTerm/</id>
    <published>2024-01-14T11:39:08.000Z</published>
    <updated>2024-01-21T12:47:38.943Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>工作一入门便是游戏服务器开发，所以常常有连接Linux服务器的需求，之前用的最多的是Xshell，最近这个软件个人版只能免费使用一个月了，超过时间会提示更新无法正常使用，工作当中用的最多的是SecureCRT，不过这个软件是收费的，公司买了授权，可以正常用，但是在家时就不行了，最近我找到了WindTerm这个软件，用起来还不错，记录一下。</p><a id="more"></a><h1 id="WindTerm介绍"><a href="#WindTerm介绍" class="headerlink" title="WindTerm介绍"></a>WindTerm介绍</h1><blockquote><p>A Quicker and better SSH/Telnet/Serial/Shell/Sftp client for DevOps.</p></blockquote><p>WindTerm一款使用使用C语言开发的跨平台SSH客户端WindTerm，完全免费开源，软件包只有20多M，性能很好，Windows、Linux、Mac均提供程序包下载，免按照，下载解压即可使用，官方地址为 <a href="https://github.com/kingToolbox/WindTerm/releases" target="_blank" rel="noopener">https://github.com/kingToolbox/WindTerm/releases</a>，最新版本为2.6.0</p><p><img src="https://img-blog.csdnimg.cn/direct/675fda112cc34909909ad7647c3fce5e.png#pic_center" alt="windterm download">最近github访问又变慢了，如果你下载不下来，可以从这个平台地址下载<a href="https://download.csdn.net/download/shihengzhen101/88740938" target="_blank" rel="noopener">CSDN下载-WindTerm_2.6.0_Prerelease_7_Windows_Portable_x86_64.zip</a>，我已经设置成免积分了，方便有需要的人直接取用，简单罗列下它的功能。</p><ul><li>多平台支持Linux，Mac，Win，免安装解压即可使用</li><li>实施了 SSH v2、Telnet、Raw Tcp、串行、Shell 协议</li><li>会话认证时支持 SSH 自动执行</li><li>支持 SSH ProxyCommand 或 ProxyJump</li><li>支持SSH代理转发。</li><li>支持使用密码、公钥、键盘交互、gssapi-with-mic 的 SSH 自动登录</li><li>支持直接/本地端口转发、反向/远程端口转发和动态端口转发</li><li>支持 XModem、YModem 和 ZModem，可以使用rz、sz上传和下载文件</li><li>集成sftp、scp客户端，支持下载、上传、删除、重命名、新建文件/目录</li><li>集成本地文件管理器，支持移动到、复制到、复制自、删除、重命名、新建文件/目录</li><li>支持 Windows Cmd、PowerShell 和 Cmd、PowerShell 作为管理员</li><li>支持Linux bash、zsh、powershell core</li><li>支持 MacOS bash、zsh、powershell core</li><li>有较好的操作界面</li></ul><h1 id="WindTerm使用"><a href="#WindTerm使用" class="headerlink" title="WindTerm使用"></a>WindTerm使用</h1><p>下载WindTerm_2.6.0_Prerelease_7_Windows_Portable_x86_64.zip 后解压，双击WindTerm.exe即可打开软件，会弹出下面的界面，提示存储配置文件的地方，我就选择放到应用程序目录了</p><p><img src="https://img-blog.csdnimg.cn/direct/cdbbedbd143f4841bc4575ca9b6c37d4.png#pic_center" alt="windterm open"></p><p>直接通过【会话】-&gt;【新建会话】便可以建立连接Linux服务器的通道，这与之前用的软件都大同小异，基本没有差别，输入主机地址点击【连接】，后续再输入密码就可以开始连接了</p><p><img src="https://img-blog.csdnimg.cn/direct/f387f7832a1549bf93726ab773c611a6.png" alt="new session">如果是第一个使用的时候，会弹出下面这个界面，让自定义一个主密码，其实就是这个软件的使用密码，后续锁屏或者更新会话信息时会用到。</p><p><img src="https://img-blog.csdnimg.cn/direct/a22b701407c24290be4b440aa906d879.png#pic_center" alt="main password"></p><p>因为我是自己在家使用，我就不设置主密码了，直接点击OK完成，后面会让输入Linux账户和密码，到这一步相信大家都会用了。</p><h1 id="主密码和锁屏"><a href="#主密码和锁屏" class="headerlink" title="主密码和锁屏"></a>主密码和锁屏</h1><p>这个问题我也是查了一些资料才解决的，因为我没有输入主密码，所以每次锁屏时我只要回车就可以了，如果想修改锁屏时间，在【会话】-&gt;【首选项】-&gt;【设置】中可以找到</p><p><img src="https://img-blog.csdnimg.cn/direct/e143aec960c4491fb4fcc22d14ca502a.png#pic_center" alt="windterm setting"><br>也可以直接通过配置文件修改，找到刚启动软件时你选择的目录 <code>D:\app\WindTerm_2.6.0\.wind\profiles\default.v10</code>，直接修改配置文件内容，通过字段名也很清楚要改哪些值</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"application.fingerprint"</span> : <span class="string">"c5QR13M1iEkNPGlVNjDBWadi1uS0PiXR4Y+79cp09PAXr7G6WQxg/7WFj9RJ9dIsKKOWqm5Xq2N6w5Jx4v2mTw=="</span>,</span><br><span class="line">    <span class="attr">"application.language"</span> : <span class="string">"zh-CN"</span>,</span><br><span class="line">    <span class="attr">"application.lockScreenTimeout"</span> : <span class="number">1</span>,</span><br><span class="line">    <span class="attr">"application.masterPassword"</span> : <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">"terminal.loginWizard.defaultAuthType"</span> : <span class="string">"Account"</span>,</span><br><span class="line">    <span class="attr">"terminal.reimportShellSessions"</span> : <span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>application.lockScreenTimeout</code>：是控制锁屏时间的</li><li><code>application.masterPassword</code>：是代表是否有主密码的</li></ul><p>整个页面布局和配色还是挺漂亮的，不喜欢可以自己调整的哈</p><p><img src="https://img-blog.csdnimg.cn/direct/ea41dd99bf6b430ba5023eb358cd5752.png#pic_center" alt="windterm shell"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>WindTerm是一款可以通过ssh连接Linux服务器的客户端工具</li><li>WindTerm免费开源，支持Windows、Linux、Mac系统，无需安装，解压即可使用</li><li>WindTerm集成sftp、scp客户端，支持下载、上传、删除、重命名、新建文件/目录</li><li>WindTerm默认需要指定一个主密码，相当于验证使用者身份的功能，当然也可以为空</li><li>WindTerm的锁屏时间可以通过首选项菜单设置，也可通过配置修改</li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/135315104" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>人生就是一本账，欠下的东西总要还的，茫茫人生路之后，你是想在历史长河中留下一笔，还是“隐藏”的毫无痕迹呢？</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;工作一入门便是游戏服务器开发，所以常常有连接Linux服务器的需求，之前用的最多的是Xshell，最近这个软件个人版只能免费使用一个月了，超过时间会提示更新无法正常使用，工作当中用的最多的是SecureCRT，不过这个软件是收费的，公司买了授权，可以正常用，但是在家时就不行了，最近我找到了WindTerm这个软件，用起来还不错，记录一下。&lt;/p&gt;
    
    </summary>
    
      <category term="linux" scheme="http://AlbertGithubHome.github.io/blog/categories/linux/"/>
    
    
      <category term="linux" scheme="http://AlbertGithubHome.github.io/blog/tags/linux/"/>
    
      <category term="运维" scheme="http://AlbertGithubHome.github.io/blog/tags/%E8%BF%90%E7%BB%B4/"/>
    
      <category term="ssh" scheme="http://AlbertGithubHome.github.io/blog/tags/ssh/"/>
    
      <category term="windterm" scheme="http://AlbertGithubHome.github.io/blog/tags/windterm/"/>
    
      <category term="免安装" scheme="http://AlbertGithubHome.github.io/blog/tags/%E5%85%8D%E5%AE%89%E8%A3%85/"/>
    
  </entry>
  
  <entry>
    <title>2023年终总结——你相信光吗</title>
    <link href="http://AlbertGithubHome.github.io/blog/2024/01/01/2023%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93%E2%80%94%E2%80%94%E4%BD%A0%E7%9B%B8%E4%BF%A1%E5%85%89%E5%90%97/"/>
    <id>http://AlbertGithubHome.github.io/blog/2024/01/01/2023年终总结——你相信光吗/</id>
    <published>2023-12-31T16:02:35.000Z</published>
    <updated>2024-01-14T11:49:26.200Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>不断追求利益的经济冲动，不停侵蚀人们的生活，压垮、吞噬并统治生活本身，无法言喻的不安和看不到明天的混沌感，让我们在现有社会经济条件下，沦为被金钱和物质所统治的行尸走肉~</p></blockquote><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近在看一本叫《饱食穷民》的书，讲述的是泡沫经济年代的日本社会，宛如梦幻泡影一样变化无常，又像断梗浮萍一样飘忽不定，到处充斥着不安的色彩，我试图从中寻找一些当前现实问题的解决方案，上段文字也是出自此书之中，阅读之后我大受震撼，其中描述的有关软件工程师的篇章，简直就是我的复刻版，无论是心境、情感、还是所面临的问题都如出一辙，读完觉得背后隐隐发凉，因为最终那些令人无法接受的结局，确实是我不想看到的。</p><a id="more"></a><p>2023年要结束了，今年的时光过的格外的快，突然想起大年初二时半夜更新游戏版本好像还是昨天发生的事情，结果一眨眼就来到了2023的尾巴，2022年末的时候大家对2023年的发展充满了希望，结果今年快过完了，发现比之前“三年”更难了，零下20度的温度配合着各种“毕业”的声音，让不安的情绪充斥着每一个打工人的内心。</p><p>面对除夕上班的决定，一开始大家还是强烈反对，但是渐渐的情绪发生了逆转，除夕上班说明还有工作，很多人在这个寒冷的冬天已经“提前放假”，没有打工的机会了，在这个寒冷的冬天，你还相信光吗？</p><h1 id="回顾2023"><a href="#回顾2023" class="headerlink" title="回顾2023"></a>回顾2023</h1><p>回顾这一年忙忙碌碌，高强度的工作却没取得预想的成果，各种Flag完成情况更是惨不忍睹。</p><h2 id="工作上"><a href="#工作上" class="headerlink" title="工作上"></a>工作上</h2><blockquote><p>FLAG</p><ul><li>适应自己身份的转变，提升自己的管理技能，做一名合格的管理者</li><li>继续做好本职可开发工作，做好工作内容的总结，推动新项目顺利上线</li><li>根据自己的技能树框架，查漏补缺，有针对性的学习和探索</li></ul><p>完成度 ：80%</p></blockquote><p>作为一个入门的管理者，今年见识到了更多更复杂的管理情景，Hire and Fire 全都经历过了，管理经验更加完整，尝试跨过了之前一直无法逾越的坎，为了能生存下去，有时不得不做出取舍，参加了一系列的管理课程，学习后发现万物皆可为工具，招人的工具、提升效率的工具、提升凝聚力的工具、提高团队氛围的工具、优化团队的工具，学习过后内心不禁生出一丝悲凉。</p><p>本职工作继续充当牛马，还真是个踏踏实实的老黄牛，推动项目一步步往前走，但目前项目暂时停滞了，今年上线是不可能了，不过经历了一次完整的测试过程，算是在失望之中获得了一点点慰藉。</p><p>今年的工作强度依旧很大，前三季度基本上12点左右回家，个别时候会工作到后半夜，比上一年能好一点，但是最终的结果却不尽如人意。</p><p>技能树框架基本荒废，因为没时间往里边填东西，基本上是被项目推着走，缺什么就补什么，nginx测试和调整配置有了一定的经验，linux系统参数的调优也在压测是接触了不少，还有网络参数配置等等。</p><p>对于这一项来说，努力到位了，结果并不能说明什么，可能还是缺少一点点运气了。</p><h2 id="学习上"><a href="#学习上" class="headerlink" title="学习上"></a>学习上</h2><blockquote><p>FLAG</p><ul><li>继续博客总结，40篇是基础线，2023要超过这个值，尽量一周一篇，放假可休息</li><li>新的一年依旧很忙，刷题不强制要求，每周最好有贡献，每月必须有输出</li><li>在现有的技能树框架上继续丰富，做到枝繁叶茂，试试找点副业</li><li>开源代码还是以项目为驱动，选取经典实现，比如kafka</li><li>继续读书，今年书也买好了，数量不多，下半年应该还会买一批</li></ul><p>完成度 ：70%</p></blockquote><p>博客总结目标达成，今年在CSDN共有42篇总结，较40篇的及格线多了一点点，年初有篇关于ChatGPT的博文一开始阅读量刷刷刷的涨，后来判定违规就被吞了，整体上博客内容比较基础，大多数来源于工作之中的知识点，也有一些是平时的思考和感悟，以下是近两年的数据对比。</p><p><img src="https://img-blog.csdnimg.cn/direct/6b8bf36d48904677a5bc85c80ac6e31e.png#pic_center" alt="vs-csdn"></p><a href="!--![2022csdn](https://img-blog.csdnimg.cn/direct/1b019f2ab6114156874451c0f6f20ad7.png#pic_center)![2023csdn](https://img-blog.csdnimg.cn/direct/77a16b7b2d6c406f9c30eda21fc529bc.png#pic_center)--">!--![2022csdn](https://img-blog.csdnimg.cn/direct/1b019f2ab6114156874451c0f6f20ad7.png#pic_center)![2023csdn](https://img-blog.csdnimg.cn/direct/77a16b7b2d6c406f9c30eda21fc529bc.png#pic_center)--</a><p>2023年一年的博客访问量突破了60万，相比于去年的40多万上升了不少，文章基数增多了应该是主要原因，去年的10W+文章<a href="https://blog.csdn.net/albertsh/article/details/92385277" target="_blank" rel="noopener">《float的精度和取值范围》</a> 一年就上涨了6万多，看来高质量的内容才是吸引人的关键，并且会形成头部效应，马太效应，出现强者恒强的情况。</p><p>今年的CSDN活动依旧不少，但是我已经很少参加了，一方面没有那么多时间，还有就是看不懂规则，年终的博客之星评选，由于博文的数量没有达标，连报名的资格都没有，有点遗憾。</p><p>关于刷题这个Flag约等于没有，别说刷题了，忙的连账号都没登录几次，刚刚看了看提交记录，仅在前两个月提交了十几道题，图我就不截了，有点磕碜，不过新的一年中可能需要多一点了，毕竟工作都不稳定了，得准备准备练练手感了。</p><p>技能树框架秃了，其实我也不想秃，但是每天回家总是很晚，我实在是懒得补充了，这明显是一个借口，但却是一个事实，心里知道这个事情要做，所以换了一种方式，改为记笔记的方式来弥补，一开始准备每天问自己一个问题，后来坚持不下来，但是每次有空闲想起来就会认真回答一次，然后就是将工作中遇到的盲点和知识点记录下来，为技能树积累素材。</p><p>阅读经典代码这部分还是以项目驱动为主，比如修改easyloging++文件描述符不释放的问题，分析libevent网络数据读取缓慢的问题，扩展框架支持 websocket 连接等，都是从项目需求实际出发，当然也看了一些帧同步小游戏的示例代码，有C#的也有JS的，暂时没有找到能明显解决我对帧同步疑问的项目，目前还在学习和寻找中。</p><p>读书一直没有停，由于每天大强度的工作时间，休息之余我已经不读技术类书籍了，现在读的更多是传记、小说、散文等等，通过一页页纸张回顾历史长河，窥探他人的一生。</p><p>有的人纷繁的一生落在纸上不过一页，而绝大多数人根部就不会在书本上留下痕迹。以下便是2023年阅读的书籍内容：</p><ul><li>时间从来不语却回答了所有问题（2023-2-12 13:56）<ul><li>一本杂记，更多的是晚年的人生</li></ul></li><li>苏东坡传 —— 一蓑烟雨任平生（2023-2-26 23:57）<ul><li>人身缘何不快乐，只因未读苏东坡</li></ul></li><li>知行合一王阳明（2023-3-12 20:43）<ul><li>良知源自内心，无需外求。功名利禄，本是外在的，得之我幸，不得我命。</li></ul></li><li>别让孩子伤在敏感期（2023-3-19 16:32:23）<ul><li>在孩子处于各种敏感期时，学会给予尊重，顺其自然，适时引导</li><li>不要规划孩子必须在哪一个领域取得成就，但只要她喜欢，就提供一个舞台，让她尽情去发挥</li></ul></li><li>我是猫（2023-6-25 00:48:05）<ul><li>两年的猫生戛然而止，古怪的苦沙弥高朋满座</li></ul></li><li>人间失格（2023-6-24 13:30:50）<ul><li>一个从小就将自己伪装起来的孩子着实令人害怕，让人回忆起了令人心酸的表哥</li><li>虽然一切都已经过去，但还是有些记忆片段会在读书是产生共鸣，从记忆深处涌上来</li><li>《斜阳》中的我是贵族是对时代的呐喊，回不去也融不进</li><li>《GoodBye》更是写成了幻想小说的范畴</li></ul></li><li>罗生门（2023-8-7 23:13:34）<ul><li>怪诞、讽刺、描写细致的短篇小说，不过有些故事的寓意看不太懂</li></ul></li><li>浮生六记（2023-11-26 22:35:23）<ul><li>初中时的课文《童趣》居然来自这本书，据说后两记是伪写的，但最后一记《养生记道》却多次引起共鸣，可能我正处在迷茫期吧。“五百年谪在红尘，略成游戏。三千里击开沧海，便是逍遥。”</li></ul></li><li>月亮与六便士（2023-12-10 17:00:27）<ul><li>一个完全不顾他人感受的人是否能称之为伟大，疯子还差不多</li></ul></li></ul><p>《苏东坡传》描写了苏东坡的一生，他虽狂放不羁，但有个一直拯救他的弟弟却是它一生的幸福，“人身缘何不快乐，只因未读苏东坡”，其实不止是苏东坡，很多大人物的一生就极其坎坷，如果看看他们的经历，我们的人生才刚刚开始，而如今这个浮躁的社会已经很难让人平静的接受这一切了。</p><p>《月亮与六便士》是一本很出名的书籍，从听说这本书到真正的开始读跨过了大概6、7年的时间，但如今读过之后却让与我的预想差距太大，我没想到这是一篇小说，斯特里克兰简直是一个变态，全文描述了他不顾一切的追求艺术，将其称之为伟大，但我觉得这样的伟大毫无意义，即使他的绘画技艺已经出神入化，世界也不缺他一个，但他却真实的伤害了周围的每一个人。</p><h2 id="投资上"><a href="#投资上" class="headerlink" title="投资上"></a>投资上</h2><blockquote><p>FLAG</p><ul><li>定投和智能条件单保持现状，ETF追加1~2个新的行业赛道</li><li>股票池还有几个垃圾票要找机会清理掉，手里的价投股票适当做做趋势</li><li>保持对新年经济的乐观，目标收益10个点</li></ul><p>完成度 ：50%</p></blockquote><p>今年除了少量增持了之前的“三傻”和科技股之外，追加了医药ETF和光伏ETF，设置了定投单和网格条件单，持仓的FLAG的是达到了，但收益有点一言难尽，手中的垃圾票清掉了部分，有些垃圾真得再等几年，这种票已经不关注了，就留在持仓列表里做个提醒好了。</p><p>工业富联算是今天收获颇丰的一个票，也是唯一一个高额正收益的票，去年的FLAG是【目标收益10个点】，可能这个愿望描述的不够具体，就像雍和宫许愿一样，被调剂成了负的，结果股票加基金损失了10个点左右，真是令人头大。</p><p><img src="https://img-blog.csdnimg.cn/direct/dcf20fef8ab34e2cac9bf3a3676c6be4.png#pic_center" alt="2023finance"></p><p>本来前10个月收益基本达标，但最后这一个季度，行情急转直下，价值投资带头向下俯冲，毫无招架之力。</p><h2 id="生活上"><a href="#生活上" class="headerlink" title="生活上"></a>生活上</h2><blockquote><p>FLAG</p><ul><li>疫情放开了，有事没事都趁着假期回家看看</li><li>身体很重要，锻炼的很费时，中和一下，可以跳跳绳</li><li>周末了陪娃耍一耍，工作尽量不占用周末的时间</li></ul><p>完成度 ：70%</p></blockquote><p>今年回家的次数也不是太多，元旦、春节、劳动节、国庆中秋节总计21天，比2022年的14天多了不少，主要差在了国庆假期上，回家正好收玉米，赶上了丰收的季节。</p><p>身体锻炼几乎没有，全年跳绳不超过3次，不过脂肪肝和高尿酸的情况都有所减轻，每天真的懒得不想动。</p><p>2023年的周末和工作日分的还是比较清晰的，工作日强度很大，但周末工作的时间很少了，真的是在家陪家人和或者一起出去逛逛，一家人去了之前谈论了8年还没去过的香山公园，看了一圈几乎还没红的枫叶。</p><p>去年的<a href="https://blog.csdn.net/albertsh/article/details/128509220" target="_blank" rel="noopener">总结</a>中给我养的<a href="https://img-blog.csdnimg.cn/ce62daf422b44245899491810d55e7d4.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9hbGJlcnRnaXRodWJob21lLmdpdGh1Yi5pby9ibG9nL2Fib3V0,size_14,color_FFFFFF,t_70#pic_center" target="_blank" rel="noopener">花花拍了照片</a>，今年对比了一下发现一年的时间长了很多，再拍一张照片看看。</p><p><img src="https://img-blog.csdnimg.cn/direct/0db1f97f7cdc4b40b0b3b3cec886986b.png#pic_center" alt="2023flower"></p><p>2023年初还补充了几盆多肉，从最开始的柔弱养成了郁郁葱葱的“绿油油”，这一年个头没少长，都窜的老高，就是不上颜色，可能是光照太少了？</p><p><img src="https://img-blog.csdnimg.cn/direct/2266494abc084622a2df361b00673cd6.png#pic_center" alt="2023flower2"></p><p>年初文章总结了<a href="https://blog.csdn.net/albertsh/article/details/128892715" target="_blank" rel="noopener">《工作十年对游戏看法的转变历程》</a>，文中提到我买了8090掌上游戏机玩俄罗斯方块，后来趁娃不在又买了Switch准备寻找灵感，但结果就是海关发货太慢了，等娃回来正好赶上游戏机送到，最后Switch就成了她的玩具。</p><p><img src="https://img-blog.csdnimg.cn/direct/422325b949a046fd9dcbc03a3364d5a5.png#pic_center" alt="在2023game"></p><p>现在每天没时间玩也不敢玩，和娃约定好了周末才可以玩一会，每周末充一次电，和宝宝一起玩一会赛车还是很有意思的，偶尔自己偷偷玩玩塞尔达，似乎这些才能被称之为真正的游戏，哪些哪里亮就点哪里的游戏真的能被称为游戏吗？自己对这类游戏有些厌倦了。</p><h1 id="展望2024"><a href="#展望2024" class="headerlink" title="展望2024"></a>展望2024</h1><h2 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h2><ul><li>今年的工作环境极其复杂，切换了新的赛道，工作内容繁杂，需要逐步将内容理顺</li><li>继续培养管理技能，面对不同的人采取不同的策略，尝试向上管理的方法</li><li>补充技能树框架，采取提问和总结的方式，有针对性的学习和探索，为新的工作机会打好基础</li></ul><h2 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h2><ul><li>40篇以上博客总结，尽量一周一篇，放假休息，保持知识库一直更新</li><li>刷题不要求每周有贡献了，不切实际的FLAG没有意义，希望每月有贡献吧</li><li>采取提问回答方式补充技能树，利用好别人总结好的知识，很多知识点没必要从头开始</li><li>阅读开源代码解决实际问题，今年想尝试的知识点有【帧同步】和【共享内存】</li><li>继续保持读书的习惯，今年的图书已经到位，类型多是历史、传记和小说</li></ul><p><img src="https://img-blog.csdnimg.cn/direct/453197020ff14f48b865f2a23e884d61.png#pic_center" alt="2023book"></p><h2 id="投资"><a href="#投资" class="headerlink" title="投资"></a>投资</h2><ul><li>垃圾票适时出清</li><li>保持定投和智能条件单策略，重点放在科技和医药赛道，光伏赛道等待产能出清，持续观望</li><li>环境很差，但依旧相信国运，考虑今年的进入低位，2024年目标正收益15个点（可得说清楚，避免调剂）</li></ul><h2 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h2><ul><li>假期回家时间不低于去年的21天</li><li>想跑跑步，目前仅停留在脑海里，每周末下楼去转转</li><li>养养花，新年不打算买新的花了，好好把目前的多肉养出状态</li><li>周末陪陪家人，希望不要被家里的神仙宝贝娃娃气炸</li></ul><p><img src="https://img-blog.csdnimg.cn/direct/aa6573e7bb8b455eb5cf55b441e9f0b0.png#pic_center" alt="在2023home"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>2023年作为魔幻的一年，本来被给予了美好的希望，没想到放开之后，情况变得越发糟糕，打破了人们的预期，报复性的反弹没有如约而至，很多事情在封闭期间没有发生，却在这个寒冷的冬天尝了个遍，HR在得知自己毕业消息后，需要在临行前通知其他小伙伴毕业，主管实在不想开人，最终不得不自己离开，这些事情听起来很新奇，却在这个寒冬中显得那么的习以为常。</p><p>最近看了一些书籍和记录片，已经渐渐的体会到，做人不能太明白，有时糊里糊涂的反而更幸福，如果作为一个明白人还能收放自如的糊里糊涂，那便是境界升华了。</p><p>你还相信光吗？<strong>我依旧相信</strong>！<strong><em>虽然深处寒冬，我心依旧向往光明</em></strong>，信仰的力量支撑着我们前进，不管现在的真实情况是向上还是向下，我相信总有一天会向上突破的，期待这一天早点到来~</p><p><img src="https://img-blog.csdnimg.cn/direct/d22fca83d9324df8bc6ddd91ec70a75f.png#pic_center" alt="2023life"></p><hr><center><a href="https://blog.csdn.net/albertsh/article/details/135161723" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>旧年伊始志气豪，万物焕新气宇高。<br>谁料寒冬多磨难，心怀光明盼春晓。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;不断追求利益的经济冲动，不停侵蚀人们的生活，压垮、吞噬并统治生活本身，无法言喻的不安和看不到明天的混沌感，让我们在现有社会经济条件下，沦为被金钱和物质所统治的行尸走肉~&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;最近在看一本叫《饱食穷民》的书，讲述的是泡沫经济年代的日本社会，宛如梦幻泡影一样变化无常，又像断梗浮萍一样飘忽不定，到处充斥着不安的色彩，我试图从中寻找一些当前现实问题的解决方案，上段文字也是出自此书之中，阅读之后我大受震撼，其中描述的有关软件工程师的篇章，简直就是我的复刻版，无论是心境、情感、还是所面临的问题都如出一辙，读完觉得背后隐隐发凉，因为最终那些令人无法接受的结局，确实是我不想看到的。&lt;/p&gt;
    
    </summary>
    
      <category term="Thinking" scheme="http://AlbertGithubHome.github.io/blog/categories/Thinking/"/>
    
    
      <category term="总结" scheme="http://AlbertGithubHome.github.io/blog/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="工作" scheme="http://AlbertGithubHome.github.io/blog/tags/%E5%B7%A5%E4%BD%9C/"/>
    
      <category term="学习" scheme="http://AlbertGithubHome.github.io/blog/tags/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="生活，投资" scheme="http://AlbertGithubHome.github.io/blog/tags/%E7%94%9F%E6%B4%BB%EF%BC%8C%E6%8A%95%E8%B5%84/"/>
    
  </entry>
  
  <entry>
    <title>Linux环境下通过journal命令查看和管理日志</title>
    <link href="http://AlbertGithubHome.github.io/blog/2023/12/22/Linux%E7%8E%AF%E5%A2%83%E4%B8%8B%E9%80%9A%E8%BF%87journal%E5%91%BD%E4%BB%A4%E6%9F%A5%E7%9C%8B%E5%92%8C%E7%AE%A1%E7%90%86%E6%97%A5%E5%BF%97/"/>
    <id>http://AlbertGithubHome.github.io/blog/2023/12/22/Linux环境下通过journal命令查看和管理日志/</id>
    <published>2023-12-22T14:03:50.000Z</published>
    <updated>2024-01-14T11:45:50.130Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>就在半月之前，负责打包更新的服务器突然登录不上去了，赶紧找来运维的同事帮忙解决，发现系统日志中有很多 <code>systemd-journald[424]: Failed to open runtime journal: No space left on device</code> 字样的错误，被告知磁盘满了需要清理，但是我当时登录不上去，只能让他们帮忙重启后利用单用户模式上去删除临时文件试试，但重启后发现问题解决了，很是诧异，查询服务器后台监控平台，发现磁盘空间还有50%，inode只占用了0.02%，这怎么会磁盘满了呢？</p><a id="more"></a><h1 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h1><p>后来经过分析，应该是journal默认将系统日志存储在/run/log/journal目录中，而 <code>/run</code>是一个临时文件系统，通常挂载在内存中，用于存储运行时产生的临时文件，如进程 ID 文件、锁文件等，如果登录所需的文件或进程受到 <code>/run</code> 空间不足的影响，可能会导致登录问题。例如，如果 <code>sshd</code> 进程的运行所需的文件被存储在 <code>/run</code> 中并且空间不足，那么可能无法正常登录。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ df -h</span><br><span class="line">Filesystem      Size  Used Avail Use% Mounted on</span><br><span class="line">devtmpfs        7.8G     0  7.8G   0% /dev</span><br><span class="line">tmpfs           7.8G  868K  7.8G   1% /run</span><br></pre></td></tr></table></figure><p>所以系统重启后，这个空间释放了也就能通过ssh登录了，并且重启后journal日志清空也证实了这一点。</p><p>关于这个空间限制多数说的是10%，但是如果真是的所处分区的10%，那么不会导致我登录不上的，所以我倾向于是系统内存10%或者硬盘最大10%，默认最大限制4G，具体限制等我有空时查查文档吧，先贴一段看起来很靠谱的描述</p><blockquote><p>SystemMaxUse=, SystemKeepFree=, SystemMaxFileSize=, SystemMaxFiles=, RuntimeMaxUse=, RuntimeKeepFree=, RuntimeMaxFileSize=, RuntimeMaxFiles=<br>限制日志文件的 大小上限。 以 “System” 开头的选项用于限制磁盘使用量， 也就是 /var/log/journal 的使用量。 以 “Runtime” 开头的选项用于限制内存使用量， 也就是 /run/log/journal 的使用量。 以 “System” 开头的选项仅在 /var/log/journal 目录确实存在且可写时才有意义。 但以 “Runtime” 开头的选项永远有意义。 也就是说， 在系统启动早期 /var 尚未挂载时、 或者系统管理员禁止在磁盘上存储日志的时候， 仅有 “Runtime” 开头的选项有意义。 journalctl 与 systemd-journald 工具会忽略日志目录中 所有后缀名不等于 “.journal” 或 “.journal~” 的文件。 换句话说，日志目录中不应该存在后缀名不等于 “.journal” 或 “.journal~” 的文件， 因为这些文件 永远不会被清理。</p><p>SystemMaxUse= 与 RuntimeMaxUse= 限制全部日志文件加在一起最多可以占用多少空间。 SystemKeepFree= 与 RuntimeKeepFree= 表示除日志文件之外，至少保留多少空间给其他用途。 systemd-journald 会同时考虑这两个因素， 并且尽量限制日志文件的总大小，以同时满足这两个限制。</p><p>SystemMaxUse= 与 RuntimeMaxUse= 的默认值是10%空间与4G空间两者中的较小者； SystemKeepFree= 与 RuntimeKeepFree= 的默认值是15%空间与4G空间两者中的较大者； 如果在 systemd-journald 启动时，文件系统即将被填满并且已经超越了 SystemKeepFree= 或 RuntimeKeepFree= 的限制，那么日志记录将被暂停。 也就是说，如果在创建日志文件时，文件系统有充足的空闲空间， 但是后来文件系统被其他非日志文件过多占用， 那么 systemd-journald 只会立即暂停日志记录， 但不会删除已经存在的日志文件。 注意，只会删除已归档的日志文件以释放空间。 也就是说，即使在完成日志清理之后， 日志所占用的空间仍然可能大于 SystemMaxUse= 或 RuntimeMaxUse= 的限制。</p><p>SystemMaxFileSize= 与 RuntimeMaxFileSize= 限制单个日志文件的最大体积， 到达此限制后日志文件将会自动滚动。 默认值是对应的 SystemMaxUse= 与 RuntimeMaxUse= 值的1/8 ， 这也意味着日志滚动 默认保留7个历史文件。</p><p>日志大小 可以使用以1024为基数的 K, M, G, T, P, E 后缀， 分别对应于 1024, 1024², … 字节。</p><p>SystemMaxFiles= 与 RuntimeMaxFiles= 限制最多允许同时存在多少个日志文件， 超出此限制后， 最老的日志文件将被删除， 而当前的活动日志文件 则不受影响。 默认值为100个。</p></blockquote><p>以上描述来自 <a href="https://www.jinbuguo.com/systemd/journald.conf.html" target="_blank" rel="noopener">《journald.conf 中文手册》</a>，另外 <a href="https://www.cnblogs.com/morgan363/p/13957565.html" target="_blank" rel="noopener">《Systemd日志管理服务：Journald以及重要配置选项》</a> 这篇博文也提到了默认日志数据将仅存储在内存中，在系统关闭时会删除该数据。</p><h1 id="journal-和-syslog-对比"><a href="#journal-和-syslog-对比" class="headerlink" title="journal 和 syslog 对比"></a>journal 和 syslog 对比</h1><p>提到系统日志除了journal比较常见以外，还有 syslog 也是比较基础的服务，两者都是日志服务，并且在系统中合理分工，相互配合，它们服务于不同的目标并且具有不同的特性。syslog是Linux系统的一套日志框架，它既可以记录日志到本地文件，也可以通过网络发送到接收syslog的服务器，以实现对多个设备的syslog消息进行统一的存储或解析。而journal是改进型的日志管理服务，主要收集来自内核、系统早期的启动阶段的日志以及系统守护进程在启动和运行中的标准输出和错误。</p><p>在CentOS 7及更高版本中，journalctl成为了查看和管理系统日志的主要工具，它从/var/log/journal/和/run/log/journal/等路径获取日志信息。同时，systemd-journald会将日志信息写入到socket文件/run/systemd/journal/syslog中，然后由rsyslog服务监听这个socket文件，从而实现对日志的统一管理和处理。因此，可以说syslog和journalctl在日志管理中各司其职，共同保障了Linux系统日志的完整性和可用性。</p><p>以上提到了一些名词，先说明一下来清楚其中的关系，journal日志使用journalctl工具管理，依赖<code>systemd-journald</code>服务，syslog日志可以用文本工具来查看，view、more、cat等命令都可以用，也可以借助其他工具查看特定信息，比如用dmesg命令查看syslog中内核相关日志，syslog依赖的服务名通常是 <code>rsyslogd</code></p><p><code>journalctl</code> 和 <code>syslog</code> 都是 Linux 系统中用于处理和查看系统日志的工具，我们从以下几个方面来对比下两者的区别：</p><ul><li><p><strong>存储方式：</strong></p><ul><li><code>syslog</code> 使用文本文件来存储日志信息，可以通过文本编辑器查看，通常存储在 <code>/var/log/syslog</code> 或 <code>/var/log/message</code></li><li><code>journalctl</code> 使用 <code>systemd-journald</code> 服务来存储二进制格式的日志文件。通常存储在 <code>/run/log/journal/</code> 或 <code>/var/log/journal/</code></li></ul></li><li><p><strong>日志内容：</strong></p><ul><li><code>syslog</code> 使用文本格式，记录在文本文件中。日志信息包含时间戳、主机名、应用程序名等</li><li><code>journalctl</code> 使用二进制格式，可以存储更多的元数据，例如进程 ID、用户 ID、SELinux 上下文等。这使得日志更加结构化，支持更高级的查询和过滤</li></ul></li><li><p><strong>查询和过滤：</strong></p><ul><li><code>syslog</code> 的查询和过滤通常使用命令行工具（例如 <code>grep</code>）或者专用的工具（例如 <code>logrotate</code>）</li><li><code>journalctl</code> 提供了更丰富和强大的查询和过滤功能，可以按时间、服务单元、日志级别等多个条件进行过滤。这使得查找和分析特定事件更加方便</li></ul></li><li><p><strong>实时查看：</strong></p><ul><li><code>syslog</code> 通常使用 <code>tail</code> 命令实时查看日志文件的末尾</li><li><code>journalctl</code> 可以使用 <code>-f</code> 或 <code>--follow</code> 选项来实时查看最新的日志</li></ul></li><li><p><strong>服务和依赖关系：</strong></p><ul><li><code>syslog</code> 是一个通用的日志服务，可以由多个日志守护进程（如 <code>rsyslog</code>、<code>syslog-ng</code>）实现</li><li><code>journalctl</code> 是 <code>systemd</code> 系统中的一部分，依赖于 <code>systemd-journald</code> 服务</li></ul></li><li><p><strong>配置文件的路径：</strong></p><ul><li><code>syslog</code> 的配置文件在 <code>/etc/rsyslog.conf</code></li><li><code>journalctl</code> 的配置文件在 <code>/etc/systemd/journald.conf</code></li></ul></li></ul><p>总体而言，<code>journalctl</code> 是 <code>systemd</code> 系统的一部分，提供了更现代化、结构化和强大的日志管理功能，但这并不意味着 <code>syslog</code> 是过时的。在一些系统中，两者可能同时存在，而且一些工具和服务可能仍然使用传统的 <code>syslog</code>。选择使用哪一个取决于系统的需求和管理员的偏好。</p><p>下面分别展示一下<code>systemd-journald</code> 和 <code>rsyslogd</code> 两个服务查询信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[root@demo ~]<span class="comment"># systemctl status systemd-journald</span></span><br><span class="line">● systemd-journald.service - Journal Service</span><br><span class="line">   Loaded: loaded (/usr/lib/systemd/system/systemd-journald.service; static; vendor preset: disabled)</span><br><span class="line">   Active: active (running) since Mon 2023-12-04 20:26:34 CST; 2 weeks 3 days ago</span><br><span class="line">     Docs: man:systemd-journald.service(8)</span><br><span class="line">           man:journald.conf(5)</span><br><span class="line"> Main PID: 7099 (systemd-journal)</span><br><span class="line">   Status: <span class="string">"Processing requests..."</span></span><br><span class="line">   CGroup: /system.slice/systemd-journald.service</span><br><span class="line">           └─7099 /usr/lib/systemd/systemd-journald</span><br><span class="line"></span><br><span class="line">Dec 04 20:26:34 demo systemd-journal[7099]: Permanent journal is using 8.0M (max allowed 4.0G, trying to leave 4.0G free of 183.5G available → c…imit 4.0G).</span><br><span class="line">Dec 04 20:26:34 demo systemd-journal[7099]: Time spent on flushing to /var is 21.108ms <span class="keyword">for</span> 1873 entries.</span><br><span class="line">Dec 04 20:26:34 demo systemd-journal[7099]: Journal started</span><br><span class="line">Hint: Some lines were ellipsized, use -l to show <span class="keyword">in</span> full.</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[root@demo ~]<span class="comment"># systemctl status rsyslogd</span></span><br><span class="line">Unit rsyslogd.service could not be found.</span><br><span class="line">[root@demo ~]<span class="comment"># systemctl status rsyslog</span></span><br><span class="line">● rsyslog.service - System Logging Service</span><br><span class="line">   Loaded: loaded (/usr/lib/systemd/system/rsyslog.service; enabled; vendor preset: enabled)</span><br><span class="line">   Active: active (running) since Mon 2023-12-04 19:46:04 CST; 2 weeks 3 days ago</span><br><span class="line">     Docs: man:rsyslogd(8)</span><br><span class="line">           http://www.rsyslog.com/doc/</span><br><span class="line"> Main PID: 913 (rsyslogd)</span><br><span class="line">   CGroup: /system.slice/rsyslog.service</span><br><span class="line">           └─913 /usr/sbin/rsyslogd -n</span><br><span class="line"></span><br><span class="line">Dec 04 19:46:04 demo systemd[1]: Starting System Logging Service...</span><br><span class="line">Dec 04 19:46:04 demo rsyslogd[913]:  [origin software=<span class="string">"rsyslogd"</span> swVersion=<span class="string">"8.24.0-57.el7_9.3"</span> x-pid=<span class="string">"913"</span> x-info=<span class="string">"http://www.rsyslog.com"</span>] start</span><br><span class="line">Dec 04 19:46:04 demo systemd[1]: Started System Logging Service.</span><br><span class="line">Dec 04 20:26:34 demo rsyslogd[913]: imjournal: journal reloaded... [v8.24.0-57.el7_9.3 try http://www.rsyslog.com/e/0 ]</span><br><span class="line">Dec 10 03:22:01 demo rsyslogd[913]:  [origin software=<span class="string">"rsyslogd"</span> swVersion=<span class="string">"8.24.0-57.el7_9.3"</span> x-pid=<span class="string">"913"</span> x-info=<span class="string">"http://www.rsyslog.com"</span>] rsys...was HUPed</span><br><span class="line">Dec 15 01:35:01 demo rsyslogd[913]: imjournal: journal reloaded... [v8.24.0-57.el7_9.3 try http://www.rsyslog.com/e/0 ]</span><br><span class="line">Dec 17 03:07:01 demo rsyslogd[913]:  [origin software=<span class="string">"rsyslogd"</span> swVersion=<span class="string">"8.24.0-57.el7_9.3"</span> x-pid=<span class="string">"913"</span> x-info=<span class="string">"http://www.rsyslog.com"</span>] rsys...was HUPed</span><br><span class="line">Hint: Some lines were ellipsized, use -l to show <span class="keyword">in</span> full.</span><br></pre></td></tr></table></figure><h1 id="journal-和-syslog-配置"><a href="#journal-和-syslog-配置" class="headerlink" title="journal 和 syslog 配置"></a>journal 和 syslog 配置</h1><p>两个服务的配置文件都有很多内容，在此只展示其中部分重要的参数，先看一下 <code>/etc/systemd/journald.conf</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[Journal]</span><br><span class="line">Storage=persistent              <span class="comment">#开启持久化存储</span></span><br><span class="line"><span class="comment">#Compress=yes                   #开启压缩功能</span></span><br><span class="line"><span class="comment">#Seal=yes</span></span><br><span class="line">SystemMaxUse=40%                <span class="comment">#设置系统最大占用率为40%</span></span><br><span class="line">StorageOption=size              <span class="comment">#设置存储选项为按大小进行存储</span></span><br><span class="line">StorageOption=autorotate        <span class="comment">#设置存储选项为自动轮换</span></span><br><span class="line">StoragePath=/<span class="built_in">export</span>/<span class="built_in">log</span>/journal <span class="comment">#设置日志文件的存储路径</span></span><br></pre></td></tr></table></figure><p>再看一下 <code>/etc/rsyslog.conf</code> 配置文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Include all config files in /etc/rsyslog.d/</span></span><br><span class="line"><span class="variable">$IncludeConfig</span> /etc/rsyslog.d/*.conf <span class="comment">#将包含 `/etc/rsyslog.d/` 目录下的所有以 `.conf` 结尾的配置文件，可以将配置分散到多个文件使得管理更加灵活</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Turn off message reception via local log socket;</span></span><br><span class="line"><span class="comment"># local messages are retrieved through imjournal now.</span></span><br><span class="line"><span class="variable">$OmitLocalLogging</span> on <span class="comment">#不再通过本地日志套接字接收消息，本地消息现在通过 `imjournal`（Journal 日志服务）来检索</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#### RULES ####</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Log all kernel messages to the console.</span></span><br><span class="line"><span class="comment"># Logging much else clutters up the screen.</span></span><br><span class="line"><span class="comment">#kern.*                                                 /dev/console</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Log anything (except mail) of level info or higher.</span></span><br><span class="line"><span class="comment"># Don't log private authentication messages!</span></span><br><span class="line">*.info;mail.none;authpriv.none;cron.none                /var/<span class="built_in">log</span>/messages <span class="comment">#将所有信息级别（info）以及除了邮件、认证、和 cron 之外的其他日志，都记录到 `/var/log/messages` 文件中</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The authpriv file has restricted access.</span></span><br><span class="line">authpriv.*                                              /var/<span class="built_in">log</span>/secure <span class="comment">#将所有 authpriv（私密认证）级别的日志记录到 `/var/log/secure` 文件中</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Log all the mail messages in one place.</span></span><br><span class="line">mail.*                                                  -/var/<span class="built_in">log</span>/maillog <span class="comment">#将所有邮件相关的日志记录到 `/var/log/maillog` 文件中</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Log cron stuff</span></span><br><span class="line">cron.*                                                  /var/<span class="built_in">log</span>/cron <span class="comment">#将所有 cron 服务相关的日志记录到 `/var/log/cron` 文件中</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Everybody gets emergency messages</span></span><br><span class="line">*.emerg                                                 :omusrmsg:*     <span class="comment">#将所有紧急级别（emergency）的日志消息发送到用户消息队列</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Save news errors of level crit and higher in a special file.</span></span><br><span class="line">uucp,news.crit                                          /var/<span class="built_in">log</span>/spooler <span class="comment">#将所有 uucp 和 news 的 crit 级别及更高级别的日志记录到 `/var/log/spooler` 文件中</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Save boot messages also to boot.log</span></span><br><span class="line">local7.*                                                /var/<span class="built_in">log</span>/boot.log <span class="comment">#表示保存启动消息到boot.log文件中</span></span><br></pre></td></tr></table></figure><h1 id="使用journalctl查看和管理日志"><a href="#使用journalctl查看和管理日志" class="headerlink" title="使用journalctl查看和管理日志"></a>使用journalctl查看和管理日志</h1><h2 id="查看日志"><a href="#查看日志" class="headerlink" title="查看日志"></a>查看日志</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看所有日志（默认情况下只保存本次启动的日志）</span></span><br><span class="line">$ sudo journalctl</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示尾部指定行数的日志，默认10行</span></span><br><span class="line">$ sudo journalctl -n 20</span><br><span class="line"></span><br><span class="line"><span class="comment"># 实时滚动显示最新日志</span></span><br><span class="line">$ sudo journalctl -f</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看指定时间的日志</span></span><br><span class="line">$ sudo journalctl --since yesterday</span><br><span class="line">$ sudo journalctl --since=<span class="string">"2023-12-22 16:52:18"</span></span><br><span class="line">$ sudo journalctl --since <span class="string">"30 min ago"</span></span><br><span class="line">$ sudo journalctl --since <span class="string">"2023-12-22 16:52:18"</span> --until <span class="string">"2023-12-22 23:52:18"</span></span><br><span class="line">$ sudo journalctl --since 09:00 --until <span class="string">"1 hour ago"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看内核日志，过滤掉应用日志</span></span><br><span class="line">$ sudo journalctl -k</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看系统本次启动的日志</span></span><br><span class="line">$ sudo journalctl -b</span><br><span class="line">$ sudo journalctl -b -0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看上一次启动的日志</span></span><br><span class="line">$ sudo journalctl -b -1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看指定优先级及其以上级别的日志，共有8级 0: emerg 1: alert 2: crit 3: err 4: warning 5: notice 6: info 7: debug</span></span><br><span class="line"><span class="comment"># -b 不加任何参数时，表示显示当前引导周期的日志。这意味着只显示自最近一次启动以来的日志。</span></span><br><span class="line"><span class="comment"># -b N： N 是一个整数，表示要显示第 N 个引导周期的日志。例如，-b 0 表示显示最新的引导周期，-b 1 表示显示上一个引导周期，以此类推</span></span><br><span class="line">$ sudo journalctl -p err -b</span><br><span class="line"></span><br><span class="line"><span class="comment"># 日志默认分页输出，--no-pager 改为正常的标准输出</span></span><br><span class="line">$ sudo journalctl --no-pager</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以单行 JSON 格式输出</span></span><br><span class="line">$ sudo journalctl -b -u nginx.service -o json</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以多行 JSON 可读性更好的格式输出</span></span><br><span class="line">$ sudo journalctl -b -u nginx.service  -o json-pretty</span><br></pre></td></tr></table></figure><h2 id="查看指定服务日志"><a href="#查看指定服务日志" class="headerlink" title="查看指定服务日志"></a>查看指定服务日志</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 查看指定服务的日志</span></span><br><span class="line">$ sudo journalctl /usr/sbin/sshd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看指定进程的日志</span></span><br><span class="line">$ sudo journalctl _PID=1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看某个路径的脚本的日志</span></span><br><span class="line">$ sudo journalctl /bin/bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看指定用户的日志</span></span><br><span class="line">$ sudo journalctl _UID=1000 --since today</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看某个 Unit 的日志</span></span><br><span class="line"><span class="comment"># 单元（unit）通常是 systemd 服务的一个抽象，用于表示系统中正在运行的各种服务或任务</span></span><br><span class="line">$ sudo journalctl -u nginx.service</span><br><span class="line">$ sudo journalctl -u nginx.service --since today</span><br><span class="line"></span><br><span class="line"><span class="comment"># 合并显示多个 Unit 的日志</span></span><br><span class="line">$ journalctl -u nginx.service -u ssh.service --since today</span><br></pre></td></tr></table></figure><h2 id="查看调整存储"><a href="#查看调整存储" class="headerlink" title="查看调整存储"></a>查看调整存储</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 显示日志占据的硬盘空间</span></span><br><span class="line">$ sudo journalctl --disk-usage</span><br><span class="line"></span><br><span class="line"><span class="comment"># 仅保留500MB大小的日志文减</span></span><br><span class="line">$ sudo journalctl --vacuum-size=500M</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定日志文件保存多久</span></span><br><span class="line">$ sudo journalctl --vacuum-time=1years</span><br><span class="line"></span><br><span class="line"><span class="comment"># 仅保留最近一个月的日志文件</span></span><br><span class="line">$ sudo journalctl --vacuum-time=1m</span><br><span class="line"></span><br><span class="line"><span class="comment"># 仅保留最近2天的日志文件</span></span><br><span class="line">$ sudo journalctl --vacuum-time=2d</span><br></pre></td></tr></table></figure><h1 id="回到文章开头的问题"><a href="#回到文章开头的问题" class="headerlink" title="回到文章开头的问题"></a>回到文章开头的问题</h1><p>通过梳理知识，我发现通过 <code>systemctl</code> 命令查询 <code>systemd-journald</code> 服务状态可以看到日志存储路径和存储限制，分别展示一下，先看存储到内存的：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">root@demo1:~<span class="comment"># systemctl status systemd-journald</span></span><br><span class="line">● systemd-journald.service - Journal Service</span><br><span class="line">   Loaded: loaded (/lib/systemd/system/systemd-journald.service; static; vendor preset: enabled)</span><br><span class="line">   Active: active (running) since Fri 2023-12-22 10:25:43 CST; 10h ago</span><br><span class="line">     Docs: man:systemd-journald.service(8)</span><br><span class="line">           man:journald.conf(5)</span><br><span class="line"> Main PID: 1132 (systemd-journal)</span><br><span class="line">   Status: <span class="string">"Processing requests..."</span></span><br><span class="line">    Tasks: 1</span><br><span class="line">   Memory: 272.0K</span><br><span class="line">      CPU: 204ms</span><br><span class="line">   CGroup: /system.slice/systemd-journald.service</span><br><span class="line">           └─1132 /lib/systemd/systemd-journald</span><br><span class="line"></span><br><span class="line">Dec 22 10:25:43 demo1 systemd-journald[1132]: Runtime journal (/run/<span class="built_in">log</span>/journal/) is 8.0M, max 159.9M, 151.9M free.</span><br><span class="line">Dec 22 10:25:43 demo1 systemd-journald[1132]: Journal started</span><br><span class="line">root@demo1:~<span class="comment"># df -h</span></span><br><span class="line">Filesystem      Size  Used Avail Use% Mounted on</span><br><span class="line">udev            7.8G     0  7.8G   0% /dev</span><br><span class="line">tmpfs           1.6G  9.3M  1.6G   1% /run</span><br><span class="line">/dev/sda1        83G   29G   51G  36% /</span><br><span class="line">tmpfs           7.9G     0  7.9G   0% /dev/shm</span><br><span class="line">tmpfs           5.0M     0  5.0M   0% /run/lock</span><br><span class="line">tmpfs           7.9G     0  7.9G   0% /sys/fs/cgroup</span><br><span class="line">/dev/sdb       1017G  903G  115G  89% /<span class="built_in">export</span></span><br><span class="line">tmpfs           1.6G     0  1.6G   0% /run/user/111</span><br><span class="line">tmpfs           1.6G     0  1.6G   0% /run/user/1001</span><br></pre></td></tr></table></figure><p>默认存储到 /run/log/journal/中，分区一共1.6G，最大max 159.9M，当前用了 8.0M，按这个来推算果然限制是10%，再看看持久化的情况</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">root@jenkins2004:~<span class="comment"># systemctl status systemd-journald</span></span><br><span class="line">● systemd-journald.service - Journal Service</span><br><span class="line">     Loaded: loaded (/lib/systemd/system/systemd-journald.service; static; vendor preset: enabled)</span><br><span class="line">     Active: active (running) since Sun 2023-08-27 09:24:15 CST; 3 months 26 days ago</span><br><span class="line">TriggeredBy: ● systemd-journald-dev-log.socket</span><br><span class="line">             ● systemd-journald.socket</span><br><span class="line">             ● systemd-journald-audit.socket</span><br><span class="line">       Docs: man:systemd-journald.service(8)</span><br><span class="line">             man:journald.conf(5)</span><br><span class="line">   Main PID: 375 (systemd-journal)</span><br><span class="line">     Status: <span class="string">"Processing requests..."</span></span><br><span class="line">      Tasks: 1 (<span class="built_in">limit</span>: 19123)</span><br><span class="line">     Memory: 42.7M</span><br><span class="line">     CGroup: /system.slice/systemd-journald.service</span><br><span class="line">             └─375 /lib/systemd/systemd-journald</span><br><span class="line"></span><br><span class="line">8月 27 09:24:15 jenkins2004 systemd-journald[375]: Journal started</span><br><span class="line">8月 27 09:24:15 jenkins2004 systemd-journald[375]: Time spent on flushing to /var/<span class="built_in">log</span>/journal/cc9ad539032546a1bd39a773d37e415f is 613.827ms <span class="keyword">for</span> 1229 entries.</span><br><span class="line">8月 27 09:24:15 jenkins2004 systemd-journald[375]: System Journal (/var/<span class="built_in">log</span>/journal/cc9ad539032546a1bd39a773d37e415f) is 1.4G, max 4.0G, 2.5G free.</span><br><span class="line">8月 27 09:24:22 jenkins2004 systemd-journald[375]: Forwarding to syslog missed 1 messages.</span><br><span class="line">8月 27 09:24:53 jenkins2004 systemd-journald[375]: Forwarding to syslog missed 80 messages.</span><br><span class="line">Warning: journal has been rotated since unit was started, output may be incomplete.</span><br><span class="line">root@jenkins2004:~<span class="comment"># df -h | grep -v snap</span></span><br><span class="line">Filesystem      Size  Used Avail Use% Mounted on</span><br><span class="line">udev            7.8G     0  7.8G   0% /dev</span><br><span class="line">tmpfs           1.6G  1.6M  1.6G   1% /run</span><br><span class="line">/dev/sda5       590G  369G  191G  66% /</span><br><span class="line">tmpfs           7.9G     0  7.9G   0% /dev/shm</span><br><span class="line">tmpfs           5.0M     0  5.0M   0% /run/lock</span><br><span class="line">tmpfs           7.9G     0  7.9G   0% /sys/fs/cgroup</span><br><span class="line">/dev/sda1       511M  4.0K  511M   1% /boot/efi</span><br><span class="line">tmpfs           1.6G   36K  1.6G   1% /run/user/125</span><br><span class="line">tmpfs           1.6G  4.0K  1.6G   1% /run/user/1002</span><br></pre></td></tr></table></figure><p>看起来存到了 <code>var/log/journal</code>，最大可用空间居然到了4G，这样来分析这次的问题可能不是journal日志搞的鬼，而是很多进程吧/run目录写满了，导致journal写不进去报了开头的错误，进而引发的无法登录。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>syslog和journal在日志管理中各司其职，共同保障了Linux系统日志的完整性和可用性</li><li>journal默认将系统日志存储在/run/log/journal目录中，而 <code>/run</code> 通常挂载在内存中，当此目录被写满时可能导致ssh无法登录</li><li>将 <code>/etc/systemd/journald.conf</code> 配置中的 Storage 字段设置为 <code>persistent</code> 可以开启日志持久化</li><li><code>sudo journalctl -n 20</code> 可以显示显示尾部最新的20行日志，-n后不加参数默认10行</li><li><code>sudo journalctl -u nginx.service</code> 查看ssh服务器的日志</li><li><code>sudo journalctl --since=&quot;2023-12-22 16:52:18&quot;</code> 查看指定时间以后的日志</li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/135094892" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>寒意一波接着一波，总会有看见“光”的时候（30厘米的下跌，摔得可真疼）</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;就在半月之前，负责打包更新的服务器突然登录不上去了，赶紧找来运维的同事帮忙解决，发现系统日志中有很多 &lt;code&gt;systemd-journald[424]: Failed to open runtime journal: No space left on device&lt;/code&gt; 字样的错误，被告知磁盘满了需要清理，但是我当时登录不上去，只能让他们帮忙重启后利用单用户模式上去删除临时文件试试，但重启后发现问题解决了，很是诧异，查询服务器后台监控平台，发现磁盘空间还有50%，inode只占用了0.02%，这怎么会磁盘满了呢？&lt;/p&gt;
    
    </summary>
    
      <category term="linux" scheme="http://AlbertGithubHome.github.io/blog/categories/linux/"/>
    
    
      <category term="linux" scheme="http://AlbertGithubHome.github.io/blog/tags/linux/"/>
    
      <category term="运维" scheme="http://AlbertGithubHome.github.io/blog/tags/%E8%BF%90%E7%BB%B4/"/>
    
      <category term="服务器" scheme="http://AlbertGithubHome.github.io/blog/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
      <category term="journalctl" scheme="http://AlbertGithubHome.github.io/blog/tags/journalctl/"/>
    
      <category term="syslog" scheme="http://AlbertGithubHome.github.io/blog/tags/syslog/"/>
    
  </entry>
  
  <entry>
    <title>gitlab修改代码库的名称、路径和分组</title>
    <link href="http://AlbertGithubHome.github.io/blog/2023/12/19/gitlab%E4%BF%AE%E6%94%B9%E4%BB%A3%E7%A0%81%E5%BA%93%E7%9A%84%E5%90%8D%E7%A7%B0%E3%80%81%E8%B7%AF%E5%BE%84%E5%92%8C%E5%88%86%E7%BB%84/"/>
    <id>http://AlbertGithubHome.github.io/blog/2023/12/19/gitlab修改代码库的名称、路径和分组/</id>
    <published>2023-12-19T14:20:24.000Z</published>
    <updated>2023-12-19T16:13:09.824Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>工作项目的源码使用gitlab进行管理，通常情况下不会修改代码库和路径，但是非一般的情况总是存在，比如刚刚立项时多次调整项目名，甚至改变管理层级，所以还是有这类需求的，一开始我本打算将旧的代码库和提交记录推送到新的地址和分组，后来在gitlab后台里翻了翻，结合网络大神们的指点，发现可以直接修改代码库的名称和分组，总共需要修改3个配置，一起来看下。</p><a id="more"></a><h1 id="修改过程"><a href="#修改过程" class="headerlink" title="修改过程"></a>修改过程</h1><h2 id="具体需求"><a href="#具体需求" class="headerlink" title="具体需求"></a>具体需求</h2><p>假设需求是将项目名从 <code>A</code> 改为 <code>B</code>，同时将访问路径从 <code>git@gitlab.example.cn:APrject/AGroup/A.git</code> 改为 <code>git@gitlab.example.cn:APrject/AGroup/B.git</code>，这里一共有三处需要修改：项目名、访问路径、以及分组，下面依次列举出修改的方法：</p><h2 id="修改项目名"><a href="#修改项目名" class="headerlink" title="修改项目名"></a>修改项目名</h2><p>导航路径【Settings】-&gt;【General】-&gt;【Naming, topics, avatar】-&gt;【Project name】，只需填入新的项目名，点击 “Save changes” 按钮即可，页面展示如下：</p><p><img src="https://img-blog.csdnimg.cn/direct/9f3e4a5c908f479e918ee20fdb86e14c.png" alt="Project name"></p><h2 id="修改访问路径"><a href="#修改访问路径" class="headerlink" title="修改访问路径"></a>修改访问路径</h2><p>做完上一步只是修改了项目名字，如果使用 <code>git clone</code> 命令下载整个库，路径是没有发生变化的，修改访问路径需要调整 “Path”</p><p>导航路径【Settings】-&gt;【General】-&gt;【Advanced】-&gt;【Expand】-&gt;【Change path】，只能修改最后一段Path，其中不能再包含 <code>/</code>，修改后点击 “Change path” 即可，页面展示如下：</p><p><img src="https://img-blog.csdnimg.cn/direct/1568d9ff2cbf4dd0b82ca05e235371f9.png" alt="Change path1"></p><p><img src="https://img-blog.csdnimg.cn/direct/80006b8b2fb84ea1bc493a6668e2f960.png" alt="Change path2"></p><h2 id="修改分组"><a href="#修改分组" class="headerlink" title="修改分组"></a>修改分组</h2><p>上面修改路径这一步只允许修改Path的最后一段，不能直接调整分组路径，想要调整前面的路径需要调整分组</p><p>导航路径【Settings】-&gt;【General】-&gt;【Advanced】-&gt;【Expand】-&gt;【Transfer project】，这一步只能选择已有的分组，选择好目标分组，点击 “Transfer project” 按钮即可，页面展示如下：</p><p><img src="https://img-blog.csdnimg.cn/direct/20dac08bf02049bf9b6f4fcb8f00a637.png" alt="Transfer project"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>gitlab后台可以直接修改代码库的名称、路径和分组等信息，不必重新创建项目</li><li>在修改名称、路径和分组等信息后需要相关人员更新对原有代码库的引用，否则会找不到</li><li>使用 <code>git remote set-url origin &lt;new-url&gt;</code> 命令可以更新已有仓库的URL</li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/134981708" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>对未来的迷茫以及内心的不安，让我们在现有社会经济条件下，沦为被金钱和物质所统治的行尸走肉</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;工作项目的源码使用gitlab进行管理，通常情况下不会修改代码库和路径，但是非一般的情况总是存在，比如刚刚立项时多次调整项目名，甚至改变管理层级，所以还是有这类需求的，一开始我本打算将旧的代码库和提交记录推送到新的地址和分组，后来在gitlab后台里翻了翻，结合网络大神们的指点，发现可以直接修改代码库的名称和分组，总共需要修改3个配置，一起来看下。&lt;/p&gt;
    
    </summary>
    
      <category term="Git" scheme="http://AlbertGithubHome.github.io/blog/categories/Git/"/>
    
    
      <category term="git" scheme="http://AlbertGithubHome.github.io/blog/tags/git/"/>
    
      <category term="gitlab" scheme="http://AlbertGithubHome.github.io/blog/tags/gitlab/"/>
    
      <category term="修改项目名" scheme="http://AlbertGithubHome.github.io/blog/tags/%E4%BF%AE%E6%94%B9%E9%A1%B9%E7%9B%AE%E5%90%8D/"/>
    
      <category term="修改路径" scheme="http://AlbertGithubHome.github.io/blog/tags/%E4%BF%AE%E6%94%B9%E8%B7%AF%E5%BE%84/"/>
    
      <category term="修改分组" scheme="http://AlbertGithubHome.github.io/blog/tags/%E4%BF%AE%E6%94%B9%E5%88%86%E7%BB%84/"/>
    
      <category term="后台管理" scheme="http://AlbertGithubHome.github.io/blog/tags/%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>利用websockify将websocket通信转换成tcp</title>
    <link href="http://AlbertGithubHome.github.io/blog/2023/12/13/%E5%88%A9%E7%94%A8websockify%E5%B0%86websocket%E9%80%9A%E4%BF%A1%E8%BD%AC%E6%8D%A2%E6%88%90tcp/"/>
    <id>http://AlbertGithubHome.github.io/blog/2023/12/13/利用websockify将websocket通信转换成tcp/</id>
    <published>2023-12-13T14:30:05.000Z</published>
    <updated>2023-12-19T16:11:09.636Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>目前遇到一个问题，原本的服务都是利用tcp通信的，但是某些平台只支持websocket，是不是要从头实现一套websocket网络收发逻辑呢？短时间内有没有替代方案呢？在经过一番寻找之后发现了websockify这个神器，可以将websocket协议转换成tcp协议，从而实现不修改应用服务就支持tcp协议的目的，接下来就说说它怎么用，以及探索的过程。</p><a id="more"></a><h1 id="websockify"><a href="#websockify" class="headerlink" title="websockify"></a>websockify</h1><h2 id="websockify-介绍"><a href="#websockify-介绍" class="headerlink" title="websockify 介绍"></a>websockify 介绍</h2><p><a href="https://github.com/novnc/websockify/tree/master" target="_blank" rel="noopener">websockify</a> 是一个用于将 WebSocket 流量转发到其他协议的工具，它的主要用途之一是将 WebSockets 转发到基于 TCP 的协议，例如 VNC（Virtual Network Computing），以下是它的一些关键特点和用途：</p><ul><li><p><strong>WebSocket 转发：</strong> <code>websockify</code> 允许你将 WebSocket 流量转发到其他类型的网络服务，使得你可以通过 WebSocket 连接访问这些服务。</p></li><li><p><strong>VNC 转发：</strong> <code>websockify</code> 最常用于将 WebSocket 转发到 VNC 服务器。这使得你可以通过 Web 浏览器访问运行 VNC 服务的远程计算机的桌面。</p></li><li><p><strong>安全性：</strong> <code>websockify</code> 支持加密通信，因此可以在安全连接上运行，提供更好的数据保护。</p></li><li><p><strong>协议适配：</strong> <code>websockify</code> 提供了一个通用的桥接机制，允许你将 WebSocket 连接转发到支持其他协议的服务，而不仅仅是 VNC。</p></li><li><p><strong>JavaScript 客户端：</strong> <code>websockify</code> 还包括一个 JavaScript 客户端库，可以直接在浏览器中使用，无需额外的插件。</p></li></ul><p>使用 websockify 的典型场景包括在 Web 浏览器中访问远程计算机的桌面，或者通过 WebSocket 连接到其他需要 TCP 连接的服务，在实际应用中，你可以通过命令行使用 websockify，也可以将其嵌入到其他应用程序中。</p><h2 id="websockify-使用"><a href="#websockify-使用" class="headerlink" title="websockify 使用"></a>websockify 使用</h2><p>在Ubuntu系统下可以直接使用以下安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt install websockify</span><br></pre></td></tr></table></figure><p>下面是一个使用示例，作用是将原本连接到8765的websocket请求转换成tcp请求，TCP端口4321</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ websockify 8765 127.0.0.1:12346</span><br></pre></td></tr></table></figure><p>启动后原本仅支持TCP协议的服务就可以通过websockify实现对websocket的支持了</p><h1 id="探索的过程"><a href="#探索的过程" class="headerlink" title="探索的过程"></a>探索的过程</h1><p>虽然是短短的一条 <code>websockify 8765 127.0.0.1:12346</code> 命令就可以实现从websocket到tcp的转换，但是探索的过程却不顺利，在发现<code>websockify</code>这个神器之后，首先是测试它是否能满足我们的需求，是否好用，但是直接在原有的服务上测试太费时间，所以尝试写了几个模拟的脚本。</p><h2 id="提供基础TCP服务"><a href="#提供基础TCP服务" class="headerlink" title="提供基础TCP服务"></a>提供基础TCP服务</h2><p>最基本的我们需要一个很能提供TCP服务的程序，这里我使用python写了一个回显的服务器 echoserver.py，绑定本地的12346端口</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 创建一个TCP套接字</span></span><br><span class="line">    server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 绑定IP地址和端口</span></span><br><span class="line">    server_socket.bind((<span class="string">'127.0.0.1'</span>, <span class="number">12346</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 监听连接</span></span><br><span class="line">    server_socket.listen(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">    print(<span class="string">"服务器已启动，等待客户端连接..."</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        <span class="comment"># 接受客户端连接</span></span><br><span class="line">        client_socket, client_address = server_socket.accept()</span><br><span class="line">        print(<span class="string">f"客户端<span class="subst">&#123;client_address&#125;</span>已连接"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 接收客户端发送的数据</span></span><br><span class="line">        data = client_socket.recv(<span class="number">1024</span>)</span><br><span class="line">        print(<span class="string">f"收到来自<span class="subst">&#123;client_address&#125;</span>的数据： <span class="subst">&#123;data.decode(<span class="string">'utf-8'</span>)&#125;</span>"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 将接收到的数据发送回客户端</span></span><br><span class="line">        client_socket.send(data)</span><br><span class="line">        print(<span class="string">f"已将数据发送回<span class="subst">&#123;client_address&#125;</span>"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 关闭客户端套接字</span></span><br><span class="line">        client_socket.close()</span><br><span class="line">        print(<span class="string">f"客户端<span class="subst">&#123;client_address&#125;</span>已断开连接"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h3 id="测试可用"><a href="#测试可用" class="headerlink" title="测试可用"></a>测试可用</h3><ul><li>启动服务</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ python3 echoserver.py</span><br><span class="line">服务器已启动，等待客户端连接...</span><br></pre></td></tr></table></figure><ul><li>用nc命令发送tcp数据</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">"Hello server"</span> | nc 127.0.0.1 12346</span><br><span class="line">Hello server</span><br></pre></td></tr></table></figure><ul><li>TCP服务器看到的内容</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">服务器已启动，等待客户端连接...</span><br><span class="line">客户端(<span class="string">'127.0.0.1'</span>, 59214)已连接</span><br><span class="line">收到来自(<span class="string">'127.0.0.1'</span>, 59214)的数据： Hello server</span><br><span class="line"></span><br><span class="line">已将数据发送回(<span class="string">'127.0.0.1'</span>, 59214)</span><br><span class="line">客户端(<span class="string">'127.0.0.1'</span>, 59214)已断开连接</span><br></pre></td></tr></table></figure><p>TCP服务一切正常</p><h2 id="实现Websocket客户端"><a href="#实现Websocket客户端" class="headerlink" title="实现Websocket客户端"></a>实现Websocket客户端</h2><p>因为python的运行环境是现成的，所以我又用它写了一个websocket客户端 wsclient.py 来发送数据，想运行的话得安装几个包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python3 -m pip install websocket</span><br><span class="line">python3 -m pip install websocket-client</span><br></pre></td></tr></table></figure><blockquote><p>真实的情况下我是用websocket客户端连接nginx，然后将nginx转发到websockify监听端口，然后websockify将数据转成tcp连接应用服务，但是这个过程太复杂了，不利于说明问题，所以后面的内容我省掉nginx，假装它不存在，直接用websocket客户端连接websockify监听端口</p></blockquote><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># 运行websocket服务器</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> websocket</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_message</span><span class="params">(ws, message)</span>:</span></span><br><span class="line">    print(<span class="string">f"Received message: <span class="subst">&#123;message&#125;</span>"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_error</span><span class="params">(ws, error)</span>:</span></span><br><span class="line">    print(<span class="string">f"Error: <span class="subst">&#123;error&#125;</span>"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_close</span><span class="params">(ws, close_status_code, close_msg)</span>:</span></span><br><span class="line">    print(<span class="string">f"Connection closed with status code <span class="subst">&#123;close_status_code&#125;</span>"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_open</span><span class="params">(ws)</span>:</span></span><br><span class="line">    print(<span class="string">"Connection opened"</span>)</span><br><span class="line">    <span class="comment"># 在连接建立后发送一条消息</span></span><br><span class="line">    ws.send(<span class="string">"abcd"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="comment"># WebSocket 服务器地址</span></span><br><span class="line">    ws_url = <span class="string">"ws://10.10.49.172:8765"</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建 WebSocket 连接</span></span><br><span class="line">    ws = websocket.WebSocketApp(ws_url,</span><br><span class="line">                                on_message=on_message,</span><br><span class="line">                                on_error=on_error,</span><br><span class="line">                                on_close=on_close)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 设置连接建立时的回调函数</span></span><br><span class="line">    ws.on_open = on_open</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 启动 WebSocket 连接</span></span><br><span class="line">    ws.run_forever()</span><br></pre></td></tr></table></figure><p>为了websocket客户端的测试，我写了一个websocket服务器 wsserver.py 来接收数据，不过这不是一开始就测试了，而是在后面发现转换TCP失败查找原因，按流程分段测试时补充的脚本内容</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> websockets</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">echo</span><span class="params">(websocket, path)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">async</span> <span class="keyword">for</span> message <span class="keyword">in</span> websocket:</span><br><span class="line">            print(<span class="string">f"Received message: <span class="subst">&#123;message&#125;</span>"</span>)</span><br><span class="line">            <span class="keyword">await</span> websocket.send(message)</span><br><span class="line">    <span class="keyword">except</span> websockets.exceptions.ConnectionClosed:</span><br><span class="line">        print(<span class="string">"WebSocket connection closed"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    server = <span class="keyword">await</span> websockets.serve(echo, <span class="string">"0.0.0.0"</span>, <span class="number">12346</span>)</span><br><span class="line"></span><br><span class="line">    print(<span class="string">"WebSocket server is running..."</span>)</span><br><span class="line">    <span class="keyword">await</span> server.wait_closed()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    asyncio.run(main())</span><br></pre></td></tr></table></figure><p>测试结果websocket客户端发送的数据，websocket服务器可以正常收到。</p><h2 id="开始测试websockify功能"><a href="#开始测试websockify功能" class="headerlink" title="开始测试websockify功能"></a>开始测试websockify功能</h2><ul><li>启动tcp服务echoserver，监听12346端口</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ python3 echoserver.py</span><br><span class="line">服务器已启动，等待客户端连接...</span><br></pre></td></tr></table></figure><ul><li>启动tcp服务websockify，监听8765端口，转换到12346端口</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ websockify 8765 127.0.0.1:12346</span><br><span class="line">WebSocket server settings:</span><br><span class="line">  - Listen on :8765</span><br><span class="line">  - No SSL/TLS support (no cert file)</span><br><span class="line">  - proxying from :8765 to 127.0.0.1:12346</span><br></pre></td></tr></table></figure><ul><li>运行websocket客户端发送的数据</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ python3 ./wsclient.py</span><br><span class="line">Connection opened</span><br><span class="line">Connection closed with status code 1003</span><br></pre></td></tr></table></figure><p>报错了！！！</p><p>再看echoserver输出，虽然连接成功，但是收到的数据为空</p><blockquote><p>客户端(‘127.0.0.1’, 55032)已连接<br>收到来自(‘127.0.0.1’, 55032)的数据：<br>已将数据发送回(‘127.0.0.1’, 55032)<br>客户端(‘127.0.0.1’, 55032)已断开连接</p></blockquote><p>然后看下websockify输出，显示转发连接12346端口成功了，但是没有后续输出</p><blockquote><p>$ websockify 8765 127.0.0.1:12346<br>WebSocket server settings:</p><ul><li>Listen on :8765</li><li>No SSL/TLS support (no cert file)</li><li>proxying from :8765 to 127.0.0.1:12346<br>10.2.48.36 - - [13/Dec/2023 20:03:11] 10.2.48.36: Plain non-SSL (ws://) WebSocket connection<br>10.2.48.36 - - [13/Dec/2023 20:03:11] connecting to: 127.0.0.1:12346</li></ul></blockquote><p>定位问题吧，期间不断调整nginx配置，查看nginx和websockify日志，调整wsclient写法，调整echoserver写法，分步测试wsclient和echoserver功能都没发现问题，具体测试细节暂且不表，后来我发现可以修改websockify启动参数输出更详细的日志，测试过程如下</p><h3 id="再次启动websockify"><a href="#再次启动websockify" class="headerlink" title="再次启动websockify"></a>再次启动websockify</h3><p>启动websockify再次使用wsclient测试，输出了额外的信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$ websockify 8765 127.0.0.1:12346 --<span class="built_in">log</span>-file /tmp/ws.log -v --traffic</span><br><span class="line">WebSocket server settings:</span><br><span class="line">  - Listen on :8765</span><br><span class="line">  - No SSL/TLS support (no cert file)</span><br><span class="line">  - proxying from :8765 to 127.0.0.1:12346</span><br><span class="line">10.2.48.36: new handler Process</span><br><span class="line">10.2.48.36 - - [13/Dec/2023 20:13:42] <span class="string">"GET / HTTP/1.1"</span> 101 -</span><br><span class="line">10.2.48.36 - - [13/Dec/2023 20:13:42] 10.2.48.36: Plain non-SSL (ws://) WebSocket connection</span><br><span class="line">10.2.48.36 - - [13/Dec/2023 20:13:42] connecting to: 127.0.0.1:12346</span><br><span class="line"></span><br><span class="line">Traffic Legend:</span><br><span class="line">    &#125;  - Client receive</span><br><span class="line">    &#125;. - Client receive partial</span><br><span class="line">    &#123;  - Target receive</span><br><span class="line"></span><br><span class="line">    &gt;  - Target send</span><br><span class="line">    &gt;. - Target send partial</span><br><span class="line">    &lt;  - Client send</span><br><span class="line">    &lt;. - Client send partial</span><br><span class="line">&#125;.10.2.48.36 - - [13/Dec/2023 20:13:42] 127.0.0.1:12346: Client closed connection</span><br><span class="line">10.2.48.36 - - [13/Dec/2023 20:13:42] 127.0.0.1:12346: Closed target</span><br></pre></td></tr></table></figure><p>顺着结尾的两条日志 <code>Client closed connection</code>，我找到了这一篇问题 <a href="https://github.com/novnc/websockify/issues/365" target="_blank" rel="noopener"><br>websockify - Client disconnects immediately after connection #365</a> 结论说是websockify不支持发送文本了</p><blockquote><p>Hmm… Are you trying to send text over that socket? We dropped support for text frames in the big cleanup.</p><p>Could you print the code and reason from the close in your close handler?</p></blockquote><p>我一看我的wsclient.py可不就是发送的文本嘛，看来有救了，赶紧改成了发送bytes <code>ws.send(b&#39;\x01\x02\x03\x04&#39;)</code>，但错误依旧，尝试各种发送函数无果，我严重怀疑我的换个python的websockets包有问题，所以我用html写了一个wsclient.html：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>WebSocket Binary Data Example<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">        <span class="comment">// 替换为你的 WebSocket 服务器地址</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">const</span> socket = <span class="keyword">new</span> WebSocket(<span class="string">"ws://10.10.49.172:8765"</span>);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">        <span class="comment">// 监听连接打开事件</span></span></span><br><span class="line"><span class="javascript">        socket.addEventListener(<span class="string">"open"</span>, (event) =&gt; &#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">"WebSocket connection opened."</span>);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">            <span class="comment">// 构造二进制数据，这里使用一个简单的示例</span></span></span><br><span class="line"><span class="javascript">            <span class="keyword">const</span> binaryData = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>([<span class="number">49</span>, <span class="number">50</span>, <span class="number">51</span>, <span class="number">52</span>]);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">            <span class="comment">// 发送二进制数据</span></span></span><br><span class="line"><span class="undefined">            socket.send(binaryData);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">"Binary data sent successfully."</span>);</span></span><br><span class="line"><span class="undefined">        &#125;);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">        <span class="comment">// 监听接收消息事件</span></span></span><br><span class="line"><span class="javascript">        socket.addEventListener(<span class="string">"message"</span>, (event) =&gt; &#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">"Received message:"</span>, event.data);</span></span><br><span class="line"><span class="undefined">        &#125;);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">        <span class="comment">// 监听连接关闭事件</span></span></span><br><span class="line"><span class="javascript">        socket.addEventListener(<span class="string">"close"</span>, (event) =&gt; &#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">"WebSocket connection closed."</span>);</span></span><br><span class="line"><span class="undefined">        &#125;);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">        <span class="comment">// 监听错误事件</span></span></span><br><span class="line"><span class="javascript">        socket.addEventListener(<span class="string">"error"</span>, (event) =&gt; &#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.error(<span class="string">"WebSocket error:"</span>, event);</span></span><br><span class="line"><span class="undefined">        &#125;);</span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这次终于正常了，websockify输出变成了由应用服务主动断开</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$ websockify 8765 127.0.0.1:12346 --<span class="built_in">log</span>-file /tmp/ws.log -v --traffic</span><br><span class="line">WebSocket server settings:</span><br><span class="line">  - Listen on :8765</span><br><span class="line">  - No SSL/TLS support (no cert file)</span><br><span class="line">  - proxying from :8765 to 127.0.0.1:12346</span><br><span class="line">10.2.48.36: new handler Process</span><br><span class="line">10.2.48.36 - - [13/Dec/2023 20:24:29] <span class="string">"GET / HTTP/1.1"</span> 101 -</span><br><span class="line">10.2.48.36 - - [13/Dec/2023 20:24:29] 10.2.48.36: Plain non-SSL (ws://) WebSocket connection</span><br><span class="line">10.2.48.36 - - [13/Dec/2023 20:24:29] connecting to: 127.0.0.1:12346</span><br><span class="line"></span><br><span class="line">Traffic Legend:</span><br><span class="line">    &#125;  - Client receive</span><br><span class="line">    &#125;. - Client receive partial</span><br><span class="line">    &#123;  - Target receive</span><br><span class="line"></span><br><span class="line">    &gt;  - Target send</span><br><span class="line">    &gt;. - Target send partial</span><br><span class="line">    &lt;  - Client send</span><br><span class="line">    &lt;. - Client send partial</span><br><span class="line">&#125;&gt;&#123;&lt;10.2.48.36 - - [13/Dec/2023 20:24:29] 127.0.0.1:12346: Target closed connection</span><br><span class="line">10.2.48.36 - - [13/Dec/2023 20:24:29] 127.0.0.1:12346: Closed target</span><br></pre></td></tr></table></figure><p>echoserver也看到了发送的内容【1234】：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ python3 echoserver.py</span><br><span class="line">服务器已启动，等待客户端连接...</span><br><span class="line">客户端(<span class="string">'127.0.0.1'</span>, 37438)已连接</span><br><span class="line">收到来自(<span class="string">'127.0.0.1'</span>, 37438)的数据： 1234</span><br><span class="line">已将数据发送回(<span class="string">'127.0.0.1'</span>, 37438)</span><br><span class="line">客户端(<span class="string">'127.0.0.1'</span>, 37438)已断开连接</span><br></pre></td></tr></table></figure><h3 id="单独实现一个js版本websocket客户端"><a href="#单独实现一个js版本websocket客户端" class="headerlink" title="单独实现一个js版本websocket客户端"></a>单独实现一个js版本websocket客户端</h3><p>刚刚用html里的js发送了websocket数据，需要浏览器的帮助，如果是在服务器上局限性很大，所以我调整了一下，改成了js版本websocket客户端，用node.js运行，wsclient.js内容如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> WebSocket = <span class="built_in">require</span>(<span class="string">'ws'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 替换为你的 WebSocket 服务器地址</span></span><br><span class="line"><span class="keyword">const</span> socket = <span class="keyword">new</span> WebSocket(<span class="string">"ws://10.10.49.172:8765"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听连接打开事件</span></span><br><span class="line">socket.addEventListener(<span class="string">"open"</span>, (event) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"WebSocket connection opened."</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造二进制数据，这里使用一个简单的示例</span></span><br><span class="line">    <span class="keyword">const</span> binaryData = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>([<span class="number">49</span>, <span class="number">50</span>, <span class="number">51</span>, <span class="number">52</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送二进制数据</span></span><br><span class="line">    socket.send(binaryData);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Binary data sent successfully."</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听接收消息事件</span></span><br><span class="line">socket.addEventListener(<span class="string">"message"</span>, (event) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Received message:"</span>, event.data);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听连接关闭事件</span></span><br><span class="line">socket.addEventListener(<span class="string">"close"</span>, (event) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"WebSocket connection closed."</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听错误事件</span></span><br><span class="line">socket.addEventListener(<span class="string">"error"</span>, (event) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(<span class="string">"WebSocket error:"</span>, event);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ node wsclient.js</span><br><span class="line">WebSocket connection opened.</span><br><span class="line">Binary data sent successfully.</span><br><span class="line">Received message: &lt;Buffer 31 32 33 34&gt;</span><br><span class="line">WebSocket connection closed.</span><br></pre></td></tr></table></figure><p>至此，websockify的测试就结束了，它可以满足我们的需求，将websocket请求转换成tcp请求</p><h1 id="什么是VNC"><a href="#什么是VNC" class="headerlink" title="什么是VNC"></a>什么是VNC</h1><p>前面在介绍websockify多次提到VNC，其实VNC (Virtual Network Computing) 是一种远程桌面协议，允许用户在一个计算机上通过网络远程控制另一个计算机的桌面。VNC 提供了一种在远程计算机上查看和操作桌面的方式，就像你坐在那台计算机前一样，以下是关于 VNC 的一些关键概念：</p><ul><li><p>Server：在 VNC 中，远程计算机上运行的应用程序称为 VNC 服务器。该服务器负责监听连接请求，并将计算机的桌面图像发送给连接的客户端。</p></li><li><p>Viewer：连接到 VNC 服务器的应用程序称为 VNC 查看器。这是用户使用的远程桌面客户端，允许他们查看和操作远程计算机的桌面。</p></li><li><p>Port：VNC 服务器通过一个特定的网络端口监听连接请求。通常，VNC 默认使用 5900 端口。如果有多个 VNC 服务器在同一台计算机上运行，它们可能使用不同的端口（5901、5902 等）。</p></li><li><p>Security：VNC 提供了一些安全性选项，如密码保护和加密。这有助于确保在远程访问时保护计算机的安全。</p></li><li><p>Authentication：VNC 服务器和查看器之间的连接通常需要身份验证。这可以是使用密码进行简单的身份验证，也可以是更复杂的加密和密钥交换过程。</p></li><li><p>websockify：对于一些场景，特别是在 Web 浏览器中访问 VNC，你可能会使用工具如 <code>websockify</code> 将 VNC 的协议转换为 WebSocket 协议，以便在浏览器中实现 VNC 远程桌面访问。</p></li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>websockify可以轻松实现从websocket请求向tcp请求的转换，使用很方便</li><li>转换路径 wsclient <code>--ws--&gt;</code> websockify <code>--tcp--&gt;</code> tcp application <code>--tcp--&gt;</code> websockify <code>--ws--&gt;</code> wsclient</li><li>wss对应的是ws的加密版本，他们的关系是wss=ws+SSL/TSL，类似的https=http+SSL/TSL</li><li>无论是nginx还是websockify都可以配置服务器证书，将应用服务器从SSL/TSL中解脱出来</li><li>VNC是一种远程桌面协议，允许用户在一个计算机上通过网络远程控制另一个计算机的桌面</li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/134888966" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>迈出这一步确实不太容易，一旦行动了就会发现没有想象中的那么难，我们都没有预知未来的能力，无法判定目前的选择是对还是错，既然选择了就要努力走下去</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;目前遇到一个问题，原本的服务都是利用tcp通信的，但是某些平台只支持websocket，是不是要从头实现一套websocket网络收发逻辑呢？短时间内有没有替代方案呢？在经过一番寻找之后发现了websockify这个神器，可以将websocket协议转换成tcp协议，从而实现不修改应用服务就支持tcp协议的目的，接下来就说说它怎么用，以及探索的过程。&lt;/p&gt;
    
    </summary>
    
      <category term="Nginx" scheme="http://AlbertGithubHome.github.io/blog/categories/Nginx/"/>
    
    
      <category term="Nginx" scheme="http://AlbertGithubHome.github.io/blog/tags/Nginx/"/>
    
      <category term="网络协议" scheme="http://AlbertGithubHome.github.io/blog/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    
      <category term="websockify" scheme="http://AlbertGithubHome.github.io/blog/tags/websockify/"/>
    
      <category term="websocket" scheme="http://AlbertGithubHome.github.io/blog/tags/websocket/"/>
    
      <category term="tcp/ip" scheme="http://AlbertGithubHome.github.io/blog/tags/tcp-ip/"/>
    
      <category term="NVC" scheme="http://AlbertGithubHome.github.io/blog/tags/NVC/"/>
    
  </entry>
  
  <entry>
    <title>nginx配置自建SSL证书</title>
    <link href="http://AlbertGithubHome.github.io/blog/2023/12/08/nginx%E9%85%8D%E7%BD%AE%E8%87%AA%E5%BB%BASSL%E8%AF%81%E4%B9%A6/"/>
    <id>http://AlbertGithubHome.github.io/blog/2023/12/08/nginx配置自建SSL证书/</id>
    <published>2023-12-08T15:24:23.000Z</published>
    <updated>2024-04-29T14:46:14.777Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>之前的一篇文章<a href="https://blog.csdn.net/albertsh/article/details/134724042" target="_blank" rel="noopener">《自建CA并生成自签名SSL证书》</a>中讲到为什么要自建CA和自签名SSL证书，是因为买证书得花钱，对于内部或小规模项目，使用自建SSL证书可能更为方便，不需要支付费用，而且不涉及复杂的验证过程。正式对外的服务一般都是要买公共证书颁发机构（CA）签发的SSL证书的，但是在对外发布前可以先使用自建证书打通流程</p><a id="more"></a><h1 id="配置SSL证书"><a href="#配置SSL证书" class="headerlink" title="配置SSL证书"></a>配置SSL证书</h1><p>创建SSL证书的流程参考上文中提到的文章吧，本文只讲怎样把自建SSL证书配置到nginx，实际上非常简单。</p><p>假设我们的自建证书是 <code>/root/ca/server.crt</code>，服务器私钥是 <code>/root/ca/server.key</code>，nginx配置文件我以<a href="https://blog.csdn.net/albertsh/article/details/129543700" target="_blank" rel="noopener">《记录一下第一次安装和配置Nginx》</a> 这篇文章的配置文件为例，初始配置为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">upstream go_entrance &#123;</span><br><span class="line">    server localhost:4101;</span><br><span class="line">    server localhost:4102;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen       4100;</span><br><span class="line">    server_name  localhost;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line"></span><br><span class="line">        proxy_pass http://go_entrance;</span><br><span class="line">        proxy_set_header Host <span class="variable">$host</span>;</span><br><span class="line">        proxy_set_header X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">        proxy_set_header X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4100端口监听http协议转发到本机的4101端口和4102端口，如果把SSL证书配置到这个端口上，就相当于这个端口支持了https，配置修改如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">upstream go_entrance &#123;</span><br><span class="line">    server localhost:4101;</span><br><span class="line">    server localhost:4102;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen 4100 ssl;</span><br><span class="line">    server_name  localhost;</span><br><span class="line"></span><br><span class="line">    ssl_certificate /root/ca/server.crt;</span><br><span class="line">    ssl_certificate_key /root/ca/server.key;</span><br><span class="line"></span><br><span class="line">    ssl_session_cache shared:SSL:10m;</span><br><span class="line">    ssl_session_timeout 10m;</span><br><span class="line"></span><br><span class="line">    ssl_protocols TLSv1 TLSv1.1 TLSv1.2;</span><br><span class="line">    ssl_ciphers HIGH:!aNULL:!MD5;</span><br><span class="line">    ssl_prefer_server_ciphers on;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_pass http://go_entrance;</span><br><span class="line">        proxy_set_header Host <span class="variable">$host</span>;</span><br><span class="line">        proxy_set_header X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">        proxy_set_header X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只需要将4100端口后面加上 ssl，再配置几个ssl相关的参数就可以了，含义如下：</p><ul><li><p><code>ssl_certificate</code>： 指定 SSL 证书文件路径 /root/ca/server.crt</p></li><li><p><code>ssl_certificate_key</code>： 指定私钥文件路径 /root/ca/server.key</p></li><li><p><code>ssl_session_cache</code>： 配置用于存储 SSL 会话的缓存。shared:SSL:10m 表示使用共享的内存区域，最大占用内存为 10MB</p></li><li><p><code>ssl_session_timeout</code>： 配置 SSL 会话的超时时间，这里设置为 10 分钟</p></li><li><p><code>ssl_protocols</code>： 指定支持的 SSL/TLS 协议版本，这里包括 TLSv1、TLSv1.1 和 TLSv1.2</p></li><li><p><code>ssl_ciphers</code>： 指定支持的加密套件，这里配置为 HIGH:!aNULL:!MD5，表示使用高强度的加密套件，不支持空加密和 MD5</p></li></ul><h1 id="SSL证书放在-Nginx-而不放在应用服务器上的好处"><a href="#SSL证书放在-Nginx-而不放在应用服务器上的好处" class="headerlink" title="SSL证书放在 Nginx 而不放在应用服务器上的好处"></a>SSL证书放在 Nginx 而不放在应用服务器上的好处</h1><p>正如上面的配置一样，4100端口收到https请求后转发到4101和4102上的是http协议，说明使用这种方式一些仅支持http协议的应用服务也可以通过nginx配置证书来达到支持https的目的，具体好处如下：</p><ul><li><p><strong>集中管理：</strong> 使用反向代理服务器管理 SSL 证书可以实现集中式管理。这意味着你可以在一个地方管理证书，而不需要在每个应用服务器上都安装和维护证书。这样能够简化证书的更新和维护流程。</p></li><li><p><strong>简化配置：</strong> 通过在反向代理服务器上配置 SSL，你可以简化应用服务器的配置。应用服务器可以专注于处理应用程序逻辑，而无需关心 SSL 配置。这样有助于提高系统的可维护性和简化配置过程。</p></li><li><p><strong>负载均衡和扩展：</strong> 如果你使用负载均衡，SSL终止（SSL Termination）在负载均衡器上执行可以减轻应用服务器的负担。负载均衡器负责处理SSL握手，将非加密的请求转发给后端应用服务器。这样，后端服务器就可以专注于处理业务逻辑，而无需处理加密和解密操作。</p></li><li><p><strong>性能优化：</strong> SSL 握手和加解密操作可能是计算密集型的任务，将这些任务从应用服务器中移除，可以在 SSL 握手和加解密方面提高性能。</p></li><li><p><strong>统一的安全策略：</strong> 通过在反向代理服务器上管理 SSL，可以实施统一的安全策略，确保所有传入和传出的流量都经过相同的安全设置。</p></li></ul><h1 id="Nginx只能转发http协议吗"><a href="#Nginx只能转发http协议吗" class="headerlink" title="Nginx只能转发http协议吗"></a>Nginx只能转发http协议吗</h1><p>不，Nginx 不仅仅能够转发 HTTP 协议，还支持其他多种协议的代理转发。主要的协议包括：</p><ul><li><p><strong>HTTPS协议：</strong> 通过在配置中启用 SSL/TLS，Nginx 可以用作安全的 HTTPS 服务器和反向代理，处理加密的 HTTP 流量。</p>  <figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">listen</span> <span class="number">443</span> ssl;</span><br><span class="line"><span class="attribute">ssl_certificate</span> /path/to/certificate.crt;</span><br><span class="line"><span class="attribute">ssl_certificate_key</span> /path/to/private-key.key;</span><br><span class="line"></span><br><span class="line"><span class="attribute">location</span> / &#123;</span><br><span class="line">    <span class="attribute">proxy_pass</span> https://backend_server;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>TCP协议：</strong> 从1.9版本开始 Nginx 可以用于代理 TCP 流量，例如数据库连接、消息队列等。</p>  <figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">stream</span> &#123;</span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span> <span class="number">3306</span>;</span><br><span class="line">        <span class="attribute">proxy_pass</span> backend_server:<span class="number">3306</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>UDP协议：</strong> 从Nginx 1.9.13版本开始，开始支持 UDP 代理。这使得它可以用于代理 UDP 流量，如 DNS 请求等。</p>  <figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">stream</span> &#123;</span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span> <span class="number">53</span> udp;</span><br><span class="line">        <span class="attribute">proxy_pass</span> backend_dns_server:<span class="number">53</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>WebSocket协议：</strong> WebSocket 是一种在单个 TCP 连接上提供全双工通信的协议，常用于实时应用程序，如在线游戏、聊天应用等。</p>  <figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">map</span> <span class="variable">$http_upgrade</span> <span class="variable">$connection_upgrade</span> &#123;</span><br><span class="line">    <span class="attribute">default</span> upgrade;</span><br><span class="line">    ''      close;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">server_name</span> your_domain.com;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">location</span> /websocket &#123;</span><br><span class="line">        <span class="attribute">proxy_pass</span> http://backend_server;</span><br><span class="line">        <span class="attribute">proxy_http_version</span> <span class="number">1</span>.<span class="number">1</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> Upgrade <span class="variable">$http_upgrade</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> Connection <span class="variable">$connection_upgrade</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="Nginx转发TCP协议会收到端口限制吗"><a href="#Nginx转发TCP协议会收到端口限制吗" class="headerlink" title="Nginx转发TCP协议会收到端口限制吗"></a>Nginx转发TCP协议会收到端口限制吗</h1><p>是的，TCP是一种面向连接的全双工通信的协议，当转发TCP消息时，Nginx不仅是一个服务器接受客户端的连接，再它连接应用服务器时还表现成一个客户端，每个连接需要消耗一个端口，以理论值65535个端口来计算，nginx最多转发65535个连接，但是可以通过 <code>proxy_bind</code> 来突破限制，或者配置多个IP或虚拟IP也可以。</p><p>这种方式还没测过，感兴趣可以参考官方说明的看一下 <a href="https://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_bind" target="_blank" rel="noopener">https://nginx.org/r/proxy_bind</a></p><h1 id="Nginx本身能将Websocket数据转化成TCP数据吗"><a href="#Nginx本身能将Websocket数据转化成TCP数据吗" class="headerlink" title="Nginx本身能将Websocket数据转化成TCP数据吗"></a>Nginx本身能将Websocket数据转化成TCP数据吗</h1><p>只使用Nginx是做不到的，但是搭配Websockify就可以做到WSS（WebSocket Secure）到 TCP 的转发</p><ol><li><p><strong>安装 Nginx：</strong><br>确保你的系统上已经安装了 Nginx。你可以使用系统包管理器或从 Nginx 官方网站下载并安装</p></li><li><p><strong>安装 Websockify：</strong><br>安装 Websockify，可以使用 pip 执行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install websockify</span><br></pre></td></tr></table></figure></li><li><p><strong>创建 Websockify 启动脚本：</strong><br>创建一个用于启动 Websockify 的脚本，例如 <code>start_websockify.sh</code>。脚本内容可能如下所示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">websockify --web /path/to/webroot 1234 localhost:5678</span><br></pre></td></tr></table></figure><p>这里 <code>1234</code> 是用于 WebSocket 连接的端口，<code>localhost:5678</code> 是实际 TCP 服务的地址</p></li><li><p><strong>配置 Nginx：</strong><br>修改 Nginx 配置文件，将 WSS 请求转发到 Websockify 启动脚本。示例配置如下：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">443</span> ssl;</span><br><span class="line">    <span class="attribute">server_name</span> your_domain.com;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">ssl_certificate</span> /root/ca/server.crt;</span><br><span class="line">    <span class="attribute">ssl_certificate_key</span> /root/ca/server.key;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">location</span> / &#123;</span><br><span class="line">        <span class="attribute">proxy_pass</span> http://localhost:1234;</span><br><span class="line">        <span class="attribute">proxy_http_version</span> <span class="number">1</span>.<span class="number">1</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> Upgrade <span class="variable">$http_upgrade</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> Connection <span class="string">"upgrade"</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> Host <span class="variable">$host</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的 <code>listen 443</code> 表示监听 HTTPS 请求，<code>proxy_pass http://localhost:1234</code> 将请求代理到 Websockify 启动脚本</p></li><li><p><strong>启动服务：</strong><br>启动 Websockify 服务：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod +x start_websockify.sh</span><br><span class="line">./start_websockify.sh</span><br></pre></td></tr></table></figure><p>启动 Nginx 服务：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start nginx</span><br></pre></td></tr></table></figure></li><li><p><strong>测试：</strong><br>使用支持 WebSocket 的客户端连接到 WSS 地址，例如 <code>wss://your_domain.com</code>，并验证是否成功将 WebSocket 请求转发到 TCP 服务</p></li></ol><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>nginx配置自建SSL证书，只需要修改nginx配置文件，在端口后配置添加 ssl 并指定证书和私钥路径即可</li><li>nginx上配置SSL证书可以将证书统一管理，减轻应用服务器加密解密的负担，专注于业务逻辑开发</li><li>nginx不仅支持http协议转发，还支持https、tcp、udp、websocket等协议的转发</li><li>nginx转发tcp协议时会收到端口号个数限制，理论上限6万，通过proxy_bind可以突破上限</li><li>nginx搭配websockify可以做到WSS 到 TCP 的转发</li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/134818171" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>寒风终究是刮到我这里了</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;之前的一篇文章&lt;a href=&quot;https://blog.csdn.net/albertsh/article/details/134724042&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《自建CA并生成自签名SSL证书》&lt;/a&gt;中讲到为什么要自建CA和自签名SSL证书，是因为买证书得花钱，对于内部或小规模项目，使用自建SSL证书可能更为方便，不需要支付费用，而且不涉及复杂的验证过程。正式对外的服务一般都是要买公共证书颁发机构（CA）签发的SSL证书的，但是在对外发布前可以先使用自建证书打通流程&lt;/p&gt;
    
    </summary>
    
      <category term="Nginx" scheme="http://AlbertGithubHome.github.io/blog/categories/Nginx/"/>
    
    
      <category term="运维" scheme="http://AlbertGithubHome.github.io/blog/tags/%E8%BF%90%E7%BB%B4/"/>
    
      <category term="Nginx" scheme="http://AlbertGithubHome.github.io/blog/tags/Nginx/"/>
    
      <category term="nginx ssl" scheme="http://AlbertGithubHome.github.io/blog/tags/nginx-ssl/"/>
    
      <category term="https" scheme="http://AlbertGithubHome.github.io/blog/tags/https/"/>
    
      <category term="websockify" scheme="http://AlbertGithubHome.github.io/blog/tags/websockify/"/>
    
  </entry>
  
  <entry>
    <title>怎么验证公钥和私钥是一对</title>
    <link href="http://AlbertGithubHome.github.io/blog/2023/12/05/%E6%80%8E%E4%B9%88%E9%AA%8C%E8%AF%81%E5%85%AC%E9%92%A5%E5%92%8C%E7%A7%81%E9%92%A5%E6%98%AF%E4%B8%80%E5%AF%B9/"/>
    <id>http://AlbertGithubHome.github.io/blog/2023/12/05/怎么验证公钥和私钥是一对/</id>
    <published>2023-12-05T15:20:43.000Z</published>
    <updated>2023-12-19T16:06:33.640Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>公钥和私钥都是一串字符，长得也没有什么关联性，那么当拿到一个公钥和一个私钥后怎么验证它们两个是一对呢？先说说为什么会有这个疑问，最近在对接一些SDK时经常需要做签名和验证签名的工作，双方要相互提供公钥来完成后续的身份验证，测试过程中生成了多个密钥对，当时就在想如果我用错了怎样才能发现呢？有没有什么方法可以验证公钥和私钥是一对呢？再寻找方法的过程中发现 <code>ssh-keygen</code> 和 <code>openssl</code> 生成的密钥对差别居然这么大，但后来又发现他们居然还有联系，所以本文将刚刚提到的问题都总结一下，方便日后查阅。</p><a id="more"></a><p>解决这个问题的思路我么可以从密钥使用的方式入手，私钥加密公钥解密可以验证身份，公钥加密私钥解密可以秘密传递数据，也就是说公钥和私钥是配合工作的，如果我们用私钥加密一个数据，公钥可以解开就说明他们两个是一对的的。</p><p>其实还有一个更简单的办法，公钥是可以从私钥中提取出来的，反之则不行。在公钥密码学中，私钥和公钥之间的关系是一种数学上的单向函数。这种函数的特性使得从私钥生成公钥是可行的，而从公钥还原私钥是非常困难的，这被称为一个单向函数或单向映射，因此被认为是安全的。</p><p>有了这个前提我们就可以这样做，从私钥中提取出公钥，然后和要比对的公钥进行比较，如果一致就说明原来的公钥和私钥是一对啦。</p><h1 id="ssh-keygen-和-openssl"><a href="#ssh-keygen-和-openssl" class="headerlink" title="ssh-keygen 和 openssl"></a>ssh-keygen 和 openssl</h1><p><code>ssh-keygen</code> 和 <code>openssl</code> 是两个不同的工具，它们分别用于生成和处理不同类型的密钥和证书。以下是它们的一些主要区别：</p><ol><li><p><strong>功能和用途：</strong></p><ul><li><code>ssh-keygen</code>：主要用于生成和管理SSH密钥对，包括RSA、DSA、ECDSA和Ed25519密钥。</li><li><code>openssl</code>：是一个通用的密码学工具，可以用于生成和管理多种密码学对象，包括SSL/TLS证书、密钥、摘要和数字签名等。</li></ul></li><li><p><strong>支持的算法：</strong></p><ul><li><code>ssh-keygen</code>：专注于SSH密钥生成，支持多种SSH密钥算法。</li><li><code>openssl</code>：支持广泛的密码学算法，包括RSA、DSA、ECDSA、Diffie-Hellman、AES、SHA等，用于生成和操作各种密码学对象。</li></ul></li><li><p><strong>密钥格式：</strong></p><ul><li><code>ssh-keygen</code>：生成的SSH密钥通常以OpenSSH格式存储。</li><li><code>openssl</code>：支持多种密钥格式，例如PEM、DER等，可以处理不同类型的密钥和证书。</li></ul></li><li><p><strong>具体应用场景：</strong></p><ul><li><code>ssh-keygen</code>：主要用于SSH连接，生成用于身份验证的密钥对。</li><li><code>openssl</code>：更广泛地用于TLS/SSL证书、数字签名、加密和其他与通用密码学相关的应用。</li></ul></li><li><p><strong>具体命令和用法：</strong></p><ul><li><p><code>ssh-keygen</code>：用于生成SSH密钥对的常见命令包括：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -b 2048 -f myid_rsa</span><br></pre></td></tr></table></figure></li><li><p><code>openssl</code>：用于生成RSA密钥对的常见命令包括：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">openssl genpkey -algorithm RSA -out private-key.pem</span><br><span class="line">openssl rsa -pubout -<span class="keyword">in</span> private-key.pem -out public-key.pem</span><br></pre></td></tr></table></figure></li></ul></li></ol><p>以上的ChatGPT提供的内容，还是对比的挺全面的，从 <code>openssl</code> 生成密钥对的过程可以看出，确实可以从私钥中提取出公钥。</p><p><code>ssh-keygen</code> 是我接触的最多的生成密钥对的命令，不管是github还是gitlab，或者一些其他的托管平台都会提到SSH Keys，所以每次我都会用 <code>ssh-keygen</code> 来生成，它是用于生成SSH连接密钥对最直接的选择，如果是想要使用更广泛的密码学操作，包括证书生成、签名和加密等，那么 <code>openssl</code> 提供了更大的灵活性。</p><h2 id="两种证书的内容对比"><a href="#两种证书的内容对比" class="headerlink" title="两种证书的内容对比"></a>两种证书的内容对比</h2><p>前面说了两种命令生成的证书、格式、算法和用途都有区别，我们来看看利用上面的命令生成的证书内容有什么不同，先看 <code>ssh-keygen</code> 生成的私钥 <code>myid_rsa</code> 和公钥 <code>myid_rsa.pub</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># demo @ demo-ThinkPad-X390 in ~/tmp/rsa [17:58:47]</span></span><br><span class="line">$ ssh-keygen -t rsa -b 2048 -f myid_rsa</span><br><span class="line">Generating public/private rsa key pair.</span><br><span class="line">Enter passphrase (empty <span class="keyword">for</span> no passphrase):</span><br><span class="line">Enter same passphrase again:</span><br><span class="line">Your identification has been saved <span class="keyword">in</span> myid_rsa</span><br><span class="line">Your public key has been saved <span class="keyword">in</span> myid_rsa.pub</span><br><span class="line">The key fingerprint is:</span><br><span class="line">SHA256:eLzG9lryO/AOdd05cDkixvBNCPFZRLRu0wp3bxZ7Vnk demo@demo-ThinkPad-X390</span><br><span class="line">The key<span class="string">'s randomart image is:</span></span><br><span class="line"><span class="string">+---[RSA 2048]----+</span></span><br><span class="line"><span class="string">|         +o =*   |</span></span><br><span class="line"><span class="string">|          =.= . .|</span></span><br><span class="line"><span class="string">|           B = + |</span></span><br><span class="line"><span class="string">|       o  . o.=.+|</span></span><br><span class="line"><span class="string">|      . S ...=.BE|</span></span><br><span class="line"><span class="string">|       o.o .+ + B|</span></span><br><span class="line"><span class="string">|        Bo.  . .*|</span></span><br><span class="line"><span class="string">|       o *o    +.|</span></span><br><span class="line"><span class="string">|        .o=o     |</span></span><br><span class="line"><span class="string">+----[SHA256]-----+</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># demo @ demo-ThinkPad-X390 in ~/tmp/rsa [19:22:03]</span></span><br><span class="line">$ cat myid_rsa</span><br><span class="line">-----BEGIN OPENSSH PRIVATE KEY-----</span><br><span class="line">b3BlbnNzaC1rZXktdjEAAAAABG5vbmUAAAAEbm9uZQAAAAAAAAABAAABFwAAAAdzc2gtcn</span><br><span class="line">NhAAAAAwEAAQAAAQEAr7gEjCdhA4at0tx0efpLunEOEGvK3ejJCh/dBwLfsvVJelwTeJjK</span><br><span class="line">zI2nFvYGkJgndhWLuvwy6+ODnvASeNvXSvZZzXvvXjTF4JP3TRbATayFvS9mZgzOnxh/rU</span><br><span class="line">z4P7ecLBfqZZkem+VBrMlv37yaIWf7co59dtrJJuAfZJFXyW//LQhNoEaqbZ/gvZls5pOX</span><br><span class="line">r2foMnYg2HV0ayPlvz8cmVF8LIOqaGOc28nMQakVwO+nZhbSv1bGprIGcy4czc7UOp/m+o</span><br><span class="line">t6mWJflpq3NBGiImyfaT2kxp1+pIdd6ISqoZqa9C2JzH7ZXVGjevbHuqup871yjUGapxDx</span><br><span class="line">lDk9HjdSLwAAA9AlxLUDJcS1AwAAAAdzc2gtcnNhAAABAQCvuASMJ2EDhq3S3HR5+ku6cQ</span><br><span class="line">4Qa8rd6MkKH90HAt+y9Ul6XBN4mMrMjacW9gaQmCd2FYu6/DLr44Oe8BJ429dK9lnNe+9e</span><br><span class="line">NMXgk/dNFsBNrIW9L2ZmDM6fGH+tTPg/t5wsF+plmR6b5UGsyW/fvJohZ/tyjn122skm4B</span><br><span class="line">9kkVfJb/8tCE2gRqptn+C9mWzmk5evZ+gydiDYdXRrI+W/PxyZUXwsg6poY5zbycxBqRXA</span><br><span class="line">76dmFtK/VsamsgZzLhzNztQ6n+b6i3qZYl+Wmrc0EaIibJ9pPaTGnX6kh13ohKqhmpr0LY</span><br><span class="line">nMftldUaN69se6q6nzvXKNQZqnEPGUOT0eN1IvAAAAAwEAAQAAAP8nH9HjYuE258XMLUnB</span><br><span class="line">3vj9ii6XeWiyACLDHlUYOouUTQkPNXEgaOS+psuNUTok97vRjvqNp5mu6/liahGy10AYcM</span><br><span class="line">GN/wpM73MfjdKCV455vPAKL4OdNTzML6g97eVYSol7R9foxy8JhwIYdsFyD4xB4+UYnKFS</span><br><span class="line">1WP0Q/K5caMaNnazPF0X7JDSenEwBwl1bDAN5OKwZNzSzUpR/96fl1DAgnG9yp1/634WGt</span><br><span class="line">IfjXLm13OSMrSHfwazNHoqAPkD0SQVJrm38ppvqArU0tBVfh/kvBkv7CCAE9mzhxusiKju</span><br><span class="line">B0c/jrsRDu45AJX5wuqIWcZdfppATJjK10S20MgN5dkAAACBALYym7mpDVQJ2gedSjv/Pv</span><br><span class="line">a+O/5b/20jawc3RFZdJAUWSGJTe9UqyHBHPlYj3/bHJVWIQ9S7s5AxpBtAEOsjeQf0VGFa</span><br><span class="line">FALQwcUghx5r1uM5sAL06CT/5t3Ze8lcJozNW7yjbVZKjJK13GTDMrnPYTfPOc+I/6N3R+</span><br><span class="line">SV2iKOwUQPAAAAgQDp9/2WvHOX2GKXan2BvMaexj6GYIQa8xEsqhtQGY9zxQ2d+9Z7YgDf</span><br><span class="line">XnNanxv8XJ61komeP9KmhS+2TCt0trj8sXtQobDsDGjFcDx0jjBobU6zKvO4htoZP3lb8w</span><br><span class="line">ZARgQoEANxqNOo8R61CsDQW4eM0ReAitKZ0GCcXbqNYCRTGwAAAIEAwEPdhAH4iH6V7IJn</span><br><span class="line">Qs3pgf9AG9UubDe9mAwVNIircWTFO2EFaBpwP7UKgpNmmZjoD2lWEcr2Zxv6x8ILBlJqea</span><br><span class="line">vCpGfLo0hwt2XZHgLRsTx8RmsbmYI2l8qnkMWyz5Lh3XAhNMZM4s9OvSJM6JPWYcedG5KY</span><br><span class="line">G1/zbarjwkq+Gn0AAAAVc2h6QHNoei1UaGlua1BhZC1YMzkwAQIDBAUG</span><br><span class="line">-----END OPENSSH PRIVATE KEY-----</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># demo @ demo-ThinkPad-X390 in ~/tmp/rsa [19:22:10]</span></span><br><span class="line">$ cat myid_rsa.pub</span><br><span class="line">ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQCvuASMJ2EDhq3S3HR5+ku6cQ4Qa8rd6MkKH90HAt+y9Ul6XBN4mMrMjacW9gaQmCd2FYu6/DLr44Oe8BJ429dK9lnNe+9eNMXgk/dNFsBNrIW9L2ZmDM6fGH+tTPg/t5wsF+plmR6b5UGsyW/fvJohZ/tyjn122skm4B9kkVfJb/8tCE2gRqptn+C9mWzmk5evZ+gydiDYdXRrI+W/PxyZUXwsg6poY5zbycxBqRXA76dmFtK/VsamsgZzLhzNztQ6n+b6i3qZYl+Wmrc0EaIibJ9pPaTGnX6kh13ohKqhmpr0LYnMftldUaN69se6q6nzvXKNQZqnEPGUOT0eN1Iv demo@demo-ThinkPad-X390</span><br></pre></td></tr></table></figure><p>接着看看 <code>openssl</code> 生成的私钥 <code>private-key.pem</code> 和公钥 <code>public-key.pem</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># demo @ demo-ThinkPad-X390 in ~/tmp/rsa [19:23:01]</span></span><br><span class="line">$ openssl genpkey -algorithm RSA -out private-key.pem</span><br><span class="line">......................................................................+++++</span><br><span class="line">..................+++++</span><br><span class="line"></span><br><span class="line"><span class="comment"># demo @ demo-ThinkPad-X390 in ~/tmp/rsa [19:25:04]</span></span><br><span class="line">$ openssl rsa -pubout -<span class="keyword">in</span> private-key.pem -out public-key.pem</span><br><span class="line">writing RSA key</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># demo @ demo-ThinkPad-X390 in ~/tmp/rsa [19:26:18]</span></span><br><span class="line">$ cat private-key.pem</span><br><span class="line">-----BEGIN PRIVATE KEY-----</span><br><span class="line">MIIEvwIBADANBgkqhkiG9w0BAQEFAASCBKkwggSlAgEAAoIBAQDjxEM9ypyLb0fT</span><br><span class="line">xk7Ujdvj7efUjbLhzAcbfHNRZqzqif1rlTS4jz+tIDZBX9/HJkDcoz1dIolp/53S</span><br><span class="line">CJtz+qBrkHMzsi6dcqd5jXUfT3Ts/FMTVsAKIkwafnw2Gbi2DGQx8WQ8Sn5+LlUP</span><br><span class="line">FSCJa+2MTc21taiMP7CtF7iG6jFeGna3xeRTWAjMMS2xk9Zk37KMz8weU4ShdQ9q</span><br><span class="line">mX7yuKHuZzUiWHmjbW/bi6abur3dfi/1jRSnFQF+r/gJoH1UXT4st/+fW425nWqO</span><br><span class="line">ohSV+xw61a09fjECfjVDkMXtwiPCbbGNjD8WjLbilOJK3uBx5e7GIN1jZjVBqlH9</span><br><span class="line">NqEk12HVAgMBAAECggEAIlcf8DwRGDDB+psGnaN5yMbA0lo+4y5Yz/sWg+pgHciK</span><br><span class="line">TeMkHMN0TUzzAS5MVgFdfCachONFJpckm1sy3OynrTANPnkZ8CEuQPRj+UGIloaA</span><br><span class="line">nATTVXPQV5pEbf+4yrHZlXIYs8JjifDAYFLGIhIEsce1QTVPYT3lDGPsLWM36ED6</span><br><span class="line">XVnvJYsr00wpLlYy4uWikt4Q8ruKDnWSS8xeE7pj0bBaqYd8Gz4jfrJ94IgNIROQ</span><br><span class="line">xnXb8aMG/o441ImrF6YXKn8jR/gjZXT1L4ZsD7fGTvLKBxxImBXL2eIoZ8usmTtX</span><br><span class="line">eLEfYaJlzyXOcnYKKVtMQxRI+4ANJWWnMDgM8NTBTQKBgQD0hboW//hXGVcng3Pu</span><br><span class="line">NfD7hUPHQKWWUHbchjRfxvxy/4itqGaWHtUrmc4PTXUxW71YaVA6qm2gvfV+jn83</span><br><span class="line">o5k009vVbXYVvztNQq9wC0Fj2OYwQkxHMgAY9JdhZr6ghuEZ0+hNd5Jea9K3w62C</span><br><span class="line">cY0mHqlvo55szhWmhuvzFtSUXwKBgQDudTFUjf7+qPsfYEX14udsKtfowrjepFLf</span><br><span class="line">nQAbxj16PxpRBSV7S77gdlW1shKEreIPbm083bhU3ypCRs7ktR0Wki/uoQGYekHr</span><br><span class="line">b8Nljh+rM9DxY83+HfLHAC/RjP8ZFrWJFgo6Whfr3jhlb8j3a4siLvqMj0d35BRv</span><br><span class="line">M+HtsEhWSwKBgQC7M746aZG5LP9akvsofkeWaHpxi366S7QUNPLX+MHBUP1U5j5T</span><br><span class="line">5BsTnFbzxDtapH+btlTj9SKlE4llcLbY4/khRqlhBsKG97bw+YLS5usTBDWG8Nrx</span><br><span class="line">DsigUnGq8jwzLdAcM+3/kPGQNEBIzBiEa2bCrmrNu5hIeKZ+rYDqxKnPRQKBgQCh</span><br><span class="line">MZuNOwfbAkPvq9bfJuml1zho4eiyqIZVHv6Jx/KbBrk1d7Mkq8l2VsgNsTiPdDPS</span><br><span class="line">lqVFdeQ7izg34UHOnRfywBOizjgT6OFS1BRUPETwKHDgHMWNOJV7LIcmspdnUFCb</span><br><span class="line">QMjdNTXifi/FclF537sH+pXoGpsHUqj1my7ozDe6DQKBgQDY9tJvXx5DRPVH2t60</span><br><span class="line">0rl1df3PogoAhwjvK+Q/Y5vLyrL470JxMNPtW546aWXRL6INTg+OvsUqLJXEMlxl</span><br><span class="line">HdHIe16orIGBrGcqHNGfkQPfddJVOo0eQCCk4jaLL9EP7+euA83vp6cP38rqgsL7</span><br><span class="line">0+gt34iMPCP9dEKaJyjZPv+vFQ==</span><br><span class="line">-----END PRIVATE KEY-----</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># demo @ demo-ThinkPad-X390 in ~/tmp/rsa [19:26:21]</span></span><br><span class="line">$ cat public-key.pem</span><br><span class="line">-----BEGIN PUBLIC KEY-----</span><br><span class="line">MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA48RDPcqci29H08ZO1I3b</span><br><span class="line">4+3n1I2y4cwHG3xzUWas6on9a5U0uI8/rSA2QV/fxyZA3KM9XSKJaf+d0gibc/qg</span><br><span class="line">a5BzM7IunXKneY11H0907PxTE1bACiJMGn58Nhm4tgxkMfFkPEp+fi5VDxUgiWvt</span><br><span class="line">jE3NtbWojD+wrRe4huoxXhp2t8XkU1gIzDEtsZPWZN+yjM/MHlOEoXUPapl+8rih</span><br><span class="line">7mc1Ilh5o21v24umm7q93X4v9Y0UpxUBfq/4CaB9VF0+LLf/n1uNuZ1qjqIUlfsc</span><br><span class="line">OtWtPX4xAn41Q5DF7cIjwm2xjYw/Foy24pTiSt7gceXuxiDdY2Y1QapR/TahJNdh</span><br><span class="line">1QIDAQAB</span><br><span class="line">-----END PUBLIC KEY-----</span><br></pre></td></tr></table></figure><h1 id="从私钥提取公钥"><a href="#从私钥提取公钥" class="headerlink" title="从私钥提取公钥"></a>从私钥提取公钥</h1><p>使用 <code>openssl</code> 命令从私钥提取公钥，上面已经展示过程了，它的公钥就是这样生成的</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl rsa -pubout -<span class="keyword">in</span> private-key.pem -out public-key.pem</span><br></pre></td></tr></table></figure><p>使用 <code>ssh-keygen</code> 命令从私钥提取公钥可以这样做</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -y -f myid_rsa &gt; compare_myid_rsa.pub</span><br></pre></td></tr></table></figure><p>结果文件 compare_myid_rsa.pub 和 myid_rsa.pub 的内容一模一样，所以从私钥提取公钥可以作为检验密钥是否匹配的方法</p><h1 id="OPENSSH和PEM两种密钥格式相互转化"><a href="#OPENSSH和PEM两种密钥格式相互转化" class="headerlink" title="OPENSSH和PEM两种密钥格式相互转化"></a>OPENSSH和PEM两种密钥格式相互转化</h1><p>之前说了<code>ssh-keygen</code> 和 <code>openssl</code>两个命令及生成的密钥区别，现在讲讲两种密钥的联系，OpenSSH 和 OpenSSL 使用的密钥对虽然有一些格式上的差异，但可以相互转换。OpenSSH 使用自己的私钥和公钥格式, 而 OpenSSL 通常使用 PEM 格式，可以通过下列命令转化</p><h2 id="OpenSSH-格式私钥转换成-OpenSSL-PEM-格式私钥"><a href="#OpenSSH-格式私钥转换成-OpenSSL-PEM-格式私钥" class="headerlink" title="OpenSSH 格式私钥转换成 OpenSSL PEM 格式私钥"></a>OpenSSH 格式私钥转换成 OpenSSL PEM 格式私钥</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -p -N <span class="string">""</span> -f myid_rsa -m PEM</span><br></pre></td></tr></table></figure><blockquote><p>$ file myid_rsa<br>myid_rsa: PEM RSA private key</p></blockquote><h2 id="OpenSSL-PEM-格式私钥转换成-OpenSSH-格式私钥"><a href="#OpenSSL-PEM-格式私钥转换成-OpenSSH-格式私钥" class="headerlink" title="OpenSSL PEM 格式私钥转换成 OpenSSH 格式私钥"></a>OpenSSL PEM 格式私钥转换成 OpenSSH 格式私钥</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -p -N <span class="string">""</span> -f myid_rsa</span><br></pre></td></tr></table></figure><blockquote><p>$ file myid_rsa<br>myid_rsa: OpenSSH private key</p></blockquote><h2 id="OpenSSH-格式公钥生成-OpenSSL-PEM-格式公钥"><a href="#OpenSSH-格式公钥生成-OpenSSL-PEM-格式公钥" class="headerlink" title="OpenSSH 格式公钥生成 OpenSSL PEM 格式公钥"></a>OpenSSH 格式公钥生成 OpenSSL PEM 格式公钥</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -e -m PEM -f myid_rsa.pub &gt; new-public-key.pem</span><br></pre></td></tr></table></figure><blockquote><p>$ file new-public-key.pem<br>new-public-key.pem: ASCII text</p></blockquote><h2 id="OpenSSL-PEM-格式公钥生成-OpenSSH-格式公钥"><a href="#OpenSSL-PEM-格式公钥生成-OpenSSH-格式公钥" class="headerlink" title="OpenSSL PEM 格式公钥生成 OpenSSH 格式公钥"></a>OpenSSL PEM 格式公钥生成 OpenSSH 格式公钥</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -i -m PKCS8 -f new-public-key.pem &gt; compare_myid_rsa.pub</span><br></pre></td></tr></table></figure><blockquote><p>$ file compare_myid_rsa.pub<br>compare_myid_rsa.pub: OpenSSH RSA public key</p></blockquote><h1 id="公钥和私钥的匹配使用"><a href="#公钥和私钥的匹配使用" class="headerlink" title="公钥和私钥的匹配使用"></a>公钥和私钥的匹配使用</h1><p>匹配使用公钥和私钥之前先准备一个测试文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"Hello World"</span> &gt; data.txt</span><br></pre></td></tr></table></figure><h2 id="加密和解密"><a href="#加密和解密" class="headerlink" title="加密和解密"></a>加密和解密</h2><p>使用公钥加密</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl rsautl -<span class="keyword">in</span> data.txt -out data_enc.txt -inkey public-key.pem -pubin -encrypt</span><br></pre></td></tr></table></figure><p>使用私钥解密</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl rsautl -<span class="keyword">in</span> data_enc.txt -out data_dec.txt -inkey private-key.pem -decrypt</span><br></pre></td></tr></table></figure><p>两个命令执行后都没有任何控制台输出，文件 <code>data_enc.txt</code> 中是加密后的内容，文件 <code>data_dec.txt</code> 是解密后的内容，成功解密后内容与 <code>data.txt</code> 文件内容一样</p><h2 id="签名和验证"><a href="#签名和验证" class="headerlink" title="签名和验证"></a>签名和验证</h2><p>使用私钥签名</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl dgst -sha256 -sign private-key.pem -out signature.bin data.txt</span><br></pre></td></tr></table></figure><p>使用公钥验证签名</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl dgst -sha256 -verify public-key.pem -signature signature.bin data.txt</span><br></pre></td></tr></table></figure><p>验证通过后，会在命令行输出 “Verified OK” 字样，若不通过则输出 “Verification Failure” 字样</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>验证公钥私钥是否匹配的最便捷的方法是通过私钥提取公钥来和原公钥进行对比</li><li>公钥加密私钥解密，私钥签名公钥验证签名，需要把公钥发给别人，私钥自己要保留好</li><li>公钥和私钥常用的有OpenSSH和PEM两种格式，这两种格式的密钥可以相互转化</li><li><code>ssh-keygen</code> 和 <code>openssl</code> 是两个不同的工具，前者用于管理SSH密钥更具体，后者使用范围更广更灵活</li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/134724042" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>事情一件件去办就好了，『没什么大不了的』，希望你长大后还可以经常乐观的说这句话，一副俾睨天下的姿态</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;公钥和私钥都是一串字符，长得也没有什么关联性，那么当拿到一个公钥和一个私钥后怎么验证它们两个是一对呢？先说说为什么会有这个疑问，最近在对接一些SDK时经常需要做签名和验证签名的工作，双方要相互提供公钥来完成后续的身份验证，测试过程中生成了多个密钥对，当时就在想如果我用错了怎样才能发现呢？有没有什么方法可以验证公钥和私钥是一对呢？再寻找方法的过程中发现 &lt;code&gt;ssh-keygen&lt;/code&gt; 和 &lt;code&gt;openssl&lt;/code&gt; 生成的密钥对差别居然这么大，但后来又发现他们居然还有联系，所以本文将刚刚提到的问题都总结一下，方便日后查阅。&lt;/p&gt;
    
    </summary>
    
      <category term="Network" scheme="http://AlbertGithubHome.github.io/blog/categories/Network/"/>
    
    
      <category term="Network" scheme="http://AlbertGithubHome.github.io/blog/tags/Network/"/>
    
      <category term="openssl" scheme="http://AlbertGithubHome.github.io/blog/tags/openssl/"/>
    
      <category term="ssh-keygen" scheme="http://AlbertGithubHome.github.io/blog/tags/ssh-keygen/"/>
    
      <category term="pem" scheme="http://AlbertGithubHome.github.io/blog/tags/pem/"/>
    
      <category term="公钥" scheme="http://AlbertGithubHome.github.io/blog/tags/%E5%85%AC%E9%92%A5/"/>
    
      <category term="私钥" scheme="http://AlbertGithubHome.github.io/blog/tags/%E7%A7%81%E9%92%A5/"/>
    
  </entry>
  
</feed>
