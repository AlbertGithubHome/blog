<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Albert World</title>
  <icon>https://www.gravatar.com/avatar/8ccc6291d5bfd34e7aaf601c4ebec7e1</icon>
  
  <link href="/blog/atom.xml" rel="self"/>
  
  <link href="http://AlbertGithubHome.github.io/blog/"/>
  <updated>2020-12-27T12:33:27.960Z</updated>
  <id>http://AlbertGithubHome.github.io/blog/</id>
  
  <author>
    <name>Albert Shi</name>
    <email>347070901@qq.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2020年终总结！新的起航，新的征程</title>
    <link href="http://AlbertGithubHome.github.io/blog/2020/12/27/2020%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93%EF%BC%81%E6%96%B0%E7%9A%84%E8%B5%B7%E8%88%AA%EF%BC%8C%E6%96%B0%E7%9A%84%E5%BE%81%E7%A8%8B/"/>
    <id>http://AlbertGithubHome.github.io/blog/2020/12/27/2020年终总结！新的起航，新的征程/</id>
    <published>2020-12-27T12:25:12.000Z</published>
    <updated>2020-12-27T12:33:27.960Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>奇变偶不变，符号看象限，真正的知识就是这么朴实无华~</p></blockquote><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>从2019年开始意识到年终总结的意义，通过反思自己的得失进而确定今后的方向，既然去年开了头，今年也不能中断，依旧写写每天的流水账，细数最近一年发生的故事。</p><a id="more"></a><p>今年最直观的、印象最深的感受就是时间不够用，一首《时间都去哪了》旋律时常出现在脑海中，对比之前长久不变的工作环境，今年确实紧张了许多，习惯了原来的安逸，对各种可能发生的问题轻车熟路的就能解决掉，但来到新环境，一切变得不是那么轻松了。</p><h1 id="回顾2020"><a href="#回顾2020" class="headerlink" title="回顾2020"></a>回顾2020</h1><p>毕竟到了年终时刻，之前的flag可不能忘，依旧是从工作、学习、生活三个方面来回忆一下去年flag的完成情况。</p><h2 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h2><blockquote><p>2020 flag：新的一年不能再碌碌无为，真的需要去闯一闯了</p><p>完成度：95%</p></blockquote><p>年初如愿的换了一份新工作，之前的公司呆的时间太长了，工作内容单一，熟悉了安逸的环境，虽然每天也在学习，但是进步缓慢，在2019年末开始寻找新的发展环境，在2020初就成功找到了新的工作机会，提前完成flag内容。</p><p>与老东家分手过程可以说不太愉快，给不了梦想，撑不起现实，一味的拖着可不是解决问题的办法，不过事情已经过去，不想再提，毕竟也为之奋斗过，近2000个日日夜夜，梦开始的地方，也是认清现实的地方。</p><p>离开原公司来到新公司算是无缝衔接吧，中间在家只待了3天，如果能早点意识到离职流程这么狗血，我真应该在家躺一个月，不过新公司的入职流程还真是暖心，提前先网上入职，帮我把社保问题解决了，感谢流程中出现的每一个人。</p><p>新的工作内容刚开始肯定要吃力一些，首先是熟悉开发环境，大体和原来相同，不过复杂的申请制度较原来规范了许多，同时也麻烦了许多，版本控制是一个重要的改变，之前主要使用SVN，如今换成了 Git + SVN，以前经常使用的 git 三部曲——add、commit、push 已经不够用了，随着不断的使用学习，渐渐熟悉了 <code>checkout</code>、<code>merge</code>、<code>rebase</code>、<code>cherry-pick</code> <code>reset</code> 等等子命令，还是那句话多用才能学会，如果只停留在纸面上，只是眼睛学会了，闭上眼睛就忘记了。</p><p>选择这份新的工作也是想拓宽自己的知识面，之前一直在做分区分服的游戏，想学习一下分布式游戏的开发和一些需要需要注意的问题，所以说这份工作是用来补充我这方面知识短板的，从学习了一年的结果来看，确实达到了这个目的，虽然现在的规模还没有那么大，有些逻辑来不太完善，但是这已经给我做出了示范，在今后的一段时间内，将沿着这条路不断的前行，去探索自己未知的领域。</p><p>新的工作认识新的伙伴，大家相处起来还是很友好的，一年来的工作算是中规中矩，不过年底这俩月有点滑铁卢的味道，接连在同一个位置摔倒几次，还是老大给背了锅，内心愧疚不已，无以为报，愿以更饱满的热情投入工作中，实践当初并肩战斗的诺言，得一伙伴不易，愿共同进步。</p><p>今年的工作强度明显高于以往，倒不是工作时间长了，而是在新环境中，长时间聚精会神的盯在一件事上本来就很累，头发掉的明显比之前多了，眼睛的视力也下降的厉害，这两点要注意一下了，可以调整一下工作的节奏，注意劳逸结合，我可不想“聪明绝顶”。</p><p><img src="https://cdn.jsdelivr.net/gh/albertgithubhome/cdn/img/summary/pressure.png" alt="pressure"></p><h2 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h2><blockquote><p>2020 flag：看两本有关分布式知识的图书，多看一些开源项目的代码</p><p>完成度：85%</p></blockquote><p>有关分布式架构的书今年只看了一本，另外基本都是和育儿知识相关，他们分别是：</p><ul><li>从零开始学架构 ——照着做，你也能称为架构师</li><li>你就是孩子最好的玩具</li><li>正面管教</li><li>小狗钱钱2</li></ul><p>今年的1本技术书籍对比去年的7本少了很多，一方面换了新工作后需要花很多时间来熟悉新的业务逻辑，用来读书的时间被侵占了一部分，另一方面宝宝一天天长大，需要花些时间去陪伴她，虽然技术书读的少了，可是故事书我可没少读，一年读了好几十本：</p><p><img src="https://cdn.jsdelivr.net/gh/albertgithubhome/cdn/img/summary/story.png" alt="story"></p><p>这些故事书中描述的故事小时候没觉得有什么不妥，不过以现在成年人的身份来看，有些故事太离奇了，比如大灰狼和七只小羊的故事，山羊妈妈居然剪开狼的肚皮救出了被吃掉的六只小山羊，然后在狼的肚子里装满石头缝上了，整个过程大灰狼都没有醒，我感觉山羊妈妈可能是个麻醉科的护士。</p><p>虽然故事内容离奇，但是并不妨碍小娃娃听到津津有味，小孩子的世界还真是单纯，有故事听就老老实实的等着，而我化身为一个播报员，一遍一遍的重复着书中的故事。</p><p>博客总结今年也没有丢，一共写了45篇，比去年还要多几篇，总体来看类别很多，总结的内容并不难懂，写到博客中主要是为了方便日后的查找，这一年的总结绝大部分都是晚上和周末花时间写的，只有尝试过才明白，想写好一篇总结需要花费很多很多时间，今年的成长可以对比两年数据来看一下。</p><p><img src="https://cdn.jsdelivr.net/gh/albertgithubhome/cdn/img/20191231csdn.png" alt="20191231csdn"><br><img src="https://cdn.jsdelivr.net/gh/albertgithubhome/cdn/img/summary/csdn.png" alt="csdn"></p><p>C++11的使用在这一年里变得更加熟练，之前的项目中无法使用C++11的特性，所以很多知识都是自己额外花时间来测试学习，来到新项目可以参考已有的代码，进一步巩固C++11的使用，知识还是越用掌握的越好。</p><p>语言方面还有Python今年用的比较多，得益于工作中的多次锻炼，一些常用的函数，类型可以很熟练的写出来了，虽然没有用来写过什么大的软件，但是也在不断尝试着使代码更规范，比如使用class、装饰器、继承、记录运行日志等等。</p><p>Go语言今年算是简单入门吧，之前只能算是听说过，今年快速的浏览了一遍Go语言的语法，编写了一些测试程序，但是对于Go语言的条条框框还是不太习惯，需要慢慢适应下。</p><p>刷题今年一直在坚持着，之前使用的国际账号一时找不到了，今年新注册了国内版LeetCode账号，本着刷简单冲中等的态度，一直在默默的洗刷刷，不过今年参加了几次竞赛，一直是两题选手，只有一次题比较简单全答出来了，当时还是很开心的，继续加油吧。</p><p><img src="https://cdn.jsdelivr.net/gh/albertgithubhome/cdn/img/summary/leetcode.png" alt="leetcode"></p><p>阅读开源项目源码方面，今年也有了很大的进步，在新项目中接触了好几个之前没有使用过的开源库，虽然没有完全整明白，但最起码开阔了眼界，比如 <code>easyloging++</code>、<code>nolhmann json</code>库等等。</p><h2 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h2><blockquote><p>2020 flag：尽最大可能陪陪家人、投资达到2019的水平</p><p>完成度：55%</p></blockquote><p>多陪陪家人这一项今年应该算完成了，因为疫情今年也没有出去疯，就是出门买买菜，其他的闲暇时间都和家人在一起，天气好的时候去附近的公园逛逛，对比2019年，每天晚上回家的时间晚了一点，但是多了每周多了一整天可以和家人一起度过。</p><p>现在每天还是很充实的，早上起来妈妈已经做好早饭，赶紧洗漱和家人一起吃个早饭，然后和宝宝告别去上班。晚上回来大多数情况宝宝已经睡了，不过有时候也能挺到我回家，和我玩一会再睡。周末陪宝宝出去玩，透透新鲜空气，等宝宝睡觉的时候对近期所学的知识做一个总结，基本上周末的时间陪娃、总结55开吧。</p><p>这个flag完成度不高主要是投资理财这块今天基本上是停滞了，未达到2019年水平，每天除了工作就是学习，账户情况没怎么看，整个一个过山车行情，所以基本上处于不赔不赚的情况。</p><p><img src="https://cdn.jsdelivr.net/gh/albertgithubhome/cdn/img/summary/stock.png" alt="stock"></p><p>目前的生活状况就是每天都相似，但确实很满足，早上起床一家人吃早饭，和宝宝告别后送媳妇上班，然后自己骑个自行车来公司上班，努力完成一天的工作再骑个小车回家，如果宝宝没睡还可以陪她玩一会儿，等宝宝睡着开始一天的总结，温暖而又充实。</p><p>2020年初养了一年的栀子花开花了，正好在我过年回老家的时候开的花，之前我好好浇水通风的时候它却连个花骨朵都没有，好像再告诉我只要我不管它就能好好开花，可是在10月份的时候枯死了。还有一盆文竹在夏天涨势良好，修剪了几次，但没有熬过寒冷的冬天，在11月份左右干枯了。</p><p>在上两盆花相继离开之后，我赶紧又补充了新的生机，一盆栀子花和一盆茉莉花，目前涨势良好，茉莉花已经开花了，希望它俩在新的一年了花香不断。</p><p><img src="https://cdn.jsdelivr.net/gh/albertgithubhome/cdn/img/summary/flower.png" alt="flower"></p><h1 id="展望2021"><a href="#展望2021" class="headerlink" title="展望2021"></a>展望2021</h1><h2 id="工作-1"><a href="#工作-1" class="headerlink" title="工作"></a>工作</h2><ul><li>脚踏实地做好本职工作</li><li>额外挤出时间去尝试技术提升（优化、解决痛点）</li><li>在熟悉业务的同时更多参与设计的工作，拓宽自己的认知范围</li></ul><h2 id="学习-1"><a href="#学习-1" class="headerlink" title="学习"></a>学习</h2><ul><li>博客总结继续，基本保持在1周一篇，可以适当偷懒，一年懒10次可以产出40篇</li><li>开源代码还是要继续学习，libevent需要详细看一下，今年的出镜率太高</li><li>读2本技术类书籍，可以是开阔眼界的，也可以是现有技能提升的</li><li>读2本经济学、金融理财相关的书籍</li></ul><h2 id="生活-1"><a href="#生活-1" class="headerlink" title="生活"></a>生活</h2><ul><li>陪娃娃，陪家人，工作内容适应后可以多拿出一点时间和家人在一起（需要比2020多一些）</li><li>投资理财还是要多花一点时间研究下，目标7%（靠工资是不可能财富自由的，必须开源才行）</li><li>注重身体的保养，身体是本钱，可不能把身体搞垮了，愿丢掉体检时的小毛病~</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>2020年在工作上是一个新的开始，同时也面临着新的挑战</li><li>2020年的flag完成度大概70%，大部分愿望已经实现，未实现部分还需努力</li><li>2021年已经悄然开始，新的flag已经在路上，为了新的目标加油努力吧</li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/111148573" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>人生旅途中运气与实力都很重要，但是强大的实力可以帮助你提升运气，减少不确定性（记一次事故后提心吊胆的等待），比如买一注彩票中一千万很难，但是如果你的实力可以强大到买下大部分甚至是所有的组合，那么要中一千万只需要等到开奖就可以了~</p><p>2020-12-27 00:32:07</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;奇变偶不变，符号看象限，真正的知识就是这么朴实无华~&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;从2019年开始意识到年终总结的意义，通过反思自己的得失进而确定今后的方向，既然去年开了头，今年也不能中断，依旧写写每天的流水账，细数最近一年发生的故事。&lt;/p&gt;
    
    </summary>
    
      <category term="Thinking" scheme="http://AlbertGithubHome.github.io/blog/categories/Thinking/"/>
    
    
      <category term="总结" scheme="http://AlbertGithubHome.github.io/blog/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="工作" scheme="http://AlbertGithubHome.github.io/blog/tags/%E5%B7%A5%E4%BD%9C/"/>
    
      <category term="学习" scheme="http://AlbertGithubHome.github.io/blog/tags/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="生活" scheme="http://AlbertGithubHome.github.io/blog/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>system_clock::now()和time()时间函数混用带来的踩坑经历</title>
    <link href="http://AlbertGithubHome.github.io/blog/2020/12/13/%E6%97%B6system-clock-now-%E5%92%8Ctime-%E6%97%B6%E9%97%B4%E5%87%BD%E6%95%B0%E6%B7%B7%E7%94%A8%E5%B8%A6%E6%9D%A5%E7%9A%84%E8%B8%A9%E5%9D%91%E7%BB%8F%E5%8E%86/"/>
    <id>http://AlbertGithubHome.github.io/blog/2020/12/13/时system-clock-now-和time-时间函数混用带来的踩坑经历/</id>
    <published>2020-12-13T15:16:17.000Z</published>
    <updated>2020-12-13T16:31:38.605Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>时间是一个可怕的东西，听说能用来杀猪。在编程世界中，时间也控制着一个维度，常常伴随着程序运行而流逝，有时也会影响着程序的运行的逻辑，所以在程序中处理时间时还是要仔细一些，最近连续踩坑，总结一下给自己提个醒，有些逻辑还是需要抱着怀疑的态度去看待。</p><h1 id="时间函数混用"><a href="#时间函数混用" class="headerlink" title="时间函数混用"></a>时间函数混用</h1><p>我们在写一个小程序时基本不会去混用时间函数，比如只用 <code>time(NULL)</code> 去控制时间，或者只使用 <code>chrono::system_clock::now()</code> 来记录时间消耗，关于 <code>chrono</code> 的用法，之前简单总结过，可传送至 <a href="https://blog.csdn.net/albertsh/article/details/105468687" target="_blank" rel="noopener">C++11中的时间库std::chrono</a>。</p><p>但是当程序变得复杂起来，这个时间函数混用的高压线还是有可能触碰到的，当程序逻辑对时间要求越发精确时，混用所带来的后果将越发严重。在此记录一个结果：连续调用 <code>time(NULL)</code> 和 <code>chrono::system_clock::now()</code> 两个函数得到的时间戳可能是不同的。</p><p>可能你会说，函数是先后调用的，肯定是不同的，后面的函数调用时的时间戳要比前面的大，但事实却是两个函数所取得的时间戳大小不确定，可能是第一个函数的时间戳比较大，也可能是第二个时间戳更大一些。</p><h1 id="测试的例子"><a href="#测试的例子" class="headerlink" title="测试的例子"></a>测试的例子</h1><p>下面展示一段代码，先后调用两个时间函数，打印所获得的时间戳，可以看看有什么特点：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int64_t</span> t1, t2;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        t1 = chrono::duration_cast&lt;chrono::milliseconds&gt;(chrono::system_clock::now().time_since_epoch()).count();</span><br><span class="line">        t2 = time(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (t1/<span class="number">1000</span> != t2) <span class="built_in">cout</span> &lt;&lt; t1 &lt;&lt; <span class="string">" "</span> &lt;&lt; t2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译运行结果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:testtime$ g++ testtime.cpp -std=c++11</span><br><span class="line">albert@home-pc:testtime$ ./a.out</span><br><span class="line">1607779917993 1607779918</span><br><span class="line">1607779957999 1607779958</span><br><span class="line">1607780080001 1607780079</span><br><span class="line">1607780103001 1607780102</span><br><span class="line">1607780150001 1607780149</span><br><span class="line">1607780202001 1607780201</span><br><span class="line">1607780327999 1607780328</span><br><span class="line">1607780440001 1607780439</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>运行之后很快就出现了一些不一致，对比可以发现，两个时间戳一个是毫秒，一个是秒，同时把单位转化成秒来比较时，两者大小不定，从仅有的这几行结果来看，最大的误差是7毫秒。</p><h1 id="再加一个时间函数"><a href="#再加一个时间函数" class="headerlink" title="再加一个时间函数"></a>再加一个时间函数</h1><p>除了上面提到的两个函数，还有一个 <code>gettimeofday()</code> 函数也是在获取时间时常常使用的，把它也放到测试函数中对比一下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int64_t</span> t1, t2, t = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>;</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        t1 = chrono::duration_cast&lt;chrono::milliseconds&gt;(chrono::system_clock::now().time_since_epoch()).count();</span><br><span class="line">        t2 = time(<span class="number">0</span>);</span><br><span class="line">        gettimeofday(&amp;tv, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (t1/<span class="number">1000</span> != t2 || t2 != tv.tv_sec)</span><br><span class="line">            <span class="keyword">if</span> (t != t1) <span class="built_in">cout</span> &lt;&lt; t1 &lt;&lt; <span class="string">" "</span> &lt;&lt; t2 &lt;&lt; <span class="string">" "</span> &lt;&lt; tv.tv_sec &lt;&lt; <span class="string">","</span> &lt;&lt; tv.tv_usec &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">        t = t1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行后查看结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">albert@DESKTOP-6746UC3:/mnt/d/data/cpp/testtime$ g++ testtime.cpp --std=c++11</span><br><span class="line">albert@DESKTOP-6746UC3:/mnt/d/data/cpp/testtime$ ./a.out</span><br><span class="line">1607876993000 1607876992 1607876993,2</span><br><span class="line">1607876994000 1607876993 1607876994,3</span><br><span class="line">1607876995000 1607876994 1607876995,3</span><br><span class="line">1607876996000 1607876995 1607876996,2</span><br><span class="line">1607876997000 1607876996 1607876997,1</span><br><span class="line">1607876998000 1607876997 1607876998,2</span><br><span class="line">1607876999000 1607876998 1607876999,2</span><br><span class="line">1607877000000 1607876999 1607877000,3</span><br><span class="line">1607877001000 1607877000 1607877001,1</span><br><span class="line">1607877002000 1607877001 1607877002,3</span><br><span class="line">1607877003000 1607877002 1607877003,2</span><br><span class="line">1607877004000 1607877003 1607877004,2</span><br><span class="line">1607877005000 1607877004 1607877005,1</span><br><span class="line">1607877006000 1607877005 1607877006,3</span><br><span class="line">1607877007000 1607877006 1607877007,2</span><br><span class="line">1607877008000 1607877007 1607877008,11</span><br><span class="line">1607877009000 1607877008 1607877009,3</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>真是各不相同，这要是在发射火箭时混用两个时间函数，那估计探月卫星就凉凉了……</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>常用来获取时间戳的函数有 <code>time()</code>、<code>chrono::system_clock::now()</code> 和 <code>gettimeofday()</code></li><li>时间函数不要混用，否则会给精密计算带来巨大的麻烦，造成计算结果的不可控</li><li>测试发现 <code>chrono::system_clock::now()</code> 和 <code>gettimeofday()</code> 时间非常接近，有微秒级别的误差，但也不建议混用</li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/109976348" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>有的人走了只留下一撮灰烬，有的人离开却千古留名，但在时间长河中就是那么一瞬，意义何在，有差吗？</p><p>2020-12-14 00:12:01</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;时间是一个可怕的东西，听说能用来杀猪。在编程世界中，时间也控制着一个维度，常常伴随着程序运行而流逝，有时也会影响着程序的运行的逻辑，所以在程
      
    
    </summary>
    
    
      <category term="C++" scheme="http://AlbertGithubHome.github.io/blog/tags/C/"/>
    
      <category term="时间" scheme="http://AlbertGithubHome.github.io/blog/tags/%E6%97%B6%E9%97%B4/"/>
    
      <category term="time" scheme="http://AlbertGithubHome.github.io/blog/tags/time/"/>
    
      <category term="system_clock" scheme="http://AlbertGithubHome.github.io/blog/tags/system-clock/"/>
    
  </entry>
  
  <entry>
    <title>C/C++中有符号数隐式类型转换成无符号数需注意的问题</title>
    <link href="http://AlbertGithubHome.github.io/blog/2020/12/07/C-C-%E4%B8%AD%E6%9C%89%E7%AC%A6%E5%8F%B7%E6%95%B0%E9%9A%90%E5%BC%8F%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E6%88%90%E6%97%A0%E7%AC%A6%E5%8F%B7%E6%95%B0%E9%9C%80%E6%B3%A8%E6%84%8F%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://AlbertGithubHome.github.io/blog/2020/12/07/C-C-中有符号数隐式类型转换成无符号数需注意的问题/</id>
    <published>2020-12-07T15:11:16.000Z</published>
    <updated>2020-12-20T15:20:19.009Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>隐式类型转换转换是一个挺基础的概念，即使对于初学者来说都不会陌生，一般情况下是指数据类型的转换是由编译系统自动进行的，不需要人工干预的类型转换方式。与之相对的是强制类型转换，在进行转换时必须使用强制类型转换运算符进行转换，这种也被称为显式转换。</p><h1 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h1><h2 id="隐式转换"><a href="#隐式转换" class="headerlink" title="隐式转换"></a>隐式转换</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">short</span> sn = <span class="number">999</span>;</span><br><span class="line"><span class="keyword">int</span> n = sn;</span><br></pre></td></tr></table></figure><h2 id="显示转换"><a href="#显示转换" class="headerlink" title="显示转换"></a>显示转换</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> f = <span class="number">110.741f</span>;</span><br><span class="line"><span class="keyword">int</span> n = (<span class="keyword">int</span>)f;</span><br></pre></td></tr></table></figure><p>这两种转换方式平时经常用到，不管是函数传参时进行转换，还是数学计算时进行强转，一直也没有发现有什么问题，直到昨天遇到了一个有符号数隐式转换成无符号数时，才发现这里也是一个知识盲点，当时脑瓜儿嗡嗡的，怎么连隐式类型转换也这么陌生了呢？</p><p>其实隐式类型转换一般发生在小类型转换成大类型时，有个常用的关系链 <code>char -&gt; short -&gt; int -&gt; long -&gt; float -&gt; double</code>，当关系链条中出现无符号数字时，情况有些难以理解了（实际上是有符号数字的锅）。</p><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>看一下这几行代码，如果你能准确说出程序的输出值，那么你已经掌握了这个知识点，后面的内容可以不用看了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c = <span class="number">128</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> n = c;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码的输出值是 <code>4294967168</code>，发生了啥？也就是说老板给你发工资时，本来想发128块，但是发工资的函数参数是 <code>unsigned int</code> 类型的，结果就给你发了 4294967168，一下就实现了40多个小目标。</p><h1 id="查找原因"><a href="#查找原因" class="headerlink" title="查找原因"></a>查找原因</h1><p>针对上面的代码我们改写一下，把变量 c 换成无符号类型：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> c = <span class="number">128</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> n = c;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这次的输出值变成了 <code>128</code>, 符合我们的预期，回过头来再看看刚才出错的代码，区别就是变量c是否有符号，结果差了好几十亿。</p><p>这里导致结果差异的原因实际上是符号位引起的，如果是无符号数字，从小类型到大类型隐式类型转换的结果数字都不会变，但是如果是有符号的数字，在转换成大类型数字的时候就要考虑符号位了，就以第一段代码为例来解释这个现象。</p><p><code>char c = 128;</code> 这一句实际上已经超出了变量 c 的范围，因为变量c是有符号数字，所以它的范围是-128~127，这里赋值成128，实际在内存中的bit排列是 <code>10000000</code>，而有符号数的第一位bit表示正负号，这里是1表示这是一个负数，计算机存储负数是以补码的形式存储的，那么把这个数据按位取反再加1，得到 <code>1000000</code> 还是原来的数字，好神奇哦！</p><p>不过这里就可以计算出 c 实际上代表-128，那么它在隐式类型转换成更大的有符号数字时，需要保证值不变，一个int的-128怎么表示呢？根据补码的定义应该是<code>11111111 11111111 11111111 10000000</code>，这个数字再转换成 <code>unsigned int</code> 就是前面提到的 4294967168 啦。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>有符号数字在转换成范围更大的无符号数字时需要注意转换所得数值是否正确，失之毫厘差之千里。</li><li>总结一个规律，有符号的整形数字在进行隐式类型转换时实际上是在数字的二进制表示前面补充符号位。</li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/110357193" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>一个人不能做完所有的事情，但是所有人都可以做一些事情，怕什么真理无穷，进一寸有进有一寸的欢喜~</p><p>2020-12-8 00:04:05</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;隐式类型转换转换是一个挺基础的概念，即使对于初学者来说都不会陌生，一般情况下是指数据类型的转换是由编译系统自动进行的，不需要人工干预的类型转
      
    
    </summary>
    
      <category term="C/C++" scheme="http://AlbertGithubHome.github.io/blog/categories/C-C/"/>
    
    
      <category term="C/C++" scheme="http://AlbertGithubHome.github.io/blog/tags/C-C/"/>
    
      <category term="符号" scheme="http://AlbertGithubHome.github.io/blog/tags/%E7%AC%A6%E5%8F%B7/"/>
    
      <category term="隐式类型" scheme="http://AlbertGithubHome.github.io/blog/tags/%E9%9A%90%E5%BC%8F%E7%B1%BB%E5%9E%8B/"/>
    
      <category term="转换" scheme="http://AlbertGithubHome.github.io/blog/tags/%E8%BD%AC%E6%8D%A2/"/>
    
  </entry>
  
  <entry>
    <title>简单聊聊01世界中编码和解码这对磨人的小妖儿</title>
    <link href="http://AlbertGithubHome.github.io/blog/2020/11/28/%E7%AE%80%E5%8D%95%E8%81%8A%E8%81%8A01%E4%B8%96%E7%95%8C%E4%B8%AD%E7%BC%96%E7%A0%81%E5%92%8C%E8%A7%A3%E7%A0%81%E8%BF%99%E5%AF%B9%E7%A3%A8%E4%BA%BA%E7%9A%84%E5%B0%8F%E5%A6%96%E5%84%BF/"/>
    <id>http://AlbertGithubHome.github.io/blog/2020/11/28/简单聊聊01世界中编码和解码这对磨人的小妖儿/</id>
    <published>2020-11-28T11:28:30.000Z</published>
    <updated>2020-11-29T15:09:39.383Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在程序员生活的01世界中有两大Boss级难题，分别是缓存失效和命名问题，对比这两大难题来说，编码和解码只能算是小妖儿了，只不过这两个小妖儿出镜率很高，有时确实很磨人的，得多花些时间捋顺一下。</p><p>编码问题不仅仅出现在计算机中，广义的说，编码问题涉及到人类社会的方方面面，比如古人规定指定长度是一寸，然后规定十寸为一尺，其实就是当时人们对长度的一种编码，但是由于每个地方的编码不统一，导致人们在交流的时候出现了很多问题，直到秦始皇统一了文字、度量衡，相当于统一了描述当时社会的编码，使得知识和文明得以快速传播。</p><h1 id="计算机中的编码"><a href="#计算机中的编码" class="headerlink" title="计算机中的编码"></a>计算机中的编码</h1><p>今天想说的编码和解码特指计算中使用的编码和解码，通俗点说：编码是给计算机看的，解码是为了让人能看懂的。可能大家对这句话还不太理解，不过没关系，这个说法本身不太严谨，也可以举出一些反例，但是大部分情况下确实是这样的。</p><p>为什么要编码，想想谍战片里近代社会中的发电报过程，滴答、滴滴答、滴滴滴答答就这个样子，怎么来表达“敌人发动进攻了”，这时候就用到了编码，提前约定好“滴答”代表“敌”，“滴滴答”代表“人”，这样在收到“滴答、滴滴答”你就知道了“敌人”这个信息，那个密码本记录的内容和规则其实就是对所有电传信息的一种编码。</p><p>计算机中的编码也是一样的，从我们开始接触到计算机的时候就听说过计算机只认识0和1，虽然现代计算机技术发展迅速，但是计算机只认识0和1这一点一直未变，所以你想让他看懂你的信息，保存你的数据，就要把这些信息和数据编码成0和1，计算机才能进行处理和存储。</p><p>所以计算机中为什么要对数据进行编码，这里可以给一个狭义的理解：计算机编码是为了让数据便于传输、存储和处理。</p><p>那有为什么要进行解码呢？其实就是为了人能看懂，给你一串二进制 <code>01010111100011111111...</code>，相信你即使有最强大脑也不能迅速把所有数据解开，这可能是一篇优美的散文、一幅美丽的图画，或者是一部励志的电影，这一切都需要解码后才能知道。</p><p>本来想画一幅“编码”和“解码”这两个小妖的画像，但是作为灵魂画手的我还没构思好，此处留空，后面补充。。。</p><hr><p>补上了&gt;&gt;</p><p><img src="https://img-blog.csdnimg.cn/20201129230755158.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9hbGJlcnRnaXRodWJob21lLmdpdGh1Yi5pby9ibG9nL2Fib3V0,size_12,color_FFFFFF,t_70#pic_center" alt="encoding"></p><h1 id="初识编码问题"><a href="#初识编码问题" class="headerlink" title="初识编码问题"></a>初识编码问题</h1><p>自从接触计算机就开始接触编码问题，比如你抄同学发来的作业文档，打开后却发现是一堆乱码，那时仅仅知道是编码错了，但是不知道怎么解决，或者直接让同学再发一份算了，后来在工作中需要做游戏多语言版本时才真正开始处理编码问题。</p><p>解决第一个编码问题大概是14年，当时做上线游戏的多语言版本、配置文件中的中文保存为 <code>ANSI</code> 编码，相同的配置文件放到日韩的系统上居然变成了其他的含义，查询解决方案决定使用 <code>UTF-8</code> 编码来保存配置文件，所以当时利用工具将所有的配置文件转换成了UTF-8编码，也是那个时候第一次接触到了Python，转换之后将其中的中文翻译成日韩的语言，从此知道了 <code>UTF-8</code> 这个编码方式，也清楚了在中日韩、越南、缅甸这个圈做产品，千万要远离 <code>ANSI</code> 编码。</p><p>其实 <code>ANSI</code> 并不是某一种特定的字符编码，而是一个编码集合，在不同的系统中，可以表示不同的编码，比如英文系统中的 <code>ASCII</code>编码，简体中文系统中的 <code>GBK</code>编码，韩文系统中 <code>EUC-KR</code> 编码等等</p><h2 id="编码变迁小八卦"><a href="#编码变迁小八卦" class="headerlink" title="编码变迁小八卦"></a>编码变迁小八卦</h2><p>计算机是美国人发明用于科学计算的，所以他们也是第一批考虑编码的，而英文只有26个字母，所以他们发明了ASCII码，只使用了0-127这128个空间就表示了所有可能用的字符，但后来计算机技术飞速发展，已经不仅仅用于科学计算，已经融入到社会的方方面面，并且迅速在全球流行。</p><p>随着计算机火遍全球，其它国家发现自己国家经常使用的字符，在 ASCII 码中找不到啊，于是就有人想啊，ASCII 码中的一个字节中不是才用了一半吗，我们使用这个最高位来扩展把，于是很多国家就开始用最高位来扩展这个 ASCII 编码以便能够表示自己国家的一些字符，但是对于我博大精深的中国文化来说，这一个字节远远不够啊，我们的汉字那可就有好几万个，你就给我一个字节，我肯定不干。</p><p>既然一个字节搞不定，那我们就用两个字节好了，我们规定一个小于等于127的字符的意义与原来相同，此处为了兼容ASCII码，但两个大于127的字符连在一起时，就表示一个汉字，前一个字节从0xA1用到0xF7，后面一个字节从0xA1到0xFE，我们将常用的6000多汉字在这个范围内定义代码点，并将这种编码方式称为 <code>GB2312</code>。</p><p>在 GB2312 这种编码中我们考虑了数学符号、希腊字母、全角标点等等，但是只有简体字没有繁体字啊，这下对面海岸的同胞们不乐意了，自己搞了一套 <code>Big5</code> 编码，用来处理繁体字。</p><p>后来随着电脑深入各个领域，常用汉字已经不能满足使用需求了，所以又把 GB2312 编码中没有使用的位置拿出来又进行代码点定义，处理了20000多个汉字，发明了 <code>GBK</code> 编码，但没过多久（2000年）发现还是不够用，又提出了变长的 <code>GB18030</code> 编码，每个字符占用1、2、4个字节。</p><h1 id="大统一的Unicode"><a href="#大统一的Unicode" class="headerlink" title="大统一的Unicode"></a>大统一的Unicode</h1><p>刚刚简单提到了在中日韩这个圈里，每个国家都对 <code>ASCII</code>编码进行了扩充，也就是对 <code>ANSI</code> 编码进行了自己的定义，通常是用两个字节来表示一个文字和符号，这样就出现了一种情况，相同的两个字节在不同的系统上显示了不同的文字，如果每个国家的人只使用自己的语言也是没问题的，但是当中日韩文字混排的时候就出现了问题，这两个字节到底应该转换成中日韩哪个国家的符号呢？</p><p>为了解决这种混乱的局面，大佬们设计了一种名为 <code>Unicode</code> 的字符集，又称万国码或者统一码。Unicode 的诞生是为整合全世界的所有语言文字。理论上任何字符在Unicode中都对应一个值，这个值被称为代码点，通常写成 <code>\uABCD</code> 的格式。</p><h2 id="UCS-4-和-UCS-2"><a href="#UCS-4-和-UCS-2" class="headerlink" title="UCS-4 和 UCS-2"></a>UCS-4 和 UCS-2</h2><p>起初使用两个字节来表示代码点，其取值范围为 \u0000～\uFFFF，这种文字和代码点之间的对应关系被描述为UCS-2，也就是 Universal Character Set Coded in 2 octets 的缩写，最多可以记录65536个字符的代码点。</p><p>后来为了能表示更多的文字，人们又提出了UCS-4，即用四个字节表示代码点。它的范围为 \u00000000～\u7FFFFFFF，其中 \u00000000～\u0000FFFF和UCS-2是一样的。</p><p>从这里可以看出 UCS-4 与 UCS-2 只是一种扩展的关系，UCS-4 是兼容 UCS-2 的，在 UCS-2 的每个代码点加入两个值为0的字节就变成了 UCS-4。</p><h2 id="UCS-2-LE-和-UCS-2-BE"><a href="#UCS-2-LE-和-UCS-2-BE" class="headerlink" title="UCS-2 LE 和 UCS-2 BE"></a>UCS-2 LE 和 UCS-2 BE</h2><p>这里的 <code>LE</code> 和 <code>BE</code> 指的是计算机中常提到的小端字节序和大端字节序，因为 UCS-4 是 UCS-2 的扩展，所以 UCS-4 也存在大端和小端的问题。</p><p>小端字节序，是指数据的高字节保存在内存的高地址中，而数据的低字节保存在内存的低地址中，而大端字节序，是指数据的高字节保存在内存的低地址中，而数据的低字节保存在内存的高地址中，这和我们平时的阅读习惯一致。</p><p>如果没接触过大端和小端可能会有点懵，举个例子就明白了，C++中一个int类型的数字通常占4个字节，假如一个int类型的变量值是256，那么他再内存中是怎样表示的呢？我们知道计算机中除了1就是0，这在计算机中对应一个bit，而计算机中表示数据的单位是字节，每个字节有8个bit大小，那么int变量值 256 翻译成二进制是 <code>00000000 00000000 00000001 00000000</code> 一共占用4个字节。</p><p>对照前面大端和小端的定义，这4个字节在内存中如果从高到低排列，就是小端字节序，如果这4个字节在内存中如果从低到高排列，就是大端字节序。因为UCS-2是两个字节表示一个代码点，所以在表示的时候存在字节排列顺序问题，对于值为 256 的这个代码点，可以是0x0100，也可以是0x0001。</p><h2 id="Unicode-和-UCS-2"><a href="#Unicode-和-UCS-2" class="headerlink" title="Unicode 和 UCS-2"></a>Unicode 和 UCS-2</h2><p>Unicode 是一个字符集，这一点应该很好理解，它表示的是字符和代码点的对应关系，比如简体字“汉”对应的Unicode代码点是 <code>\u6C49</code>，而 UCS-2 究竟是一种字符集还是一种编码方式呢？</p><p>我个人偏向于它是一种编码方式，因为它存在大端、小端这种说法，如果是一种字符集只会考虑对应关系，不会考虑字节序，这只是我个人观点，有些软件上确实是这样标注的，但有些文章也会把UCS-2当成一种字符集，这样也能说的通，不用太纠结这里的区别。</p><p>其实 UCS-2 编码对应的字符集是UCS，这些是历史原因导致的，一方面国际标准化组织（ISO）于1984年创建ISO/IEC JTC1/SC2/WG2工作组，试图制定一份通用字符集（Universal Character Set，简称UCS），并最终制定了ISO 10646标准。<br>而另一方面统一码联盟，也很想做这个统一编码的武林盟主，由Xerox、Apple等软件制造商于1988年组成，并且开发了Unicode标准。</p><p>然后1991年左右，两个项目的参与者都认识到，世界不需要两个不兼容的字符集。于是，它们开始合并双方的工作成果，并为创立一个单一编码表而协同工作。从Unicode 2.0开始，Unicode采用了与ISO 10646-1相同的字库和字码。ISO也承诺，ISO 10646将不会替超出\u10FFFF的UCS-4编码赋值，以使得两者保持一致。两个项目仍都独立存在，并独立地公布各自的标准。不过由于Unicode这一名字名字起的好，比较好记，因而它使用更为广泛。</p><p>从这段历史我们可以看到，虽然 UCS-4 将 UCS-2 从2个字节扩展成了4个字节，但是范围并没到使用到 \u00000000～\uFFFFFFFF，而是将范围集中到 \u000000～\u10FFFF 内，保证了 UCS 和 Unicode 各个字符代码点的统一，也奠定了UTF-8实现标准Unicode时最多需要4个字节的基础。</p><h1 id="UTF-8-的诞生"><a href="#UTF-8-的诞生" class="headerlink" title="UTF-8 的诞生"></a>UTF-8 的诞生</h1><p>按理说 Unicode 已经给世界范围内的所有字符定义了代码点，无论是什么字符，使用4个字节都能表示出来，为什么要搞出一个UTF-8呢？是因为使用者发现，对于ASCII码范围内的字符，本来1个字节就能正确表示，现在居然要4个字节表示，即使使用 UCS-2编码，占用的空间也扩大了1倍，有些太浪费了。</p><p>为了解决这种空间浪费问题，就出现了一类变长的通用转换格式，即UTF（Universal Transformation Format），常见的UTF格式有：UTF-7，UTF-7.5，UTF-8，UTF-16 以及 UTF-32。</p><p>这类格式中最常见的就是 UTF-8 编码了，UTF-8 是针对于 Unicode 字符集中各个代码点的编码方式，是一种 Unicode 字符的实现方式，采用变长字节来表示Unicode编码，最长使用4个字节来表示标准的Unicode代码点，在有些资料中可能会看到5、6个字节的编码方式，这些都是非标准的Unicode代码点，根据规范，这些字节值将无法出现在合法 UTF-8序列中。</p><h2 id="Unicode-和-UTF-8"><a href="#Unicode-和-UTF-8" class="headerlink" title="Unicode 和 UTF-8"></a>Unicode 和 UTF-8</h2><p>UTF-8在对标准Unicode字符编码时最多使用4个字节，其代码点范围与UTF-8编码后的形式对应如下：</p><table><thead><tr><th style="text-align:center"><strong>Unicode/UCS-4</strong>（十六进制）</th><th style="text-align:center">字节数</th><th style="text-align:left">UTF-8编码格式（二进制）</th></tr></thead><tbody><tr><td style="text-align:center">000000-00007F</td><td style="text-align:center">1</td><td style="text-align:left">0xxxxxxx</td></tr><tr><td style="text-align:center">000080-0007FF</td><td style="text-align:center">2</td><td style="text-align:left">110xxxxx 10xxxxxx</td></tr><tr><td style="text-align:center">000800-00FFFF</td><td style="text-align:center">3</td><td style="text-align:left">1110xxxx 10xxxxxx 10xxxxxx</td></tr><tr><td style="text-align:center">010000-10FFFF</td><td style="text-align:center">4</td><td style="text-align:left">11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</td></tr></tbody></table><h2 id="UTF-8编码示例"><a href="#UTF-8编码示例" class="headerlink" title="UTF-8编码示例"></a>UTF-8编码示例</h2><p>只看上面这种对应关系，可能还不太清楚是怎样表示，接下来可以举一个例子试一下，比如一个常用的简体中文字——“好”，查询它的Unicode代码点是 <code>\u597D</code>，对照上面的表格发现在 000800-00FFFF 这个范围，应该采用3个字节的表现形式。</p><p>先把这个数值翻译成二进制为 <code>0101100101111101</code>，然后按照3个字节的形式分成3组，<code>0101</code>、<code>100101</code> 和 <code>111101</code>，把这些内容天填充到xxx这样的空位中就得到了“好”这个字的UTF-8编码—— <code>11100101 10100101 10111101</code>，表示成十六进制就是 <code>0xE5A5BD</code>。</p><p>这个过程还是比较简单的，其他编码要转换成UTF-8编码都要经过Unicode这一步中转，先通过转换表查到其他编码对应字符的Unicode编码，然后再转换成UTF-8的表示格式。</p><h2 id="优点和缺点"><a href="#优点和缺点" class="headerlink" title="优点和缺点"></a>优点和缺点</h2><p>根据 UTF-8 的编码规则，任何一个 byte 漏传，多传，传错只影响当前字符，前后字符都不受影响，而 Unicode 如果从一个字的中间截断会导致接下来所有的字符解析都是错的，这使得UTF-8编码的数据在不够可靠的网络传输中是有利的。</p><p>兼容ASCII，并且是字节顺序无关的。它的字节顺序在所有系统中都是一样的，因此它实际上并不需要BOM，不过在文件开头常常保存 0xEFBBBF 三个字节来表明文件编码是UTF-8。</p><p>缺点是因为UTF-8是一种变长编码，无法从直接从Unicode字符直接判断出UTF-8文本的字节数。除了ASCII字符集内的字符，其他情况实际上都增加了固定的头数据，占用了无效空间。</p><h1 id="编码和解码在编程中的应用"><a href="#编码和解码在编程中的应用" class="headerlink" title="编码和解码在编程中的应用"></a>编码和解码在编程中的应用</h1><p>编码和解码在网站页面和数据库存储时用的非常多，一不小心就搞出一堆乱码，这种编码和解码操作在Python3中很直观，Python2中 string 和 bytes 混合在一起，编码和解码操作不太明显，而在python3中 string 和 bytes 是完全不同的两个类型，string编码成bytes，而bytes解码成string。</p><p>相比于python3中的编码、解码对应两个类型，C++中的编码和解码操作的前后都是字符串，这在一定程度上会给人造成误解，接下来我们使用Python3来简单测试一下编码和解码操作。</p><h2 id="编码操作"><a href="#编码操作" class="headerlink" title="编码操作"></a>编码操作</h2><p>编码通常是把人类可以理解的字符转换成计算机可以认识二进制数据，这个过程在python3中对应的是把string转化成bytes，测试如下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">word = <span class="string">'好好'</span></span><br><span class="line">print(type(word), word)</span><br><span class="line"></span><br><span class="line">result = word.encode(<span class="string">'utf-8'</span>)</span><br><span class="line">print(type(result), result)</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;class &apos;str&apos;&gt; 好好</span><br><span class="line">&lt;class &apos;bytes&apos;&gt; b&apos;\xe5\xa5\xbd\xe5\xa5\xbd&apos;</span><br></pre></td></tr></table></figure><h2 id="解码操作"><a href="#解码操作" class="headerlink" title="解码操作"></a>解码操作</h2><p>解码操作通常是把计算机中存储和传输的数据转换成人类能看懂的字符，这个过程在python3中对应的是把bytes转化成string，测试如下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">data = <span class="string">b'\xe5\xa5\xbd\xe5\xa5\xbd'</span></span><br><span class="line">print(type(data), data)</span><br><span class="line"></span><br><span class="line">result = data.decode(<span class="string">'utf-8'</span>)</span><br><span class="line">print(type(result), result)</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;class &apos;bytes&apos;&gt; b&apos;\xe5\xa5\xbd\xe5\xa5\xbd&apos;</span><br><span class="line">&lt;class &apos;str&apos;&gt; 好好</span><br></pre></td></tr></table></figure><h2 id="乱码产生"><a href="#乱码产生" class="headerlink" title="乱码产生"></a>乱码产生</h2><p>从上面的两个例子来看编码和解码非常简单，那怎么还能出现乱码呢？计算机说到底还是一种工具，你在把可见字符编码后交给计算机存储和传输时，你要记住这些二进制的编码方式，在你想看这些数据时还要用相反的方式进行解码，否则就会出现乱码，比如下面这种使用 utf-8 编码，却使用 gbk 这种方式来解码，就得不到你想要的数据。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">word = <span class="string">'好好'</span></span><br><span class="line">print(type(word), word)</span><br><span class="line"></span><br><span class="line">result = word.encode(<span class="string">'utf-8'</span>)</span><br><span class="line">print(type(result), result)</span><br><span class="line"></span><br><span class="line">new_word = result.decode(<span class="string">'gbk'</span>)</span><br><span class="line">print(type(new_word), new_word)</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;class &apos;str&apos;&gt; 好好</span><br><span class="line">&lt;class &apos;bytes&apos;&gt; b&apos;\xe5\xa5\xbd\xe5\xa5\xbd&apos;</span><br><span class="line">&lt;class &apos;str&apos;&gt; 濂藉ソ</span><br></pre></td></tr></table></figure><p>虽然结果是可以看得见的字符，但是这不是我们想要的数据，所以 <code>濂藉ソ</code> 对于我们来说也是一种乱码，在处理字符编码时我们必须清楚知道要用什么方式来进行编码和解码，如果编码和解码的方式不一致，那么就会产生乱码现象。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li><code>Unicode</code> 是一种字符集，描述了人类范围内用于交流的所有字符的代码点，给与唯一的数字进行对应</li><li><code>Unicode</code> 规定的代码点范围是 \u000000-\u10FFFF，这与 UCS-4 规定的范围达成了统一，共定义了17个Plan</li><li><code>UTF-8</code> 是Unicode字符集的一种实现，采用变长的方式，标准规范最多使用4个字节表示一个Unicode字符</li><li>编码是为了把人类用来交流的字符转换成二进制数据便于存储和传输</li><li>解码是为了把存储在计算机中的二进制数据转换成人们能看得懂的字符</li><li>编码和解码不一致时就会造成乱码，比如使用UTF-8编码，使用GBK来解码就会造成乱码现象</li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/109976348" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>对未知的事物充满恐惧，过于保守的看待当下的一切，有时候太稳反而会失去很多~</p><p>2020-11-29 19:23:13</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;在程序员生活的01世界中有两大Boss级难题，分别是缓存失效和命名问题，对比这两大难题来说，编码和解码只能算是小妖儿了，只不过这两个小妖儿出
      
    
    </summary>
    
      <category term="Thinking" scheme="http://AlbertGithubHome.github.io/blog/categories/Thinking/"/>
    
    
      <category term="Python" scheme="http://AlbertGithubHome.github.io/blog/tags/Python/"/>
    
      <category term="编码" scheme="http://AlbertGithubHome.github.io/blog/tags/%E7%BC%96%E7%A0%81/"/>
    
      <category term="解码" scheme="http://AlbertGithubHome.github.io/blog/tags/%E8%A7%A3%E7%A0%81/"/>
    
      <category term="encode" scheme="http://AlbertGithubHome.github.io/blog/tags/encode/"/>
    
      <category term="decode" scheme="http://AlbertGithubHome.github.io/blog/tags/decode/"/>
    
  </entry>
  
  <entry>
    <title>linux环境下使用netstat命令查看网络信息</title>
    <link href="http://AlbertGithubHome.github.io/blog/2020/11/22/linux%E7%8E%AF%E5%A2%83%E4%B8%8B%E4%BD%BF%E7%94%A8netstat%E5%91%BD%E4%BB%A4%E6%9F%A5%E7%9C%8B%E7%BD%91%E7%BB%9C%E4%BF%A1%E6%81%AF/"/>
    <id>http://AlbertGithubHome.github.io/blog/2020/11/22/linux环境下使用netstat命令查看网络信息/</id>
    <published>2020-11-22T15:05:55.000Z</published>
    <updated>2020-11-28T12:30:55.383Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><code>netstat</code> 这个命令一直以为是 net status 的缩写，今天一查发现并没有找到官方的这种说法，然后参考了 man 手册，发现这个词更像是 net statistics 的缩写，命令的作用是显示网络连接、路由表、接口连接、无效连接和多播成员关系的，man 手册中描述这个命令如下：</p><blockquote><p>netstat - Print network connections, routing tables, interface statistics, masquerade connections, and multicast memberships</p></blockquote><p>这个命令很强大，但是我经常使用的参数很简单，通常用来查询端口占用问题，命令为 <code>netstat -anp | grep xxxPORT</code>，因为在我测试自己项目程序的时候，总有一些进程企图占用我使用的端口，比如那个 被我 kill 了 n 次的 TIM 客户端，使用 netstat 可以方便的找到是哪个进程占用了你的端口。</p><p>虽然这个命令经常使用，但是其中的这些参数含义却不是很清楚，所以特地总结一下，综合其他常见的用法，记录下来以备后续查找使用。</p><h1 id="参数选项"><a href="#参数选项" class="headerlink" title="参数选项"></a>参数选项</h1><ul><li><strong>-a</strong>：显示所有连接，包括 LISTEN 状态的连接</li><li><strong>-l</strong>：仅显示 LISTEN 状态的连接</li><li><strong>-t</strong>：仅显示tcp相关选项</li><li><strong>-u</strong>：仅显示udp相关选项</li><li><strong>-n</strong>：拒绝显示别名，能显示数字的全部转化成数字</li><li><strong>-o</strong>：显示信息中包括与网络计时器相关的信息</li><li><strong>-e</strong>：显示扩展信息，例如uid等</li><li><strong>-p</strong>：显示建立相关链接的程序名</li><li><strong>-r</strong>：显示路由信息，路由表</li><li><strong>-s</strong>：按各个协议进行统计</li><li><strong>-c</strong>：每隔一个固定时间，执行该netstat命令。</li></ul><h1 id="无参数执行"><a href="#无参数执行" class="headerlink" title="无参数执行"></a>无参数执行</h1><p>该命令无参数执行时显示数据会少一些，便于我们看清命令执行的结果，内容如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[root@node1 ~]<span class="comment"># netstat</span></span><br><span class="line">Active Internet connections (w/o servers)</span><br><span class="line">Proto Recv-Q Send-Q Local Address           Foreign Address         State</span><br><span class="line">tcp        0      0 192.168.0.201:ssh       178.129.126.124.b:19450 ESTABLISHED</span><br><span class="line">tcp        0     52 192.168.0.201:ssh       178.129.126.124.b:17626 ESTABLISHED</span><br><span class="line">tcp        0      0 192.168.0.201:57784     101.200.35.175:https    TIME_WAIT</span><br><span class="line">tcp        0      0 192.168.0.201:42298     100.125.2.72:https      ESTABLISHED</span><br><span class="line">Active UNIX domain sockets (w/o servers)</span><br><span class="line">Proto RefCnt Flags       Type       State         I-Node   Path</span><br><span class="line">unix  2      [ ]         DGRAM                    11550    /run/systemd/shutdownd</span><br><span class="line">unix  2      [ ]         DGRAM                    13355412 /var/run/chrony/chronyd.sock</span><br><span class="line">unix  3      [ ]         DGRAM                    1228     /run/systemd/notify</span><br><span class="line">unix  2      [ ]         DGRAM                    1230     /run/systemd/cgroups-agent</span><br><span class="line">unix  5      [ ]         DGRAM                    1241     /run/systemd/journal/socket</span><br><span class="line">unix  16     [ ]         DGRAM                    1243     /dev/<span class="built_in">log</span></span><br><span class="line">unix  3      [ ]         STREAM     CONNECTED     15663</span><br><span class="line">unix  3      [ ]         STREAM     CONNECTED     15662</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>输出结果可以分为 <code>Active Internet connections</code> 和 <code>Active UNIX domain sockets</code> 两个部分：</p><p>Active Internet connections 指有效的网络连接，默认显示6列内容：</p><ul><li>Proto：协议名字，包括tcp, udp, udpl, raw等</li><li>Recv-Q：表示网络接收队列，表示收到的数据已经在本地接收缓冲，还有多少没有被应用程序取走</li><li>Send-Q：表示网络发送队列，表示存在本地缓冲区，但对方没有收到的数据或者没有 ACK 的</li><li>Local Address：本地IP地址和端口</li><li>Foreign Address：外部IP地址和端口</li><li>State：网络连接状态，包括 ESTABLISHED、SYN_SENT、SYN_RECV、FIN_WAIT1、FIN_WAIT2、TIME_WAIT、CLOSE、CLOSE_WAIT、LAST_ACK、LISTEN、CLOSING、UNKNOWN 等状态</li></ul><p>Active UNIX domain sockets 是指本地套接口，我们知道 socket 也可用于同一台主机的进程间（IPC）通讯，但是 socket 用于IPC更有效率：不需要经过网络协议栈，不需要打包拆包、计算校验和、维护序号和应答等，只是将应用层数据从一个进程拷贝到另一个进程<br>并且它是是全双工的，API接口语义丰富，相比其它进程间通信机制有明显的优越性。</p><h1 id="常用命令组合"><a href="#常用命令组合" class="headerlink" title="常用命令组合"></a>常用命令组合</h1><h2 id="查询端口占用"><a href="#查询端口占用" class="headerlink" title="查询端口占用"></a>查询端口占用</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@node1 /]<span class="comment"># netstat -anp | grep 8889</span></span><br><span class="line">tcp        0      0 0.0.0.0:8889            0.0.0.0:*               LISTEN      27584/tinyproxy</span><br></pre></td></tr></table></figure><p>这是我目前最常用的命令，在windows可以改为 <code>netstat -ano | findstr 8889</code></p><h2 id="显示tcp连接"><a href="#显示tcp连接" class="headerlink" title="显示tcp连接"></a>显示tcp连接</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@node1 /]<span class="comment"># netstat -at</span></span><br><span class="line">Active Internet connections (servers and established)</span><br><span class="line">Proto Recv-Q Send-Q Local Address           Foreign Address         State</span><br><span class="line">tcp        0      0 0.0.0.0:ddi-tcp-2       0.0.0.0:*               LISTEN</span><br><span class="line">tcp        0      0 localhost:smtp          0.0.0.0:*               LISTEN</span><br><span class="line">tcp        0      0 0.0.0.0:ssh             0.0.0.0:*               LISTEN</span><br><span class="line">tcp        0     52 192.168.0.201:ssh       178.129.126.124.b:19450 ESTABLISHED</span><br><span class="line">tcp        0      0 192.168.0.201:ssh       178.129.126.124.b:17626 ESTABLISHED</span><br><span class="line">tcp        0      0 192.168.0.201:42298     100.125.2.72:https      ESTABLISHED</span><br><span class="line">tcp6       0      0 [::]:squid              [::]:*                  LISTEN</span><br><span class="line">tcp6       0      0 localhost:smtp          [::]:*                  LISTEN</span><br><span class="line">tcp6       0      0 [::]:ssh                [::]:*                  LISTEN</span><br></pre></td></tr></table></figure><h2 id="显示处于-LISTEN-状态的端口"><a href="#显示处于-LISTEN-状态的端口" class="headerlink" title="显示处于 LISTEN 状态的端口"></a>显示处于 LISTEN 状态的端口</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[root@node1 /]<span class="comment"># netstat -l</span></span><br><span class="line">Active Internet connections (only servers)</span><br><span class="line">Proto Recv-Q Send-Q Local Address           Foreign Address         State</span><br><span class="line">tcp        0      0 0.0.0.0:ddi-tcp-2       0.0.0.0:*               LISTEN</span><br><span class="line">tcp        0      0 localhost:smtp          0.0.0.0:*               LISTEN</span><br><span class="line">tcp        0      0 0.0.0.0:ssh             0.0.0.0:*               LISTEN</span><br><span class="line">tcp6       0      0 [::]:squid              [::]:*                  LISTEN</span><br><span class="line">tcp6       0      0 localhost:smtp          [::]:*                  LISTEN</span><br><span class="line">tcp6       0      0 [::]:ssh                [::]:*                  LISTEN</span><br><span class="line">udp        0      0 0.0.0.0:bootpc          0.0.0.0:*</span><br><span class="line">udp        0      0 0.0.0.0:ntp             0.0.0.0:*</span><br><span class="line">udp        0      0 localhost:323           0.0.0.0:*</span><br><span class="line">udp        0      0 0.0.0.0:56034           0.0.0.0:*</span><br><span class="line">udp6       0      0 [::]:42035              [::]:*</span><br><span class="line">udp6       0      0 localhost:323           [::]:*</span><br><span class="line">Active UNIX domain sockets (only servers)</span><br><span class="line">Proto RefCnt Flags       Type       State         I-Node   Path</span><br><span class="line">unix  2      [ ACC ]     STREAM     LISTENING     11533    /run/lvm/lvmpolld.socket</span><br><span class="line">unix  2      [ ACC ]     STREAM     LISTENING     6848304  /var/run/rpcbind.sock</span><br><span class="line">unix  2      [ ACC ]     STREAM     LISTENING     11584    /run/lvm/lvmetad.socket</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h2 id="分类统计每种协议的信息"><a href="#分类统计每种协议的信息" class="headerlink" title="分类统计每种协议的信息"></a>分类统计每种协议的信息</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">[root@node1 /]<span class="comment"># netstat -s</span></span><br><span class="line">Ip:</span><br><span class="line">    7902622 total packets received</span><br><span class="line">    60675 forwarded</span><br><span class="line">    127 with unknown protocol</span><br><span class="line">    0 incoming packets discarded</span><br><span class="line">    7841813 incoming packets delivered</span><br><span class="line">    7270606 requests sent out</span><br><span class="line">    8 dropped because of missing route</span><br><span class="line">Icmp:</span><br><span class="line">    928210 ICMP messages received</span><br><span class="line">    25426 input ICMP message failed.</span><br><span class="line">    InCsumErrors: 8</span><br><span class="line">    ICMP input histogram:</span><br><span class="line">        destination unreachable: 71154</span><br><span class="line">        timeout <span class="keyword">in</span> transit: 484</span><br><span class="line">        <span class="built_in">echo</span> requests: 856165</span><br><span class="line">        <span class="built_in">echo</span> replies: 337</span><br><span class="line">        timestamp request: 54</span><br><span class="line">    896502 ICMP messages sent</span><br><span class="line">    0 ICMP messages failed</span><br><span class="line">    ICMP output histogram:</span><br><span class="line">        destination unreachable: 40039</span><br><span class="line">        <span class="built_in">echo</span> request: 244</span><br><span class="line">        <span class="built_in">echo</span> replies: 856165</span><br><span class="line">        timestamp replies: 54</span><br><span class="line">Tcp:</span><br><span class="line">    274517 active connections openings</span><br><span class="line">    66347 passive connection openings</span><br><span class="line">    187800 failed connection attempts</span><br><span class="line">    90950 connection resets received</span><br><span class="line">    3 connections established</span><br><span class="line">    6359177 segments received</span><br><span class="line">    5808198 segments send out</span><br><span class="line">    494062 segments retransmited</span><br><span class="line">    4 bad segments received.</span><br><span class="line">    452720 resets sent</span><br><span class="line">Udp:</span><br><span class="line">    539313 packets received</span><br><span class="line">    14902 packets to unknown port received.</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h2 id="每秒显示一次信息"><a href="#每秒显示一次信息" class="headerlink" title="每秒显示一次信息"></a>每秒显示一次信息</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@node1 /]<span class="comment"># netstat -c</span></span><br><span class="line">Active Internet connections (w/o servers)</span><br><span class="line">Proto Recv-Q Send-Q Local Address           Foreign Address         State</span><br><span class="line">tcp        0     52 192.168.0.201:ssh       178.129.126.124.b:19450 ESTABLISHED</span><br><span class="line">tcp        0      0 192.168.0.201:ssh       178.129.126.124.b:17626 ESTABLISHED</span><br><span class="line">tcp        0      0 192.168.0.201:42298     100.125.2.72:https      ESTABLISHED</span><br><span class="line">Active UNIX domain sockets (w/o servers)</span><br><span class="line">Proto RefCnt Flags       Type       State         I-Node   Path</span><br><span class="line">unix  2      [ ]         DGRAM                    11550    /run/systemd/shutdownd</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h2 id="显示核心路由信息"><a href="#显示核心路由信息" class="headerlink" title="显示核心路由信息"></a>显示核心路由信息</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@node1 /]<span class="comment"># netstat -r</span></span><br><span class="line">Kernel IP routing table</span><br><span class="line">Destination     Gateway         Genmask         Flags   MSS Window  irtt Iface</span><br><span class="line">default         192.168.0.1     0.0.0.0         UG        0 0          0 eth0</span><br><span class="line">169.254.169.254 192.168.0.254   255.255.255.255 UGH       0 0          0 eth0</span><br><span class="line">172.17.0.0      0.0.0.0         255.255.0.0     U         0 0          0 docker0</span><br><span class="line">192.168.0.0     0.0.0.0         255.255.255.0   U         0 0          0 eth0</span><br></pre></td></tr></table></figure><h2 id="显示网络接口列表"><a href="#显示网络接口列表" class="headerlink" title="显示网络接口列表"></a>显示网络接口列表</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@node1 /]<span class="comment"># netstat -i</span></span><br><span class="line">Kernel Interface table</span><br><span class="line">Iface             MTU    RX-OK RX-ERR RX-DRP RX-OVR    TX-OK TX-ERR TX-DRP TX-OVR Flg</span><br><span class="line">docker0          1500    36248      0      0 0         33647      0      0      0 BMU</span><br><span class="line">eth0             1500  9119246      0      0 0       8277212      0      0      0 BMRU</span><br><span class="line">lo              65536    27700      0      0 0         27700      0      0      0 LRU</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li><code>netstat -anp | grep 8889</code> 命令可用于查询8889端口被哪个进程占用了，在Windows上翻译为 <code>netstat -ano | findstr 8889</code></li><li>netstat 命令查询出的网络连接信息中，<code>Recv-Q</code> 和 <code>Send-Q</code> 通常应该为0，如果长时间不为0可能是有问题的，需要尽快排查</li><li>如果 <code>Recv-Q</code> 数值一直处于不为0的状态，可能是遭受了拒绝服务 DOS 攻击，导致本地消息处理过慢</li><li>如果 <code>Send-Q</code> 数值一直处于不为0的状态，可能是有应用向外发送数据包过快，或者是对方接收处理数据包不够快</li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/109712347" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>以史为鉴可以知兴替，以铜为鉴可以正衣冠，以人为鉴可以明得失。人的成长需要对比，总有人比你更加优秀~</p><p>2020-11-23 01:17:59</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&lt;code&gt;netstat&lt;/code&gt; 这个命令一直以为是 net status 的缩写，今天一查发现并没有找到官方的这种说法，然后参考了
      
    
    </summary>
    
      <category term="linux" scheme="http://AlbertGithubHome.github.io/blog/categories/linux/"/>
    
    
      <category term="linux" scheme="http://AlbertGithubHome.github.io/blog/tags/linux/"/>
    
      <category term="sort" scheme="http://AlbertGithubHome.github.io/blog/tags/sort/"/>
    
      <category term="排序" scheme="http://AlbertGithubHome.github.io/blog/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>学习cmake从成功编译一个小程序开始</title>
    <link href="http://AlbertGithubHome.github.io/blog/2020/11/14/%E5%AD%A6%E4%B9%A0cmake%E4%BB%8E%E6%88%90%E5%8A%9F%E7%BC%96%E8%AF%91%E4%B8%80%E4%B8%AA%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%A7%8B/"/>
    <id>http://AlbertGithubHome.github.io/blog/2020/11/14/学习cmake从成功编译一个小程序开始/</id>
    <published>2020-11-14T15:59:17.000Z</published>
    <updated>2020-11-15T15:59:20.861Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在 Windows上开发我使用最多的IDE还是 Visual Studio，编写、编译一条龙服务，导致了不少编译流程知识的缺失，这种大型的IDE确实好用，诸多配置通过在界面上勾选一下就可以了，但是在编译细节的掌握上还是漏掉了一些知识。</p><p>在 linux 开发环境下通常会使用 gcc 或者 g++ 进行编译，可是编译选项有点多，当工程非常大的时候需要写的编译参数太多了，这时可以使用make命令来帮助我们编译 C++ 程序，编译时依赖一些规则，这些规则就写在一个叫 Makefile 的文件中。</p><p>后来发现写 Makefile 还是太麻烦了，这个文件也相当大。于是“懒惰”的程序员们又开发出了各种各样的工具用来生成 Makefile 文件，我使用过的目前就只有 <code>automake</code> 和 <code>cmake</code>。</p><h1 id="生成Makefile"><a href="#生成Makefile" class="headerlink" title="生成Makefile"></a>生成Makefile</h1><p>之前使用的生成 Makefile 文件的工具是 <code>automake</code>，被称为是“八股文”一样的操作，每次操作都是固定的几个步骤，比如每次都要运行 <code>autoscan</code>、<code>aclocal</code>、<code>autoconf</code>、<code>automake</code>、<code>./confiugre</code>等命令，需要个人发挥的地方并不多，之前使用的时候也不是完全从0开始一点点写的，往往是写一个项目模板之后，对照着在Makefile.am文件中修改几个参数就好了。</p><p>现在新的工作内容中使用 cmake 来生成 Makefile，这个 cmake 之前还确实接触过一些，大概是2012年的时候，那时在编译 OpenCV 库还有增强现实插件的时候用过几次，当时感觉安装起来太麻烦了，对那个红绿蓝的图标记忆犹新，感觉和当时的新闻联播的图标有些亲戚关系。</p><p>其实当时根本分不清什么是编译器，什么是 Makefile，对于各种库文件的编译完全是按照文档来操作，现在回过头来看看 cmake 生成 Makefile 还是比较简单的，最起码要比 automake 省了很多步骤，只要编写一个 CMakeLists.txt 文件就好了。</p><h1 id="编写CMakeLists-txt生成Makefile"><a href="#编写CMakeLists-txt生成Makefile" class="headerlink" title="编写CMakeLists.txt生成Makefile"></a>编写CMakeLists.txt生成Makefile</h1><p>为了练习使用编写CMakeLists.txt生成Makefile，进而编译C++项目，我们可以从头来实现一个小例子，目标是编写一个计算加法的静态库和一个计算减法静态库，然后实现一个测试工程来使用这两个函数库，整个工程使用 cmake 来生成 Makefile，然后使用 make 命令完成编译。</p><h2 id="实现简单的代码文件"><a href="#实现简单的代码文件" class="headerlink" title="实现简单的代码文件"></a>实现简单的代码文件</h2><p>加法和减法都是常用的简单计算，用来举例子很容易理解，接下来展示要用到的几个文件内容，每个文件只有几行，只为了说明问题，文件内容如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//myadd.h</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//myadd.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"myadd.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//mysub.h</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sub</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//mysub.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mysub.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sub</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a - b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//test.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"myadd.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mysub.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"happy birthday!"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"519 + 1 = "</span> &lt;&lt; add(<span class="number">519</span>, <span class="number">1</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"1320 - 6 = "</span> &lt;&lt; sub(<span class="number">1320</span>, <span class="number">6</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用常规方法编译"><a href="#使用常规方法编译" class="headerlink" title="使用常规方法编译"></a>使用常规方法编译</h2><p>首先使用最简单 g++ 命令来编译这个样例程序：</p><ol><li>查看目录下文件</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:testcmake$ ls</span><br><span class="line">myadd.cpp  myadd.h  mysub.cpp  mysub.h  test.cpp</span><br></pre></td></tr></table></figure><ol><li>将 <code>myadd.h</code> 和 <code>myadd.cpp</code> 编译成静态库 <code>libmyadd.a</code></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:testcmake$ g++ -c myadd.cpp</span><br><span class="line">albert@home-pc:testcmake$ ar crv libmyadd.a myadd.o</span><br><span class="line">a - myadd.o</span><br><span class="line">albert@home-pc:testcmake$ ls</span><br><span class="line">libmyadd.a  myadd.cpp  myadd.h  myadd.o  mysub.cpp  mysub.h  test.cpp</span><br></pre></td></tr></table></figure><ol><li>将 <code>mysub.h</code> 和 <code>mysub.cpp</code> 编译成静态库 <code>libmysub.so</code></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:testcmake$ g++ -c mysub.cpp</span><br><span class="line">albert@home-pc:testcmake$ g++ -shared -fPIC -o libmysub.so mysub.o</span><br><span class="line">albert@home-pc:testcmake$ ls</span><br><span class="line">libmyadd.a  libmysub.so  myadd.cpp  myadd.h  myadd.o  mysub.cpp  mysub.h  mysub.o  test.cpp</span><br></pre></td></tr></table></figure><ol><li>编译链接静态库 <code>libmyadd.a</code>、动态库 <code>libmysub.so</code> 和测试文件生成可执行程序 <code>test</code></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:testcmake$ g++ test.cpp libmyadd.a -L. -lmysub -o <span class="built_in">test</span> -Wl,-rpath=.</span><br><span class="line">albert@home-pc:testcmake$ ls</span><br><span class="line">libmyadd.a  libmysub.so  myadd.cpp  myadd.h  myadd.o  mysub.cpp  mysub.h  mysub.o  <span class="built_in">test</span>  test.cpp</span><br></pre></td></tr></table></figure><ol><li>运行查看结果，成功计算表达式的值</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:testcmake$ ./<span class="built_in">test</span></span><br><span class="line">happy birthday!</span><br><span class="line">519 + 1 = 520</span><br><span class="line">1320 - 6 = 1314</span><br></pre></td></tr></table></figure><h2 id="使用cmake方式"><a href="#使用cmake方式" class="headerlink" title="使用cmake方式"></a>使用cmake方式</h2><p>上面展示了最原始的编译方法，每次都要敲这些命令，接下来编写一个 CMakeLists 文件，使用 cmake 生成Makefile，以后只要运行 make 命令就可以完成编译了。</p><p>调整一下目录结构如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:testcmake$ tree</span><br><span class="line">.</span><br><span class="line">|-- myadd</span><br><span class="line">|   |-- myadd.cpp</span><br><span class="line">|   `-- myadd.h</span><br><span class="line">|-- mysub</span><br><span class="line">|   |-- mysub.cpp</span><br><span class="line">|   `-- mysub.h</span><br><span class="line">`-- test.cpp</span><br></pre></td></tr></table></figure><ol><li>进入 myadd 目录新建 CMakeLists.txt 编写内容如下：</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">aux_source_directory(. SRC_LIST)        <span class="comment">#将此目录的源文件集合设置为变量SRC_LIST</span></span><br><span class="line">add_library(myadd STATIC <span class="variable">$&#123;SRC_LIST&#125;</span>)   <span class="comment">#库的名称，库的类型，静态库的源文件列表</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span>(LIBRARY_OUTPUT_PATH <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/lib)  <span class="comment">#库的输出路径为根目录下的lib文件夹</span></span><br></pre></td></tr></table></figure><ol><li>进入 mysub 目录新建 CMakeLists.txt 编写内容如下：</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">aux_source_directory(. SRC_LIST)        <span class="comment">#将此目录的源文件集合设置为变量SRC_LIST</span></span><br><span class="line">add_library(mysub SHARED <span class="variable">$&#123;SRC_LIST&#125;</span>)   <span class="comment">#库的名称，库的类型，动态库的源文件列表</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span>(LIBRARY_OUTPUT_PATH <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/lib)  <span class="comment">#库的输出路径为根目录下的lib文件夹</span></span><br></pre></td></tr></table></figure><ol><li>在工程主目录下新建 CMakeLists.txt 编写内容如下：</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 指定cmake版本</span></span><br><span class="line">cmake_minimum_required(VERSION 3.5)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定项目的名称，一般和项目的文件夹名称对应</span></span><br><span class="line">project(testcmake)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定子目录</span></span><br><span class="line">add_subdirectory(myadd)</span><br><span class="line">add_subdirectory(mysub)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加c++ 11标准支持</span></span><br><span class="line"><span class="built_in">set</span>(CMAKE_CXX_FLAGS <span class="string">"-std=c++11"</span> )</span><br><span class="line"></span><br><span class="line"><span class="comment"># 特殊宏，之前编译mysqlcppconn8用到过</span></span><br><span class="line">add_definitions(-DGLIBCXX_USE_CXX11_ABI)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 头文件目录</span></span><br><span class="line">include_directories(myadd mysub)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 源文件目录</span></span><br><span class="line">aux_source_directory(. DIR_SRCS)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置环境变量，编译用到的源文件全部都要放到这</span></span><br><span class="line"><span class="built_in">set</span>(TEST_MATH <span class="variable">$&#123;DIR_SRCS&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 库文件目录</span></span><br><span class="line">link_directories(lib)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加要编译的可执行文件</span></span><br><span class="line">add_executable(<span class="variable">$&#123;PROJECT_NAME&#125;</span> <span class="variable">$&#123;TEST_MATH&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加可执行文件所需要的库</span></span><br><span class="line">target_link_libraries(<span class="variable">$&#123;PROJECT_NAME&#125;</span> myadd)</span><br><span class="line">target_link_libraries(<span class="variable">$&#123;PROJECT_NAME&#125;</span> mysub)</span><br></pre></td></tr></table></figure><ol><li>新建build目录和lib目录，整个工程目录关系如下：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:testcmake$ tree</span><br><span class="line">.</span><br><span class="line">|-- CMakeLists.txt</span><br><span class="line">|-- build</span><br><span class="line">|-- lib</span><br><span class="line">|-- myadd</span><br><span class="line">|   |-- CMakeLists.txt</span><br><span class="line">|   |-- myadd.cpp</span><br><span class="line">|   `-- myadd.h</span><br><span class="line">|-- mysub</span><br><span class="line">|   |-- CMakeLists.txt</span><br><span class="line">|   |-- mysub.cpp</span><br><span class="line">|   `-- mysub.h</span><br><span class="line">`-- test.cpp</span><br><span class="line"></span><br><span class="line">4 directories, 8 files</span><br></pre></td></tr></table></figure><ol><li>进入 build 目录下依次运行 <code>cmake ..</code> 和 <code>make</code> 命令</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:testcmake/build$ cmake ..</span><br><span class="line">-- The C compiler identification is GNU 5.4.0</span><br><span class="line">-- The CXX compiler identification is GNU 5.4.0</span><br><span class="line">-- Check <span class="keyword">for</span> working C compiler: /usr/bin/cc</span><br><span class="line">-- Check <span class="keyword">for</span> working C compiler: /usr/bin/cc -- works</span><br><span class="line">-- Detecting C compiler ABI info</span><br><span class="line">-- Detecting C compiler ABI info - <span class="keyword">done</span></span><br><span class="line">-- Detecting C compile features</span><br><span class="line">-- Detecting C compile features - <span class="keyword">done</span></span><br><span class="line">-- Check <span class="keyword">for</span> working CXX compiler: /usr/bin/c++</span><br><span class="line">-- Check <span class="keyword">for</span> working CXX compiler: /usr/bin/c++ -- works</span><br><span class="line">-- Detecting CXX compiler ABI info</span><br><span class="line">-- Detecting CXX compiler ABI info - <span class="keyword">done</span></span><br><span class="line">-- Detecting CXX compile features</span><br><span class="line">-- Detecting CXX compile features - <span class="keyword">done</span></span><br><span class="line">-- Configuring <span class="keyword">done</span></span><br><span class="line">-- Generating <span class="keyword">done</span></span><br><span class="line">-- Build files have been written to: testcmake/build</span><br><span class="line">albert@home-pc:testcmake/build$ make</span><br><span class="line">Scanning dependencies of target mysub</span><br><span class="line">[ 16%] Building CXX object mysub/CMakeFiles/mysub.dir/mysub.cpp.o</span><br><span class="line">[ 33%] Linking CXX shared library ../../lib/libmysub.so</span><br><span class="line">[ 33%] Built target mysub</span><br><span class="line">Scanning dependencies of target myadd</span><br><span class="line">[ 50%] Building CXX object myadd/CMakeFiles/myadd.dir/myadd.cpp.o</span><br><span class="line">[ 66%] Linking CXX static library ../../lib/libmyadd.a</span><br><span class="line">[ 66%] Built target myadd</span><br><span class="line">Scanning dependencies of target testcmake</span><br><span class="line">[ 83%] Building CXX object CMakeFiles/testcmake.dir/test.cpp.o</span><br><span class="line">[100%] Linking CXX executable testcmake</span><br><span class="line">[100%] Built target testcmake</span><br><span class="line">albert@home-pc:testcmake/build$ ./testcmake</span><br><span class="line">happy birthday!</span><br><span class="line">519 + 1 = 520</span><br><span class="line">1320 - 6 = 1314</span><br><span class="line">albert@home-pc:testcmake/build$</span><br></pre></td></tr></table></figure><p>至此，使用cmake方式编译工程的例子就写完了。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol><li><code>cmake</code> 和 <code>automake</code> 本身不提供编译功能，只是可以按照编写的 CMakeLists.txt 文件生成 Makefile</li><li><code>make</code> 可以根据 Makefile 文件调用 gcc/g++ 命令对源代码进行编译工作</li><li><code>-Wl,-rpath=.</code> 这个选项可以指定可执行文件查找动态库的路径，感觉比 <code>export LD_LIBRARY_PATH</code> 要方便一点</li><li><code>-DGLIBCXX_USE_CXX11_ABI</code> 这个宏可坑了我不少时间，编译使用libmysqlcppconn8的时候，如果不禁用会报编译错误</li></ol><hr><center><a href="https://blog.csdn.net/albertsh/article/details/109553923" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>有你，真好~</p><p>2020-11-15 23:55:35</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;在 Windows上开发我使用最多的IDE还是 Visual Studio，编写、编译一条龙服务，导致了不少编译流程知识的缺失，这种大型的I
      
    
    </summary>
    
      <category term="linux" scheme="http://AlbertGithubHome.github.io/blog/categories/linux/"/>
    
    
      <category term="C++" scheme="http://AlbertGithubHome.github.io/blog/tags/C/"/>
    
      <category term="linux" scheme="http://AlbertGithubHome.github.io/blog/tags/linux/"/>
    
      <category term="编译" scheme="http://AlbertGithubHome.github.io/blog/tags/%E7%BC%96%E8%AF%91/"/>
    
      <category term="cmake" scheme="http://AlbertGithubHome.github.io/blog/tags/cmake/"/>
    
  </entry>
  
  <entry>
    <title>linux环境下sed命令的基础用法</title>
    <link href="http://AlbertGithubHome.github.io/blog/2020/11/07/linux%E7%8E%AF%E5%A2%83%E4%B8%8Bsed%E5%91%BD%E4%BB%A4%E7%9A%84%E5%9F%BA%E7%A1%80%E7%94%A8%E6%B3%95/"/>
    <id>http://AlbertGithubHome.github.io/blog/2020/11/07/linux环境下sed命令的基础用法/</id>
    <published>2020-11-07T06:37:04.000Z</published>
    <updated>2020-11-07T15:11:06.471Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>每次看到sed这个词就想起“种子”，心里明知道是把它和seed弄混了，但是先入为主的思想怕是改不过来了，不过现在还好，虽然把第一印象的意思弄错了，但还是很快能反应过来这是一个很“厉害”的linux命令，也有一些网友评论到，每次看到这个命令就双腿发抖，我虽然没抖，但是谈到这个命令还是有些挠头，心里有些发怵。</p><p>一味地逃避困难是不可取的，虽然心里感觉这是个很难的命令，但是今天还是要硬着头皮学一下，边学边记录，易于下次复习，那些打败不了我的困难终将使我更加强大。</p><h1 id="sed功能"><a href="#sed功能" class="headerlink" title="sed功能"></a>sed功能</h1><p>其实sed并不是一个单词，而是 stream editor 的缩写，本意为面向字符流的编辑器，说白了sed就是用来编辑文件的命令，编辑文件是我们每天经常做的工作，但是如果每天的编辑工作都类似，我们就要考虑使用sed工具来提高工作效率了，比如说把今天新增的100个文件的第一行都加上版本信息，虽然手动编辑也能做，但是你想体验一下敲个命令瞬间搞定这件事情的快感吗，我们来学习sed命令吧？</p><h2 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed [OPTION]... &#123;script-only-if-no-other-script&#125; [input-file]</span><br></pre></td></tr></table></figure><p>sed 的选项不是太多，最常用的有下面两种形式：</p><ul><li><code>sed -e &#39;sed命令脚本&#39; input-file</code></li><li><code>sed -f &#39;sed命令脚本文件&#39; input-file</code></li></ul><h2 id="命令选项"><a href="#命令选项" class="headerlink" title="命令选项"></a>命令选项</h2><ul><li><strong>-e</strong> ：命令行模式，选项后直接跟sed编辑脚本，在只有一组脚本的情况下可以省略</li><li><strong>-f</strong> ：脚本文件模式，选项后跟写有sed编辑脚本的文件名，运行后会执行脚本文件内的编辑动作</li><li><strong>-i</strong> ：直接修改文件内容，如果不加这个选项是不修改源文件的，只将修改后的文件输出</li><li><strong>-n</strong> ：只打印模式匹配的行，便于查看所作修改</li></ul><p>以上列举只是一些常见选项，还有些比如 <code>-l</code> 指定每行长度，<code>-s</code> 指定换行的分隔符等等，用到了再来分析学习。</p><h2 id="寻找匹配"><a href="#寻找匹配" class="headerlink" title="寻找匹配"></a>寻找匹配</h2><p>既然是编辑文件，首先要找到需要编辑的位置，在sed命令中可以使用行号，或者字符查找等方式找到需要修改的位置，然后再执行编辑动作，常见的范围：</p><ul><li><strong>x</strong>：指定的行号，表示第x行</li><li><strong>x,y</strong>：指定的行号范围，表示第x行到y行</li><li><strong>/pattern</strong>：查询到包含指定模式的行</li><li><strong>x,y!</strong>：指定的行号范围，表示不包括第x行到y行</li></ul><h1 id="sed操作"><a href="#sed操作" class="headerlink" title="sed操作"></a>sed操作</h1><p>sed几乎可以实现文件的所有编辑工作，接下来尝试一些常见的用法：</p><h2 id="打印内容"><a href="#打印内容" class="headerlink" title="打印内容"></a>打印内容</h2><p>使用编辑命令 <code>p</code>，可以向匹配行后面插入内容。</p><ul><li>打印文件第2行和第3行的内容，命令为<code>sed -n &#39;2,3p&#39; data.txt</code></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">albert@DESKTOP-6746UC3:/mnt/d/data/shell$ cat data.txt</span><br><span class="line">1234</span><br><span class="line">abc</span><br><span class="line">xyz</span><br><span class="line">1==</span><br><span class="line">123</span><br><span class="line">albert@DESKTOP-6746UC3:/mnt/d/data/shell$ sed -n <span class="string">'2,3p'</span> data.txt</span><br><span class="line">abc</span><br><span class="line">xyz</span><br></pre></td></tr></table></figure><h2 id="追加内容"><a href="#追加内容" class="headerlink" title="追加内容"></a>追加内容</h2><p>使用编辑命令 <code>a</code>，可以向匹配行后面插入内容。</p><ul><li>在第2行后面添加文本<code>newline</code>，命令为<code>sed &#39;2anewline&#39; data.txt</code></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">albert@DESKTOP-6746UC3:/mnt/d/data/shell$ cat data.txt</span><br><span class="line">1234</span><br><span class="line">abc</span><br><span class="line">xyz</span><br><span class="line">1==</span><br><span class="line">123</span><br><span class="line">albert@DESKTOP-6746UC3:/mnt/d/data/shell$ sed <span class="string">'2anewline'</span> data.txt</span><br><span class="line">1234</span><br><span class="line">abc</span><br><span class="line">newline</span><br><span class="line">xyz</span><br><span class="line">1==</span><br><span class="line">123</span><br></pre></td></tr></table></figure><ul><li>在最后一行后面添加文本<code>endline</code>，命令为<code>sed &#39;$aendline&#39; data.txt</code></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">albert@DESKTOP-6746UC3:/mnt/d/data/shell$ cat data.txt</span><br><span class="line">1234</span><br><span class="line">abc</span><br><span class="line">xyz</span><br><span class="line">1==</span><br><span class="line">123</span><br><span class="line">albert@DESKTOP-6746UC3:/mnt/d/data/shell$ sed <span class="string">'$aendline'</span> data.txt</span><br><span class="line">1234</span><br><span class="line">abc</span><br><span class="line">xyz</span><br><span class="line">1==</span><br><span class="line">123</span><br><span class="line">endline</span><br><span class="line">albert@DESKTOP-6746UC3:/mnt/d/data/shell$</span><br></pre></td></tr></table></figure><h2 id="插入内容"><a href="#插入内容" class="headerlink" title="插入内容"></a>插入内容</h2><p>使用编辑命令 <code>i</code>，可以在匹配的那一行插入内容。</p><ul><li>在第1行插入文本<code>firstline</code>，命令为<code>sed &#39;1ifirstline&#39; data.txt</code></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">albert@DESKTOP-6746UC3:/mnt/d/data/shell$ cat data.txt</span><br><span class="line">1234</span><br><span class="line">abc</span><br><span class="line">xyz</span><br><span class="line">1==</span><br><span class="line">123</span><br><span class="line">albert@DESKTOP-6746UC3:/mnt/d/data/shell$ sed <span class="string">'1ifirstline'</span> data.txt</span><br><span class="line">firstline</span><br><span class="line">1234</span><br><span class="line">abc</span><br><span class="line">xyz</span><br><span class="line">1==</span><br><span class="line">123</span><br></pre></td></tr></table></figure><ul><li>在包含文本 “123” 的行插入文本<code>insertline</code>，命令为<code>sed &#39;/123/iinsertline&#39; data.txt</code></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">albert@DESKTOP-6746UC3:/mnt/d/data/shell$ cat data.txt</span><br><span class="line">1234</span><br><span class="line">abc</span><br><span class="line">xyz</span><br><span class="line">1==</span><br><span class="line">123</span><br><span class="line">albert@DESKTOP-6746UC3:/mnt/d/data/shell$ sed <span class="string">'/123/iinsertline'</span> data.txt</span><br><span class="line">insertline</span><br><span class="line">1234</span><br><span class="line">abc</span><br><span class="line">xyz</span><br><span class="line">1==</span><br><span class="line">insertline</span><br><span class="line">123</span><br></pre></td></tr></table></figure><h2 id="更改行内容"><a href="#更改行内容" class="headerlink" title="更改行内容"></a>更改行内容</h2><p>使用编辑命令 <code>c</code>，可以修改匹配行的内容。</p><ul><li>将包含文本 “123” 的行替换为 “456”，命令为<code>sed &#39;/123/c456&#39; data.txt</code></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">albert@DESKTOP-6746UC3:/mnt/d/data/shell$ cat data.txt</span><br><span class="line">1234</span><br><span class="line">abc</span><br><span class="line">xyz</span><br><span class="line">1==</span><br><span class="line">123</span><br><span class="line">albert@DESKTOP-6746UC3:/mnt/d/data/shell$ sed <span class="string">'/123/c456'</span> data.txt</span><br><span class="line">456</span><br><span class="line">abc</span><br><span class="line">xyz</span><br><span class="line">1==</span><br><span class="line">456</span><br></pre></td></tr></table></figure><ul><li>将3、4、5行内容更改为newworld，命令为<code>sed &#39;3,5cneworld&#39; data.txt</code></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">albert@DESKTOP-6746UC3:/mnt/d/data/shell$ cat data.txt</span><br><span class="line">1234</span><br><span class="line">abc</span><br><span class="line">xyz</span><br><span class="line">1==</span><br><span class="line">123</span><br><span class="line">albert@DESKTOP-6746UC3:/mnt/d/data/shell$ sed <span class="string">'3,5cneworld'</span> data.txt</span><br><span class="line">1234</span><br><span class="line">abc</span><br><span class="line">neworld</span><br></pre></td></tr></table></figure><h2 id="替换行内容"><a href="#替换行内容" class="headerlink" title="替换行内容"></a>替换行内容</h2><p>使用编辑命令 <code>s</code>，可以替换匹配行的内容，需要注意和 <code>c</code> 的区别，<code>c</code> 是整行的内容都改变，而 <code>s</code> 是只替换命令中指定的部分。</p><ul><li>将文件中的文本 “123” 替换为 “456”，命令为<code>sed &#39;s/123/456/g&#39; data.txt</code></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">albert@DESKTOP-6746UC3:/mnt/d/data/shell$ cat data.txt</span><br><span class="line">1234</span><br><span class="line">abc</span><br><span class="line">xyz</span><br><span class="line">1==</span><br><span class="line">123</span><br><span class="line">albert@DESKTOP-6746UC3:/mnt/d/data/shell$ sed <span class="string">'s/123/456/g'</span> data.txt</span><br><span class="line">4564</span><br><span class="line">abc</span><br><span class="line">xyz</span><br><span class="line">1==</span><br><span class="line">456</span><br></pre></td></tr></table></figure><h1 id="综合运用"><a href="#综合运用" class="headerlink" title="综合运用"></a>综合运用</h1><ul><li>删除空行并给所有内容是 “123” 的文本加上小括号</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">albert@DESKTOP-6746UC3:/mnt/d/data/shell$ cat data.txt</span><br><span class="line">1234</span><br><span class="line">abc</span><br><span class="line">xyz</span><br><span class="line"></span><br><span class="line">1==</span><br><span class="line">123</span><br><span class="line">albert@DESKTOP-6746UC3:/mnt/d/data/shell$ sed -e <span class="string">'s/123/(&amp;)/g'</span> -e <span class="string">'/^$/d'</span> data.txt</span><br><span class="line">(123)4</span><br><span class="line">abc</span><br><span class="line">xyz</span><br><span class="line">1==</span><br><span class="line">(123)</span><br></pre></td></tr></table></figure><h2 id="删除内容"><a href="#删除内容" class="headerlink" title="删除内容"></a>删除内容</h2><p>使用编辑命令 <code>c</code>，可以删除匹配行。</p><ul><li>删除空行，命令为<code>sed &#39;/^$/d&#39; data.txt</code></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">albert@DESKTOP-6746UC3:/mnt/d/data/shell$ cat data.txt</span><br><span class="line">1234</span><br><span class="line"></span><br><span class="line">abc</span><br><span class="line">xyz</span><br><span class="line">1==</span><br><span class="line">123</span><br><span class="line">albert@DESKTOP-6746UC3:/mnt/d/data/shell$ sed <span class="string">'/^$/d'</span> data.txt</span><br><span class="line">1234</span><br><span class="line">abc</span><br><span class="line">xyz</span><br><span class="line">1==</span><br><span class="line">123</span><br></pre></td></tr></table></figure><ul><li>从第一行开始，每两行删除掉一行，命令为<code>sed &#39;1~2d&#39; data.txt</code></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">albert@DESKTOP-6746UC3:/mnt/d/data/shell$ cat data.txt</span><br><span class="line">1234</span><br><span class="line">abc</span><br><span class="line">xyz</span><br><span class="line">1==</span><br><span class="line">123</span><br><span class="line">albert@DESKTOP-6746UC3:/mnt/d/data/shell$ sed <span class="string">'1~2d'</span> data.txt</span><br><span class="line">abc</span><br><span class="line">1==</span><br></pre></td></tr></table></figure><ul><li>删除2行和3行以外的行，命令为<code>sed &#39;2,3!d&#39; data.txt</code></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">albert@DESKTOP-6746UC3:/mnt/d/data/shell$ cat data.txt</span><br><span class="line">1234</span><br><span class="line">abc</span><br><span class="line">xyz</span><br><span class="line">1==</span><br><span class="line">123</span><br><span class="line">albert@DESKTOP-6746UC3:/mnt/d/data/shell$ sed <span class="string">'2,3!d'</span> data.txt</span><br><span class="line">abc</span><br><span class="line">xyz</span><br></pre></td></tr></table></figure><ul><li>删除指定行数范围内的匹配行，命令为<code>sed &#39;1,3{/123/d}&#39; data.txt</code></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">albert@DESKTOP-6746UC3:/mnt/d/data/shell$ cat data.txt</span><br><span class="line">1234</span><br><span class="line">abc</span><br><span class="line">xyz</span><br><span class="line">1==</span><br><span class="line">123</span><br><span class="line">albert@DESKTOP-6746UC3:/mnt/d/data/shell$ sed <span class="string">'1,3&#123;/123/d&#125;'</span> data.txt</span><br><span class="line">abc</span><br><span class="line">xyz</span><br><span class="line">1==</span><br><span class="line">123</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li><code>sed</code> 是 stream editor 的缩写，表示为面向字符流的编辑器</li><li><code>sed</code> 命令常用的几个选项，<code>-e</code>、<code>-f</code>、<code>-i</code>、<code>-n</code></li><li><code>sed</code> 命令常用的几个编辑动作，也就是选项后的常用命令有 <code>p（打印）</code>、<code>a（追加）</code>、<code>i（插入）</code>、<code>c（改变）</code>、<code>s（替换）</code>、<code>d（删除）</code></li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/109267664" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>不能打败我的困难终将使我更加强大，绊不倒我的石头最后只会被拿来踩踏，拥抱一个个困难，生活本来就是一条打怪升级之路，那有什么一帆风顺~</p><p>2020-11-7 22:47:01</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;每次看到sed这个词就想起“种子”，心里明知道是把它和seed弄混了，但是先入为主的思想怕是改不过来了，不过现在还好，虽然把第一印象的意思弄
      
    
    </summary>
    
      <category term="linux" scheme="http://AlbertGithubHome.github.io/blog/categories/linux/"/>
    
    
      <category term="linux" scheme="http://AlbertGithubHome.github.io/blog/tags/linux/"/>
    
      <category term="sed" scheme="http://AlbertGithubHome.github.io/blog/tags/sed/"/>
    
      <category term="文件" scheme="http://AlbertGithubHome.github.io/blog/tags/%E6%96%87%E4%BB%B6/"/>
    
      <category term="编辑" scheme="http://AlbertGithubHome.github.io/blog/tags/%E7%BC%96%E8%BE%91/"/>
    
  </entry>
  
  <entry>
    <title>关于数据一致性的思考</title>
    <link href="http://AlbertGithubHome.github.io/blog/2020/10/24/%E5%85%B3%E4%BA%8E%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7%E7%9A%84%E6%80%9D%E8%80%83/"/>
    <id>http://AlbertGithubHome.github.io/blog/2020/10/24/关于数据一致性的思考/</id>
    <published>2020-10-24T14:11:21.000Z</published>
    <updated>2020-10-25T16:28:58.522Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>也不知道是谁这么有才，居然发明了1024这个程序员的节日，其他的节日都是买买买，唯独这个节日促销活动少的可怜，连早上买菜都是占了第二天重阳节的便宜，除了程序员们自嗨，也没人来给码农们庆祝了。</p><a id="more"></a><p>今天也嗨了一把，程序员的节日必须在工位上，飞速的敲着代码才是对1024最大的尊重，在这一天的结尾之际还是聊聊最近开发中的一些问题，其中数据一致性的问题确实需要梳理一下。</p><h1 id="什么是一致性"><a href="#什么是一致性" class="headerlink" title="什么是一致性"></a>什么是一致性</h1><p>关于一致性常常在两个地方听到，一个是数据库，另一个是分布式，两者都叫一致性，但是含义却不同。</p><h2 id="数据库一致性"><a href="#数据库一致性" class="headerlink" title="数据库一致性"></a>数据库一致性</h2><p>数据库中的一致性其实代表不破坏完整性，所有的数据从一个状态转化到另一个状态时不发生逻辑问题，比如说A通过手机银行给B转了100万，这件事情发生后A账户少了100万，B账户多了100万，这样就保证了数据的一致，如果转账结束A账户的钱少了100万，B账户却只多了100块，那完蛋了，A和B肯定一起去找银行打架去了。</p><h2 id="分布式一致性"><a href="#分布式一致性" class="headerlink" title="分布式一致性"></a>分布式一致性</h2><p>很多资料对于分布式一致性理解的都是数据冗余副本，当所有副本的数据一样时，那么此时的状态就是一致的。按照我自己的理解，这里的冗余副本不一定指的是数据形式完全一样，比如玩家在游戏服拥有金币资产200万，然后全服排行榜上的展示面板上显示资产也是200万，可能具体数据的形式不同，但这应该也是一种数据一致性的表现。</p><p>两个概念容易混淆，因为经常在分布式的架构下更新数据库，两种一致性也常常在同一个操作中有所体现。其实我也经常混着用，反正知道这个意思就好了，最近遇到的问题也是两个概念的集合，不过还是先来理解一下分布式的一致性吧</p><h1 id="分布式一致性分类"><a href="#分布式一致性分类" class="headerlink" title="分布式一致性分类"></a>分布式一致性分类</h1><ul><li><strong>强一致性：</strong> 要求无论更新操作是在哪一个节点副本上执行，之后获取的数据都是最新的。</li><li><strong>弱一致性：</strong> 能容忍部分或全部节点都看不到最新数据，数据改变时尽量通知可能多的节点。</li><li><strong>最终一致性：</strong> 是弱一致性的一种特例表现，需要保证用户最终能够读取到最新的数据。</li></ul><p>我们当然希望能实现强一致性，但这样需要付出相当大的代价，往往要通过牺牲可用性才能达到。</p><h1 id="一致性的保证"><a href="#一致性的保证" class="headerlink" title="一致性的保证"></a>一致性的保证</h1><p>如果要想达到强一致性，那么就得保证任何数据在改变之后必须通知所有节点，等待所有节点更新完毕后才能给用户提供服，这就要在开始更新时加一把大锁，先锁住数据，等待所有节点完成更新时释放锁，这样才能提供数据的强一致性保证。</p><p>如果节点太多的话，这个锁的机制将会消耗大量的时间来等待，可能导致应用长时间不能提供正常服务，在一些应用上显然是不合适的，所以是否要保证强一致性需要根据具体的业务逻辑来选择。</p><p>还有一个经常听到的观点就是在分布式系统中一致性和可用性我们只能选择一个，这一般是从CAP理论中得到的结论，但是这样说是不准确的，关于CAP理论最初版的大意为：“对于一个分布式计算系统，不可能同时满足一致性（Consistence）、可用性（Availability）、分区容错性（Partition Tolerance ）三个设计约束”。</p><p>通过CAP理论告诉我们分布式系统只能选择CP或者AP，但其实这里的前提是分布式系统发生了“分区”现象。如果当前系统没有发生分区现象，我们没有必要放弃C或者A，应该C和A都可以保证。</p><p>还有一点个人的理解，由于数据传输是需要时间的，那么当一个节点修改了数据同步到另一个节点时不可能瞬间完成，所以数据不一致总是时刻存在，而我们前面提到的数据一致总是指对用户而言的，虽然数据在传输过程中是不一致的，但是我们可以规定在数据完成同步前，用户看到的都是旧数据，这样就对用户而言数据就是一致的。</p><p>而数据同步过程中的不一致，如果在不一致期间还发生了中断、崩溃等问题，就必须通过日志来恢复了，个人觉得，总是有那么一种极限情况，连日志都救不了你，毕竟记录日志的也是一种程序，但是这类事情发生的概率也比较小了。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>程序世界的一致性常常指数据库中的一致性和分布式中的一致性</li><li>CAP理论告诉我们分布式系统在发生了分区现象时，才需要选择CP或者AP，否则应该可以保证CA</li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/109145949" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>欲穷千里目，更上一层楼。最近越来越发现古诗的精妙之处了，随着阅历的增加，之前背诵的古诗有些突然就明白了，不知道应该开心还是难过~</p><p>2020-10-26 00:27:02</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;也不知道是谁这么有才，居然发明了1024这个程序员的节日，其他的节日都是买买买，唯独这个节日促销活动少的可怜，连早上买菜都是占了第二天重阳节的便宜，除了程序员们自嗨，也没人来给码农们庆祝了。&lt;/p&gt;
    
    </summary>
    
      <category term="Thinking" scheme="http://AlbertGithubHome.github.io/blog/categories/Thinking/"/>
    
    
      <category term="游戏" scheme="http://AlbertGithubHome.github.io/blog/tags/%E6%B8%B8%E6%88%8F/"/>
    
      <category term="架构设计" scheme="http://AlbertGithubHome.github.io/blog/tags/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    
      <category term="一致性" scheme="http://AlbertGithubHome.github.io/blog/tags/%E4%B8%80%E8%87%B4%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>linux环境下使用sort命令完成常见排序操作</title>
    <link href="http://AlbertGithubHome.github.io/blog/2020/10/14/linux%E7%8E%AF%E5%A2%83%E4%B8%8B%E4%BD%BF%E7%94%A8sort%E5%91%BD%E4%BB%A4%E5%AE%8C%E6%88%90%E5%B8%B8%E8%A7%81%E6%8E%92%E5%BA%8F%E6%93%8D%E4%BD%9C/"/>
    <id>http://AlbertGithubHome.github.io/blog/2020/10/14/linux环境下使用sort命令完成常见排序操作/</id>
    <published>2020-10-14T15:46:28.000Z</published>
    <updated>2020-10-18T07:58:34.656Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>linux 系统下的命令常常给人一种短小精悍的感觉，使用起来就像一把把锋利的小刀，在自己专注的领域做到极致，今天要聊的就是 linux 环境下的排序命令 <code>sort</code>，处理文本按列排序非常方便，最近使用 <code>sort</code>命令来排序日志查找问题，为了防止一段时间不用又会忘记，所以记录下来便于下次查找。</p><h1 id="命令作用"><a href="#命令作用" class="headerlink" title="命令作用"></a>命令作用</h1><p><code>sort</code> 命令默认会将待排序内容以空格划分为多个列，然后对内容进行按列排序，命令本身不会修改待排序内容，而是将排序结果重新输出，如果想修改待排序源文件的内容，可以通过重定向命令来实现。</p><p>命令格式为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sort [选项] 文件名</span><br></pre></td></tr></table></figure><h1 id="常见选项"><a href="#常见选项" class="headerlink" title="常见选项"></a>常见选项</h1><p><code>sort</code> 作为一个强大的命令，参数选项还挺多的，不过我只列举一些常见的参数，方便日常使用即可。</p><ul><li><strong>-k：</strong> 指定排序依据的列数，可以分多次指定</li><li><strong>-o：</strong> 将排序后的结果存入指定文件</li><li><strong>-c：</strong> 检查指定文件是否已经排好序</li><li><strong>-u：</strong> 删除所有重复行</li><li><strong>-b：</strong> 忽略每行或字段前面开始出的空格字符</li><li><strong>-f：</strong> 排序比较时忽略大小写</li><li><strong>-n：</strong> 转化为数字，按照数值的大小排序</li><li><strong>-r：</strong> 反向排序，从大到小</li><li><strong>-t：</strong> 指定排序时划分列数的分隔字符</li></ul><h1 id="数据文件"><a href="#数据文件" class="headerlink" title="数据文件"></a>数据文件</h1><p>为了展示 <code>sort</code> 命令的作用，专门利用 <code>ls</code> 命令产生了一段数据，并保存在了 data.txt 文件中，之后会利用这个文件来展示 <code>sort</code> 的用法，文件内容展示如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:~$ cat data.txt</span><br><span class="line">-rwxrwxr-x 1 albert albert  9272 Jul 18 22:27 a.out*</span><br><span class="line">-rw------- 1 albert albert  7064 Oct 17 22:14 .bash_history</span><br><span class="line">-rw-r--r-- 1 albert albert   220 Jul 16 00:52 .bash_logout</span><br><span class="line">-rw-r--r-- 1 albert albert  3771 Jul 16 00:52 .bashrc</span><br><span class="line">drwxrwxrwx 1 albert albert  4096 Jul 16 01:10 .cache/</span><br><span class="line">drwx------ 1 albert albert  4096 Jul 16 00:52 .config/</span><br><span class="line">-rw------- 1 albert albert    35 Jul 19 14:14 .lesshst</span><br><span class="line">-rwxrwxr-x 1 albert albert 20328 Jul 18 19:49 mainpro*</span><br><span class="line">-rw-rw-r-- 1 albert albert   195 Jul 18 22:27 mainpro.cpp</span><br><span class="line">-rw-r--r-- 1 albert albert   655 Jul 16 00:52 .profile</span><br><span class="line">-rw-r--r-- 1 albert albert     0 Jul 16 00:52 .sudo_as_admin_successful</span><br><span class="line">-rw------- 1 root   root    2257 Jul 16 01:10 .viminfo</span><br><span class="line">drwxrwxrwx 1 albert albert  4096 Jul 19 21:19 .vscode-server/</span><br><span class="line">-rw------- 1 albert albert    61 Sep 20 09:42 .Xauthority</span><br></pre></td></tr></table></figure><p>这个文件中的内容在使用 <code>sort</code> 命令排序时默认以空格分割，所以共有9列，在指定列数时从1开始，接下来我们用这些数据来测试一下排序命令的用法。</p><h1 id="核心参数"><a href="#核心参数" class="headerlink" title="核心参数"></a>核心参数</h1><p>对于我来说 <code>sort</code> 命令的核心参数是 <code>-k</code>，其完整的参数列表为 <code>-k START_F[.START_C][OPTIONS][,END_F[.END_C][OPTIONS]]</code>，参数列表很长，但是不要恐惧，逐步分析就可以了。</p><p><code>-k</code> 后面这已打算都是用来指定排序依据的范围的，其中 <code>START_F</code> 和 <code>END_F</code> 表示开始和结束的字段，也就是列数，<code>.START_C</code> 和 <code>.END_C</code> 表示指定字段开始和结束的字符数，<code>OPTIONS</code> 是由一个或多个单个字母排序的选项[bdfgiMhnRrV]，这些选项中常用的已经列举在前面了，写在此处的选项会覆盖全局排序选项。</p><p>这样文字叙述有些枯燥，可以看下这个参数 <code>-k 6.2b,6.3b</code>，这个排序选项的含义是把内容按照第6列的第2个字符到第6列的第3个字符排序，查找字符位置的时候要去掉前面的空白。</p><h1 id="用法展示"><a href="#用法展示" class="headerlink" title="用法展示"></a>用法展示</h1><p>看了以上的参数可能还是不太清楚具体怎样用，所以举了下面这些例子，可以方便的处理常用的排序工作。</p><h2 id="按照指定列排序"><a href="#按照指定列排序" class="headerlink" title="按照指定列排序"></a>按照指定列排序</h2><p>这是最普通的排序要求了，也是我用的最多的情况，需要使用-k参数</p><ul><li>按照第3列排序</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:~$ sort -k3,3 data.txt</span><br><span class="line">drwx------ 1 albert albert  4096 Jul 16 00:52 .config/</span><br><span class="line">drwxrwxrwx 1 albert albert  4096 Jul 16 01:10 .cache/</span><br><span class="line">drwxrwxrwx 1 albert albert  4096 Jul 19 21:19 .vscode-server/</span><br><span class="line">-rw------- 1 albert albert    35 Jul 19 14:14 .lesshst</span><br><span class="line">-rw------- 1 albert albert    61 Sep 20 09:42 .Xauthority</span><br><span class="line">-rw------- 1 albert albert  7064 Oct 17 22:14 .bash_history</span><br><span class="line">-rw-r--r-- 1 albert albert     0 Jul 16 00:52 .sudo_as_admin_successful</span><br><span class="line">-rw-r--r-- 1 albert albert   220 Jul 16 00:52 .bash_logout</span><br><span class="line">-rw-r--r-- 1 albert albert  3771 Jul 16 00:52 .bashrc</span><br><span class="line">-rw-r--r-- 1 albert albert   655 Jul 16 00:52 .profile</span><br><span class="line">-rw-rw-r-- 1 albert albert   195 Jul 18 22:27 mainpro.cpp</span><br><span class="line">-rwxrwxr-x 1 albert albert 20328 Jul 18 19:49 mainpro*</span><br><span class="line">-rwxrwxr-x 1 albert albert  9272 Jul 18 22:27 a.out*</span><br><span class="line">-rw------- 1 root   root    2257 Jul 16 01:10 .viminfo</span><br></pre></td></tr></table></figure><blockquote><p>root 已经被排到了所有albert的后面</p></blockquote><h2 id="将排序结果存入指定文件"><a href="#将排序结果存入指定文件" class="headerlink" title="将排序结果存入指定文件"></a>将排序结果存入指定文件</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:~$ sort -k3,3 data.txt -o dst.txt</span><br><span class="line">albert@home-pc:~$ cat dst.txt</span><br><span class="line">drwx------ 1 albert albert  4096 Jul 16 00:52 .config/</span><br><span class="line">drwxrwxrwx 1 albert albert  4096 Jul 16 01:10 .cache/</span><br><span class="line">drwxrwxrwx 1 albert albert  4096 Jul 19 21:19 .vscode-server/</span><br><span class="line">-rw------- 1 albert albert    35 Jul 19 14:14 .lesshst</span><br><span class="line">-rw------- 1 albert albert    61 Sep 20 09:42 .Xauthority</span><br><span class="line">-rw------- 1 albert albert  7064 Oct 17 22:14 .bash_history</span><br><span class="line">-rw-r--r-- 1 albert albert     0 Jul 16 00:52 .sudo_as_admin_successful</span><br><span class="line">-rw-r--r-- 1 albert albert   220 Jul 16 00:52 .bash_logout</span><br><span class="line">-rw-r--r-- 1 albert albert  3771 Jul 16 00:52 .bashrc</span><br><span class="line">-rw-r--r-- 1 albert albert   655 Jul 16 00:52 .profile</span><br><span class="line">-rw-rw-r-- 1 albert albert   195 Jul 18 22:27 mainpro.cpp</span><br><span class="line">-rwxrwxr-x 1 albert albert 20328 Jul 18 19:49 mainpro*</span><br><span class="line">-rwxrwxr-x 1 albert albert  9272 Jul 18 22:27 a.out*</span><br><span class="line">-rw------- 1 root   root    2257 Jul 16 01:10 .viminfo</span><br></pre></td></tr></table></figure><blockquote><p>排序结果已经被存储到了文件 dst.txt 中，其实这个命令还可以改写成 <code>sort data.txt &gt; dst.txt</code></p></blockquote><h2 id="查看文件是否已经排序好"><a href="#查看文件是否已经排序好" class="headerlink" title="查看文件是否已经排序好"></a>查看文件是否已经排序好</h2><ul><li>测试没排好序的文件</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:~$ sort -k3,3 data.txt -c</span><br><span class="line">sort: data.txt:2: disorder: -rw------- 1 albert albert  7064 Oct 17 22:14 .bash_history</span><br></pre></td></tr></table></figure><ul><li>测试已经排序的文件</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:~$ sort -k3,3 dst.txt -c</span><br><span class="line">albert@home-pc:~$</span><br></pre></td></tr></table></figure><blockquote><p>对于已经拍好序的文件使用 -c 参数没有任何输出，如果是未排序的文件则会给出提示</p></blockquote><h2 id="去掉排序结果中的重复行"><a href="#去掉排序结果中的重复行" class="headerlink" title="去掉排序结果中的重复行"></a>去掉排序结果中的重复行</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:~$ sort -k3,3 data.txt -u</span><br><span class="line">-rwxrwxr-x 1 albert albert  9272 Jul 18 22:27 a.out*</span><br><span class="line">-rw------- 1 root   root    2257 Jul 16 01:10 .viminfo</span><br></pre></td></tr></table></figure><blockquote><p>这里的重复行参考是你指定排序依据的列数，也就是第3列如果重复就会认为是重复行，结果中只能出现一次</p></blockquote><h2 id="按照数值结果进行排序"><a href="#按照数值结果进行排序" class="headerlink" title="按照数值结果进行排序"></a>按照数值结果进行排序</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:~$ sort -k5n,5 data.txt</span><br><span class="line">-rw-r--r-- 1 albert albert     0 Jul 16 00:52 .sudo_as_admin_successful</span><br><span class="line">-rw------- 1 albert albert    35 Jul 19 14:14 .lesshst</span><br><span class="line">-rw------- 1 albert albert    61 Sep 20 09:42 .Xauthority</span><br><span class="line">-rw-rw-r-- 1 albert albert   195 Jul 18 22:27 mainpro.cpp</span><br><span class="line">-rw-r--r-- 1 albert albert   220 Jul 16 00:52 .bash_logout</span><br><span class="line">-rw-r--r-- 1 albert albert   655 Jul 16 00:52 .profile</span><br><span class="line">-rw------- 1 root   root    2257 Jul 16 01:10 .viminfo</span><br><span class="line">-rw-r--r-- 1 albert albert  3771 Jul 16 00:52 .bashrc</span><br><span class="line">drwx------ 1 albert albert  4096 Jul 16 00:52 .config/</span><br><span class="line">drwxrwxrwx 1 albert albert  4096 Jul 16 01:10 .cache/</span><br><span class="line">drwxrwxrwx 1 albert albert  4096 Jul 19 21:19 .vscode-server/</span><br><span class="line">-rw------- 1 albert albert  7064 Oct 17 22:14 .bash_history</span><br><span class="line">-rwxrwxr-x 1 albert albert  9272 Jul 18 22:27 a.out*</span><br><span class="line">-rwxrwxr-x 1 albert albert 20328 Jul 18 19:49 mainpro*</span><br></pre></td></tr></table></figure><blockquote><p>这里使用了 -k5n,5 作为排序选项，其中的 n 表示以数值方式排序，如果不加 n 的排序结果如下：</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:~$ sort -k5,5 data.txt</span><br><span class="line">-rw-r--r-- 1 albert albert     0 Jul 16 00:52 .sudo_as_admin_successful</span><br><span class="line">-rw-rw-r-- 1 albert albert   195 Jul 18 22:27 mainpro.cpp</span><br><span class="line">-rwxrwxr-x 1 albert albert 20328 Jul 18 19:49 mainpro*</span><br><span class="line">-rw-r--r-- 1 albert albert   220 Jul 16 00:52 .bash_logout</span><br><span class="line">-rw------- 1 root   root    2257 Jul 16 01:10 .viminfo</span><br><span class="line">-rw------- 1 albert albert    35 Jul 19 14:14 .lesshst</span><br><span class="line">-rw-r--r-- 1 albert albert  3771 Jul 16 00:52 .bashrc</span><br><span class="line">drwx------ 1 albert albert  4096 Jul 16 00:52 .config/</span><br><span class="line">drwxrwxrwx 1 albert albert  4096 Jul 16 01:10 .cache/</span><br><span class="line">drwxrwxrwx 1 albert albert  4096 Jul 19 21:19 .vscode-server/</span><br><span class="line">-rw------- 1 albert albert    61 Sep 20 09:42 .Xauthority</span><br><span class="line">-rw-r--r-- 1 albert albert   655 Jul 16 00:52 .profile</span><br><span class="line">-rw------- 1 albert albert  7064 Oct 17 22:14 .bash_history</span><br><span class="line">-rwxrwxr-x 1 albert albert  9272 Jul 18 22:27 a.out*</span><br></pre></td></tr></table></figure><blockquote><p>数据看起来很乱，其实也是按照第5列排好序的，仔细分析你会发现是把这些数字当成字符串排的序</p></blockquote><h2 id="反向排序"><a href="#反向排序" class="headerlink" title="反向排序"></a>反向排序</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:~$ sort -k3,3 data.txt -r</span><br><span class="line">-rw------- 1 root   root    2257 Jul 16 01:10 .viminfo</span><br><span class="line">-rwxrwxr-x 1 albert albert  9272 Jul 18 22:27 a.out*</span><br><span class="line">-rwxrwxr-x 1 albert albert 20328 Jul 18 19:49 mainpro*</span><br><span class="line">-rw-rw-r-- 1 albert albert   195 Jul 18 22:27 mainpro.cpp</span><br><span class="line">-rw-r--r-- 1 albert albert   655 Jul 16 00:52 .profile</span><br><span class="line">-rw-r--r-- 1 albert albert  3771 Jul 16 00:52 .bashrc</span><br><span class="line">-rw-r--r-- 1 albert albert   220 Jul 16 00:52 .bash_logout</span><br><span class="line">-rw-r--r-- 1 albert albert     0 Jul 16 00:52 .sudo_as_admin_successful</span><br><span class="line">-rw------- 1 albert albert  7064 Oct 17 22:14 .bash_history</span><br><span class="line">-rw------- 1 albert albert    61 Sep 20 09:42 .Xauthority</span><br><span class="line">-rw------- 1 albert albert    35 Jul 19 14:14 .lesshst</span><br><span class="line">drwxrwxrwx 1 albert albert  4096 Jul 19 21:19 .vscode-server/</span><br><span class="line">drwxrwxrwx 1 albert albert  4096 Jul 16 01:10 .cache/</span><br><span class="line">drwx------ 1 albert albert  4096 Jul 16 00:52 .config/</span><br></pre></td></tr></table></figure><blockquote><p>按照第3列反向排序，root就排到了所有albert的前面</p></blockquote><h2 id="自定义分割字符"><a href="#自定义分割字符" class="headerlink" title="自定义分割字符"></a>自定义分割字符</h2><p><code>sort</code> 命令默认是以空格作为列的分割符号的，可以使用 <code>-t</code> 选项自定义分割符，比如我们使用 <code>:</code> 作为分隔符，然后以第二列进行排序</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:~$ sort -t <span class="string">":"</span> -k2,2 data.txt</span><br><span class="line">drwxrwxrwx 1 albert albert  4096 Jul 16 01:10 .cache/</span><br><span class="line">-rw------- 1 root   root    2257 Jul 16 01:10 .viminfo</span><br><span class="line">-rw------- 1 albert albert  7064 Oct 17 22:14 .bash_history</span><br><span class="line">-rw------- 1 albert albert    35 Jul 19 14:14 .lesshst</span><br><span class="line">drwxrwxrwx 1 albert albert  4096 Jul 19 21:19 .vscode-server/</span><br><span class="line">-rwxrwxr-x 1 albert albert  9272 Jul 18 22:27 a.out*</span><br><span class="line">-rw-rw-r-- 1 albert albert   195 Jul 18 22:27 mainpro.cpp</span><br><span class="line">-rw------- 1 albert albert    61 Sep 20 09:42 .Xauthority</span><br><span class="line">-rwxrwxr-x 1 albert albert 20328 Jul 18 19:49 mainpro*</span><br><span class="line">-rw-r--r-- 1 albert albert   220 Jul 16 00:52 .bash_logout</span><br><span class="line">-rw-r--r-- 1 albert albert  3771 Jul 16 00:52 .bashrc</span><br><span class="line">drwx------ 1 albert albert  4096 Jul 16 00:52 .config/</span><br><span class="line">-rw-r--r-- 1 albert albert   655 Jul 16 00:52 .profile</span><br><span class="line">-rw-r--r-- 1 albert albert     0 Jul 16 00:52 .sudo_as_admin_successful</span><br></pre></td></tr></table></figure><blockquote><p>结果是以分钟数进行的排序</p></blockquote><h1 id="综合排序"><a href="#综合排序" class="headerlink" title="综合排序"></a>综合排序</h1><p>学习了上面这么多参数，可以做一个综合的例子，以第6列的月份从小到大排序，以第5列文件大小逆序排列，通过组合上面的参数，可以使用下面的命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:~$ sort -k6,6 -k5rn,5 data.txt</span><br><span class="line">-rwxrwxr-x 1 albert albert 20328 Jul 18 19:49 mainpro*</span><br><span class="line">-rwxrwxr-x 1 albert albert  9272 Jul 18 22:27 a.out*</span><br><span class="line">drwx------ 1 albert albert  4096 Jul 16 00:52 .config/</span><br><span class="line">drwxrwxrwx 1 albert albert  4096 Jul 16 01:10 .cache/</span><br><span class="line">drwxrwxrwx 1 albert albert  4096 Jul 19 21:19 .vscode-server/</span><br><span class="line">-rw-r--r-- 1 albert albert  3771 Jul 16 00:52 .bashrc</span><br><span class="line">-rw------- 1 root   root    2257 Jul 16 01:10 .viminfo</span><br><span class="line">-rw-r--r-- 1 albert albert   655 Jul 16 00:52 .profile</span><br><span class="line">-rw-r--r-- 1 albert albert   220 Jul 16 00:52 .bash_logout</span><br><span class="line">-rw-rw-r-- 1 albert albert   195 Jul 18 22:27 mainpro.cpp</span><br><span class="line">-rw------- 1 albert albert    35 Jul 19 14:14 .lesshst</span><br><span class="line">-rw-r--r-- 1 albert albert     0 Jul 16 00:52 .sudo_as_admin_successful</span><br><span class="line">-rw------- 1 albert albert  7064 Oct 17 22:14 .bash_history</span><br><span class="line">-rw------- 1 albert albert    61 Sep 20 09:42 .Xauthority</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li><code>sort</code> 命令中的 <code>-k</code> 选项是最重要的参数，可以指定排序依据的列数</li><li><code>sort</code> 命令中的 <code>-n</code> 选项也是常用的参数，可以进行数值比较</li><li>在实际问题中常常需要综合运用这些参数，参考综合例子中的方式逐步确定参数选项就可以了。</li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/109020024" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>业精于勤，荒于嬉；行成于思，毁于随。没有人能随随便便成功~</p><p>2020-10-18 15:43:51</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;linux 系统下的命令常常给人一种短小精悍的感觉，使用起来就像一把把锋利的小刀，在自己专注的领域做到极致，今天要聊的就是 linux 环境
      
    
    </summary>
    
      <category term="linux" scheme="http://AlbertGithubHome.github.io/blog/categories/linux/"/>
    
    
      <category term="linux" scheme="http://AlbertGithubHome.github.io/blog/tags/linux/"/>
    
      <category term="sort" scheme="http://AlbertGithubHome.github.io/blog/tags/sort/"/>
    
      <category term="排序" scheme="http://AlbertGithubHome.github.io/blog/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>Go语言在解决实际问题时的优点与不便</title>
    <link href="http://AlbertGithubHome.github.io/blog/2020/10/14/Go%E8%AF%AD%E8%A8%80%E5%9C%A8%E8%A7%A3%E5%86%B3%E5%AE%9E%E9%99%85%E9%97%AE%E9%A2%98%E6%97%B6%E7%9A%84%E4%BC%98%E7%82%B9%E4%B8%8E%E4%B8%8D%E4%BE%BF/"/>
    <id>http://AlbertGithubHome.github.io/blog/2020/10/14/Go语言在解决实际问题时的优点与不便/</id>
    <published>2020-10-14T15:19:16.000Z</published>
    <updated>2020-10-14T15:20:52.573Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><code>Go</code>语言，全称<code>golang</code>，是Google开发的一种静态强类型、编译型、并发型并具有垃圾回收功能的编程语言。 从2007年末由 Robert Griesemer、Rob Pike、Ken Thompson 主持开发，其中的 Ken Thompson 可是和 Dennis Ritchie 一起发明了C语言的大佬。Go 语言于2009年11月正式宣布成为开放源代码项目， 并在2012年初，发布了Go 1.0稳定版本，此后便开启了稳步发展的道路。</p><a id="more"></a><h1 id="Go-语言"><a href="#Go-语言" class="headerlink" title="Go 语言"></a>Go 语言</h1><p>作为一个从2007年开始诞生的语言，在庞大的语言家族中算是一个晚辈，和C++、Python这种老牌语言相比查了将近20年，和 C 语言相比资历就更低了，但是这个新晋的语言在 Google 光环的强大加持下也在飞速发展着，由于前辈们在发展的途中趟了很多坑，所以 Go 在发明之初就避免了其他语言的很多不便，可以说是站在巨人的肩膀上发展起来的。</p><p>但是即便这样，Go 语言的特点也不能被所有人喜欢，和许多人一样，我在学习这门语言的过程中也发现一些很方便特性和一些不太方便的特点，下面简单说几个点，有不对的地方希望小伙伴能及时指出，防止我在错误的思想上越走越远（怎么有种新闻发言稿的感觉~）。</p><h1 id="不便之处"><a href="#不便之处" class="headerlink" title="不便之处"></a>不便之处</h1><p>这里的不便之处只是我在使用过程中感觉不太方便，可能很多人并没有这个感觉，或许还有很多其他的解决方法和替代方案，烦请小伙伴能指点一下。</p><h2 id="三目运算符"><a href="#三目运算符" class="headerlink" title="三目运算符"></a>三目运算符</h2><p>这个三目运算符是个很常用的逻辑处理部件，也是我在逻辑中经常使用到的，在Python、Lua等语言中也不存在，但是我都找到了简单的替代方式，但是在Go 中不得不写成中规中矩的 <code>if</code> 条件判断，这让很多算法的解题代码看起来并不那么优雅，比如一个简单的约瑟夫环问题：</p><blockquote><p>N个人围成一圈，从第一个人从开始报数，报到m的人出圈，剩下的人继续从1开始报数，报到m的人出圈；如此往复，直到所有人出圈，输出最后一个出圈人最初始的编号。</p></blockquote><p>这个问题的解法最简单的是模拟法，使用数组模拟一个环来按照规则运行，最后一个出圈的人的编号就可以输出到结果，还有一种思路就是找规律，可以找到出圈前后的序号对应关系，进而写出一行代码的解决方案。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 索引从0开始，只要对结果加1就好了</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">joseph_ring</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n == <span class="number">1</span> ? <span class="number">0</span> : (joseph_ring(n - <span class="number">1</span>, m) + m) % n</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是在没有三目运算符的 Go 中要实现这个算法，就不得不多写几行了，和 C 语言相比就没有那么简洁了。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">joseph_ring</span><span class="params">(n <span class="keyword">int</span>, m <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (joseph_ring(n - <span class="number">1</span>, m) + m) % n</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="if-单行语句也要加大括号"><a href="#if-单行语句也要加大括号" class="headerlink" title="if 单行语句也要加大括号"></a>if 单行语句也要加大括号</h2><p>Go 语言本身带有自己的格式化命令，可以保证编写时不同的缩进样式格式化之后得到相同的代码，<code>if</code> 后面的条件语句可以不加小括号，但是后面的语句块必须加大括号，这样的规定对于我经常写的代码有点不太友好，比如下面这些C++代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (a &gt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (b &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span>;</span><br></pre></td></tr></table></figure><p>有时候为了看起来紧凑，可能会写成这样：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (a &gt; <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">if</span> (b &lt; <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span> (c == <span class="number">0</span>) <span class="keyword">return</span>;</span><br></pre></td></tr></table></figure><p>但是放到 Go 语言中，就不得不写成好几行了，并且还要加大括号，看起来代码有些松散。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> a &gt; <span class="number">0</span> &#123;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> b &lt; <span class="number">0</span> &#123;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> c == <span class="number">0</span> &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="优秀特性"><a href="#优秀特性" class="headerlink" title="优秀特性"></a>优秀特性</h1><p>上面提到了 Go 语言中不方便的地方，现在可以来说说 Go 语言相对于 C、C++ 更优越的特性：</p><h2 id="多个变量同时赋值"><a href="#多个变量同时赋值" class="headerlink" title="多个变量同时赋值"></a>多个变量同时赋值</h2><p>在 C++ 中交换两个变量的通常使用中间变量来完成，比如交换 <code>a</code>、<code>b</code> 两个变量的值：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> tmp = a;</span><br><span class="line">a = b;</span><br><span class="line">b = tmp;</span><br></pre></td></tr></table></figure><p>针对于这种整形的变量，一些大牛们发明了特殊的算法来处理，避免使用中间变量：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>,;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">a = a ^ b</span><br><span class="line">b = b ^ a</span><br><span class="line">a = a ^ b</span><br></pre></td></tr></table></figure><p>但是在 Go语言中这种情况非常好处理，直接从左到右依次赋值就好了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var a <span class="keyword">int</span> = <span class="number">1</span></span><br><span class="line">var b <span class="keyword">int</span> = <span class="number">6</span></span><br><span class="line"></span><br><span class="line">b, a = a, b</span><br></pre></td></tr></table></figure><h2 id="defer-声明"><a href="#defer-声明" class="headerlink" title="defer 声明"></a>defer 声明</h2><p><code>defer</code> 可以用于在当前函数返回前执行一些清理代码，而不管此函数如何退出。defer 在函数中可以随时出现，这使得清理代码可以尽可能在需要清理的地方运行，比如我们常常要释放申请的资源，常见的需要释放的资源有文件描述符：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">file, err := os.Open(fileName)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> file.Close()</span><br></pre></td></tr></table></figure><p>有了 defer 终于不再在担心，资源没回收的问题，也不用在各个提前返回的条件分支中添加释放资源的重复代码了。</p><h2 id="goroutine-并发"><a href="#goroutine-并发" class="headerlink" title="goroutine 并发"></a>goroutine 并发</h2><p><code>goroutine</code> 是Go并行设计的核心，说到底其实就是协程，但是它比线程更小并且在Go语言内部帮你实现了这些 goroutine 之间的内存共享。执行 goroutine 只需要极少的栈内存，可同时运行成千上万个并发任务。goroutine 一定程度上比 thread 更易用、更高效、更轻便。</p><p>使用起来也非常方便，创建 goroutine 只需在函数调用语句前添加 go 关键字，就可以创建并发执行单元。开发人员无需了解任何执行细节，调度器会自动将其安排到合适的系统线程上执行，这是解放生产力的又一创举，简单示例代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">new_task</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        fmt.Println(<span class="string">"this is a newTask"</span>)</span><br><span class="line">        time.Sleep(time.Second) <span class="comment">//延时1s</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> new_task() <span class="comment">//新建一个协程， 新建一个任务</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    time.Sleep(time.Second * <span class="number">15</span>) <span class="comment">//延时15s</span></span><br><span class="line">    fmt.Println(<span class="string">"this is a main goroutine"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>Go 语言作为编程语言中的新晋小弟，吸收了前人的经验，现阶段发展迅猛</li><li>虽然 Go 出于一些目的规定了语言的标准，但是类似于没有三目运算符这种特点还是有些不方便</li><li>Go 这门语言还很年轻，相信随着不断发展它会越来越优秀，但没有任何语言是完美无缺的</li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/108819869" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>陪伴是最长情的告白，而守护是最沉默的陪伴。国庆中秋双节合并，放假了，陪家人待在一起真的很开心，什么都不用做，就静静的待在一起很满足，聊聊天、抬抬杠，假期嗖嗖嗖地溜掉了~</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&lt;code&gt;Go&lt;/code&gt;语言，全称&lt;code&gt;golang&lt;/code&gt;，是Google开发的一种静态强类型、编译型、并发型并具有垃圾回收功能的编程语言。 从2007年末由 Robert Griesemer、Rob Pike、Ken Thompson 主持开发，其中的 Ken Thompson 可是和 Dennis Ritchie 一起发明了C语言的大佬。Go 语言于2009年11月正式宣布成为开放源代码项目， 并在2012年初，发布了Go 1.0稳定版本，此后便开启了稳步发展的道路。&lt;/p&gt;
    
    </summary>
    
      <category term="Go" scheme="http://AlbertGithubHome.github.io/blog/categories/Go/"/>
    
    
      <category term="C++" scheme="http://AlbertGithubHome.github.io/blog/tags/C/"/>
    
      <category term="Go" scheme="http://AlbertGithubHome.github.io/blog/tags/Go/"/>
    
      <category term="优点" scheme="http://AlbertGithubHome.github.io/blog/tags/%E4%BC%98%E7%82%B9/"/>
    
      <category term="缺点" scheme="http://AlbertGithubHome.github.io/blog/tags/%E7%BC%BA%E7%82%B9/"/>
    
  </entry>
  
  <entry>
    <title>使用Spreadsheet Compare工具对比Excel文件差异</title>
    <link href="http://AlbertGithubHome.github.io/blog/2020/10/04/%E4%BD%BF%E7%94%A8Spreadsheet-Compare%E5%B7%A5%E5%85%B7%E5%AF%B9%E6%AF%94Excel%E6%96%87%E4%BB%B6%E5%B7%AE%E5%BC%82/"/>
    <id>http://AlbertGithubHome.github.io/blog/2020/10/04/使用Spreadsheet-Compare工具对比Excel文件差异/</id>
    <published>2020-10-04T15:09:33.000Z</published>
    <updated>2020-10-14T15:22:01.216Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>与 <code>Spreadsheet Compare</code> 这个工具的相遇是通过 TortoiseSVN 来牵线的，在使用 SVN 管理 Excel 表格时发现，TortoiseSVN自带的比较工具不能对比Excel文件的版本差异，这对于通过日志查找问题来说非常不方便，通过搜索发现了 <code>Spreadsheet Compare</code> 这款优秀的工具，特此记录一下，方便日后查找并快速配置。</p><a id="more"></a><h1 id="Spreadsheet-Compare"><a href="#Spreadsheet-Compare" class="headerlink" title="Spreadsheet Compare"></a>Spreadsheet Compare</h1><p><code>Spreadsheet Compare</code> 是 Microsoft Office 自带的一款工具软件（2013版本以后），可以用来比较不同 Excel 表格的差异，既能显示数据的不同，也可以显示出表结构的不同。这是一款带界面的工具软件，布局分为左右两部分，与 Beyond Compare 这个工具界面类似，但是功能更加强大。</p><p>Beyond Compare 也可以用来对比表格差异，但是只能比较两个Excel的当前工作表，如果每个 Excel 文件中包含多个工作表时就会对比错误的情况，而 <code>Spreadsheet Compare</code> 在这一点上更加优秀，可以对比多个表格数据。</p><p><code>Spreadsheet Compare</code> 使用起来也非常简单，可以操作的按钮很少，界面简洁， 启动软件后单击左上角的 <code>Compare Files</code> 按钮，选择要对比的文件即可，非常方便，数据差异、结构差异等都会用不同的颜色标记出来，还可以导出对比结果。</p><h1 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h1><p>这种模式对于是提供给 TortoiseSVN 使用的前提，因为 TortoiseSVN 无法像人一样一步步操作选择待比较的 Excel 表格，而是需要一个命令脚本，将要比较的参数传给 <code>Spreadsheet Compare</code> 工具进而完成比较工作。</p><h2 id="找到工具"><a href="#找到工具" class="headerlink" title="找到工具"></a>找到工具</h2><p>想要编写命令脚本，首先要找到这个比较的工具，我找到的路径是在 <code>&quot;C:\Program Files (x86)\Microsoft Office\Root\Office16\DCF\SPREADSHEETCOMPARE.EXE&quot;</code>，相信大家的路径都差不多，在 Office 工具目录下应该就能找到了，可以在开始菜单中找到工具，然后通过属性找到可执行程序所在目录，工具的可执行文件名字叫做 <code>SPREADSHEETCOMPARE.EXE</code>。</p><h2 id="编写脚本"><a href="#编写脚本" class="headerlink" title="编写脚本"></a>编写脚本</h2><p>编写脚本之前有一点需要强调一下，<code>SPREADSHEETCOMPARE.EXE</code> 有点奇怪，大多数软件在比较差异的时候会将两个文件作为参数使用，但是 <code>SPREADSHEETCOMPARE.EXE</code> 在比较之前，需要将两个待比较的文件名分成两行写入一个文件，再将这个文件作为参数传给工具使用，比如要比较 ExcelA.xlsx 和 ExcelB.xlsx 两个文件，需要将两个文件写入一个临时文件 ExcelCompare.txt 中:</p><blockquote><p>ExcelA.xlsx<br>ExcelB.xlsx</p></blockquote><p>然后再把这个文件作为参数传给工具：</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SPREADSHEETCOMPARE.EXE ExcelCompare.txt</span><br></pre></td></tr></table></figure><h2 id="脚本内容"><a href="#脚本内容" class="headerlink" title="脚本内容"></a>脚本内容</h2><p>有了上面的说明，我们就可以写出一个较为通用的版本，比如我的脚本名字是 SC.bat，内容如下：</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line"><span class="built_in">chcp</span> <span class="number">65001</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> batpath=%~dp0</span><br><span class="line"><span class="built_in">echo</span> %~<span class="number">1</span>&gt; "<span class="variable">%batpath%</span>ExcelCompare.txt"</span><br><span class="line"><span class="built_in">echo</span> %~<span class="number">2</span>&gt;&gt; "<span class="variable">%batpath%</span>ExcelCompare.txt"</span><br><span class="line">"C:\\Program Files (x86)\\Microsoft Office\\Root\\Office16\\DCF\\SPREADSHEETCOMPARE.EXE" "<span class="variable">%batpath%</span>ExcelCompare.txt"</span><br></pre></td></tr></table></figure><h2 id="脚本执行"><a href="#脚本执行" class="headerlink" title="脚本执行"></a>脚本执行</h2><p>直接在 cmd 命令行中输入以下命令就可以对比 ExcelA.xlsx 和 ExcelB.xlsx 两个文件了：</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">D:\<span class="title">data</span>\<span class="title">bat</span>&gt;</span></span><br><span class="line"><span class="function"><span class="title">D</span>:\<span class="title">data</span>\<span class="title">bat</span>&gt;<span class="title">SC.bat</span> <span class="title">ExcelA.xlsx</span> <span class="title">ExcelB.xlsx</span></span></span><br></pre></td></tr></table></figure><h2 id="供给SVN调用"><a href="#供给SVN调用" class="headerlink" title="供给SVN调用"></a>供给SVN调用</h2><p>个人比较懒，不喜欢截图，在 TortoiseSVN 工具的设置中找到“差异查看器”选项，选择该选项然后点击界面上的高级设置，点击增加按钮，增加根据扩展名指定差异比较程序，填写 <code>.xlsx</code> 和所需命令 <code>D:\data\bat&gt;SC.bat %base %mine</code></p><p>命令中的 <code>%base</code> 和 <code>%mine</code> 参数是 TortoiseSVN 提供的，代表原始文件和自己修改的文件，这次再通过 SVN 查看表格差异就可以启动 <code>Spreadsheet Compare</code> 程序方便地查看两个表格的差异啦。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li><code>Spreadsheet Compare</code> 是一款强大的表格比较工具，在表格比较时比 Beyond Compare 还要优秀</li><li>脚本调用 <code>SPREADSHEETCOMPARE.EXE</code> 程序时参数是一个包含了待比较文件名的临时文件，这一点和其他的比较工具有些不同</li><li>脚本中我们生成的临时文件无需手动处理，再打开待比较文件后会自动删除</li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/108920923" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>急需找到一个看得见摸得着的目标为之努力，不然真的有点止步不前了，至今还未找到可以废寝忘食之事，长此以往终将碌碌无为，继续找寻，此事可以不伟大，但应该有趣~</p><p>2020-10-12 00:16:52</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;与 &lt;code&gt;Spreadsheet Compare&lt;/code&gt; 这个工具的相遇是通过 TortoiseSVN 来牵线的，在使用 SVN 管理 Excel 表格时发现，TortoiseSVN自带的比较工具不能对比Excel文件的版本差异，这对于通过日志查找问题来说非常不方便，通过搜索发现了 &lt;code&gt;Spreadsheet Compare&lt;/code&gt; 这款优秀的工具，特此记录一下，方便日后查找并快速配置。&lt;/p&gt;
    
    </summary>
    
      <category term="Tools" scheme="http://AlbertGithubHome.github.io/blog/categories/Tools/"/>
    
    
      <category term="Excel" scheme="http://AlbertGithubHome.github.io/blog/tags/Excel/"/>
    
      <category term="Spreadsheet-Compare" scheme="http://AlbertGithubHome.github.io/blog/tags/Spreadsheet-Compare/"/>
    
      <category term="SVN" scheme="http://AlbertGithubHome.github.io/blog/tags/SVN/"/>
    
  </entry>
  
  <entry>
    <title>东拉西扯01世界的沧海桑田</title>
    <link href="http://AlbertGithubHome.github.io/blog/2020/09/26/%E4%B8%9C%E6%8B%89%E8%A5%BF%E6%89%AF01%E4%B8%96%E7%95%8C%E7%9A%84%E6%B2%A7%E6%B5%B7%E6%A1%91%E7%94%B0/"/>
    <id>http://AlbertGithubHome.github.io/blog/2020/09/26/东拉西扯01世界的沧海桑田/</id>
    <published>2020-09-26T14:47:01.000Z</published>
    <updated>2020-10-14T15:21:05.336Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>此篇非技术总结，但却与技术相关，写这篇总结的起因是前两天看了一节关于虚幻四的公开课，这节课也不是讲开发技术，更多的是讲创作艺术，课程开始前看到虚幻编辑器的画面，还是有一种很熟悉的感觉，毕竟使用了3年多的时间，外观几乎没有变化，使用方式依旧是原来的步骤，但随着课程的进行，我发现它变了。</p><a id="more"></a><p>其中有一段内容提到，虚幻四已经不再将自己作为一款游戏开发引擎，而是定位成一个艺术创作和开发的平台，也就是说它不仅仅可以做游戏，同时可以用来出影视剧、国漫、特定素材等等，它已经将自己的势力范围扩张，变得丰富而强大，后来又提到虚幻五带来的种种提升。</p><p>什么？虚幻五已经出了，这是我之前不知道的，我知道今年 Redis 出了最新的 6.0 版本，MySQL 一跃发行了 8.0 版本，IOS 也更新到的 14.0.1 版本，似乎各种技术都在飞速的发展着，但是人的精力毕竟有限，很难把它们成长历程尽收眼底，一不留神就发现某种技术已经悄悄从你身边跨了过去。</p><h1 id="技术的发展"><a href="#技术的发展" class="headerlink" title="技术的发展"></a>技术的发展</h1><p>记得我第一篇博客记录的是处理 Ubuntu 黑屏的解决方案，我去翻了翻当时记录的版本是 12.04，时间已经过去了7年，Ubuntu 20.04 已经发行，当年解决黑屏的经验或许已经毫无用处。</p><p>10年接触的第一种计算机编程语言是 C 语言，当时开发环境是 Turbe C 2.0，后来使用 VC++6.0，接着就是VS系列，期间用过 Dev-C++、CodeBlocks等编辑器，但是 VS 还是用的最多的，直到目前使用的 VS2017，可是刚刚一个好学的小朋友问我 VS2019 相关的问题，我发现这款用了这么久的工具，之前一直无变化的菜单布局在 VS2019 版本上发生了改变。</p><p>之前一直号称单线程内存数据库 Redis 在今年5月份发布的 6.0 版本中，加入了网络多线程，使得整体性能提升近一倍，这被认为是 Redis 最大的一次改版。</p><p>MySQL 直接从 5.7 版本跳到了 8.0 版本，因为之前一直是 5.6 、5.7 这样的小版本提升，一跃跳到 8.0 一时让人好奇到底改了什么？其实 6.0 是一个过渡版本，而 7.0 是作为集群的保留版本，所以这次直接到了 8.0。其中一个亮点增加了 MySQL 文档存储，可以存储 json 格式，开始支持向 NoSQL 格式转化。</p><p>差点忘了C++，这个庞然大物目前已经从最开始的 C++98，发展到现在的 C++20，我在想它如果真的存活到 2098 年，应该怎么命名它呢？新标准的内容很长，需要慢慢来消化，可以发现一些很好玩的东西，比如三向比较运算符 <code>&lt;=&gt;</code>，也叫飞船运算符，感兴趣的可以去了解下。</p><p>经历的和未经历的变化还有很多，想好了再来补充。。。</p><h1 id="技术公司的发展"><a href="#技术公司的发展" class="headerlink" title="技术公司的发展"></a>技术公司的发展</h1><p>当年找工作的听说过的巨头就是 BAT，而今天晚上问一个即将毕业进入工作岗位的同学，哪些是他心目中的大厂，他给出了四个名字，“阿里、腾讯、字节、美团”，很明显百度已经掉队，但是瘦死的骆驼比马大，短时间内百度的技术底蕴不会消失殆尽，这些手握资源和技术的大厂很早就给自己挖好了护城河，一般企业很难追赶的上。</p><p>相比早期的 BAT，我感觉后来的字节、美团能够赶上他们实属不易，记得当年开玩笑说 TX 除了发明了一套钻石收费系统，其他的都是抄的，任何公司有了好点子，不是被他合并了就是被他抄走了，所以说能在某个它无法掌控的赛道上超越它也是非常厉害了。</p><p>有些东西是其他公司无法做到的，比如疫情期间的健康宝，每天上班、去商场、去公园都要看，都要打开微信和支付宝的APP，这个日活的数据放到其他任意一款软件上都是庞大的数字，可是他们就在这两大巨头这自然的发生着。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>技术每时每刻都在发展，有时你发现它陌生了，其实只是你关注的少了</li><li>好的赛道大多数已被别人占领，从夹缝中寻找到机会还需好好把握，才能做出一定的成绩</li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/108691877" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>年年岁岁花相似，岁岁年年人不同</p><p>2020-9-27 00:20:42</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;此篇非技术总结，但却与技术相关，写这篇总结的起因是前两天看了一节关于虚幻四的公开课，这节课也不是讲开发技术，更多的是讲创作艺术，课程开始前看到虚幻编辑器的画面，还是有一种很熟悉的感觉，毕竟使用了3年多的时间，外观几乎没有变化，使用方式依旧是原来的步骤，但随着课程的进行，我发现它变了。&lt;/p&gt;
    
    </summary>
    
      <category term="Thinking" scheme="http://AlbertGithubHome.github.io/blog/categories/Thinking/"/>
    
    
      <category term="技术" scheme="http://AlbertGithubHome.github.io/blog/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="计算机" scheme="http://AlbertGithubHome.github.io/blog/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>C++求解组合数的具体实现</title>
    <link href="http://AlbertGithubHome.github.io/blog/2020/09/19/C-%E6%B1%82%E8%A7%A3%E7%BB%84%E5%90%88%E6%95%B0%E7%9A%84%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0/"/>
    <id>http://AlbertGithubHome.github.io/blog/2020/09/19/C-求解组合数的具体实现/</id>
    <published>2020-09-19T12:22:34.000Z</published>
    <updated>2020-09-22T14:38:19.264Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>很少写关于具体算法的总结笔记，因为很难把一个算法从头到尾的叙述清晰并且完整，容易造成误解。这次想总结一下组合数的具体实现，原因是最近总是碰见组合数，所以决定来写写，免得每次从头推导公式耽误时间。排列组合经常会作为一个问题解决方案中一部分，通常是求某个问题有多少个解，达到某种状态有多少种操作方式等等。</p><a id="more"></a><h1 id="问题起因"><a href="#问题起因" class="headerlink" title="问题起因"></a>问题起因</h1><p>今天下午解一道简单题，难度简直刷新了我的认知，其中需要用到组合数，但这仅仅是解题的一小部分，没办法，从头推导的，简单优化下，写出了如下代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">C</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = a; i &gt; a - b; i--) ans *= i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = b; i &gt; <span class="number">1</span>; i--) ans /= i;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为时间紧迫，范围也比较小，同时可以控制 <code>a</code> 和 <code>b</code> 的大小，所以临时写下的这段代码可以运行，不然这段代码会出现各种错误的。</p><h1 id="组合公式"><a href="#组合公式" class="headerlink" title="组合公式"></a>组合公式</h1><p>既然是想做总结，还是从头来看看组合公式，根据原始公式实现算法，并尝试优化它，当熟悉这个套路之后，就可以直接拿来用了，可以节省不少时间，组合公式的常见表示方式如下：</p><p>$$<br>C^m_n = \frac{n!}{m!(n-m)!} = C^{n-m}_n,(n \geq m \geq 0)<br>$$</p><p>这个公式写出来清晰多了，<code>n!</code>表示n的阶乘，计算方式为 n*(n-1)*(n-2)*(n-3)*…*3*2*1， 相信很多人都清楚，我们只要把这个数据公式翻译成代码就可以了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">C2</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">1</span>, c = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; --i) a *= i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = m; i &gt;= <span class="number">1</span>; --i) b *= i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n-m; i &gt;= <span class="number">1</span>; --i) c *= i;</span><br><span class="line">    <span class="keyword">return</span> a/(b*c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码比较简单，依次计算公式中三个数的阶乘，然后再做乘除法就可以了，但是你有没有思考过一个问题，<code>int</code> 类型的整数最大能表示的阶乘是多少？是<code>12!</code>，它的值是 479,001,600，它是 <code>int</code> 表示范围内最大的阶乘数，看来这种实现方式局限性很大，如果 n 大于12就没有办法计算了。</p><h1 id="公式变形"><a href="#公式变形" class="headerlink" title="公式变形"></a>公式变形</h1><p>实际上根据阶乘的定义，n! 和 (n-m)! 是可以约分的，将这两个式子约分后，公式可以化简为：</p><p>$$<br>C^m_n = \frac{n!}{m!(n-m)!} = \frac{n(n-1)(n-2)…(n-m+1))}{m!},(n \geq m \geq 0)<br>$$</p><p>公式写成这样之后可以少计算一个阶乘，并且计算的范围也会缩小，代码实现和一开始展示的代码思想是一样的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">C3</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt; n - m; --i) a *= i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = m; i &gt;= <span class="number">1</span>; i--) b *= i;</span><br><span class="line">    <span class="keyword">return</span> a/b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码虽然经过了化简，但是当 n 和 m 非常接近的时候，分子还是接近于 n!，所以表示的范围还是比较小。</p><h1 id="递推公式"><a href="#递推公式" class="headerlink" title="递推公式"></a>递推公式</h1><p>直接给出的公式经过化简后还是受制于计算阶乘的范围，得想个办法看看能不能绕过阶乘计算，方法总是有的，并且前辈们已经给我们整理好了，我们总是站在巨人的肩膀上，下面就是递推公式：</p><p>$$<br>\begin{cases} {C^m_n} = 1,\qquad\qquad\qquad (m=0 或 m=n) \ {C^m<em>n} = {C^m</em>{n-1}} + {C^{m-1}_{n-1}},\qquad(n &gt; m &gt; 0) \end{cases}<br>$$</p><h2 id="递归实现"><a href="#递归实现" class="headerlink" title="递归实现"></a>递归实现</h2><p>有了上面的分段函数表示，就满足了递归的条件，既有递归调用缩小规模，也有递归出口，这样实现起来很简单，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">C4</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == m || m == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> C4(n<span class="number">-1</span>, m) + C4(n<span class="number">-1</span>, m<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这两行代码是不是很秀？不过使用递归常常会出现一问题，那就是相同子问题多次计算，导致效率低下，这个计算组合数的方式同样存在重复计算子问题的缺点，我们以调用C4(5, 3)为例，看看下面的调用关系图：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">graph TB</span><br><span class="line">A(5,3)--&gt;B(4,3)</span><br><span class="line">    B(4,3)--&gt;C(3,3);</span><br><span class="line">    B(4,3)--&gt;D(3,2);</span><br><span class="line">    D(3,2)--&gt;E(2,2);</span><br><span class="line">    D(3,2)--&gt;F(2,1);</span><br><span class="line">    F(2,1)--&gt;G(1,1);</span><br><span class="line">    F(2,1)--&gt;H(1,0);</span><br><span class="line"></span><br><span class="line">    A(5,3)--&gt;O(4,2)</span><br><span class="line">O(4,2)--&gt;P(3,2)</span><br><span class="line">O(4,2)--&gt;Q(3,1)</span><br><span class="line">P(3,2)--&gt;R(2,2)</span><br><span class="line">P(3,2)--&gt;S(2,1)</span><br><span class="line">Q(3,1)--&gt;T(2,1)</span><br><span class="line">Q(3,1)--&gt;U(2,0)</span><br><span class="line">S(2,1)--&gt;V(1,1)</span><br><span class="line">S(2,1)--&gt;W(1,0)</span><br><span class="line">T(2,1)--&gt;X(1,1)</span><br><span class="line">T(2,1)--&gt;Y(1,0)</span><br></pre></td></tr></table></figure><p>从这个图可以清晰看出<code>C4(3, 2)</code> 和 <code>C4(2, 1)</code> 都被计算了多次，当 m 和 n 的数字比较大的时候，会进行更多次的重复计算，严重影响计算的效率，有没有什么办法解决重复计算的问题呢？</p><h2 id="备忘递归"><a href="#备忘递归" class="headerlink" title="备忘递归"></a>备忘递归</h2><p>解决重复计算的常用方法是利用一个备忘录，将已经计算式子结果存储起来，下次再遇到重复的计算时直接取上次的结果就可以了，我们可以将中间结果简单存储到map中。</p><p>假设 n 不超过10000，这比12已经大太多了，我们可以使用 <code>n * 10000 + m</code> 作为map的键，然后将结果存储到map中，每次计算一个式子前先看查询备忘录，看之前有没有计算过，如果计算过直接取结果就可以了，代码简单实现如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">C5</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m, <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&amp; memo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == m || m == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> itora = memo.find((n<span class="number">-1</span>)*<span class="number">10000</span>+m);</span><br><span class="line">    <span class="keyword">int</span> a = itora != memo.end() ? itora-&gt;second : C4(n<span class="number">-1</span>, m);</span><br><span class="line">    <span class="keyword">if</span> (itora == memo.end()) memo[(n<span class="number">-1</span>)*<span class="number">10000</span>+m] = a;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> itorb = memo.find((n<span class="number">-1</span>)*<span class="number">10000</span>+m<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">int</span> b = itorb != memo.end() ? itorb-&gt;second : C4(n<span class="number">-1</span>, m<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">if</span> (itorb == memo.end()) memo[(n<span class="number">-1</span>)*<span class="number">10000</span>+m<span class="number">-1</span>] = b;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 map 作为备忘录可以避免重复计算，这是解决递归效率低下的常用方法，那么有了递推公式不使用递归实现可不可以呢？当然可以了，针对于这个问题，有了递推公式我们还可以使用动态规划（dp）的方式来实现。</p><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>动态规划常常适用于有重叠子问题和最优子结构性质的问题，试图只解决每个子问题一次，具有天然剪枝的功能。基本思想非常简单，若要解一个给定问题，我们需要解其不同子问题，再根据子问题的解以得出原问题的解。</p><p>再回顾一下递推公式：</p><p>$$<br>\begin{cases} {C^m_n} = 1,\qquad\qquad\qquad (m=0 或 m=n) \ {C^m<em>n} = {C^m</em>{n-1}} + {C^{m-1}_{n-1}},\qquad(n &gt; m &gt; 0) \end{cases}<br>$$</p><p>翻译成人话就是，当m等于0或者等于n的时候，组合数结果为1，否则组合数结果等于另外两个组合数的和，我们可以采用正向推导的方式，将 n 和 m 逐步扩大，最终得到我们想要的结果，定义dp表格如下：</p><table><thead><tr><th style="text-align:center">n\m</th><th style="text-align:center">(0)</th><th style="text-align:center">(1)</th><th style="text-align:center">(2)</th><th style="text-align:center">(3)</th><th style="text-align:center">(4)</th><th style="text-align:center">(5)</th></tr></thead><tbody><tr><td style="text-align:center">(0)</td><td style="text-align:center">1</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">(1)</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">(2)</td><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">1</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">(3)</td><td style="text-align:center">1</td><td style="text-align:center">3</td><td style="text-align:center">3</td><td style="text-align:center">1</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">(4)</td><td style="text-align:center">1</td><td style="text-align:center">4</td><td style="text-align:center">6</td><td style="text-align:center">4</td><td style="text-align:center"><em><1></1></em></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">(5)</td><td style="text-align:center">1</td><td style="text-align:center">5</td><td style="text-align:center">10</td><td style="text-align:center"><strong>==&gt;10</strong></td><td style="text-align:center"><em><5></5></em></td><td style="text-align:center"><em><1></1></em></td></tr></tbody></table><p>从表格可以清晰的看出求解 <code>C(5,3)</code> 只需要计算5行3列（从0开始）的数据，其余的值可以不用计算，这样我们就可以对照着表格写代码啦，定义一个dp数组，然后双重for循环就搞定了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">C6</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == m || m == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(n+<span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(m+<span class="number">1</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i &amp;&amp; j &lt;= m; j++)</span><br><span class="line">            <span class="keyword">if</span> (i == j || j == <span class="number">0</span>) dp[i][j] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> dp[i][j] = dp[i<span class="number">-1</span>][j] + dp[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[n][m];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，我们就采用了非递归的方式求解出了组合数的结果，但是这里的空间有点浪费，每次都要花费<code>O(mn)</code>的空间复杂度，有没有办法降低一点呢？我们可以找找规律进行压缩。</p><h2 id="压缩DP"><a href="#压缩DP" class="headerlink" title="压缩DP"></a>压缩DP</h2><p>观察之前的动态规划实现的代码，我们发现求解第 <code>i</code>行的数据时只与第 <code>i-1</code> 行有关，所以我们可以考虑将二维数据压缩成一维，还是逐行求解，只不过可以用一维数组来记录求解的结果，优化代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">C7</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == m || m == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(m+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = min(i, m); j &gt;= <span class="number">0</span>; j--)</span><br><span class="line">            <span class="keyword">if</span> (i == j || j == <span class="number">0</span>) dp[j] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> dp[j] = dp[j] + dp[j<span class="number">-1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[m];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们就将空间复杂度降低到了<code>O(m)</code>，需要注意的是在计算dp时，因为采用了压缩结构，为防止前面的修改影响后续结果，所以采用里倒序遍历，这是一个易错的点。</p><h2 id="其他优化"><a href="#其他优化" class="headerlink" title="其他优化"></a>其他优化</h2><p>代码实现到这里，我们的时间复杂度是<code>O(nm)</code>，空间复杂是<code>O(m)</code>，其实还有进一步的优化空间：</p><ul><li><p><strong>减小m：</strong> 因为题目是求解C(n, m)，但是我们知道组合公式中，C(n, m) 和 C(n, n-m) 相等，所以当 n-m 小于 m 的时候求解C(n, n-m)可以降低时间复杂度和空间复杂度。</p></li><li><p><strong>部分剪枝：</strong> 观察函数<code>int C7(int n, int m)</code>，实际上当i为n时，j没必要遍历到0，只需要计算j等于m的情况就可以了，可以提前计算出结果。</p></li><li><p><strong>缩小计算范围：</strong> 从上面的剪枝操作得到启示，其实每一行没必要全部计算出来，以 <code>C(5,3)</code> 为例，我们只需要计算出表格中有数字的位置的结果就可以了：</p></li></ul><table><thead><tr><th style="text-align:center">n\m</th><th style="text-align:center">(0)</th><th style="text-align:center">(1)</th><th style="text-align:center">(2)</th><th style="text-align:center">(3)</th><th style="text-align:center">(4)</th><th style="text-align:center">(5)</th></tr></thead><tbody><tr><td style="text-align:center">(0)</td><td style="text-align:center">1</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">(1)</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">(2)</td><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">1</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">(3)</td><td style="text-align:center"></td><td style="text-align:center">3</td><td style="text-align:center">3</td><td style="text-align:center">1</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">(4)</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">6</td><td style="text-align:center">4</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">(5)</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"><strong>==&gt;10</strong></td><td style="text-align:center"></td></tr></tbody></table><p>这样来看每行最多需要计算3个值，那么时间复杂度可以降低到 <code>O(3n)</code>，去掉常数，时间复杂度降为 <code>O(n)</code>。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>计算组合数可以采用逆向递归和正向递推两种方式，递归时注意写好递归出口</li><li>采用正向递推方法时利用动态规划思想，使用子问题的解拼凑出最终问题的解</li><li>计算组合数若使用了计算阶乘应注意范围，避免在计算时产生溢出，<code>int</code>最多能表示 <code>12!</code></li><li>使用动态规划方法时可以逐步优化空间和时间，这其实就是优化算法的过程，也是提升的过程</li><li>关于组合数的求解方式，我们可以找到时间复杂度<code>O(n)</code>、空间复杂度<code>O(m)</code>的非递归解法</li></ul><h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><p>感谢 @小胡同的诗 同学的补充和提醒，让我再次感受到数学力量的深不可测，原来求解组合数还有这样一个递推公式：</p><p>$$<br>\begin{cases} {C^m_n} = 1,\qquad\qquad\qquad (m=0 或 m=n) \ C_n^m=\frac{n-m+1}{m}C_n^{m-1},\qquad(n &gt; m &gt; 0) \end{cases}<br>$$</p><p>这个公式厉害就厉害在它是一个线性的，不存在分叉的情况，也就是说即使递归也不会出现重复的计算，我们简单实现一下。</p><h2 id="反向递归"><a href="#反向递归" class="headerlink" title="反向递归"></a>反向递归</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">C8</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == m || m == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> C8(n, m<span class="number">-1</span>) * (n-m+<span class="number">1</span>) / m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码非常紧凑，也不存在重复计算的情况，当然我们也可以使用正向计算的方式来实现。</p><h2 id="正向递推"><a href="#正向递推" class="headerlink" title="正向递推"></a>正向递推</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">C9</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == m || m == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">    m = min(m, n-m);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) ans = ans * (n-i+<span class="number">1</span>) / i;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码将时间复杂度降到了O(m)，空间复杂度降到了O(1)，不过特定的场景还是要选择特定的实现，虽然<code>C9</code>函数在时间复杂度和空间复杂度上都优于 <code>C5</code> 函数，但是如果一个实际问题中需要用到多个组合数的时候，<code>C5</code> 这种采用缓存的方式可能会是更好的选择。</p><hr><center><a href="https://blog.csdn.net/albertsh/article/details/108552268" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>想讲故事？没人倾听？那是因为你还未到达一个指定的高度，当你在某个领域站稳了脚跟，做出了成绩，自然有的是时间去讲故事或者“编”故事，到时候随便一句话都会被很多人奉为圭臬，甚至会出现一些鸡汤莫名其妙的从你嘴里“说”出来。在你拥有了讲故事权利的同时，批判的声音也将随之而来~</p><p>2020-9-20 12:32:37</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;很少写关于具体算法的总结笔记，因为很难把一个算法从头到尾的叙述清晰并且完整，容易造成误解。这次想总结一下组合数的具体实现，原因是最近总是碰见组合数，所以决定来写写，免得每次从头推导公式耽误时间。排列组合经常会作为一个问题解决方案中一部分，通常是求某个问题有多少个解，达到某种状态有多少种操作方式等等。&lt;/p&gt;
    
    </summary>
    
      <category term="C/C++" scheme="http://AlbertGithubHome.github.io/blog/categories/C-C/"/>
    
    
      <category term="C/C++" scheme="http://AlbertGithubHome.github.io/blog/tags/C-C/"/>
    
      <category term="combination" scheme="http://AlbertGithubHome.github.io/blog/tags/combination/"/>
    
      <category term="dp" scheme="http://AlbertGithubHome.github.io/blog/tags/dp/"/>
    
      <category term="recursion" scheme="http://AlbertGithubHome.github.io/blog/tags/recursion/"/>
    
  </entry>
  
  <entry>
    <title>C++中优先队列priority_queue的基础用法</title>
    <link href="http://AlbertGithubHome.github.io/blog/2020/09/11/C-%E4%B8%AD%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97priority-queue%E7%9A%84%E5%9F%BA%E7%A1%80%E7%94%A8%E6%B3%95/"/>
    <id>http://AlbertGithubHome.github.io/blog/2020/09/11/C-中优先队列priority-queue的基础用法/</id>
    <published>2020-09-11T15:10:11.000Z</published>
    <updated>2020-09-12T09:26:02.012Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>学习优先队列之前先看个单词队列 queue， 这个单词的读法很多人都能读对吧，音标是 <code>/kjuː/</code> ，再看一个双端队列 deque，它的音标是 <code>/dek/</code>，应该有人读错了吧，反正我是没读对，刚开始看见一次错一次，现在还好了，基本能记住怎么读了，可是这些队列怎么用呢？</p><a id="more"></a><p>队列就不用多说了，一个先进先出的经典数据结构，那么优先队列是个什么鬼，其实它就是在队列的基础上加上优先两个字，想想怎样才能优先呢？没错——排队！只有排好了队伍才会有落后和优先之分，否则一团乱糟糟的，怎么才能分出优先的，所以优先队列一定应用了排序。</p><p>可是排序要怎样实现呢？其实排序这个底层逻辑你是不用管的，你只要把想要的数据放到优先队列里，然后取出的必定是当前状态下最优的，当然，究竟什么是最优的条件是需要你来设定的，也就是说我们需要定义排序的规则。</p><h1 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h1><p>优先队列 priority_queue 是队列 queue 的一个变种，头文件是<code>#include &lt;queue&gt;</code>，使用优先队列必须要包含这个头文件。</p><h1 id="结构定义"><a href="#结构定义" class="headerlink" title="结构定义"></a>结构定义</h1><p>优先队列的结构定义是一个模板类，需要提供三个类型参数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">T</span>,</span></span><br><span class="line"><span class="class">    <span class="title">class</span> <span class="title">Container</span> = <span class="title">std</span>:</span>:<span class="built_in">vector</span>&lt;T&gt;,</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Compare</span> = <span class="title">std</span>:</span>:less&lt;<span class="keyword">typename</span> Container::value_type&gt;</span><br><span class="line">&gt; <span class="class"><span class="keyword">class</span> <span class="title">priority_queue</span>;</span></span><br></pre></td></tr></table></figure><p>从定义可以看出，虽然要结构是三个参数，但是后两个参数带了默认值，所以针对于普通的数据类型，一般情况下指提供第1个参数就可以了，比如 <code>priority_queue&lt;int&gt;</code> 实际上等价于 <code>priority_queue&lt;int, vector&lt;int&gt;, less&lt;int&gt;&gt;</code>。</p><p>这三个参数的含义分别为：数据类型，容器类型和比较函数，实际上优先队列就是维护了一个装有 <code>T</code> 类型元素的容器 <code>Container</code>，并在入队和出队时对容器内元素使用 <code>Compare</code> 比较函数进行了排序。</p><p>这3个参数还要满足一定的要求，并且在使用过程中有些注意事项：</p><ul><li>如果类型 <code>T</code> 和 <code>Container</code> 容器中元素类型不一致，那么行为未定义，所以要避免这种情况。</li><li><code>Container</code> 必须是序列容器，其实C++中序列容器很多的，比如<code>std::array</code>、<code>std::vector</code>、<code>std::deque</code>、<code>std::list</code>等</li><li><code>Container</code> 还必须要支持随机访问，并且有 <code>front()</code>、<code>push_back()</code>、<code>pop_back()</code> 等函数</li></ul><p>这样来看只有 <code>std::vector</code>、<code>std::deque</code> 满足容器条件了，而优先队列中使用的默认参数也是 <code>std::vector</code>。</p><h1 id="队列排序"><a href="#队列排序" class="headerlink" title="队列排序"></a>队列排序</h1><p>一直在说优先队列里使用了排序，而常用的容器是 <code>std::verctor</code>，那么究竟用的是什么排序，又是在什么时候进行的排序呢？实际上这里的排序并不是我们通常拿到数据后使用的冒泡排序、快速排序等，优先队列中的排序本质上是堆排序，但是它不是每次都进行完整的堆排序，而是通过 <code>Container</code> 维护了一个堆结构，每次入队和出队时都进行一次堆调整，所花时间为 <code>log(n)</code>，所以用在数据量大的地方，速度比较快。</p><h1 id="优先队列使用"><a href="#优先队列使用" class="headerlink" title="优先队列使用"></a>优先队列使用</h1><p>当我们大概了解了优先队列的原理后，可以通过使用来进一步熟悉这个结构，下面来看几个例子。</p><h2 id="实现排序"><a href="#实现排序" class="headerlink" title="实现排序"></a>实现排序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">common_sort</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> source_data[<span class="number">10</span>] = &#123;<span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">10</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">15</span>, <span class="number">13</span>, <span class="number">16</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认大根堆，实现由大到小排序</span></span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> n : source_data) q.push(n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; q.top() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        q.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>priority_queue&lt;int&gt;</code> 默认构建的是一个大根堆，所以每次从头取数据得到的是一个从大到小的队列排序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:/mnt/c++/datastruct$ g++ priorityqueue.cpp -o commonsort -std=c++11</span><br><span class="line">albert@home-pc:/mnt/c++/datastruct$ ./commonsort</span><br><span class="line">16</span><br><span class="line">15</span><br><span class="line">13</span><br><span class="line">10</span><br><span class="line">9</span><br><span class="line">8</span><br><span class="line">5</span><br><span class="line">3</span><br><span class="line">2</span><br><span class="line">1</span><br></pre></td></tr></table></figure><p>如果是完整排序使用优先队列就有些麻烦了，还不如直接调用 <code>std::sort</code> 函数，但是如果只取部分数据的话，优先队列还是非常方便快速的，比如下面这个问题。</p><h2 id="取出数组中最大的k个数"><a href="#取出数组中最大的k个数" class="headerlink" title="取出数组中最大的k个数"></a>取出数组中最大的k个数</h2><p>这是一个经典的算法题，最容易想到的办法就是遍历，先找到最大的，然后排出这个数再找到最大的，这样找k次就好了，所需时间大概表示为 <code>O(kN)</code>。</p><p>还有一个方法是排序，使用 <code>std::sort</code> 排序后，然后依次取出前 k 个数就行了，排序使用快速排序的话可以达到所需时间为 <code>O(Nlog(N))</code>，其实这样已经很优秀了，但是还可以通过优先队列来加速，下面来写一下代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">max_k_num</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> source_data[<span class="number">10</span>] = &#123;<span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">10</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">15</span>, <span class="number">13</span>, <span class="number">16</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 小根堆</span></span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> n : source_data) &#123;</span><br><span class="line">        <span class="keyword">if</span> (q.size() == k) &#123;</span><br><span class="line">            <span class="keyword">if</span> (n &gt; q.top()) &#123;</span><br><span class="line">                q.pop();</span><br><span class="line">                q.push(n);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> q.push(n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; q.top() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        q.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里是定义了一个小根堆，堆顶是最小值，当有新元素大于堆顶元素时，并且队列中元素等于k个，需要移除堆顶元素，然后插入新的元素，这样就能保证优先队列中始终拥有最大的k个数，运行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:/mnt/c++/datastruct$ g++ priorityqueue.cpp -o max_k_num -std=c++11</span><br><span class="line">albert@home-pc:/mnt/c++/datastruct$ ./max_k_num</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">13</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td></tr></table></figure><p>因为这里控制堆的规模最大为k，所以这个算法的执行时间大概是<code>O(Nlog(k))</code>，绝大多数情况是由于快速排序的。</p><h2 id="自定义结构"><a href="#自定义结构" class="headerlink" title="自定义结构"></a>自定义结构</h2><p>使用优先队列时常常要用到自定义结构，这时候就需要自己来写比较函数了，比如输出成绩最好的三个人的信息：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span> &#123;</span></span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">int</span> score;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmp_custom</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(student&amp; x, student&amp; y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x.score &gt; y.score;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">max_k_score</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;student&gt; stu_list = &#123;&#123;<span class="string">"Andy"</span>, <span class="number">89</span>&#125;, &#123;<span class="string">"Bella"</span>, <span class="number">79</span>&#125;, &#123;<span class="string">"Cary"</span>, <span class="number">92</span>&#125;, &#123;<span class="string">"Dick"</span>, <span class="number">60</span>&#125;, &#123;<span class="string">"Ray"</span>, <span class="number">70</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 小根堆</span></span><br><span class="line">    priority_queue&lt;student, <span class="built_in">vector</span>&lt;student&gt;, cmp_custom&gt; q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> stu : stu_list) &#123;</span><br><span class="line">        <span class="keyword">if</span> (q.size() == k) &#123;</span><br><span class="line">            <span class="keyword">if</span> (stu.score &gt; q.top().score) &#123;</span><br><span class="line">                q.pop();</span><br><span class="line">                q.push(stu);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> q.push(stu);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; q.top().name &lt;&lt; <span class="string">":"</span> &lt;&lt; q.top().score &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        q.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下，每个人的名字后面跟着分数，结果是分数最大的3个人的信息：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:/mnt/c++/datastruct$ g++ priorityqueue.cpp -o max_k_score -<span class="built_in">std</span>=c++<span class="number">11</span></span><br><span class="line">albert@home-pc:/mnt/c++/datastruct$ ./max_k_score</span><br><span class="line">Bella:<span class="number">79</span></span><br><span class="line">Andy:<span class="number">89</span></span><br><span class="line">Cary:<span class="number">92</span></span><br></pre></td></tr></table></figure><h2 id="自定义比较函数的另一种写法"><a href="#自定义比较函数的另一种写法" class="headerlink" title="自定义比较函数的另一种写法"></a>自定义比较函数的另一种写法</h2><p>看到上个例子中自定义比较函数的写法比较怪，一般我们在排序时定义的比较函数使用lambda表达式就可以，而这里是不能直接这样写的，需要多转化一步，写成下面这种形式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> cmp = [](student&amp; x, student&amp; y) &#123; <span class="keyword">return</span> x.score &gt; y.score; &#125;;</span><br><span class="line">priority_queue&lt;student, <span class="built_in">vector</span>&lt;student&gt;, <span class="keyword">decltype</span>(cmp)&gt; q(cmp);</span><br></pre></td></tr></table></figure><p>虽然看起来还是有点怪，但总比下面这样要好看的多：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmp_custom</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(student&amp; x, student&amp; y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x.score &gt; y.score;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">priority_queue&lt;student, <span class="built_in">vector</span>&lt;student&gt;, cmp_custom&gt; q;</span><br></pre></td></tr></table></figure><h1 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h1><p>优先队列的常用函数与队列类似，常用的有以下这些，如果想了解详细的用法，请戳<a href="https://en.cppreference.com/w/cpp/container/priority_queue" target="_blank" rel="noopener">在线文档</a></p><table><thead><tr><th style="text-align:center">函数名</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center"><a href="https://en.cppreference.com/w/cpp/container/priority_queue/top" target="_blank" rel="noopener">top</a></td><td style="text-align:center">访问队列的头部元素</td></tr><tr><td style="text-align:center"><a href="https://en.cppreference.com/w/cpp/container/priority_queue/empty" target="_blank" rel="noopener">empty</a></td><td style="text-align:center">判断优先队列内是否有元素</td></tr><tr><td style="text-align:center"><a href="https://en.cppreference.com/w/cpp/container/priority_queue/size" target="_blank" rel="noopener">size</a></td><td style="text-align:center">返回优先队列内元素个数</td></tr><tr><td style="text-align:center"><a href="https://en.cppreference.com/w/cpp/container/priority_queue/push" target="_blank" rel="noopener">push</a></td><td style="text-align:center">向优先队列中插入元素</td></tr><tr><td style="text-align:center"><a href="https://en.cppreference.com/w/cpp/container/priority_queue/emplace" target="_blank" rel="noopener">emplace</a></td><td style="text-align:center">在优先队列中构造元素</td></tr><tr><td style="text-align:center"><a href="https://en.cppreference.com/w/cpp/container/priority_queue/pop" target="_blank" rel="noopener">pop</a></td><td style="text-align:center">从优先队列头部弹出元素</td></tr><tr><td style="text-align:center"><a href="https://en.cppreference.com/w/cpp/container/priority_queue/swap" target="_blank" rel="noopener">swap</a></td><td style="text-align:center">与其他容器交换元素</td></tr></tbody></table><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>优先队列在一些需要部分排序的场景可以加快访问速度，降低时间复杂度</li><li>优先队列加速所付出的代价就是构建堆结构所需的内存，时间和空间总是一对矛盾共同体</li><li>以自定义结构作为元素的优先队列需要单独编写比较函数，可以使用lambda表达式，并用 <code>decltype(cmp)</code> 推导类型</li><li>需要注意的是这里的优先队列定义，第三个参数的需要的是比较函数的参数类型，而不是比较函数，区分与 <code>std::sort</code> 的不同</li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/108439423" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>人在比较中奋进，同在比较中消亡，起初面临差距时会奋起直追，但是当努力过后发现距离反而越来越远时，便会麻木懈怠，曾经的努力没有用吗？我觉得不是，努力过不一定会成功，但是努力的过程已经印在了骨子里，这本身就是生活的一部分。你可以选择这条艰苦的路，同样也可以选择跳过，至于跳过时错失了什么，谁又知道呢？毕竟人生无法再来过，重新读档只发生在游戏世界中~</p><p>2020-9-12 17:06:10</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;学习优先队列之前先看个单词队列 queue， 这个单词的读法很多人都能读对吧，音标是 &lt;code&gt;/kjuː/&lt;/code&gt; ，再看一个双端队列 deque，它的音标是 &lt;code&gt;/dek/&lt;/code&gt;，应该有人读错了吧，反正我是没读对，刚开始看见一次错一次，现在还好了，基本能记住怎么读了，可是这些队列怎么用呢？&lt;/p&gt;
    
    </summary>
    
      <category term="C/C++" scheme="http://AlbertGithubHome.github.io/blog/categories/C-C/"/>
    
    
      <category term="C/C++" scheme="http://AlbertGithubHome.github.io/blog/tags/C-C/"/>
    
      <category term="queue" scheme="http://AlbertGithubHome.github.io/blog/tags/queue/"/>
    
      <category term="priority_queue" scheme="http://AlbertGithubHome.github.io/blog/tags/priority-queue/"/>
    
      <category term="heap" scheme="http://AlbertGithubHome.github.io/blog/tags/heap/"/>
    
  </entry>
  
  <entry>
    <title>git log根据特定条件查询日志并统计修改的代码行数</title>
    <link href="http://AlbertGithubHome.github.io/blog/2020/09/05/git-log%E6%A0%B9%E6%8D%AE%E7%89%B9%E5%AE%9A%E6%9D%A1%E4%BB%B6%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97%E5%B9%B6%E7%BB%9F%E8%AE%A1%E4%BF%AE%E6%94%B9%E7%9A%84%E4%BB%A3%E7%A0%81%E8%A1%8C%E6%95%B0/"/>
    <id>http://AlbertGithubHome.github.io/blog/2020/09/05/git-log根据特定条件查询日志并统计修改的代码行数/</id>
    <published>2020-09-04T16:01:27.000Z</published>
    <updated>2020-09-06T16:29:49.470Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://img-blog.csdnimg.cn/20200907002654523.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9hbGJlcnRnaXRodWJob21lLmdpdGh1Yi5pby9ibG9nL2Fib3V0,size_10,color_FFFFFF,t_70#pic_center" alt="gitlog"></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>随着年龄的增长和知识的积累，最近常常有种豁然开朗的感觉，或者对一个已经存在的事物突然有了新的认识，比如统计这个词很早就接触了，从没考虑过它是什么意思，而这篇总结的题目中用了统计一词，第一感觉应该是汇总、记录的意思，后来去查了词条定义，也确实就是类似的解释，从没有刻意去学这个词的含义，但是在每天的生活中已经潜移默化地归纳、总结出来了。</p><a id="more"></a><p>想要统计就得有数据源，而 <code>git log</code> 命令恰恰就能提供这个数据源，<code>git log</code> 本身就是一个显示日志的命令，日志记录的是代码库变化的数据，类似于描述代码库变化的 “史书”，想要描述历史就需要大量的数据支撑，想要统计修改的代码行数，只要我们从历史记录中找到需要计算的部分就可以了。</p><h1 id="git-log"><a href="#git-log" class="headerlink" title="git log"></a>git log</h1><p>在统计之前我们需要先整理数据，杂乱无章的数据不是不能统计，只是计算起来更加的麻烦，所以在统计前需要先将数据规范化，所以我们需要先学习一下 <code>git log</code> 的相关操作。</p><p>我们以 <code>redis</code> 开源库为例，切换到 <code>6.0</code> 分支，提交记录定位到 <code>7bf665f125a4771db095c83a7ad6ed46692cd314</code>，以此为数据源，学习一下<code>git log</code> 的常用的查询方法，其实使用不同的条件查询就是整理、归类数据的过程。</p><p><code>git log</code> 的用法多种多样，我们主要关心两个大类，分别是条件筛选和显示格式。</p><h2 id="条件筛选"><a href="#条件筛选" class="headerlink" title="条件筛选"></a>条件筛选</h2><p><code>git log</code> 条件筛选的选项非常多，使用条件筛选的选项会影响显示的提交记录的范围，查找到想要显示的提交记录。</p><h3 id="查询最近几条log"><a href="#查询最近几条log" class="headerlink" title="查询最近几条log"></a>查询最近几条log</h3><p>使用 <code>-number</code> 参数可以查询最近几条提交提交记录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> -3</span><br><span class="line">commit 7bf665f125a4771db095c83a7ad6ed46692cd314 (HEAD -&gt; 6.0, tag: 6.0.6, origin/6.0)</span><br><span class="line">Author: Oran Agra &lt;oran@redislabs.com&gt;</span><br><span class="line">Date:   Sun Jul 19 14:00:20 2020 +0300</span><br><span class="line"></span><br><span class="line">    Redis 6.0.6.</span><br><span class="line"></span><br><span class="line">commit a5696bdf4f2687ab45f633ccb7cdc4ee9c2f957d</span><br><span class="line">Author: Oran Agra &lt;oran@redislabs.com&gt;</span><br><span class="line">Date:   Sun Jul 19 15:33:21 2020 +0300</span><br><span class="line"></span><br><span class="line">    Run daily CI on PRs to release a branch</span><br><span class="line"></span><br><span class="line">commit e15528bf1da1f1232fd08801ad382c915be94662</span><br><span class="line">Author: Itamar Haber &lt;itamar@redislabs.com&gt;</span><br><span class="line">Date:   Thu Jul 16 21:31:36 2020 +0300</span><br><span class="line"></span><br><span class="line">    Adds SHA256SUM to redis-stable tarball upload</span><br><span class="line"></span><br><span class="line">    (cherry picked from commit 5df0a64d30e7815c0a4a75a80f165fdee0bd1db6)</span><br></pre></td></tr></table></figure><h3 id="查询指定作者提交"><a href="#查询指定作者提交" class="headerlink" title="查询指定作者提交"></a>查询指定作者提交</h3><p>使用 <code>--author</code> 参数可以查询指定作者的提交记录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Albert@DESKTOP-6746UC3 MINGW64 /d/data/maingit/redis (6.0)</span><br><span class="line">$ git <span class="built_in">log</span> -2 --author=<span class="string">'Oran Agra'</span></span><br><span class="line">commit 7bf665f125a4771db095c83a7ad6ed46692cd314 (HEAD -&gt; 6.0, tag: 6.0.6, origin/6.0)</span><br><span class="line">Author: Oran Agra &lt;oran@redislabs.com&gt;</span><br><span class="line">Date:   Sun Jul 19 14:00:20 2020 +0300</span><br><span class="line"></span><br><span class="line">    Redis 6.0.6.</span><br><span class="line"></span><br><span class="line">commit a5696bdf4f2687ab45f633ccb7cdc4ee9c2f957d</span><br><span class="line">Author: Oran Agra &lt;oran@redislabs.com&gt;</span><br><span class="line">Date:   Sun Jul 19 15:33:21 2020 +0300</span><br><span class="line"></span><br><span class="line">    Run daily CI on PRs to release a branch</span><br></pre></td></tr></table></figure><h3 id="查询指定时间段的日志"><a href="#查询指定时间段的日志" class="headerlink" title="查询指定时间段的日志"></a>查询指定时间段的日志</h3><p>这个可选参数比较多，比如 <code>--since</code>、<code>--until</code>、<code>--before</code>、<code>--after</code> 等等，从意思很容易分辨怎么使用：</p><p><strong>查询2020-01-01到2020-04-01的提交记录</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> -2 --after=2020-01-01 --before=2020-04-01</span><br><span class="line">commit 957e917a84ac9979f18145a4d0b53386f5ce4fd9 (tag: 6.0-rc3)</span><br><span class="line">Author: antirez &lt;antirez@gmail.com&gt;</span><br><span class="line">Date:   Tue Mar 31 17:56:04 2020 +0200</span><br><span class="line"></span><br><span class="line">    Redis 6.0-RC3.</span><br><span class="line"></span><br><span class="line">commit ef1b1f01a84e969ea368e7fdbaf0d10615743269</span><br><span class="line">Author: antirez &lt;antirez@gmail.com&gt;</span><br><span class="line">Date:   Tue Mar 31 17:41:23 2020 +0200</span><br><span class="line"></span><br><span class="line">    cast raxSize() to avoid warning with format spec.</span><br></pre></td></tr></table></figure><p><em>恰好逮到了原作者的提交~</em></p><p><strong>查询1年前的提交记录</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> -2 --until=1.year.ago</span><br><span class="line">commit 86aade9a024c3582665903d0cc0c5692c6677cfd</span><br><span class="line">Merge: 89ad0ca56 3bfcae247</span><br><span class="line">Author: Salvatore Sanfilippo &lt;antirez@gmail.com&gt;</span><br><span class="line">Date:   Thu Sep 5 13:30:26 2019 +0200</span><br><span class="line"></span><br><span class="line">    Merge pull request <span class="comment">#6364 from oranagra/fix_module_aux_when</span></span><br><span class="line"></span><br><span class="line">    Fix to module aux data rdb format <span class="keyword">for</span> backwards compatibility with old check-rdb</span><br><span class="line"></span><br><span class="line">commit 3bfcae247a1c51788940bd4d2f32751ead451e42</span><br><span class="line">Author: Oran Agra &lt;oran@redislabs.com&gt;</span><br><span class="line">Date:   Thu Sep 5 14:11:37 2019 +0300</span><br><span class="line"></span><br><span class="line">    Fix to module aux data rdb format <span class="keyword">for</span> backwards compatibility with old check-rdb</span><br><span class="line"></span><br><span class="line">    When implementing the code that saves and loads these aux fields we used rdb</span><br><span class="line">    format that was added <span class="keyword">for</span> that <span class="keyword">in</span> redis 5.0, but <span class="keyword">then</span> we added the <span class="string">'when'</span> field</span><br><span class="line">    <span class="built_in">which</span> meant that the old redis-check-rdb won<span class="string">'t be able to skip these.</span></span><br><span class="line"><span class="string">    this fix adds an opcode as if that '</span>when<span class="string">' is part of the module data.</span></span><br></pre></td></tr></table></figure><h3 id="查询包含指定描述内容的提交记录"><a href="#查询包含指定描述内容的提交记录" class="headerlink" title="查询包含指定描述内容的提交记录"></a>查询包含指定描述内容的提交记录</h3><p>这里用可以使用 <code>--grep</code> 参数，可以过滤出包含指定内容的提交记录，这里指的是在 commit 描述中筛选符合条件的提交，比如查找提交描述中包含 client 的提交记录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> -2 --grep=<span class="string">'client'</span></span><br><span class="line">commit 0f75036c07db48dfcf605e090216a4447edc38fc</span><br><span class="line">Author: Wen Hui &lt;wen.hui.ware@gmail.com&gt;</span><br><span class="line">Date:   Wed Jul 15 05:38:47 2020 -0400</span><br><span class="line"></span><br><span class="line">    correct error msg <span class="keyword">for</span> num connections reaching maxclients <span class="keyword">in</span> cluster mode (<span class="comment">#7444)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    (cherry picked from commit d85af4d6f5fbe9cb9787b81583627cd74b47f838)</span><br><span class="line"></span><br><span class="line">commit f89f50dbd06247677b8cb3927cbb88c1b5384061</span><br><span class="line">Author: Oran Agra &lt;oran@redislabs.com&gt;</span><br><span class="line">Date:   Tue Jul 14 20:21:59 2020 +0300</span><br><span class="line"></span><br><span class="line">    diskless master disconnect replicas when rdb child failed (<span class="comment">#7518)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">in</span> <span class="keyword">case</span> the rdb child failed, crashed or terminated unexpectedly redis</span><br><span class="line">    would have marked the replica clients with repl_put_online_on_ack and</span><br><span class="line">    <span class="keyword">then</span> <span class="built_in">kill</span> them only after a minute when no ack was received.</span><br><span class="line"></span><br><span class="line">    it would not stream anything to these connections, so the only effect of</span><br><span class="line">    this bug is a delay of 1 minute <span class="keyword">in</span> the replicas attempt to re-connect.</span><br><span class="line"></span><br><span class="line">    (cherry picked from commit a176cb56a3c0235adddde33fcbaee2369a5af73e)</span><br></pre></td></tr></table></figure><h3 id="查找指定分支的提交记录"><a href="#查找指定分支的提交记录" class="headerlink" title="查找指定分支的提交记录"></a>查找指定分支的提交记录</h3><p>使用 <code>git log</code> 默认查找的是当前分支的提交记录，如果想查询其他分支的记录直接在命令后面加上分支名字就行，比如查询 <code>arm</code> 分支上的提交记录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> -2 arm</span><br><span class="line">commit 7329cc39818a05c168e7d1e791afb03c089f1933 (origin/arm, arm)</span><br><span class="line">Author: Salvatore Sanfilippo &lt;antirez@gmail.com&gt;</span><br><span class="line">Date:   Sun Feb 19 15:07:08 2017 +0000</span><br><span class="line"></span><br><span class="line">    ARM: Avoid fast path <span class="keyword">for</span> BITOP.</span><br><span class="line"></span><br><span class="line">    GCC will produce certain unaligned multi load-store instructions</span><br><span class="line">    that will be trapped by the Linux kernel since ARM v6 cannot</span><br><span class="line">    handle them with unaligned addresses. Better to use the slower</span><br><span class="line">    but safer implementation instead of generating the exception <span class="built_in">which</span></span><br><span class="line">    should be anyway very slow.</span><br><span class="line"></span><br><span class="line">commit 4e9cf4cc7ed4b732fc4bb592f19ceb41d132954e</span><br><span class="line">Author: Salvatore Sanfilippo &lt;antirez@gmail.com&gt;</span><br><span class="line">Date:   Sun Feb 19 15:02:37 2017 +0000</span><br><span class="line"></span><br><span class="line">    ARM: Use libc malloc by default.</span><br><span class="line"></span><br><span class="line">    I<span class="string">'m not sure how much test Jemalloc gets on ARM, moreover</span></span><br><span class="line"><span class="string">    compiling Redis with Jemalloc support in not very powerful</span></span><br><span class="line"><span class="string">    devices, like most ARMs people will build Redis on, is extremely</span></span><br><span class="line"><span class="string">    slow. It is possible to enable Jemalloc build anyway if needed</span></span><br><span class="line"><span class="string">    by using "make MALLOC=jemalloc".</span></span><br></pre></td></tr></table></figure><p>其实在 git 体系中，分支名、commit、标签等拥有几乎相同的含义，所以在很多场景下可以扩展互换，比如 <code>git log</code> 后面加上分支名就可以查询指定分支的提交记录，如果加上 commit 就会查询这个 commit 之前的提交记录，如果加上标签，就可以查询这个标签之前的提交记录，比如我们加一个 commit 试试：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> -2 7329cc39818a05c168e7d1e791afb03c089f1933</span><br><span class="line">commit 7329cc39818a05c168e7d1e791afb03c089f1933 (origin/arm, arm)</span><br><span class="line">Author: Salvatore Sanfilippo &lt;antirez@gmail.com&gt;</span><br><span class="line">Date:   Sun Feb 19 15:07:08 2017 +0000</span><br><span class="line"></span><br><span class="line">    ARM: Avoid fast path <span class="keyword">for</span> BITOP.</span><br><span class="line"></span><br><span class="line">    GCC will produce certain unaligned multi load-store instructions</span><br><span class="line">    that will be trapped by the Linux kernel since ARM v6 cannot</span><br><span class="line">    handle them with unaligned addresses. Better to use the slower</span><br><span class="line">    but safer implementation instead of generating the exception <span class="built_in">which</span></span><br><span class="line">    should be anyway very slow.</span><br><span class="line"></span><br><span class="line">commit 4e9cf4cc7ed4b732fc4bb592f19ceb41d132954e</span><br><span class="line">Author: Salvatore Sanfilippo &lt;antirez@gmail.com&gt;</span><br><span class="line">Date:   Sun Feb 19 15:02:37 2017 +0000</span><br><span class="line"></span><br><span class="line">    ARM: Use libc malloc by default.</span><br><span class="line"></span><br><span class="line">    I<span class="string">'m not sure how much test Jemalloc gets on ARM, moreover</span></span><br><span class="line"><span class="string">    compiling Redis with Jemalloc support in not very powerful</span></span><br><span class="line"><span class="string">    devices, like most ARMs people will build Redis on, is extremely</span></span><br><span class="line"><span class="string">    slow. It is possible to enable Jemalloc build anyway if needed</span></span><br><span class="line"><span class="string">    by using "make MALLOC=jemalloc".</span></span><br></pre></td></tr></table></figure><p>因为 commit id 就是之前的 arm 分支最新的记录，所以这个命令等价于 <code>git log -2 arm</code></p><h3 id="查询指定-commit-之间的提交记录"><a href="#查询指定-commit-之间的提交记录" class="headerlink" title="查询指定 commit 之间的提交记录"></a>查询指定 commit 之间的提交记录</h3><p>如果想查询两个 commit 之前的提交记录，可以将两个 commit id 依次放在命令后面并用 <code>..</code> 连接就可以了，格式为 <code>git log commit1..commit2</code>，需要注意的是这样查询出来的提交记录列表中不包含 commit1，其实列举出的就是 commit1 之后又做了哪些修改提交。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> e15528bf1da1f1232fd08801ad382c915be94662..7bf665f125a4771db095c83a7ad6ed46692cd314</span><br><span class="line">commit 7bf665f125a4771db095c83a7ad6ed46692cd314 (HEAD -&gt; 6.0, tag: 6.0.6, origin/6.0)</span><br><span class="line">Author: Oran Agra &lt;oran@redislabs.com&gt;</span><br><span class="line">Date:   Sun Jul 19 14:00:20 2020 +0300</span><br><span class="line"></span><br><span class="line">    Redis 6.0.6.</span><br><span class="line"></span><br><span class="line">commit a5696bdf4f2687ab45f633ccb7cdc4ee9c2f957d</span><br><span class="line">Author: Oran Agra &lt;oran@redislabs.com&gt;</span><br><span class="line">Date:   Sun Jul 19 15:33:21 2020 +0300</span><br><span class="line"></span><br><span class="line">    Run daily CI on PRs to release a branch</span><br></pre></td></tr></table></figure><p>这个特性有一个应用就是在 merge 分支之前可以查询究竟会 merge 哪些记录，常见的用法比如 <code>git log feature..dev</code> 就是列举出 feature 分支合并到 dev 分支将要合并的提交记录有哪些。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> 6.0..unstable</span><br><span class="line">commit 324e22accf457edc996971bc97f5474349cd7c4c (unstable)</span><br><span class="line">Author: antirez &lt;antirez@gmail.com&gt;</span><br><span class="line">Date:   Fri Dec 20 12:29:02 2019 +0100</span><br><span class="line"></span><br><span class="line">    Fix ip and missing mode <span class="keyword">in</span> RM_GetClusterNodeInfo().</span><br></pre></td></tr></table></figure><h3 id="查询指定文件的提交记录"><a href="#查询指定文件的提交记录" class="headerlink" title="查询指定文件的提交记录"></a>查询指定文件的提交记录</h3><p>查询指定文件的提交记录一般直接在 <code>git log</code> 命令后面跟上文件名就可以，但是为了避免和分支名产生分歧，所以通常在文件名前面加上 <code>--</code> 用来区分，<code>--</code> 这个标识符就是用来防止混淆的，放在 <code>--</code> 前面的是分支名，放在后面的是文件名，相同的作用不仅仅在 <code>git log</code> 命令中，在其他命令比如 <code>git checkout</code> 中也有相同的用法。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> -2 -- redis.conf</span><br><span class="line">commit 7a536c2912be1fd9f62b26b7022a00644c88ef8b</span><br><span class="line">Author: Yossi Gottlieb &lt;yossigo@users.noreply.github.com&gt;</span><br><span class="line">Date:   Fri Jul 10 11:33:47 2020 +0300</span><br><span class="line"></span><br><span class="line">    TLS: Session caching configuration support. (<span class="comment">#7420)</span></span><br><span class="line"></span><br><span class="line">    * TLS: Session caching configuration support.</span><br><span class="line">    * TLS: Remove redundant config initialization.</span><br><span class="line"></span><br><span class="line">    (cherry picked from commit 3e6f2b1a45176ac3d81b95cb6025f30d7aaa1393)</span><br><span class="line"></span><br><span class="line">commit 8312aa27d47c0befcf69eb74d0a5dc19745ffd32</span><br><span class="line">Author: antirez &lt;antirez@gmail.com&gt;</span><br><span class="line">Date:   Mon Jun 22 11:21:21 2020 +0200</span><br><span class="line"></span><br><span class="line">    Clarify maxclients and cluster <span class="keyword">in</span> conf. Remove myself too.</span><br><span class="line"></span><br><span class="line">    (cherry picked from commit 59fd178014c7cca1b0c668b30ab0d991dd3030f3)</span><br></pre></td></tr></table></figure><h2 id="显示格式"><a href="#显示格式" class="headerlink" title="显示格式"></a>显示格式</h2><p><code>git log</code> 除了可以筛选提交记录，还可以控制显示格式，普通不加参数，会显示作者、邮件、提交描述信息、日期等信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> -1</span><br><span class="line">commit 7bf665f125a4771db095c83a7ad6ed46692cd314 (HEAD -&gt; 6.0, tag: 6.0.6, origin/6.0)</span><br><span class="line">Author: Oran Agra &lt;oran@redislabs.com&gt;</span><br><span class="line">Date:   Sun Jul 19 14:00:20 2020 +0300</span><br><span class="line"></span><br><span class="line">    Redis 6.0.6.</span><br></pre></td></tr></table></figure><p>通过添加参数可以控制和改变显示格式，下面来看几条常见的</p><h3 id="显示单行信息"><a href="#显示单行信息" class="headerlink" title="显示单行信息"></a>显示单行信息</h3><p><code>git log</code> 默认会显示多行信息，使用 <code>--oneline</code> 后每条提交记录只显示一行信息，可以在一屏幕中查看到更多的信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> -10 --oneline</span><br><span class="line">7bf665f12 (HEAD -&gt; 6.0, tag: 6.0.6, origin/6.0) Redis 6.0.6.</span><br><span class="line">a5696bdf4 Run daily CI on PRs to release a branch</span><br><span class="line">e15528bf1 Adds SHA256SUM to redis-stable tarball upload</span><br><span class="line">e28aa99af Support passing stack allocated module strings to moduleCreateArgvFromUserFormat (<span class="comment">#7528)</span></span><br><span class="line">305143004 Send null <span class="keyword">for</span> invalidate on flush (<span class="comment">#7469)</span></span><br><span class="line">29b20fd52 Notify systemd on sentinel startup (<span class="comment">#7168)</span></span><br><span class="line">5b3668121 Add registers dump support <span class="keyword">for</span> Apple silicon (<span class="comment">#7453)</span></span><br><span class="line">0f75036c0 correct error msg <span class="keyword">for</span> num connections reaching maxclients <span class="keyword">in</span> cluster mode (<span class="comment">#7444)</span></span><br><span class="line">b1a01fda9 Fix <span class="built_in">command</span> <span class="built_in">help</span> <span class="keyword">for</span> unexpected options (<span class="comment">#7476)</span></span><br><span class="line">83f55f61a Refactor RM_KeyType() by using macro. (<span class="comment">#7486)</span></span><br></pre></td></tr></table></figure><h3 id="显示每条记录中文件修改的具体行数和行体统计"><a href="#显示每条记录中文件修改的具体行数和行体统计" class="headerlink" title="显示每条记录中文件修改的具体行数和行体统计"></a>显示每条记录中文件修改的具体行数和行体统计</h3><p>使用 <code>--stat</code> 参数就可以显示每条记录的中修改文件的具体行数和行数统计</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> -2 --<span class="built_in">stat</span></span><br><span class="line">commit 7bf665f125a4771db095c83a7ad6ed46692cd314 (HEAD -&gt; 6.0, tag: 6.0.6, origin/6.0)</span><br><span class="line">Author: Oran Agra &lt;oran@redislabs.com&gt;</span><br><span class="line">Date:   Sun Jul 19 14:00:20 2020 +0300</span><br><span class="line"></span><br><span class="line">    Redis 6.0.6.</span><br><span class="line"></span><br><span class="line"> 00-RELEASENOTES | 245 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span><br><span class="line"> src/help.h      |   4 +-</span><br><span class="line"> src/version.h   |   2 +-</span><br><span class="line"> 3 files changed, 248 insertions(+), 3 deletions(-)</span><br><span class="line"></span><br><span class="line">commit a5696bdf4f2687ab45f633ccb7cdc4ee9c2f957d</span><br><span class="line">Author: Oran Agra &lt;oran@redislabs.com&gt;</span><br><span class="line">Date:   Sun Jul 19 15:33:21 2020 +0300</span><br><span class="line"></span><br><span class="line">    Run daily CI on PRs to release a branch</span><br><span class="line"></span><br><span class="line"> .github/workflows/daily.yml | 6 ++++--</span><br><span class="line"> 1 file changed, 4 insertions(+), 2 deletions(-)</span><br></pre></td></tr></table></figure><h3 id="显示每条提交记录中文件的增加行数和删除行数"><a href="#显示每条提交记录中文件的增加行数和删除行数" class="headerlink" title="显示每条提交记录中文件的增加行数和删除行数"></a>显示每条提交记录中文件的增加行数和删除行数</h3><p>使用 <code>--numstat</code> 参数会把 <code>--stat</code> 参数中合并显示的修改行数拆分成增加行数和删除行数</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> -2 --numstat</span><br><span class="line">commit 7bf665f125a4771db095c83a7ad6ed46692cd314 (HEAD -&gt; 6.0, tag: 6.0.6, origin/6.0)</span><br><span class="line">Author: Oran Agra &lt;oran@redislabs.com&gt;</span><br><span class="line">Date:   Sun Jul 19 14:00:20 2020 +0300</span><br><span class="line"></span><br><span class="line">    Redis 6.0.6.</span><br><span class="line"></span><br><span class="line">245     0       00-RELEASENOTES</span><br><span class="line">2       2       src/help.h</span><br><span class="line">1       1       src/version.h</span><br><span class="line"></span><br><span class="line">commit a5696bdf4f2687ab45f633ccb7cdc4ee9c2f957d</span><br><span class="line">Author: Oran Agra &lt;oran@redislabs.com&gt;</span><br><span class="line">Date:   Sun Jul 19 15:33:21 2020 +0300</span><br><span class="line"></span><br><span class="line">    Run daily CI on PRs to release a branch</span><br><span class="line"></span><br><span class="line">4       2       .github/workflows/daily.yml</span><br></pre></td></tr></table></figure><h3 id="依次罗列各提交记录中每个文件中增加的行数和删除的行数"><a href="#依次罗列各提交记录中每个文件中增加的行数和删除的行数" class="headerlink" title="依次罗列各提交记录中每个文件中增加的行数和删除的行数"></a>依次罗列各提交记录中每个文件中增加的行数和删除的行数</h3><p>要想达到这个目的需要用到 <code>--prety=tformat: --numstat</code> 参数，这样的显示格式便于统计</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> -2 --pretty=tformat: --numstat</span><br><span class="line">245     0       00-RELEASENOTES</span><br><span class="line">2       2       src/help.h</span><br><span class="line">1       1       src/version.h</span><br><span class="line">4       2       .github/workflows/daily.yml</span><br></pre></td></tr></table></figure><h1 id="统计修改的代码行数"><a href="#统计修改的代码行数" class="headerlink" title="统计修改的代码行数"></a>统计修改的代码行数</h1><p>有了前面的铺垫，想要统一修改的行数就容易了，只要配合 <code>awk</code> 工具就可以完成统计了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ $ git <span class="built_in">log</span> -2 --pretty=tformat: --numstat  | awk <span class="string">'&#123;adds += $1; subs += $2; diffs += $1 - $2&#125; END &#123;printf "added lines: %s removed lines: %s, diff lines: %s\n", adds, subs, diffs&#125;'</span></span><br><span class="line">added lines: 252 removed lines: 5, diff lines: 247</span><br></pre></td></tr></table></figure><p>还可以统计两个分支相差的代码行数</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> 6.0..unstable --pretty=tformat: --numstat  | awk <span class="string">'&#123;adds += $1; subs += $2; diffs += $1 - $2&#125; END &#123;printf "added lines: %s removed lines: %s, diff lines: %s\n", adds, subs, diffs&#125;'</span></span><br><span class="line">added lines: 5 removed lines: 2, diff lines: 3</span><br></pre></td></tr></table></figure><p>到这里可以发现前面的知识都可以用上，前面筛选的参数变了，得到的结果就变了，我们可以根据需求来调整不同的参数</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li><code>git log</code> 就是一部代码库记录的“史书”，对于曾经所做的修改可以做到有史可查</li><li><code>git log</code> 的选项参数可以分为筛选参数和格式参数，筛选参数可以选择记录范围，格式参数可以控制显示样式</li><li>统计就是按照一定规律来将数据进行汇总，在进行汇总前需要将数据进行整理，这样汇总的工作才会更加顺利</li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/108311845" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>慌慌张张，匆匆忙忙，原来生活就是这样~</p><p>2020-9-7 00:05:18</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200907002654523.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9hbGJlcnRnaXRodWJob21lLmdpdGh1Yi5pby9ibG9nL2Fib3V0,size_10,color_FFFFFF,t_70#pic_center&quot; alt=&quot;gitlog&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;随着年龄的增长和知识的积累，最近常常有种豁然开朗的感觉，或者对一个已经存在的事物突然有了新的认识，比如统计这个词很早就接触了，从没考虑过它是什么意思，而这篇总结的题目中用了统计一词，第一感觉应该是汇总、记录的意思，后来去查了词条定义，也确实就是类似的解释，从没有刻意去学这个词的含义，但是在每天的生活中已经潜移默化地归纳、总结出来了。&lt;/p&gt;
    
    </summary>
    
      <category term="Git" scheme="http://AlbertGithubHome.github.io/blog/categories/Git/"/>
    
    
      <category term="git" scheme="http://AlbertGithubHome.github.io/blog/tags/git/"/>
    
      <category term="log" scheme="http://AlbertGithubHome.github.io/blog/tags/log/"/>
    
      <category term="awk" scheme="http://AlbertGithubHome.github.io/blog/tags/awk/"/>
    
      <category term="统计" scheme="http://AlbertGithubHome.github.io/blog/tags/%E7%BB%9F%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>Python中时间戳、时间字符串、时间结构对象之间的相互转化</title>
    <link href="http://AlbertGithubHome.github.io/blog/2020/08/27/Python%E4%B8%AD%E6%97%B6%E9%97%B4%E6%88%B3%E3%80%81%E6%97%B6%E9%97%B4%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%81%E6%97%B6%E9%97%B4%E7%BB%93%E6%9E%84%E5%AF%B9%E8%B1%A1%E4%B9%8B%E9%97%B4%E7%9A%84%E7%9B%B8%E4%BA%92%E8%BD%AC%E5%8C%96/"/>
    <id>http://AlbertGithubHome.github.io/blog/2020/08/27/Python中时间戳、时间字符串、时间结构对象之间的相互转化/</id>
    <published>2020-08-27T15:32:21.000Z</published>
    <updated>2020-09-02T15:49:01.373Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>使用 Python 写程序的时候常常要查看中间结果，需要把一些内容记录到日志中，为了不让新产生的日志覆盖之前的日志文件，所以通常使用时间字符串来作为文件名，类似于 <code>2020827_233842.log</code> 这种格式，就是表示程序在 2020-8-27 23:38:42 启动时产生的日志文件。</p><a id="more"></a><p>日志文件名需要一个字符串，但是这个时间字符串不能直接得到，需要将时间戳经过转化才可以，每次用到都要查一次有些浪费时间，总结到一起方便自己今后快速查找。</p><p>通过学习总结发现，操作时间和日期常用的模块有 <code>time</code> 和 <code>datetime</code> 这两个，并且 <code>time</code> 模块与 C 语言中的时间处理函数颇为相似，下面来一起看一下吧。</p><h1 id="时间的表示形式"><a href="#时间的表示形式" class="headerlink" title="时间的表示形式"></a>时间的表示形式</h1><p>显示生活中的时间表示形式多种多样，比如15分钟可以说成是1刻钟，半夜12点可以叫做子时，在程序中也有几种常用的表示形式，比如 python 中的时间戳、时间结构对象和时间字符串，分别对应 <code>C</code> 语言中的<code>time_t</code>、<code>struct tm</code> 和 <code>char[]</code>，处理函数的名字也很相近，自己可以扩展学习下，本文只列举 <code>Python</code> 的用法了</p><h2 id="时间戳"><a href="#时间戳" class="headerlink" title="时间戳"></a>时间戳</h2><p>在Python中被实现成一个浮点数，表示从1970年1月1日00:00:00到当前时间所经历的秒数，因为是浮点数所以可以表示不足1秒的时间，而在有些语言中，比如<code>C</code> 语言中使用整数来表示这个值，在 python 中使用 <code>time.time()</code> 函数来获取时间戳：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">val = time.time()</span><br><span class="line">print(val, type(val))</span><br><span class="line"></span><br><span class="line"><span class="string">'''输出结果</span></span><br><span class="line"><span class="string">1598769108.8337526 &lt;class 'float'&gt;</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><h2 id="时间结构对象"><a href="#时间结构对象" class="headerlink" title="时间结构对象"></a>时间结构对象</h2><p>在 python 中使用 <code>time.struct_time</code> 这个类用来表示时间结构，其实是一个九元组，可以参考C语言中的 <code>struct tm</code>结构，表现形式相同，在 python 中这个九元组中元素依次表达的含义是：4位数年份、1-12月、1-31日、0-23小时、0-59分钟，0-59秒，0-6一周第几日，1-366一年第几日，{-1, 0, 1}夏令时标志。</p><p>通过代码我们可以尝试构造如下，不够时间使用时通常是通过函数转化，很少直接构造 <code>time.struct_time</code> 对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">val = time.struct_time([<span class="number">2020</span>, <span class="number">8</span>, <span class="number">30</span>, <span class="number">14</span>, <span class="number">45</span>, <span class="number">30</span>, <span class="number">6</span>, <span class="number">243</span>, <span class="number">0</span>])</span><br><span class="line">print(val, type(val))</span><br><span class="line"></span><br><span class="line"><span class="string">'''输出结果</span></span><br><span class="line"><span class="string">time.struct_time(tm_year=2020, tm_mon=8, tm_mday=30, tm_hour=14,</span></span><br><span class="line"><span class="string">    tm_min=45, tm_sec=30, tm_wday=6, tm_yday=243, tm_isdst=0) &lt;class 'time.struct_time'&gt;</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><h2 id="时间字符串"><a href="#时间字符串" class="headerlink" title="时间字符串"></a>时间字符串</h2><p>时间字符串是本质上是一种普通的字符串，因为用来表示时间所以感觉上有些不同，实际使用过程时会通过转化函数来生成时间字符串，然后就可以当场普通字符串来使用了，比如记录日志时间，作为文件名等都是常见用法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">val = <span class="string">'2019-08-30 15:04:00'</span></span><br><span class="line">print(val, type(val))</span><br><span class="line"></span><br><span class="line"><span class="string">'''输出结果</span></span><br><span class="line"><span class="string">2019-08-30 15:04:00 &lt;class 'str'&gt;</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><h1 id="举例说明"><a href="#举例说明" class="headerlink" title="举例说明"></a>举例说明</h1><p>仅仅认识了这三种类型还是不够的，还要学习经常使用的转化函数才可以，上面提到的这三种类型一般不会从时间戳到字符串或者从字符戳到时间戳，都是通过时间结构对象来转化的，所以常见的转化是时间戳和时间结构对象的转化、时间结构对象和时间字符串的转化，需要用到的函数展示如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/albertgithubhome/cdn/img/python_time.png" alt="python_time"></p><h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成时间戳</span></span><br><span class="line">t = time.time()</span><br><span class="line">print(t, type(t))</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">1598775821.840567 &lt;class 'float'&gt;</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成时间结构对象(本地时间)</span></span><br><span class="line">l = time.localtime()</span><br><span class="line">print(l, type(l))</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">time.struct_time(tm_year=2020, tm_mon=8, tm_mday=30, tm_hour=16, tm_min=23,</span></span><br><span class="line"><span class="string"> tm_sec=41, tm_wday=6, tm_yday=243, tm_isdst=0) &lt;class 'time.struct_time'&gt;</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 时间戳 -&gt; 时间结构对象(本地时间)</span></span><br><span class="line">l = time.localtime(t)</span><br><span class="line">print(l, type(l))</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">time.struct_time(tm_year=2020, tm_mon=8, tm_mday=30, tm_hour=16, tm_min=23,</span></span><br><span class="line"><span class="string"> tm_sec=41, tm_wday=6, tm_yday=243, tm_isdst=0) &lt;class 'time.struct_time'&gt;</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成时间结构对象(格林威治时间)</span></span><br><span class="line">g = time.gmtime()</span><br><span class="line">print(g, type(g))</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">time.struct_time(tm_year=2020, tm_mon=8, tm_mday=30, tm_hour=8, tm_min=23,</span></span><br><span class="line"><span class="string"> tm_sec=41, tm_wday=6, tm_yday=243, tm_isdst=0) &lt;class 'time.struct_time'&gt;</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 时间戳 -&gt; 时间结构对象(格林威治时间)</span></span><br><span class="line">g = time.gmtime(t)</span><br><span class="line">print(g, type(g))</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">time.struct_time(tm_year=2020, tm_mon=8, tm_mday=30, tm_hour=8, tm_min=23,</span></span><br><span class="line"><span class="string"> tm_sec=41, tm_wday=6, tm_yday=243, tm_isdst=0) &lt;class 'time.struct_time'&gt;</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成时间字符串</span></span><br><span class="line">s = time.strftime(<span class="string">"%Y-%m-%d %X"</span>)</span><br><span class="line">print(s, type(s))</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">2020-08-30 16:23:41 &lt;class 'str'&gt;</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 时间结构对象 -&gt; 时间字符串</span></span><br><span class="line">s = time.strftime(<span class="string">"%Y-%m-%d %X"</span>,time.localtime())</span><br><span class="line">print(s, type(s))</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">2020-08-30 16:23:41 &lt;class 'str'&gt;</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"><span class="string">'================================================================='</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义时间字符串</span></span><br><span class="line">s = <span class="string">'2022-02-18 09:30:00'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 时间字符串 -&gt; 时间结构对象</span></span><br><span class="line">l = time.strptime(s, <span class="string">'%Y-%m-%d %X'</span>)</span><br><span class="line">print(l, type(l))</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">time.struct_time(tm_year=2022, tm_mon=2, tm_mday=18, tm_hour=9, tm_min=30,</span></span><br><span class="line"><span class="string"> tm_sec=0, tm_wday=4, tm_yday=49, tm_isdst=-1) &lt;class 'time.struct_time'&gt;</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 时间结构对象 -&gt; 时间戳</span></span><br><span class="line">t = time.mktime(l)</span><br><span class="line">print(t, type(t))</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">1645147800.0 &lt;class 'float'&gt;</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"><span class="string">'================================================================='</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成固定格式(%a %b %d %H:%M:%S %Y)时间字符串</span></span><br><span class="line">s = time.asctime(time.localtime())</span><br><span class="line">print(s, type(s))</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">Sun Aug 30 16:23:41 2020 &lt;class 'str'&gt;</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line">s = time.ctime(time.time())</span><br><span class="line">print(s, type(s))</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">Sun Aug 30 16:23:41 2020 &lt;class 'str'&gt;</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><h2 id="格式化符号"><a href="#格式化符号" class="headerlink" title="格式化符号"></a>格式化符号</h2><p>将时间转化成字符串表示形式的时候，需要使用格式化符号，为了查找方便整理如下：</p><table><thead><tr><th><strong>格式</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>%a</td><td>本地（locale）简化星期名称</td></tr><tr><td>%A</td><td>本地完整星期名称</td></tr><tr><td>%b</td><td>本地简化月份名称</td></tr><tr><td>%B</td><td>本地完整月份名称</td></tr><tr><td>%c</td><td>本地相应的日期和时间表示</td></tr><tr><td>%d</td><td>一个月中的第几天（01 - 31）</td></tr><tr><td>%H</td><td>一天中的第几个小时（24小时制，00 - 23）</td></tr><tr><td>%I</td><td>第几个小时（12小时制，01 - 12）</td></tr><tr><td>%j</td><td>一年中的第几天（001 - 366）</td></tr><tr><td>%m</td><td>月份（01 - 12）</td></tr><tr><td>%M</td><td>分钟数（00 - 59）</td></tr><tr><td>%p</td><td>本地am或者pm的相应符</td></tr><tr><td>%S</td><td>秒（00 - 59）</td></tr><tr><td>%U</td><td>一年中的星期数。（00 - 53星期天是一个星期的开始。）</td></tr><tr><td>%w</td><td>一个星期中的第几天（0 - 6，0是星期天）</td></tr><tr><td>%W</td><td>和%U基本相同，不同的是%W以星期一为一个星期的开始。</td></tr><tr><td>%x</td><td>本地相应日期</td></tr><tr><td>%X</td><td>本地相应时间</td></tr><tr><td>%y</td><td>去掉世纪的年份（00 - 99）</td></tr><tr><td>%Y</td><td>完整的年份</td></tr><tr><td>%Z</td><td>时区的名字（如果不存在为空字符）</td></tr></tbody></table><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>时间戳和时间字符串的转化，通常要经过时间结构对象作为中间结果。</li><li>时间戳也可以通过 <code>time.ctime()</code> 函数直接转化为时间字符串，但格式固定。</li><li>常用来表示文件名的时间字符串写法：<code>time.strftime(&quot;%Y%m%d_%H%M%S&quot;, time.localtime())</code></li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/108212001" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>有时选择的意义确实高于努力的结果，认清这一点，学会适当的放下，会让焦躁的生活更美好一点，毕竟全部都坚持真的太累了，有时收益真的不高~</p><p>2020-8-30 21:50:19</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;使用 Python 写程序的时候常常要查看中间结果，需要把一些内容记录到日志中，为了不让新产生的日志覆盖之前的日志文件，所以通常使用时间字符串来作为文件名，类似于 &lt;code&gt;2020827_233842.log&lt;/code&gt; 这种格式，就是表示程序在 2020-8-27 23:38:42 启动时产生的日志文件。&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="http://AlbertGithubHome.github.io/blog/categories/Python/"/>
    
    
      <category term="Python" scheme="http://AlbertGithubHome.github.io/blog/tags/Python/"/>
    
      <category term="time" scheme="http://AlbertGithubHome.github.io/blog/tags/time/"/>
    
      <category term="datetime" scheme="http://AlbertGithubHome.github.io/blog/tags/datetime/"/>
    
      <category term="转化" scheme="http://AlbertGithubHome.github.io/blog/tags/%E8%BD%AC%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>GDB调试指北-启动调试或者附加到进程</title>
    <link href="http://AlbertGithubHome.github.io/blog/2020/08/17/GDB%E8%B0%83%E8%AF%95%E6%8C%87%E5%8C%97-%E5%90%AF%E5%8A%A8%E8%B0%83%E8%AF%95%E6%88%96%E8%80%85%E9%99%84%E5%8A%A0%E5%88%B0%E8%BF%9B%E7%A8%8B/"/>
    <id>http://AlbertGithubHome.github.io/blog/2020/08/17/GDB调试指北-启动调试或者附加到进程/</id>
    <published>2020-08-17T15:45:15.000Z</published>
    <updated>2020-09-02T16:23:47.618Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>要想使用 <code>gdb</code> 调试程序，必须让 <code>gdb</code> 程序和被调试程序建立联系，这种联系可以通过程序的可执行文件、core文件或者正在运行的进程来建立，具体调试的时候使用的选项不同，涉及到参数的传递，选项的顺序，多进程启动前的设置等等，接下来可以看一些常见用法。</p><a id="more"></a><h1 id="测试样例"><a href="#测试样例" class="headerlink" title="测试样例"></a>测试样例</h1><p>首先来写一段简单的但是会自动崩溃的代码，主要是为了展示core文件的调试方法，通过调试崩溃产生的core文件是一种很直接的查找问题的方法，可以帮助我们快速定位到问题的栈帧，进而找到具体的逻辑代码。</p><h2 id="代码内容"><a href="#代码内容" class="headerlink" title="代码内容"></a>代码内容</h2><p>新建文件 examplepro.cpp，编写代码内容如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc &gt; <span class="number">1</span>)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"argv[1] = "</span> &lt;&lt; argv[<span class="number">1</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">3</span>, b = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">int</span> c = a + b;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"c = "</span> &lt;&lt; c &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> *p = <span class="literal">NULL</span>;</span><br><span class="line">    *p = c;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="代码编译"><a href="#代码编译" class="headerlink" title="代码编译"></a>代码编译</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ examplepro.cpp -o examplepro -g</span><br></pre></td></tr></table></figure><h2 id="运行程序"><a href="#运行程序" class="headerlink" title="运行程序"></a>运行程序</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:~/WorkSpace/cpp$ ./examplepro</span><br><span class="line">c = 7</span><br><span class="line">Segmentation fault (core dumped)</span><br></pre></td></tr></table></figure><p>我们发现程序在运行之后发生了段错误，这是一种比较常见的BUG，通常由访问无效内存导致，查看程序目录下内容，多了一个叫 <code>core</code> 的文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:~/WorkSpace/cpp$ ls</span><br><span class="line">core  examplepro  examplepro.cpp</span><br></pre></td></tr></table></figure><p>通过这一步你可能看不到这个 <code>core</code> 文件，需要检查两点，第一是编译的时候需要加 <code>-g</code> 选项，第二是使用 <code>ulimit -c unlimited</code> 命令设置core文件占用空间的最小限制，默认大小为0，也就是不产生 <code>core</code> 文件，需要改为 <code>unlimited</code> 才可以，如果你确定产生的 <code>core</code> 文件不会太大，也可以设置一个具体的数值。</p><h1 id="使用gdb调试"><a href="#使用gdb调试" class="headerlink" title="使用gdb调试"></a>使用gdb调试</h1><p>有了上面的程序我们就可以进行调试了，因为已经产生了 core 文件，所以先来调试一下 core 文件，看下程序崩溃的原因。</p><h2 id="使用gdb调试core文件"><a href="#使用gdb调试core文件" class="headerlink" title="使用gdb调试core文件"></a>使用gdb调试core文件</h2><p>启动程序的语法如下，<code>gdb</code> 命令之后跟程序名，然后后面跟着 core 文件的名字：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gdb examplepro core</span><br></pre></td></tr></table></figure><p>具体调试的时候需要换成自己的崩溃的程序名，而core文件大多数是 <code>core.进程id</code> 的形式。</p><h3 id="调试过程"><a href="#调试过程" class="headerlink" title="调试过程"></a>调试过程</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:~/WorkSpace/cpp$ gdb examplepro core</span><br><span class="line">GNU gdb (Ubuntu 7.11.1-0ubuntu1~16.5) 7.11.1</span><br><span class="line">Copyright (C) 2016 Free Software Foundation, Inc.</span><br><span class="line">License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;</span><br><span class="line">This is free software: you are free to change and redistribute it.</span><br><span class="line">There is NO WARRANTY, to the extent permitted by law.  Type <span class="string">"show copying"</span></span><br><span class="line">and <span class="string">"show warranty"</span> <span class="keyword">for</span> details.</span><br><span class="line">This GDB was configured as <span class="string">"x86_64-linux-gnu"</span>.</span><br><span class="line">Type <span class="string">"show configuration"</span> <span class="keyword">for</span> configuration details.</span><br><span class="line">For bug reporting instructions, please see:</span><br><span class="line">&lt;http://www.gnu.org/software/gdb/bugs/&gt;.</span><br><span class="line">Find the GDB manual and other documentation resources online at:</span><br><span class="line">&lt;http://www.gnu.org/software/gdb/documentation/&gt;.</span><br><span class="line">For <span class="built_in">help</span>, <span class="built_in">type</span> <span class="string">"help"</span>.</span><br><span class="line">Type <span class="string">"apropos word"</span> to search <span class="keyword">for</span> commands related to <span class="string">"word"</span>...</span><br><span class="line">Reading symbols from examplepro...done.</span><br><span class="line">[New LWP 19786]</span><br><span class="line">Core was generated by `./examplepro<span class="string">'.</span></span><br><span class="line"><span class="string">Program terminated with signal SIGSEGV, Segmentation fault.</span></span><br><span class="line"><span class="string">#0  0x0000000000400932 in main (argc=1, argv=0x7ffd23cc3a18) at examplepro.cpp:15</span></span><br><span class="line"><span class="string">15      *p = c;</span></span><br><span class="line"><span class="string">(gdb)</span></span><br></pre></td></tr></table></figure><p>从调试信息来看一下就定位到了问题，在代码的第15行发生了段错误，也就是我们刚刚给野指针赋值的代码。</p><h2 id="使用gdb直接启动程序"><a href="#使用gdb直接启动程序" class="headerlink" title="使用gdb直接启动程序"></a>使用gdb直接启动程序</h2><p>这种情况就是调试运行，相当于在 <code>gdb</code> 的监控下启动程序，一旦发生错误，<code>gdb</code> 会给出响应的提示，启动方式很简单，<code>gdb</code> 命令之后直接跟着程序名字就可以了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gdb examplepro</span><br></pre></td></tr></table></figure><h3 id="调试过程-1"><a href="#调试过程-1" class="headerlink" title="调试过程"></a>调试过程</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:~/WorkSpace/cpp$ gdb examplepro</span><br><span class="line">GNU gdb (Ubuntu 7.11.1-0ubuntu1~16.5) 7.11.1</span><br><span class="line">Copyright (C) 2016 Free Software Foundation, Inc.</span><br><span class="line">License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;</span><br><span class="line">This is free software: you are free to change and redistribute it.</span><br><span class="line">There is NO WARRANTY, to the extent permitted by law.  Type <span class="string">"show copying"</span></span><br><span class="line">and <span class="string">"show warranty"</span> <span class="keyword">for</span> details.</span><br><span class="line">This GDB was configured as <span class="string">"x86_64-linux-gnu"</span>.</span><br><span class="line">Type <span class="string">"show configuration"</span> <span class="keyword">for</span> configuration details.</span><br><span class="line">For bug reporting instructions, please see:</span><br><span class="line">&lt;http://www.gnu.org/software/gdb/bugs/&gt;.</span><br><span class="line">Find the GDB manual and other documentation resources online at:</span><br><span class="line">&lt;http://www.gnu.org/software/gdb/documentation/&gt;.</span><br><span class="line">For <span class="built_in">help</span>, <span class="built_in">type</span> <span class="string">"help"</span>.</span><br><span class="line">Type <span class="string">"apropos word"</span> to search <span class="keyword">for</span> commands related to <span class="string">"word"</span>...</span><br><span class="line">Reading symbols from examplepro...done.</span><br><span class="line">(gdb) run</span><br><span class="line">Starting program: /home/albert/WorkSpace/cpp/examplepro</span><br><span class="line">c = 7</span><br><span class="line"></span><br><span class="line">Program received signal SIGSEGV, Segmentation fault.</span><br><span class="line">0x0000000000400932 <span class="keyword">in</span> main (argc=1, argv=0x7fffffffdd18) at examplepro.cpp:15</span><br><span class="line">15      *p = c;</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure><p>这种情况下，启动之后需要输入 <code>run</code> 命令才可以运行程序，这时发现程序又崩溃了。</p><p>如果被调试的程序有参数的话，需要将启动的命令进行修改，写成 <code>gdb --args examplepro testparam1</code>，加上 <code>--args</code> 选项，然后将参数罗列在后面就好了，因为看这些声明很麻烦，我们利用之前学过的 <code>-q</code> 选项来屏蔽启动说明，测试如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:~/WorkSpace/cpp$ gdb -q --args examplepro NB</span><br><span class="line">Reading symbols from examplepro...done.</span><br><span class="line">(gdb) run</span><br><span class="line">Starting program: /home/albert/WorkSpace/cpp/examplepro NB</span><br><span class="line">argv[1] = NB</span><br><span class="line">c = 7</span><br><span class="line"></span><br><span class="line">Program received signal SIGSEGV, Segmentation fault.</span><br><span class="line">0x0000000000400932 <span class="keyword">in</span> main (argc=2, argv=0x7fffffffdd08) at examplepro.cpp:15</span><br><span class="line">15      *p = c;</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure><p>还有一种写法就是启动 gdb 之后再传参数，具体操作方法如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:~/WorkSpace/cpp$ gdb -q examplepro</span><br><span class="line">Reading symbols from examplepro...done.</span><br><span class="line">(gdb) run NB</span><br><span class="line">Starting program: /home/albert/WorkSpace/cpp/examplepro NB</span><br><span class="line">argv[1] = NB</span><br><span class="line">c = 7</span><br><span class="line"></span><br><span class="line">Program received signal SIGSEGV, Segmentation fault.</span><br><span class="line">0x0000000000400932 <span class="keyword">in</span> main (argc=2, argv=0x7fffffffdd08) at examplepro.cpp:15</span><br><span class="line">15      *p = c;</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure><p>这种情况是先启动 gdb，然后在执行 <code>run</code> 命令的时候传递参数。</p><h2 id="使用gdb调试正在运行的文件"><a href="#使用gdb调试正在运行的文件" class="headerlink" title="使用gdb调试正在运行的文件"></a>使用gdb调试正在运行的文件</h2><p>这时需要获得被套是程序的进程id，可以使用 <code>ps</code>、<code>top</code> 或者 <code>pidof</code> 命令来获取进程id，然后通过 <code>attch</code> 的方式附加到进程。</p><p>比如查到需要调试的 examplepro 程序进程号是 3598，那么可以直接启动 <code>gdb</code> 附加到这个进程：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gdb examplepro 3598</span><br></pre></td></tr></table></figure><p>也可以先启动 <code>gdb</code>，然后使用 <code>attach</code> 命令附加到进程：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:~/WorkSpace/cpp$ gdb -q examplepro</span><br><span class="line">Reading symbols from examplepro...done.</span><br><span class="line">(gdb) attach 3598</span><br></pre></td></tr></table></figure><p>如果此时提示进程拒绝被附加通常是权限问题，可以使用所属账号调试，或者可以尝试 <code>sudo</code> 命令。</p><h1 id="语法对比"><a href="#语法对比" class="headerlink" title="语法对比"></a>语法对比</h1><p>常见的调试方式就文中提到的这几种，特整理成表格方便对比和查找：</p><table><thead><tr><th>语法</th><th>解释</th></tr></thead><tbody><tr><td><code>gdb examlepro</code></td><td>直接 gdb 调试启动</td></tr><tr><td><code>gdb examlepro core.3598</code></td><td>调试崩溃的 core 文件</td></tr><tr><td><code>gdb examlepro 3598</code><br><code>gdb -p 3598</code></td><td>附加到正在运行的程序进程上</td></tr><tr><td><code>gdb</code><br> <code>attach 3598</code></td><td>先启动gdb，后附加到程序上</td></tr></tbody></table><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>gdb 不但可以调试 core 文件，还可以调试正在运行的程序，这对于难重现的 bug 来说非常有帮助</li><li>在调试正在运行的程序时可以使用 <code>pidof</code> 命令来直接获取被调试程序的进程号</li><li>gdb 调试附加的进程的时候要注意权限问题，如果不成功可以尝试 sudo 命令</li></ul><hr><h2 id="gt-gt-反爬链接，请勿点击，原地爆炸，概不负责！-lt-lt"><a href="#gt-gt-反爬链接，请勿点击，原地爆炸，概不负责！-lt-lt" class="headerlink" title=" ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== "></a><center><a href="https://blog.csdn.net/albertsh/article/details/108030540" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center></h2><blockquote><p>兜兜转转又换了一个住所，匆匆忙忙如蝼蚁般迁徙，路程短了，可选的路却少了。回头看看，一个窝、一段事、一群人而已~</p><p>2020-8-25 00:24:01</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;要想使用 &lt;code&gt;gdb&lt;/code&gt; 调试程序，必须让 &lt;code&gt;gdb&lt;/code&gt; 程序和被调试程序建立联系，这种联系可以通过程序的可执行文件、core文件或者正在运行的进程来建立，具体调试的时候使用的选项不同，涉及到参数的传递，选项的顺序，多进程启动前的设置等等，接下来可以看一些常见用法。&lt;/p&gt;
    
    </summary>
    
      <category term="GDB" scheme="http://AlbertGithubHome.github.io/blog/categories/GDB/"/>
    
    
      <category term="GDB" scheme="http://AlbertGithubHome.github.io/blog/tags/GDB/"/>
    
      <category term="manual" scheme="http://AlbertGithubHome.github.io/blog/tags/manual/"/>
    
      <category term="调试" scheme="http://AlbertGithubHome.github.io/blog/tags/%E8%B0%83%E8%AF%95/"/>
    
      <category term="启动" scheme="http://AlbertGithubHome.github.io/blog/tags/%E5%90%AF%E5%8A%A8/"/>
    
  </entry>
  
  <entry>
    <title>Redis源码-BFS方式浏览main函数</title>
    <link href="http://AlbertGithubHome.github.io/blog/2020/08/05/Redis%E6%BA%90%E7%A0%81-BFS%E6%96%B9%E5%BC%8F%E6%B5%8F%E8%A7%88main%E5%87%BD%E6%95%B0/"/>
    <id>http://AlbertGithubHome.github.io/blog/2020/08/05/Redis源码-BFS方式浏览main函数/</id>
    <published>2020-08-05T15:35:19.000Z</published>
    <updated>2020-08-15T16:06:34.730Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>欠下的技术债慢慢还，继续为去年吹过的牛而努力。去年年末的时候意识到自己掌握的知识还不够深入，决定开始看一些开源项目的源码，因为当时 <code>Redis</code> 的兴起，所以瞄准了准备从它下手，之后确实看了一部分内容，比如跳表、网络事件库等等，后来过年就鸽了。今年开始一直熟悉新的业务，比较懒没跟进，最近间歇性踌躇满志又发作了，准备抽时间再捋顺一遍，老规矩，还是从 <code>main()</code> 函数下手。</p><a id="more"></a><p>对于 <code>C/C++</code> 程序一定是从 <code>main()</code> 函数开头的，这是我们切入的一个点，至于怎么找到 <code>main</code> 函数，每个人有不同的方法，最暴力的方法当然就是全文搜索了，不过较为成熟的项目一般搜索出来都不止一个 <code>main</code> 函数，因为整个项目完整构建下来不止一个程序。</p><p>像 <code>redis</code> 这个项目最起码有服务器和客户端两个程序，源码中至少包含了两个 <code>main</code> 函数，再加上一些测试程序，<code>main</code> 函数在源码中会有很多。再比如 <code>Lua</code> 的源代码中包含和解释器和编译器，如果直接搜索至少会找到两个 <code>main</code> 函数。</p><p><code>redis</code> 服务器程序的 <code>main</code> 函数在文件 <code>src/server.c</code> 中，之前好像是在 <code>redis.c</code> 文件中后来改名了，这都不重要，反正你需要从搜索出来的 <code>main</code> 函数中找到一个开始的地方，这个花不了多少时间。</p><h1 id="看代码的方式"><a href="#看代码的方式" class="headerlink" title="看代码的方式"></a>看代码的方式</h1><p>标题中提到了 <code>BFS</code> 方式看代码，而 <code>BFS</code> 指的是广度优先搜索，与之相对应的是 <code>DFS</code> 深度优先搜索，对于不含异步调用的单线程程序来说，执行代码是以深度优先搜索的方式，遇到一个函数就调用进去，在函数中又遇到另一个函数再调用进去，当函数执行完成返回到上一层。</p><p>为什么选择 <code>BFS</code> 方式看代码呢？因为这样可以在短时间内更全面的了解代码结构，我们先看第一层，当第一层浏览完成之后再进入到第二层，比如我们先看 <code>main</code> 函数，即使 <code>main</code> 函数调用了很多不认识的函数也不要去管，从名字大概判断一些作用就可以了，不用纠结具体的实现内容，当 <code>main</code> 函数全部看完了再进入到第二层去了解它调用的那些函数。</p><p>总之使用 <code>BFS</code> 方式看代码就要有一种“不懂装懂”的态度，不然容易陷入细节，无法整体把握。</p><h1 id="Redis-服务器的-main-函数"><a href="#Redis-服务器的-main-函数" class="headerlink" title="Redis 服务器的 main 函数"></a>Redis 服务器的 main 函数</h1><p><code>redis</code> 服务器的 <code>main</code> 函数代码量不是很大，总共 200 行左右，我选择了 <code>6.0.6</code> 这个版本 <code>7bf665f125a4771db095c83a7ad6ed46692cd314</code>，因为只是学习源码，没有特殊情况就不更新版本了，保证环境的统一，我先把代码贴一份在这，后面再来慢慢看。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>;</span></span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> REDIS_TEST</span></span><br><span class="line">    <span class="keyword">if</span> (argc == <span class="number">3</span> &amp;&amp; !strcasecmp(argv[<span class="number">1</span>], <span class="string">"test"</span>)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!strcasecmp(argv[<span class="number">2</span>], <span class="string">"ziplist"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> ziplistTest(argc, argv);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(argv[<span class="number">2</span>], <span class="string">"quicklist"</span>)) &#123;</span><br><span class="line">            quicklistTest(argc, argv);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(argv[<span class="number">2</span>], <span class="string">"intset"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> intsetTest(argc, argv);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(argv[<span class="number">2</span>], <span class="string">"zipmap"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> zipmapTest(argc, argv);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(argv[<span class="number">2</span>], <span class="string">"sha1test"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> sha1Test(argc, argv);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(argv[<span class="number">2</span>], <span class="string">"util"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> utilTest(argc, argv);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(argv[<span class="number">2</span>], <span class="string">"endianconv"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> endianconvTest(argc, argv);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(argv[<span class="number">2</span>], <span class="string">"crc64"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> crc64Test(argc, argv);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(argv[<span class="number">2</span>], <span class="string">"zmalloc"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> zmalloc_test(argc, argv);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">/* test not found */</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* We need to initialize our libraries, and the server configuration. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> INIT_SETPROCTITLE_REPLACEMENT</span></span><br><span class="line">    spt_init(argc, argv);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    setlocale(LC_COLLATE,<span class="string">""</span>);</span><br><span class="line">    tzset(); <span class="comment">/* Populates 'timezone' global. */</span></span><br><span class="line">    zmalloc_set_oom_handler(redisOutOfMemoryHandler);</span><br><span class="line">    srand(time(<span class="literal">NULL</span>)^getpid());</span><br><span class="line">    gettimeofday(&amp;tv,<span class="literal">NULL</span>);</span><br><span class="line">    crc64_init();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint8_t</span> hashseed[<span class="number">16</span>];</span><br><span class="line">    getRandomBytes(hashseed,<span class="keyword">sizeof</span>(hashseed));</span><br><span class="line">    dictSetHashFunctionSeed(hashseed);</span><br><span class="line">    server.sentinel_mode = checkForSentinelMode(argc,argv);</span><br><span class="line">    initServerConfig();</span><br><span class="line">    ACLInit(); <span class="comment">/* The ACL subsystem must be initialized ASAP because the</span></span><br><span class="line"><span class="comment">                  basic networking code and client creation depends on it. */</span></span><br><span class="line">    moduleInitModulesSystem();</span><br><span class="line">    tlsInit();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Store the executable path and arguments in a safe place in order</span></span><br><span class="line"><span class="comment">     * to be able to restart the server later. */</span></span><br><span class="line">    server.executable = getAbsolutePath(argv[<span class="number">0</span>]);</span><br><span class="line">    server.exec_argv = zmalloc(<span class="keyword">sizeof</span>(<span class="keyword">char</span>*)*(argc+<span class="number">1</span>));</span><br><span class="line">    server.exec_argv[argc] = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; argc; j++) server.exec_argv[j] = zstrdup(argv[j]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* We need to init sentinel right now as parsing the configuration file</span></span><br><span class="line"><span class="comment">     * in sentinel mode will have the effect of populating the sentinel</span></span><br><span class="line"><span class="comment">     * data structures with master nodes to monitor. */</span></span><br><span class="line">    <span class="keyword">if</span> (server.sentinel_mode) &#123;</span><br><span class="line">        initSentinelConfig();</span><br><span class="line">        initSentinel();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check if we need to start in redis-check-rdb/aof mode. We just execute</span></span><br><span class="line"><span class="comment">     * the program main. However the program is part of the Redis executable</span></span><br><span class="line"><span class="comment">     * so that we can easily execute an RDB check on loading errors. */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strstr</span>(argv[<span class="number">0</span>],<span class="string">"redis-check-rdb"</span>) != <span class="literal">NULL</span>)</span><br><span class="line">        redis_check_rdb_main(argc,argv,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strstr</span>(argv[<span class="number">0</span>],<span class="string">"redis-check-aof"</span>) != <span class="literal">NULL</span>)</span><br><span class="line">        redis_check_aof_main(argc,argv);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">        j = <span class="number">1</span>; <span class="comment">/* First option to parse in argv[] */</span></span><br><span class="line">        sds options = sdsempty();</span><br><span class="line">        <span class="keyword">char</span> *configfile = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Handle special options --help and --version */</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">"-v"</span>) == <span class="number">0</span> ||</span><br><span class="line">            <span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">"--version"</span>) == <span class="number">0</span>) version();</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">"--help"</span>) == <span class="number">0</span> ||</span><br><span class="line">            <span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">"-h"</span>) == <span class="number">0</span>) usage();</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">"--test-memory"</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (argc == <span class="number">3</span>) &#123;</span><br><span class="line">                memtest(atoi(argv[<span class="number">2</span>]),<span class="number">50</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"Please specify the amount of memory to test in megabytes.\n"</span>);</span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"Example: ./redis-server --test-memory 4096\n\n"</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* First argument is the config file name? */</span></span><br><span class="line">        <span class="keyword">if</span> (argv[j][<span class="number">0</span>] != <span class="string">'-'</span> || argv[j][<span class="number">1</span>] != <span class="string">'-'</span>) &#123;</span><br><span class="line">            configfile = argv[j];</span><br><span class="line">            server.configfile = getAbsolutePath(configfile);</span><br><span class="line">            <span class="comment">/* Replace the config file in server.exec_argv with</span></span><br><span class="line"><span class="comment">             * its absolute path. */</span></span><br><span class="line">            zfree(server.exec_argv[j]);</span><br><span class="line">            server.exec_argv[j] = zstrdup(server.configfile);</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* All the other options are parsed and conceptually appended to the</span></span><br><span class="line"><span class="comment">         * configuration file. For instance --port 6380 will generate the</span></span><br><span class="line"><span class="comment">         * string "port 6380\n" to be parsed after the actual file name</span></span><br><span class="line"><span class="comment">         * is parsed, if any. */</span></span><br><span class="line">        <span class="keyword">while</span>(j != argc) &#123;</span><br><span class="line">            <span class="keyword">if</span> (argv[j][<span class="number">0</span>] == <span class="string">'-'</span> &amp;&amp; argv[j][<span class="number">1</span>] == <span class="string">'-'</span>) &#123;</span><br><span class="line">                <span class="comment">/* Option name */</span></span><br><span class="line">                <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[j], <span class="string">"--check-rdb"</span>)) &#123;</span><br><span class="line">                    <span class="comment">/* Argument has no options, need to skip for parsing. */</span></span><br><span class="line">                    j++;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (sdslen(options)) options = sdscat(options,<span class="string">"\n"</span>);</span><br><span class="line">                options = sdscat(options,argv[j]+<span class="number">2</span>);</span><br><span class="line">                options = sdscat(options,<span class="string">" "</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">/* Option argument */</span></span><br><span class="line">                options = sdscatrepr(options,argv[j],<span class="built_in">strlen</span>(argv[j]));</span><br><span class="line">                options = sdscat(options,<span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (server.sentinel_mode &amp;&amp; configfile &amp;&amp; *configfile == <span class="string">'-'</span>) &#123;</span><br><span class="line">            serverLog(LL_WARNING,</span><br><span class="line">                <span class="string">"Sentinel config from STDIN not allowed."</span>);</span><br><span class="line">            serverLog(LL_WARNING,</span><br><span class="line">                <span class="string">"Sentinel needs config file on disk to save state.  Exiting..."</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        resetServerSaveParams();</span><br><span class="line">        loadServerConfig(configfile,options);</span><br><span class="line">        sdsfree(options);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    serverLog(LL_WARNING, <span class="string">"oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo"</span>);</span><br><span class="line">    serverLog(LL_WARNING,</span><br><span class="line">        <span class="string">"Redis version=%s, bits=%d, commit=%s, modified=%d, pid=%d, just started"</span>,</span><br><span class="line">            REDIS_VERSION,</span><br><span class="line">            (<span class="keyword">sizeof</span>(<span class="keyword">long</span>) == <span class="number">8</span>) ? <span class="number">64</span> : <span class="number">32</span>,</span><br><span class="line">            redisGitSHA1(),</span><br><span class="line">            strtol(redisGitDirty(),<span class="literal">NULL</span>,<span class="number">10</span>) &gt; <span class="number">0</span>,</span><br><span class="line">            (<span class="keyword">int</span>)getpid());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc == <span class="number">1</span>) &#123;</span><br><span class="line">        serverLog(LL_WARNING, <span class="string">"Warning: no config file specified, using the default config. In order to specify a config file use %s /path/to/%s.conf"</span>, argv[<span class="number">0</span>], server.sentinel_mode ? <span class="string">"sentinel"</span> : <span class="string">"redis"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        serverLog(LL_WARNING, <span class="string">"Configuration loaded"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    server.supervised = redisIsSupervised(server.supervised_mode);</span><br><span class="line">    <span class="keyword">int</span> background = server.daemonize &amp;&amp; !server.supervised;</span><br><span class="line">    <span class="keyword">if</span> (background) daemonize();</span><br><span class="line"></span><br><span class="line">    initServer();</span><br><span class="line">    <span class="keyword">if</span> (background || server.pidfile) createPidFile();</span><br><span class="line">    redisSetProcTitle(argv[<span class="number">0</span>]);</span><br><span class="line">    redisAsciiArt();</span><br><span class="line">    checkTcpBacklogSettings();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!server.sentinel_mode) &#123;</span><br><span class="line">        <span class="comment">/* Things not needed when running in Sentinel mode. */</span></span><br><span class="line">        serverLog(LL_WARNING,<span class="string">"Server initialized"</span>);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> __linux__</span></span><br><span class="line">        linuxMemoryWarnings();</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        moduleLoadFromQueue();</span><br><span class="line">        ACLLoadUsersAtStartup();</span><br><span class="line">        InitServerLast();</span><br><span class="line">        loadDataFromDisk();</span><br><span class="line">        <span class="keyword">if</span> (server.cluster_enabled) &#123;</span><br><span class="line">            <span class="keyword">if</span> (verifyClusterConfigWithData() == C_ERR) &#123;</span><br><span class="line">                serverLog(LL_WARNING,</span><br><span class="line">                    <span class="string">"You can't have keys in a DB different than DB 0 when in "</span></span><br><span class="line">                    <span class="string">"Cluster mode. Exiting."</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (server.ipfd_count &gt; <span class="number">0</span> || server.tlsfd_count &gt; <span class="number">0</span>)</span><br><span class="line">            serverLog(LL_NOTICE,<span class="string">"Ready to accept connections"</span>);</span><br><span class="line">        <span class="keyword">if</span> (server.sofd &gt; <span class="number">0</span>)</span><br><span class="line">            serverLog(LL_NOTICE,<span class="string">"The server is now ready to accept connections at %s"</span>, server.unixsocket);</span><br><span class="line">        <span class="keyword">if</span> (server.supervised_mode == SUPERVISED_SYSTEMD) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!server.masterhost) &#123;</span><br><span class="line">                redisCommunicateSystemd(<span class="string">"STATUS=Ready to accept connections\n"</span>);</span><br><span class="line">                redisCommunicateSystemd(<span class="string">"READY=1\n"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                redisCommunicateSystemd(<span class="string">"STATUS=Waiting for MASTER &lt;-&gt; REPLICA sync\n"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        InitServerLast();</span><br><span class="line">        sentinelIsRunning();</span><br><span class="line">        <span class="keyword">if</span> (server.supervised_mode == SUPERVISED_SYSTEMD) &#123;</span><br><span class="line">            redisCommunicateSystemd(<span class="string">"STATUS=Ready to accept connections\n"</span>);</span><br><span class="line">            redisCommunicateSystemd(<span class="string">"READY=1\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Warning the user about suspicious maxmemory setting. */</span></span><br><span class="line">    <span class="keyword">if</span> (server.maxmemory &gt; <span class="number">0</span> &amp;&amp; server.maxmemory &lt; <span class="number">1024</span>*<span class="number">1024</span>) &#123;</span><br><span class="line">        serverLog(LL_WARNING,<span class="string">"WARNING: You specified a maxmemory value that is less than 1MB (current value is %llu bytes). Are you sure this is what you really want?"</span>, server.maxmemory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    redisSetCpuAffinity(server.server_cpulist);</span><br><span class="line">    aeMain(server.el);</span><br><span class="line">    aeDeleteEventLoop(server.el);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="main-函数分段解释"><a href="#main-函数分段解释" class="headerlink" title="main 函数分段解释"></a>main 函数分段解释</h1><h2 id="函数名及参数"><a href="#函数名及参数" class="headerlink" title="函数名及参数"></a>函数名及参数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>;</span></span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就是一个标准的 <code>main</code> 函数，参数 <code>argc</code> 和 <code>argv</code> 对于一个命令行程序来说可以是重头戏，肯定会拿来做重度解析的，函数开头还定义了 <code>tv</code> 和 <code>j</code> 两个变量，不知道干嘛的，接着往下看吧。</p><h2 id="启动测试程序"><a href="#启动测试程序" class="headerlink" title="启动测试程序"></a>启动测试程序</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> REDIS_TEST</span></span><br><span class="line">    <span class="keyword">if</span> (argc == <span class="number">3</span> &amp;&amp; !strcasecmp(argv[<span class="number">1</span>], <span class="string">"test"</span>)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!strcasecmp(argv[<span class="number">2</span>], <span class="string">"ziplist"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> ziplistTest(argc, argv);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(argv[<span class="number">2</span>], <span class="string">"quicklist"</span>)) &#123;</span><br><span class="line">            quicklistTest(argc, argv);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(argv[<span class="number">2</span>], <span class="string">"intset"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> intsetTest(argc, argv);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(argv[<span class="number">2</span>], <span class="string">"zipmap"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> zipmapTest(argc, argv);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(argv[<span class="number">2</span>], <span class="string">"sha1test"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> sha1Test(argc, argv);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(argv[<span class="number">2</span>], <span class="string">"util"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> utilTest(argc, argv);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(argv[<span class="number">2</span>], <span class="string">"endianconv"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> endianconvTest(argc, argv);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(argv[<span class="number">2</span>], <span class="string">"crc64"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> crc64Test(argc, argv);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(argv[<span class="number">2</span>], <span class="string">"zmalloc"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> zmalloc_test(argc, argv);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">/* test not found */</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>当宏定义 <code>REDIS_TEST</code> 存在，并且参数合适的情况下启动测试程序，<code>argv[0]</code> 肯定是指 <code>redis</code> 服务器喽，那 <code>argv[1]</code> 的值如果是 <code>test</code>，而 <code>argv[2]</code> 的值是 <code>ziplist</code>，那么会调用 <code>ziplist</code> 的测试函数 <code>ziplistTest</code>，如果 <code>argv[2]</code> 的值是 <code>zmalloc</code>，那么会调用测试函数 <code>zmalloc_test</code>，为啥这里函数名命名规范不统一呢？挠头。</p><h2 id="程序环境初始化"><a href="#程序环境初始化" class="headerlink" title="程序环境初始化"></a>程序环境初始化</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/* We need to initialize our libraries, and the server configuration. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> INIT_SETPROCTITLE_REPLACEMENT</span></span><br><span class="line">    spt_init(argc, argv);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    setlocale(LC_COLLATE,<span class="string">""</span>);</span><br><span class="line">    tzset(); <span class="comment">/* Populates 'timezone' global. */</span></span><br><span class="line">    zmalloc_set_oom_handler(redisOutOfMemoryHandler);</span><br><span class="line">    srand(time(<span class="literal">NULL</span>)^getpid());</span><br><span class="line">    gettimeofday(&amp;tv,<span class="literal">NULL</span>);</span><br><span class="line">    crc64_init();</span><br></pre></td></tr></table></figure><ol><li>当 <code>INIT_SETPROCTITLE_REPLACEMENT</code> 这个宏存在的时候，调用 <code>spt_init</code> 函数来为设置程序标题做准备</li><li><code>setlocale()</code> 用来设置地点信息，这一句应该是设置成依赖操作系统的地点信息，比如中国，韩国等等</li><li><code>tzset()</code> 设置时区，这里可能影响到程序运行后，调整时区是否对程序产生影响</li><li><code>srand(time(NULL)^getpid());</code> 初始化随机种子</li><li><code>gettimeofday(&amp;tv,NULL);</code> 这里用到了函数开头定义的一个变量 <code>tv</code>，用来获取当前时间</li><li><code>crc64_init();</code> 循环冗余校验初始化，<code>crc</code> 神奇的存在</li></ol><h2 id="初始化配置信息"><a href="#初始化配置信息" class="headerlink" title="初始化配置信息"></a>初始化配置信息</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uint8_t</span> hashseed[<span class="number">16</span>];</span><br><span class="line">getRandomBytes(hashseed,<span class="keyword">sizeof</span>(hashseed));</span><br><span class="line">dictSetHashFunctionSeed(hashseed);</span><br><span class="line">server.sentinel_mode = checkForSentinelMode(argc,argv);</span><br><span class="line">initServerConfig();</span><br><span class="line">ACLInit(); <span class="comment">/* The ACL subsystem must be initialized ASAP because the</span></span><br><span class="line"><span class="comment">              basic networking code and client creation depends on it. */</span></span><br><span class="line">moduleInitModulesSystem();</span><br><span class="line">tlsInit();</span><br></pre></td></tr></table></figure><ol><li>定一个16字节的空间用来存放哈希种子</li><li>随机获取一段16字节数据作为种子</li><li>将刚刚获取的种子数据设置到hash函数中</li><li>分析命令行参数，判断是否是哨兵模式</li><li>初始化服务器配置</li><li><code>ACL</code> 初始化，不用管它具体是什么，进入下一层时自然会看到</li><li>初始化模块系统</li><li><code>tls</code> 初始化，存疑，好奇的话进去看看也可以，好吧，原来是 <code>ssl</code> 那一套，够喝一壶的</li></ol><h2 id="存储参数信息"><a href="#存储参数信息" class="headerlink" title="存储参数信息"></a>存储参数信息</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Store the executable path and arguments in a safe place in order</span></span><br><span class="line"><span class="comment"> * to be able to restart the server later. */</span></span><br><span class="line">server.executable = getAbsolutePath(argv[<span class="number">0</span>]);</span><br><span class="line">server.exec_argv = zmalloc(<span class="keyword">sizeof</span>(<span class="keyword">char</span>*)*(argc+<span class="number">1</span>));</span><br><span class="line">server.exec_argv[argc] = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; argc; j++) server.exec_argv[j] = zstrdup(argv[j]);</span><br></pre></td></tr></table></figure><p>这一小节比较简单，注释写的也很清楚，就是将命令行参数存储起来，方便重启 <code>redis</code> 服务</p><h2 id="根据参数确定启动方式"><a href="#根据参数确定启动方式" class="headerlink" title="根据参数确定启动方式"></a>根据参数确定启动方式</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* We need to init sentinel right now as parsing the configuration file</span></span><br><span class="line"><span class="comment"> * in sentinel mode will have the effect of populating the sentinel</span></span><br><span class="line"><span class="comment"> * data structures with master nodes to monitor. */</span></span><br><span class="line"><span class="keyword">if</span> (server.sentinel_mode) &#123;</span><br><span class="line">    initSentinelConfig();</span><br><span class="line">    initSentinel();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Check if we need to start in redis-check-rdb/aof mode. We just execute</span></span><br><span class="line"><span class="comment"> * the program main. However the program is part of the Redis executable</span></span><br><span class="line"><span class="comment"> * so that we can easily execute an RDB check on loading errors. */</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strstr</span>(argv[<span class="number">0</span>],<span class="string">"redis-check-rdb"</span>) != <span class="literal">NULL</span>)</span><br><span class="line">    redis_check_rdb_main(argc,argv,<span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strstr</span>(argv[<span class="number">0</span>],<span class="string">"redis-check-aof"</span>) != <span class="literal">NULL</span>)</span><br><span class="line">    redis_check_aof_main(argc,argv);</span><br></pre></td></tr></table></figure><p>当启用哨兵模式的时候初始化额外的配置，啥是哨兵，现在还不用知道啊，从字面上来看就好了，反正知道命令行里如果指定了哨兵模式就要额外初始化一点东西。</p><p>下面这两个参数有点意思，简单扩展下，<code>rdb</code> 和 <code>aof</code> 是 <code>redis</code> 的两种数据落地的持久化方式，这里有意思的地方是判断了 <code>argv[0]</code> 这个参数，一般 <code>argv[0]</code> 是程序的名字，这个是固定不变的，而 <code>redis</code> 这里将程序名字作为参数来判断，也就是说你把可执行程序换个名字运行，它的行为就会发生变化。</p><h2 id="处理并加载命令行参数"><a href="#处理并加载命令行参数" class="headerlink" title="处理并加载命令行参数"></a>处理并加载命令行参数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (argc &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">    j = <span class="number">1</span>; <span class="comment">/* First option to parse in argv[] */</span></span><br><span class="line">    sds options = sdsempty();</span><br><span class="line">    <span class="keyword">char</span> *configfile = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Handle special options --help and --version */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">"-v"</span>) == <span class="number">0</span> ||</span><br><span class="line">        <span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">"--version"</span>) == <span class="number">0</span>) version();</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">"--help"</span>) == <span class="number">0</span> ||</span><br><span class="line">        <span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">"-h"</span>) == <span class="number">0</span>) usage();</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">"--test-memory"</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (argc == <span class="number">3</span>) &#123;</span><br><span class="line">            memtest(atoi(argv[<span class="number">2</span>]),<span class="number">50</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"Please specify the amount of memory to test in megabytes.\n"</span>);</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"Example: ./redis-server --test-memory 4096\n\n"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* First argument is the config file name? */</span></span><br><span class="line">    <span class="keyword">if</span> (argv[j][<span class="number">0</span>] != <span class="string">'-'</span> || argv[j][<span class="number">1</span>] != <span class="string">'-'</span>) &#123;</span><br><span class="line">        configfile = argv[j];</span><br><span class="line">        server.configfile = getAbsolutePath(configfile);</span><br><span class="line">        <span class="comment">/* Replace the config file in server.exec_argv with</span></span><br><span class="line"><span class="comment">         * its absolute path. */</span></span><br><span class="line">        zfree(server.exec_argv[j]);</span><br><span class="line">        server.exec_argv[j] = zstrdup(server.configfile);</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* All the other options are parsed and conceptually appended to the</span></span><br><span class="line"><span class="comment">     * configuration file. For instance --port 6380 will generate the</span></span><br><span class="line"><span class="comment">     * string "port 6380\n" to be parsed after the actual file name</span></span><br><span class="line"><span class="comment">     * is parsed, if any. */</span></span><br><span class="line">    <span class="keyword">while</span>(j != argc) &#123;</span><br><span class="line">        <span class="keyword">if</span> (argv[j][<span class="number">0</span>] == <span class="string">'-'</span> &amp;&amp; argv[j][<span class="number">1</span>] == <span class="string">'-'</span>) &#123;</span><br><span class="line">            <span class="comment">/* Option name */</span></span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[j], <span class="string">"--check-rdb"</span>)) &#123;</span><br><span class="line">                <span class="comment">/* Argument has no options, need to skip for parsing. */</span></span><br><span class="line">                j++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (sdslen(options)) options = sdscat(options,<span class="string">"\n"</span>);</span><br><span class="line">            options = sdscat(options,argv[j]+<span class="number">2</span>);</span><br><span class="line">            options = sdscat(options,<span class="string">" "</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* Option argument */</span></span><br><span class="line">            options = sdscatrepr(options,argv[j],<span class="built_in">strlen</span>(argv[j]));</span><br><span class="line">            options = sdscat(options,<span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (server.sentinel_mode &amp;&amp; configfile &amp;&amp; *configfile == <span class="string">'-'</span>) &#123;</span><br><span class="line">        serverLog(LL_WARNING,</span><br><span class="line">            <span class="string">"Sentinel config from STDIN not allowed."</span>);</span><br><span class="line">        serverLog(LL_WARNING,</span><br><span class="line">            <span class="string">"Sentinel needs config file on disk to save state.  Exiting..."</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    resetServerSaveParams();</span><br><span class="line">    loadServerConfig(configfile,options);</span><br><span class="line">    sdsfree(options);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段内容很长，但是核心的内容不多，前一部分是判断特殊参数，用来显示程序使用方法，启动内存测试等等，中间部分是分析命令行参数保存到字符串中，最后几行是读取服务器配置文件，并使用字符串中的参数选项覆盖文件中的部分配置。</p><h2 id="打印启动和警告信息"><a href="#打印启动和警告信息" class="headerlink" title="打印启动和警告信息"></a>打印启动和警告信息</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">serverLog(LL_WARNING, <span class="string">"oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo"</span>);</span><br><span class="line">serverLog(LL_WARNING,</span><br><span class="line">    <span class="string">"Redis version=%s, bits=%d, commit=%s, modified=%d, pid=%d, just started"</span>,</span><br><span class="line">        REDIS_VERSION,</span><br><span class="line">        (<span class="keyword">sizeof</span>(<span class="keyword">long</span>) == <span class="number">8</span>) ? <span class="number">64</span> : <span class="number">32</span>,</span><br><span class="line">        redisGitSHA1(),</span><br><span class="line">        strtol(redisGitDirty(),<span class="literal">NULL</span>,<span class="number">10</span>) &gt; <span class="number">0</span>,</span><br><span class="line">        (<span class="keyword">int</span>)getpid());</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (argc == <span class="number">1</span>) &#123;</span><br><span class="line">    serverLog(LL_WARNING, <span class="string">"Warning: no config file specified, using the default config. In order to specify a config file use %s /path/to/%s.conf"</span>, argv[<span class="number">0</span>], server.sentinel_mode ? <span class="string">"sentinel"</span> : <span class="string">"redis"</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    serverLog(LL_WARNING, <span class="string">"Configuration loaded"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印 <code>redis</code> 服务器启动信息，比如版本号，pid，警告信息等等，没有实际修改数据。</p><h2 id="守护模式和初始化"><a href="#守护模式和初始化" class="headerlink" title="守护模式和初始化"></a>守护模式和初始化</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">server.supervised = redisIsSupervised(server.supervised_mode);</span><br><span class="line"><span class="keyword">int</span> background = server.daemonize &amp;&amp; !server.supervised;</span><br><span class="line"><span class="keyword">if</span> (background) daemonize();</span><br><span class="line"></span><br><span class="line">initServer();</span><br><span class="line"><span class="keyword">if</span> (background || server.pidfile) createPidFile();</span><br><span class="line">redisSetProcTitle(argv[<span class="number">0</span>]);</span><br><span class="line">redisAsciiArt();</span><br><span class="line">checkTcpBacklogSettings();</span><br></pre></td></tr></table></figure><p>根据守护进程配置和是否受监督来决定是否作为守护进程，什么是受监督，到现在还不知道，但是本着不懂装懂的方式看代码，可以认为我们懂了，后面自然还会有解释的地方。</p><p>接着就调用了 <code>initServer();</code> 函数，这个初始化函数内容是比较长的，之前版本中很多 <code>mian</code> 函数中的内容都移到了这里面，初始化完成后创建 <code>Pid</code> 文件，设置进程名字，显示 <code>redis</code> 的Logo，检查一些配置，这个 <code>backlog</code> 参数之前面试的时候还被问到过，好奇的话可以提前了解一下。</p><h2 id="哨兵模式判断启动并加载持久化数据"><a href="#哨兵模式判断启动并加载持久化数据" class="headerlink" title="哨兵模式判断启动并加载持久化数据"></a>哨兵模式判断启动并加载持久化数据</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">if</span> (!server.sentinel_mode) &#123;</span><br><span class="line">    <span class="comment">/* Things not needed when running in Sentinel mode. */</span></span><br><span class="line">    serverLog(LL_WARNING,<span class="string">"Server initialized"</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __linux__</span></span><br><span class="line">    linuxMemoryWarnings();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    moduleLoadFromQueue();</span><br><span class="line">    ACLLoadUsersAtStartup();</span><br><span class="line">    InitServerLast();</span><br><span class="line">    loadDataFromDisk();</span><br><span class="line">    <span class="keyword">if</span> (server.cluster_enabled) &#123;</span><br><span class="line">        <span class="keyword">if</span> (verifyClusterConfigWithData() == C_ERR) &#123;</span><br><span class="line">            serverLog(LL_WARNING,</span><br><span class="line">                <span class="string">"You can't have keys in a DB different than DB 0 when in "</span></span><br><span class="line">                <span class="string">"Cluster mode. Exiting."</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (server.ipfd_count &gt; <span class="number">0</span> || server.tlsfd_count &gt; <span class="number">0</span>)</span><br><span class="line">        serverLog(LL_NOTICE,<span class="string">"Ready to accept connections"</span>);</span><br><span class="line">    <span class="keyword">if</span> (server.sofd &gt; <span class="number">0</span>)</span><br><span class="line">        serverLog(LL_NOTICE,<span class="string">"The server is now ready to accept connections at %s"</span>, server.unixsocket);</span><br><span class="line">    <span class="keyword">if</span> (server.supervised_mode == SUPERVISED_SYSTEMD) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!server.masterhost) &#123;</span><br><span class="line">            redisCommunicateSystemd(<span class="string">"STATUS=Ready to accept connections\n"</span>);</span><br><span class="line">            redisCommunicateSystemd(<span class="string">"READY=1\n"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            redisCommunicateSystemd(<span class="string">"STATUS=Waiting for MASTER &lt;-&gt; REPLICA sync\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    InitServerLast();</span><br><span class="line">    sentinelIsRunning();</span><br><span class="line">    <span class="keyword">if</span> (server.supervised_mode == SUPERVISED_SYSTEMD) &#123;</span><br><span class="line">        redisCommunicateSystemd(<span class="string">"STATUS=Ready to accept connections\n"</span>);</span><br><span class="line">        redisCommunicateSystemd(<span class="string">"READY=1\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码看起来像是再做一些通知提醒，其中比较重要的几个函数是<code>moduleLoadFromQueue()</code>、 <code>InitServerLast()</code> 和 <code>loadDataFromDisk()</code> ，第一个函数是加载模块的，第二个函数是在模块加载完成之后才能初始化的部分内容，最后一个是从磁盘加载数据到内存，这也是 <code>redis</code> 支持持久化的必要保证。</p><h2 id="打印内存警告并启动事件监听"><a href="#打印内存警告并启动事件监听" class="headerlink" title="打印内存警告并启动事件监听"></a>打印内存警告并启动事件监听</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Warning the user about suspicious maxmemory setting. */</span></span><br><span class="line"><span class="keyword">if</span> (server.maxmemory &gt; <span class="number">0</span> &amp;&amp; server.maxmemory &lt; <span class="number">1024</span>*<span class="number">1024</span>) &#123;</span><br><span class="line">    serverLog(LL_WARNING,<span class="string">"WARNING: You specified a maxmemory value that is less than 1MB (current value is %llu bytes). Are you sure this is what you really want?"</span>, server.maxmemory);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">redisSetCpuAffinity(server.server_cpulist);</span><br><span class="line">aeMain(server.el);</span><br><span class="line">aeDeleteEventLoop(server.el);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>看到这段代码我们就来到了 <code>main</code> 函数结尾的部分，<code>redisSetCpuAffinity()</code> 是要做些和 <code>CPU</code> 相关的设置或配置，<code>aeMain()</code> 是主逻辑，对于提供服务的程序来说里面大概率是一个死循环，再满足指定的条件下才会打断退出，而 <code>aeDeleteEventLoop()</code> 就是循环结束时清理事件的操作，到此为止 <code>main</code> 函数就执行完啦。</p><h1 id="彩蛋"><a href="#彩蛋" class="headerlink" title="彩蛋"></a>彩蛋</h1><p>这个 <code>main</code> 函数的代码中有一个神奇的用法不知道大家有没有发现，就是下面这句话：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">serverLog(LL_WARNING,</span><br><span class="line">    <span class="string">"You can't have keys in a DB different than DB 0 when in "</span></span><br><span class="line">    <span class="string">"Cluster mode. Exiting."</span>);</span><br></pre></td></tr></table></figure><p>是不是看起来有些奇怪，不用管这个函数的定义是怎样的，可以告诉大家这个函数的定义类似于 <code>printf</code> 函数，只不过在最前面加了一个整型参数，那么调用这个函数时传了几个参数呢？3个？2个？，这个地方很神奇的会把两个字符串拼接到一起，类似于下面的写法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">serverLog(LL_WARNING,</span><br><span class="line">        <span class="string">"You can't have keys in a DB different than DB 0 when in Cluster mode. Exiting."</span>);</span><br></pre></td></tr></table></figure><p>这样的字符串不仅可以分成两行，实际上可以分成任意行，最后都会拼接在一起，是不是很神奇。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li><code>j</code> 这个变量在 <code>redis</code> 的源码中经常出现，应该是作者的行为习惯吧，有些人爱用 <code>i</code>，而这个作者 <code>antirez</code> 爱用 <code>j</code>。</li><li>不能一口吃个胖子，看代码也是一样，不能期望一次性把所有的内容都看懂，一段时间后自己的代码都看不懂了，跟别说别人写的了。</li><li><code>redis</code> 代码中频繁使用 <code>server</code> 这个变量，从 <code>main</code> 函数分析中也能看到，这个是个全局变量，代表了整个 <code>redis</code> 服务器程序数据。</li><li>不懂装懂或者说不求甚解是熟悉代码整体结构的一项优秀品质，这时候只要看个大概就可以了，真到熟悉细节的时候才是需要钻研的时候。</li><li>代码风格完全统一还是比较难实现的，从一个 <code>main</code> 函数中也可以看到，大部分函数是驼峰命名法，还要少量的下划线命名和帕斯卡命名。</li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/107873029" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>你微笑的模样，提醒着我不要躲藏，坚持原来的方向，哪怕最后遍体鳞伤，困难只会让坚持的人越来越强，共勉~</p><p>2020-8-15 23:48:53</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;欠下的技术债慢慢还，继续为去年吹过的牛而努力。去年年末的时候意识到自己掌握的知识还不够深入，决定开始看一些开源项目的源码，因为当时 &lt;code&gt;Redis&lt;/code&gt; 的兴起，所以瞄准了准备从它下手，之后确实看了一部分内容，比如跳表、网络事件库等等，后来过年就鸽了。今年开始一直熟悉新的业务，比较懒没跟进，最近间歇性踌躇满志又发作了，准备抽时间再捋顺一遍，老规矩，还是从 &lt;code&gt;main()&lt;/code&gt; 函数下手。&lt;/p&gt;
    
    </summary>
    
      <category term="Redis" scheme="http://AlbertGithubHome.github.io/blog/categories/Redis/"/>
    
    
      <category term="Redis" scheme="http://AlbertGithubHome.github.io/blog/tags/Redis/"/>
    
      <category term="源码" scheme="http://AlbertGithubHome.github.io/blog/tags/%E6%BA%90%E7%A0%81/"/>
    
      <category term="C" scheme="http://AlbertGithubHome.github.io/blog/tags/C/"/>
    
      <category term="BFS" scheme="http://AlbertGithubHome.github.io/blog/tags/BFS/"/>
    
  </entry>
  
  <entry>
    <title>GDB调试指北-启动GDB并查看说明信息</title>
    <link href="http://AlbertGithubHome.github.io/blog/2020/08/01/GDB%E8%B0%83%E8%AF%95%E6%8C%87%E5%8C%97-%E5%90%AF%E5%8A%A8GDB%E5%B9%B6%E6%9F%A5%E7%9C%8B%E8%AF%B4%E6%98%8E%E4%BF%A1%E6%81%AF/"/>
    <id>http://AlbertGithubHome.github.io/blog/2020/08/01/GDB调试指北-启动GDB并查看说明信息/</id>
    <published>2020-08-01T15:08:16.000Z</published>
    <updated>2020-08-07T16:16:09.954Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>学习 <code>gdb</code> 使用是一个漫长的过程，先了解一下 <code>gdb</code> 的启动方式和基础信息的查看方法，能够帮助我们更全面的认知这个工具。<code>gdb</code> 是一个交互式命令行程序，在使用 <code>gdb</code> 调试的时候不断的在命令行内输入命令，然后 <code>gdb</code> 程序就会给出反馈信息，这在很大程序上可以帮助我们调试程序问题。</p><a id="more"></a><h1 id="gdb-版本查看"><a href="#gdb-版本查看" class="headerlink" title="gdb 版本查看"></a>gdb 版本查看</h1><p><code>gdb</code> 的安装教程网络上有很多，这里就不提供安装步骤了，可以直接通过命令行，也可以从源码安装，找个教程一步步操作就行了，安装完之后使用 <code>which</code> 命令查看一下程序安装的位置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:~$ <span class="built_in">which</span> gdb</span><br><span class="line">/usr/bin/gdb</span><br></pre></td></tr></table></figure><p>确认 <code>gdb</code> 已经安装后我们再看一下程序版本，我用的是 <code>Ubuntu 16.04</code> 版本中匹配的 <code>gdb</code> 程序，版本稍微有些低，据说 <code>9.x</code> 版本中对 <code>Python</code> 支持的非常好，调试的时候查看变量更加方便了，这些神奇的特性我们暂时还用不到，先简单了解下就好：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:~$ gdb --version</span><br><span class="line">GNU gdb (Ubuntu 7.11.1-0ubuntu1~16.5) 7.11.1</span><br><span class="line">Copyright (C) 2016 Free Software Foundation, Inc.</span><br><span class="line">License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;</span><br><span class="line">This is free software: you are free to change and redistribute it.</span><br><span class="line">There is NO WARRANTY, to the extent permitted by law.  Type <span class="string">"show copying"</span></span><br><span class="line">and <span class="string">"show warranty"</span> <span class="keyword">for</span> details.</span><br><span class="line">This GDB was configured as <span class="string">"x86_64-linux-gnu"</span>.</span><br><span class="line">Type <span class="string">"show configuration"</span> <span class="keyword">for</span> configuration details.</span><br><span class="line">For bug reporting instructions, please see:</span><br><span class="line">&lt;http://www.gnu.org/software/gdb/bugs/&gt;.</span><br><span class="line">Find the GDB manual and other documentation resources online at:</span><br><span class="line">&lt;http://www.gnu.org/software/gdb/documentation/&gt;.</span><br><span class="line">For <span class="built_in">help</span>, <span class="built_in">type</span> <span class="string">"help"</span>.</span><br><span class="line">Type <span class="string">"apropos word"</span> to search <span class="keyword">for</span> commands related to <span class="string">"word"</span>.</span><br><span class="line">albert@home-pc:~$</span><br></pre></td></tr></table></figure><h1 id="gdb-启动"><a href="#gdb-启动" class="headerlink" title="gdb 启动"></a>gdb 启动</h1><h2 id="直接启动"><a href="#直接启动" class="headerlink" title="直接启动"></a>直接启动</h2><p><code>gdb</code> 作为一个程序和其他的程序启动方式是一样的，直接敲入 <code>gdb</code> 命令回车就可以了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:~$ gdb</span><br><span class="line">GNU gdb (Ubuntu 7.11.1-0ubuntu1~16.5) 7.11.1</span><br><span class="line">Copyright (C) 2016 Free Software Foundation, Inc.</span><br><span class="line">License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;</span><br><span class="line">This is free software: you are free to change and redistribute it.</span><br><span class="line">There is NO WARRANTY, to the extent permitted by law.  Type <span class="string">"show copying"</span></span><br><span class="line">and <span class="string">"show warranty"</span> <span class="keyword">for</span> details.</span><br><span class="line">This GDB was configured as <span class="string">"x86_64-linux-gnu"</span>.</span><br><span class="line">Type <span class="string">"show configuration"</span> <span class="keyword">for</span> configuration details.</span><br><span class="line">For bug reporting instructions, please see:</span><br><span class="line">&lt;http://www.gnu.org/software/gdb/bugs/&gt;.</span><br><span class="line">Find the GDB manual and other documentation resources online at:</span><br><span class="line">&lt;http://www.gnu.org/software/gdb/documentation/&gt;.</span><br><span class="line">For <span class="built_in">help</span>, <span class="built_in">type</span> <span class="string">"help"</span>.</span><br><span class="line">Type <span class="string">"apropos word"</span> to search <span class="keyword">for</span> commands related to <span class="string">"word"</span>.</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure><p>看着是不是有些眼熟，这就是刚刚查 <code>gdb</code> 版本时看到的那段文字，只不过这段文字结束时不是返回到命令行，而是显现出了 <code>(gdb)</code> 的字样，我们暂时把它叫做 <code>gdb 命令行</code>，这就是我们与 <code>gdb</code> 程序进行交互的主要途径了。</p><h2 id="去掉版本信息启动"><a href="#去掉版本信息启动" class="headerlink" title="去掉版本信息启动"></a>去掉版本信息启动</h2><p>上面启动 <code>gdb</code> 时出现的这段文字很长，有时候反复调试程序时看到这段文字有点烦，想把它去掉怎么办？非常简单，在启动时加上 <code>-q</code> 参数就可以了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:~$ gdb -q</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure><p>怎么样，这次上面那段文字不见了，直接就进入 <code>gdb</code> 命令行了吧。</p><h1 id="gdb-信息查看"><a href="#gdb-信息查看" class="headerlink" title="gdb 信息查看"></a>gdb 信息查看</h1><p>其实刚刚被我们嫌弃的那段文字，里面记录了不少信息，其中还展示了 <code>show copying</code>、<code>show warranty</code>、<code>show configuration</code> 等多个命令，我们可以简单尝试下这些命令有什么作用。</p><h2 id="show-copying"><a href="#show-copying" class="headerlink" title="show copying"></a>show copying</h2><p>输入 <code>show copying</code> 命令展示的是一份比较长的版本许可证说明，我省略了中间的部分，如果想看的话可以自己输入命令试一下，<code>GPL v3</code> 的许可证看起来很熟悉吧。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:~$ gdb -q</span><br><span class="line">(gdb) show copying</span><br><span class="line">                    GNU GENERAL PUBLIC LICENSE</span><br><span class="line">                       Version 3, 29 June 2007</span><br><span class="line"></span><br><span class="line"> Copyright (C) 2007 Free Software Foundation, Inc. &lt;http://fsf.org/&gt;</span><br><span class="line"> Everyone is permitted to copy and distribute verbatim copies</span><br><span class="line"> of this license document, but changing it is not allowed.</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">  Later license versions may give you additional or different</span><br><span class="line">permissions.  However, no additional obligations are imposed on any</span><br><span class="line">author or copyright holder as a result of your choosing to follow a</span><br><span class="line">later version.</span><br></pre></td></tr></table></figure><h2 id="show-warranty"><a href="#show-warranty" class="headerlink" title="show warranty"></a>show warranty</h2><p>命令 <code>show warranty</code> 输出的内容相比之前的命令就短很多了，是一份免责声明，序号从15开始，接着版本许可证的序号往下写的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">(gdb) show warranty</span><br><span class="line">  15. Disclaimer of Warranty.</span><br><span class="line"></span><br><span class="line">  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY</span><br><span class="line">APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT</span><br><span class="line">HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM <span class="string">"AS IS"</span> WITHOUT WARRANTY</span><br><span class="line">OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,</span><br><span class="line">THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR</span><br><span class="line">PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM</span><br><span class="line">IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF</span><br><span class="line">ALL NECESSARY SERVICING, REPAIR OR CORRECTION.</span><br><span class="line"></span><br><span class="line">  16. Limitation of Liability.</span><br><span class="line"></span><br><span class="line">  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING</span><br><span class="line">WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS</span><br><span class="line">THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY</span><br><span class="line">GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE</span><br><span class="line">USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF</span><br><span class="line">DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD</span><br><span class="line">PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),</span><br><span class="line">EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF</span><br><span class="line">SUCH DAMAGES.</span><br><span class="line"></span><br><span class="line">  17. Interpretation of Sections 15 and 16.</span><br><span class="line"></span><br><span class="line">  If the disclaimer of warranty and limitation of liability provided</span><br><span class="line">above cannot be given <span class="built_in">local</span> legal effect according to their terms,</span><br><span class="line">reviewing courts shall apply <span class="built_in">local</span> law that most closely approximates</span><br><span class="line">an absolute waiver of all civil liability <span class="keyword">in</span> connection with the</span><br><span class="line">Program, unless a warranty or assumption of liability accompanies a</span><br><span class="line">copy of the Program <span class="keyword">in</span> <span class="built_in">return</span> <span class="keyword">for</span> a fee.</span><br></pre></td></tr></table></figure><h2 id="show-configuration"><a href="#show-configuration" class="headerlink" title="show configuration"></a>show configuration</h2><p>最后一个 <code>show configuration</code> 展示的 <code>gdb</code> 的一下配置信息，比如 <code>--with-system-gdbinit=/etc/gdb/gdbinit</code> 在进阶版的 <code>gdb</code> 调试技巧中应该经常用到，先有个印象就行。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">(gdb) show configuration</span><br><span class="line">This GDB was configured as follows:</span><br><span class="line">   configure --host=x86_64-linux-gnu --target=x86_64-linux-gnu</span><br><span class="line">             --with-auto-load-dir=<span class="variable">$debugdir</span>:<span class="variable">$datadir</span>/auto-load</span><br><span class="line">             --with-auto-load-safe-path=<span class="variable">$debugdir</span>:<span class="variable">$datadir</span>/auto-load</span><br><span class="line">             --with-expat</span><br><span class="line">             --with-gdb-datadir=/usr/share/gdb (relocatable)</span><br><span class="line">             --with-jit-reader-dir=/usr/lib/gdb (relocatable)</span><br><span class="line">             --without-libunwind-ia64</span><br><span class="line">             --with-lzma</span><br><span class="line">             --with-python=/usr (relocatable)</span><br><span class="line">             --without-guile</span><br><span class="line">             --with-separate-debug-dir=/usr/lib/debug (relocatable)</span><br><span class="line">             --with-system-gdbinit=/etc/gdb/gdbinit</span><br><span class="line">             --with-babeltrace</span><br><span class="line"></span><br><span class="line">(<span class="string">"Relocatable"</span> means the directory can be moved with the GDB installation</span><br><span class="line">tree, and GDB will still find it.)</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure><h2 id="apropos"><a href="#apropos" class="headerlink" title="apropos"></a>apropos</h2><p>其实在 <code>gdb</code> 启动说明中还展示了 <code>apropos</code> 这个命令，可以用这个命令来显示与指定词语相关的命令，比如 <code>apropos print</code> 就是查询所有描述中带有 <code>print</code> 的命令，可以执行测试一下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">(gdb) apropos <span class="built_in">print</span></span><br><span class="line">agent-printf -- Agent-printf <span class="string">"printf format string"</span></span><br><span class="line"><span class="built_in">alias</span> -- Define a new <span class="built_in">command</span> that is an <span class="built_in">alias</span> of an existing <span class="built_in">command</span></span><br><span class="line">backtrace -- Print backtrace of all stack frames</span><br><span class="line">bt -- Print backtrace of all stack frames</span><br><span class="line">call -- Call a <span class="keyword">function</span> <span class="keyword">in</span> the program</span><br><span class="line">commands -- Set commands to be executed when a breakpoint is hit</span><br><span class="line">compile code -- Compile</span><br><span class="line">compile <span class="built_in">print</span> -- Evaluate EXPR by using the compiler and <span class="built_in">print</span> result</span><br><span class="line"><span class="built_in">disable</span> pretty-printer -- GDB <span class="built_in">command</span> to <span class="built_in">disable</span> the specified pretty-printer</span><br><span class="line">...</span><br><span class="line">info <span class="built_in">type</span>-printers -- GDB <span class="built_in">command</span> to list all registered <span class="built_in">type</span>-printers</span><br><span class="line">info vector -- Print the status of the vector unit</span><br><span class="line">inspect -- Print value of expression EXP</span><br><span class="line">maintenance agent-printf -- Translate an expression into remote agent bytecode <span class="keyword">for</span> evaluation and display the bytecodes</span><br><span class="line">maintenance btrace packet-history -- Print the raw branch tracing data</span><br><span class="line">---Type &lt;<span class="built_in">return</span>&gt; to <span class="built_in">continue</span>, or q &lt;<span class="built_in">return</span>&gt; to quit---</span><br></pre></td></tr></table></figure><h2 id="help"><a href="#help" class="headerlink" title="help"></a>help</h2><p>查询具体的命令可以使用 <code>help</code> 子命令，比如查看 <code>bt</code> 这个查看调用栈帧的命令就可以使用 <code>help bt</code>，输入后回车可以得到这个命令的描述信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(gdb) <span class="built_in">help</span> bt</span><br><span class="line">Print backtrace of all stack frames, or innermost COUNT frames.</span><br><span class="line">With a negative argument, <span class="built_in">print</span> outermost -COUNT frames.</span><br><span class="line">Use of the <span class="string">'full'</span> qualifier also prints the values of the <span class="built_in">local</span> variables.</span><br><span class="line">Use of the <span class="string">'no-filters'</span> qualifier prohibits frame filters from executing</span><br><span class="line">on this backtrace.</span><br></pre></td></tr></table></figure><p><code>gdb</code>工作作为一款调试利器，可以使用的命令是在是太多了，除了这些还有很多命令等着我们去发现，今天的内容仅仅作为入门必备先简单了解一下。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li><code>gdb</code> 是一个交互式的命令行调试工具，通过不断执行命令，展示调试信息帮助我们调试程序</li><li>当启动 <code>gdb</code> 这个工具后，命令行会变成 <code>(gdb)</code>的形式，等着我们输入命令开始调试使用</li><li><code>gdb</code> 作为一个强大的 <code>GNU</code> 工具，文档比较全，如果觉的文档枯燥，也可以跟着我的总结来熟悉一下基础用法。</li><li>开源环境下软件的版权信息和免责声明写的都比较完整，其中有很多描述值得我们学习。</li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/107724714" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>而世之奇伟、瑰怪，非常之观，常在于险远，而人之所罕至焉，故非有志者不能至也~</p><p>2020-8-5 23:17:04</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;学习 &lt;code&gt;gdb&lt;/code&gt; 使用是一个漫长的过程，先了解一下 &lt;code&gt;gdb&lt;/code&gt; 的启动方式和基础信息的查看方法，能够帮助我们更全面的认知这个工具。&lt;code&gt;gdb&lt;/code&gt; 是一个交互式命令行程序，在使用 &lt;code&gt;gdb&lt;/code&gt; 调试的时候不断的在命令行内输入命令，然后 &lt;code&gt;gdb&lt;/code&gt; 程序就会给出反馈信息，这在很大程序上可以帮助我们调试程序问题。&lt;/p&gt;
    
    </summary>
    
      <category term="GDB" scheme="http://AlbertGithubHome.github.io/blog/categories/GDB/"/>
    
    
      <category term="GDB" scheme="http://AlbertGithubHome.github.io/blog/tags/GDB/"/>
    
      <category term="manual" scheme="http://AlbertGithubHome.github.io/blog/tags/manual/"/>
    
      <category term="调试" scheme="http://AlbertGithubHome.github.io/blog/tags/%E8%B0%83%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>小白眼中的docker究竟是个什么东西</title>
    <link href="http://AlbertGithubHome.github.io/blog/2020/07/28/%E5%B0%8F%E7%99%BD%E7%9C%BC%E4%B8%AD%E7%9A%84docker%E7%A9%B6%E7%AB%9F%E6%98%AF%E4%B8%AA%E4%BB%80%E4%B9%88%E4%B8%9C%E8%A5%BF/"/>
    <id>http://AlbertGithubHome.github.io/blog/2020/07/28/小白眼中的docker究竟是个什么东西/</id>
    <published>2020-07-28T15:44:10.000Z</published>
    <updated>2020-08-01T05:43:13.785Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><code>Docker</code>，中文名：容器引擎，别名：小鲸鱼，生于2013年3月20日，有一个法裔美籍的母亲 <code>Solumon Hykes</code>，父亲是谁，不得而知。虽然只有7岁，但是在 <code>Hello World</code> 平行宇宙中也算进入了青壮年吧，正在飞速的发展着。</p><a id="more"></a><p><code>Docker</code> 这个动物选的比较有意思，是一只蓝色的鲸鱼，作为地球上最大的动物，用它来代表容器再合适不过了。不过有谁知道为什么编程技术总是和动物挂钩啊？比如 <code>Linux</code> 的企鹅，<code>Python</code> 的大蛇，<code>Hadoop</code> 的大象等等，有知道的小伙伴还请告知一下。</p><p>俗话说的好，“程序不逛动物园，肯定技术有点悬”，经常看到网上有人推荐编程学习方法，先学学基础，然后再看几本儿动物书就可以了，看来这些封面上的动物已经深入人心了。</p><p>先把这些动物放到一边，来看看这个 <code>docker</code> 究竟是什么，之前我也不知道它是什么，甚至到了现在我也不能准确的说出它是什么，我只是以一个小白的身份来学习和使用，并且把一些弄懂的知识点总结起来，方便日后查找。</p><h1 id="关于docker的疑问"><a href="#关于docker的疑问" class="headerlink" title="关于docker的疑问"></a>关于docker的疑问</h1><p>如果你之前看到 <code>docker</code> 时会有下面这些疑问，可以跟着文章梳理了解一下，如果你对这些问题的答案早已烂熟于胸，那么可以简单浏览下，帮我挑挑毛病，也是帮助想学习的同学们：</p><ol><li><code>docker</code> 最近很火啊，它到底能用来做什么？</li><li><code>docker</code> 和虚拟机好像啊，难道就是轻量虚拟机吗？它们两者还有其他的区别吗？</li><li><code>docker</code> 教程里有 <code>ubuntu</code> 上安装 <code>docker</code>，还有 <code>docker</code> 上安装 <code>linux</code>，什么鬼，到底谁装谁啊？</li><li><code>docker</code> 真的这么牛吗？那开发项目必须得用上它啊，显得高端大气上档次！</li><li><code>docker</code> 宣称构建一次，处处运行，那它应该能跨平台吧？</li></ol><p>作为小白我也是带着这些疑问开始慢慢了解 <code>docker</code> 的，特别是那个 <code>ubuntu</code> 上装 <code>docker</code>，<code>docker</code> 上还能装 <code>ubuntu</code>，都给我整蒙圈了，通过不断学习才渐渐弄清了其中的原因。</p><h1 id="疑问探索解答"><a href="#疑问探索解答" class="headerlink" title="疑问探索解答"></a>疑问探索解答</h1><h2 id="docker-是什么"><a href="#docker-是什么" class="headerlink" title="docker 是什么"></a>docker 是什么</h2><p>关于 <code>docker</code> 我们来看下常见的介绍：</p><blockquote><p><code>Docker</code> 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的 <code>Linux</code> 机器或 <code>Windows</code> 机器上，也可以实现虚拟化，容器是完全使用沙箱机制，相互之间不会有任何接口。</p></blockquote><p>从这一段话中我们可以得到以下几个知识点：</p><ol><li>它是一个容器引擎</li><li>可以用来打包应用</li><li>可以发布到 <code>linux</code> 或者 <code>windows</code> 上</li><li>可以实现虚拟化</li><li>采用沙箱机制，相互隔离</li></ol><p>结合查到的资料来了解一下 <code>docker</code>，首先它是一个容器引擎，引擎这个词经常出现，什么游戏引擎，物理引擎，发动机引擎等等，每种引擎其实就是负责一种核心工作的模块或事物，通过封装来简化工作流程，降低工作难度，而 <code>docker</code> 作为容器引擎的作用当然就是生产容器了。</p><p>它的目的就是隔离应用，在隔离空间内部署自己独特的环境，需要了解的是它并不是一项新的技术，而是利用了 <code>Linux</code> 核心中的 <code>cgroups</code> 和 <code>namespace</code> 等资源分脱机制来进行隔离，这种被称为容器的进程独立于宿主和其它的隔离的进程，是很早就存在的技术，只不过经过 <code>docker</code> 封装之后使用起来更加方便了。</p><p>再说打包应用，这也是 <code>docker</code> 迅速火起来的一个原因，因为环境部署是在太费时费力了，之前在服务器配置一个应用的运行环境，要安装各种软件，<code>Java/Tomcat/MySQL</code>等等。安装和配置这些东西非常麻烦，并且还存在各种版本，而当我们换另一台同样操作系统的服务器还要再配置一遍，有没有办法这些配置直接拷贝过来呢？其实这就是 <code>docker</code> 要做的事情，将应用与运行环境打包到一起，直接在 <code>docker</code> 中运行一个容器就好了，你所依赖的环境直接就装好了。</p><p>前面提到 <code>docker</code> 是利用了 <code>linux</code> 内核的一些特性，那么 <code>windows</code> 可以运行吗？如果你查询早期一点的资料会得到不可以的答案，或者说即使在 <code>windows</code> 上运行 <code>docker</code>，也是在中间加了一层 <code>linux</code> 虚拟机。而如今已经 2020 年了，<code>windows</code> 上可以直接安装 <code>docker for windows</code> 来启动提供 <code>docker</code> 服务，而 <code>docker for mac</code> 也使得 <code>docker</code> 运行在 <code>mac</code> 上不再困难，<code>windows</code> 很早就和 <code>docker</code> 进行了合作，最新的 <code>win10</code> 上启动 <code>docker</code> 甚至可以切换内核为 <code>linux</code> 或者 <code>windows</code>，很神奇吧。</p><p>说到这里你应该对 <code>docker</code> 有了一个简单的了解，其中有一点很重要，它和宿主机是共享内核的，这是解答上面很多疑惑的钥匙，至于虚拟化，隔离这些都很容易理解了，而这些概念在虚拟机上常常出现，所以很容易把它俩弄混。</p><h2 id="容器与虚拟机"><a href="#容器与虚拟机" class="headerlink" title="容器与虚拟机"></a>容器与虚拟机</h2><p>自从 <code>docker</code> 出现，容器和虚拟机的对比就没有停过，这些对比常常从启动时间、资源占用、隔离性，操作便利性等方面来进行比较，可以用搜索引擎搜一下，大概就是下面这个样子：</p><table><thead><tr><th>特性</th><th>Docker容器</th><th>VM虚拟机</th></tr></thead><tbody><tr><td>启动速速</td><td>秒级</td><td>分钟级</td></tr><tr><td>性能</td><td>接近原生</td><td>明显弱于原生</td></tr><tr><td>硬盘使用</td><td>相对较小，可以自由分配</td><td>创建时分配，易造成浪费</td></tr><tr><td>系统支持量</td><td>支持上千个</td><td>一般几十个</td></tr></tbody></table><p>造成这种差异的原因是什么？还是前面说的 <code>docker</code> 和宿主机是共享内核，而虚拟机是自己创建了一整套系统，虽然隔离性更强，但是也造成了资源的浪费和效率的降低。</p><p>一直想找一个例子来形象地对比一下虚拟机和容器，我强行编一个吧，比如你是一个财富自由的人，准备回老家养养牛种种菜，包个鱼塘钓钓鱼，顺便再养一窝小白兔，但是小白兔会吃你种的蔬菜，牛偶尔也会踩到小白兔，这时怎么办，把它们隔开呗。</p><p>作为一个钱花不完的人，你准备造几个“小地球”，然后把饲养的动物和种植的植物都放到各自的“地球”中放养，每个小地球都是一个密封的环境，里面有自己的太阳、月亮、空气、河流、山川等等，这种方法当然可以，只是成本有些高，一旦建立了这个小地球，它所占有的资源就定下来了，基本上与大地球隔离，但是它还要依赖大地球，还要建立在地球上，可以类比下<strong>虚拟机</strong>。</p><p>因为建造小地球太费时费力了，所以你改了策略，这次不创建完全密闭的环境了，我直接造个篱笆就可以了，阳光、空气、河流我还是使用大地球的，只是在篱笆里我进行定制，做一些鱼塘、蔬菜大棚等等。由于建造篱笆非常省事，我可以批量生产，有需要了我可以直接拿来几个，放在地上就可以使用了，并且不同动物以及植物之间都有篱笆挡着，不会出现相互影响的问题了，这就有点像<strong>容器</strong>了。</p><p>虽然有些牵强，但是这个例子还是可以帮助我们了解容器和虚拟机的区别，实际上容器与虚拟机并不是对立的关系，有时为了防止容器无限制的占用物理机资源，还会现在物理机上运行虚拟机，然后在虚拟机里运行 <code>docker</code>，他们两者只是不同需求下的不同选择而已。</p><h2 id="操作系统和容器到底谁安装谁"><a href="#操作系统和容器到底谁安装谁" class="headerlink" title="操作系统和容器到底谁安装谁"></a>操作系统和容器到底谁安装谁</h2><p>前面说过 <code>ubuntu</code> 上装 <code>docker</code>，<code>docker</code> 上还能装 <code>ubuntu</code> 这个问题困扰了我好久，实际上 <code>windows</code> 可以装虚拟机，而虚拟机中有可以装 <code>windows</code> 这没什么好奇怪的，这里的 <code>dokcker</code> 指的就是 <code>docker</code> 引擎，或者认为是 <code>docker</code> 服务器。</p><p>它们确实可以相互安装，但情况是不同的，首先说 <code>ubuntu</code> 上装 <code>docker</code>，<code>docker</code> 说白了还是一种软件，本质上和你在电脑上装个QQ也没有多大差别，只不过这个软件有点特殊，通过它还能下载、安装别的环境，这么说它看起来有点像应用商店了，不过他虽然提供仓库，但是不仅仅是仓库，本质上它就是一种帮助你搭建环境的软件。</p><p>再来看看 <code>docker</code> 上装 <code>ubuntu</code>，还记得之前说过的一个重点吗？ <code>docker</code> 上安装的环境与宿主机共享内核，这就决定了他不能安装完整的系统，不管是 <code>ubuntu</code>、<code>CentOS</code> 还是 <code>RedHat</code>，它所安装的系统仅仅包含运行库和工具链，内核还是用宿主机的，相当于在 <code>docker</code> 中给内核套了一个新的壳子而已。</p><p>这下应该清楚了，<code>ubuntu</code> 上装 <code>docker</code> 就是在 <code>ubuntu</code> 上装了一个容器软件， <code>docker</code> 上装 <code>ubuntu</code> 就是在 <code>docker</code> 容器中给宿主内核套上了一个新系统的壳子，使其满足应用软件的环境，配备应用软件可使用的工具链。</p><h2 id="这么厉害的容器项目中一定要用吗"><a href="#这么厉害的容器项目中一定要用吗" class="headerlink" title="这么厉害的容器项目中一定要用吗"></a>这么厉害的容器项目中一定要用吗</h2><p>相信这种问题就是不了解容器也可以回答，肯定不是都要用啊，没有什么技术是只有优点没有缺点吧，凡是技术总有其适合的领域和场景，一味的追求最新的技术不一定符合所要开发的项目。</p><p><code>docker</code> 也没有传说的那么神，它也有着这样那样的问题，比如一直津津乐道的资源伸缩机制，不像虚拟机那样创建时便规定了资源大小，即使不使用也占用着，而 <code>docker</code> 可以直接使用宿主资源，避免了很多浪费。但是反过来想，虚拟机规定了资源的多少，如果不够用了只影响它自己，而 <code>docker</code> 如果一个环境出了问题，它可以把整个物理机的资源耗完，影响机器上的所有服务。</p><p>另外，<code>docker</code> 建议只部署无状态的服务，它们不应该承载任何交易数据，所有数据应该保存在数据库服务器中，器随时可以停止、或者删除。当容器被删除掉，容器里的数据将会丢失，即使你要把 <code>docker</code> 数据放在主机来存储，它依然不能保证不丢数据，具体的细节我也在学习，有这方面经验的朋友可以发表一下见解。</p><h2 id="docker的跨平台"><a href="#docker的跨平台" class="headerlink" title="docker的跨平台"></a>docker的跨平台</h2><p>先来看看跨平台的概念：</p><blockquote><p>跨平台概念是软件开发中一个重要的概念，即不依赖于操作系统，也不依赖硬件环境。一个操作系统下开发的应用，放到另一个操作系统下依然可以运行。</p></blockquote><p>首先要弄明白你说的跨平台指的是 <code>docker</code> 跨平台，还是它里边的应用使用 <code>docker</code> 就能跨平台了，从定义来说 <code>docker</code> 这个容器软件应该算是跨平台的，毕竟 <code>Linux</code>、 <code>Windows</code>、 <code>Mac</code> 都有了 <code>docker</code> 的安装包，那么他里面的镜像运行之后的容器能跨平台吗？这还要看具体的应用，<code>docker</code> 没有让一个非跨平台软件变成跨平台软件的能力。</p><p>关于这一点你还要牢记前面说的，<code>docker</code> 中的环境与宿主机共享内核，你创建了一个自己编写的exe程序的镜像，拿到安装了 <code>docker</code> 的 <code>ubuntu</code> 机器上显然是无法成功运行的。</p><h1 id="基础知识点"><a href="#基础知识点" class="headerlink" title="基础知识点"></a>基础知识点</h1><h2 id="docker的缺点"><a href="#docker的缺点" class="headerlink" title="docker的缺点"></a>docker的缺点</h2><p><code>docker</code> 的卖点是让你摆脱配置环境的困扰，但真实情况是你打包镜像的机器和系统版本，最好和你要运行的目标机器和系统版本一致，另外 <code>docker</code> 环境最好也一样，忽然感觉它没有那么神奇了，这不还是要求版本吗？</p><p>试想一下，你用一个高版本的 <code>docker</code> 服务打包，其中使用了一些新特性，然后放到低版本的 <code>docker</code> 服务下怎么能保证成功运行，机器配置也是一样，之前看到过一个问题 “尝试在具有 <code>4.19</code> 或更高内核的 <code>Linux</code> 系统上运行 <code>docker official centos:6</code> 或 <code>centos:5</code> 容器，当尝试启动它时，你会发现内核和程序不兼容”。</p><p>这样看来，<code>docker</code> 只适合在相同环境下批量复制，使得实现自动化测试和持续的集成很方便，但还是有些问题需要注意的：</p><ol><li><code>docker</code> 是基于64位系统环境的，32位环境下无法使用</li><li>隔离性相比 <code>KVM</code> 之类的虚拟化方案还是有些欠缺</li><li>容器随着用户进程的停止而销毁，其中的日志、打点等用户数据不便收集</li><li>网络管理相对简单，主要是基于 <code>namespace</code> 隔离</li><li>容器的 <code>root</code> 和宿主机 <code>root</code> 等同，这使得容器容易受到攻击</li><li>…</li></ol><h2 id="docker-的组成"><a href="#docker-的组成" class="headerlink" title="docker 的组成"></a>docker 的组成</h2><p>前面一直在说初学 <code>docker</code> 时的疑问，接下来看看 <code>docker</code> 究竟都包括哪些内容，<code>docker</code> 这个容器引擎实际上是一个客户端/服务器应用程序，客户端负责与守护的服务进程进行对话，而服务进程负责构建、运行和分发 <code>docker</code> 容器。<br><code>docker</code> 客户端和服务进程可以在同一系统上运行，也可以进行远程访问，通过网络接口使用 <code>RESTful API</code> 进行通信。</p><p>使用 <code>docker</code> 时常常要接触三个概念：镜像（Image）、容器（Container）和仓库（Repository）。简单来说镜像就是我们的想要打包的程序机加上程序运行环境，打包出来的一个文件，相当于程序安装包。当镜像运行起来我们就得到了容器，镜像与容器的关系就类似于类和对象的关系。仓库就是存放镜像的地方，与代码的仓库 <code>Github</code> 很像，<code>docker</code> 镜像也有一个常用的仓库叫 <code>Docker Hub</code>，方便人们直接下载镜像来运行。</p><h2 id="运行一个镜像"><a href="#运行一个镜像" class="headerlink" title="运行一个镜像"></a>运行一个镜像</h2><p><code>Hello world</code> 常常被拿来新知识的入门和开头，今天我们用这个例子来做一下收尾吧，首先你得有 <code>docker</code> 环境，说人话就是你得装了 <code>docker</code> 软件，之前不是一直说 <code>docker</code> 就是一个软件吗，你想用它当然得安装了，这类教程很多，假设你已经安装完了，</p><p>我们在一台 <code>CentOS</code> 上操作使用一下 <code>docker</code>，查询下系统版本和 <code>docker</code> 版本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@remote-os ~]<span class="comment"># lsb_release -a</span></span><br><span class="line">LSB Version:    :core-4.1-amd64:core-4.1-noarch</span><br><span class="line">Distributor ID: CentOS</span><br><span class="line">Description:    CentOS Linux release 7.7.1908 (Core)</span><br><span class="line">Release:    7.7.1908</span><br><span class="line">Codename:   Core</span><br><span class="line">[root@remote-os ~]<span class="comment"># docker --version</span></span><br><span class="line">Docker version 19.03.7, build 7141c199a2</span><br><span class="line">[root@remote-os ~]<span class="comment">#</span></span><br></pre></td></tr></table></figure><p>首先下载 <code>hello world</code> 镜像，使用 <code>docker image pull hello-world</code> 命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@remote-os ~]<span class="comment"># docker image pull hello-world</span></span><br><span class="line">Using default tag: latest</span><br><span class="line">latest: Pulling from library/hello-world</span><br><span class="line">Digest: sha256:49a1c8800c94df04e9658809b006fd8a686cab8028d33cfba2cc049724254202</span><br><span class="line">Status: Image is up to date <span class="keyword">for</span> hello-world:latest</span><br><span class="line">docker.io/library/hello-world:latest</span><br></pre></td></tr></table></figure><p>查看本地镜，使用 <code>docker image ls</code> 命令，发现 <code>hell-world</code> 镜像已经在本地了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@remote-os ~]<span class="comment"># docker image ls</span></span><br><span class="line">REPOSITORY                  TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">ubuntu                      latest              adafef2e596e        3 weeks ago         73.9MB</span><br><span class="line">registry                    latest              708bc6af7e5e        6 months ago        25.8MB</span><br><span class="line">hello-world                 latest              bf756fb1ae65        7 months ago        13.3kB</span><br><span class="line">wurstmeister/zookeeper      latest              3f43f72cb283        18 months ago       510MB</span><br><span class="line">hyper/docker-registry-web   latest              0db5683824d8        3 years ago         599MB</span><br><span class="line">[root@remote-os ~]<span class="comment">#</span></span><br></pre></td></tr></table></figure><p>下载完成之后直接使用 <code>docker container run hello-world</code> 命令运行就可以了，这个镜像运行打印完直接就退出了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[root@remote-os ~]<span class="comment"># docker container run hello-world</span></span><br><span class="line"></span><br><span class="line">Hello from Docker!</span><br><span class="line">This message shows that your installation appears to be working correctly.</span><br><span class="line"></span><br><span class="line">To generate this message, Docker took the following steps:</span><br><span class="line"> 1. The Docker client contacted the Docker daemon.</span><br><span class="line"> 2. The Docker daemon pulled the <span class="string">"hello-world"</span> image from the Docker Hub.</span><br><span class="line">    (amd64)</span><br><span class="line"> 3. The Docker daemon created a new container from that image <span class="built_in">which</span> runs the</span><br><span class="line">    executable that produces the output you are currently reading.</span><br><span class="line"> 4. The Docker daemon streamed that output to the Docker client, <span class="built_in">which</span> sent it</span><br><span class="line">    to your terminal.</span><br><span class="line"></span><br><span class="line">To try something more ambitious, you can run an Ubuntu container with:</span><br><span class="line"> $ docker run -it ubuntu bash</span><br><span class="line"></span><br><span class="line">Share images, automate workflows, and more with a free Docker ID:</span><br><span class="line"> https://hub.docker.com/</span><br><span class="line"></span><br><span class="line">For more examples and ideas, visit:</span><br><span class="line"> https://docs.docker.com/get-started/</span><br></pre></td></tr></table></figure><p>如果不想退出，运行的镜像应该是能提供某种服务的，比如前面一直说的 <code>ubuntu</code>，它可以在 <code>docker</code> 中运行起来，直接使用 <code>docker container run -it ubuntu bash</code> 命令就行，这里为什么我们不先下载呢？实际上如果你指定的镜像在本地没有的话会自动下载，不需要手动下载完再运行。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@remote-os ~]<span class="comment"># docker container run -it ubuntu bash</span></span><br><span class="line">root@0577050677ac:/<span class="comment"># cat /etc/issue</span></span><br><span class="line">Ubuntu 20.04 LTS \n \l</span><br><span class="line"></span><br><span class="line">root@0ecfed0920aa:/<span class="comment"># ls</span></span><br><span class="line">bin  boot  dev  etc  home  lib  lib32  lib64  libx32  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var</span><br><span class="line">root@0ecfed0920aa:/<span class="comment"># ll home/</span></span><br><span class="line">total 8</span><br><span class="line">drwxr-xr-x 2 root root 4096 Apr 15 11:09 ./</span><br><span class="line">drwxr-xr-x 1 root root 4096 Jul 31 16:23 ../</span><br><span class="line">root@0ecfed0920aa:/<span class="comment">#</span></span><br></pre></td></tr></table></figure><p>可以看到上面的操作，我们又进入了 <code>ubuntu</code> 系统，成功运行了镜像，现在得到了一个容器，可以通过 <code>docker container ls</code> 命令查看，还可以通过 <code>docker container rm [containerID]</code> 命令来删除容器。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li><code>docker</code> 软件可以运行在<code>windows</code>、<code>linux</code> 和 <code>mac</code> 上</li><li><code>docker</code> 容器与宿主机共享一个系统内核，如果依赖内核版本的应用最好保证物理机系统版本一致</li><li><code>docker</code> 容器与虚拟机并不是对立的，有时候会放在一起配合使用</li><li><code>docker</code> 有自己的镜像仓库，可以直接下载安装，使用起来相当方便，因为网络原因，如果想快速搭建最好提前准备好镜像文件</li></ul><hr><h2 id="gt-gt-反爬链接，请勿点击，原地爆炸，概不负责！-lt-lt"><a href="#gt-gt-反爬链接，请勿点击，原地爆炸，概不负责！-lt-lt" class="headerlink" title=" ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== "></a><center><a href="https://blog.csdn.net/albertsh/article/details/107587859" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center></h2><blockquote><p>海纳百川有容乃大，壁立千仞无欲则刚~</p><p>2020-8-1 00:31:35</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&lt;code&gt;Docker&lt;/code&gt;，中文名：容器引擎，别名：小鲸鱼，生于2013年3月20日，有一个法裔美籍的母亲 &lt;code&gt;Solumon Hykes&lt;/code&gt;，父亲是谁，不得而知。虽然只有7岁，但是在 &lt;code&gt;Hello World&lt;/code&gt; 平行宇宙中也算进入了青壮年吧，正在飞速的发展着。&lt;/p&gt;
    
    </summary>
    
      <category term="docker" scheme="http://AlbertGithubHome.github.io/blog/categories/docker/"/>
    
    
      <category term="docker" scheme="http://AlbertGithubHome.github.io/blog/tags/docker/"/>
    
      <category term="容器" scheme="http://AlbertGithubHome.github.io/blog/tags/%E5%AE%B9%E5%99%A8/"/>
    
  </entry>
  
</feed>
