<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Albert World</title>
  <icon>https://www.gravatar.com/avatar/8ccc6291d5bfd34e7aaf601c4ebec7e1</icon>
  
  <link href="/blog/atom.xml" rel="self"/>
  
  <link href="http://AlbertGithubHome.github.io/blog/"/>
  <updated>2024-01-14T11:53:01.922Z</updated>
  <id>http://AlbertGithubHome.github.io/blog/</id>
  
  <author>
    <name>Albert Shi</name>
    <email>347070901@qq.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>推荐一款通过ssh连接linux服务的开源工具WindTerm</title>
    <link href="http://AlbertGithubHome.github.io/blog/2024/01/14/%E6%8E%A8%E8%8D%90%E4%B8%80%E6%AC%BE%E9%80%9A%E8%BF%87ssh%E8%BF%9E%E6%8E%A5linux%E6%9C%8D%E5%8A%A1%E7%9A%84%E5%BC%80%E6%BA%90%E5%B7%A5%E5%85%B7WindTerm/"/>
    <id>http://AlbertGithubHome.github.io/blog/2024/01/14/推荐一款通过ssh连接linux服务的开源工具WindTerm/</id>
    <published>2024-01-14T11:39:08.000Z</published>
    <updated>2024-01-14T11:53:01.922Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>工作一入门便是游戏服务器开发，所以常常有连接Linux服务器的需求，之前用的最多的是Xshell，最近这个软件个人版只能免费使用一个月了，超过时间会提示更新无法正常使用，工作当中用的最多的是SecureCRT，不过这个软件是收费的，公司买了授权，可以正常用，但是在家时就不行了，最近我找到了WindTerm这个软件，用起来还不错，记录一下。</p><h1 id="WindTerm介绍"><a href="#WindTerm介绍" class="headerlink" title="WindTerm介绍"></a>WindTerm介绍</h1><blockquote><p>A Quicker and better SSH/Telnet/Serial/Shell/Sftp client for DevOps.</p></blockquote><p>WindTerm一款使用使用C语言开发的跨平台SSH客户端WindTerm，完全免费开源，软件包只有20多M，性能很好，Windows、Linux、Mac均提供程序包下载，免按照，下载解压即可使用，官方地址为 <a href="https://github.com/kingToolbox/WindTerm/releases" target="_blank" rel="noopener">https://github.com/kingToolbox/WindTerm/releases</a>，最新版本为2.6.0</p><p><img src="https://img-blog.csdnimg.cn/direct/675fda112cc34909909ad7647c3fce5e.png#pic_center" alt="windterm download">最近github访问又变慢了，如果你下载不下来，可以从这个平台地址下载<a href="https://download.csdn.net/download/shihengzhen101/88740938" target="_blank" rel="noopener">CSDN下载-WindTerm_2.6.0_Prerelease_7_Windows_Portable_x86_64.zip</a>，我已经设置成免积分了，方便有需要的人直接取用，简单罗列下它的功能。</p><ul><li>多平台支持Linux，Mac，Win，免安装解压即可使用</li><li>实施了 SSH v2、Telnet、Raw Tcp、串行、Shell 协议</li><li>会话认证时支持 SSH 自动执行</li><li>支持 SSH ProxyCommand 或 ProxyJump</li><li>支持SSH代理转发。</li><li>支持使用密码、公钥、键盘交互、gssapi-with-mic 的 SSH 自动登录</li><li>支持直接/本地端口转发、反向/远程端口转发和动态端口转发</li><li>支持 XModem、YModem 和 ZModem，可以使用rz、sz上传和下载文件</li><li>集成sftp、scp客户端，支持下载、上传、删除、重命名、新建文件/目录</li><li>集成本地文件管理器，支持移动到、复制到、复制自、删除、重命名、新建文件/目录</li><li>支持 Windows Cmd、PowerShell 和 Cmd、PowerShell 作为管理员</li><li>支持Linux bash、zsh、powershell core</li><li>支持 MacOS bash、zsh、powershell core</li><li>有较好的操作界面</li></ul><h1 id="WindTerm使用"><a href="#WindTerm使用" class="headerlink" title="WindTerm使用"></a>WindTerm使用</h1><p>下载WindTerm_2.6.0_Prerelease_7_Windows_Portable_x86_64.zip 后解压，双击WindTerm.exe即可打开软件，会弹出下面的界面，提示存储配置文件的地方，我就选择放到应用程序目录了</p><p><img src="https://img-blog.csdnimg.cn/direct/cdbbedbd143f4841bc4575ca9b6c37d4.png#pic_center" alt="windterm open"></p><p>直接通过【会话】-&gt;【新建会话】便可以建立连接Linux服务器的通道，这与之前用的软件都大同小异，基本没有差别，输入主机地址点击【连接】，后续再输入密码就可以开始连接了</p><p><img src="https://img-blog.csdnimg.cn/direct/f387f7832a1549bf93726ab773c611a6.png" alt="new session">如果是第一个使用的时候，会弹出下面这个界面，让自定义一个主密码，其实就是这个软件的使用密码，后续锁屏或者更新会话信息时会用到。</p><p><img src="https://img-blog.csdnimg.cn/direct/a22b701407c24290be4b440aa906d879.png#pic_center" alt="main password"></p><p>因为我是自己在家使用，我就不设置主密码了，直接点击OK完成，后面会让输入Linux账户和密码，到这一步相信大家都会用了。</p><h1 id="主密码和锁屏"><a href="#主密码和锁屏" class="headerlink" title="主密码和锁屏"></a>主密码和锁屏</h1><p>这个问题我也是查了一些资料才解决的，因为我没有输入主密码，所以每次锁屏时我只要回车就可以了，如果想修改锁屏时间，在【会话】-&gt;【首选项】-&gt;【设置】中可以找到</p><p><img src="https://img-blog.csdnimg.cn/direct/e143aec960c4491fb4fcc22d14ca502a.png#pic_center" alt="windterm setting"><br>也可以直接通过配置文件修改，找到刚启动软件时你选择的目录 <code>D:\app\WindTerm_2.6.0\.wind\profiles\default.v10</code>，直接修改配置文件内容，通过字段名也很清楚要改哪些值</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"application.fingerprint"</span> : <span class="string">"c5QR13M1iEkNPGlVNjDBWadi1uS0PiXR4Y+79cp09PAXr7G6WQxg/7WFj9RJ9dIsKKOWqm5Xq2N6w5Jx4v2mTw=="</span>,</span><br><span class="line">    <span class="attr">"application.language"</span> : <span class="string">"zh-CN"</span>,</span><br><span class="line">    <span class="attr">"application.lockScreenTimeout"</span> : <span class="number">1</span>,</span><br><span class="line">    <span class="attr">"application.masterPassword"</span> : <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">"terminal.loginWizard.defaultAuthType"</span> : <span class="string">"Account"</span>,</span><br><span class="line">    <span class="attr">"terminal.reimportShellSessions"</span> : <span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>application.lockScreenTimeout</code>：是控制锁屏时间的</li><li><code>application.masterPassword</code>：是代表是否有主密码的</li></ul><p>整个页面布局和配色还是挺漂亮的，不喜欢可以自己调整的哈</p><p><img src="https://img-blog.csdnimg.cn/direct/ea41dd99bf6b430ba5023eb358cd5752.png#pic_center" alt="windterm shell"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>WindTerm是一款可以通过ssh连接Linux服务器的客户端工具</li><li>WindTerm免费开源，支持Windows、Linux、Mac系统，无需安装，解压即可使用</li><li>WindTerm集成sftp、scp客户端，支持下载、上传、删除、重命名、新建文件/目录</li><li>WindTerm默认需要指定一个主密码，相当于验证使用者身份的功能，当然也可以为空</li><li>WindTerm的锁屏时间可以通过首选项菜单设置，也可通过配置修改</li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/135315104" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>人生就是一本账，欠下的东西总要还的，茫茫人生路之后，你是想在历史长河中留下一笔，还是“隐藏”的毫无痕迹呢？</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;工作一入门便是游戏服务器开发，所以常常有连接Linux服务器的需求，之前用的最多的是Xshell，最近这个软件个人版只能免费使用一个月了，超
      
    
    </summary>
    
      <category term="linux" scheme="http://AlbertGithubHome.github.io/blog/categories/linux/"/>
    
    
      <category term="linux" scheme="http://AlbertGithubHome.github.io/blog/tags/linux/"/>
    
      <category term="运维" scheme="http://AlbertGithubHome.github.io/blog/tags/%E8%BF%90%E7%BB%B4/"/>
    
      <category term="ssh" scheme="http://AlbertGithubHome.github.io/blog/tags/ssh/"/>
    
      <category term="windterm" scheme="http://AlbertGithubHome.github.io/blog/tags/windterm/"/>
    
      <category term="免安装" scheme="http://AlbertGithubHome.github.io/blog/tags/%E5%85%8D%E5%AE%89%E8%A3%85/"/>
    
  </entry>
  
  <entry>
    <title>2023年终总结——你相信光吗</title>
    <link href="http://AlbertGithubHome.github.io/blog/2024/01/01/2023%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93%E2%80%94%E2%80%94%E4%BD%A0%E7%9B%B8%E4%BF%A1%E5%85%89%E5%90%97/"/>
    <id>http://AlbertGithubHome.github.io/blog/2024/01/01/2023年终总结——你相信光吗/</id>
    <published>2023-12-31T16:02:35.000Z</published>
    <updated>2024-01-14T11:49:26.200Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>不断追求利益的经济冲动，不停侵蚀人们的生活，压垮、吞噬并统治生活本身，无法言喻的不安和看不到明天的混沌感，让我们在现有社会经济条件下，沦为被金钱和物质所统治的行尸走肉~</p></blockquote><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近在看一本叫《饱食穷民》的书，讲述的是泡沫经济年代的日本社会，宛如梦幻泡影一样变化无常，又像断梗浮萍一样飘忽不定，到处充斥着不安的色彩，我试图从中寻找一些当前现实问题的解决方案，上段文字也是出自此书之中，阅读之后我大受震撼，其中描述的有关软件工程师的篇章，简直就是我的复刻版，无论是心境、情感、还是所面临的问题都如出一辙，读完觉得背后隐隐发凉，因为最终那些令人无法接受的结局，确实是我不想看到的。</p><a id="more"></a><p>2023年要结束了，今年的时光过的格外的快，突然想起大年初二时半夜更新游戏版本好像还是昨天发生的事情，结果一眨眼就来到了2023的尾巴，2022年末的时候大家对2023年的发展充满了希望，结果今年快过完了，发现比之前“三年”更难了，零下20度的温度配合着各种“毕业”的声音，让不安的情绪充斥着每一个打工人的内心。</p><p>面对除夕上班的决定，一开始大家还是强烈反对，但是渐渐的情绪发生了逆转，除夕上班说明还有工作，很多人在这个寒冷的冬天已经“提前放假”，没有打工的机会了，在这个寒冷的冬天，你还相信光吗？</p><h1 id="回顾2023"><a href="#回顾2023" class="headerlink" title="回顾2023"></a>回顾2023</h1><p>回顾这一年忙忙碌碌，高强度的工作却没取得预想的成果，各种Flag完成情况更是惨不忍睹。</p><h2 id="工作上"><a href="#工作上" class="headerlink" title="工作上"></a>工作上</h2><blockquote><p>FLAG</p><ul><li>适应自己身份的转变，提升自己的管理技能，做一名合格的管理者</li><li>继续做好本职可开发工作，做好工作内容的总结，推动新项目顺利上线</li><li>根据自己的技能树框架，查漏补缺，有针对性的学习和探索</li></ul><p>完成度 ：80%</p></blockquote><p>作为一个入门的管理者，今年见识到了更多更复杂的管理情景，Hire and Fire 全都经历过了，管理经验更加完整，尝试跨过了之前一直无法逾越的坎，为了能生存下去，有时不得不做出取舍，参加了一系列的管理课程，学习后发现万物皆可为工具，招人的工具、提升效率的工具、提升凝聚力的工具、提高团队氛围的工具、优化团队的工具，学习过后内心不禁生出一丝悲凉。</p><p>本职工作继续充当牛马，还真是个踏踏实实的老黄牛，推动项目一步步往前走，但目前项目暂时停滞了，今年上线是不可能了，不过经历了一次完整的测试过程，算是在失望之中获得了一点点慰藉。</p><p>今年的工作强度依旧很大，前三季度基本上12点左右回家，个别时候会工作到后半夜，比上一年能好一点，但是最终的结果却不尽如人意。</p><p>技能树框架基本荒废，因为没时间往里边填东西，基本上是被项目推着走，缺什么就补什么，nginx测试和调整配置有了一定的经验，linux系统参数的调优也在压测是接触了不少，还有网络参数配置等等。</p><p>对于这一项来说，努力到位了，结果并不能说明什么，可能还是缺少一点点运气了。</p><h2 id="学习上"><a href="#学习上" class="headerlink" title="学习上"></a>学习上</h2><blockquote><p>FLAG</p><ul><li>继续博客总结，40篇是基础线，2023要超过这个值，尽量一周一篇，放假可休息</li><li>新的一年依旧很忙，刷题不强制要求，每周最好有贡献，每月必须有输出</li><li>在现有的技能树框架上继续丰富，做到枝繁叶茂，试试找点副业</li><li>开源代码还是以项目为驱动，选取经典实现，比如kafka</li><li>继续读书，今年书也买好了，数量不多，下半年应该还会买一批</li></ul><p>完成度 ：70%</p></blockquote><p>博客总结目标达成，今年在CSDN共有42篇总结，较40篇的及格线多了一点点，年初有篇关于ChatGPT的博文一开始阅读量刷刷刷的涨，后来判定违规就被吞了，整体上博客内容比较基础，大多数来源于工作之中的知识点，也有一些是平时的思考和感悟，以下是近两年的数据对比。</p><p><img src="https://img-blog.csdnimg.cn/direct/6b8bf36d48904677a5bc85c80ac6e31e.png#pic_center" alt="vs-csdn"></p><a href="!--![2022csdn](https://img-blog.csdnimg.cn/direct/1b019f2ab6114156874451c0f6f20ad7.png#pic_center)![2023csdn](https://img-blog.csdnimg.cn/direct/77a16b7b2d6c406f9c30eda21fc529bc.png#pic_center)--">!--![2022csdn](https://img-blog.csdnimg.cn/direct/1b019f2ab6114156874451c0f6f20ad7.png#pic_center)![2023csdn](https://img-blog.csdnimg.cn/direct/77a16b7b2d6c406f9c30eda21fc529bc.png#pic_center)--</a><p>2023年一年的博客访问量突破了60万，相比于去年的40多万上升了不少，文章基数增多了应该是主要原因，去年的10W+文章<a href="https://blog.csdn.net/albertsh/article/details/92385277" target="_blank" rel="noopener">《float的精度和取值范围》</a> 一年就上涨了6万多，看来高质量的内容才是吸引人的关键，并且会形成头部效应，马太效应，出现强者恒强的情况。</p><p>今年的CSDN活动依旧不少，但是我已经很少参加了，一方面没有那么多时间，还有就是看不懂规则，年终的博客之星评选，由于博文的数量没有达标，连报名的资格都没有，有点遗憾。</p><p>关于刷题这个Flag约等于没有，别说刷题了，忙的连账号都没登录几次，刚刚看了看提交记录，仅在前两个月提交了十几道题，图我就不截了，有点磕碜，不过新的一年中可能需要多一点了，毕竟工作都不稳定了，得准备准备练练手感了。</p><p>技能树框架秃了，其实我也不想秃，但是每天回家总是很晚，我实在是懒得补充了，这明显是一个借口，但却是一个事实，心里知道这个事情要做，所以换了一种方式，改为记笔记的方式来弥补，一开始准备每天问自己一个问题，后来坚持不下来，但是每次有空闲想起来就会认真回答一次，然后就是将工作中遇到的盲点和知识点记录下来，为技能树积累素材。</p><p>阅读经典代码这部分还是以项目驱动为主，比如修改easyloging++文件描述符不释放的问题，分析libevent网络数据读取缓慢的问题，扩展框架支持 websocket 连接等，都是从项目需求实际出发，当然也看了一些帧同步小游戏的示例代码，有C#的也有JS的，暂时没有找到能明显解决我对帧同步疑问的项目，目前还在学习和寻找中。</p><p>读书一直没有停，由于每天大强度的工作时间，休息之余我已经不读技术类书籍了，现在读的更多是传记、小说、散文等等，通过一页页纸张回顾历史长河，窥探他人的一生。</p><p>有的人纷繁的一生落在纸上不过一页，而绝大多数人根部就不会在书本上留下痕迹。以下便是2023年阅读的书籍内容：</p><ul><li>时间从来不语却回答了所有问题（2023-2-12 13:56）<ul><li>一本杂记，更多的是晚年的人生</li></ul></li><li>苏东坡传 —— 一蓑烟雨任平生（2023-2-26 23:57）<ul><li>人身缘何不快乐，只因未读苏东坡</li></ul></li><li>知行合一王阳明（2023-3-12 20:43）<ul><li>良知源自内心，无需外求。功名利禄，本是外在的，得之我幸，不得我命。</li></ul></li><li>别让孩子伤在敏感期（2023-3-19 16:32:23）<ul><li>在孩子处于各种敏感期时，学会给予尊重，顺其自然，适时引导</li><li>不要规划孩子必须在哪一个领域取得成就，但只要她喜欢，就提供一个舞台，让她尽情去发挥</li></ul></li><li>我是猫（2023-6-25 00:48:05）<ul><li>两年的猫生戛然而止，古怪的苦沙弥高朋满座</li></ul></li><li>人间失格（2023-6-24 13:30:50）<ul><li>一个从小就将自己伪装起来的孩子着实令人害怕，让人回忆起了令人心酸的表哥</li><li>虽然一切都已经过去，但还是有些记忆片段会在读书是产生共鸣，从记忆深处涌上来</li><li>《斜阳》中的我是贵族是对时代的呐喊，回不去也融不进</li><li>《GoodBye》更是写成了幻想小说的范畴</li></ul></li><li>罗生门（2023-8-7 23:13:34）<ul><li>怪诞、讽刺、描写细致的短篇小说，不过有些故事的寓意看不太懂</li></ul></li><li>浮生六记（2023-11-26 22:35:23）<ul><li>初中时的课文《童趣》居然来自这本书，据说后两记是伪写的，但最后一记《养生记道》却多次引起共鸣，可能我正处在迷茫期吧。“五百年谪在红尘，略成游戏。三千里击开沧海，便是逍遥。”</li></ul></li><li>月亮与六便士（2023-12-10 17:00:27）<ul><li>一个完全不顾他人感受的人是否能称之为伟大，疯子还差不多</li></ul></li></ul><p>《苏东坡传》描写了苏东坡的一生，他虽狂放不羁，但有个一直拯救他的弟弟却是它一生的幸福，“人身缘何不快乐，只因未读苏东坡”，其实不止是苏东坡，很多大人物的一生就极其坎坷，如果看看他们的经历，我们的人生才刚刚开始，而如今这个浮躁的社会已经很难让人平静的接受这一切了。</p><p>《月亮与六便士》是一本很出名的书籍，从听说这本书到真正的开始读跨过了大概6、7年的时间，但如今读过之后却让与我的预想差距太大，我没想到这是一篇小说，斯特里克兰简直是一个变态，全文描述了他不顾一切的追求艺术，将其称之为伟大，但我觉得这样的伟大毫无意义，即使他的绘画技艺已经出神入化，世界也不缺他一个，但他却真实的伤害了周围的每一个人。</p><h2 id="投资上"><a href="#投资上" class="headerlink" title="投资上"></a>投资上</h2><blockquote><p>FLAG</p><ul><li>定投和智能条件单保持现状，ETF追加1~2个新的行业赛道</li><li>股票池还有几个垃圾票要找机会清理掉，手里的价投股票适当做做趋势</li><li>保持对新年经济的乐观，目标收益10个点</li></ul><p>完成度 ：50%</p></blockquote><p>今年除了少量增持了之前的“三傻”和科技股之外，追加了医药ETF和光伏ETF，设置了定投单和网格条件单，持仓的FLAG的是达到了，但收益有点一言难尽，手中的垃圾票清掉了部分，有些垃圾真得再等几年，这种票已经不关注了，就留在持仓列表里做个提醒好了。</p><p>工业富联算是今天收获颇丰的一个票，也是唯一一个高额正收益的票，去年的FLAG是【目标收益10个点】，可能这个愿望描述的不够具体，就像雍和宫许愿一样，被调剂成了负的，结果股票加基金损失了10个点左右，真是令人头大。</p><p><img src="https://img-blog.csdnimg.cn/direct/dcf20fef8ab34e2cac9bf3a3676c6be4.png#pic_center" alt="2023finance"></p><p>本来前10个月收益基本达标，但最后这一个季度，行情急转直下，价值投资带头向下俯冲，毫无招架之力。</p><h2 id="生活上"><a href="#生活上" class="headerlink" title="生活上"></a>生活上</h2><blockquote><p>FLAG</p><ul><li>疫情放开了，有事没事都趁着假期回家看看</li><li>身体很重要，锻炼的很费时，中和一下，可以跳跳绳</li><li>周末了陪娃耍一耍，工作尽量不占用周末的时间</li></ul><p>完成度 ：70%</p></blockquote><p>今年回家的次数也不是太多，元旦、春节、劳动节、国庆中秋节总计21天，比2022年的14天多了不少，主要差在了国庆假期上，回家正好收玉米，赶上了丰收的季节。</p><p>身体锻炼几乎没有，全年跳绳不超过3次，不过脂肪肝和高尿酸的情况都有所减轻，每天真的懒得不想动。</p><p>2023年的周末和工作日分的还是比较清晰的，工作日强度很大，但周末工作的时间很少了，真的是在家陪家人和或者一起出去逛逛，一家人去了之前谈论了8年还没去过的香山公园，看了一圈几乎还没红的枫叶。</p><p>去年的<a href="https://blog.csdn.net/albertsh/article/details/128509220" target="_blank" rel="noopener">总结</a>中给我养的<a href="https://img-blog.csdnimg.cn/ce62daf422b44245899491810d55e7d4.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9hbGJlcnRnaXRodWJob21lLmdpdGh1Yi5pby9ibG9nL2Fib3V0,size_14,color_FFFFFF,t_70#pic_center" target="_blank" rel="noopener">花花拍了照片</a>，今年对比了一下发现一年的时间长了很多，再拍一张照片看看。</p><p><img src="https://img-blog.csdnimg.cn/direct/0db1f97f7cdc4b40b0b3b3cec886986b.png#pic_center" alt="2023flower"></p><p>2023年初还补充了几盆多肉，从最开始的柔弱养成了郁郁葱葱的“绿油油”，这一年个头没少长，都窜的老高，就是不上颜色，可能是光照太少了？</p><p><img src="https://img-blog.csdnimg.cn/direct/2266494abc084622a2df361b00673cd6.png#pic_center" alt="2023flower2"></p><p>年初文章总结了<a href="https://blog.csdn.net/albertsh/article/details/128892715" target="_blank" rel="noopener">《工作十年对游戏看法的转变历程》</a>，文中提到我买了8090掌上游戏机玩俄罗斯方块，后来趁娃不在又买了Switch准备寻找灵感，但结果就是海关发货太慢了，等娃回来正好赶上游戏机送到，最后Switch就成了她的玩具。</p><p><img src="https://img-blog.csdnimg.cn/direct/422325b949a046fd9dcbc03a3364d5a5.png#pic_center" alt="在2023game"></p><p>现在每天没时间玩也不敢玩，和娃约定好了周末才可以玩一会，每周末充一次电，和宝宝一起玩一会赛车还是很有意思的，偶尔自己偷偷玩玩塞尔达，似乎这些才能被称之为真正的游戏，哪些哪里亮就点哪里的游戏真的能被称为游戏吗？自己对这类游戏有些厌倦了。</p><h1 id="展望2024"><a href="#展望2024" class="headerlink" title="展望2024"></a>展望2024</h1><h2 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h2><ul><li>今年的工作环境极其复杂，切换了新的赛道，工作内容繁杂，需要逐步将内容理顺</li><li>继续培养管理技能，面对不同的人采取不同的策略，尝试向上管理的方法</li><li>补充技能树框架，采取提问和总结的方式，有针对性的学习和探索，为新的工作机会打好基础</li></ul><h2 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h2><ul><li>40篇以上博客总结，尽量一周一篇，放假休息，保持知识库一直更新</li><li>刷题不要求每周有贡献了，不切实际的FLAG没有意义，希望每月有贡献吧</li><li>采取提问回答方式补充技能树，利用好别人总结好的知识，很多知识点没必要从头开始</li><li>阅读开源代码解决实际问题，今年想尝试的知识点有【帧同步】和【共享内存】</li><li>继续保持读书的习惯，今年的图书已经到位，类型多是历史、传记和小说</li></ul><p><img src="https://img-blog.csdnimg.cn/direct/453197020ff14f48b865f2a23e884d61.png#pic_center" alt="2023book"></p><h2 id="投资"><a href="#投资" class="headerlink" title="投资"></a>投资</h2><ul><li>垃圾票适时出清</li><li>保持定投和智能条件单策略，重点放在科技和医药赛道，光伏赛道等待产能出清，持续观望</li><li>环境很差，但依旧相信国运，考虑今年的进入低位，2024年目标正收益15个点（可得说清楚，避免调剂）</li></ul><h2 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h2><ul><li>假期回家时间不低于去年的21天</li><li>想跑跑步，目前仅停留在脑海里，每周末下楼去转转</li><li>养养花，新年不打算买新的花了，好好把目前的多肉养出状态</li><li>周末陪陪家人，希望不要被家里的神仙宝贝娃娃气炸</li></ul><p><img src="https://img-blog.csdnimg.cn/direct/aa6573e7bb8b455eb5cf55b441e9f0b0.png#pic_center" alt="在2023home"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>2023年作为魔幻的一年，本来被给予了美好的希望，没想到放开之后，情况变得越发糟糕，打破了人们的预期，报复性的反弹没有如约而至，很多事情在封闭期间没有发生，却在这个寒冷的冬天尝了个遍，HR在得知自己毕业消息后，需要在临行前通知其他小伙伴毕业，主管实在不想开人，最终不得不自己离开，这些事情听起来很新奇，却在这个寒冬中显得那么的习以为常。</p><p>最近看了一些书籍和记录片，已经渐渐的体会到，做人不能太明白，有时糊里糊涂的反而更幸福，如果作为一个明白人还能收放自如的糊里糊涂，那便是境界升华了。</p><p>你还相信光吗？<strong>我依旧相信</strong>！<strong><em>虽然深处寒冬，我心依旧向往光明</em></strong>，信仰的力量支撑着我们前进，不管现在的真实情况是向上还是向下，我相信总有一天会向上突破的，期待这一天早点到来~</p><p><img src="https://img-blog.csdnimg.cn/direct/d22fca83d9324df8bc6ddd91ec70a75f.png#pic_center" alt="2023life"></p><hr><center><a href="https://blog.csdn.net/albertsh/article/details/135161723" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>旧年伊始志气豪，万物焕新气宇高。<br>谁料寒冬多磨难，心怀光明盼春晓。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;不断追求利益的经济冲动，不停侵蚀人们的生活，压垮、吞噬并统治生活本身，无法言喻的不安和看不到明天的混沌感，让我们在现有社会经济条件下，沦为被金钱和物质所统治的行尸走肉~&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;最近在看一本叫《饱食穷民》的书，讲述的是泡沫经济年代的日本社会，宛如梦幻泡影一样变化无常，又像断梗浮萍一样飘忽不定，到处充斥着不安的色彩，我试图从中寻找一些当前现实问题的解决方案，上段文字也是出自此书之中，阅读之后我大受震撼，其中描述的有关软件工程师的篇章，简直就是我的复刻版，无论是心境、情感、还是所面临的问题都如出一辙，读完觉得背后隐隐发凉，因为最终那些令人无法接受的结局，确实是我不想看到的。&lt;/p&gt;
    
    </summary>
    
      <category term="Thinking" scheme="http://AlbertGithubHome.github.io/blog/categories/Thinking/"/>
    
    
      <category term="总结" scheme="http://AlbertGithubHome.github.io/blog/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="工作" scheme="http://AlbertGithubHome.github.io/blog/tags/%E5%B7%A5%E4%BD%9C/"/>
    
      <category term="学习" scheme="http://AlbertGithubHome.github.io/blog/tags/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="生活，投资" scheme="http://AlbertGithubHome.github.io/blog/tags/%E7%94%9F%E6%B4%BB%EF%BC%8C%E6%8A%95%E8%B5%84/"/>
    
  </entry>
  
  <entry>
    <title>Linux环境下通过journal命令查看和管理日志</title>
    <link href="http://AlbertGithubHome.github.io/blog/2023/12/22/Linux%E7%8E%AF%E5%A2%83%E4%B8%8B%E9%80%9A%E8%BF%87journal%E5%91%BD%E4%BB%A4%E6%9F%A5%E7%9C%8B%E5%92%8C%E7%AE%A1%E7%90%86%E6%97%A5%E5%BF%97/"/>
    <id>http://AlbertGithubHome.github.io/blog/2023/12/22/Linux环境下通过journal命令查看和管理日志/</id>
    <published>2023-12-22T14:03:50.000Z</published>
    <updated>2024-01-14T11:45:50.130Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>就在半月之前，负责打包更新的服务器突然登录不上去了，赶紧找来运维的同事帮忙解决，发现系统日志中有很多 <code>systemd-journald[424]: Failed to open runtime journal: No space left on device</code> 字样的错误，被告知磁盘满了需要清理，但是我当时登录不上去，只能让他们帮忙重启后利用单用户模式上去删除临时文件试试，但重启后发现问题解决了，很是诧异，查询服务器后台监控平台，发现磁盘空间还有50%，inode只占用了0.02%，这怎么会磁盘满了呢？</p><a id="more"></a><h1 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h1><p>后来经过分析，应该是journal默认将系统日志存储在/run/log/journal目录中，而 <code>/run</code>是一个临时文件系统，通常挂载在内存中，用于存储运行时产生的临时文件，如进程 ID 文件、锁文件等，如果登录所需的文件或进程受到 <code>/run</code> 空间不足的影响，可能会导致登录问题。例如，如果 <code>sshd</code> 进程的运行所需的文件被存储在 <code>/run</code> 中并且空间不足，那么可能无法正常登录。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ df -h</span><br><span class="line">Filesystem      Size  Used Avail Use% Mounted on</span><br><span class="line">devtmpfs        7.8G     0  7.8G   0% /dev</span><br><span class="line">tmpfs           7.8G  868K  7.8G   1% /run</span><br></pre></td></tr></table></figure><p>所以系统重启后，这个空间释放了也就能通过ssh登录了，并且重启后journal日志清空也证实了这一点。</p><p>关于这个空间限制多数说的是10%，但是如果真是的所处分区的10%，那么不会导致我登录不上的，所以我倾向于是系统内存10%或者硬盘最大10%，默认最大限制4G，具体限制等我有空时查查文档吧，先贴一段看起来很靠谱的描述</p><blockquote><p>SystemMaxUse=, SystemKeepFree=, SystemMaxFileSize=, SystemMaxFiles=, RuntimeMaxUse=, RuntimeKeepFree=, RuntimeMaxFileSize=, RuntimeMaxFiles=<br>限制日志文件的 大小上限。 以 “System” 开头的选项用于限制磁盘使用量， 也就是 /var/log/journal 的使用量。 以 “Runtime” 开头的选项用于限制内存使用量， 也就是 /run/log/journal 的使用量。 以 “System” 开头的选项仅在 /var/log/journal 目录确实存在且可写时才有意义。 但以 “Runtime” 开头的选项永远有意义。 也就是说， 在系统启动早期 /var 尚未挂载时、 或者系统管理员禁止在磁盘上存储日志的时候， 仅有 “Runtime” 开头的选项有意义。 journalctl 与 systemd-journald 工具会忽略日志目录中 所有后缀名不等于 “.journal” 或 “.journal~” 的文件。 换句话说，日志目录中不应该存在后缀名不等于 “.journal” 或 “.journal~” 的文件， 因为这些文件 永远不会被清理。</p><p>SystemMaxUse= 与 RuntimeMaxUse= 限制全部日志文件加在一起最多可以占用多少空间。 SystemKeepFree= 与 RuntimeKeepFree= 表示除日志文件之外，至少保留多少空间给其他用途。 systemd-journald 会同时考虑这两个因素， 并且尽量限制日志文件的总大小，以同时满足这两个限制。</p><p>SystemMaxUse= 与 RuntimeMaxUse= 的默认值是10%空间与4G空间两者中的较小者； SystemKeepFree= 与 RuntimeKeepFree= 的默认值是15%空间与4G空间两者中的较大者； 如果在 systemd-journald 启动时，文件系统即将被填满并且已经超越了 SystemKeepFree= 或 RuntimeKeepFree= 的限制，那么日志记录将被暂停。 也就是说，如果在创建日志文件时，文件系统有充足的空闲空间， 但是后来文件系统被其他非日志文件过多占用， 那么 systemd-journald 只会立即暂停日志记录， 但不会删除已经存在的日志文件。 注意，只会删除已归档的日志文件以释放空间。 也就是说，即使在完成日志清理之后， 日志所占用的空间仍然可能大于 SystemMaxUse= 或 RuntimeMaxUse= 的限制。</p><p>SystemMaxFileSize= 与 RuntimeMaxFileSize= 限制单个日志文件的最大体积， 到达此限制后日志文件将会自动滚动。 默认值是对应的 SystemMaxUse= 与 RuntimeMaxUse= 值的1/8 ， 这也意味着日志滚动 默认保留7个历史文件。</p><p>日志大小 可以使用以1024为基数的 K, M, G, T, P, E 后缀， 分别对应于 1024, 1024², … 字节。</p><p>SystemMaxFiles= 与 RuntimeMaxFiles= 限制最多允许同时存在多少个日志文件， 超出此限制后， 最老的日志文件将被删除， 而当前的活动日志文件 则不受影响。 默认值为100个。</p></blockquote><p>以上描述来自 <a href="https://www.jinbuguo.com/systemd/journald.conf.html" target="_blank" rel="noopener">《journald.conf 中文手册》</a>，另外 <a href="https://www.cnblogs.com/morgan363/p/13957565.html" target="_blank" rel="noopener">《Systemd日志管理服务：Journald以及重要配置选项》</a> 这篇博文也提到了默认日志数据将仅存储在内存中，在系统关闭时会删除该数据。</p><h1 id="journal-和-syslog-对比"><a href="#journal-和-syslog-对比" class="headerlink" title="journal 和 syslog 对比"></a>journal 和 syslog 对比</h1><p>提到系统日志除了journal比较常见以外，还有 syslog 也是比较基础的服务，两者都是日志服务，并且在系统中合理分工，相互配合，它们服务于不同的目标并且具有不同的特性。syslog是Linux系统的一套日志框架，它既可以记录日志到本地文件，也可以通过网络发送到接收syslog的服务器，以实现对多个设备的syslog消息进行统一的存储或解析。而journal是改进型的日志管理服务，主要收集来自内核、系统早期的启动阶段的日志以及系统守护进程在启动和运行中的标准输出和错误。</p><p>在CentOS 7及更高版本中，journalctl成为了查看和管理系统日志的主要工具，它从/var/log/journal/和/run/log/journal/等路径获取日志信息。同时，systemd-journald会将日志信息写入到socket文件/run/systemd/journal/syslog中，然后由rsyslog服务监听这个socket文件，从而实现对日志的统一管理和处理。因此，可以说syslog和journalctl在日志管理中各司其职，共同保障了Linux系统日志的完整性和可用性。</p><p>以上提到了一些名词，先说明一下来清楚其中的关系，journal日志使用journalctl工具管理，依赖<code>systemd-journald</code>服务，syslog日志可以用文本工具来查看，view、more、cat等命令都可以用，也可以借助其他工具查看特定信息，比如用dmesg命令查看syslog中内核相关日志，syslog依赖的服务名通常是 <code>rsyslogd</code></p><p><code>journalctl</code> 和 <code>syslog</code> 都是 Linux 系统中用于处理和查看系统日志的工具，我们从以下几个方面来对比下两者的区别：</p><ul><li><p><strong>存储方式：</strong></p><ul><li><code>syslog</code> 使用文本文件来存储日志信息，可以通过文本编辑器查看，通常存储在 <code>/var/log/syslog</code> 或 <code>/var/log/message</code></li><li><code>journalctl</code> 使用 <code>systemd-journald</code> 服务来存储二进制格式的日志文件。通常存储在 <code>/run/log/journal/</code> 或 <code>/var/log/journal/</code></li></ul></li><li><p><strong>日志内容：</strong></p><ul><li><code>syslog</code> 使用文本格式，记录在文本文件中。日志信息包含时间戳、主机名、应用程序名等</li><li><code>journalctl</code> 使用二进制格式，可以存储更多的元数据，例如进程 ID、用户 ID、SELinux 上下文等。这使得日志更加结构化，支持更高级的查询和过滤</li></ul></li><li><p><strong>查询和过滤：</strong></p><ul><li><code>syslog</code> 的查询和过滤通常使用命令行工具（例如 <code>grep</code>）或者专用的工具（例如 <code>logrotate</code>）</li><li><code>journalctl</code> 提供了更丰富和强大的查询和过滤功能，可以按时间、服务单元、日志级别等多个条件进行过滤。这使得查找和分析特定事件更加方便</li></ul></li><li><p><strong>实时查看：</strong></p><ul><li><code>syslog</code> 通常使用 <code>tail</code> 命令实时查看日志文件的末尾</li><li><code>journalctl</code> 可以使用 <code>-f</code> 或 <code>--follow</code> 选项来实时查看最新的日志</li></ul></li><li><p><strong>服务和依赖关系：</strong></p><ul><li><code>syslog</code> 是一个通用的日志服务，可以由多个日志守护进程（如 <code>rsyslog</code>、<code>syslog-ng</code>）实现</li><li><code>journalctl</code> 是 <code>systemd</code> 系统中的一部分，依赖于 <code>systemd-journald</code> 服务</li></ul></li><li><p><strong>配置文件的路径：</strong></p><ul><li><code>syslog</code> 的配置文件在 <code>/etc/rsyslog.conf</code></li><li><code>journalctl</code> 的配置文件在 <code>/etc/systemd/journald.conf</code></li></ul></li></ul><p>总体而言，<code>journalctl</code> 是 <code>systemd</code> 系统的一部分，提供了更现代化、结构化和强大的日志管理功能，但这并不意味着 <code>syslog</code> 是过时的。在一些系统中，两者可能同时存在，而且一些工具和服务可能仍然使用传统的 <code>syslog</code>。选择使用哪一个取决于系统的需求和管理员的偏好。</p><p>下面分别展示一下<code>systemd-journald</code> 和 <code>rsyslogd</code> 两个服务查询信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[root@demo ~]<span class="comment"># systemctl status systemd-journald</span></span><br><span class="line">● systemd-journald.service - Journal Service</span><br><span class="line">   Loaded: loaded (/usr/lib/systemd/system/systemd-journald.service; static; vendor preset: disabled)</span><br><span class="line">   Active: active (running) since Mon 2023-12-04 20:26:34 CST; 2 weeks 3 days ago</span><br><span class="line">     Docs: man:systemd-journald.service(8)</span><br><span class="line">           man:journald.conf(5)</span><br><span class="line"> Main PID: 7099 (systemd-journal)</span><br><span class="line">   Status: <span class="string">"Processing requests..."</span></span><br><span class="line">   CGroup: /system.slice/systemd-journald.service</span><br><span class="line">           └─7099 /usr/lib/systemd/systemd-journald</span><br><span class="line"></span><br><span class="line">Dec 04 20:26:34 demo systemd-journal[7099]: Permanent journal is using 8.0M (max allowed 4.0G, trying to leave 4.0G free of 183.5G available → c…imit 4.0G).</span><br><span class="line">Dec 04 20:26:34 demo systemd-journal[7099]: Time spent on flushing to /var is 21.108ms <span class="keyword">for</span> 1873 entries.</span><br><span class="line">Dec 04 20:26:34 demo systemd-journal[7099]: Journal started</span><br><span class="line">Hint: Some lines were ellipsized, use -l to show <span class="keyword">in</span> full.</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[root@demo ~]<span class="comment"># systemctl status rsyslogd</span></span><br><span class="line">Unit rsyslogd.service could not be found.</span><br><span class="line">[root@demo ~]<span class="comment"># systemctl status rsyslog</span></span><br><span class="line">● rsyslog.service - System Logging Service</span><br><span class="line">   Loaded: loaded (/usr/lib/systemd/system/rsyslog.service; enabled; vendor preset: enabled)</span><br><span class="line">   Active: active (running) since Mon 2023-12-04 19:46:04 CST; 2 weeks 3 days ago</span><br><span class="line">     Docs: man:rsyslogd(8)</span><br><span class="line">           http://www.rsyslog.com/doc/</span><br><span class="line"> Main PID: 913 (rsyslogd)</span><br><span class="line">   CGroup: /system.slice/rsyslog.service</span><br><span class="line">           └─913 /usr/sbin/rsyslogd -n</span><br><span class="line"></span><br><span class="line">Dec 04 19:46:04 demo systemd[1]: Starting System Logging Service...</span><br><span class="line">Dec 04 19:46:04 demo rsyslogd[913]:  [origin software=<span class="string">"rsyslogd"</span> swVersion=<span class="string">"8.24.0-57.el7_9.3"</span> x-pid=<span class="string">"913"</span> x-info=<span class="string">"http://www.rsyslog.com"</span>] start</span><br><span class="line">Dec 04 19:46:04 demo systemd[1]: Started System Logging Service.</span><br><span class="line">Dec 04 20:26:34 demo rsyslogd[913]: imjournal: journal reloaded... [v8.24.0-57.el7_9.3 try http://www.rsyslog.com/e/0 ]</span><br><span class="line">Dec 10 03:22:01 demo rsyslogd[913]:  [origin software=<span class="string">"rsyslogd"</span> swVersion=<span class="string">"8.24.0-57.el7_9.3"</span> x-pid=<span class="string">"913"</span> x-info=<span class="string">"http://www.rsyslog.com"</span>] rsys...was HUPed</span><br><span class="line">Dec 15 01:35:01 demo rsyslogd[913]: imjournal: journal reloaded... [v8.24.0-57.el7_9.3 try http://www.rsyslog.com/e/0 ]</span><br><span class="line">Dec 17 03:07:01 demo rsyslogd[913]:  [origin software=<span class="string">"rsyslogd"</span> swVersion=<span class="string">"8.24.0-57.el7_9.3"</span> x-pid=<span class="string">"913"</span> x-info=<span class="string">"http://www.rsyslog.com"</span>] rsys...was HUPed</span><br><span class="line">Hint: Some lines were ellipsized, use -l to show <span class="keyword">in</span> full.</span><br></pre></td></tr></table></figure><h1 id="journal-和-syslog-配置"><a href="#journal-和-syslog-配置" class="headerlink" title="journal 和 syslog 配置"></a>journal 和 syslog 配置</h1><p>两个服务的配置文件都有很多内容，在此只展示其中部分重要的参数，先看一下 <code>/etc/systemd/journald.conf</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[Journal]</span><br><span class="line">Storage=persistent              <span class="comment">#开启持久化存储</span></span><br><span class="line"><span class="comment">#Compress=yes                   #开启压缩功能</span></span><br><span class="line"><span class="comment">#Seal=yes</span></span><br><span class="line">SystemMaxUse=40%                <span class="comment">#设置系统最大占用率为40%</span></span><br><span class="line">StorageOption=size              <span class="comment">#设置存储选项为按大小进行存储</span></span><br><span class="line">StorageOption=autorotate        <span class="comment">#设置存储选项为自动轮换</span></span><br><span class="line">StoragePath=/<span class="built_in">export</span>/<span class="built_in">log</span>/journal <span class="comment">#设置日志文件的存储路径</span></span><br></pre></td></tr></table></figure><p>再看一下 <code>/etc/rsyslog.conf</code> 配置文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Include all config files in /etc/rsyslog.d/</span></span><br><span class="line"><span class="variable">$IncludeConfig</span> /etc/rsyslog.d/*.conf <span class="comment">#将包含 `/etc/rsyslog.d/` 目录下的所有以 `.conf` 结尾的配置文件，可以将配置分散到多个文件使得管理更加灵活</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Turn off message reception via local log socket;</span></span><br><span class="line"><span class="comment"># local messages are retrieved through imjournal now.</span></span><br><span class="line"><span class="variable">$OmitLocalLogging</span> on <span class="comment">#不再通过本地日志套接字接收消息，本地消息现在通过 `imjournal`（Journal 日志服务）来检索</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#### RULES ####</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Log all kernel messages to the console.</span></span><br><span class="line"><span class="comment"># Logging much else clutters up the screen.</span></span><br><span class="line"><span class="comment">#kern.*                                                 /dev/console</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Log anything (except mail) of level info or higher.</span></span><br><span class="line"><span class="comment"># Don't log private authentication messages!</span></span><br><span class="line">*.info;mail.none;authpriv.none;cron.none                /var/<span class="built_in">log</span>/messages <span class="comment">#将所有信息级别（info）以及除了邮件、认证、和 cron 之外的其他日志，都记录到 `/var/log/messages` 文件中</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The authpriv file has restricted access.</span></span><br><span class="line">authpriv.*                                              /var/<span class="built_in">log</span>/secure <span class="comment">#将所有 authpriv（私密认证）级别的日志记录到 `/var/log/secure` 文件中</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Log all the mail messages in one place.</span></span><br><span class="line">mail.*                                                  -/var/<span class="built_in">log</span>/maillog <span class="comment">#将所有邮件相关的日志记录到 `/var/log/maillog` 文件中</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Log cron stuff</span></span><br><span class="line">cron.*                                                  /var/<span class="built_in">log</span>/cron <span class="comment">#将所有 cron 服务相关的日志记录到 `/var/log/cron` 文件中</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Everybody gets emergency messages</span></span><br><span class="line">*.emerg                                                 :omusrmsg:*     <span class="comment">#将所有紧急级别（emergency）的日志消息发送到用户消息队列</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Save news errors of level crit and higher in a special file.</span></span><br><span class="line">uucp,news.crit                                          /var/<span class="built_in">log</span>/spooler <span class="comment">#将所有 uucp 和 news 的 crit 级别及更高级别的日志记录到 `/var/log/spooler` 文件中</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Save boot messages also to boot.log</span></span><br><span class="line">local7.*                                                /var/<span class="built_in">log</span>/boot.log <span class="comment">#表示保存启动消息到boot.log文件中</span></span><br></pre></td></tr></table></figure><h1 id="使用journalctl查看和管理日志"><a href="#使用journalctl查看和管理日志" class="headerlink" title="使用journalctl查看和管理日志"></a>使用journalctl查看和管理日志</h1><h2 id="查看日志"><a href="#查看日志" class="headerlink" title="查看日志"></a>查看日志</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看所有日志（默认情况下只保存本次启动的日志）</span></span><br><span class="line">$ sudo journalctl</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示尾部指定行数的日志，默认10行</span></span><br><span class="line">$ sudo journalctl -n 20</span><br><span class="line"></span><br><span class="line"><span class="comment"># 实时滚动显示最新日志</span></span><br><span class="line">$ sudo journalctl -f</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看指定时间的日志</span></span><br><span class="line">$ sudo journalctl --since yesterday</span><br><span class="line">$ sudo journalctl --since=<span class="string">"2023-12-22 16:52:18"</span></span><br><span class="line">$ sudo journalctl --since <span class="string">"30 min ago"</span></span><br><span class="line">$ sudo journalctl --since <span class="string">"2023-12-22 16:52:18"</span> --until <span class="string">"2023-12-22 23:52:18"</span></span><br><span class="line">$ sudo journalctl --since 09:00 --until <span class="string">"1 hour ago"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看内核日志，过滤掉应用日志</span></span><br><span class="line">$ sudo journalctl -k</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看系统本次启动的日志</span></span><br><span class="line">$ sudo journalctl -b</span><br><span class="line">$ sudo journalctl -b -0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看上一次启动的日志</span></span><br><span class="line">$ sudo journalctl -b -1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看指定优先级及其以上级别的日志，共有8级 0: emerg 1: alert 2: crit 3: err 4: warning 5: notice 6: info 7: debug</span></span><br><span class="line"><span class="comment"># -b 不加任何参数时，表示显示当前引导周期的日志。这意味着只显示自最近一次启动以来的日志。</span></span><br><span class="line"><span class="comment"># -b N： N 是一个整数，表示要显示第 N 个引导周期的日志。例如，-b 0 表示显示最新的引导周期，-b 1 表示显示上一个引导周期，以此类推</span></span><br><span class="line">$ sudo journalctl -p err -b</span><br><span class="line"></span><br><span class="line"><span class="comment"># 日志默认分页输出，--no-pager 改为正常的标准输出</span></span><br><span class="line">$ sudo journalctl --no-pager</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以单行 JSON 格式输出</span></span><br><span class="line">$ sudo journalctl -b -u nginx.service -o json</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以多行 JSON 可读性更好的格式输出</span></span><br><span class="line">$ sudo journalctl -b -u nginx.service  -o json-pretty</span><br></pre></td></tr></table></figure><h2 id="查看指定服务日志"><a href="#查看指定服务日志" class="headerlink" title="查看指定服务日志"></a>查看指定服务日志</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 查看指定服务的日志</span></span><br><span class="line">$ sudo journalctl /usr/sbin/sshd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看指定进程的日志</span></span><br><span class="line">$ sudo journalctl _PID=1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看某个路径的脚本的日志</span></span><br><span class="line">$ sudo journalctl /bin/bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看指定用户的日志</span></span><br><span class="line">$ sudo journalctl _UID=1000 --since today</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看某个 Unit 的日志</span></span><br><span class="line"><span class="comment"># 单元（unit）通常是 systemd 服务的一个抽象，用于表示系统中正在运行的各种服务或任务</span></span><br><span class="line">$ sudo journalctl -u nginx.service</span><br><span class="line">$ sudo journalctl -u nginx.service --since today</span><br><span class="line"></span><br><span class="line"><span class="comment"># 合并显示多个 Unit 的日志</span></span><br><span class="line">$ journalctl -u nginx.service -u ssh.service --since today</span><br></pre></td></tr></table></figure><h2 id="查看调整存储"><a href="#查看调整存储" class="headerlink" title="查看调整存储"></a>查看调整存储</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 显示日志占据的硬盘空间</span></span><br><span class="line">$ sudo journalctl --disk-usage</span><br><span class="line"></span><br><span class="line"><span class="comment"># 仅保留500MB大小的日志文减</span></span><br><span class="line">$ sudo journalctl --vacuum-size=500M</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定日志文件保存多久</span></span><br><span class="line">$ sudo journalctl --vacuum-time=1years</span><br><span class="line"></span><br><span class="line"><span class="comment"># 仅保留最近一个月的日志文件</span></span><br><span class="line">$ sudo journalctl --vacuum-time=1m</span><br><span class="line"></span><br><span class="line"><span class="comment"># 仅保留最近2天的日志文件</span></span><br><span class="line">$ sudo journalctl --vacuum-time=2d</span><br></pre></td></tr></table></figure><h1 id="回到文章开头的问题"><a href="#回到文章开头的问题" class="headerlink" title="回到文章开头的问题"></a>回到文章开头的问题</h1><p>通过梳理知识，我发现通过 <code>systemctl</code> 命令查询 <code>systemd-journald</code> 服务状态可以看到日志存储路径和存储限制，分别展示一下，先看存储到内存的：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">root@demo1:~<span class="comment"># systemctl status systemd-journald</span></span><br><span class="line">● systemd-journald.service - Journal Service</span><br><span class="line">   Loaded: loaded (/lib/systemd/system/systemd-journald.service; static; vendor preset: enabled)</span><br><span class="line">   Active: active (running) since Fri 2023-12-22 10:25:43 CST; 10h ago</span><br><span class="line">     Docs: man:systemd-journald.service(8)</span><br><span class="line">           man:journald.conf(5)</span><br><span class="line"> Main PID: 1132 (systemd-journal)</span><br><span class="line">   Status: <span class="string">"Processing requests..."</span></span><br><span class="line">    Tasks: 1</span><br><span class="line">   Memory: 272.0K</span><br><span class="line">      CPU: 204ms</span><br><span class="line">   CGroup: /system.slice/systemd-journald.service</span><br><span class="line">           └─1132 /lib/systemd/systemd-journald</span><br><span class="line"></span><br><span class="line">Dec 22 10:25:43 demo1 systemd-journald[1132]: Runtime journal (/run/<span class="built_in">log</span>/journal/) is 8.0M, max 159.9M, 151.9M free.</span><br><span class="line">Dec 22 10:25:43 demo1 systemd-journald[1132]: Journal started</span><br><span class="line">root@demo1:~<span class="comment"># df -h</span></span><br><span class="line">Filesystem      Size  Used Avail Use% Mounted on</span><br><span class="line">udev            7.8G     0  7.8G   0% /dev</span><br><span class="line">tmpfs           1.6G  9.3M  1.6G   1% /run</span><br><span class="line">/dev/sda1        83G   29G   51G  36% /</span><br><span class="line">tmpfs           7.9G     0  7.9G   0% /dev/shm</span><br><span class="line">tmpfs           5.0M     0  5.0M   0% /run/lock</span><br><span class="line">tmpfs           7.9G     0  7.9G   0% /sys/fs/cgroup</span><br><span class="line">/dev/sdb       1017G  903G  115G  89% /<span class="built_in">export</span></span><br><span class="line">tmpfs           1.6G     0  1.6G   0% /run/user/111</span><br><span class="line">tmpfs           1.6G     0  1.6G   0% /run/user/1001</span><br></pre></td></tr></table></figure><p>默认存储到 /run/log/journal/中，分区一共1.6G，最大max 159.9M，当前用了 8.0M，按这个来推算果然限制是10%，再看看持久化的情况</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">root@jenkins2004:~<span class="comment"># systemctl status systemd-journald</span></span><br><span class="line">● systemd-journald.service - Journal Service</span><br><span class="line">     Loaded: loaded (/lib/systemd/system/systemd-journald.service; static; vendor preset: enabled)</span><br><span class="line">     Active: active (running) since Sun 2023-08-27 09:24:15 CST; 3 months 26 days ago</span><br><span class="line">TriggeredBy: ● systemd-journald-dev-log.socket</span><br><span class="line">             ● systemd-journald.socket</span><br><span class="line">             ● systemd-journald-audit.socket</span><br><span class="line">       Docs: man:systemd-journald.service(8)</span><br><span class="line">             man:journald.conf(5)</span><br><span class="line">   Main PID: 375 (systemd-journal)</span><br><span class="line">     Status: <span class="string">"Processing requests..."</span></span><br><span class="line">      Tasks: 1 (<span class="built_in">limit</span>: 19123)</span><br><span class="line">     Memory: 42.7M</span><br><span class="line">     CGroup: /system.slice/systemd-journald.service</span><br><span class="line">             └─375 /lib/systemd/systemd-journald</span><br><span class="line"></span><br><span class="line">8月 27 09:24:15 jenkins2004 systemd-journald[375]: Journal started</span><br><span class="line">8月 27 09:24:15 jenkins2004 systemd-journald[375]: Time spent on flushing to /var/<span class="built_in">log</span>/journal/cc9ad539032546a1bd39a773d37e415f is 613.827ms <span class="keyword">for</span> 1229 entries.</span><br><span class="line">8月 27 09:24:15 jenkins2004 systemd-journald[375]: System Journal (/var/<span class="built_in">log</span>/journal/cc9ad539032546a1bd39a773d37e415f) is 1.4G, max 4.0G, 2.5G free.</span><br><span class="line">8月 27 09:24:22 jenkins2004 systemd-journald[375]: Forwarding to syslog missed 1 messages.</span><br><span class="line">8月 27 09:24:53 jenkins2004 systemd-journald[375]: Forwarding to syslog missed 80 messages.</span><br><span class="line">Warning: journal has been rotated since unit was started, output may be incomplete.</span><br><span class="line">root@jenkins2004:~<span class="comment"># df -h | grep -v snap</span></span><br><span class="line">Filesystem      Size  Used Avail Use% Mounted on</span><br><span class="line">udev            7.8G     0  7.8G   0% /dev</span><br><span class="line">tmpfs           1.6G  1.6M  1.6G   1% /run</span><br><span class="line">/dev/sda5       590G  369G  191G  66% /</span><br><span class="line">tmpfs           7.9G     0  7.9G   0% /dev/shm</span><br><span class="line">tmpfs           5.0M     0  5.0M   0% /run/lock</span><br><span class="line">tmpfs           7.9G     0  7.9G   0% /sys/fs/cgroup</span><br><span class="line">/dev/sda1       511M  4.0K  511M   1% /boot/efi</span><br><span class="line">tmpfs           1.6G   36K  1.6G   1% /run/user/125</span><br><span class="line">tmpfs           1.6G  4.0K  1.6G   1% /run/user/1002</span><br></pre></td></tr></table></figure><p>看起来存到了 <code>var/log/journal</code>，最大可用空间居然到了4G，这样来分析这次的问题可能不是journal日志搞的鬼，而是很多进程吧/run目录写满了，导致journal写不进去报了开头的错误，进而引发的无法登录。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>syslog和journal在日志管理中各司其职，共同保障了Linux系统日志的完整性和可用性</li><li>journal默认将系统日志存储在/run/log/journal目录中，而 <code>/run</code> 通常挂载在内存中，当此目录被写满时可能导致ssh无法登录</li><li>将 <code>/etc/systemd/journald.conf</code> 配置中的 Storage 字段设置为 <code>persistent</code> 可以开启日志持久化</li><li><code>sudo journalctl -n 20</code> 可以显示显示尾部最新的20行日志，-n后不加参数默认10行</li><li><code>sudo journalctl -u nginx.service</code> 查看ssh服务器的日志</li><li><code>sudo journalctl --since=&quot;2023-12-22 16:52:18&quot;</code> 查看指定时间以后的日志</li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/135094892" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>寒意一波接着一波，总会有看见“光”的时候（30厘米的下跌，摔得可真疼）</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;就在半月之前，负责打包更新的服务器突然登录不上去了，赶紧找来运维的同事帮忙解决，发现系统日志中有很多 &lt;code&gt;systemd-journald[424]: Failed to open runtime journal: No space left on device&lt;/code&gt; 字样的错误，被告知磁盘满了需要清理，但是我当时登录不上去，只能让他们帮忙重启后利用单用户模式上去删除临时文件试试，但重启后发现问题解决了，很是诧异，查询服务器后台监控平台，发现磁盘空间还有50%，inode只占用了0.02%，这怎么会磁盘满了呢？&lt;/p&gt;
    
    </summary>
    
      <category term="linux" scheme="http://AlbertGithubHome.github.io/blog/categories/linux/"/>
    
    
      <category term="linux" scheme="http://AlbertGithubHome.github.io/blog/tags/linux/"/>
    
      <category term="运维" scheme="http://AlbertGithubHome.github.io/blog/tags/%E8%BF%90%E7%BB%B4/"/>
    
      <category term="服务器" scheme="http://AlbertGithubHome.github.io/blog/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
      <category term="journalctl" scheme="http://AlbertGithubHome.github.io/blog/tags/journalctl/"/>
    
      <category term="syslog" scheme="http://AlbertGithubHome.github.io/blog/tags/syslog/"/>
    
  </entry>
  
  <entry>
    <title>gitlab修改代码库的名称、路径和分组</title>
    <link href="http://AlbertGithubHome.github.io/blog/2023/12/19/gitlab%E4%BF%AE%E6%94%B9%E4%BB%A3%E7%A0%81%E5%BA%93%E7%9A%84%E5%90%8D%E7%A7%B0%E3%80%81%E8%B7%AF%E5%BE%84%E5%92%8C%E5%88%86%E7%BB%84/"/>
    <id>http://AlbertGithubHome.github.io/blog/2023/12/19/gitlab修改代码库的名称、路径和分组/</id>
    <published>2023-12-19T14:20:24.000Z</published>
    <updated>2023-12-19T16:13:09.824Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>工作项目的源码使用gitlab进行管理，通常情况下不会修改代码库和路径，但是非一般的情况总是存在，比如刚刚立项时多次调整项目名，甚至改变管理层级，所以还是有这类需求的，一开始我本打算将旧的代码库和提交记录推送到新的地址和分组，后来在gitlab后台里翻了翻，结合网络大神们的指点，发现可以直接修改代码库的名称和分组，总共需要修改3个配置，一起来看下。</p><a id="more"></a><h1 id="修改过程"><a href="#修改过程" class="headerlink" title="修改过程"></a>修改过程</h1><h2 id="具体需求"><a href="#具体需求" class="headerlink" title="具体需求"></a>具体需求</h2><p>假设需求是将项目名从 <code>A</code> 改为 <code>B</code>，同时将访问路径从 <code>git@gitlab.example.cn:APrject/AGroup/A.git</code> 改为 <code>git@gitlab.example.cn:APrject/AGroup/B.git</code>，这里一共有三处需要修改：项目名、访问路径、以及分组，下面依次列举出修改的方法：</p><h2 id="修改项目名"><a href="#修改项目名" class="headerlink" title="修改项目名"></a>修改项目名</h2><p>导航路径【Settings】-&gt;【General】-&gt;【Naming, topics, avatar】-&gt;【Project name】，只需填入新的项目名，点击 “Save changes” 按钮即可，页面展示如下：</p><p><img src="https://img-blog.csdnimg.cn/direct/9f3e4a5c908f479e918ee20fdb86e14c.png" alt="Project name"></p><h2 id="修改访问路径"><a href="#修改访问路径" class="headerlink" title="修改访问路径"></a>修改访问路径</h2><p>做完上一步只是修改了项目名字，如果使用 <code>git clone</code> 命令下载整个库，路径是没有发生变化的，修改访问路径需要调整 “Path”</p><p>导航路径【Settings】-&gt;【General】-&gt;【Advanced】-&gt;【Expand】-&gt;【Change path】，只能修改最后一段Path，其中不能再包含 <code>/</code>，修改后点击 “Change path” 即可，页面展示如下：</p><p><img src="https://img-blog.csdnimg.cn/direct/1568d9ff2cbf4dd0b82ca05e235371f9.png" alt="Change path1"></p><p><img src="https://img-blog.csdnimg.cn/direct/80006b8b2fb84ea1bc493a6668e2f960.png" alt="Change path2"></p><h2 id="修改分组"><a href="#修改分组" class="headerlink" title="修改分组"></a>修改分组</h2><p>上面修改路径这一步只允许修改Path的最后一段，不能直接调整分组路径，想要调整前面的路径需要调整分组</p><p>导航路径【Settings】-&gt;【General】-&gt;【Advanced】-&gt;【Expand】-&gt;【Transfer project】，这一步只能选择已有的分组，选择好目标分组，点击 “Transfer project” 按钮即可，页面展示如下：</p><p><img src="https://img-blog.csdnimg.cn/direct/20dac08bf02049bf9b6f4fcb8f00a637.png" alt="Transfer project"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>gitlab后台可以直接修改代码库的名称、路径和分组等信息，不必重新创建项目</li><li>在修改名称、路径和分组等信息后需要相关人员更新对原有代码库的引用，否则会找不到</li><li>使用 <code>git remote set-url origin &lt;new-url&gt;</code> 命令可以更新已有仓库的URL</li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/134981708" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>对未来的迷茫以及内心的不安，让我们在现有社会经济条件下，沦为被金钱和物质所统治的行尸走肉</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;工作项目的源码使用gitlab进行管理，通常情况下不会修改代码库和路径，但是非一般的情况总是存在，比如刚刚立项时多次调整项目名，甚至改变管理层级，所以还是有这类需求的，一开始我本打算将旧的代码库和提交记录推送到新的地址和分组，后来在gitlab后台里翻了翻，结合网络大神们的指点，发现可以直接修改代码库的名称和分组，总共需要修改3个配置，一起来看下。&lt;/p&gt;
    
    </summary>
    
      <category term="Git" scheme="http://AlbertGithubHome.github.io/blog/categories/Git/"/>
    
    
      <category term="git" scheme="http://AlbertGithubHome.github.io/blog/tags/git/"/>
    
      <category term="gitlab" scheme="http://AlbertGithubHome.github.io/blog/tags/gitlab/"/>
    
      <category term="修改项目名" scheme="http://AlbertGithubHome.github.io/blog/tags/%E4%BF%AE%E6%94%B9%E9%A1%B9%E7%9B%AE%E5%90%8D/"/>
    
      <category term="修改路径" scheme="http://AlbertGithubHome.github.io/blog/tags/%E4%BF%AE%E6%94%B9%E8%B7%AF%E5%BE%84/"/>
    
      <category term="修改分组" scheme="http://AlbertGithubHome.github.io/blog/tags/%E4%BF%AE%E6%94%B9%E5%88%86%E7%BB%84/"/>
    
      <category term="后台管理" scheme="http://AlbertGithubHome.github.io/blog/tags/%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>利用websockify将websocket通信转换成tcp</title>
    <link href="http://AlbertGithubHome.github.io/blog/2023/12/13/%E5%88%A9%E7%94%A8websockify%E5%B0%86websocket%E9%80%9A%E4%BF%A1%E8%BD%AC%E6%8D%A2%E6%88%90tcp/"/>
    <id>http://AlbertGithubHome.github.io/blog/2023/12/13/利用websockify将websocket通信转换成tcp/</id>
    <published>2023-12-13T14:30:05.000Z</published>
    <updated>2023-12-19T16:11:09.636Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>目前遇到一个问题，原本的服务都是利用tcp通信的，但是某些平台只支持websocket，是不是要从头实现一套websocket网络收发逻辑呢？短时间内有没有替代方案呢？在经过一番寻找之后发现了websockify这个神器，可以将websocket协议转换成tcp协议，从而实现不修改应用服务就支持tcp协议的目的，接下来就说说它怎么用，以及探索的过程。</p><a id="more"></a><h1 id="websockify"><a href="#websockify" class="headerlink" title="websockify"></a>websockify</h1><h2 id="websockify-介绍"><a href="#websockify-介绍" class="headerlink" title="websockify 介绍"></a>websockify 介绍</h2><p><a href="https://github.com/novnc/websockify/tree/master" target="_blank" rel="noopener">websockify</a> 是一个用于将 WebSocket 流量转发到其他协议的工具，它的主要用途之一是将 WebSockets 转发到基于 TCP 的协议，例如 VNC（Virtual Network Computing），以下是它的一些关键特点和用途：</p><ul><li><p><strong>WebSocket 转发：</strong> <code>websockify</code> 允许你将 WebSocket 流量转发到其他类型的网络服务，使得你可以通过 WebSocket 连接访问这些服务。</p></li><li><p><strong>VNC 转发：</strong> <code>websockify</code> 最常用于将 WebSocket 转发到 VNC 服务器。这使得你可以通过 Web 浏览器访问运行 VNC 服务的远程计算机的桌面。</p></li><li><p><strong>安全性：</strong> <code>websockify</code> 支持加密通信，因此可以在安全连接上运行，提供更好的数据保护。</p></li><li><p><strong>协议适配：</strong> <code>websockify</code> 提供了一个通用的桥接机制，允许你将 WebSocket 连接转发到支持其他协议的服务，而不仅仅是 VNC。</p></li><li><p><strong>JavaScript 客户端：</strong> <code>websockify</code> 还包括一个 JavaScript 客户端库，可以直接在浏览器中使用，无需额外的插件。</p></li></ul><p>使用 websockify 的典型场景包括在 Web 浏览器中访问远程计算机的桌面，或者通过 WebSocket 连接到其他需要 TCP 连接的服务，在实际应用中，你可以通过命令行使用 websockify，也可以将其嵌入到其他应用程序中。</p><h2 id="websockify-使用"><a href="#websockify-使用" class="headerlink" title="websockify 使用"></a>websockify 使用</h2><p>在Ubuntu系统下可以直接使用以下安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt install websockify</span><br></pre></td></tr></table></figure><p>下面是一个使用示例，作用是将原本连接到8765的websocket请求转换成tcp请求，TCP端口4321</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ websockify 8765 127.0.0.1:12346</span><br></pre></td></tr></table></figure><p>启动后原本仅支持TCP协议的服务就可以通过websockify实现对websocket的支持了</p><h1 id="探索的过程"><a href="#探索的过程" class="headerlink" title="探索的过程"></a>探索的过程</h1><p>虽然是短短的一条 <code>websockify 8765 127.0.0.1:12346</code> 命令就可以实现从websocket到tcp的转换，但是探索的过程却不顺利，在发现<code>websockify</code>这个神器之后，首先是测试它是否能满足我们的需求，是否好用，但是直接在原有的服务上测试太费时间，所以尝试写了几个模拟的脚本。</p><h2 id="提供基础TCP服务"><a href="#提供基础TCP服务" class="headerlink" title="提供基础TCP服务"></a>提供基础TCP服务</h2><p>最基本的我们需要一个很能提供TCP服务的程序，这里我使用python写了一个回显的服务器 echoserver.py，绑定本地的12346端口</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 创建一个TCP套接字</span></span><br><span class="line">    server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 绑定IP地址和端口</span></span><br><span class="line">    server_socket.bind((<span class="string">'127.0.0.1'</span>, <span class="number">12346</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 监听连接</span></span><br><span class="line">    server_socket.listen(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">    print(<span class="string">"服务器已启动，等待客户端连接..."</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        <span class="comment"># 接受客户端连接</span></span><br><span class="line">        client_socket, client_address = server_socket.accept()</span><br><span class="line">        print(<span class="string">f"客户端<span class="subst">&#123;client_address&#125;</span>已连接"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 接收客户端发送的数据</span></span><br><span class="line">        data = client_socket.recv(<span class="number">1024</span>)</span><br><span class="line">        print(<span class="string">f"收到来自<span class="subst">&#123;client_address&#125;</span>的数据： <span class="subst">&#123;data.decode(<span class="string">'utf-8'</span>)&#125;</span>"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 将接收到的数据发送回客户端</span></span><br><span class="line">        client_socket.send(data)</span><br><span class="line">        print(<span class="string">f"已将数据发送回<span class="subst">&#123;client_address&#125;</span>"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 关闭客户端套接字</span></span><br><span class="line">        client_socket.close()</span><br><span class="line">        print(<span class="string">f"客户端<span class="subst">&#123;client_address&#125;</span>已断开连接"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h3 id="测试可用"><a href="#测试可用" class="headerlink" title="测试可用"></a>测试可用</h3><ul><li>启动服务</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ python3 echoserver.py</span><br><span class="line">服务器已启动，等待客户端连接...</span><br></pre></td></tr></table></figure><ul><li>用nc命令发送tcp数据</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">"Hello server"</span> | nc 127.0.0.1 12346</span><br><span class="line">Hello server</span><br></pre></td></tr></table></figure><ul><li>TCP服务器看到的内容</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">服务器已启动，等待客户端连接...</span><br><span class="line">客户端(<span class="string">'127.0.0.1'</span>, 59214)已连接</span><br><span class="line">收到来自(<span class="string">'127.0.0.1'</span>, 59214)的数据： Hello server</span><br><span class="line"></span><br><span class="line">已将数据发送回(<span class="string">'127.0.0.1'</span>, 59214)</span><br><span class="line">客户端(<span class="string">'127.0.0.1'</span>, 59214)已断开连接</span><br></pre></td></tr></table></figure><p>TCP服务一切正常</p><h2 id="实现Websocket客户端"><a href="#实现Websocket客户端" class="headerlink" title="实现Websocket客户端"></a>实现Websocket客户端</h2><p>因为python的运行环境是现成的，所以我又用它写了一个websocket客户端 wsclient.py 来发送数据，想运行的话得安装几个包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python3 -m pip install websocket</span><br><span class="line">python3 -m pip install websocket-client</span><br></pre></td></tr></table></figure><blockquote><p>真实的情况下我是用websocket客户端连接nginx，然后将nginx转发到websockify监听端口，然后websockify将数据转成tcp连接应用服务，但是这个过程太复杂了，不利于说明问题，所以后面的内容我省掉nginx，假装它不存在，直接用websocket客户端连接websockify监听端口</p></blockquote><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># 运行websocket服务器</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> websocket</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_message</span><span class="params">(ws, message)</span>:</span></span><br><span class="line">    print(<span class="string">f"Received message: <span class="subst">&#123;message&#125;</span>"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_error</span><span class="params">(ws, error)</span>:</span></span><br><span class="line">    print(<span class="string">f"Error: <span class="subst">&#123;error&#125;</span>"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_close</span><span class="params">(ws, close_status_code, close_msg)</span>:</span></span><br><span class="line">    print(<span class="string">f"Connection closed with status code <span class="subst">&#123;close_status_code&#125;</span>"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_open</span><span class="params">(ws)</span>:</span></span><br><span class="line">    print(<span class="string">"Connection opened"</span>)</span><br><span class="line">    <span class="comment"># 在连接建立后发送一条消息</span></span><br><span class="line">    ws.send(<span class="string">"abcd"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="comment"># WebSocket 服务器地址</span></span><br><span class="line">    ws_url = <span class="string">"ws://10.10.49.172:8765"</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建 WebSocket 连接</span></span><br><span class="line">    ws = websocket.WebSocketApp(ws_url,</span><br><span class="line">                                on_message=on_message,</span><br><span class="line">                                on_error=on_error,</span><br><span class="line">                                on_close=on_close)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 设置连接建立时的回调函数</span></span><br><span class="line">    ws.on_open = on_open</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 启动 WebSocket 连接</span></span><br><span class="line">    ws.run_forever()</span><br></pre></td></tr></table></figure><p>为了websocket客户端的测试，我写了一个websocket服务器 wsserver.py 来接收数据，不过这不是一开始就测试了，而是在后面发现转换TCP失败查找原因，按流程分段测试时补充的脚本内容</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> websockets</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">echo</span><span class="params">(websocket, path)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">async</span> <span class="keyword">for</span> message <span class="keyword">in</span> websocket:</span><br><span class="line">            print(<span class="string">f"Received message: <span class="subst">&#123;message&#125;</span>"</span>)</span><br><span class="line">            <span class="keyword">await</span> websocket.send(message)</span><br><span class="line">    <span class="keyword">except</span> websockets.exceptions.ConnectionClosed:</span><br><span class="line">        print(<span class="string">"WebSocket connection closed"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    server = <span class="keyword">await</span> websockets.serve(echo, <span class="string">"0.0.0.0"</span>, <span class="number">12346</span>)</span><br><span class="line"></span><br><span class="line">    print(<span class="string">"WebSocket server is running..."</span>)</span><br><span class="line">    <span class="keyword">await</span> server.wait_closed()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    asyncio.run(main())</span><br></pre></td></tr></table></figure><p>测试结果websocket客户端发送的数据，websocket服务器可以正常收到。</p><h2 id="开始测试websockify功能"><a href="#开始测试websockify功能" class="headerlink" title="开始测试websockify功能"></a>开始测试websockify功能</h2><ul><li>启动tcp服务echoserver，监听12346端口</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ python3 echoserver.py</span><br><span class="line">服务器已启动，等待客户端连接...</span><br></pre></td></tr></table></figure><ul><li>启动tcp服务websockify，监听8765端口，转换到12346端口</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ websockify 8765 127.0.0.1:12346</span><br><span class="line">WebSocket server settings:</span><br><span class="line">  - Listen on :8765</span><br><span class="line">  - No SSL/TLS support (no cert file)</span><br><span class="line">  - proxying from :8765 to 127.0.0.1:12346</span><br></pre></td></tr></table></figure><ul><li>运行websocket客户端发送的数据</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ python3 ./wsclient.py</span><br><span class="line">Connection opened</span><br><span class="line">Connection closed with status code 1003</span><br></pre></td></tr></table></figure><p>报错了！！！</p><p>再看echoserver输出，虽然连接成功，但是收到的数据为空</p><blockquote><p>客户端(‘127.0.0.1’, 55032)已连接<br>收到来自(‘127.0.0.1’, 55032)的数据：<br>已将数据发送回(‘127.0.0.1’, 55032)<br>客户端(‘127.0.0.1’, 55032)已断开连接</p></blockquote><p>然后看下websockify输出，显示转发连接12346端口成功了，但是没有后续输出</p><blockquote><p>$ websockify 8765 127.0.0.1:12346<br>WebSocket server settings:</p><ul><li>Listen on :8765</li><li>No SSL/TLS support (no cert file)</li><li>proxying from :8765 to 127.0.0.1:12346<br>10.2.48.36 - - [13/Dec/2023 20:03:11] 10.2.48.36: Plain non-SSL (ws://) WebSocket connection<br>10.2.48.36 - - [13/Dec/2023 20:03:11] connecting to: 127.0.0.1:12346</li></ul></blockquote><p>定位问题吧，期间不断调整nginx配置，查看nginx和websockify日志，调整wsclient写法，调整echoserver写法，分步测试wsclient和echoserver功能都没发现问题，具体测试细节暂且不表，后来我发现可以修改websockify启动参数输出更详细的日志，测试过程如下</p><h3 id="再次启动websockify"><a href="#再次启动websockify" class="headerlink" title="再次启动websockify"></a>再次启动websockify</h3><p>启动websockify再次使用wsclient测试，输出了额外的信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$ websockify 8765 127.0.0.1:12346 --<span class="built_in">log</span>-file /tmp/ws.log -v --traffic</span><br><span class="line">WebSocket server settings:</span><br><span class="line">  - Listen on :8765</span><br><span class="line">  - No SSL/TLS support (no cert file)</span><br><span class="line">  - proxying from :8765 to 127.0.0.1:12346</span><br><span class="line">10.2.48.36: new handler Process</span><br><span class="line">10.2.48.36 - - [13/Dec/2023 20:13:42] <span class="string">"GET / HTTP/1.1"</span> 101 -</span><br><span class="line">10.2.48.36 - - [13/Dec/2023 20:13:42] 10.2.48.36: Plain non-SSL (ws://) WebSocket connection</span><br><span class="line">10.2.48.36 - - [13/Dec/2023 20:13:42] connecting to: 127.0.0.1:12346</span><br><span class="line"></span><br><span class="line">Traffic Legend:</span><br><span class="line">    &#125;  - Client receive</span><br><span class="line">    &#125;. - Client receive partial</span><br><span class="line">    &#123;  - Target receive</span><br><span class="line"></span><br><span class="line">    &gt;  - Target send</span><br><span class="line">    &gt;. - Target send partial</span><br><span class="line">    &lt;  - Client send</span><br><span class="line">    &lt;. - Client send partial</span><br><span class="line">&#125;.10.2.48.36 - - [13/Dec/2023 20:13:42] 127.0.0.1:12346: Client closed connection</span><br><span class="line">10.2.48.36 - - [13/Dec/2023 20:13:42] 127.0.0.1:12346: Closed target</span><br></pre></td></tr></table></figure><p>顺着结尾的两条日志 <code>Client closed connection</code>，我找到了这一篇问题 <a href="https://github.com/novnc/websockify/issues/365" target="_blank" rel="noopener"><br>websockify - Client disconnects immediately after connection #365</a> 结论说是websockify不支持发送文本了</p><blockquote><p>Hmm… Are you trying to send text over that socket? We dropped support for text frames in the big cleanup.</p><p>Could you print the code and reason from the close in your close handler?</p></blockquote><p>我一看我的wsclient.py可不就是发送的文本嘛，看来有救了，赶紧改成了发送bytes <code>ws.send(b&#39;\x01\x02\x03\x04&#39;)</code>，但错误依旧，尝试各种发送函数无果，我严重怀疑我的换个python的websockets包有问题，所以我用html写了一个wsclient.html：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>WebSocket Binary Data Example<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">        <span class="comment">// 替换为你的 WebSocket 服务器地址</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">const</span> socket = <span class="keyword">new</span> WebSocket(<span class="string">"ws://10.10.49.172:8765"</span>);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">        <span class="comment">// 监听连接打开事件</span></span></span><br><span class="line"><span class="javascript">        socket.addEventListener(<span class="string">"open"</span>, (event) =&gt; &#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">"WebSocket connection opened."</span>);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">            <span class="comment">// 构造二进制数据，这里使用一个简单的示例</span></span></span><br><span class="line"><span class="javascript">            <span class="keyword">const</span> binaryData = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>([<span class="number">49</span>, <span class="number">50</span>, <span class="number">51</span>, <span class="number">52</span>]);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">            <span class="comment">// 发送二进制数据</span></span></span><br><span class="line"><span class="undefined">            socket.send(binaryData);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">"Binary data sent successfully."</span>);</span></span><br><span class="line"><span class="undefined">        &#125;);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">        <span class="comment">// 监听接收消息事件</span></span></span><br><span class="line"><span class="javascript">        socket.addEventListener(<span class="string">"message"</span>, (event) =&gt; &#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">"Received message:"</span>, event.data);</span></span><br><span class="line"><span class="undefined">        &#125;);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">        <span class="comment">// 监听连接关闭事件</span></span></span><br><span class="line"><span class="javascript">        socket.addEventListener(<span class="string">"close"</span>, (event) =&gt; &#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">"WebSocket connection closed."</span>);</span></span><br><span class="line"><span class="undefined">        &#125;);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">        <span class="comment">// 监听错误事件</span></span></span><br><span class="line"><span class="javascript">        socket.addEventListener(<span class="string">"error"</span>, (event) =&gt; &#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.error(<span class="string">"WebSocket error:"</span>, event);</span></span><br><span class="line"><span class="undefined">        &#125;);</span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这次终于正常了，websockify输出变成了由应用服务主动断开</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$ websockify 8765 127.0.0.1:12346 --<span class="built_in">log</span>-file /tmp/ws.log -v --traffic</span><br><span class="line">WebSocket server settings:</span><br><span class="line">  - Listen on :8765</span><br><span class="line">  - No SSL/TLS support (no cert file)</span><br><span class="line">  - proxying from :8765 to 127.0.0.1:12346</span><br><span class="line">10.2.48.36: new handler Process</span><br><span class="line">10.2.48.36 - - [13/Dec/2023 20:24:29] <span class="string">"GET / HTTP/1.1"</span> 101 -</span><br><span class="line">10.2.48.36 - - [13/Dec/2023 20:24:29] 10.2.48.36: Plain non-SSL (ws://) WebSocket connection</span><br><span class="line">10.2.48.36 - - [13/Dec/2023 20:24:29] connecting to: 127.0.0.1:12346</span><br><span class="line"></span><br><span class="line">Traffic Legend:</span><br><span class="line">    &#125;  - Client receive</span><br><span class="line">    &#125;. - Client receive partial</span><br><span class="line">    &#123;  - Target receive</span><br><span class="line"></span><br><span class="line">    &gt;  - Target send</span><br><span class="line">    &gt;. - Target send partial</span><br><span class="line">    &lt;  - Client send</span><br><span class="line">    &lt;. - Client send partial</span><br><span class="line">&#125;&gt;&#123;&lt;10.2.48.36 - - [13/Dec/2023 20:24:29] 127.0.0.1:12346: Target closed connection</span><br><span class="line">10.2.48.36 - - [13/Dec/2023 20:24:29] 127.0.0.1:12346: Closed target</span><br></pre></td></tr></table></figure><p>echoserver也看到了发送的内容【1234】：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ python3 echoserver.py</span><br><span class="line">服务器已启动，等待客户端连接...</span><br><span class="line">客户端(<span class="string">'127.0.0.1'</span>, 37438)已连接</span><br><span class="line">收到来自(<span class="string">'127.0.0.1'</span>, 37438)的数据： 1234</span><br><span class="line">已将数据发送回(<span class="string">'127.0.0.1'</span>, 37438)</span><br><span class="line">客户端(<span class="string">'127.0.0.1'</span>, 37438)已断开连接</span><br></pre></td></tr></table></figure><h3 id="单独实现一个js版本websocket客户端"><a href="#单独实现一个js版本websocket客户端" class="headerlink" title="单独实现一个js版本websocket客户端"></a>单独实现一个js版本websocket客户端</h3><p>刚刚用html里的js发送了websocket数据，需要浏览器的帮助，如果是在服务器上局限性很大，所以我调整了一下，改成了js版本websocket客户端，用node.js运行，wsclient.js内容如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> WebSocket = <span class="built_in">require</span>(<span class="string">'ws'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 替换为你的 WebSocket 服务器地址</span></span><br><span class="line"><span class="keyword">const</span> socket = <span class="keyword">new</span> WebSocket(<span class="string">"ws://10.10.49.172:8765"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听连接打开事件</span></span><br><span class="line">socket.addEventListener(<span class="string">"open"</span>, (event) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"WebSocket connection opened."</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造二进制数据，这里使用一个简单的示例</span></span><br><span class="line">    <span class="keyword">const</span> binaryData = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>([<span class="number">49</span>, <span class="number">50</span>, <span class="number">51</span>, <span class="number">52</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送二进制数据</span></span><br><span class="line">    socket.send(binaryData);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Binary data sent successfully."</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听接收消息事件</span></span><br><span class="line">socket.addEventListener(<span class="string">"message"</span>, (event) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Received message:"</span>, event.data);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听连接关闭事件</span></span><br><span class="line">socket.addEventListener(<span class="string">"close"</span>, (event) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"WebSocket connection closed."</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听错误事件</span></span><br><span class="line">socket.addEventListener(<span class="string">"error"</span>, (event) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(<span class="string">"WebSocket error:"</span>, event);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ node wsclient.js</span><br><span class="line">WebSocket connection opened.</span><br><span class="line">Binary data sent successfully.</span><br><span class="line">Received message: &lt;Buffer 31 32 33 34&gt;</span><br><span class="line">WebSocket connection closed.</span><br></pre></td></tr></table></figure><p>至此，websockify的测试就结束了，它可以满足我们的需求，将websocket请求转换成tcp请求</p><h1 id="什么是VNC"><a href="#什么是VNC" class="headerlink" title="什么是VNC"></a>什么是VNC</h1><p>前面在介绍websockify多次提到VNC，其实VNC (Virtual Network Computing) 是一种远程桌面协议，允许用户在一个计算机上通过网络远程控制另一个计算机的桌面。VNC 提供了一种在远程计算机上查看和操作桌面的方式，就像你坐在那台计算机前一样，以下是关于 VNC 的一些关键概念：</p><ul><li><p>Server：在 VNC 中，远程计算机上运行的应用程序称为 VNC 服务器。该服务器负责监听连接请求，并将计算机的桌面图像发送给连接的客户端。</p></li><li><p>Viewer：连接到 VNC 服务器的应用程序称为 VNC 查看器。这是用户使用的远程桌面客户端，允许他们查看和操作远程计算机的桌面。</p></li><li><p>Port：VNC 服务器通过一个特定的网络端口监听连接请求。通常，VNC 默认使用 5900 端口。如果有多个 VNC 服务器在同一台计算机上运行，它们可能使用不同的端口（5901、5902 等）。</p></li><li><p>Security：VNC 提供了一些安全性选项，如密码保护和加密。这有助于确保在远程访问时保护计算机的安全。</p></li><li><p>Authentication：VNC 服务器和查看器之间的连接通常需要身份验证。这可以是使用密码进行简单的身份验证，也可以是更复杂的加密和密钥交换过程。</p></li><li><p>websockify：对于一些场景，特别是在 Web 浏览器中访问 VNC，你可能会使用工具如 <code>websockify</code> 将 VNC 的协议转换为 WebSocket 协议，以便在浏览器中实现 VNC 远程桌面访问。</p></li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>websockify可以轻松实现从websocket请求向tcp请求的转换，使用很方便</li><li>转换路径 wsclient <code>--ws--&gt;</code> websockify <code>--tcp--&gt;</code> tcp application <code>--tcp--&gt;</code> websockify <code>--ws--&gt;</code> wsclient</li><li>wss对应的是ws的加密版本，他们的关系是wss=ws+SSL/TSL，类似的https=http+SSL/TSL</li><li>无论是nginx还是websockify都可以配置服务器证书，将应用服务器从SSL/TSL中解脱出来</li><li>VNC是一种远程桌面协议，允许用户在一个计算机上通过网络远程控制另一个计算机的桌面</li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/134888966" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>迈出这一步确实不太容易，一旦行动了就会发现没有想象中的那么难，我们都没有预知未来的能力，无法判定目前的选择是对还是错，既然选择了就要努力走下去</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;目前遇到一个问题，原本的服务都是利用tcp通信的，但是某些平台只支持websocket，是不是要从头实现一套websocket网络收发逻辑呢？短时间内有没有替代方案呢？在经过一番寻找之后发现了websockify这个神器，可以将websocket协议转换成tcp协议，从而实现不修改应用服务就支持tcp协议的目的，接下来就说说它怎么用，以及探索的过程。&lt;/p&gt;
    
    </summary>
    
      <category term="Nginx" scheme="http://AlbertGithubHome.github.io/blog/categories/Nginx/"/>
    
    
      <category term="Nginx" scheme="http://AlbertGithubHome.github.io/blog/tags/Nginx/"/>
    
      <category term="网络协议" scheme="http://AlbertGithubHome.github.io/blog/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    
      <category term="websockify" scheme="http://AlbertGithubHome.github.io/blog/tags/websockify/"/>
    
      <category term="websocket" scheme="http://AlbertGithubHome.github.io/blog/tags/websocket/"/>
    
      <category term="tcp/ip" scheme="http://AlbertGithubHome.github.io/blog/tags/tcp-ip/"/>
    
      <category term="NVC" scheme="http://AlbertGithubHome.github.io/blog/tags/NVC/"/>
    
  </entry>
  
  <entry>
    <title>nginx配置自建SSL证书</title>
    <link href="http://AlbertGithubHome.github.io/blog/2023/12/08/nginx%E9%85%8D%E7%BD%AE%E8%87%AA%E5%BB%BASSL%E8%AF%81%E4%B9%A6/"/>
    <id>http://AlbertGithubHome.github.io/blog/2023/12/08/nginx配置自建SSL证书/</id>
    <published>2023-12-08T15:24:23.000Z</published>
    <updated>2023-12-19T16:09:06.362Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>之前的一篇文章<a href="https://blog.csdn.net/albertsh/article/details/134724042" target="_blank" rel="noopener">《自建CA并生成自签名SSL证书》</a>中讲到为什么要自建CA和自签名SSL证书，是因为买证书得花钱，对于内部或小规模项目，使用自建SSL证书可能更为方便，不需要支付费用，而且不涉及复杂的验证过程。正式对外的服务一般都是要买公共证书颁发机构（CA）签发的SSL证书的，但是在对外发布前可以先使用自建证书打通流程</p><a id="more"></a><h1 id="配置SSL证书"><a href="#配置SSL证书" class="headerlink" title="配置SSL证书"></a>配置SSL证书</h1><p>创建SSL证书的流程参考上文中提到的文章吧，本文只讲怎样把自建SSL证书配置到nginx，实际上非常简单。</p><p>假设我们的自建证书是 <code>/root/ca/server.crt</code>，服务器私钥是 <code>/root/ca/server.key</code>，nginx配置文件我以<a href="https://blog.csdn.net/albertsh/article/details/129543700" target="_blank" rel="noopener">《记录一下第一次安装和配置Nginx》</a> 这篇文章的配置文件为例，初始配置为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">upstream go_entrance &#123;</span><br><span class="line">    server localhost:4101;</span><br><span class="line">    server localhost:4102;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen       4100;</span><br><span class="line">    server_name  localhost;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line"></span><br><span class="line">        proxy_pass http://go_entrance;</span><br><span class="line">        proxy_set_header Host <span class="variable">$host</span>;</span><br><span class="line">        proxy_set_header X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">        proxy_set_header X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4100端口监听http协议转发到本机的4101端口和4102端口，如果把SSL证书配置到这个端口上，就相当于这个端口支持了https，配置修改如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">upstream go_entrance &#123;</span><br><span class="line">    server localhost:4101;</span><br><span class="line">    server localhost:4102;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen 4100 ssl;</span><br><span class="line">    server_name  localhost;</span><br><span class="line"></span><br><span class="line">    ssl_certificate /root/ca/server.crt;</span><br><span class="line">    ssl_certificate_key /root/ca/server.key;</span><br><span class="line"></span><br><span class="line">    ssl_session_cache shared:SSL:10m;</span><br><span class="line">    ssl_session_timeout 10m;</span><br><span class="line"></span><br><span class="line">    ssl_protocols TLSv1 TLSv1.1 TLSv1.2;</span><br><span class="line">    ssl_ciphers HIGH:!aNULL:!MD5;</span><br><span class="line">    ssl_prefer_server_ciphers on;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_pass http://go_entrance;</span><br><span class="line">        proxy_set_header Host <span class="variable">$host</span>;</span><br><span class="line">        proxy_set_header X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">        proxy_set_header X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只需要将4100端口后面加上 ssl，再配置几个ssl相关的参数就可以了，含义如下：</p><ul><li><p><code>ssl_certificate</code>： 指定 SSL 证书文件路径 /root/ca/server.crt</p></li><li><p><code>ssl_certificate_key</code>： 指定私钥文件路径 /root/ca/server.key</p></li><li><p><code>ssl_session_cache</code>： 配置用于存储 SSL 会话的缓存。shared:SSL:10m 表示使用共享的内存区域，最大占用内存为 10MB</p></li><li><p><code>ssl_session_timeout</code>： 配置 SSL 会话的超时时间，这里设置为 10 分钟</p></li><li><p><code>ssl_protocols</code>： 指定支持的 SSL/TLS 协议版本，这里包括 TLSv1、TLSv1.1 和 TLSv1.2</p></li><li><p><code>ssl_ciphers</code>： 指定支持的加密套件，这里配置为 HIGH:!aNULL:!MD5，表示使用高强度的加密套件，不支持空加密和 MD5</p></li></ul><h1 id="SSL证书放在-Nginx-而不放在应用服务器上的好处"><a href="#SSL证书放在-Nginx-而不放在应用服务器上的好处" class="headerlink" title="SSL证书放在 Nginx 而不放在应用服务器上的好处"></a>SSL证书放在 Nginx 而不放在应用服务器上的好处</h1><p>正如上面的配置一样，4100端口收到https请求后转发到4101和4102上的是http协议，说明使用这种方式一些仅支持http协议的应用服务也可以通过nginx配置证书来达到支持https的目的，具体好处如下：</p><ul><li><p><strong>集中管理：</strong> 使用反向代理服务器管理 SSL 证书可以实现集中式管理。这意味着你可以在一个地方管理证书，而不需要在每个应用服务器上都安装和维护证书。这样能够简化证书的更新和维护流程。</p></li><li><p><strong>简化配置：</strong> 通过在反向代理服务器上配置 SSL，你可以简化应用服务器的配置。应用服务器可以专注于处理应用程序逻辑，而无需关心 SSL 配置。这样有助于提高系统的可维护性和简化配置过程。</p></li><li><p><strong>负载均衡和扩展：</strong> 如果你使用负载均衡，SSL终止（SSL Termination）在负载均衡器上执行可以减轻应用服务器的负担。负载均衡器负责处理SSL握手，将非加密的请求转发给后端应用服务器。这样，后端服务器就可以专注于处理业务逻辑，而无需处理加密和解密操作。</p></li><li><p><strong>性能优化：</strong> SSL 握手和加解密操作可能是计算密集型的任务，将这些任务从应用服务器中移除，可以在 SSL 握手和加解密方面提高性能。</p></li><li><p><strong>统一的安全策略：</strong> 通过在反向代理服务器上管理 SSL，可以实施统一的安全策略，确保所有传入和传出的流量都经过相同的安全设置。</p></li></ul><h1 id="Nginx只能转发http协议吗"><a href="#Nginx只能转发http协议吗" class="headerlink" title="Nginx只能转发http协议吗"></a>Nginx只能转发http协议吗</h1><p>不，Nginx 不仅仅能够转发 HTTP 协议，还支持其他多种协议的代理转发。主要的协议包括：</p><ul><li><p><strong>HTTPS协议：</strong> 通过在配置中启用 SSL/TLS，Nginx 可以用作安全的 HTTPS 服务器和反向代理，处理加密的 HTTP 流量。</p>  <figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">listen</span> <span class="number">443</span> ssl;</span><br><span class="line"><span class="attribute">ssl_certificate</span> /path/to/certificate.crt;</span><br><span class="line"><span class="attribute">ssl_certificate_key</span> /path/to/private-key.key;</span><br><span class="line"></span><br><span class="line"><span class="attribute">location</span> / &#123;</span><br><span class="line">    <span class="attribute">proxy_pass</span> https://backend_server;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>TCP协议：</strong> 从1.9版本开始 Nginx 可以用于代理 TCP 流量，例如数据库连接、消息队列等。</p>  <figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">stream</span> &#123;</span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span> <span class="number">3306</span>;</span><br><span class="line">        <span class="attribute">proxy_pass</span> backend_server:<span class="number">3306</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>UDP协议：</strong> 从Nginx 1.9.13版本开始，开始支持 UDP 代理。这使得它可以用于代理 UDP 流量，如 DNS 请求等。</p>  <figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">stream</span> &#123;</span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span> <span class="number">53</span> udp;</span><br><span class="line">        <span class="attribute">proxy_pass</span> backend_dns_server:<span class="number">53</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>WebSocket协议：</strong> WebSocket 是一种在单个 TCP 连接上提供全双工通信的协议，常用于实时应用程序，如在线游戏、聊天应用等。</p>  <figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">map</span> <span class="variable">$http_upgrade</span> <span class="variable">$connection_upgrade</span> &#123;</span><br><span class="line">    <span class="attribute">default</span> upgrade;</span><br><span class="line">    ''      close;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">server_name</span> your_domain.com;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">location</span> /websocket &#123;</span><br><span class="line">        <span class="attribute">proxy_pass</span> http://backend_server;</span><br><span class="line">        <span class="attribute">proxy_http_version</span> <span class="number">1</span>.<span class="number">1</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> Upgrade <span class="variable">$http_upgrade</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> Connection <span class="variable">$connection_upgrade</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="Nginx转发TCP协议会收到端口限制吗"><a href="#Nginx转发TCP协议会收到端口限制吗" class="headerlink" title="Nginx转发TCP协议会收到端口限制吗"></a>Nginx转发TCP协议会收到端口限制吗</h1><p>是的，TCP是一种面向连接的全双工通信的协议，当转发TCP消息时，Nginx不仅是一个服务器接受客户端的连接，再它连接应用服务器时还表现成一个客户端，每个连接需要消耗一个端口，以理论值65535个端口来计算，nginx最多转发65535个连接，但是可以通过 <code>proxy_bind</code> 来突破限制，或者配置多个IP或虚拟IP也可以。</p><p>这种方式还没测过，感兴趣可以参考官方说明的看一下 <a href="https://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_bind" target="_blank" rel="noopener">https://nginx.org/r/proxy_bind</a></p><h1 id="Nginx本身能将Websocket数据转化成TCP数据吗"><a href="#Nginx本身能将Websocket数据转化成TCP数据吗" class="headerlink" title="Nginx本身能将Websocket数据转化成TCP数据吗"></a>Nginx本身能将Websocket数据转化成TCP数据吗</h1><p>只使用Nginx是做不到的，但是搭配Websockify就可以做到WSS（WebSocket Secure）到 TCP 的转发</p><ol><li><p><strong>安装 Nginx：</strong><br>确保你的系统上已经安装了 Nginx。你可以使用系统包管理器或从 Nginx 官方网站下载并安装</p></li><li><p><strong>安装 Websockify：</strong><br>安装 Websockify，可以使用 pip 执行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install websockify</span><br></pre></td></tr></table></figure></li><li><p><strong>创建 Websockify 启动脚本：</strong><br>创建一个用于启动 Websockify 的脚本，例如 <code>start_websockify.sh</code>。脚本内容可能如下所示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">websockify --web /path/to/webroot 1234 localhost:5678</span><br></pre></td></tr></table></figure><p>这里 <code>1234</code> 是用于 WebSocket 连接的端口，<code>localhost:5678</code> 是实际 TCP 服务的地址</p></li><li><p><strong>配置 Nginx：</strong><br>修改 Nginx 配置文件，将 WSS 请求转发到 Websockify 启动脚本。示例配置如下：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">443</span> ssl;</span><br><span class="line">    <span class="attribute">server_name</span> your_domain.com;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">ssl_certificate</span> /root/ca/server.crt;</span><br><span class="line">    <span class="attribute">ssl_certificate_key</span> /root/ca/server.key;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">location</span> / &#123;</span><br><span class="line">        <span class="attribute">proxy_pass</span> http://localhost:1234;</span><br><span class="line">        <span class="attribute">proxy_http_version</span> <span class="number">1</span>.<span class="number">1</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> Upgrade <span class="variable">$http_upgrade</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> Connection <span class="string">"upgrade"</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> Host <span class="variable">$host</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的 <code>listen 443</code> 表示监听 HTTPS 请求，<code>proxy_pass http://localhost:1234</code> 将请求代理到 Websockify 启动脚本</p></li><li><p><strong>启动服务：</strong><br>启动 Websockify 服务：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod +x start_websockify.sh</span><br><span class="line">./start_websockify.sh</span><br></pre></td></tr></table></figure><p>启动 Nginx 服务：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start nginx</span><br></pre></td></tr></table></figure></li><li><p><strong>测试：</strong><br>使用支持 WebSocket 的客户端连接到 WSS 地址，例如 <code>wss://your_domain.com</code>，并验证是否成功将 WebSocket 请求转发到 TCP 服务</p></li></ol><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>nginx配置自建SSL证书，只需要修改nginx配置文件，在端口后配置添加 ssl 并指定证书和私钥路径即可</li><li>nginx上配置SSL证书可以将证书统一管理，减轻应用服务器加密解密的负担，专注于业务逻辑开发</li><li>nginx不仅支持http协议转发，还支持https、tcp、udp、websocket等协议的转发</li><li>nginx转发tcp协议时会收到端口号个数限制，理论上限6万，通过proxy_bind可以突破上限</li><li>nginx搭配websockify可以做到WSS 到 TCP 的转发</li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/134818171" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>寒风终究是刮到我这里了</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;之前的一篇文章&lt;a href=&quot;https://blog.csdn.net/albertsh/article/details/134724042&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《自建CA并生成自签名SSL证书》&lt;/a&gt;中讲到为什么要自建CA和自签名SSL证书，是因为买证书得花钱，对于内部或小规模项目，使用自建SSL证书可能更为方便，不需要支付费用，而且不涉及复杂的验证过程。正式对外的服务一般都是要买公共证书颁发机构（CA）签发的SSL证书的，但是在对外发布前可以先使用自建证书打通流程&lt;/p&gt;
    
    </summary>
    
      <category term="Nginx" scheme="http://AlbertGithubHome.github.io/blog/categories/Nginx/"/>
    
    
      <category term="运维" scheme="http://AlbertGithubHome.github.io/blog/tags/%E8%BF%90%E7%BB%B4/"/>
    
      <category term="Nginx" scheme="http://AlbertGithubHome.github.io/blog/tags/Nginx/"/>
    
      <category term="nginx ssl" scheme="http://AlbertGithubHome.github.io/blog/tags/nginx-ssl/"/>
    
      <category term="https" scheme="http://AlbertGithubHome.github.io/blog/tags/https/"/>
    
      <category term="websockify" scheme="http://AlbertGithubHome.github.io/blog/tags/websockify/"/>
    
  </entry>
  
  <entry>
    <title>怎么验证公钥和私钥是一对</title>
    <link href="http://AlbertGithubHome.github.io/blog/2023/12/05/%E6%80%8E%E4%B9%88%E9%AA%8C%E8%AF%81%E5%85%AC%E9%92%A5%E5%92%8C%E7%A7%81%E9%92%A5%E6%98%AF%E4%B8%80%E5%AF%B9/"/>
    <id>http://AlbertGithubHome.github.io/blog/2023/12/05/怎么验证公钥和私钥是一对/</id>
    <published>2023-12-05T15:20:43.000Z</published>
    <updated>2023-12-19T16:06:33.640Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>公钥和私钥都是一串字符，长得也没有什么关联性，那么当拿到一个公钥和一个私钥后怎么验证它们两个是一对呢？先说说为什么会有这个疑问，最近在对接一些SDK时经常需要做签名和验证签名的工作，双方要相互提供公钥来完成后续的身份验证，测试过程中生成了多个密钥对，当时就在想如果我用错了怎样才能发现呢？有没有什么方法可以验证公钥和私钥是一对呢？再寻找方法的过程中发现 <code>ssh-keygen</code> 和 <code>openssl</code> 生成的密钥对差别居然这么大，但后来又发现他们居然还有联系，所以本文将刚刚提到的问题都总结一下，方便日后查阅。</p><a id="more"></a><p>解决这个问题的思路我么可以从密钥使用的方式入手，私钥加密公钥解密可以验证身份，公钥加密私钥解密可以秘密传递数据，也就是说公钥和私钥是配合工作的，如果我们用私钥加密一个数据，公钥可以解开就说明他们两个是一对的的。</p><p>其实还有一个更简单的办法，公钥是可以从私钥中提取出来的，反之则不行。在公钥密码学中，私钥和公钥之间的关系是一种数学上的单向函数。这种函数的特性使得从私钥生成公钥是可行的，而从公钥还原私钥是非常困难的，这被称为一个单向函数或单向映射，因此被认为是安全的。</p><p>有了这个前提我们就可以这样做，从私钥中提取出公钥，然后和要比对的公钥进行比较，如果一致就说明原来的公钥和私钥是一对啦。</p><h1 id="ssh-keygen-和-openssl"><a href="#ssh-keygen-和-openssl" class="headerlink" title="ssh-keygen 和 openssl"></a>ssh-keygen 和 openssl</h1><p><code>ssh-keygen</code> 和 <code>openssl</code> 是两个不同的工具，它们分别用于生成和处理不同类型的密钥和证书。以下是它们的一些主要区别：</p><ol><li><p><strong>功能和用途：</strong></p><ul><li><code>ssh-keygen</code>：主要用于生成和管理SSH密钥对，包括RSA、DSA、ECDSA和Ed25519密钥。</li><li><code>openssl</code>：是一个通用的密码学工具，可以用于生成和管理多种密码学对象，包括SSL/TLS证书、密钥、摘要和数字签名等。</li></ul></li><li><p><strong>支持的算法：</strong></p><ul><li><code>ssh-keygen</code>：专注于SSH密钥生成，支持多种SSH密钥算法。</li><li><code>openssl</code>：支持广泛的密码学算法，包括RSA、DSA、ECDSA、Diffie-Hellman、AES、SHA等，用于生成和操作各种密码学对象。</li></ul></li><li><p><strong>密钥格式：</strong></p><ul><li><code>ssh-keygen</code>：生成的SSH密钥通常以OpenSSH格式存储。</li><li><code>openssl</code>：支持多种密钥格式，例如PEM、DER等，可以处理不同类型的密钥和证书。</li></ul></li><li><p><strong>具体应用场景：</strong></p><ul><li><code>ssh-keygen</code>：主要用于SSH连接，生成用于身份验证的密钥对。</li><li><code>openssl</code>：更广泛地用于TLS/SSL证书、数字签名、加密和其他与通用密码学相关的应用。</li></ul></li><li><p><strong>具体命令和用法：</strong></p><ul><li><p><code>ssh-keygen</code>：用于生成SSH密钥对的常见命令包括：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -b 2048 -f myid_rsa</span><br></pre></td></tr></table></figure></li><li><p><code>openssl</code>：用于生成RSA密钥对的常见命令包括：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">openssl genpkey -algorithm RSA -out private-key.pem</span><br><span class="line">openssl rsa -pubout -<span class="keyword">in</span> private-key.pem -out public-key.pem</span><br></pre></td></tr></table></figure></li></ul></li></ol><p>以上的ChatGPT提供的内容，还是对比的挺全面的，从 <code>openssl</code> 生成密钥对的过程可以看出，确实可以从私钥中提取出公钥。</p><p><code>ssh-keygen</code> 是我接触的最多的生成密钥对的命令，不管是github还是gitlab，或者一些其他的托管平台都会提到SSH Keys，所以每次我都会用 <code>ssh-keygen</code> 来生成，它是用于生成SSH连接密钥对最直接的选择，如果是想要使用更广泛的密码学操作，包括证书生成、签名和加密等，那么 <code>openssl</code> 提供了更大的灵活性。</p><h2 id="两种证书的内容对比"><a href="#两种证书的内容对比" class="headerlink" title="两种证书的内容对比"></a>两种证书的内容对比</h2><p>前面说了两种命令生成的证书、格式、算法和用途都有区别，我们来看看利用上面的命令生成的证书内容有什么不同，先看 <code>ssh-keygen</code> 生成的私钥 <code>myid_rsa</code> 和公钥 <code>myid_rsa.pub</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># demo @ demo-ThinkPad-X390 in ~/tmp/rsa [17:58:47]</span></span><br><span class="line">$ ssh-keygen -t rsa -b 2048 -f myid_rsa</span><br><span class="line">Generating public/private rsa key pair.</span><br><span class="line">Enter passphrase (empty <span class="keyword">for</span> no passphrase):</span><br><span class="line">Enter same passphrase again:</span><br><span class="line">Your identification has been saved <span class="keyword">in</span> myid_rsa</span><br><span class="line">Your public key has been saved <span class="keyword">in</span> myid_rsa.pub</span><br><span class="line">The key fingerprint is:</span><br><span class="line">SHA256:eLzG9lryO/AOdd05cDkixvBNCPFZRLRu0wp3bxZ7Vnk demo@demo-ThinkPad-X390</span><br><span class="line">The key<span class="string">'s randomart image is:</span></span><br><span class="line"><span class="string">+---[RSA 2048]----+</span></span><br><span class="line"><span class="string">|         +o =*   |</span></span><br><span class="line"><span class="string">|          =.= . .|</span></span><br><span class="line"><span class="string">|           B = + |</span></span><br><span class="line"><span class="string">|       o  . o.=.+|</span></span><br><span class="line"><span class="string">|      . S ...=.BE|</span></span><br><span class="line"><span class="string">|       o.o .+ + B|</span></span><br><span class="line"><span class="string">|        Bo.  . .*|</span></span><br><span class="line"><span class="string">|       o *o    +.|</span></span><br><span class="line"><span class="string">|        .o=o     |</span></span><br><span class="line"><span class="string">+----[SHA256]-----+</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># demo @ demo-ThinkPad-X390 in ~/tmp/rsa [19:22:03]</span></span><br><span class="line">$ cat myid_rsa</span><br><span class="line">-----BEGIN OPENSSH PRIVATE KEY-----</span><br><span class="line">b3BlbnNzaC1rZXktdjEAAAAABG5vbmUAAAAEbm9uZQAAAAAAAAABAAABFwAAAAdzc2gtcn</span><br><span class="line">NhAAAAAwEAAQAAAQEAr7gEjCdhA4at0tx0efpLunEOEGvK3ejJCh/dBwLfsvVJelwTeJjK</span><br><span class="line">zI2nFvYGkJgndhWLuvwy6+ODnvASeNvXSvZZzXvvXjTF4JP3TRbATayFvS9mZgzOnxh/rU</span><br><span class="line">z4P7ecLBfqZZkem+VBrMlv37yaIWf7co59dtrJJuAfZJFXyW//LQhNoEaqbZ/gvZls5pOX</span><br><span class="line">r2foMnYg2HV0ayPlvz8cmVF8LIOqaGOc28nMQakVwO+nZhbSv1bGprIGcy4czc7UOp/m+o</span><br><span class="line">t6mWJflpq3NBGiImyfaT2kxp1+pIdd6ISqoZqa9C2JzH7ZXVGjevbHuqup871yjUGapxDx</span><br><span class="line">lDk9HjdSLwAAA9AlxLUDJcS1AwAAAAdzc2gtcnNhAAABAQCvuASMJ2EDhq3S3HR5+ku6cQ</span><br><span class="line">4Qa8rd6MkKH90HAt+y9Ul6XBN4mMrMjacW9gaQmCd2FYu6/DLr44Oe8BJ429dK9lnNe+9e</span><br><span class="line">NMXgk/dNFsBNrIW9L2ZmDM6fGH+tTPg/t5wsF+plmR6b5UGsyW/fvJohZ/tyjn122skm4B</span><br><span class="line">9kkVfJb/8tCE2gRqptn+C9mWzmk5evZ+gydiDYdXRrI+W/PxyZUXwsg6poY5zbycxBqRXA</span><br><span class="line">76dmFtK/VsamsgZzLhzNztQ6n+b6i3qZYl+Wmrc0EaIibJ9pPaTGnX6kh13ohKqhmpr0LY</span><br><span class="line">nMftldUaN69se6q6nzvXKNQZqnEPGUOT0eN1IvAAAAAwEAAQAAAP8nH9HjYuE258XMLUnB</span><br><span class="line">3vj9ii6XeWiyACLDHlUYOouUTQkPNXEgaOS+psuNUTok97vRjvqNp5mu6/liahGy10AYcM</span><br><span class="line">GN/wpM73MfjdKCV455vPAKL4OdNTzML6g97eVYSol7R9foxy8JhwIYdsFyD4xB4+UYnKFS</span><br><span class="line">1WP0Q/K5caMaNnazPF0X7JDSenEwBwl1bDAN5OKwZNzSzUpR/96fl1DAgnG9yp1/634WGt</span><br><span class="line">IfjXLm13OSMrSHfwazNHoqAPkD0SQVJrm38ppvqArU0tBVfh/kvBkv7CCAE9mzhxusiKju</span><br><span class="line">B0c/jrsRDu45AJX5wuqIWcZdfppATJjK10S20MgN5dkAAACBALYym7mpDVQJ2gedSjv/Pv</span><br><span class="line">a+O/5b/20jawc3RFZdJAUWSGJTe9UqyHBHPlYj3/bHJVWIQ9S7s5AxpBtAEOsjeQf0VGFa</span><br><span class="line">FALQwcUghx5r1uM5sAL06CT/5t3Ze8lcJozNW7yjbVZKjJK13GTDMrnPYTfPOc+I/6N3R+</span><br><span class="line">SV2iKOwUQPAAAAgQDp9/2WvHOX2GKXan2BvMaexj6GYIQa8xEsqhtQGY9zxQ2d+9Z7YgDf</span><br><span class="line">XnNanxv8XJ61komeP9KmhS+2TCt0trj8sXtQobDsDGjFcDx0jjBobU6zKvO4htoZP3lb8w</span><br><span class="line">ZARgQoEANxqNOo8R61CsDQW4eM0ReAitKZ0GCcXbqNYCRTGwAAAIEAwEPdhAH4iH6V7IJn</span><br><span class="line">Qs3pgf9AG9UubDe9mAwVNIircWTFO2EFaBpwP7UKgpNmmZjoD2lWEcr2Zxv6x8ILBlJqea</span><br><span class="line">vCpGfLo0hwt2XZHgLRsTx8RmsbmYI2l8qnkMWyz5Lh3XAhNMZM4s9OvSJM6JPWYcedG5KY</span><br><span class="line">G1/zbarjwkq+Gn0AAAAVc2h6QHNoei1UaGlua1BhZC1YMzkwAQIDBAUG</span><br><span class="line">-----END OPENSSH PRIVATE KEY-----</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># demo @ demo-ThinkPad-X390 in ~/tmp/rsa [19:22:10]</span></span><br><span class="line">$ cat myid_rsa.pub</span><br><span class="line">ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQCvuASMJ2EDhq3S3HR5+ku6cQ4Qa8rd6MkKH90HAt+y9Ul6XBN4mMrMjacW9gaQmCd2FYu6/DLr44Oe8BJ429dK9lnNe+9eNMXgk/dNFsBNrIW9L2ZmDM6fGH+tTPg/t5wsF+plmR6b5UGsyW/fvJohZ/tyjn122skm4B9kkVfJb/8tCE2gRqptn+C9mWzmk5evZ+gydiDYdXRrI+W/PxyZUXwsg6poY5zbycxBqRXA76dmFtK/VsamsgZzLhzNztQ6n+b6i3qZYl+Wmrc0EaIibJ9pPaTGnX6kh13ohKqhmpr0LYnMftldUaN69se6q6nzvXKNQZqnEPGUOT0eN1Iv demo@demo-ThinkPad-X390</span><br></pre></td></tr></table></figure><p>接着看看 <code>openssl</code> 生成的私钥 <code>private-key.pem</code> 和公钥 <code>public-key.pem</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># demo @ demo-ThinkPad-X390 in ~/tmp/rsa [19:23:01]</span></span><br><span class="line">$ openssl genpkey -algorithm RSA -out private-key.pem</span><br><span class="line">......................................................................+++++</span><br><span class="line">..................+++++</span><br><span class="line"></span><br><span class="line"><span class="comment"># demo @ demo-ThinkPad-X390 in ~/tmp/rsa [19:25:04]</span></span><br><span class="line">$ openssl rsa -pubout -<span class="keyword">in</span> private-key.pem -out public-key.pem</span><br><span class="line">writing RSA key</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># demo @ demo-ThinkPad-X390 in ~/tmp/rsa [19:26:18]</span></span><br><span class="line">$ cat private-key.pem</span><br><span class="line">-----BEGIN PRIVATE KEY-----</span><br><span class="line">MIIEvwIBADANBgkqhkiG9w0BAQEFAASCBKkwggSlAgEAAoIBAQDjxEM9ypyLb0fT</span><br><span class="line">xk7Ujdvj7efUjbLhzAcbfHNRZqzqif1rlTS4jz+tIDZBX9/HJkDcoz1dIolp/53S</span><br><span class="line">CJtz+qBrkHMzsi6dcqd5jXUfT3Ts/FMTVsAKIkwafnw2Gbi2DGQx8WQ8Sn5+LlUP</span><br><span class="line">FSCJa+2MTc21taiMP7CtF7iG6jFeGna3xeRTWAjMMS2xk9Zk37KMz8weU4ShdQ9q</span><br><span class="line">mX7yuKHuZzUiWHmjbW/bi6abur3dfi/1jRSnFQF+r/gJoH1UXT4st/+fW425nWqO</span><br><span class="line">ohSV+xw61a09fjECfjVDkMXtwiPCbbGNjD8WjLbilOJK3uBx5e7GIN1jZjVBqlH9</span><br><span class="line">NqEk12HVAgMBAAECggEAIlcf8DwRGDDB+psGnaN5yMbA0lo+4y5Yz/sWg+pgHciK</span><br><span class="line">TeMkHMN0TUzzAS5MVgFdfCachONFJpckm1sy3OynrTANPnkZ8CEuQPRj+UGIloaA</span><br><span class="line">nATTVXPQV5pEbf+4yrHZlXIYs8JjifDAYFLGIhIEsce1QTVPYT3lDGPsLWM36ED6</span><br><span class="line">XVnvJYsr00wpLlYy4uWikt4Q8ruKDnWSS8xeE7pj0bBaqYd8Gz4jfrJ94IgNIROQ</span><br><span class="line">xnXb8aMG/o441ImrF6YXKn8jR/gjZXT1L4ZsD7fGTvLKBxxImBXL2eIoZ8usmTtX</span><br><span class="line">eLEfYaJlzyXOcnYKKVtMQxRI+4ANJWWnMDgM8NTBTQKBgQD0hboW//hXGVcng3Pu</span><br><span class="line">NfD7hUPHQKWWUHbchjRfxvxy/4itqGaWHtUrmc4PTXUxW71YaVA6qm2gvfV+jn83</span><br><span class="line">o5k009vVbXYVvztNQq9wC0Fj2OYwQkxHMgAY9JdhZr6ghuEZ0+hNd5Jea9K3w62C</span><br><span class="line">cY0mHqlvo55szhWmhuvzFtSUXwKBgQDudTFUjf7+qPsfYEX14udsKtfowrjepFLf</span><br><span class="line">nQAbxj16PxpRBSV7S77gdlW1shKEreIPbm083bhU3ypCRs7ktR0Wki/uoQGYekHr</span><br><span class="line">b8Nljh+rM9DxY83+HfLHAC/RjP8ZFrWJFgo6Whfr3jhlb8j3a4siLvqMj0d35BRv</span><br><span class="line">M+HtsEhWSwKBgQC7M746aZG5LP9akvsofkeWaHpxi366S7QUNPLX+MHBUP1U5j5T</span><br><span class="line">5BsTnFbzxDtapH+btlTj9SKlE4llcLbY4/khRqlhBsKG97bw+YLS5usTBDWG8Nrx</span><br><span class="line">DsigUnGq8jwzLdAcM+3/kPGQNEBIzBiEa2bCrmrNu5hIeKZ+rYDqxKnPRQKBgQCh</span><br><span class="line">MZuNOwfbAkPvq9bfJuml1zho4eiyqIZVHv6Jx/KbBrk1d7Mkq8l2VsgNsTiPdDPS</span><br><span class="line">lqVFdeQ7izg34UHOnRfywBOizjgT6OFS1BRUPETwKHDgHMWNOJV7LIcmspdnUFCb</span><br><span class="line">QMjdNTXifi/FclF537sH+pXoGpsHUqj1my7ozDe6DQKBgQDY9tJvXx5DRPVH2t60</span><br><span class="line">0rl1df3PogoAhwjvK+Q/Y5vLyrL470JxMNPtW546aWXRL6INTg+OvsUqLJXEMlxl</span><br><span class="line">HdHIe16orIGBrGcqHNGfkQPfddJVOo0eQCCk4jaLL9EP7+euA83vp6cP38rqgsL7</span><br><span class="line">0+gt34iMPCP9dEKaJyjZPv+vFQ==</span><br><span class="line">-----END PRIVATE KEY-----</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># demo @ demo-ThinkPad-X390 in ~/tmp/rsa [19:26:21]</span></span><br><span class="line">$ cat public-key.pem</span><br><span class="line">-----BEGIN PUBLIC KEY-----</span><br><span class="line">MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA48RDPcqci29H08ZO1I3b</span><br><span class="line">4+3n1I2y4cwHG3xzUWas6on9a5U0uI8/rSA2QV/fxyZA3KM9XSKJaf+d0gibc/qg</span><br><span class="line">a5BzM7IunXKneY11H0907PxTE1bACiJMGn58Nhm4tgxkMfFkPEp+fi5VDxUgiWvt</span><br><span class="line">jE3NtbWojD+wrRe4huoxXhp2t8XkU1gIzDEtsZPWZN+yjM/MHlOEoXUPapl+8rih</span><br><span class="line">7mc1Ilh5o21v24umm7q93X4v9Y0UpxUBfq/4CaB9VF0+LLf/n1uNuZ1qjqIUlfsc</span><br><span class="line">OtWtPX4xAn41Q5DF7cIjwm2xjYw/Foy24pTiSt7gceXuxiDdY2Y1QapR/TahJNdh</span><br><span class="line">1QIDAQAB</span><br><span class="line">-----END PUBLIC KEY-----</span><br></pre></td></tr></table></figure><h1 id="从私钥提取公钥"><a href="#从私钥提取公钥" class="headerlink" title="从私钥提取公钥"></a>从私钥提取公钥</h1><p>使用 <code>openssl</code> 命令从私钥提取公钥，上面已经展示过程了，它的公钥就是这样生成的</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl rsa -pubout -<span class="keyword">in</span> private-key.pem -out public-key.pem</span><br></pre></td></tr></table></figure><p>使用 <code>ssh-keygen</code> 命令从私钥提取公钥可以这样做</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -y -f myid_rsa &gt; compare_myid_rsa.pub</span><br></pre></td></tr></table></figure><p>结果文件 compare_myid_rsa.pub 和 myid_rsa.pub 的内容一模一样，所以从私钥提取公钥可以作为检验密钥是否匹配的方法</p><h1 id="OPENSSH和PEM两种密钥格式相互转化"><a href="#OPENSSH和PEM两种密钥格式相互转化" class="headerlink" title="OPENSSH和PEM两种密钥格式相互转化"></a>OPENSSH和PEM两种密钥格式相互转化</h1><p>之前说了<code>ssh-keygen</code> 和 <code>openssl</code>两个命令及生成的密钥区别，现在讲讲两种密钥的联系，OpenSSH 和 OpenSSL 使用的密钥对虽然有一些格式上的差异，但可以相互转换。OpenSSH 使用自己的私钥和公钥格式, 而 OpenSSL 通常使用 PEM 格式，可以通过下列命令转化</p><h2 id="OpenSSH-格式私钥转换成-OpenSSL-PEM-格式私钥"><a href="#OpenSSH-格式私钥转换成-OpenSSL-PEM-格式私钥" class="headerlink" title="OpenSSH 格式私钥转换成 OpenSSL PEM 格式私钥"></a>OpenSSH 格式私钥转换成 OpenSSL PEM 格式私钥</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -p -N <span class="string">""</span> -f myid_rsa -m PEM</span><br></pre></td></tr></table></figure><blockquote><p>$ file myid_rsa<br>myid_rsa: PEM RSA private key</p></blockquote><h2 id="OpenSSL-PEM-格式私钥转换成-OpenSSH-格式私钥"><a href="#OpenSSL-PEM-格式私钥转换成-OpenSSH-格式私钥" class="headerlink" title="OpenSSL PEM 格式私钥转换成 OpenSSH 格式私钥"></a>OpenSSL PEM 格式私钥转换成 OpenSSH 格式私钥</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -p -N <span class="string">""</span> -f myid_rsa</span><br></pre></td></tr></table></figure><blockquote><p>$ file myid_rsa<br>myid_rsa: OpenSSH private key</p></blockquote><h2 id="OpenSSH-格式公钥生成-OpenSSL-PEM-格式公钥"><a href="#OpenSSH-格式公钥生成-OpenSSL-PEM-格式公钥" class="headerlink" title="OpenSSH 格式公钥生成 OpenSSL PEM 格式公钥"></a>OpenSSH 格式公钥生成 OpenSSL PEM 格式公钥</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -e -m PEM -f myid_rsa.pub &gt; new-public-key.pem</span><br></pre></td></tr></table></figure><blockquote><p>$ file new-public-key.pem<br>new-public-key.pem: ASCII text</p></blockquote><h2 id="OpenSSL-PEM-格式公钥生成-OpenSSH-格式公钥"><a href="#OpenSSL-PEM-格式公钥生成-OpenSSH-格式公钥" class="headerlink" title="OpenSSL PEM 格式公钥生成 OpenSSH 格式公钥"></a>OpenSSL PEM 格式公钥生成 OpenSSH 格式公钥</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -i -m PKCS8 -f new-public-key.pem &gt; compare_myid_rsa.pub</span><br></pre></td></tr></table></figure><blockquote><p>$ file compare_myid_rsa.pub<br>compare_myid_rsa.pub: OpenSSH RSA public key</p></blockquote><h1 id="公钥和私钥的匹配使用"><a href="#公钥和私钥的匹配使用" class="headerlink" title="公钥和私钥的匹配使用"></a>公钥和私钥的匹配使用</h1><p>匹配使用公钥和私钥之前先准备一个测试文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"Hello World"</span> &gt; data.txt</span><br></pre></td></tr></table></figure><h2 id="加密和解密"><a href="#加密和解密" class="headerlink" title="加密和解密"></a>加密和解密</h2><p>使用公钥加密</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl rsautl -<span class="keyword">in</span> data.txt -out data_enc.txt -inkey public-key.pem -pubin -encrypt</span><br></pre></td></tr></table></figure><p>使用私钥解密</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl rsautl -<span class="keyword">in</span> data_enc.txt -out data_dec.txt -inkey private-key.pem -decrypt</span><br></pre></td></tr></table></figure><p>两个命令执行后都没有任何控制台输出，文件 <code>data_enc.txt</code> 中是加密后的内容，文件 <code>data_dec.txt</code> 是解密后的内容，成功解密后内容与 <code>data.txt</code> 文件内容一样</p><h2 id="签名和验证"><a href="#签名和验证" class="headerlink" title="签名和验证"></a>签名和验证</h2><p>使用私钥签名</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl dgst -sha256 -sign private-key.pem -out signature.bin data.txt</span><br></pre></td></tr></table></figure><p>使用公钥验证签名</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl dgst -sha256 -verify public-key.pem -signature signature.bin data.txt</span><br></pre></td></tr></table></figure><p>验证通过后，会在命令行输出 “Verified OK” 字样，若不通过则输出 “Verification Failure” 字样</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>验证公钥私钥是否匹配的最便捷的方法是通过私钥提取公钥来和原公钥进行对比</li><li>公钥加密私钥解密，私钥签名公钥验证签名，需要把公钥发给别人，私钥自己要保留好</li><li>公钥和私钥常用的有OpenSSH和PEM两种格式，这两种格式的密钥可以相互转化</li><li><code>ssh-keygen</code> 和 <code>openssl</code> 是两个不同的工具，前者用于管理SSH密钥更具体，后者使用范围更广更灵活</li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/134724042" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>事情一件件去办就好了，『没什么大不了的』，希望你长大后还可以经常乐观的说这句话，一副俾睨天下的姿态</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;公钥和私钥都是一串字符，长得也没有什么关联性，那么当拿到一个公钥和一个私钥后怎么验证它们两个是一对呢？先说说为什么会有这个疑问，最近在对接一些SDK时经常需要做签名和验证签名的工作，双方要相互提供公钥来完成后续的身份验证，测试过程中生成了多个密钥对，当时就在想如果我用错了怎样才能发现呢？有没有什么方法可以验证公钥和私钥是一对呢？再寻找方法的过程中发现 &lt;code&gt;ssh-keygen&lt;/code&gt; 和 &lt;code&gt;openssl&lt;/code&gt; 生成的密钥对差别居然这么大，但后来又发现他们居然还有联系，所以本文将刚刚提到的问题都总结一下，方便日后查阅。&lt;/p&gt;
    
    </summary>
    
      <category term="Network" scheme="http://AlbertGithubHome.github.io/blog/categories/Network/"/>
    
    
      <category term="Network" scheme="http://AlbertGithubHome.github.io/blog/tags/Network/"/>
    
      <category term="公钥" scheme="http://AlbertGithubHome.github.io/blog/tags/%E5%85%AC%E9%92%A5/"/>
    
      <category term="私钥" scheme="http://AlbertGithubHome.github.io/blog/tags/%E7%A7%81%E9%92%A5/"/>
    
      <category term="openssl" scheme="http://AlbertGithubHome.github.io/blog/tags/openssl/"/>
    
      <category term="ssh-keygen" scheme="http://AlbertGithubHome.github.io/blog/tags/ssh-keygen/"/>
    
      <category term="pem" scheme="http://AlbertGithubHome.github.io/blog/tags/pem/"/>
    
  </entry>
  
  <entry>
    <title>自建CA并生成自签名SSL证书</title>
    <link href="http://AlbertGithubHome.github.io/blog/2023/11/30/%E8%87%AA%E5%BB%BACA%E5%B9%B6%E7%94%9F%E6%88%90%E8%87%AA%E7%AD%BE%E5%90%8DSSL%E8%AF%81%E4%B9%A6/"/>
    <id>http://AlbertGithubHome.github.io/blog/2023/11/30/自建CA并生成自签名SSL证书/</id>
    <published>2023-11-30T15:20:00.000Z</published>
    <updated>2023-12-19T16:33:51.378Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这是加密与认证系列的第五篇文章了，本来我是想把自建证书和nginx配置https访问总结到一起的，但是在实际操作的过程中我发现了很多细小的知识点，有些还是挺有意思的，这是一个不断自我提问不断寻求答案的过程，随着扩展的内容越来越多，我决定这篇只写自建CA和签名SSL证书这部分，至于nginx配置https访问放到后面再写吧。</p><a id="more"></a><p>相信点进这篇文章的人应该知道为什么要自建CA和自签名SSL证书了，因为买现成的SSL证书挺贵的，SSL证书通常有三种类型：域名级（DV）、企业级（OV）、增强级（EV），价格从每年几百元到上万元不等，再细分的话还有单域名证书、通配符证书、多域名证书等等，有些证书还可以追加域名。</p><p>这笔费用对于大厂来说可能不算什么，但是对于小产品来说，即使选择最便宜的证书也是一笔开销，比如在上一篇<a href="https://blog.csdn.net/albertsh/article/details/107147803" target="_blank" rel="noopener">《根证书的应用和信任基础》</a>提到的12306官网在2017以前使用的也是用的自签名证书，一般正式产品总会咬咬牙买个证书，但是如果是本地测试，或者局域内网的使用的产品使用自建的证书就足够了，相当于我们配了临时证书资源在开发新功能，等到真正对外发布时再替换成购买的证书也来的及，所以接下来我们就一起走一遍自建证书的流程。</p><h1 id="一键生成自签名证书"><a href="#一键生成自签名证书" class="headerlink" title="一键生成自签名证书"></a>一键生成自签名证书</h1><p>总有心急的人想吃热豆腐，所以我把用到的命令写了一个脚本，只要输入几个自定义密码就可以完成CA证书和SSL证书的创建，前提是在你的电脑安装了openssl命令，在ubuntu上系统上默认就有，没有的自己安装一下吧。</p><h2 id="命令脚本"><a href="#命令脚本" class="headerlink" title="命令脚本"></a>命令脚本</h2><p>将下列命令放到shell脚本文件<code>onekeyssl</code>中执行即可</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">read</span> -p <span class="string">"Enter your domain or ip [www.example.com/10.10.49.172]: "</span> INPUT</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"1. Create ca private key..."</span></span><br><span class="line"></span><br><span class="line">openssl genrsa -des3 -out selfca.key 2048</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"2. Create ca root certificate..."</span></span><br><span class="line"></span><br><span class="line">openssl req -new -x509 -days 3650 -key selfca.key -subj <span class="string">"/C=CN/ST=BJ/L=BJ/O=MyRootCA/OU=MyCA/CN=CA"</span> -out selfca.crt</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"3. Create server key and certificate signing request..."</span></span><br><span class="line"></span><br><span class="line">openssl req -newkey rsa:2048 -nodes -keyout server.key -subj <span class="string">"/C=CN/ST=BJ/L=BJ/O=MyRootServer/OU=MyServer/CN=<span class="variable">$INPUT</span>"</span> -out server.csr</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"4. Sign SSL certificate..."</span></span><br><span class="line"></span><br><span class="line">openssl x509 -req -extfile &lt;(<span class="built_in">printf</span> <span class="string">"subjectAltName=IP:<span class="variable">$INPUT</span>"</span>) -days 3650 -<span class="keyword">in</span> server.csr -CA selfca.crt -CAkey selfca.key -CAcreateserial -out server.crt</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"5. Create end, next work..."</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Copy server.crt and server.key to your server machine"</span></span><br></pre></td></tr></table></figure><h2 id="执行结果"><a href="#执行结果" class="headerlink" title="执行结果"></a>执行结果</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">$ ./onekeyssl.sh</span><br><span class="line">Enter your domain or ip [www.example.com/10.10.49.172]: 10.10.19.1</span><br><span class="line">1. Create ca private key...</span><br><span class="line">Generating RSA private key, 2048 bit long modulus (2 primes)</span><br><span class="line">..................................................+++++</span><br><span class="line">.....................................+++++</span><br><span class="line">e is 65537 (0x010001)</span><br><span class="line">Enter pass phrase <span class="keyword">for</span> selfca.key:【输入自定义密码】</span><br><span class="line">Verifying - Enter pass phrase <span class="keyword">for</span> selfca.key:【重复密码】</span><br><span class="line">2. Create ca root certificate...</span><br><span class="line">Enter pass phrase <span class="keyword">for</span> selfca.key:【重复密码】</span><br><span class="line">3. Create server key and certificate signing request...</span><br><span class="line">Generating a RSA private key</span><br><span class="line">.............................................................+++++</span><br><span class="line">..........+++++</span><br><span class="line">writing new private key to <span class="string">'server.key'</span></span><br><span class="line">-----</span><br><span class="line">4. Sign SSL certificate...</span><br><span class="line">Signature ok</span><br><span class="line">subject=C = CN, ST = BJ, L = BJ, O = MyRootServer, OU = MyServer, CN = 10.10.19.1</span><br><span class="line">Getting CA Private Key</span><br><span class="line">Enter pass phrase <span class="keyword">for</span> selfca.key:【重复密码】</span><br><span class="line">5. Create end, next work...</span><br><span class="line">Copy server.crt and server.key to your server machine</span><br></pre></td></tr></table></figure><h1 id="分步来看看自建证书的过程"><a href="#分步来看看自建证书的过程" class="headerlink" title="分步来看看自建证书的过程"></a>分步来看看自建证书的过程</h1><p>整个过程分为自建CA和自签名SSL证书两部分：</p><p>自建CA：并不是要你自己搭建一个CA中心，这里的CA其实指的是创建自己的CA根证书，这样可以给其他人签署证书，但是这个CA根证书是你自己创建的，没有得到互联网的承认，也不会被正规CA认可，所以不具备通用和有效性，一般可以在内部网络使用。</p><p>自签名SSL证书：一般来说，我们的证书是要发给权威机构CA进行验证签署的，但是自签证书，就是自己给自己签署生成一份CA证书，或者用自建的CA根证书来签发的SSL证书，同样不具备互联网的通用和有效性，一般只用于测试环境或内部网络。</p><h2 id="自建CA根证书"><a href="#自建CA根证书" class="headerlink" title="自建CA根证书"></a>自建CA根证书</h2><p>自建CA根证书也是分成两步</p><h3 id="生成CA私钥"><a href="#生成CA私钥" class="headerlink" title="生成CA私钥"></a>生成CA私钥</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl genrsa -des3 -out selfca.key 2048</span><br></pre></td></tr></table></figure><p>这条命令使用 OpenSSL 工具生成一个带有Triple-DES（3DES）加密的密码保护的2048位RSA私钥文件，各个参数的含义如下：</p><ul><li><p><code>openssl</code>: OpenSSL 工具的命令行执行器。</p></li><li><p><code>genrsa</code>: 生成RSA密钥的命令。</p></li><li><p><code>-des3</code>: 使用Triple-DES算法对生成的私钥进行加密，这会在生成私钥时要求你设置一个密码，以便在每次使用私钥时都需要提供密码。</p></li><li><p><code>-out selfca.key</code>: 指定生成的私钥的输出文件名为 <code>selfca.key</code>，私钥文件将被保存在当前工作目录中。</p></li><li><p><code>2048</code>: 指定生成的RSA私钥的位数为2048位，这是一种常见的安全密钥长度。</p></li></ul><p>其中密码这一项在生成CA证书时我们是想加的，运行命令后需要输入一个自定义密码两次，以后每次使用这个私钥都要输入密码，但是在很多文章中你会发现他们有一步是要删除密码，原因是在一些自动化部署场景中，去掉私钥密码可以避免手动输入密码，使整个过程更加自动化，比如配置到Apache或者Nginx中时不必每次启动时输入密码，所以我们在后面生成服务器私钥时就不使用密码了。</p><p>带有密码的私钥内容</p><blockquote><p>—–BEGIN RSA PRIVATE KEY—–<br>Proc-Type: 4,ENCRYPTED<br>DEK-Info: DES-EDE3-CBC,2D6A221FF66727E0</p><p>vEzhQnjsKVBLw6tPNo6Dx7D8CyzhZdZYgfxuZBYP30cLWOORTpsS1q0txNMCaWoy<br>S79k0+qTgENne2oirALiCnPB5Rzf3vO6gv/KSScvEnGrZ6Q57i3xObhLYzCtKOAg<br>E6wSBBfbeC6cXczAFZ2ehnM42+Cv/9BX829X7BnbylNbaV1VXQTaEsmo+uWwx9dZ<br>…<br>C2udyFqENooTB7n1Qbtm3Fsruwgk/0IM3vSRk41/EWADabWs4tR/uXQmCPyxouHI<br>xhT3U4EeabyY8dyjSRCkzKPIEFl2HwnYQHZcDVUPD52uHEvA5M7c1QNgX2VmTXzP<br>AgSijAZHDrh6QWa+R9eqUVQShY4mAN7c1sv1or4ZckV7jQTbIBjUGcjhX1TooxX0<br>/RE/GLodSqD8wCkxjgD7uxy93oOLuV/9iDDsrI7VMrs5jlKhKEuPozc+Y+hERRBm<br>UUMbAE2JBW+jD/JzkmXL8w4AGU8wHeRI/FqKQXLbP6v3h+Yb4zP/aOVZ5mdWlHWT<br>1+BykB3qgKUqcn+FmRbodvK8C1G1opDchyomCToHzCGTDqAAcRPoNiB5z3jB+yPC<br>M0m83wI4rWYPghWL4hT7aZgI8l2xwTJfJfyJ+/6MfBZgh/qa4t703A==<br>—–END RSA PRIVATE KEY—–</p></blockquote><p>不带密码的私钥内容</p><blockquote><p>—–BEGIN RSA PRIVATE KEY—–<br>MIIEpQIBAAKCAQEA6OCPgi1pUWdkS9DdR2mk6QJsE9i6rCgaDuk+xyi8Sdxp2u8r<br>f81ZrK4xUNUNTX8+lnj5WeolJ/Hk1o9I659oPkbWuw7yyuCBFbZ9m3goZCt2w+lc<br>csLw6o6XyGTUiptcgB/GmGcd/ua3REAt3l6uYn32vjeit5oX5xsmsUKbwpIH/B81<br>nMohd/t6m9c0h2mcVnUYDmUsV+hmgdASvkTSmvqHOUwV1qX/pQNgjR+auLiezoza<br>LmVkvtSI9/tX6sqtlyROn7ZFsUHJbYuyfOekqLCiY5Wo5ocSTqAd4n/JYmjA6anI<br>YGDXbLcP+075ZgkHSoR9ab4uFtghStx99QYwywIDAQABAoIBAQDWeWryE2y5wiVH<br>…<br>SdwHzniXCpBpNYB6XoV57bPpQiSCqVyT9Owd0A9csZf4905dOZg+/25K2TFmv7gG<br>fHN/4EkCgYEAz7VrytExyCm1B+7sFln7c1hjy5wzNaW2tYi08szvErJkpe3jz9HH<br>MLbTn+DrXZu76nsiXfQbTl7SpPQJptHctHx7K+9mykDaJNGDDNmJRKdwi8cfINrD<br>yYPab+aojwU1FZtF8EEXKjnzWIvmM8FO71ej+COUOmDxWCsDbpoHyhA=<br>—–END RSA PRIVATE KEY—–</p></blockquote><h3 id="生成CA自签名证书"><a href="#生成CA自签名证书" class="headerlink" title="生成CA自签名证书"></a>生成CA自签名证书</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl req -new -x509 -days 3650 -key selfca.key -subj <span class="string">"/C=CN/ST=BJ/L=BJ/O=MyRootCA/OU=MyCA/CN=CA"</span> -out selfca.crt</span><br></pre></td></tr></table></figure><p>这条命令使用 OpenSSL 工具生成自签名根证书（Root Certificate），各个参数的含义如下：</p><ul><li><p><strong><code>openssl req</code>：</strong> 这是 OpenSSL 工具中用于处理证书签署请求（CSR）的命令。</p></li><li><p><strong><code>-new</code>：</strong> 表示创建新的 CSR。</p></li><li><p><strong><code>-x509</code>：</strong> 表示生成自签名的 X.509 证书，而不是生成 CSR。</p></li><li><p><strong><code>-days 3650</code>：</strong> 设置证书的有效期为 3650 天（10 年）。</p></li><li><p><strong><code>-key selfca.key</code>：</strong> 指定用于生成证书的私钥文件为 <code>selfca.key</code>。</p></li><li><p><strong><code>-subj &quot;/C=CN/ST=BJ/L=BJ/O=MyRootCA/OU=MyCA/CN=CA&quot;</code>：</strong> 设置证书主题（Subject）的信息。这里使用了简化的 Distinguished Name (DN)，包括了国家（C=CN）、省/州（ST=BJ）、城市（L=BJ）、组织（O=MyRootCA）、组织单位（OU=MyCA）、通用名称（CN=CA）等信息。</p></li><li><p><strong><code>-out selfca.crt</code>：</strong> 指定生成的证书文件的输出路径和文件名，这里为 <code>selfca.crt</code>。</p></li></ul><p>至此我们就生成了一个自签名的CA根证书，如果把它加入到操作系统或浏览器的信任列表中，那么之后由他签发的SSL证书都可以被信任了，接下来我们开始用它来签发SSL证书。</p><h2 id="自签名SSL证书"><a href="#自签名SSL证书" class="headerlink" title="自签名SSL证书"></a>自签名SSL证书</h2><p>这个过程主要包括生成服务器密钥、构建签名请求和用CA签名证书三部分，其中前两步可以合并为一步：</p><!--### 生成服务器私钥<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl genrsa -out server.key 2048</span><br></pre></td></tr></table></figure><p>这一步与生成CA私钥的命令几乎一样，只是去掉了 <code>-des3</code> 选项，不再需要密码，这样以后配置到服务器上时免去了手动输入密码的麻烦。<br>–&gt;</p><h3 id="生成服务器私钥和证书申请文件CRS"><a href="#生成服务器私钥和证书申请文件CRS" class="headerlink" title="生成服务器私钥和证书申请文件CRS"></a>生成服务器私钥和证书申请文件CRS</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ openssl req -newkey rsa:2048 -nodes -keyout server.key -subj <span class="string">"/C=CN/ST=BJ/L=BJ/O=MyRootServer/OU=MyServer/CN=10.10.49.172"</span> -out server.csr</span><br></pre></td></tr></table></figure><p>这条命令使用 OpenSSL 工具生成证书签署请求（CSR），各个参数的含义如下：</p><ul><li><p><strong><code>openssl req</code>：</strong> 这是 OpenSSL 工具中用于处理证书签署请求（CSR）的命令。</p></li><li><p><strong><code>-newkey rsa:2048</code>：</strong> 创建一个新的 RSA 密钥对，其中包括一个 2048 位的 RSA 私钥和相应的公钥。</p></li><li><p><strong><code>-nodes</code>：</strong> 生成的私钥不使用密码进行加密。这意味着私钥文件 <code>server.key</code> 将不需要密码才能访问。</p></li><li><p><strong><code>-keyout server.key</code>：</strong> 指定生成的私钥文件的输出路径和文件名，这里为 <code>server.key</code>。</p></li><li><p><strong><code>-subj &quot;/C=CN/ST=BJ/L=BJ/O=MyRootServer/OU=MyServer/CN=10.10.49.172&quot;</code>：</strong> 设置证书主题（Subject）的信息。这里使用了简化的 Distinguished Name (DN)，包括了国家（C=CN）、省/州（ST=BJ）、城市（L=BJ）、组织（O=MyRootServer）、组织单位（OU=MyServer）、通用名称（CN=10.10.49.172）等信息。通用名称（CN）通常用于指定服务器的主机名或 IP 地址。</p></li><li><p><strong><code>-out server.csr</code>：</strong> 指定生成的证书签署请求文件的输出路径和文件名，这里为 <code>server.csr</code>。</p></li></ul><h3 id="使用CA根证书签名SSL证书"><a href="#使用CA根证书签名SSL证书" class="headerlink" title="使用CA根证书签名SSL证书"></a>使用CA根证书签名SSL证书</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ openssl x509 -req -extfile &lt;(<span class="built_in">printf</span> <span class="string">"subjectAltName=IP:10.10.49.172"</span>) -days 3650 -<span class="keyword">in</span> server.csr -CA selfca.crt -CAkey selfca.key -CAcreateserial -out server.crt</span><br></pre></td></tr></table></figure><p>这条命令使用 OpenSSL 工具签署证书签署请求（CSR）并生成证书，并且带有SAN信息，各个参数的含义如下：</p><ul><li><p><strong><code>openssl x509</code>：</strong> 这是 OpenSSL 工具中用于处理 X.509 证书的命令。</p></li><li><p><strong><code>-req</code>：</strong> 表示输入的文件是证书签署请求（CSR）。</p></li><li><p><strong><code>-extfile &lt;(printf &quot;subjectAltName=IP:10.10.49.172[,DNS:&lt;YOUR_DOMAIN&gt;,...]&quot;)</code>：</strong> 使用扩展文件，该文件包含了额外的证书扩展信息。在这里，<code>subjectAltName</code> 扩展用于指定主体的备用名称（Subject Alternative Name），这里指定了 IP 地址 <code>10.10.49.172</code>。你也可以在方括号中添加其他主机名或 IP 地址，用逗号分隔。</p></li><li><p><strong><code>-days 3650</code>：</strong> 设置生成的证书的有效期为 3650 天（10 年）。</p></li><li><p><strong><code>-in server.csr</code>：</strong> 指定输入的证书签署请求文件，这里为 <code>server.csr</code>。</p></li><li><p><strong><code>-CA selfca.crt</code>：</strong> 指定用于签署证书的 CA 证书文件，这里为 <code>selfca.crt</code>。</p></li><li><p><strong><code>-CAkey selfca.key</code>：</strong> 指定用于签署证书的 CA 私钥文件，这里为 <code>selfca.key</code>。</p></li><li><p><strong><code>-CAcreateserial</code>：</strong> 创建一个新的序列号文件，该文件用于跟踪 CA 签署的证书的唯一性。</p></li><li><p><strong><code>-out server.crt</code>：</strong> 指定生成的证书文件的输出路径和文件名，这里为 <code>server.crt</code>。</p></li></ul><p>SAN（Subject Alternative Name）是 X.509 证书的一种扩展，用于指定除主题（Subject）之外的其他标识信息。主要用于解决传统的基于主题（Subject）的身份验证方式可能存在的限制，特别是在一个证书需要覆盖多个主机名或 IP 地址的情况下。</p><p>SAN 扩展可以包含多个备用名称（Alternative Name），这些备用名称可以是：</p><ol><li><p><strong>DNS Name（域名）：</strong> 用于指定主机名，可以是域名或子域名。</p></li><li><p><strong>IP Address（IP 地址）：</strong> 用于指定 IP 地址。</p></li><li><p><strong>Email Address（电子邮件地址）：</strong> 用于指定电子邮件地址。</p></li><li><p><strong>URI（统一资源标识符）：</strong> 用于指定统一资源标识符。</p></li><li><p><strong>Directory Name（目录名称）：</strong> 用于指定目录名。</p></li></ol><p>在实际使用中，SAN 可以解决多种问题，例如：</p><ul><li><p><strong>多域 SSL 证书：</strong> 当一个 SSL 证书需要覆盖多个域名时，可以使用 SAN 扩展。</p></li><li><p><strong>IP 地址验证：</strong> 当需要确保证书可以与特定 IP 地址关联时，可以使用 SAN 扩展。</p></li><li><p><strong>多级子域名：</strong> 当证书需要覆盖主域和多级子域时，可以使用 SAN 扩展。</p></li></ul><p>SAN 扩展通常在证书签署请求（CSR）或证书颁发时指定，并在证书中进行存储。在 OpenSSl 命令中，使用 <code>-extfile</code> 选项指定一个包含 SAN 信息的文件，通过该文件可以指定多个备用名称。</p><h1 id="最终的文件列表"><a href="#最终的文件列表" class="headerlink" title="最终的文件列表"></a>最终的文件列表</h1><p>至此CA根证书和自签名SSL证书就生成好了，我们一共收获到了5个文件，作用分别如下：</p><ul><li><p><code>selfca.key</code>：CA私钥，用于后续签名SSL证书</p></li><li><p><code>selfca.crt</code>：CA根证书，用于后续签名SSL证书，需要加入到操作系统或浏览器的信任列表中</p></li><li><p><code>server.key</code>：服务器私钥，需要配置到https服务，比如Apache和Nginx配置文件中</p></li><li><p><code>server.csr</code>：证书签署请求文件，后续没用了</p></li><li><p><code>server.crt</code>：自签名SSL证书，需要配置到https服务，比如Apache和Nginx配置文件中，这就是代表服务器的身份证件</p></li></ul><p>如果想查询证书信息同样可以使用 <code>openssl</code> 命令查询</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">$  openssl x509 -text -noout -<span class="keyword">in</span> server.crt</span><br><span class="line">Certificate:</span><br><span class="line">    Data:</span><br><span class="line">        Version: 3 (0x2)</span><br><span class="line">        Serial Number:</span><br><span class="line">            56:76:35:2c:61:a5:a0:7c:8c:3b:26:93:db:c2:95:a7:18:f9:95:f0</span><br><span class="line">        Signature Algorithm: sha256WithRSAEncryption</span><br><span class="line">        Issuer: C = CN, ST = BJ, L = BJ, O = MyRootCA, OU = MyCA, CN = CA</span><br><span class="line">        Validity</span><br><span class="line">            Not Before: Nov 30 14:43:32 2023 GMT</span><br><span class="line">            Not After : Nov 27 14:43:32 2033 GMT</span><br><span class="line">        Subject: C = CN, ST = BJ, L = BJ, O = MyRootServer, OU = MyServer, CN = 10.10.17.2</span><br><span class="line">        Subject Public Key Info:</span><br><span class="line">            Public Key Algorithm: rsaEncryption</span><br><span class="line">                RSA Public-Key: (2048 bit)</span><br><span class="line">                Modulus:</span><br><span class="line">                    00:b3:41:7c:58:c7:13:c1:c9:af:5b:d6:7d:cb:9a:</span><br><span class="line">                    04:f1:73:5f:60:c4:43:df:4e:26:f5:4d:da:48:f6:</span><br><span class="line">                    4f:13:90:c0:6f:17:a8:44:00:9c:3f:a5:f1:5e:6c:</span><br><span class="line">                    28:15:74:5f:c7:c5:0c:bf:a1:7b:b3:31:ac:7c:67:</span><br><span class="line">                    59:58:f6:33:<span class="built_in">cd</span>:bb:a6:45:85:98:21:c1:79:2c:b9:</span><br><span class="line">                    d2:46:9e:9c:ef:59:ba:d4:0d:fb:4c:86:81:a1:4c:</span><br><span class="line">                    a8:47:d7:4c:cf:13:89:8b:d2:6d:68:85:8f:10:26:</span><br><span class="line">                    87:15:73:ee:e6:14:36:f2:09:d3:c9:2f:f5:bf:c6:</span><br><span class="line">                    e1:ec:ee:54:06:82:83:ee:f7:70:e1:50:2e:a0:44:</span><br><span class="line">                    ce:e1:a4:f9:68:4e:e5:b4:be:39:77:02:1b:ca:c2:</span><br><span class="line">                    c9:55:72:d1:56:ca:e4:47:67:54:1b:d8:a2:83:29:</span><br><span class="line">                    02:0a:1a:b3:81:22:a0:fb:84:cf:d7:43:1c:be:37:</span><br><span class="line">                    bf:9e:04:95:ad:2e:20:ca:2f:04:c8:ef:92:26:7f:</span><br><span class="line">                    5c:f9:1c:94:6d:e5:7b:93:2a:51:fa:d2:e1:a8:87:</span><br><span class="line">                    d4:f8:aa:6d:38:d0:6a:19:8f:48:9d:3a:c3:40:bd:</span><br><span class="line">                    e9:00:ff:cf:f6:67:08:7e:ec:f2:e6:3b:b1:f5:c9:</span><br><span class="line">                    ea:f9:52:5c:f4:68:6b:ee:15:b4:<span class="built_in">fc</span>:ce:44:6d:86:</span><br><span class="line">                    4d:ef</span><br><span class="line">                Exponent: 65537 (0x10001)</span><br><span class="line">        X509v3 extensions:</span><br><span class="line">            X509v3 Subject Alternative Name:</span><br><span class="line">                IP Address:10.10.17.2</span><br><span class="line">    Signature Algorithm: sha256WithRSAEncryption</span><br><span class="line">         26:c8:f8:bd:dc:a3:67:86:e9:a9:81:ce:1a:be:a4:be:c2:f0:</span><br><span class="line">         10:cf:9f:30:1a:a8:40:ee:1a:41:ab:87:33:7e:35:2c:f0:3b:</span><br><span class="line">         9b:62:79:82:fe:7c:63:6e:e8:65:a7:2d:2e:aa:d9:73:2d:58:</span><br><span class="line">         a1:b6:70:ae:33:5f:28:27:52:a0:06:d9:37:d4:a8:70:85:73:</span><br><span class="line">         34:a4:a0:f4:f0:da:4c:9a:61:ab:74:9d:2f:ff:56:be:e4:7a:</span><br><span class="line">         c8:af:7e:f6:8a:4c:52:dc:13:db:9a:33:63:cb:79:b0:18:78:</span><br><span class="line">         f4:9e:af:dd:02:54:0b:94:b0:94:29:77:92:ae:7a:35:ca:00:</span><br><span class="line">         28:bc:be:c1:a1:1a:47:1b:72:5d:2c:1d:0e:79:e6:45:0e:3e:</span><br><span class="line">         e1:25:dc:4c:e0:cb:a0:2a:ad:98:02:d1:e3:92:68:5a:37:89:</span><br><span class="line">         5e:36:54:ec:ed:8a:b4:8b:f7:26:a9:4e:89:15:5e:ed:b1:26:</span><br><span class="line">         45:b4:03:99:37:74:c1:4c:d4:11:eb:42:3d:a4:3f:a8:30:99:</span><br><span class="line">         a0:61:08:85:f7:9e:4e:15:21:37:c3:61:ea:7e:24:3d:73:85:</span><br><span class="line">         44:28:b1:be:b5:27:26:df:38:49:43:ce:b9:96:f9:48:d4:15:</span><br><span class="line">         4b:49:e6:6c:9e:e1:21:d1:25:af:da:76:e2:7e:ca:da:9e:30:</span><br><span class="line">         60:77:53:70</span><br></pre></td></tr></table></figure><h1 id="相关名词"><a href="#相关名词" class="headerlink" title="相关名词"></a>相关名词</h1><p>写到这里虽然说了很多，但感觉还是有点不太清楚，问题出在哪里呢？貌似很多名字直接把初学者干蒙了，所以对于一些认证的名次我再简单总结一下：</p><h2 id="SSL-TLS协议"><a href="#SSL-TLS协议" class="headerlink" title="SSL/TLS协议"></a>SSL/TLS协议</h2><p>SSL: Secure Socket Layer 是由网景公司创建的，一种在互联网上提供密钥传输机制或者叫做协议。其主要目标是保证两个应用间通信数据的保密性和可靠性，可在服务器端和用户端同时支持的一种加密算法。</p><p>TLS：Transport Lanyer Security，由于网景公司的没落，IETF将SSL进行标准化，1999年公布了TLS标准文件。常用的版本：TLS v1（与SSL v3基本相同）</p><h2 id="证书颁发机构（CA）"><a href="#证书颁发机构（CA）" class="headerlink" title="证书颁发机构（CA）"></a>证书颁发机构（CA）</h2><p>CA（Certificate Authority）是一个负责签发和管理数字证书的可信任实体。数字证书用于在计算机网络上进行身份验证和加密通信。CA 的主要职责包括验证证书请求者的身份，并签发数字证书，确认公钥和身份之间的关联。</p><p>以下是 CA 的主要特征和职责：</p><ol><li><p><strong>身份验证：</strong> CA 负责验证证书请求者的身份。这通常涉及验证请求者拥有特定域名或 IP 地址的控制权。验证可以通过多种方式进行，包括域验证、组织验证等。</p></li><li><p><strong>签发证书：</strong> 一旦验证通过，CA 将签发数字证书。数字证书包含了一对密钥中的公钥，以及相关的身份信息。私钥通常由证书的所有者保管，而公钥和证书信息则被 CA 所签署。</p></li><li><p><strong>证书吊销：</strong> CA 负责在需要时吊销证书。证书可能需要吊销的原因包括证书的所有者不再控制相关私钥、证书的私钥被泄露、证书的所有者不再合法等。</p></li><li><p><strong>维护证书撤销列表（CRL）：</strong> CA 维护一个证书撤销列表，其中包含吊销的证书的信息。这允许其他实体检查某个证书是否已被吊销。</p></li><li><p><strong>数字签名：</strong> CA 使用其私钥对签发的证书进行数字签名，以确保证书的完整性和真实性。其他实体可以使用 CA 的公钥来验证数字签名。</p></li><li><p><strong>信任链：</strong> CA 的根证书被内置到操作系统和浏览器中，形成了信任链。当服务器或服务端提供由 CA 签发的证书时，客户端可以通过信任链验证证书的真实性。</p></li></ol><h2 id="数字证书（Certificate）"><a href="#数字证书（Certificate）" class="headerlink" title="数字证书（Certificate）"></a>数字证书（Certificate）</h2><p>数字证书，是一种用于电脑的身份识别机制。由数字证书颁发机构（CA）对使用私钥创建的签名请求文件做的签名（盖章），表示CA结构对证书持有者的认可。</p><p>X.509证书包含三个文件：后缀分别为key，csr和crt，在密码学中，X.509是一个标准，规范了公开秘钥认证、证书吊销列表、授权凭证、凭证路径验证算法等</p><p>key：是服务器上的私钥文件，用于对发送给客户端数据的加密，以及对从客户端接收到数据的解密</p><p>csr：是证书签名请求文件，用于提交给证书颁发机构（CA）对证书签名</p><p>crt：是由证书颁发机构（CA）签名后的证书，或者是开发者自签名的证书，包含证书持有人的信息，持有人的公钥，以及签署者的签名等信息</p><h2 id="pem文件"><a href="#pem文件" class="headerlink" title=".pem文件"></a>.pem文件</h2><p>在生成密钥的过程中通常会涉及到.pem文件，<code>.pem</code> 是一种通用的文件扩展名，表示文件内容遵循 Privacy Enhanced Mail (PEM) 格式。PEM 格式是一种基于文本的编码格式，常用于存储和传输数据，特别是涉及加密和证书的数据。PEM 格式的文件使用 ASCII 编码，以便于阅读和传输。</p><p>PEM 文件通常包含的信息类型有：</p><ol><li><p><strong>证书（Certificate）：</strong> 通常以 <code>.pem</code> 扩展名保存，包含用于公钥加密和身份验证的数字证书。</p></li><li><p><strong>私钥（Private Key）：</strong> 也可以以 <code>.pem</code> 扩展名保存，包含用于对数据进行解密和签名的私钥。</p></li><li><p><strong>证书请求（Certificate Signing Request，CSR）：</strong> 包含有关证书请求者的信息，通常用于向证书颁发机构（CA）请求签发数字证书。</p></li><li><p><strong>密钥和证书的捆绑（Bundle）：</strong> 有时，PEM 文件还可以包含密钥和证书的捆绑，以便在一个文件中同时包含私钥和相关的证书。</p></li></ol><p>PEM 格式的文件采用 Base64 编码，同时包含用于描述文件内容的文本标记。标记通常以 <code>-----BEGIN ...-----</code> 和 <code>-----END ...-----</code> 的形式出现，标记之间的内容是经过 Base64 编码的二进制数据。</p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-----BEGIN CERTIFICATE-----</span><br><span class="line">MIID...</span><br><span class="line">...</span><br><span class="line">... (Base64-encoded data)</span><br><span class="line">...</span><br><span class="line">-----END CERTIFICATE-----</span><br></pre></td></tr></table></figure><p>不同的应用程序和系统可能会使用 <code>.pem</code> 扩展名来表示各种类型的文件，因此需要根据上下文和文件内容来确定其确切的含义。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>自建CA根证书和生成SSL签名证书都可以通过 <code>openssl</code> 命令来完成</li><li>自建CA根证书结果会得到selfca.key和selfca.crt两个文件，名字可以自定义，用于后续签名服务器SSL证书</li><li>生成SSL签名证书的结果会得到server.key、server.csr、server.csr三个文件，只要把server.key和server.csr配置到服务器就好了</li><li>生成server.key时一般为了自动化维护不会设置密码，如果为了安全确实需要密码的话，可以配置到密码文件中防止服务重启时打断流程</li><li>网络的世界里证书就是身份证，在这个环境下你总要无条件信点啥，比如你的操作系统和浏览器</li></ul><h1 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h1><p>不知道你有没有注意到，用私钥签名根证书的时候并没有使用公钥，按道理说签名的时候会把公钥放到签名证书中才对，为什么这里没有呢？那是因为对于 RSA 算法，从私钥可以提取公钥，因为私钥包含了模数（modulus）和私钥指数（private exponent）。然而，从公钥（包含模数和公钥指数）推导出私钥，则取决于大数分解问题的难解性，目前尚未找到有效的算法在合理的时间内解决大整数的分解问题。所以说公钥是可以从私钥从得到的，所以不必单独获取。</p><hr><center><a href="https://blog.csdn.net/albertsh/article/details/134607439"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>兜兜又转转，有些时候真的迈出那一步就成了，想了又想是不可能前进1cm的，就像这篇总结，真的开始了，到现在也就完成了~</p></blockquote>-->]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;这是加密与认证系列的第五篇文章了，本来我是想把自建证书和nginx配置https访问总结到一起的，但是在实际操作的过程中我发现了很多细小的知识点，有些还是挺有意思的，这是一个不断自我提问不断寻求答案的过程，随着扩展的内容越来越多，我决定这篇只写自建CA和签名SSL证书这部分，至于nginx配置https访问放到后面再写吧。&lt;/p&gt;
    
    </summary>
    
      <category term="Network" scheme="http://AlbertGithubHome.github.io/blog/categories/Network/"/>
    
    
      <category term="网络" scheme="http://AlbertGithubHome.github.io/blog/tags/%E7%BD%91%E7%BB%9C/"/>
    
      <category term="https" scheme="http://AlbertGithubHome.github.io/blog/tags/https/"/>
    
      <category term="openssl" scheme="http://AlbertGithubHome.github.io/blog/tags/openssl/"/>
    
      <category term="CA根证书" scheme="http://AlbertGithubHome.github.io/blog/tags/CA%E6%A0%B9%E8%AF%81%E4%B9%A6/"/>
    
      <category term="自签名SSL证书" scheme="http://AlbertGithubHome.github.io/blog/tags/%E8%87%AA%E7%AD%BE%E5%90%8DSSL%E8%AF%81%E4%B9%A6/"/>
    
  </entry>
  
  <entry>
    <title>究竟什么是阻塞与非阻塞、同步与异步</title>
    <link href="http://AlbertGithubHome.github.io/blog/2023/11/24/%E7%A9%B6%E7%AB%9F%E4%BB%80%E4%B9%88%E6%98%AF%E9%98%BB%E5%A1%9E%E4%B8%8E%E9%9D%9E%E9%98%BB%E5%A1%9E%E3%80%81%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%BC%82%E6%AD%A5/"/>
    <id>http://AlbertGithubHome.github.io/blog/2023/11/24/究竟什么是阻塞与非阻塞、同步与异步/</id>
    <published>2023-11-24T14:08:31.000Z</published>
    <updated>2023-12-19T16:01:17.785Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这几个名词在程序开发时经常听到，但是突然问起来各个词的含义一时间还真是说不清楚，貌似这几个词都是翻译过来的，每个人的解释都不太一样，我对这几个词的理解也不是一成不变的，随着开发经验的积累，渐渐有了自己的记忆方式，所以总结一下，不一定准确，有问题可以一起聊一聊。</p><p>先说说我的结论：<strong>阻塞与非阻塞是指等待执行结果时的状态，同步与异步是指获取执行结果的方式</strong>，读起来有点绕口，听起来也迷迷糊糊的，没关系，我们用具体的例子来说明应该就容易理解了。</p><a id="more"></a><h1 id="阻塞与非阻塞"><a href="#阻塞与非阻塞" class="headerlink" title="阻塞与非阻塞"></a>阻塞与非阻塞</h1><p>先说说『阻塞与非阻塞是指等待执行结果时的状态』这一句，是说在执行某个操作或者某个函数时，在没有拿到我们想要的结果时，我们的状态是怎样的，如果是一直等就是【阻塞】的，如果发现没有结果就去做别的事情了就是【非阻塞】的。</p><p>以常见的网络IO为例，服务器对客户端连接的socket调用<code>read</code>函数，试图获取客户端发送的请求数据，但是客户端并不总是有数据发送过来，所以想要获得数据我可以采用【阻塞】方式一直等，也可以采用【非阻塞】方式，在发现此时没有数据时就先去干别的事，一会再来看看。</p><h1 id="同步与异步"><a href="#同步与异步" class="headerlink" title="同步与异步"></a>同步与异步</h1><p>再来说说『同步与异步是指获取执行结果的方式』这一句，以游戏中的常见升级发奖为例，可以主动调用升级函数，在执行完成后返回升级的结果，然后根据结果来发奖励，也就是【同步】写法，也可以注册一个监听等级变化的回调函数，注册完我就不管了，当升级时会将升级的结果通过回调函数传回来，这就是【异步】处理方式。</p><h1 id="复杂的网络IO"><a href="#复杂的网络IO" class="headerlink" title="复杂的网络IO"></a>复杂的网络IO</h1><p>为什么同步和异步没有用网络IO来举例呢？因为网络IO这里的情况更加复杂，虽然你注册了回调函数，但它很可能是个同步IO，究竟怎么回事，一起来看看。</p><p>我们知道要想从IO读取数据，需要经历「内核数据准备好」和「数据从内核态拷贝到用户态」两个过程，还是以<code>read</code>函数为例，如果设置为阻塞模式，相当于<code>read</code>函数等待了「内核数据准备好」和「数据从内核态拷贝到用户态」两个过程，然后取到IO数据，如果设置成非阻塞模式，当内核数据没准备好会直接返回，也就是不会等待第一个过程，但是当数据准备好时，会直接等待第二个过程完成后，将结果数据返回。</p><p>所以无论是否阻塞，我们都等待了第二个阶段，等着它执行完成后获取结果，所以这两种都是同步IO。</p><p>那作为IO多路复用里的“一哥”epoll也是同步IO吗？是的！那封装了select/poll/epoll的libevent可是用了Reactor模式，支持事件回调，它也是同步IO吗？是的！</p><h1 id="真正的异步IO"><a href="#真正的异步IO" class="headerlink" title="真正的异步IO"></a>真正的异步IO</h1><p>有点惊呆了不是吗？那究竟什么是异步IO呢？还真有！Windows 里实现了一套完整的支持 socket 的异步编程接口 <code>IOCP</code>，而 Linux 是在 2019 年 5.1 版本 内核首次引入的高性能异步I/O 框架 <code>io_uring</code>，我确实都没用过，感兴趣的可以试一下</p><p>是否是异步IO就看「数据从内核态拷贝到用户态」这个过程需不需要等待，如果需要逻辑层自己等待这个过程取数据就是同步IO，如果这个过程都不用等，调用回调函数时已经把内核态的数据拷贝出来，并且通过回调将数据进行了回传，这就是异步IO。</p><h1 id="IO分类与示例"><a href="#IO分类与示例" class="headerlink" title="IO分类与示例"></a>IO分类与示例</h1><p>所以总结下来一共有这么几种：同步阻塞IO，同步非阻塞IO，异步IO，为啥不区分异步阻塞IO和异步非阻塞IO呢？你在阻塞时搞个异步试试，办不到吧，所以异步只能与非阻塞搭配，也就习惯只写异步IO了。</p><p>一顿理论讲下来可能还是比较抽象，那我们再举个日常生活中的例子，比如中午买饭的过程：</p><p>同步阻塞IO就好像，你去食堂吃面条，但是你去这一锅面条还没煮好，然后你就一直在那里等啊等，等了一段时间终于做好了（数据准备的过程），但是你还得继续等工作人员把面条（内核空间）打到你的餐盘里（用户空间），才能找个桌子开始吃饭。</p><p>同步非阻塞IO就好像，你又去食堂吃饭，问大叔饭做好了没有，告诉你没有你就离开了，过了一会，你又来饭堂问大叔饭做好了吗，人家说说做好了，于是你等着把饭打到你的餐盘里，后面这个过程你是得等待的。</p><p>异步IO就好像，你在十分焦急的写BUG，这时到饭点肚子饿了，给食堂大叔打电话，等饭做好了麻烦给我送一份，等到饭好了真的送来直接就能吃了，一直在抓紧写BUG中间没有等待（做梦中）</p><p>我想大部分同学吃午饭都是第一种同步阻塞IO吧，第二种同步非阻塞IO可能也有，但是不是要重新排队啊，如果是第三种异步IO的情况，我只能说大哥/姐，我跟你混了~~</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>IO分为同步阻塞IO，同步非阻塞IO，异步IO三类</li><li>异步IO有Windows平台的 <code>IOCP</code> 和 Linux 平台的 <code>io_uring</code></li><li>从IO读取数据，需要经历「内核数据准备好」和「数据从内核态拷贝到用户态」两个过程</li><li>分析阻塞和非阻塞看是否等待第一个过程，分析同步与异步看是否等待第二个过程</li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/134149247" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>人生的岔路口，不知是机会还是风险，边走边看吧，毕竟路还是在脚下，空想也到不了终点~</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;这几个名词在程序开发时经常听到，但是突然问起来各个词的含义一时间还真是说不清楚，貌似这几个词都是翻译过来的，每个人的解释都不太一样，我对这几个词的理解也不是一成不变的，随着开发经验的积累，渐渐有了自己的记忆方式，所以总结一下，不一定准确，有问题可以一起聊一聊。&lt;/p&gt;
&lt;p&gt;先说说我的结论：&lt;strong&gt;阻塞与非阻塞是指等待执行结果时的状态，同步与异步是指获取执行结果的方式&lt;/strong&gt;，读起来有点绕口，听起来也迷迷糊糊的，没关系，我们用具体的例子来说明应该就容易理解了。&lt;/p&gt;
    
    </summary>
    
      <category term="Network" scheme="http://AlbertGithubHome.github.io/blog/categories/Network/"/>
    
    
      <category term="服务器" scheme="http://AlbertGithubHome.github.io/blog/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
      <category term="同步与异步" scheme="http://AlbertGithubHome.github.io/blog/tags/%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%BC%82%E6%AD%A5/"/>
    
      <category term="阻塞与非阻塞" scheme="http://AlbertGithubHome.github.io/blog/tags/%E9%98%BB%E5%A1%9E%E4%B8%8E%E9%9D%9E%E9%98%BB%E5%A1%9E/"/>
    
      <category term="异步IO" scheme="http://AlbertGithubHome.github.io/blog/tags/%E5%BC%82%E6%AD%A5IO/"/>
    
      <category term="Reactor" scheme="http://AlbertGithubHome.github.io/blog/tags/Reactor/"/>
    
  </entry>
  
  <entry>
    <title>git diff对比差异时指定或排除特定的文件和目录</title>
    <link href="http://AlbertGithubHome.github.io/blog/2023/10/31/git-diff%E5%AF%B9%E6%AF%94%E5%B7%AE%E5%BC%82%E6%97%B6%E6%8C%87%E5%AE%9A%E6%88%96%E6%8E%92%E9%99%A4%E7%89%B9%E5%AE%9A%E7%9A%84%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95/"/>
    <id>http://AlbertGithubHome.github.io/blog/2023/10/31/git-diff对比差异时指定或排除特定的文件和目录/</id>
    <published>2023-10-31T13:26:41.000Z</published>
    <updated>2023-12-19T15:57:40.465Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>你一般什么时候会用GPT?</p></blockquote><p>居然会有这种话题，答案就是作为程序员的我天天在用，虽然GPT有个胡说八道的毛病，但试试总没错的，就比如今天题目中这个问题，我也是先查了GPT没好使，但给我提供了查询思路，最后在Stack Overflow上找到解决办法，记录一下</p><a id="more"></a><h1 id="git-diff指定或者排除文件"><a href="#git-diff指定或者排除文件" class="headerlink" title="git diff指定或者排除文件"></a>git diff指定或者排除文件</h1><p>我就直接列答案了，没什么可说的，工具参数记住就好</p><h2 id="指定文件和目录"><a href="#指定文件和目录" class="headerlink" title="指定文件和目录"></a>指定文件和目录</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff dev..feature --<span class="built_in">stat</span>  -- <span class="string">':*.pb.go'</span> <span class="string">':*.pb.h'</span> <span class="string">':*.pb.cc'</span></span><br></pre></td></tr></table></figure><p>以上语句表示对比dev和feature分支差异的文件，但是只选择后缀为以上三种的文件，如果是特定的目录，将冒号后的内容替换成目录即可，<code>-- &#39;:src/thirdparty&#39;</code></p><h2 id="排除文件和目录"><a href="#排除文件和目录" class="headerlink" title="排除文件和目录"></a>排除文件和目录</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff dev..feature --<span class="built_in">stat</span>  -- <span class="string">':!*.pb.go'</span> <span class="string">':!*.pb.h'</span> <span class="string">':!*.pb.cc'</span></span><br></pre></td></tr></table></figure><p>在上面的基础上加个取反的感叹号就行，如果是排除目录就在 <code>!</code>直接写目录就可以了，这种排除的写法还有另一种形式，用<code>(exclude)</code>代替感叹号，其中还可以写其他属性，感兴趣可以自己扩展查询一下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff dev..feature --<span class="built_in">stat</span> -- <span class="string">':(exclude)*.pb.go'</span> <span class="string">':(exclude)*.pb.h'</span> <span class="string">':(exclude)*.pb.cc'</span></span><br></pre></td></tr></table></figure><h1 id="番外篇"><a href="#番外篇" class="headerlink" title="番外篇"></a>番外篇</h1><p>今天在某乎上看到一个提问《C++有多难？》，看着大佬们口若悬河、引经据典的在诉说、在吐槽、在愤慨，却引起了我的回忆，我为什么选择C++？</p><blockquote><p>只因为在人群中多看了一眼吧，有先入为主的因素，也有水到渠成的必然。</p></blockquote><p>我最先接触的一门编程语言是C语言，对于刚刚接触编程的我来说，它是那么令人着迷，虽然开发环境是寒酸可怜的Turbo C，但是丝毫没有影响我的学习热情，刚开始打印出一个杨辉三角都开心的不得了，教科书上的每个例子我都敲了很多遍，虽然那古老的教材现在被大佬们批判的不行，但确实领我在代码的世界里入了门。</p><p>后来随着学习的推进，又逐步接触了Java、C#等高级语言，也接触了汇编、单片机等偏底层的领域，为什么没有选Java、C#而一直坚守C语言呢？有份程序员的孤傲，当时觉得C语言很酷，我是底层我牛X，你们这些语言不是带个虚拟机，就是拖个运行时一点都Cool，那为什么不选汇编语言呢？咳咳，确实吼不住。</p><p>就这样我带着C语言，C语言伴着我开始一步步经历大学生活，当然期间也从一些“旁门左道”里习得只言片语的C++，只是我不知道它还有这个名字，带着舍我其谁的年轻气盛，我和C语言一起去参加各种编程比赛，结果有好有坏，但实力确实很菜，虽然也拿到过一些区域或者国家级的名次，但如今已成过往云烟。</p><p>转眼间就来到了大四实习，一个专业100多人，少部分人选择了苹果应用，绝大多数投身于Java开发，而我独自一人选择了嵌入式C，为什么选择嵌入式，因为只有它带“C”，也是在这短暂的几个月里我再一次听说了C++，但仅仅局限于了解C和C++有什么不同，C++好像有个class和struct挺像的。</p><p>开始真正的找工作了，受大学和室友一起打dota的影响，我毅然决然的加入了游戏开发大军，在那个各类游戏百花齐放的年代，C/C++在游戏行业有着根深蒂固的基础，因为我的C语言还不错，所以还是顺利的入了坑。</p><p>但随着踏入这个坑，我和C++开始正面交锋了，纠缠至今已经有10多年，中间工作6年之后有一次转Golang开发的机会被我拒绝了，我给那个面试官的回答是因为情怀吧，我不能离开C++。</p><p>如今我用C++20的标准在工作，与刚开始接触的C++98真的跨了一个世纪，各种语法糖之外是另一些语法糖，每个版本中标准委员会提到的特性，恨不得要3年后的要下个版本才能开发，庞大语言体系使得一些初入社会的毛头小子才配标注“精通”二字，而像我这种使用十多年的菜鸟只敢承认用过C++，略懂皮毛而已。</p><p>C++很难吗？真的很难！可不可以简单一点，其实它也可以很简单，不要拿着各种内存问题和我C++挑战，这不是我的强项，但我同样可以写出没有内存泄漏的程序；也不要拿着各种工具、运行时库和我比开发效率，这也不是我的强项，我难道就没有库吗，开源的世界里百花齐放。</p><p>不要一提到C++就是面向对象、STL、模板元编程，它是一门编程语言，一门用于完成任务的可编写逻辑的语言，用它写一个冒泡排序也很简单，不要过分夸大他的难度，每次你都把它最难的地方亮出来，对它来说是不公平的。</p><p>如今，我不会再说C++就是牛X其他语言都是垃圾这种脑抽的话，C++只是一种语言，一种我暂时还离不开的语言，但它不再是我的唯一，写个小工具偶尔也会使用Python或者Golang，不是我不再爱C++，而是有了更合适的选择而已。</p><p>C++，一门集强大与庞大于一身的语言，学会它容易，但学透它确实很难，我们在一起共同成长。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>GPT无处不在，每天必用超过了google</li><li>git diff 指定文件类型 <code>git diff dev..feature -- &#39;:*.pb.go&#39; &#39;:*.pb.h&#39; &#39;:*.pb.cc&#39;</code></li><li>git diff 排除文件类型 <code>git diff dev..feature -- &#39;:!*.pb.go&#39; &#39;:!*.pb.h&#39; &#39;:!*.pb.cc&#39;</code></li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/134000167" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>每天提问自己一个问题，试验一段时间，看看是否有效吧，本质还是眼高手低造成了目前的焦虑</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;你一般什么时候会用GPT?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;居然会有这种话题，答案就是作为程序员的我天天在用，虽然GPT有个胡说八道的毛病，但试试总没错的，就比如今天题目中这个问题，我也是先查了GPT没好使，但给我提供了查询思路，最后在Stack Overflow上找到解决办法，记录一下&lt;/p&gt;
    
    </summary>
    
      <category term="Git" scheme="http://AlbertGithubHome.github.io/blog/categories/Git/"/>
    
    
      <category term="git" scheme="http://AlbertGithubHome.github.io/blog/tags/git/"/>
    
      <category term="diff" scheme="http://AlbertGithubHome.github.io/blog/tags/diff/"/>
    
      <category term="gpt" scheme="http://AlbertGithubHome.github.io/blog/tags/gpt/"/>
    
      <category term="c++" scheme="http://AlbertGithubHome.github.io/blog/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>linux环境下使用timeout监控命令执行超过5分钟后发送通知</title>
    <link href="http://AlbertGithubHome.github.io/blog/2023/10/23/linux%E7%8E%AF%E5%A2%83%E4%B8%8B%E4%BD%BF%E7%94%A8timeout%E7%9B%91%E6%8E%A7%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E8%B6%85%E8%BF%875%E5%88%86%E9%92%9F%E5%90%8E%E5%8F%91%E9%80%81%E9%80%9A%E7%9F%A5/"/>
    <id>http://AlbertGithubHome.github.io/blog/2023/10/23/linux环境下使用timeout监控命令执行超过5分钟后发送通知/</id>
    <published>2023-10-23T14:35:37.000Z</published>
    <updated>2023-12-19T15:56:57.530Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>有一段时间没写了，马上1024了，总得有点输出吧，想到最近用了一个挺有用的命令 <code>timeout</code>   ，所以拿出来简单展示一下它的用法，作用就是可以给指定命令设置超时时间，相当于扩展了原命令，对于一般没有超时参数的命令是个方便的扩展方式，可以增加超时处理。</p><a id="more"></a><h1 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h1><p>使用方法也非常简单，下面是一个简单的示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置超时时间（秒）</span></span><br><span class="line">TIMEOUT=300</span><br><span class="line"></span><br><span class="line"><span class="comment"># 要监控的命令</span></span><br><span class="line">./hooks/rsync.sh &amp;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取命令的进程ID</span></span><br><span class="line">command_pid=$!</span><br><span class="line"></span><br><span class="line"><span class="comment"># 等待命令执行完成，或者直到超时</span></span><br><span class="line">timeout <span class="variable">$TIMEOUT</span> tail --pid=<span class="variable">$command_pid</span> -f /dev/null</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查是否超时</span></span><br><span class="line"><span class="keyword">if</span> [ $? -eq 124 ]; <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"timeout"</span></span><br><span class="line">  iostat -d -x 2 9</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"normal"</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p><code>tail --pid=$command_pid -f /dev/null</code> 这个命令是用来等待指定进程 <code>$command_pid</code> 结束的同时保持脚本的运行，以确保后续的超时检查。</p><ul><li><p><code>tail</code> 是一个用于显示文件末尾内容的命令，通常用于查看日志文件。</p></li><li><p><code>--pid=$command_pid</code> 是 <code>tail</code> 命令的一个选项。它告诉 <code>tail</code> 命令在结束之前等待指定的进程 <code>$command_pid</code> 完成。这是通过监视 <code>/proc/$command_pid/fd/1</code> 文件（进程的标准输出）来实现的，以便在进程结束时 <code>tail</code> 命令也会退出。</p></li><li><p><code>-f /dev/null</code> 表示 <code>tail</code> 命令要查看 <code>/dev/null</code> 文件的内容，但 <code>/dev/null</code> 文件是一个空文件，所以它不会产生输出。这里的目的是让 <code>tail</code> 命令一直运行，直到 <code>$command_pid</code> 进程结束。</p></li></ul><p>这种构造的作用是等待命令执行完成，但在等待的过程中不产生输出。一旦 <code>$command_pid</code> 进程结束，<code>tail</code> 命令也会退出，允许脚本继续执行后续操作，如检查是否超时。</p><ul><li><p><code>if [ $? -eq 124 ]; then ... else ...:</code>这一段是条件语句，用于检查timeout命令的返回状态。如果返回状态是124，意味着rsync.sh脚本执行超时，那么它会打印”timeout”以指示发生了超时，并且运行iostat -d -x 2 9命令来获取磁盘I/O统计信息。</p></li><li><p>如果timeout命令的返回状态不是124，即没有发生超时，它将执行else部分打印”normal”以指示命令正常执行。</p></li></ul><h1 id="其他有趣的命令"><a href="#其他有趣的命令" class="headerlink" title="其他有趣的命令"></a>其他有趣的命令</h1><p>类似这种监控或者扩展的命令还有：</p><ul><li><code>time</code>，于测量命令执行的时间。它会运行一个命令，并报告命令执行所花费的实际时间（包括用户CPU时间和系统CPU时间），通常用于性能分析和优化。例如 <code>time my_command</code>，</li><li><code>at</code>，可以计划执行一次性任务，比如将在15:30执行命令<code>echo &quot;my_command&quot; | at 15:30</code></li><li><code>nohup</code>，用于在后台运行命令，比如 <code>nohup my_command &gt; output.log 2&gt;&amp;1 &amp;</code></li></ul><h1 id="系统资源查询命令"><a href="#系统资源查询命令" class="headerlink" title="系统资源查询命令"></a>系统资源查询命令</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">date &gt;&gt; /tmp/slow.log</span><br><span class="line">iostat -d -x 2 5 &gt;&gt; /tmp/slow.log</span><br><span class="line">vmstat -n 2 5 &gt;&gt; /tmp/slow.log</span><br><span class="line">sar -B 2 5 &gt;&gt; /tmp/slow.log</span><br><span class="line">top -b -n 3 | grep <span class="string">"md5sum"</span> &gt;&gt; /tmp/slow.log</span><br></pre></td></tr></table></figure><p>有时发现系统总是被无故拖慢，有些进程迟迟不能结束，虽然有监控grafana大盘可以查，但是有些参数不太细致，可以上面展示的这些命令来临时查一下，它们的含义如下：</p><ol><li><p><strong>iostat -d -x 2 5 &gt;&gt; /tmp/slow.log</strong>：</p><ul><li><code>iostat</code> 用于报告系统磁盘活动和性能</li><li><code>-d</code> 选项表示只显示磁盘相关的信息</li><li><code>-x</code> 选项用于显示扩展的磁盘统计信息</li><li><code>2</code> 表示每隔2秒报告一次</li><li><code>5</code> 表示报告5次</li></ul></li><li><p><strong>vmstat -n 2 5 &gt;&gt; /tmp/slow.log</strong>：</p><ul><li><code>vmstat</code> 用于显示虚拟内存统计</li><li><code>-n</code> 选项用于指定输出中不显示表头</li></ul></li><li><p><strong>sar -B 2 5 &gt;&gt; /tmp/slow.log</strong>：</p><ul><li><code>sar</code> 用于系统性能数据采集和报告</li><li><code>-B</code> 选项用于报告缓冲区和页缓存统计信息</li></ul></li><li><p><strong>top -b -n 3 | grep “md5sum” &gt;&gt; /tmp/slow.log</strong>：</p><ul><li><code>top</code> 用于实时查看系统中正在运行的进程和其性能</li><li><code>-b</code> 选项表示以批处理模式运行，适用于脚本</li><li><code>-n 3</code> 表示运行3次 <code>top</code></li><li><code>grep &quot;md5sum&quot;</code> 用于筛选包含 “md5sum” 的行，以查找与 “md5sum” 相关的进程</li></ul></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">Fri Oct 20 13:36:31 CST 2023</span><br><span class="line">Linux 3.10.0-1160.88.1.el7.x86_64 (demo-machine)        10/20/2023      &gt;_x86_64_        (8 CPU)</span><br><span class="line"></span><br><span class="line">Device:         rrqm/s   wrqm/s     r/s     w/s    rkB/s    wkB/s avgrq-sz &gt;avgqu-sz   await r_await w_await  svctm  %util</span><br><span class="line">fd0               0.00     0.00    0.00    0.00     0.00     0.00     8.00     &gt;0.00  136.50  136.50    0.00 136.50   0.00</span><br><span class="line">sdb               0.00     0.00    1.98    0.02   179.62     6.55   186.84     &gt;0.06   32.16   30.23  265.38   1.45   0.29</span><br><span class="line">sda               0.00     0.02    0.01    0.23     0.27     1.98    18.70     &gt;0.00    9.97  103.14    6.89   1.96   0.05</span><br><span class="line"></span><br><span class="line">Device:         rrqm/s   wrqm/s     r/s     w/s    rkB/s    wkB/s avgrq-sz &gt;avgqu-sz   await r_await w_await  svctm  %util</span><br><span class="line">fd0               0.00     0.00    0.00    0.00     0.00     0.00     0.00     &gt;0.00    0.00    0.00    0.00   0.00   0.00</span><br><span class="line">sdb               0.00     0.00    1.47    0.00   598.04     0.00   813.33     &gt;0.13   86.33   86.33    0.00  42.33   6.23</span><br><span class="line">sda               0.00     0.00    0.49    0.98     3.92     2.70     9.00     &gt;0.01   10.00   30.00    0.00  10.00   1.47</span><br><span class="line"></span><br><span class="line">Device:         rrqm/s   wrqm/s     r/s     w/s    rkB/s    wkB/s avgrq-sz &gt;avgqu-sz   await r_await w_await  svctm  %util</span><br><span class="line">fd0               0.00     0.00    0.00    0.00     0.00     0.00     0.00     &gt;0.00    0.00    0.00    0.00   0.00   0.00</span><br><span class="line">sdb               0.00     0.00    0.99    0.00   392.08     0.00   792.00     &gt;0.02   19.00   19.00    0.00   9.50   0.94</span><br><span class="line">sda               0.00     0.00    0.00    0.00     0.00     0.00     0.00     &gt;0.00    0.00    0.00    0.00   0.00   0.00</span><br><span class="line"></span><br><span class="line">Device:         rrqm/s   wrqm/s     r/s     w/s    rkB/s    wkB/s avgrq-sz &gt;avgqu-sz   await r_await w_await  svctm  %util</span><br><span class="line">fd0               0.00     0.00    0.00    0.00     0.00     0.00     0.00     &gt;0.00    0.00    0.00    0.00   0.00   0.00</span><br><span class="line">sdb               0.00     0.00    4.00    0.00  1776.00     0.00   888.00     &gt;0.06   15.25   15.25    0.00   2.62   1.05</span><br><span class="line">sda               0.00     0.00    0.00    1.50     0.00     6.00     8.00     &gt;0.00    2.00    0.00    2.00   0.67   0.10</span><br><span class="line"></span><br><span class="line">Device:         rrqm/s   wrqm/s     r/s     w/s    rkB/s    wkB/s avgrq-sz &gt;avgqu-sz   await r_await w_await  svctm  %util</span><br><span class="line">fd0               0.00     0.00    0.00    0.00     0.00     0.00     0.00     &gt;0.00    0.00    0.00    0.00   0.00   0.00</span><br><span class="line">sdb               0.00     0.00    4.23    0.00  2066.15     0.00   976.73     &gt;0.13   31.00   31.00    0.00   3.55   1.50</span><br><span class="line">sda               0.00     0.00    0.00    0.00     0.00     0.00     0.00     &gt;0.00    0.00    0.00    0.00   0.00   0.00</span><br><span class="line"></span><br><span class="line">procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----</span><br><span class="line"> r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st</span><br><span class="line"> 2  0      0 162364      0 12586664    0    0    23     1    0    1  0  0 100  0  0</span><br><span class="line"> 2  0      0 158892      0 12565264    0    0     0     0 3209  413  0  8 92  0  0</span><br><span class="line"> 2  0      0 165976      0 12543900    0    0     0     0 1879  332  0  5 95  0  0</span><br><span class="line"> 2  0      0 163496      0 12523372    0    0   396     0 2844  678  0  8 92  0  0</span><br><span class="line"> 3  0      0 162240      0 12502092    0    0     0     0 2038  574  0  7 93  0  0</span><br><span class="line">Linux 3.10.0-1160.88.1.el7.x86_64 (demo-machine)        10/20/2023      &gt;_x86_64_        (8 CPU)</span><br><span class="line"></span><br><span class="line">01:36:48 PM  pgpgin/s pgpgout/s   fault/s  majflt/s  pgfree/s pgscank/s pgscand/s &gt;pgsteal/s    %vmeff</span><br><span class="line">01:36:50 PM   1674.00      0.00   3098.00      0.00   3431.00   3362.00      &gt;0.00   3362.00    100.00</span><br><span class="line">01:36:52 PM      0.00      0.00   2874.50      0.00   2675.00   2650.50      &gt;0.00   2650.50    100.00</span><br><span class="line">01:36:54 PM   2822.00      0.00   2478.50      0.00   2666.50   2645.00      &gt;0.00   2645.00    100.00</span><br><span class="line">01:36:56 PM      0.00      0.50   1248.50      0.00 156173.00   2642.00      &gt;0.00   2642.00    100.00</span><br><span class="line">01:36:58 PM      0.00      0.00   1975.00      0.00    321.50      0.00      &gt;0.00      0.00      0.00</span><br><span class="line">Average:       899.20      0.10   2334.90      0.00  33053.40   2259.90      0.00   2259.90    100.00</span><br><span class="line"> 5667 root      20   0 1455484  54400   1256 R 100.0  0.3   3:54.39 md5sum</span><br><span class="line"> 5667 root      20   0 1455484  75784   1256 R 100.0  0.5   3:57.40 md5sum</span><br><span class="line"> 5667 root      20   0 1455484  98752   1256 R 100.0  0.6   4:00.41 md5sum</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li><code>timeout</code> 可以给其他命令设置超时时间</li><li><code>at</code> 可以计划执行一次性任务</li><li><code>iostat -d -x 2 5</code> 用于报告系统磁盘活动和性能</li><li><code>vmstat -n 2 5</code> 用于显示虚拟内存统计</li><li><code>sar -B 2 5</code> 用于系统性能数据采集和报告</li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/133689734" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>心态还是很难调整好，大道理学了这么久，发现都是讲给别人听的，根本治愈不了自己，该歇歇了~</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;有一段时间没写了，马上1024了，总得有点输出吧，想到最近用了一个挺有用的命令 &lt;code&gt;timeout&lt;/code&gt;   ，所以拿出来简单展示一下它的用法，作用就是可以给指定命令设置超时时间，相当于扩展了原命令，对于一般没有超时参数的命令是个方便的扩展方式，可以增加超时处理。&lt;/p&gt;
    
    </summary>
    
      <category term="linux" scheme="http://AlbertGithubHome.github.io/blog/categories/linux/"/>
    
    
      <category term="linux" scheme="http://AlbertGithubHome.github.io/blog/tags/linux/"/>
    
      <category term="运维" scheme="http://AlbertGithubHome.github.io/blog/tags/%E8%BF%90%E7%BB%B4/"/>
    
      <category term="服务器" scheme="http://AlbertGithubHome.github.io/blog/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
      <category term="timeout" scheme="http://AlbertGithubHome.github.io/blog/tags/timeout/"/>
    
      <category term="iostat" scheme="http://AlbertGithubHome.github.io/blog/tags/iostat/"/>
    
  </entry>
  
  <entry>
    <title>废了九牛二虎之力终于修改了MySQL8.0的root密码</title>
    <link href="http://AlbertGithubHome.github.io/blog/2023/10/08/%E5%BA%9F%E4%BA%86%E4%B9%9D%E7%89%9B%E4%BA%8C%E8%99%8E%E4%B9%8B%E5%8A%9B%E7%BB%88%E4%BA%8E%E4%BF%AE%E6%94%B9%E4%BA%86MySQL8-0%E7%9A%84root%E5%AF%86%E7%A0%81/"/>
    <id>http://AlbertGithubHome.github.io/blog/2023/10/08/废了九牛二虎之力终于修改了MySQL8-0的root密码/</id>
    <published>2023-10-08T12:56:28.000Z</published>
    <updated>2023-10-08T15:10:27.895Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>上次说到在Ubuntu系统上安装MySQL8.0之后默认是没有密码的，如果想设置密码需要写成<code>ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED WITH mysql_native_password BY &#39;xxx&#39;;</code> 的形式，其实在用这种方式之前，我还使用功能了mysql_secure_installation这个MySQL自带的程序来设置密码，但是没生效，为什么这个看起来很正规的方式不生效的呢？接下来一起找找原因。</p><a id="more"></a><h1 id="使用mysql-secure-installation"><a href="#使用mysql-secure-installation" class="headerlink" title="使用mysql_secure_installation"></a>使用mysql_secure_installation</h1><p>使用步骤比较简单，就按照提示来输入就可以了，这是我第二次运行，第一次运行时还要加个 ‘Would you like to setup VALIDATE PASSWORD component?’ 步骤</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">root@w-dev:~<span class="comment"># mysql_secure_installation</span></span><br><span class="line"></span><br><span class="line">Securing the MySQL server deployment.</span><br><span class="line"></span><br><span class="line">Enter password <span class="keyword">for</span> user root:</span><br><span class="line">The <span class="string">'validate_password'</span> component is installed on the server.</span><br><span class="line">The subsequent steps will run with the existing configuration</span><br><span class="line">of the component.</span><br><span class="line">Using existing password <span class="keyword">for</span> root.</span><br><span class="line"></span><br><span class="line">Estimated strength of the password: 50</span><br><span class="line">Change the password <span class="keyword">for</span> root ? ((Press y|Y <span class="keyword">for</span> Yes, any other key <span class="keyword">for</span> No) : y</span><br><span class="line"></span><br><span class="line">New password:</span><br><span class="line"></span><br><span class="line">Re-enter new password:</span><br><span class="line"></span><br><span class="line">Estimated strength of the password: 50</span><br><span class="line">Do you wish to <span class="built_in">continue</span> with the password provided?(Press y|Y <span class="keyword">for</span> Yes, any other key <span class="keyword">for</span> No) : y</span><br><span class="line">By default, a MySQL installation has an anonymous user,</span><br><span class="line">allowing anyone to <span class="built_in">log</span> into MySQL without having to have</span><br><span class="line">a user account created <span class="keyword">for</span> them. This is intended only <span class="keyword">for</span></span><br><span class="line">testing, and to make the installation go a bit smoother.</span><br><span class="line">You should remove them before moving into a production</span><br><span class="line">environment.</span><br><span class="line"></span><br><span class="line">Remove anonymous users? (Press y|Y <span class="keyword">for</span> Yes, any other key <span class="keyword">for</span> No) : y</span><br><span class="line">Success.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Normally, root should only be allowed to connect from</span><br><span class="line"><span class="string">'localhost'</span>. This ensures that someone cannot guess at</span><br><span class="line">the root password from the network.</span><br><span class="line"></span><br><span class="line">Disallow root login remotely? (Press y|Y <span class="keyword">for</span> Yes, any other key <span class="keyword">for</span> No) : y</span><br><span class="line">Success.</span><br><span class="line"></span><br><span class="line">By default, MySQL comes with a database named <span class="string">'test'</span> that</span><br><span class="line">anyone can access. This is also intended only <span class="keyword">for</span> testing,</span><br><span class="line">and should be removed before moving into a production</span><br><span class="line">environment.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Remove <span class="built_in">test</span> database and access to it? (Press y|Y <span class="keyword">for</span> Yes, any other key <span class="keyword">for</span> No) : y</span><br><span class="line"> - Dropping <span class="built_in">test</span> database...</span><br><span class="line">Success.</span><br><span class="line"></span><br><span class="line"> - Removing privileges on <span class="built_in">test</span> database...</span><br><span class="line">Success.</span><br><span class="line"></span><br><span class="line">Reloading the privilege tables will ensure that all changes</span><br><span class="line">made so far will take effect immediately.</span><br><span class="line"></span><br><span class="line">Reload privilege tables now? (Press y|Y <span class="keyword">for</span> Yes, any other key <span class="keyword">for</span> No) : y</span><br><span class="line">Success.</span><br><span class="line"></span><br><span class="line">All <span class="keyword">done</span>!</span><br></pre></td></tr></table></figure><p>那么这个程序具体干了哪些事呢，下面来解释一下。</p><p>mysql_secure_installation 是一个 MySQL 提供的命令行工具，用于帮助加强和改善 MySQL 服务器的安全性。当首次安装 MySQL 后，运行此工具可以执行一系列的操作来提高 MySQL 服务器的安全性，并确保默认设置不会导致潜在的安全漏洞。以下是 mysql_secure_installation 工具执行的主要任务：</p><p><strong>设置 root 密码：</strong> 如果您在安装 MySQL 时没有为 root 用户设置密码，mysql_secure_installation 会提示您设置 root 密码。设置 root 密码是非常重要的，因为 root 用户具有最高的权限，拥有对 MySQL 服务器的完全控制。</p><p><strong>删除匿名用户：</strong> mysql_secure_installation 会删除默认情况下存在的匿名用户。匿名用户是指没有用户名和密码就能访问 MySQL 服务器的用户。删除这些用户可以减少潜在的安全风险。</p><p><strong>禁止远程 root 登录：</strong> 默认情况下，MySQL 允许 root 用户从任何主机登录。mysql_secure_installation 会提示您是否禁止 root 用户从远程主机登录，以减少潜在的远程攻击风险。</p><p><strong>删除测试数据库：</strong> 默认情况下，MySQL 安装包含一个名为 “test” 的测试数据库，这个数据库可能会成为潜在的攻击目标。mysql_secure_installation 会提示您是否删除测试数据库。</p><p><strong>刷新权限：</strong> 完成上述任务后，mysql_secure_installation 会刷新 MySQL 权限表，以确保更改生效。</p><p>mysql_secure_installation 工具有助于在 MySQL 安装完成后采取一些基本的安全措施，以减少潜在的风险和攻击。然而，这只是开始，为了更好地保护 MySQL 服务器和数据，您还应该采取其他安全措施，如定期备份、限制用户权限、监控数据库活动等。</p><h1 id="mysql-secure-installation-为什么设置root密码无效"><a href="#mysql-secure-installation-为什么设置root密码无效" class="headerlink" title="mysql_secure_installation 为什么设置root密码无效"></a>mysql_secure_installation 为什么设置root密码无效</h1><p>看上面的描述这个程序挺靠谱的，为啥设置密码不好使呢？遵循着网络大神们的脚本，我找到了一个 <a href="https://github.com/twitter-forks/mysql/blob/master/scripts/mysql_secure_installation.sh" target="_blank" rel="noopener">mysql_secure_installation.sh</a>脚本，来自[twitter-forks/mysql]开源库，其中包含这样一段代码：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">esc_pass=`basic_single_escape "$password1"`</span><br><span class="line">do_query "UPDATE mysql.user SET Password=PASSWORD('$esc_pass') WHERE User='root';"</span><br><span class="line">if [ $? -eq 0 ]; then</span><br><span class="line">echo "Password updated successfully!"</span><br><span class="line">echo "Reloading privilege tables.."</span><br><span class="line">reload_privilege_tables</span><br><span class="line">if [ $? -eq 1 ]; then</span><br><span class="line">    clean_and_exit</span><br><span class="line">fi</span><br><span class="line">echo</span><br><span class="line">rootpass=$password1</span><br><span class="line">make_config</span><br><span class="line">else</span><br><span class="line">echo "Password update failed!"</span><br><span class="line">clean_and_exit</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p><code>&quot;UPDATE mysql.user SET Password=PASSWORD(&#39;$esc_pass&#39;) WHERE User=&#39;root&#39;;&quot;</code> 这个脚本里居然用了我们之前提到的已经失效的更新方式，但是我发现我在Ubuntu系统下安装的mysql_secure_installation是一个二进制程序，不是shell脚本，所以我又找到了<a href="https://github.com/mysql/mysql-server/blob/8.0/client/mysql_secure_installation.cc#L425" target="_blank" rel="noopener">mysql的源码</a>程序，其中包含这样一段：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">  query =</span><br><span class="line">      (<span class="keyword">char</span> *)my_malloc(PSI_NOT_INSTRUMENTED, password_len + <span class="number">50</span>, MYF(MY_WME));</span><br><span class="line">  end = my_stpmov(query, <span class="string">"SET PASSWORD="</span>);</span><br><span class="line">  *end++ = <span class="string">'\''</span>;</span><br><span class="line">  end += mysql_real_escape_string_quote(mysql, end, password,</span><br><span class="line">                                        (ulong)password_len, <span class="string">'\''</span>);</span><br><span class="line">  *end++ = <span class="string">'\''</span>;</span><br><span class="line">  <span class="keyword">if</span> (mysql_real_query(mysql, query, (ulong)(end - query))) &#123;</span><br><span class="line">    my_free(query);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>里面包含了<code>&quot;SET PASSWORD=&quot;</code>的字样，看起来不太靠谱的样子，需要注意的是，在 MySQL 5.7 版本之后，<code>SET PASSWORD</code> 命令已被弃用，推荐使用 <code>ALTER USER</code> 命令来修改密码。例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">USER</span> <span class="string">'root'</span>@<span class="string">'localhost'</span> <span class="keyword">IDENTIFIED</span> <span class="keyword">BY</span> <span class="string">'新密码'</span>;</span><br></pre></td></tr></table></figure><p>这个命令更加直观，并且与最新版本的 MySQL 兼容。同样，将 <code>&#39;新密码&#39;</code> 替换为您希望设置的新密码。</p><p>难道是MySQL 8.0没有更新工具的代码？暂时不得而知，这或许就是mysql_secure_installation设置密码不生效的原因。</p><h1 id="ALTER-USER再生事端"><a href="#ALTER-USER再生事端" class="headerlink" title="ALTER USER再生事端"></a>ALTER USER再生事端</h1><p>前文提到了一种更加直观的设置新密码的方式 <code>ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;新密码&#39;;</code>，但是在我这行不通，不仅我这行不通，网上也有很多人说设置不了，需要加上插件名称 <code>WITH mysql_native_password</code>，改为 <code>ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED WITH mysql_native_password BY &#39;新密码&#39;;</code> 才可以，这又是为什么呢？</p><p>执行 <code>select host,user,plugin,authentication_string from mysql.user;</code> 语句查看发现：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select host,user,plugin,authentication_string from mysql.user;</span><br><span class="line">+<span class="comment">-----------+------------------+-----------------------+------------------------------------------------------------------------+</span></span><br><span class="line">| host      | user             | plugin                | authentication_string                                                  |</span><br><span class="line">+<span class="comment">-----------+------------------+-----------------------+------------------------------------------------------------------------+</span></span><br><span class="line">| localhost | zone1            | mysql_native_password | *4C7684A2CD28A1C3C55CC832E6O817FCE3C5B5DB                              |</span><br><span class="line">| localhost | mysql.infoschema | caching_sha2_password | $A$005$THISISACOMBINATIONOFINVALIDSALTANDPASSWORDTHATMUSTNEVERBRBEUSED |</span><br><span class="line">| localhost | mysql.session    | caching_sha2_password | $A$005$THISISACOMBINATIONOFINVALIDSALTANDPASSWORDTHATMUSTNEVERBRBEUSED |</span><br><span class="line">| localhost | mysql.sys        | caching_sha2_password | $A$005$THISISACOMBINATIONOFINVALIDSALTANDPASSWORDTHATMUSTNEVERBRBEUSED |</span><br><span class="line">| localhost | root             | auth_socket           |                                                                        |</span><br><span class="line">| localhost | admin            | mysql_native_password | *F52COBE5FFB5FFCCD5BFD976OADEB81081AE4787                              |</span><br><span class="line">+<span class="comment">-----------+------------------+-----------------------+------------------------------------------------------------------------+</span></span><br></pre></td></tr></table></figure><p>原来每个账户还有默认的不同的密码管理插件，用于验证和管理用户密码，mysql_native_password、auth_socket和caching_sha2_password这三种插件的含义如下：</p><h2 id="mysql-native-password"><a href="#mysql-native-password" class="headerlink" title="mysql_native_password"></a>mysql_native_password</h2><ul><li>加密算法： 使用较旧的哈希算法，如SHA-1或SHA-256，取决于 MySQL 版本。</li><li>认证方式： 用户密码以哈希形式存储在系统表中，服务器在用户登录时将明文密码哈希并与数据库中存储的哈希进行比较。</li><li>支持远程登录： 支持远程密码登录，可以从远程主机登录 MySQL。</li><li>适用场景： 适用于需要与旧版 MySQL 兼容或需要与其他应用程序或系统进行集成的情况。</li></ul><h2 id="caching-sha2-password"><a href="#caching-sha2-password" class="headerlink" title="caching_sha2_password"></a>caching_sha2_password</h2><ul><li>加密算法： 使用 SHA-256 进行加密，提供更高级别的安全性。</li><li>支持版本： 从 MySQL 5.7.4 开始，caching_sha2_password 成为默认的密码插件。</li><li>认证方式： 用户密码以加密形式存储在系统表中，并且在用户登录时，服务器将明文密码哈希并与数据库中存储的哈希进行比较。</li><li>支持远程登录： 支持远程密码登录，可以从远程主机登录 MySQL。</li></ul><h2 id="auth-socket"><a href="#auth-socket" class="headerlink" title="auth_socket"></a>auth_socket</h2><ul><li>认证方式： 不存储密码哈希，而是依赖于操作系统（Linux）的用户认证机制。只有与操作系统用户账户关联的 MySQL 用户可以登录，而不需要密码。</li><li>适用场景： 通常用于本地连接，因为它要求数据库用户和操作系统用户名称一致。</li><li>安全性： 提供了一定的安全性，因为不需要存储密码哈希，但需要确保服务器的用户账户和 MySQL 用户账户的一致性。</li></ul><p>总结来说，这些密码插件之间的区别主要涉及到加密算法、认证方式以及适用场景。caching_sha2_password 提供更高级别的安全性，而 auth_socket 依赖于操作系统用户认证机制，mysql_native_password 则提供与旧版 MySQL 兼容性。使用前应根据安全性需求、用户管理和应用程序集成的要求来选择合适的密码插件。一般来说，推荐使用较新且安全性更高的密码插件，如caching_sha2_password。</p><p>测试后发现，MySQL8.0默认安装后root用户的默认插件是 <code>auth_socket</code>，这种插件没办法设置密码，所以指定插件为 <code>mysql_native_password</code> 时就可以设置密码了，但是根据建议，我们应该选择 <code>caching_sha2_password</code>插件。</p><h1 id="肯定好使的MySQL初始化方法"><a href="#肯定好使的MySQL初始化方法" class="headerlink" title="肯定好使的MySQL初始化方法"></a>肯定好使的MySQL初始化方法</h1><ul><li><code>apt install mysql-server</code></li><li><code>mysql</code></li><li><code>ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED WITH caching_sha2_password BY &#39;新密码&#39;;</code></li><li><code>flush privileges;</code></li><li><code>exit;</code></li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>安装MySQL8.0后使用<code>ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED WITH caching_sha2_password BY &#39;xxx&#39;;</code>设置密码</li><li>mysql_secure_installation工具不好使的原因目前来看是源代码没有工具的源代码没有及时更新，与MySQL版本不匹配</li><li>mysql_secure_installation另外的几项功能，比如删除匿名用户、删除测试数据库、禁止远程登录在安装完貌似都处理好了</li><li>综上来看，难道mysql_secure_installation工具已经被废弃了？</li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/132701267" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>你们的一切都是我的，只要留心你将获得无穷的助力，很多东西不必从头开始，既然做不成巨人，就从巨人的肩膀上出发吧~</p><p>证件照尺寸查询<br>一寸    295<em>413px   | 25</em>35mm<br>二寸    413<em>579px   | 35</em>49mm<br>小一寸  260<em>378px   | 22</em>32mm<br>大一寸  390<em>567px   | 33</em>48mm<br>小二寸  413<em>531px   | 35</em>45mm<br>大二寸  413<em>626px   | 35</em>53mm<br>三寸    650<em>992px   | 55</em>84mm<br>四寸    898<em>1181px  | 76</em>100mm<br>五寸    1050<em>1500px | 89</em>127mm</p><p>2023-10-8 20:56:28</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;上次说到在Ubuntu系统上安装MySQL8.0之后默认是没有密码的，如果想设置密码需要写成&lt;code&gt;ALTER USER &amp;#39;root&amp;#39;@&amp;#39;localhost&amp;#39; IDENTIFIED WITH mysql_native_password BY &amp;#39;xxx&amp;#39;;&lt;/code&gt; 的形式，其实在用这种方式之前，我还使用功能了mysql_secure_installation这个MySQL自带的程序来设置密码，但是没生效，为什么这个看起来很正规的方式不生效的呢？接下来一起找找原因。&lt;/p&gt;
    
    </summary>
    
      <category term="Mysql" scheme="http://AlbertGithubHome.github.io/blog/categories/Mysql/"/>
    
    
      <category term="Mysql" scheme="http://AlbertGithubHome.github.io/blog/tags/Mysql/"/>
    
      <category term="root" scheme="http://AlbertGithubHome.github.io/blog/tags/root/"/>
    
      <category term="mysql_secure_installation" scheme="http://AlbertGithubHome.github.io/blog/tags/mysql-secure-installation/"/>
    
      <category term="AlterUser" scheme="http://AlbertGithubHome.github.io/blog/tags/AlterUser/"/>
    
      <category term="修改密码" scheme="http://AlbertGithubHome.github.io/blog/tags/%E4%BF%AE%E6%94%B9%E5%AF%86%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>C++20中的关键字</title>
    <link href="http://AlbertGithubHome.github.io/blog/2023/10/07/C-20%E4%B8%AD%E7%9A%84%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <id>http://AlbertGithubHome.github.io/blog/2023/10/07/C-20中的关键字/</id>
    <published>2023-10-07T15:34:23.000Z</published>
    <updated>2023-10-08T15:08:12.248Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>源于上一篇中提到了 <code>decltype</code>是一个关键字，所以去查了现有的关键字列表，其实我对C/C++的关键字还停留在上世纪大概30多个的时代，虽然知道C++加了 <code>auto</code>、<code>constexpr</code> 等关键字，但查询过后才发现原来他扩充到了将近100个，而C语言的关键字也扩到了六七十个，有点震惊了。</p><a id="more"></a><h1 id="关键字列表"><a href="#关键字列表" class="headerlink" title="关键字列表"></a>关键字列表</h1><p><img src="https://img-blog.csdnimg.cn/571f2e791dfa484c82436da29a1e5b61.png" alt="keywords"><br>这份列表来源于<a href="https://en.cppreference.com/w/cpp/keyword" target="_blank" rel="noopener">cppreference</a>，感兴趣的可以去看原文，下面对这些关键字进行一个简单的介绍，有些还是很陌生的。</p><h1 id="关键字含义"><a href="#关键字含义" class="headerlink" title="关键字含义"></a>关键字含义</h1><table><thead><tr><th style="text-align:left">关键字</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td style="text-align:left">alignas</td><td style="text-align:left">指定类型或对象的对齐要求</td></tr><tr><td style="text-align:left">alignof</td><td style="text-align:left">查询类型的对齐要求</td></tr><tr><td style="text-align:left">and</td><td style="text-align:left">用作 <code>&amp;&amp;</code> 的替代写法</td></tr><tr><td style="text-align:left">and_eq</td><td style="text-align:left">用作 <code>&amp;=</code> 的替代写法</td></tr><tr><td style="text-align:left">asm</td><td style="text-align:left">汇编（asm）声明给予在 C++ 程序中嵌入汇编语言源代码的能力</td></tr><tr><td style="text-align:left">atomic_cancel (TM TS)</td><td style="text-align:left">原子块，若抛出异常，则调用 std::abort，除非该异常是用于事务取消的异常之一，这种情况下事务被取消</td></tr><tr><td style="text-align:left">atomic_commit (TM TS)</td><td style="text-align:left">原子块，若抛出异常，则正常地提交事务</td></tr><tr><td style="text-align:left">atomic_noexcept (TM TS)</td><td style="text-align:left">原子块，若抛出异常，则调用 std::abort</td></tr><tr><td style="text-align:left">auto</td><td style="text-align:left">可以在声明变量的时候根据变量初始值的类型自动为此变量选择匹配的类型（C++11）</td></tr><tr><td style="text-align:left">bitand</td><td style="text-align:left">用作 <code>&amp;</code> 的替代写法</td></tr><tr><td style="text-align:left">bitor</td><td style="text-align:left">用作  `\</td><td>`  的替代写法</td></tr><tr><td style="text-align:left">bool</td><td style="text-align:left">足以存放两个值 true 或 false 之一的类型</td></tr><tr><td style="text-align:left">break</td><td style="text-align:left">控制将被转移到紧跟其外围循环或 switch 的下一位置</td></tr><tr><td style="text-align:left">case</td><td style="text-align:left">根据条件的值，将控制流转移到若干语句之一</td></tr><tr><td style="text-align:left">catch</td><td style="text-align:left">和try联合使用，将一或多个异常处理块（catch 子句）与复合语句关联</td></tr><tr><td style="text-align:left">char</td><td style="text-align:left">能在目标系统上最有效地处理的字符表示的类型</td></tr><tr><td style="text-align:left">char8_t</td><td style="text-align:left">UTF-8 字符表示的类型，要求大到足以表示任何 UTF-8 编码单元（ 8 位）</td></tr><tr><td style="text-align:left">char16_t</td><td style="text-align:left">UTF-16 字符表示的类型，要求大到足以表示任何 UTF-16 编码单元（ 16 位）</td></tr><tr><td style="text-align:left">char32_t</td><td style="text-align:left">UTF-32 字符表示的类型，要求大到足以表示任何 UTF-32 编码单元（ 32 位）， C++ 标准还保证 1 == sizeof(char) &lt;= sizeof(short) &lt;= sizeof(int) &lt;= sizeof(long) &lt;= sizeof(long long)</td></tr><tr><td style="text-align:left">class</td><td style="text-align:left">声明类</td></tr><tr><td style="text-align:left">compl</td><td style="text-align:left">用作 <code>~</code> 的替代写法</td></tr><tr><td style="text-align:left">concept</td><td style="text-align:left">声明具名类型要求</td></tr><tr><td style="text-align:left">const</td><td style="text-align:left">类型限定符，定义类型为常量</td></tr><tr><td style="text-align:left">consteval</td><td style="text-align:left">指定函数是立即函数（immediate function），即每次调用该函数必须产生编译时常量</td></tr><tr><td style="text-align:left">constexpr</td><td style="text-align:left">指定变量或函数的值可在常量表达式中出现，在 constexpr if 语句中，条件的值必须是可按语境转换到 bool 类型的经转换常量表达式</td></tr><tr><td style="text-align:left">constinit</td><td style="text-align:left">断言变量拥有静态初始化，即零初始化与常量初始化</td></tr><tr><td style="text-align:left">const_cast</td><td style="text-align:left">用const_cast来去除const限定</td></tr><tr><td style="text-align:left">continue</td><td style="text-align:left">导致外围 for、范围 for、while 或 do-while 循环体的剩余部分被跳过</td></tr><tr><td style="text-align:left">co_await</td><td style="text-align:left">协程是能暂停执行以在之后恢复的函数</td></tr><tr><td style="text-align:left">co_return</td><td style="text-align:left">协程中的 return 语句</td></tr><tr><td style="text-align:left">co_yield</td><td style="text-align:left">协程中表达式向调用方返回一个值并暂停当前协程</td></tr><tr><td style="text-align:left">decltype</td><td style="text-align:left">检查实体的声明类型，或表达式的类型和值类别</td></tr><tr><td style="text-align:left">default</td><td style="text-align:left">1.switch 语句用于声明默认情况标号。2.显式默认化的函数定义令编译器为某个类生成特殊成员函数或比较运算符的显式指令</td></tr><tr><td style="text-align:left">delete</td><td style="text-align:left">1.销毁先前由 new 表达式分配的对象，并释放获得的内存区域。2.弃置函数(C++11 起)</td></tr><tr><td style="text-align:left">do</td><td style="text-align:left">do-while 循环，用作循环的声明</td></tr><tr><td style="text-align:left">double</td><td style="text-align:left">浮点类型</td></tr><tr><td style="text-align:left">dynamic_cast</td><td style="text-align:left">沿继承层级向上、向下及侧向，安全地转换到其他类的指针和引用</td></tr><tr><td style="text-align:left">else</td><td style="text-align:left">if 语句用作另一分支的声明</td></tr><tr><td style="text-align:left">enum</td><td style="text-align:left">声明枚举类型</td></tr><tr><td style="text-align:left">explicit</td><td style="text-align:left">1.指定构造函数或转换函数 (C++11 起)或推导指引 (C++17 起)为显式，即它不能用于隐式转换和复制初始化。2.explicit 说明符可以与常量表达式一同使用。当且仅当该常量表达式求值为 true 时函数为显式。</td></tr><tr><td style="text-align:left">export</td><td style="text-align:left">1.用于标记模板定义为被导出，这允许在其他翻译单元中声明但不定义同一模板。(C++11 前) 2.不使用并保留该关键词。(C++11 起)(C++20 前) 3.标记一个声明、一组声明或另一模块为当前模块所导出。(C++20 起)</td></tr><tr><td style="text-align:left">extern</td><td style="text-align:left">1.具有外部连接的静态存储期说明符 2.语言连接说明 3.显示模板实例化声明（或“extern 模板”）</td></tr><tr><td style="text-align:left">false</td><td style="text-align:left">布尔字面量</td></tr><tr><td style="text-align:left">float</td><td style="text-align:left">单精度浮点类型</td></tr><tr><td style="text-align:left">for</td><td style="text-align:left">用于该循环的声明</td></tr><tr><td style="text-align:left">friend</td><td style="text-align:left">友元声明出现于类体内，并向一个函数或另一个类授予对包含友元声明的类的私有及受保护成员的访问权。</td></tr><tr><td style="text-align:left">goto</td><td style="text-align:left">无条件转移控制流。当使用其他语句不可能将控制转移到所需位置时使用。</td></tr><tr><td style="text-align:left">if</td><td style="text-align:left">有条件地执行另一条语句。用于需要基于运行时或编译时条件执行的代码。</td></tr><tr><td style="text-align:left">inline</td><td style="text-align:left">1.将函数声明为一个 内联（inline）函数。完全在 class/struct/union 的定义之内定义的函数，无论它是成员函数还是非成员 friend 函数，均为隐式的内联函数。2.内联命名空间</td></tr><tr><td style="text-align:left">int</td><td style="text-align:left">基本整数类型</td></tr><tr><td style="text-align:left">long</td><td style="text-align:left">长整数类型</td></tr><tr><td style="text-align:left">mutable(1)</td><td style="text-align:left">1.容许在即便包含它的对象被声明为 const 时仍可修改声明为 mutable 的类成员。2.mutable 用于指定不影响类的外部可观察状态的成员（通常用于互斥体、记忆缓存、惰性求值和访问指令等）。3.从按复制捕获的形参中移除的 const 限定性的 lambda 声明符 (C++11 起) 4.被mutable修饰的变量，将永远处于可变的状态，即使在一个const函数中</td></tr><tr><td style="text-align:left">namespace</td><td style="text-align:left">命名空间声明</td></tr><tr><td style="text-align:left">new</td><td style="text-align:left">.创建并初始化拥有动态存储期的对象，这些对象的生存期不受它们创建时所在的作用域限制</td></tr><tr><td style="text-align:left">noexcept (C++11 起)</td><td style="text-align:left">1.noexcept 运算符进行编译时检查，若表达式声明为不抛出任何异常则返回 true 2.指定函数是否抛出异常</td></tr><tr><td style="text-align:left">not</td><td style="text-align:left">用作 <code>!</code> 的替代写法</td></tr><tr><td style="text-align:left">not_eq</td><td style="text-align:left">用作 <code>!=</code> 的替代写法</td></tr><tr><td style="text-align:left">nullptr (C++11 起)</td><td style="text-align:left">代表指针字面量，保持空指针常量的含义</td></tr><tr><td style="text-align:left">operator</td><td style="text-align:left">重载的运算符是具有特殊的函数名的函数</td></tr><tr><td style="text-align:left">or</td><td style="text-align:left">用作</td><td>的替代写法</td></tr><tr><td style="text-align:left">or_eq</td><td style="text-align:left">用作 `\</td><td>=` 的替代写法</td></tr><tr><td style="text-align:left">private</td><td style="text-align:left">该访问说明符之后的各个成员具有私有成员访问</td></tr><tr><td style="text-align:left">protected</td><td style="text-align:left">该访问说明符之后的各个成员具有受保护成员访问</td></tr><tr><td style="text-align:left">public</td><td style="text-align:left">该访问说明符之后的各个成员具有公开成员访问</td></tr><tr><td style="text-align:left">reflexpr (反射 TS)</td><td style="text-align:left">反射是指程序在运行时动态获取对象属性与方法的一种机制</td></tr><tr><td style="text-align:left">register</td><td style="text-align:left">1.动存储期，另提示编译器将此对象置于处理器的寄存器。2.不使用并保留该关键词</td></tr><tr><td style="text-align:left">reinterpret_cast</td><td style="text-align:left">通过重新解释底层位模式在类型间转换。</td></tr><tr><td style="text-align:left">requires (C++20 起)</td><td style="text-align:left">1.对模板形参指定一个求值为要求的常量表达式。 2.于模板声明中指定关联制约</td></tr><tr><td style="text-align:left">return</td><td style="text-align:left">终止当前函数并返回指定值（若存在）给调用方函数</td></tr><tr><td style="text-align:left">short</td><td style="text-align:left">至少 16 位的宽度（和long一样表示大小）</td></tr><tr><td style="text-align:left">signed</td><td style="text-align:left">目标类型将拥有有符号表示（若省略则此为默认）</td></tr><tr><td style="text-align:left">sizeof(1)</td><td style="text-align:left">1.查询对象或类型的大小。2.在需要知道对象的实际大小时使用。3.返回形参包中的元素数量</td></tr><tr><td style="text-align:left">static</td><td style="text-align:left">1.声明具有静态存储期和内部连接的命名空间成员。2.定义具有静态存储期且仅初始化一次的块作用域变量。3.声明不绑定到特定实例的类成员</td></tr><tr><td style="text-align:left">static_assert (C++11 起)</td><td style="text-align:left">进行编译时断言检查</td></tr><tr><td style="text-align:left">static_cast</td><td style="text-align:left">用隐式和用户定义转换的组合在类型间转换</td></tr><tr><td style="text-align:left">struct</td><td style="text-align:left">1.复合类型的声明。2.有作用域枚举类型的声明(C++11 起) 3.若存在于作用域中的某个函数或变量所拥有的名字，与某个非联合体类类型的名字相同，则可在其名字之前加上 struct 来消歧义，这产生一个详述类型说明符</td></tr><tr><td style="text-align:left">switch</td><td style="text-align:left">根据条件的值，将控制流转移到若干语句之一</td></tr><tr><td style="text-align:left">synchronized (TM TS)</td><td style="text-align:left">程序中的所有最外层同步块都以一个单独的全序执行</td></tr><tr><td style="text-align:left">template</td><td style="text-align:left">1.声明模板。 2.在模板定义中，template 可用于将某个待决名声明为模板</td></tr><tr><td style="text-align:left">this</td><td style="text-align:left">this 是一个纯右值表达式，其值是隐式对象形参（在其上调用非静态成员函数的对象）的地址</td></tr><tr><td style="text-align:left">thread_local (C++11 起)</td><td style="text-align:left">线程存储期</td></tr><tr><td style="text-align:left">throw</td><td style="text-align:left">1.对错误条件发信号，并执行错误处理代码 2.列出函数可能直接或间接抛出的异常</td></tr><tr><td style="text-align:left">true</td><td style="text-align:left">bool 类型的纯右值，为真</td></tr><tr><td style="text-align:left">try</td><td style="text-align:left">将一或多个异常处理块（catch 子句）与复合语句关联</td></tr><tr><td style="text-align:left">typedef</td><td style="text-align:left">创建能在任何位置替代（可能复杂的）类型名的别名</td></tr><tr><td style="text-align:left">typeid</td><td style="text-align:left">查询类型的信息。用于必须知晓多态对象的动态类型的场合以及静态类型鉴别</td></tr><tr><td style="text-align:left">typename</td><td style="text-align:left">1.在模板声明中，typename 可用作 class 的代替品，以声明类型模板形参和模板形参 (C++17 起) 2.在模板的声明或定义内，typename 可用于声明某个待决的有限定名是类型。3.在模板的声明或定义内， (C++11 前)typename 可在非待决的有限定类型名之前使用。此情况下它没有效果。4.在类型要求的要求中。(C++20 起)</td></tr><tr><td style="text-align:left">union</td><td style="text-align:left">1.联合体类型的声明。2.若存在于作用域中的某个函数或变量所拥有的名字与某个联合体类型的名字相同，则可在该名字之前加上 union 以消歧义，这产生详述类型说明符</td></tr><tr><td style="text-align:left">unsigned</td><td style="text-align:left">目标类型将拥有无符号表示</td></tr><tr><td style="text-align:left">using</td><td style="text-align:left">1.对命名空间的 using 指令及对命名空间成员的 using 声明。2.对类成员的 using 声明。3.类型别名与别名模板声明 (C++11 起)</td></tr><tr><td style="text-align:left">virtual</td><td style="text-align:left">1.虚函数说明符。2.虚基类说明符</td></tr><tr><td style="text-align:left">void</td><td style="text-align:left">1.void 类型。2.无形参函数的形参列表</td></tr><tr><td style="text-align:left">volatile</td><td style="text-align:left">定义类型为易变，确保本条指令不会因编译器的优化而省略，且要求每次直接读值</td></tr><tr><td style="text-align:left">wchar_t</td><td style="text-align:left">宽字符表示的类型</td></tr><tr><td style="text-align:left">while</td><td style="text-align:left">1.while 循环的声明。2.do-while 循环终止条件的声明</td></tr><tr><td style="text-align:left">xor</td><td style="text-align:left">作为 <code>^</code> 的替代写法</td></tr><tr><td style="text-align:left">xor_eq</td><td style="text-align:left">用作 <code>^=</code> 的替代写法</td></tr></tbody></table><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>C++关键字从C++11开始快速扩张，到C++20标准已经有100个左右了</li><li>C语言关键字发展到现在也有60多个了</li><li>像 <code>xor_eq</code>、<code>or_eq</code> 这些关键字就是对原来的运算符号换了个写法，感觉上没有什么用，只是不用敲特殊符号了</li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/133655454" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>好日子都是自己争取来的~</p><p>2023-10-7 23:34:23</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;源于上一篇中提到了 &lt;code&gt;decltype&lt;/code&gt;是一个关键字，所以去查了现有的关键字列表，其实我对C/C++的关键字还停留在上世纪大概30多个的时代，虽然知道C++加了 &lt;code&gt;auto&lt;/code&gt;、&lt;code&gt;constexpr&lt;/code&gt; 等关键字，但查询过后才发现原来他扩充到了将近100个，而C语言的关键字也扩到了六七十个，有点震惊了。&lt;/p&gt;
    
    </summary>
    
      <category term="C/C++" scheme="http://AlbertGithubHome.github.io/blog/categories/C-C/"/>
    
    
      <category term="C/C++" scheme="http://AlbertGithubHome.github.io/blog/tags/C-C/"/>
    
      <category term="keywords" scheme="http://AlbertGithubHome.github.io/blog/tags/keywords/"/>
    
      <category term="xor_eq" scheme="http://AlbertGithubHome.github.io/blog/tags/xor-eq/"/>
    
      <category term="co_await" scheme="http://AlbertGithubHome.github.io/blog/tags/co-await/"/>
    
  </entry>
  
  <entry>
    <title>linux环境下如果掌控了系统root账户就能对上面安装的MySQL数据为所欲为了吗</title>
    <link href="http://AlbertGithubHome.github.io/blog/2023/10/07/linux%E7%8E%AF%E5%A2%83%E4%B8%8B%E5%A6%82%E6%9E%9C%E6%8E%8C%E6%8E%A7%E4%BA%86%E7%B3%BB%E7%BB%9Froot%E8%B4%A6%E6%88%B7%E5%B0%B1%E8%83%BD%E5%AF%B9%E4%B8%8A%E9%9D%A2%E5%AE%89%E8%A3%85%E7%9A%84MySQL%E6%95%B0%E6%8D%AE%E4%B8%BA%E6%89%80%E6%AC%B2%E4%B8%BA%E4%BA%86%E5%90%97/"/>
    <id>http://AlbertGithubHome.github.io/blog/2023/10/07/linux环境下如果掌控了系统root账户就能对上面安装的MySQL数据为所欲为了吗/</id>
    <published>2023-10-07T12:47:41.000Z</published>
    <updated>2023-10-08T15:06:03.971Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>根据我目前测试的情况来看，这个问题的答案是【确实可以为所欲为】，事情的起因是这样的，一次偶然的机会我发现Ubuntu20.04系统上通过 <code>sudo apt install mysql-server</code> 命令安装的MySQL服务器，使用root账号登录无论输入什么密码都可以成功进入，多次尝试后才知道原来root用户默认没有密码，这可是让我惊呆了，居然还可以这样，为了服务器的安全，我必须给他设置个密码，在不断尝试的过程中引发了标题中的疑问。</p><a id="more"></a><h1 id="修改root密码"><a href="#修改root密码" class="headerlink" title="修改root密码"></a>修改root密码</h1><p>修改MySQL用户root密码在网络上充斥着各种各样的版本，最常见的这种在MySQL8.0中已经不生效了，错误示例如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">user</span> <span class="keyword">SET</span> authentication_string = <span class="keyword">PASSWORD</span>(<span class="string">'iL1jfLqUSfmTECXRi4nO'</span>) <span class="keyword">WHERE</span> <span class="keyword">User</span> = <span class="string">'root'</span>;</span><br></pre></td></tr></table></figure><p>目前测试在MySQL8.0版本中可行的设置root密码的方式为：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">USE</span> mysql;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">USER</span> <span class="string">'root'</span>@<span class="string">'localhost'</span> <span class="keyword">IDENTIFIED</span> <span class="keyword">WITH</span> mysql_native_password <span class="keyword">BY</span> <span class="string">'iL1jfLqUSfmTECXRi4nO'</span>;</span><br><span class="line"><span class="keyword">FLUSH</span> <span class="keyword">PRIVILEGES</span>;</span><br></pre></td></tr></table></figure><h1 id="产生疑问"><a href="#产生疑问" class="headerlink" title="产生疑问"></a>产生疑问</h1><p>root用户的密码是设置好了，这么长的密码估计破解个几年也破解不开，但是我发现安装完毕提示了这样一样配置文件 <code>/etc/mysql/debian.cnf</code>，打开文件内容展示如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># Automatically generated for Debian scripts. DO NOT TOUCH!</span><br><span class="line">[client]</span><br><span class="line">host     = localhost</span><br><span class="line">user     = debian-sys-maint</span><br><span class="line">password = xg9vyvjNly3vUSsm</span><br><span class="line">socket   = /var/run/mysqld/mysqld.sock</span><br><span class="line">[mysql_upgrade]</span><br><span class="line">host     = localhost</span><br><span class="line">user     = debian-sys-maint</span><br><span class="line">password = xg9vyvjNly3vUSsm</span><br><span class="line">socket   = /var/run/mysqld/mysqld.sock</span><br></pre></td></tr></table></figure><p>居然是一个包含了MySQL用户和密码的未加密的文本文件，这不是在大门口的脚垫底下放上了大门的钥匙吗？关键这个debian-sys-maint虽然设计上是用于数据库维护和管理，但权限上与root几乎相同，通常在 Debian 或基于 Debian 的 Linux 发行版比如Ununtu上安装MySQL就会自动生成这个文件，看起来有点不安全啊？</p><p>于是查了相关的处理方法，都说要控制这个文件的权限，只让系统root用户可以访问它，这时我就产生了疑问，这样做安全吗？如果系统root用户被窃取了呢？那是不是完全可以通过这个文件来操控MySQL数据了，答案是很显然的。</p><h1 id="渐渐明白"><a href="#渐渐明白" class="headerlink" title="渐渐明白"></a>渐渐明白</h1><p>虽然说掌握了root用户就可以任意修改MySQL数据让人难以接受，但是换个角度或许就可以释然了，root可是系统里的上帝啊，控制了root用户可以任意执行 <code>rm -rf /*</code>，如果你知道银行卡密码当然就可以从取款机里取钱，对于操作系统也是一样，既然你是root你就掌控了这个系统里的一切。</p><p>即便没有这个<code>/etc/mysql/debian.cnf</code>文件，root用户还可以先关闭MySQL服务，然后通过 <code>sudo mysqld_safe --skip-grant-tables &amp;</code>以跳过授权表的方式启动MySQL，此时允许你在不知道密码的情况下以 root 身份登录 MySQL，这还有什么隐私可言。再换种方式，作为root用户的我从磁盘上把MySQL存储的文件拿到其他MySQL服务器上都是可以的，所以你是防不住root上帝的。</p><p>所以刚刚那个【大门口的脚垫底下放上了大门的钥匙】的比喻不太恰当，应该是<code>/etc/mysql/debian.cnf</code>就像屋里的桌子上摆着的保险柜的钥匙，而你要保证大门的钥匙（root密码）不要轻易被人搞到手，像 <code>--skip-grant-tables</code> 这种看起来很像是后门，或者叫应急开关，实际上它的设计就是为了提供一种紧急的修复机制，用于在丧失所有密码或无法登录到 MySQL 数据库时进行数据库恢复和修复，比如紧急恢复、密码重置、修复数据库权限等等</p><p>这种设计就像是各司其职，我只负责我数据的管理与权限的分配，而用户需要保证系统很牢固，一旦你的系统被攻破我将束手就擒，做的再多也是徒劳。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>MySQL8.0修改密码的方式<code>ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED WITH mysql_native_password BY &#39;xxx&#39;;</code></li><li>文件<code>/etc/mysql/debian.cnf</code>是Debian系列系统上安装MySQL时自动生成的，其中的用户用于用于数据库维护和管理</li><li>如果忘了MySQL中root用户的密码可以通过 <code>sudo mysqld_safe --skip-grant-tables &amp;</code> 启动服务来进行免密登录</li><li>控制了系统的root用户，你就掌控了操作系统的一切</li></ul><center><a href="https://blog.csdn.net/albertsh/article/details/132641641" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>假期归来又看了很多，也不安分了许多，或许只有通过打破常规才能获得额外的收益，否则只能是一直保持饿不死的状态</p><p>2023-10-7 20:47:41</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;根据我目前测试的情况来看，这个问题的答案是【确实可以为所欲为】，事情的起因是这样的，一次偶然的机会我发现Ubuntu20.04系统上通过 &lt;code&gt;sudo apt install mysql-server&lt;/code&gt; 命令安装的MySQL服务器，使用root账号登录无论输入什么密码都可以成功进入，多次尝试后才知道原来root用户默认没有密码，这可是让我惊呆了，居然还可以这样，为了服务器的安全，我必须给他设置个密码，在不断尝试的过程中引发了标题中的疑问。&lt;/p&gt;
    
    </summary>
    
      <category term="linux" scheme="http://AlbertGithubHome.github.io/blog/categories/linux/"/>
    
    
      <category term="linux" scheme="http://AlbertGithubHome.github.io/blog/tags/linux/"/>
    
      <category term="ubuntu" scheme="http://AlbertGithubHome.github.io/blog/tags/ubuntu/"/>
    
      <category term="mysql" scheme="http://AlbertGithubHome.github.io/blog/tags/mysql/"/>
    
      <category term="root" scheme="http://AlbertGithubHome.github.io/blog/tags/root/"/>
    
      <category term="debian-sys-maint" scheme="http://AlbertGithubHome.github.io/blog/tags/debian-sys-maint/"/>
    
      <category term="skip-grant-tables" scheme="http://AlbertGithubHome.github.io/blog/tags/skip-grant-tables/"/>
    
  </entry>
  
  <entry>
    <title>C++中的decltype、std::declval 和 std::decay_t傻傻分不清楚</title>
    <link href="http://AlbertGithubHome.github.io/blog/2023/09/05/C-%E4%B8%AD%E7%9A%84decltype%E3%80%81std-declval-%E5%92%8C-std-decay-t%E5%82%BB%E5%82%BB%E5%88%86%E4%B8%8D%E6%B8%85%E6%A5%9A/"/>
    <id>http://AlbertGithubHome.github.io/blog/2023/09/05/C-中的decltype、std-declval-和-std-decay-t傻傻分不清楚/</id>
    <published>2023-09-05T13:42:25.000Z</published>
    <updated>2023-10-08T15:02:51.293Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在C++中提到推导第一个映入脑海的可能是“模板”，当然有人也可能想到 <code>auto</code>，这些都是和推导相关的语言语法，再比如“完美转发”等等，总是就是他们的类型不用明明白白的写出来，可以利用一种简单的方式来定义，比如 <code>candidates</code> 是一个字符串数组， 如果遍历它我们可以写成 <code>for (auto&amp; skillId : candidates)</code>，而不用将 <code>skillId</code> 变量定义成 <code>const std::string&amp;</code>，这在一定程度上带来了便利，今天的几个东东也是用于推导的，我们一起来看看。</p><a id="more"></a><h1 id="它们是什么"><a href="#它们是什么" class="headerlink" title="它们是什么"></a>它们是什么</h1><p><code>decltype</code>、<code>std::declval</code> 和 <code>std::decay_t</code> 都是 C++ 标准库中的类型相关工具，这些工具在 C++ 编程中提供了强大的类型推导和处理能力，使得代码更加灵活。</p><ul><li><p><code>decltype</code> 是一个关键字，用于从一个表达式中推导出其类型。它通常与表达式一起使用，以便在编译时确定表达式的类型。例如：</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">decltype</span>(x) y = <span class="number">10</span>;  <span class="comment">// y 的类型将被推导为 int</span></span><br></pre></td></tr></table></figure><p> <code>decltype</code> 还可以用于推导函数返回类型，以及在泛型编程中处理模板的类型。</p></li><li><p><code>std::declval</code> 是一个函数模板，用于在不实际调用构造函数的情况下生成一个对象引用，以便在类型推导中使用。通常在需要引用某个类型的对象但实际无法创建该对象的上下文中使用，例如在函数返回类型推导中：</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">auto createAndProcess() -&gt; decltype(std::declval&lt;T&gt;().process()) &#123;</span><br><span class="line">    <span class="comment">// 此处只是用于类型推导，并不会实际创建 T 的对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 在这个例子中，<code>std::declval&lt;T&gt;().process()</code> 用于推导函数的返回类型，但并不会实际调用 <code>process</code> 函数。</p></li><li><p><code>std::decay_t</code> 是一个类型转换工具模板，用于将给定类型的”衰变”后的类型返回。衰变指的是将类型转换为其”自然”形式，即去掉引用、添加 cv 限定符（const 和 volatile）。例如：</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> T1 = <span class="built_in">std</span>::<span class="keyword">decay_t</span>&lt;<span class="keyword">int</span>&amp;&gt;;      <span class="comment">// T1 为 int</span></span><br><span class="line"><span class="keyword">using</span> T2 = <span class="built_in">std</span>::<span class="keyword">decay_t</span>&lt;<span class="keyword">const</span> <span class="keyword">int</span>&gt;; <span class="comment">// T2 为 int</span></span><br><span class="line"><span class="keyword">using</span> T3 = <span class="built_in">std</span>::<span class="keyword">decay_t</span>&lt;<span class="keyword">int</span>[]&gt;;     <span class="comment">// T3 为 int*</span></span><br></pre></td></tr></table></figure><p> <code>std::decay_t</code> 在模板编程中很有用，因为它可以帮助去除类型的多余限定符，使得函数模板的匹配更加精确。</p></li></ul><h1 id="通俗解释"><a href="#通俗解释" class="headerlink" title="通俗解释"></a>通俗解释</h1><p>如果看了上面的例子还是有点迷糊，那我再解释的通俗一点：</p><ul><li><p><code>decltype</code>  读音为 “dee-kluh-type”，就是返回一个变量的类型，比如你有一个对象 <code>obj</code> 想要再定义一个和它相同各类型的变量就可以写成 <code>decltype(obj) newObj;</code></p></li><li><p><code>std::declval</code>  读音为 “standard dee-cl-val”，它能返回类型 T 的右值引用，其实是一个伪实例，不会产生任何临时对象，也不会因为表达式很复杂而发生真实的计算。因为不会真正的进行构造，所以可以实现在元编程时伪构造一个没有定义默认构造函数类，还可以避开纯虚基类不能实例化的问题，说白了它就是假装创建个对象用于推导类型。</p></li><li><p><code>std::decay_t</code> 读音为 “standard dee-kay tee”，有点褪去外表直击内心的意味，就是大家一起褪去花里胡哨的修饰符，获得原始的类型，用于函数模板的匹配更加精确，比如判断类型 <code>T</code>是不是int，<code>if constexpr (std::is_same_v&lt;std::decay_t&lt;T&gt;, int&gt;)</code></p></li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li><code>decltype</code> 是关键字，用于有了值或对象求类型的</li><li><code>std::declval</code> 是函数模板，用于伪造一个对象但不实际构造的</li><li><code>std::decay_t</code> 是类模板，用于去除修饰符获取原始类型的</li><li>没想到<code>decltype</code> 居然是关键字，结果一查发现C++的关键字已经膨胀了，下次总结一下</li></ul><center><a href="https://blog.csdn.net/albertsh/article/details/132549001" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>当身边出现不和谐声音的时候问问自己，是不是你把他们招来的，用实力让他们闭嘴，而不要视图通过语言让他们明白</p><p>2023-9-5 21:42:25</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;在C++中提到推导第一个映入脑海的可能是“模板”，当然有人也可能想到 &lt;code&gt;auto&lt;/code&gt;，这些都是和推导相关的语言语法，再比如“完美转发”等等，总是就是他们的类型不用明明白白的写出来，可以利用一种简单的方式来定义，比如 &lt;code&gt;candidates&lt;/code&gt; 是一个字符串数组， 如果遍历它我们可以写成 &lt;code&gt;for (auto&amp;amp; skillId : candidates)&lt;/code&gt;，而不用将 &lt;code&gt;skillId&lt;/code&gt; 变量定义成 &lt;code&gt;const std::string&amp;amp;&lt;/code&gt;，这在一定程度上带来了便利，今天的几个东东也是用于推导的，我们一起来看看。&lt;/p&gt;
    
    </summary>
    
      <category term="C/C++" scheme="http://AlbertGithubHome.github.io/blog/categories/C-C/"/>
    
    
      <category term="C/C++" scheme="http://AlbertGithubHome.github.io/blog/tags/C-C/"/>
    
      <category term="decltype" scheme="http://AlbertGithubHome.github.io/blog/tags/decltype/"/>
    
      <category term="std::declval" scheme="http://AlbertGithubHome.github.io/blog/tags/std-declval/"/>
    
      <category term="std::decay_t" scheme="http://AlbertGithubHome.github.io/blog/tags/std-decay-t/"/>
    
  </entry>
  
  <entry>
    <title>C++定义一个返回值为拥有3个元素的 char 数组引用的函数</title>
    <link href="http://AlbertGithubHome.github.io/blog/2023/08/28/C-%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA%E8%BF%94%E5%9B%9E%E5%80%BC%E4%B8%BA%E6%8B%A5%E6%9C%893%E4%B8%AA%E5%85%83%E7%B4%A0%E7%9A%84-char-%E6%95%B0%E7%BB%84%E5%BC%95%E7%94%A8%E7%9A%84%E5%87%BD%E6%95%B0/"/>
    <id>http://AlbertGithubHome.github.io/blog/2023/08/28/C-定义一个返回值为拥有3个元素的-char-数组引用的函数/</id>
    <published>2023-08-28T14:21:41.000Z</published>
    <updated>2023-09-03T12:57:59.425Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>编程语言最怕细节，怼着一个点扣能让你怀疑人生，今天就碰到这么一个问题，“C++定义一个返回值为拥有3个元素的 char 数组引用的函数”，不敢说99%的人不会，但我觉得应该有80%的人写不出来吧，要不你来试试。</p><a id="more"></a><h1 id="分解需求"><a href="#分解需求" class="headerlink" title="分解需求"></a>分解需求</h1><p>首先得能看出来这是要求定义一个函数，如果这一步就错了，那就没必要往后走了，函数有的参数没有要求，但是返回值得是一个引用，这个引用的原始类型应该为一个拥有3个元素的char类型数组，难道要这样写？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>&amp; [<span class="number">3</span>] func()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>试试吧，肯定编不过的，要是这么容易就哪能让人死去活来，直接给答案了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line">const char (&amp;getCharArray())[3] &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> charArray[<span class="number">3</span>] = &#123;<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'X'</span>&#125;;</span><br><span class="line">    <span class="keyword">return</span> charArray;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    const char (&amp;result)[3] = getCharArray();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> c : result) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; c &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="举一反三"><a href="#举一反三" class="headerlink" title="举一反三"></a>举一反三</h1><p>学习要学会举一反三，把题目中的“引用”换成“指针”，再试一下，依葫芦画瓢还是很容易的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> (*getCharArrayPointer())[<span class="number">3</span>] &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> charArray[<span class="number">3</span>] = &#123;<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'J'</span>&#125;;</span><br><span class="line">    <span class="keyword">return</span> &amp;charArray;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> (*result)[<span class="number">3</span>] = getCharArrayPointer();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; (*result)[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>仿佛这也不是我们常常见到的形式，对于指针作为返回值，我们常见到的应该是下面这种</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">getCharArrayPointer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> charArray[<span class="number">10</span>] = &#123;<span class="string">'H'</span>, <span class="string">'e'</span>, <span class="string">'l'</span>, <span class="string">'l'</span>, <span class="string">'o'</span>, <span class="string">' '</span>, <span class="string">'W'</span>, <span class="string">'o'</span>, <span class="string">'r'</span>, <span class="string">'l'</span>&#125;;</span><br><span class="line">    <span class="keyword">return</span> charArray;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span>* result = getCharArrayPointer();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; result[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>他们有什么区别呢？我们从定义层面来对比一下：</p><h1 id="进行对比"><a href="#进行对比" class="headerlink" title="进行对比"></a>进行对比</h1><ul><li><figure class="highlight plain"><figcaption><span>char (&result)[3] </span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  - `result` 是一个引用类型变量，被引用的类型为 `char[3]`</span><br><span class="line">  - `sizeof(result)` == 3</span><br><span class="line">- ```char (*result)[3] = getCharArrayPointer();</span><br></pre></td></tr></table></figure><ul><li><code>result</code> 是一个指针类型变量，指向的类型的类型为 <code>char[3]</code></li><li><code>sizeof(result)</code> == 8</li><li><code>result++</code> 先后移动24个字节=8*3</li></ul></li><li><code>char* result = getCharArrayPointer();</code><ul><li><code>result</code> 是一个指针类型变量，被引用的类型为 <code>char</code></li><li><code>sizeof(result)</code> == 8</li><li><code>result++</code> 先后移动8个字节=8*1</li></ul></li></ul><p>有了上面的对比就可以根据区别来选择定义什么样的返回值，使用引用类型能取到被引用变量的原始大小，使用指针要注意移动的步长。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>定义一个返回定长数组引用的函数 <code>const char (&amp;getCharArray())[3] { //... }</code></li><li>定义一个返回定长数组指针的函数 <code>const char (*getCharArray())[3] { //... }</code></li><li>引用不需要内存分配和释放，因为它只是目标对象的别名（存疑，在绝大多数编译器中，引用在底层是通过指针来实现的，但GPT嘴硬说不需要，表示需要继续探索）</li></ul><blockquote><p>引用在底层通过指针实现时，并不需要额外的内存分配。引用被设计为变量的别名，它并不占用额外的内存空间。引用在编译器生成的汇编代码中，会被处理为指向原始对象的指针，但是这个指针对于用户来说是透明的，不需要分配额外的内存来存储引用本身。<br>引用只是目标对象的别名，与指针不同，它没有自己的内存存储空间。因此，无论引用在底层是通过指针实现还是其他方式实现，都不会导致额外的内存分配。这也是为什么引用在使用上更接近于对变量的直接访问。<br>需要注意的是，尽管引用不需要额外的内存分配，但指针本身需要存储指向对象的地址，因此指针会占用一定的内存空间。这也是引用和指针之间的一个重要区别。</p></blockquote><center><a href="https://blog.csdn.net/albertsh/article/details/132484006" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>内练一口气，外练筋骨皮</p><p>2023-8-28 22:17:27</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;编程语言最怕细节，怼着一个点扣能让你怀疑人生，今天就碰到这么一个问题，“C++定义一个返回值为拥有3个元素的 char 数组引用的函数”，不敢说99%的人不会，但我觉得应该有80%的人写不出来吧，要不你来试试。&lt;/p&gt;
    
    </summary>
    
      <category term="C/C++" scheme="http://AlbertGithubHome.github.io/blog/categories/C-C/"/>
    
    
      <category term="C/C++" scheme="http://AlbertGithubHome.github.io/blog/tags/C-C/"/>
    
      <category term="开发语言" scheme="http://AlbertGithubHome.github.io/blog/tags/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/"/>
    
      <category term="指针" scheme="http://AlbertGithubHome.github.io/blog/tags/%E6%8C%87%E9%92%88/"/>
    
      <category term="引用" scheme="http://AlbertGithubHome.github.io/blog/tags/%E5%BC%95%E7%94%A8/"/>
    
      <category term="函数定义" scheme="http://AlbertGithubHome.github.io/blog/tags/%E5%87%BD%E6%95%B0%E5%AE%9A%E4%B9%89/"/>
    
  </entry>
  
  <entry>
    <title>C++编程中的六种内存顺序模型</title>
    <link href="http://AlbertGithubHome.github.io/blog/2023/08/24/C-%E7%BC%96%E7%A8%8B%E4%B8%AD%E7%9A%84%E5%85%AD%E7%A7%8D%E5%86%85%E5%AD%98%E9%A1%BA%E5%BA%8F%E6%A8%A1%E5%9E%8B/"/>
    <id>http://AlbertGithubHome.github.io/blog/2023/08/24/C-编程中的六种内存顺序模型/</id>
    <published>2023-08-24T15:01:59.000Z</published>
    <updated>2023-09-03T12:55:58.237Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>程序员真是一个活到老学到老的职业，一天不学习就会掉队，『内存顺序模型』对于我来说就是一个新的世界，虽然之前写过多线程的服务器，也处理过死锁和竞态条件等问题，但是从来没考虑过内存顺序问题，所以当我第一次看到这个概念时，整个人都是懵的，经过一段时间的学习和了解有了初步的认识，所以简单总结下来，以备后续查看，不多写，慢慢总结。</p><a id="more"></a><h1 id="为什么要设计内存顺序模型"><a href="#为什么要设计内存顺序模型" class="headerlink" title="为什么要设计内存顺序模型"></a>为什么要设计内存顺序模型</h1><p>内存顺序模型是为了解决多线程程序中的内存一致性和可见性问题而引入的。在多线程环境下，不同线程可能同时访问和修改共享的内存，这会引发一系列并发性问题，如竞态条件、数据竞争等。内存顺序模型的目的是通过定义不同操作之间的执行顺序和可见性规则，来保证多线程程序的正确性和可预测性。主要原因如下：</p><ol><li><p><strong>多线程并发问题：</strong> 在多线程程序中，线程之间可能并发地读取和写入共享内存，导致数据不一致和不可预测的行为。</p></li><li><p><strong>编译器和处理器优化：</strong> 编译器和处理器可能会对代码进行优化，例如重排指令以提高性能。这些优化可能会导致操作的执行顺序与代码中的顺序不一致，从而引发问题。</p></li><li><p><strong>硬件内存模型：</strong> 不同的计算机体系结构有不同的硬件内存模型，即不同的读写操作在不同的条件下可能表现出不同的行为。</p></li><li><p><strong>数据依赖性：</strong> 在某些情况下，某个操作的结果可能会影响后续操作的执行。内存顺序模型可以帮助定义这种数据依赖性。</p></li></ol><p>内存顺序模型通过定义不同操作之间的关系，如同步、重排等，来解决上述问题。不同的内存顺序模型提供了不同的可见性和同步保证，开发者可以根据自己的需求选择适当的模型。总之，内存顺序模型是为了在多线程环境下提供一种标准化的方式来处理内存一致性和可见性问题，从而使多线程编程更加可靠和可预测，重点关注下第2点和第4点。</p><p>有人可能会说，我可以用锁来保证顺序，为什么还要设计内存顺序模型呢？</p><p>虽然锁（比如互斥锁）在多线程编程中是一种常见的同步机制，用于保护共享资源，但锁并不能解决所有的并发性问题，而且在某些情况下使用锁可能会引入性能问题。内存顺序模型的设计是为了在不同线程之间定义操作的执行顺序和可见性规则，以解决锁无法解决的一些问题，同时在一些情况下也可以提高性能。</p><ol><li><p><strong>细粒度同步：</strong> 锁通常是用于保护共享资源的，但有时候我们需要更细粒度的同步，比如在不涉及共享资源的情况下也需要保证操作的顺序和可见性。</p></li><li><p><strong>原子操作：</strong> 内存顺序模型通过定义原子操作的执行顺序和可见性，可以在不使用锁的情况下确保操作的正确执行。这在一些场景下可以避免锁带来的性能开销。</p></li><li><p><strong>锁的开销：</strong> 锁在某些情况下可能引入较大的性能开销，特别是在高并发环境中。内存顺序模型提供了一种更轻量级的同步机制，可以在一些情况下取代锁，提高性能。</p></li><li><p><strong>编译器和处理器优化：</strong> 编译器和处理器对代码进行优化时可能会引入指令重排，这可能会导致锁保护下的共享资源出现问题。内存顺序模型通过规定操作的执行顺序，可以避免这种问题。</p></li><li><p><strong>原子操作的组合：</strong> 内存顺序模型的原子操作可以灵活地组合，以实现更复杂的同步和顺序要求，而不必仅仅依赖于锁。</p></li></ol><p>总之，内存顺序模型和锁在多线程编程中都有其适用的场景。锁通常用于保护共享资源的访问，而内存顺序模型则用于定义操作的执行顺序和可见性，以确保多线程程序的正确性。在多线程编程中，根据具体需求和性能要求，可以选择合适的同步机制。</p><p><strong>如果想理解内存顺序，首先要理解两个东西：同一线程中，谁先执行，谁后执行；不同线程中，切换内存的时是否会及时的把依赖数据带过去，对另一个线程可见。</strong></p><h1 id="常见的内存顺序模型"><a href="#常见的内存顺序模型" class="headerlink" title="常见的内存顺序模型"></a>常见的内存顺序模型</h1><p>C++ 标准库中定义了六种内存顺序模型，用于控制多线程程序中不同操作之间的执行顺序和可见性。这些内存顺序模型通过枚举值表示，从“<strong>宽松</strong>”到“<strong>严格</strong>”的次序分别是：</p><ol><li><p><strong><code>std::memory_order_relaxed</code>：</strong> 这是最轻量级的内存顺序模型。它不会引入任何额外的同步开销，只保证操作在时间上的顺序是正确的。即使没有明确的同步操作，也不会改变其他线程看到的操作结果。</p></li><li><p><strong><code>std::memory_order_consume</code>：</strong> 在 C++11 中引入，但在 C++20 中被弃用。它主要用于处理数据依赖关系，但在实际中难以实现，已经不推荐使用。</p></li><li><p><strong><code>std::memory_order_acquire</code>：</strong> 在执行当前操作之前，确保所有前面的读操作都完成。它提供了一种读操作同步的保证，确保读操作的结果在后续操作中是可见的。</p></li><li><p><strong><code>std::memory_order_release</code>：</strong> 在执行当前操作之后，确保所有后面的写操作都不会重排到当前操作之前。它提供了一种写操作同步的保证，确保写操作的结果对其他线程是可见的。</p></li><li><p><strong><code>std::memory_order_acq_rel</code>：</strong> 是 <code>memory_order_acquire</code> 和 <code>memory_order_release</code> 的组合。它同时提供了读和写操作的同步保证，适用于需要同时保证读写操作同步的情况。</p></li><li><p><strong><code>std::memory_order_seq_cst</code>：</strong> 是最严格的内存顺序模型，提供了全局的、顺序一致的保证。它确保所有操作按照一个全局的顺序执行，不会引入重排，也保证了最高级别的可见性。</p></li></ol><p>根据具体的多线程编程需求，你可以选择适当的内存顺序模型，以确保正确性和性能。不同的内存顺序模型会引入不同程度的同步开销，因此需要根据实际情况权衡选择。了解这些内存顺序模型可以帮助你在多线程编程中更好地控制操作的执行顺序和可见性，每种模型具体的例子我们后面再慢慢总结。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>常见的内存顺序模型前三种：<code>std::memory_order_relaxed</code>、<code>std::memory_order_acquire</code>、<code>std::memory_order_acquire</code></li><li>常见的内存顺序模型后三种：<code>std::memory_order_release</code>、<code>std::memory_order_acq_rel</code>、<code>std::memory_order_seq_cst</code></li><li>其中 `std::memory_order_consume`` 在实际中难以实现，已经在 C++20 中被弃用</li><li>编译器和处理器对代码进行优化时可能会引入指令重排，这可能会导致锁保护下的共享资源出现问题</li><li>内存顺序模型通过规定操作的执行顺序，可以避免上一个问题</li><li>内存顺序和原子操作的引入，是为了无锁的并发编程，提高并发编程的效率</li></ul><center><a href="https://blog.csdn.net/albertsh/article/details/132252530" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>或许我就不在你规划的未来<br>或许她才是你唯一的偏爱<br>或许我就不该跟你赌未来<br>或许就不会深陷苦海</p><p>2023-8-24 22:57:11</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;程序员真是一个活到老学到老的职业，一天不学习就会掉队，『内存顺序模型』对于我来说就是一个新的世界，虽然之前写过多线程的服务器，也处理过死锁和竞态条件等问题，但是从来没考虑过内存顺序问题，所以当我第一次看到这个概念时，整个人都是懵的，经过一段时间的学习和了解有了初步的认识，所以简单总结下来，以备后续查看，不多写，慢慢总结。&lt;/p&gt;
    
    </summary>
    
      <category term="C/C++" scheme="http://AlbertGithubHome.github.io/blog/categories/C-C/"/>
    
    
      <category term="C/C++" scheme="http://AlbertGithubHome.github.io/blog/tags/C-C/"/>
    
      <category term="内存顺序" scheme="http://AlbertGithubHome.github.io/blog/tags/%E5%86%85%E5%AD%98%E9%A1%BA%E5%BA%8F/"/>
    
      <category term="无锁编程" scheme="http://AlbertGithubHome.github.io/blog/tags/%E6%97%A0%E9%94%81%E7%BC%96%E7%A8%8B/"/>
    
      <category term="指令重排" scheme="http://AlbertGithubHome.github.io/blog/tags/%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92/"/>
    
  </entry>
  
  <entry>
    <title>linux环境下Shell脚本中定义函数</title>
    <link href="http://AlbertGithubHome.github.io/blog/2023/08/15/linux%E7%8E%AF%E5%A2%83%E4%B8%8BShell%E8%84%9A%E6%9C%AC%E4%B8%AD%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0/"/>
    <id>http://AlbertGithubHome.github.io/blog/2023/08/15/linux环境下Shell脚本中定义函数/</id>
    <published>2023-08-15T14:46:29.000Z</published>
    <updated>2023-09-03T12:54:02.752Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>说实话，这是我第一次用Shell来定义函数，之前也写了很多shell脚本，但是体量都不大，所以基本上是按照需求罗列了多个命令来实现的，这次也是一样，但是我发现重复的地方太多了，所以还是要拿出看见本事“抽象函数”来解放我懒惰的手指</p><a id="more"></a><h1 id="具体需求"><a href="#具体需求" class="headerlink" title="具体需求"></a>具体需求</h1><blockquote><p>检测特定名称的进程是否存在，若不存在则重新启动这个进程</p></blockquote><p>仿照着之前的类似的脚本我写出了以下函数 <code>check_and_fix_process</code>，仅有一个需要注意的点就是Shell函数不需要定义参数，如果用到参数直接是用 <code>$1</code>、 <code>$2</code>、 <code>$3</code>……依次来代替就可以了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查并修复进程的函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">check_and_fix_process</span></span>() &#123;</span><br><span class="line">        <span class="comment"># $1 进程名</span></span><br><span class="line">        <span class="comment"># $2 进程ID列表文件名</span></span><br><span class="line">        <span class="comment"># $3 进程ID列表文件md5值</span></span><br><span class="line"></span><br><span class="line">        datetime=$(date +%y%m%d%H%M%S)</span><br><span class="line">        ps aux |grep <span class="string">"<span class="variable">$1</span>"</span> |grep -v grep |awk <span class="string">'&#123;print $15&#125;'</span> |awk -F <span class="string">'='</span> <span class="string">'&#123;print $2&#125;'</span>|sort -n &gt; ~/tmplist</span><br><span class="line"></span><br><span class="line">        a=$(md5sum ~/tmplist |awk <span class="string">'&#123;print $1&#125;'</span>)</span><br><span class="line">        b=<span class="string">"<span class="variable">$3</span>"</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> [[ <span class="variable">$a</span> = <span class="variable">$b</span> ]]; <span class="keyword">then</span></span><br><span class="line">                <span class="built_in">echo</span> <span class="string">"check [<span class="variable">$1</span> <span class="variable">$2</span> <span class="variable">$3</span>] ok"</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">                tmp=$(diff ~/<span class="string">"<span class="variable">$2</span>"</span> ~/tmplist |grep ^\&lt; |awk <span class="string">'&#123;print $2&#125;'</span> &gt; /tmp/tmplist)</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> `cat /tmp/tmplist`</span><br><span class="line">                <span class="keyword">do</span></span><br><span class="line">                        <span class="built_in">cd</span> ~/<span class="built_in">test</span> &amp;&amp; grep <span class="string">"ID=<span class="variable">$i</span>"</span> start.sh | xargs -I &#123;&#125; sh -c <span class="string">'&#123;&#125;'</span></span><br><span class="line"></span><br><span class="line">                        <span class="built_in">echo</span> <span class="string">"<span class="variable">$datetime</span> <span class="variable">$i</span>"</span> &gt;&gt;~/fixtxt</span><br><span class="line">                        python3 ~/send_msg.py -c <span class="string">"process:<span class="variable">$i</span> crashed; fixtime:<span class="variable">$datetime</span>"</span></span><br><span class="line">                <span class="keyword">done</span></span><br><span class="line">        <span class="keyword">fi</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># check all process list</span></span><br><span class="line">check_and_fix_process <span class="string">"AProcess"</span> <span class="string">"aprocesslist"</span> <span class="string">"a887eedb72472f2ad152e5e91a0727da"</span></span><br><span class="line">check_and_fix_process <span class="string">"BProcess"</span> <span class="string">"bprocesslist"</span> <span class="string">"a887eedb72472f2ad152e5e91a0727db"</span></span><br></pre></td></tr></table></figure><h1 id="ChatGPT读代码"><a href="#ChatGPT读代码" class="headerlink" title="ChatGPT读代码"></a>ChatGPT读代码</h1><p>如果对于这段代码有不理解的地方，可以请ChatGPT来帮忙，以下内容是它的解释，不得不说真是太强大了！身为此段代码的实现者，我都描述不了这么详细</p><hr><p>这段代码是一个 Bash 脚本，用于检查指定的进程是否正常运行，并在发现异常时进行修复操作。下面逐行解释代码：</p><ol><li><p><code>function check_and_fix_process() {</code>: 定义了一个名为 <code>check_and_fix_process</code> 的 Bash 函数。</p></li><li><p><code># $1 进程名</code>: 这是一个注释，表示函数的第一个参数是进程名。</p></li><li><p><code># $2 进程ID列表文件名</code>: 这是一个注释，表示函数的第二个参数是进程ID列表文件的文件名。</p></li><li><p><code># $3 进程ID列表文件md5值</code>: 这是一个注释，表示函数的第三个参数是进程ID列表文件的MD5值。</p></li><li><p><code>datetime=$(date +%y%m%d%H%M%S)</code>: 获取当前日期和时间，并将其格式化为”YYMMDDHHMMSS”的形式，存储在变量 <code>datetime</code> 中。</p></li><li><p><code>ps aux |grep &quot;$1&quot; |grep -v grep |awk &#39;{print $15}&#39; |awk -F &#39;=&#39; &#39;{print $2}&#39;|sort -n &gt; ~/tmplist</code>: 这一行通过一系列的管道命令来查找指定进程名 <code>$1</code> 的进程，提取其中的某个列（可能是进程ID），然后排序，将结果保存到文件 <code>~/tmplist</code> 中。</p></li><li><p><code>a=$(md5sum ~/tmplist |awk &#39;{print $1}&#39;)</code>: 计算文件 <code>~/tmplist</code> 的 MD5 值，并将结果保存在变量 <code>a</code> 中。</p></li><li><p><code>b=&quot;$3&quot;</code>: 将第三个参数值（进程ID列表文件的MD5值）保存在变量 <code>b</code> 中。</p></li><li><p><code>if [[ $a = $b ]]; then</code>: 如果变量 <code>a</code> 的值等于变量 <code>b</code> 的值（即进程ID列表文件的MD5值相匹配），则执行下面的代码块。</p></li><li><p><code>echo &quot;check [$1 $2 $3] ok&quot;</code>: 输出一条信息表示检查通过。</p></li><li><p><code>else</code>: 如果进程ID列表文件的MD5值不匹配，则执行下面的代码块。</p></li><li><p><code>tmp=$(diff ~/&quot;$2&quot; ~/tmplist |grep ^\&lt; |awk &#39;{print $2}&#39; &gt; /tmp/tmplist)</code>: 比较进程ID列表文件（路径为 <code>~/&quot;$2&quot;</code>)和当前的进程ID列表文件 (<code>~/tmplist</code>)，将不匹配的部分提取出来并保存在临时文件 <code>/tmp/tmplist</code> 中。</p></li><li><p><code>for i in $(cat /tmp/tmplist)</code>: 循环遍历临时文件 <code>/tmp/tmplist</code> 中的每一行内容。</p></li><li><p><code>do</code>: 循环体开始。</p></li><li><p><code>cd ~/test &amp;&amp; grep &quot;ID=$i&quot; start.sh | xargs -I {} sh -c &#39;{}&#39;</code>: 这一行的作用是切换到目录 <code>~/test</code> 并在 <code>start.sh</code> 文件中查找包含字符串 “ID=$i” 的行，然后执行找到的行（通常是一些命令）。</p></li><li><p><code>echo &quot;$datetime $i&quot; &gt;&gt;~/fixtxt</code>: 将当前日期时间和进程ID添加到文件 <code>~/fixtxt</code> 中。</p></li><li><p><code>python3 ~/send_msg.py -c &quot;process:$i crashed; fixtime:$datetime&quot;</code>: 调用 Python 脚本 <code>send_msg.py</code> 并传递一条消息，该消息包含进程ID以及修复操作的时间。</p></li><li><p><code>done</code>: 循环结束。</p></li><li><p><code>fi</code>: 条件分支结束。</p></li><li><p><code>}</code>: 函数定义结束。</p></li><li><p><code>check_and_fix_process &quot;AProcess&quot; &quot;aprocesslist&quot; &quot;a887eedb72472f2ad152e5e91a0727da&quot;</code>: 调用 <code>check_and_fix_process</code> 函数，检查名为 “AProcess” 的进程是否正常运行，使用文件 “aprocesslist” 作为进程ID列表文件，并传递预期的MD5值。</p></li><li><p><code>check_and_fix_process &quot;BProcess&quot; &quot;bprocesslist&quot; &quot;a887eedb72472f2ad152e5e91a0727db&quot;</code>: 同上，检查名为 “BProcess” 的进程是否正常运行，使用文件 “bprocesslist” 作为进程ID列表文件，并传递预期的MD5值。</p></li></ol><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>Shell脚本中的函数不需要定义参数，如果用到参数直接是用 <code>$1</code>、 <code>$2</code>、 <code>$3</code>……依次来代替就可以</li><li>Shell脚本函数中使用 $1 作为参数，并不会与内部命令的 $1 冲突，因为Shell在不同的上下文中，变量的作用域是不同的</li></ul><center><a href="https://blog.csdn.net/albertsh/article/details/132245367" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>看我ge，看我nai，看我jiu，玩的开心吗？</p><p>2023-8-15 22:41:32</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;说实话，这是我第一次用Shell来定义函数，之前也写了很多shell脚本，但是体量都不大，所以基本上是按照需求罗列了多个命令来实现的，这次也是一样，但是我发现重复的地方太多了，所以还是要拿出看见本事“抽象函数”来解放我懒惰的手指&lt;/p&gt;
    
    </summary>
    
      <category term="linux" scheme="http://AlbertGithubHome.github.io/blog/categories/linux/"/>
    
    
      <category term="linux" scheme="http://AlbertGithubHome.github.io/blog/tags/linux/"/>
    
      <category term="运维" scheme="http://AlbertGithubHome.github.io/blog/tags/%E8%BF%90%E7%BB%B4/"/>
    
      <category term="服务器" scheme="http://AlbertGithubHome.github.io/blog/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
      <category term="Shell函数" scheme="http://AlbertGithubHome.github.io/blog/tags/Shell%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu删除大量磁盘文件时，内存cache降free升而创造的漂亮曲线</title>
    <link href="http://AlbertGithubHome.github.io/blog/2023/08/15/Ubuntu%E5%88%A0%E9%99%A4%E5%A4%A7%E9%87%8F%E7%A3%81%E7%9B%98%E6%96%87%E4%BB%B6%E6%97%B6%EF%BC%8C%E5%86%85%E5%AD%98cache%E9%99%8Dfree%E5%8D%87%E8%80%8C%E5%88%9B%E9%80%A0%E7%9A%84%E6%BC%82%E4%BA%AE%E6%9B%B2%E7%BA%BF/"/>
    <id>http://AlbertGithubHome.github.io/blog/2023/08/15/Ubuntu删除大量磁盘文件时，内存cache降free升而创造的漂亮曲线/</id>
    <published>2023-08-15T14:44:05.000Z</published>
    <updated>2023-09-03T12:52:02.083Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近在做压力测试，对磁盘、CPU、内存等指标比较敏感，因为产生了大量的日志文件需要定期删除，于是写了个定时清理磁盘的脚本，今天早上发现内存曲线居然产生了一个漂亮的图形，不知道你们想到了什么？看到这曲线我首先想到的是《编程之美》中那个“让CPU占用率曲线听你指挥” 的面试题，是不是得加一个想内存使用率曲线听你指挥啊？</p><a id="more"></a><h1 id="图形本尊"><a href="#图形本尊" class="headerlink" title="图形本尊"></a>图形本尊</h1><p>我所说的漂亮曲线入下图所示，是不是有一种对称美？</p><p><img src="https://img-blog.csdnimg.cn/f59c901aa1e945b780072ebc4cef60aa.png" alt="memory"></p><p>搭配这条曲线的还有当时的磁盘占用曲线，两幅图对比基本可以确定这两个指标是相关的</p><p><img src="https://img-blog.csdnimg.cn/a1e60162702149a482c53aeb75024973.png" alt="disk"></p><h1 id="产生的原因"><a href="#产生的原因" class="headerlink" title="产生的原因"></a>产生的原因</h1><p>关于实际的原因我不能给出准确的解释，所以跑去问了GPT，它的回答内容如下，如果有不同意的小伙伴欢迎来反驳：</p><blockquote><p>在Ubuntu或其他Linux操作系统中，当你删除大量磁盘文件时，可能会看到内存缓存（cache）降低而”free”（可用内存）升高的情况。这是由于Linux的内存管理机制导致的，这个机制是为了最大程度地提高系统性能。</p><p>当你删除文件时，内核会将这些文件从文件系统中删除，但为了提高文件访问的效率，已经读取的数据可能会被保留在内存的缓存中。这样，如果在不久的将来需要访问相同的文件，可以直接从内存缓存中获取，而不必从磁盘读取。这个缓存被称为”page cache”，它占用一部分内存。</p><p>当你删除大量文件时，这些文件所占用的内存缓存将被释放，以便更好地利用内存来满足其他正在运行的程序的需求。因此，内存缓存的降低是一个正常现象。</p><p>同时，”free”命令在Linux中显示的”free”内存指的是没有被使用的内存，包括未被分配的内存和被内核回收的缓存。因此，当你删除大量文件时，已释放的缓存会被计算在”free”内存中，导致”free”内存升高。</p><p>这种行为是Linux内存管理的一部分，它旨在在系统性能和内存使用之间找到平衡。当系统需要更多内存时，它可以释放缓存来满足正在运行的程序的需求。所以，不要担心这种情况，它是Linux操作系统的正常行为。</p></blockquote><h1 id="补一个长周期对比图"><a href="#补一个长周期对比图" class="headerlink" title="补一个长周期对比图"></a>补一个长周期对比图</h1><p><img src="https://img-blog.csdnimg.cn/253f2b6dd2454943b24016c08591d5ac.png" alt="mem-disk"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>想要控制好计算机资源产生自定义曲线，控制好“消耗”就可以了，但是如何控制是门学问，需要考虑的各种相关因素</li><li>为了提高文件访问的效率，已经读取的数据可能会被保留在内存的缓存中，其被称为”page cache”，便于下次访问直接从内存缓存中获取</li><li>当删除大量文件时，已释放的缓存会被计算在”free”内存中，导致”free”内存升高</li></ul><center><a href="https://blog.csdn.net/albertsh/article/details/132240499" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>风急天高猿啸哀，渚清沙白鸟飞回。无边落木萧萧下，不尽长江滚滚来~</p><p>2023-8-12 10:41:18</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;最近在做压力测试，对磁盘、CPU、内存等指标比较敏感，因为产生了大量的日志文件需要定期删除，于是写了个定时清理磁盘的脚本，今天早上发现内存曲线居然产生了一个漂亮的图形，不知道你们想到了什么？看到这曲线我首先想到的是《编程之美》中那个“让CPU占用率曲线听你指挥” 的面试题，是不是得加一个想内存使用率曲线听你指挥啊？&lt;/p&gt;
    
    </summary>
    
      <category term="linux" scheme="http://AlbertGithubHome.github.io/blog/categories/linux/"/>
    
    
      <category term="Ubuntu" scheme="http://AlbertGithubHome.github.io/blog/tags/Ubuntu/"/>
    
      <category term="DevOps" scheme="http://AlbertGithubHome.github.io/blog/tags/DevOps/"/>
    
      <category term="服务器性能调优" scheme="http://AlbertGithubHome.github.io/blog/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/"/>
    
  </entry>
  
  <entry>
    <title>常用游戏运营指标DAU、LTV及参考范围</title>
    <link href="http://AlbertGithubHome.github.io/blog/2023/08/11/%E5%B8%B8%E7%94%A8%E6%B8%B8%E6%88%8F%E8%BF%90%E8%90%A5%E6%8C%87%E6%A0%87DAU%E3%80%81LTV%E5%8F%8A%E5%8F%82%E8%80%83%E8%8C%83%E5%9B%B4/"/>
    <id>http://AlbertGithubHome.github.io/blog/2023/08/11/常用游戏运营指标DAU、LTV及参考范围/</id>
    <published>2023-08-11T14:28:52.000Z</published>
    <updated>2023-09-03T12:49:58.168Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>作为游戏人免不了听到 <code>DAU</code> 、<code>UP值</code>、<code>留存</code> 等名词，并且有些名词听起来还很像，特别是一款上线的游戏，这些游戏运营指标是衡量游戏业务绩效和用户参与度的重要数据，想做一个合格的游戏人得花点时间了解一下，接下来会总结一些常见的游戏运营指标及其简称。</p><a id="more"></a><h1 id="运营指标"><a href="#运营指标" class="headerlink" title="运营指标"></a>运营指标</h1><ul><li><strong>DAU</strong> - 日活跃用户 (Daily Active Users)：每日登录游戏的独立用户数量</li><li><strong>MAU</strong> - 月活跃用户 (Monthly Active Users)：每月登录游戏的独立用户数量</li><li><strong>ARPU</strong> - 平均收入每用户 (Average Revenue Per User)：平均每个用户带来的收入</li><li><strong>ARPDAU</strong> - 每日平均收入每用户 (Average Revenue Per Daily Active User)：每日平均每个活跃用户带来的收入</li><li><strong>ARPPU</strong> - 平均付费用户收入 (Average Revenue Per Paying User)：平均每个付费用户带来的收入</li><li><strong>Retention Rate</strong> - 留存率：测量特定时间段内用户的保留情况，通常以百分比表示</li><li><strong>Churn Rate</strong> - 流失率：衡量用户流失的速度，通常以月度或年度为周期</li><li><strong>Conversion Rate</strong> - 转化率：衡量用户从免费用户转化为付费用户的比率</li><li><strong>LTV</strong> - 用户生命周期价值 (Lifetime Value)：预测一个用户在其使用周期内可能带来的总收入</li><li><strong>CAC</strong> - 用户获取成本 (Customer Acquisition Cost)：获取一个新用户所花费的成本</li><li><strong>ROI</strong> - 投资回报率 (Return on Investment)：衡量游戏营销和推广活动的效果</li><li><strong>ARPPDAU</strong> - 每日平均收入每付费用户 (Average Revenue Per Paying Daily Active User)：每日平均每个付费活跃用户带来的收入。</li><li><strong>ACPU</strong> - 平均成本每用户 (Average Cost Per User)：获取每个用户的平均成本</li><li><strong>Conversion Funnel</strong> - 转化漏斗：衡量用户从首次接触游戏到最终付费的整个过程</li><li><strong>UGC</strong> - 用户生成内容 (User-Generated Content)：用户创造的游戏内容，如自定义角色、地图等，对游戏社区的活跃度有影响</li></ul><p>这些指标可以帮助游戏开发者和运营者了解游戏的商业表现和用户行为，从而优化游戏的设计和运营策略。</p><h1 id="指标范围参考值"><a href="#指标范围参考值" class="headerlink" title="指标范围参考值"></a>指标范围参考值</h1><p>知道了有上述的运营指标，但是一款合格的游戏上述指标应该达到多少呢？</p><p>其实每款游戏的合格水平可能会因多种因素而有所不同，包括游戏类型、目标市场、营销策略以及开发成本等，并不是固定的标准，实际情况会受到众多因素的影响，包括游戏的质量、竞争情况、玩家喜好以及运营策略等，下面进给出一些参考值。</p><ul><li><strong>DAU</strong> - 日活跃用户：数百到数千，具体取决于游戏的类型和受众规模</li><li><strong>MAU</strong> - 月活跃用户：数千到数万，取决于市场规模和竞争状况</li><li><strong>ARPU</strong> - 平均收入每用户：几美元到十几美元，视付费玩家比例而定</li><li><strong>ARPDAU</strong> - 每日平均收入每用户：几分到几毛美元，视玩家付费情况而定</li><li><strong>ARPPU</strong> - 平均付费用户收入：十美元到数十美元，取决于游戏内购的设计和价值</li><li><strong>Retention Rate</strong> - 留存率：20%-50% 之间，高于 50% 为很好的表现。</li><li><strong>Churn Rate</strong> - 流失率：低于 10% 为很好的表现。</li><li><strong>Conversion Rate</strong> - 转化率：2%-5% 之间，高于 5% 为不错的表现。</li><li><strong>LTV</strong> - 用户生命周期价值：数十美元到数百美元，取决于玩家的长期付费情况。</li><li><strong>CAC</strong> - 用户获取成本：通常 LTV 的 1/3 到 1/2，以确保收益能覆盖用户获取成本。</li></ul><p>这些值仅供参考，并不适用于所有情况。游戏开发者和运营者需要根据自己的情况制定合适的目标，并随着游戏的运营进行不断优化。同时，密切关注竞争对手的表现也是非常重要的。</p><h1 id="留存指标的意义"><a href="#留存指标的意义" class="headerlink" title="留存指标的意义"></a>留存指标的意义</h1><p>留存率是衡量用户参与度和游戏粘性的重要指标之一。它衡量了一段时间内用户的持续参与情况，通常以百分比表示。针对回合制卡牌游戏，留存率的及格线会受到多种因素的影响，包括游戏的类型、受众群体、市场竞争、游戏质量、运营策略等等</p><ul><li><p><strong>次日留存率</strong>：在 30% - 40% 以上被视为相当不错的表现。这意味着有相当比例的玩家在第一次体验游戏后仍然对游戏感兴趣，并愿意在第二天继续游戏。</p></li><li><p><strong>3日留存率</strong>：通常在 20% - 40% 之间被视为良好的表现。这表示在游戏初始安装后的头三天内，有相当比例的玩家愿意继续登录游戏。</p></li><li><strong>7日留存率</strong>：较高的及格线通常在 15% - 30% 左右。相比于3日留存，7日留存更能体现游戏对玩家的长期吸引力。</li><li><strong>月留存率</strong>：这个指标较难界定“及格线”，但在 10% - 20% 以上的范围内被视为不错的表现。月留存更考验游戏的长期吸引力和社区活跃度。</li></ul><p>需要注意的是，这些及格线可能会根据不同的情况有所变化。例如，对于新发布的游戏，初始留存率可能会较高，但随着时间推移，可能会逐渐下降。此外，针对特定类型的玩家群体，留存率也可能有所不同。</p><p>这三个留存率指标都有助于了解游戏的玩家保持情况，但值得注意的是，不同类型的游戏可能会有不同的留存率标准，而且这些指标可能会受到市场、竞争、游戏类型以及运营策略的影响。提高留存率是游戏开发者和运营者追求的目标，因为更高的留存率通常意味着更好的长期经营和用户忠诚度。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li><strong>DAU</strong> - 日活跃用户 (Daily Active Users)：每日登录游戏的独立用户数量</li><li><strong>ARPU</strong> - 平均收入每用户 (Average Revenue Per User)：平均每个用户带来的收入</li><li><strong>LTV</strong> - 用户生命周期价值 (Lifetime Value)：预测一个用户在其使用周期内可能带来的总收入</li><li><strong>Retention Rate</strong> - 留存率：测量特定时间段内用户的保留情况，通常以百分比表示</li></ul><center><a href="https://blog.csdn.net/albertsh/article/details/132219946" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>挥手自兹去，萧萧班马鸣~</p><p>2023-8-10 22:34:28</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;作为游戏人免不了听到 &lt;code&gt;DAU&lt;/code&gt; 、&lt;code&gt;UP值&lt;/code&gt;、&lt;code&gt;留存&lt;/code&gt; 等名词，并且有些名词听起来还很像，特别是一款上线的游戏，这些游戏运营指标是衡量游戏业务绩效和用户参与度的重要数据，想做一个合格的游戏人得花点时间了解一下，接下来会总结一些常见的游戏运营指标及其简称。&lt;/p&gt;
    
    </summary>
    
      <category term="Game" scheme="http://AlbertGithubHome.github.io/blog/categories/Game/"/>
    
    
      <category term="游戏" scheme="http://AlbertGithubHome.github.io/blog/tags/%E6%B8%B8%E6%88%8F/"/>
    
      <category term="大数据" scheme="http://AlbertGithubHome.github.io/blog/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="运行指标" scheme="http://AlbertGithubHome.github.io/blog/tags/%E8%BF%90%E8%A1%8C%E6%8C%87%E6%A0%87/"/>
    
      <category term="DAU" scheme="http://AlbertGithubHome.github.io/blog/tags/DAU/"/>
    
      <category term="LTV" scheme="http://AlbertGithubHome.github.io/blog/tags/LTV/"/>
    
  </entry>
  
</feed>
