<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Albert World</title>
  <icon>https://www.gravatar.com/avatar/8ccc6291d5bfd34e7aaf601c4ebec7e1</icon>
  
  <link href="/blog/atom.xml" rel="self"/>
  
  <link href="http://AlbertGithubHome.github.io/blog/"/>
  <updated>2021-09-12T15:31:06.530Z</updated>
  <id>http://AlbertGithubHome.github.io/blog/</id>
  
  <author>
    <name>Albert Shi</name>
    <email>347070901@qq.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Dijkstra——通过不断松弛来解决单源最短路径问题的算法</title>
    <link href="http://AlbertGithubHome.github.io/blog/2021/09/11/Dijkstra%E2%80%94%E2%80%94%E9%80%9A%E8%BF%87%E4%B8%8D%E6%96%AD%E6%9D%BE%E5%BC%9B%E6%9D%A5%E8%A7%A3%E5%86%B3%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98%E7%9A%84%E7%AE%97%E6%B3%95/"/>
    <id>http://AlbertGithubHome.github.io/blog/2021/09/11/Dijkstra——通过不断松弛来解决单源最短路径问题的算法/</id>
    <published>2021-09-11T15:28:12.000Z</published>
    <updated>2021-09-12T15:31:06.530Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Dijkstra算法又称迪杰斯特拉算法，它采用的是一种贪心的策略，使用广度优先搜索的方式解决带权有向图或者无向图的单源最短路径问题，需要注意的是它不能处理带负边权的情况，核心思想就是“<strong>守住现有阵地不断攻占底盘</strong>”，这一点可以在后面代码实现中慢慢体会，接下来梳理一下算法思路。</p><a id="more"></a><h1 id="Dijkstra思路"><a href="#Dijkstra思路" class="headerlink" title="Dijkstra思路"></a>Dijkstra思路</h1><p>Dijkstra 算法的思路是维护一个点集合 <code>S</code> 和一个用来保存起点 <code>m</code> 到各个顶点到各个顶点最短距离的数组 <code>dis</code>，用邻接数组来表示带权图信息。</p><p>初始情况时，集合 <code>S</code> 中只包括起点<code>m</code>，通过图信息来初始化 <code>dis</code> 数组，将起点 <code>m</code> 可以直接到达的点设置为边的权值，不能到达的点设置为无穷大，比如点 <code>m</code> 到点 <code>n</code> 的距离是d，则 <code>dis[n] = d</code>。</p><p>然后从带权图中选择不在集合<code>S</code> 中的到点 <code>m</code> 距离最近的点，假设为 <code>n</code>，把它加到集合 <code>S</code> 中，然后尝试通过点 <code>n</code> “松弛” 那些不在集合 <code>S</code> 中的点到点 <code>m</code>的距离，更新 <code>dis</code> 数组信息，具体操作就是使用点 <code>n</code> 作为中转，如果距离如果点 <code>m</code> 到任意点 <code>x</code> 通过点 <code>n</code> 中转距离变短了，那么就更新 <code>dis[x]</code> 的值。</p><p>之后不断重复上面的“松弛”操作，直到集合 <code>S</code> 中包含了所有得到顶点，至此就通过Dijkstra算法求解出了从点 <code>m</code> 到图中任意点的最短距离。</p><h1 id="图解实例"><a href="#图解实例" class="headerlink" title="图解实例"></a>图解实例</h1><!--看了上面的关于Dijkstra算法的文字描述可能还是有点蒙，这时候需要画个图来解释一下，对于算法问题，特别是图论方面的算法题，有时候真的是一图胜千言，奈何我真的是不想画图，一方面因为“懒”，另一方面就是图片的搬运比较麻烦，所以对于大部分问题我都是文字描述，但是为了解释这个Dijkstra我还是决定画一画，假如求解从点`a` 到各个顶点的最短距离，初始图信息如下：第一步，我们把点 `a` 添加到集合 `S` 中变为 `S = {a}`，然后初始化dis数组为 `dis = {0, 1, 12, ∞, ∞, ∞}`，加入集合的点用红色表示，操作之后更新如下：第二步，找到距离点 `a` 最近的且不在 `S` 中的点，根据 `dis` 数组计算应该是点 `b`，将点 `b` 添加到集合 `S` 中，通过点 `b` 中转更新 `dis` 数组，dis[c]变为8，dis[d]变为4，更新后集合为 `S = {a, b}`， 距离数组为 `dis = {0, 1, 8, 4, ∞, ∞}`, 图信息如下：第三步，找到距离点 `a` 最近的且不在 `S` 中的点，根据 `dis` 数组计算应该是点 `d`，将点 `d` 添加到集合 `S` 中，通过点 `d` 中转更新 `dis` 数组，dis[e]变为14，dis[f]变为17，更新后集合为 `S = {a, b, d}`， 距离数组为 `dis = {0, 1, 8, 4, 14, 17}`, 图信息如下：第四步，找到距离点 `a` 最近的且不在 `S` 中的点，根据 `dis` 数组计算应该是点 `c`，将点 `c` 添加到集合 `S` 中，通过点 `c` 中转更新 `dis` 数组，dis[e]变为13，更新后集合为 `S = {a, b, d, c}`， 距离数组为 `dis = {0, 1, 8, 4, 13, 17}`, 图信息如下：第五步，找到距离点 `a` 最近的且不在 `S` 中的点，根据 `dis` 数组计算应该是点 `e`，将点 `e` 添加到集合 `S` 中，通过点 `e` 中转更新 `dis` 数组，通过距离判断发现此次不需要更新dis数组，更新后集合为 `S = {a, b, d, c, e}`， 距离数组为 `dis = {0, 1, 8, 4, 13, 17}`, 图信息如下：第六步，找到距离点 `a` 最近的且不在 `S` 中的点，根据 `dis` 数组计算应该是点 `f`，将点 `f` 添加到集合 `S` 中，至此集合 `S` 中包含了所有的顶点，Dijkstra算法执行结束，集合信息为 `S = {a, b, d, c, e, f}`， 距离数组为 `dis = {0, 1, 8, 4, 13, 17}`, 图信息如下：--><p>看了上面的关于Dijkstra算法的文字描述可能还是有点蒙，这时候需要画个图来解释一下，对于算法问题，特别是图论方面的算法题，有时候真的是一图胜千言，奈何我真的是不想画图，一方面因为“懒”，另一方面就是图片的搬运比较麻烦，所以对于大部分问题我都是文字描述，但是为了解释这个Dijkstra我还是决定画一画，假如求解从点<code>a</code> 到各个顶点的最短距离，初始图信息如下：</p><p><img src="https://img-blog.csdnimg.cn/0bdcb09cb6574b32b194e25087c4f9a3.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9hbGJlcnRnaXRodWJob21lLmdpdGh1Yi5pby9ibG9nL2Fib3V0,size_18,color_FFFFFF,t_70#pic_center" alt="Dijkstra_0"></p><p>第一步，我们把点 <code>a</code> 添加到集合 <code>S</code> 中变为 <code>S = {a}</code>，然后初始化dis数组为 <code>dis = {0, 1, 12, ∞, ∞, ∞}</code>，加入集合的点用红色表示，操作之后更新如下：</p><p><img src="https://img-blog.csdnimg.cn/51fcb81971eb4d3c8cfdd24ee82e5494.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9hbGJlcnRnaXRodWJob21lLmdpdGh1Yi5pby9ibG9nL2Fib3V0,size_18,color_FFFFFF,t_70#pic_center" alt="Dijkstra_1"></p><p>第二步，找到距离点 <code>a</code> 最近的且不在 <code>S</code> 中的点，根据 <code>dis</code> 数组计算应该是点 <code>b</code>，将点 <code>b</code> 添加到集合 <code>S</code> 中，通过点 <code>b</code> 中转更新 <code>dis</code> 数组，dis[c]变为8，dis[d]变为4，更新后集合为 <code>S = {a, b}</code>， 距离数组为 <code>dis = {0, 1, 8, 4, ∞, ∞}</code>, 图信息如下：</p><p><img src="https://img-blog.csdnimg.cn/9e3b38dd6ab943979002b646bb79c9e4.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9hbGJlcnRnaXRodWJob21lLmdpdGh1Yi5pby9ibG9nL2Fib3V0,size_18,color_FFFFFF,t_70#pic_center" alt="Dijkstra_2"></p><p>第三步，找到距离点 <code>a</code> 最近的且不在 <code>S</code> 中的点，根据 <code>dis</code> 数组计算应该是点 <code>d</code>，将点 <code>d</code> 添加到集合 <code>S</code> 中，通过点 <code>d</code> 中转更新 <code>dis</code> 数组，dis[e]变为14，dis[f]变为17，更新后集合为 <code>S = {a, b, d}</code>， 距离数组为 <code>dis = {0, 1, 8, 4, 14, 17}</code>, 图信息如下：</p><p><img src="https://img-blog.csdnimg.cn/bf9efd1a9f7247318cc3c609af99b46a.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9hbGJlcnRnaXRodWJob21lLmdpdGh1Yi5pby9ibG9nL2Fib3V0,size_18,color_FFFFFF,t_70#pic_center" alt="Dijkstra_3"></p><p>第四步，找到距离点 <code>a</code> 最近的且不在 <code>S</code> 中的点，根据 <code>dis</code> 数组计算应该是点 <code>c</code>，将点 <code>c</code> 添加到集合 <code>S</code> 中，通过点 <code>c</code> 中转更新 <code>dis</code> 数组，dis[e]变为13，更新后集合为 <code>S = {a, b, d, c}</code>， 距离数组为 <code>dis = {0, 1, 8, 4, 13, 17}</code>, 图信息如下：</p><p><img src="https://img-blog.csdnimg.cn/4fc4077f20d141ddaf95ab07940c1bb7.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9hbGJlcnRnaXRodWJob21lLmdpdGh1Yi5pby9ibG9nL2Fib3V0,size_18,color_FFFFFF,t_70#pic_center" alt="Dijkstra_4"></p><p>第五步，找到距离点 <code>a</code> 最近的且不在 <code>S</code> 中的点，根据 <code>dis</code> 数组计算应该是点 <code>e</code>，将点 <code>e</code> 添加到集合 <code>S</code> 中，通过点 <code>e</code> 中转更新 <code>dis</code> 数组，通过距离判断发现此次不需要更新dis数组，更新后集合为 <code>S = {a, b, d, c, e}</code>， 距离数组为 <code>dis = {0, 1, 8, 4, 13, 17}</code>, 图信息如下：</p><p><img src="https://img-blog.csdnimg.cn/37b5260c109f41d1bdb43bf347d88088.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9hbGJlcnRnaXRodWJob21lLmdpdGh1Yi5pby9ibG9nL2Fib3V0,size_18,color_FFFFFF,t_70#pic_center" alt="Dijkstra_5"></p><p>第六步，找到距离点 <code>a</code> 最近的且不在 <code>S</code> 中的点，根据 <code>dis</code> 数组计算应该是点 <code>f</code>，将点 <code>f</code> 添加到集合 <code>S</code> 中，至此集合 <code>S</code> 中包含了所有的顶点，Dijkstra算法执行结束，集合信息为 <code>S = {a, b, d, c, e, f}</code>， 距离数组为 <code>dis = {0, 1, 8, 4, 13, 17}</code>, 图信息如下：</p><p><img src="https://img-blog.csdnimg.cn/17a7704ff3c943b987a7e85b9411b3f2.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9hbGJlcnRnaXRodWJob21lLmdpdGh1Yi5pby9ibG9nL2Fib3V0,size_18,color_FFFFFF,t_70#pic_center" alt="Dijkstra_6"></p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><p>通过上面的图解实例对于Dijkstra的实现应该有了一些思路，那么接下来我们把它转化成代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; graph)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dis = graph[<span class="number">0</span>];</span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; S;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> n = dis.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, x = <span class="number">0</span>; i &lt; n; i++, x = <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// find  minimum weight</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) <span class="keyword">if</span> (!S.count(j) &amp;&amp; (x == <span class="number">0</span> || dis[j] &lt; dis[x])) x = j;</span><br><span class="line"></span><br><span class="line">        S.insert(x);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// relax</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) <span class="keyword">if</span> (!S.count(j) &amp;&amp; dis[x] + graph[x][j] &lt; dis[j]) dis[j] = dis[x] + graph[x][j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行上述代码之后我们便得到了节点0到任意点的最短路径长度数组 <code>dis</code>。</p><p>从上面的分析我们可以知道从点 <code>a</code> 到点 <code>f</code> 的最短路径长度是 17，那么最短路径怎样求呢？</p><p>其实只要在做松弛操作时记录每个节点是从哪个节点松弛得到的就可以了，比如可以使用一个pre数组来记录这个信息，当计算 dis 结束时通过pre数组反推就可以得到最短路径，简单实现如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; graph)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dis = graph[<span class="number">0</span>];</span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; S;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> n = dis.size();</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pre(n, <span class="number">0</span>); <span class="comment">// save previous point index</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, x = <span class="number">0</span>; i &lt; n; i++, x = <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// find  minimum weight</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) <span class="keyword">if</span> (!S.count(j) &amp;&amp; (x == <span class="number">0</span> || dis[j] &lt; dis[x])) x = j;</span><br><span class="line"></span><br><span class="line">        S.insert(x);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// relax</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) <span class="keyword">if</span> (!S.count(j) &amp;&amp; dis[x] + graph[x][j] &lt; dis[j]) &#123;</span><br><span class="line">            dis[j] = dis[x] + graph[x][j];</span><br><span class="line">            pre[j] = x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// output path info</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path&#123;<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">while</span>(path.back() != <span class="number">0</span>) &#123;</span><br><span class="line">        path.push_back(pre[path.back()]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = path.rbegin(); it != path.rend(); it++)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>Dijkstra算法的时间复杂度为<code>O(N^2)</code>，空间复杂度为 <code>O(N)</code>，如果对时间复杂度有更高要求可以使用堆结构进行优化</li><li>Dijkstra是一种求解单源最短路径的算法，在时间复杂度这一项要优于之前所说的 Floyd 算法</li><li>Dijkstra不能处理带负边权的情况，不过实际生活中类似于行车路线、管道铺设等问题都不会有负边权，应用还是比较广泛的</li><li>该算法仔细分析之后还是比较好理解的，不过还是有一些变型和编程技巧，需要在实际问题中灵活变通</li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/120148274" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>历史总是惊人的相似，却不会简单的重复。在柯立芝实行了以放任自流的经济政策之后，紧接着便迎来了1929年的大萧条；而在克林顿到小布什任期内采取的经济自由化的政策，引发了之后2008年的国际金融危机；如今我们抬头看看大洋彼岸那疯狂运转的印钞机，这次的泡泡或许很快就能迎来炸裂的时刻~</p><p>2021-9-12 23:29:46</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;Dijkstra算法又称迪杰斯特拉算法，它采用的是一种贪心的策略，使用广度优先搜索的方式解决带权有向图或者无向图的单源最短路径问题，需要注意的是它不能处理带负边权的情况，核心思想就是“&lt;strong&gt;守住现有阵地不断攻占底盘&lt;/strong&gt;”，这一点可以在后面代码实现中慢慢体会，接下来梳理一下算法思路。&lt;/p&gt;
    
    </summary>
    
      <category term="C/C++" scheme="http://AlbertGithubHome.github.io/blog/categories/C-C/"/>
    
    
      <category term="C++" scheme="http://AlbertGithubHome.github.io/blog/tags/C/"/>
    
      <category term="Dijkstra" scheme="http://AlbertGithubHome.github.io/blog/tags/Dijkstra/"/>
    
      <category term="算法" scheme="http://AlbertGithubHome.github.io/blog/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="最短路径" scheme="http://AlbertGithubHome.github.io/blog/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/"/>
    
  </entry>
  
  <entry>
    <title>Floyd-Warshall——仅用4行代码就能解决多源最短路径问题的算法</title>
    <link href="http://AlbertGithubHome.github.io/blog/2021/09/05/Floyd-Warshall%E2%80%94%E2%80%94%E4%BB%85%E7%94%A85%E8%A1%8C%E4%BB%A3%E7%A0%81%E5%B0%B1%E8%83%BD%E8%A7%A3%E5%86%B3%E5%A4%9A%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98%E7%9A%84%E7%AE%97%E6%B3%95/"/>
    <id>http://AlbertGithubHome.github.io/blog/2021/09/05/Floyd-Warshall——仅用5行代码就能解决多源最短路径问题的算法/</id>
    <published>2021-09-04T16:42:38.000Z</published>
    <updated>2021-09-06T17:25:24.807Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Floyd-Warshall算法简记Floyd算法，又称弗洛伊德算法，是解决任意两点间的最短路径问题的一种常用算法，核心思想就是“<strong>不断利用第三者影响原配关系</strong>”，这一点在4行核心代码中表现的淋漓尽致，接下来梳理一下算法思路。</p><a id="more"></a><h1 id="Floyd思路"><a href="#Floyd思路" class="headerlink" title="Floyd思路"></a>Floyd思路</h1><p>从A点走到B点要想路径最短只有两种可能，一种就是直接从A到B，另一种就是通过其他点来中转，Floyd的思路就是先把直接能到达的点固定下来，然后不断的尝试从其他点来中转来降低路程。</p><p>Floyd算法实现通常使用一个二维数组来表示任意两点之间的初始距离，每个点到自身的距离为0，若两个点之间没有直接连通，则赋值为 <code>+∞</code>，我们假设这个二维数组是 <code>v</code>，则 <code>v[i][j]</code> 代表了从点 <code>i</code> 到点 <code>j</code> 的初始距离。</p><p>假设不允许中转，那么二维数组 <code>v</code> 中的数据就代表了任意两点间的距离。</p><p>如果允许中转一次，我们假设只允许从节点1进行中转，那么点 <code>i</code> 到点 <code>j</code> 的最近距离最小为 <code>v[i][j]</code> 或者 <code>v[i][1] + v[1][j]</code>，如果 <code>v[i][1] + v[1][j]</code> 的值更小，我们可以使用它来更新 <code>v[i][j]</code> 的值，这时 <code>v[i][j]</code> 就不仅仅是一个值了，而是隐含着 <code>i-&gt;1-&gt;j</code> 这样一条路径，这个过程实际上翻译成代码就是：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">        v[i][j] = min(v[i][j], v[i][<span class="number">1</span>] + v[<span class="number">1</span>][j]);</span><br></pre></td></tr></table></figure><p>那么这条路径怎样才能更短呢？</p><p>答案就是引入另一个点，比如我们不仅允许从节点1中转，也允许从节点2中转，从上一步我们知道从从点 <code>i</code> 到点 <code>j</code> 的最短距离是从 <code>i-&gt;1-&gt;j</code> 得到的，实际上经过上面一步，任意两点的距离都是允许从节点1中转条件下的最小值， 那么引入节点2之后就是要看看 <code>v[i][j]</code> 和 <code>v[i][2] + v[2][j]</code> 谁更小一点，然后遍历更新即可，类似的代码可以写成：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">        v[i][j] = min(v[i][j], v[i][<span class="number">2</span>] + v[<span class="number">2</span>][j]);</span><br></pre></td></tr></table></figure><p>看到套路了没有，就是每个点都作为一个可能中转的点来试一下，整个算法就结束了，好神奇~ 完整4行代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n; k++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">            v[i][j] = min(v[i][j], v[i][k] + v[k][j]);</span><br></pre></td></tr></table></figure><p>简单粗暴又不失美感！</p><h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><p>初始路径及每条边的距离如图：</p><p><img src="https://img-blog.csdnimg.cn/7a32a9cd366a4d8eaab56d8916b08953.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9hbGJlcnRnaXRodWJob21lLmdpdGh1Yi5pby9ibG9nL2Fib3V0,size_15,color_FFFFFF,t_70#pic_center" alt="路径"></p><ol><li>翻译成二维数组如下：</li></ol><table><thead><tr><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th></tr></thead><tbody><tr><td style="text-align:center">0</td><td style="text-align:center">2</td><td style="text-align:center">7</td><td style="text-align:center">4</td></tr><tr><td style="text-align:center">∞</td><td style="text-align:center">0</td><td style="text-align:center">4</td><td style="text-align:center">∞</td></tr><tr><td style="text-align:center">9</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">∞</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">∞</td><td style="text-align:center">15</td><td style="text-align:center">0</td></tr></tbody></table><ol><li>仅通过节点0作为中转，二维数组更新如下：</li></ol><table><thead><tr><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th></tr></thead><tbody><tr><td style="text-align:center">0</td><td style="text-align:center">2</td><td style="text-align:center">7</td><td style="text-align:center">4</td></tr><tr><td style="text-align:center">∞</td><td style="text-align:center">0</td><td style="text-align:center">4</td><td style="text-align:center">∞</td></tr><tr><td style="text-align:center">9</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">13</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">8</td><td style="text-align:center">13</td><td style="text-align:center">0</td></tr></tbody></table><ol><li>增加节点1作为中转，二维数组更新如下：</li></ol><table><thead><tr><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th></tr></thead><tbody><tr><td style="text-align:center">0</td><td style="text-align:center">2</td><td style="text-align:center">6</td><td style="text-align:center">4</td></tr><tr><td style="text-align:center">∞</td><td style="text-align:center">0</td><td style="text-align:center">4</td><td style="text-align:center">∞</td></tr><tr><td style="text-align:center">9</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">13</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">8</td><td style="text-align:center">12</td><td style="text-align:center">0</td></tr></tbody></table><ol><li>再增加节点2作为中转，二维数组更新如下：</li></ol><table><thead><tr><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th></tr></thead><tbody><tr><td style="text-align:center">0</td><td style="text-align:center">2</td><td style="text-align:center">6</td><td style="text-align:center">4</td></tr><tr><td style="text-align:center">13</td><td style="text-align:center">0</td><td style="text-align:center">4</td><td style="text-align:center">17</td></tr><tr><td style="text-align:center">9</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">13</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">8</td><td style="text-align:center">12</td><td style="text-align:center">0</td></tr></tbody></table><ol><li>最后增加节点3作为中转，二维数组更新如下：</li></ol><table><thead><tr><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th></tr></thead><tbody><tr><td style="text-align:center">0</td><td style="text-align:center">2</td><td style="text-align:center">6</td><td style="text-align:center">4</td></tr><tr><td style="text-align:center">13</td><td style="text-align:center">0</td><td style="text-align:center">4</td><td style="text-align:center">17</td></tr><tr><td style="text-align:center">9</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">13</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">8</td><td style="text-align:center">12</td><td style="text-align:center">0</td></tr></tbody></table><p>至此我们就求解出了任意两点间的最小距离。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>Floyd算法的时间复杂度为<code>O(N^3)</code>，空间复杂度为 <code>O(N^2)</code></li><li>Floyd是一种求解多源最短路径的算法，如果是求解单源最短路径这 N^3 的时间复杂度确实有点伤</li><li>Floyd可以正确处理有向图或存在负权边的图，但不能处理存在负权回路的图的最短路径问题</li><li>4行代码3层循环或许可以助它称为最容易让人理解的最短路径算法</li><li>这4行代码只是一个理想化的模型，实际在编码时要注意加法的越界问题，因为两个无穷大相加理论上是无穷大，但在代码里可能就崩溃了</li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/119722553" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>人生到底是追求到达目的地还是准备欣赏沿途的风景，一味地向前奔跑忽略了周围的一切，很多美好的事物就在身边却不自知，我们已经被世俗蒙蔽了双眼，什么时候可以慢下来呢？</p><p>2021-9-7 01:14:05</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;Floyd-Warshall算法简记Floyd算法，又称弗洛伊德算法，是解决任意两点间的最短路径问题的一种常用算法，核心思想就是“&lt;strong&gt;不断利用第三者影响原配关系&lt;/strong&gt;”，这一点在4行核心代码中表现的淋漓尽致，接下来梳理一下算法思路。&lt;/p&gt;
    
    </summary>
    
      <category term="C/C++" scheme="http://AlbertGithubHome.github.io/blog/categories/C-C/"/>
    
    
      <category term="C++" scheme="http://AlbertGithubHome.github.io/blog/tags/C/"/>
    
      <category term="算法" scheme="http://AlbertGithubHome.github.io/blog/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="最短路径" scheme="http://AlbertGithubHome.github.io/blog/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/"/>
    
      <category term="Floyd" scheme="http://AlbertGithubHome.github.io/blog/tags/Floyd/"/>
    
  </entry>
  
  <entry>
    <title>从一个小题中的应用来体会下std::tie的便利之处</title>
    <link href="http://AlbertGithubHome.github.io/blog/2021/08/15/%E4%BB%8E%E4%B8%80%E4%B8%AA%E5%B0%8F%E9%A2%98%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8%E6%9D%A5%E4%BD%93%E4%BC%9A%E4%B8%8Bstd-tie%E7%9A%84%E4%BE%BF%E5%88%A9%E4%B9%8B%E5%A4%84/"/>
    <id>http://AlbertGithubHome.github.io/blog/2021/08/15/从一个小题中的应用来体会下std-tie的便利之处/</id>
    <published>2021-08-15T08:28:18.000Z</published>
    <updated>2021-08-15T15:48:38.441Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>今天主要学习一下 <code>std::tie</code> 函数的使用方法，之前看到 <code>tie</code> 函数是和 IO 绑定的，最近发现它是和 <code>std::tuple</code> 绑定的，查询资料后发现两个函数虽然名字相同，但是在不同的作用域下，今天学一下和 tuple 有关的这个 <code>tie</code> 函数，不过在学习之前先看一道小题。</p><a id="more"></a><h1 id="解题过程"><a href="#解题过程" class="headerlink" title="解题过程"></a>解题过程</h1><h2 id="爬楼梯的最少成本"><a href="#爬楼梯的最少成本" class="headerlink" title="爬楼梯的最少成本"></a>爬楼梯的最少成本</h2><p>这是 <a href="https://leetcode-cn.com/problems/GzCJIP/" target="_blank" rel="noopener">LeetCode</a> 上的一道题，题目描述如下：</p><p>数组的每个下标作为一个阶梯，第 i 个阶梯对应着一个非负数的体力花费值 cost[i]（下标从 0 开始）。</p><p>每当爬上一个阶梯都要花费对应的体力值，一旦支付了相应的体力值，就可以选择向上爬一个阶梯或者爬两个阶梯。</p><p>请找出达到楼层顶部的最低花费。在开始时，你可以选择从下标为 0 或 1 的元素作为初始阶梯。</p><p>示例 1：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：cost = [10, 15, 20]</span><br><span class="line">输出：15</span><br><span class="line">解释：最低花费是从 cost[1] 开始，然后走两步即可到阶梯顶，一共花费 15 。</span><br></pre></td></tr></table></figure></p><p> 示例 2：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]</span><br><span class="line">输出：6</span><br><span class="line">解释：最低花费方式是从 cost[0] 开始，逐个经过那些 1 ，跳过 cost[3] ，一共花费 6 。</span><br></pre></td></tr></table></figure></p><p>提示：</p><pre><code>2 &lt;= cost.length &lt;= 10000 &lt;= cost[i] &lt;= 999</code></pre><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>这种求解最小花费、最大方案数，最大价值的题目是典型的动态规划题目，这道题也可以使用动态规划的方式来解，既然每次可以选择爬一个或者两个阶梯，那么到达某一个阶梯的花费就等于这个阶梯的花费加上前一个阶梯花费和前两个花费的之间最小值即可，最终的结果取最后一个阶梯和倒数第二个阶梯中的最小值，代码比较简单，实现如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minCostClimbingStairs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; cost)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = cost.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans(n);</span><br><span class="line">        ans[<span class="number">0</span>] = cost[<span class="number">0</span>];</span><br><span class="line">        ans[<span class="number">1</span>] = cost[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; i++) ans[i] = min(ans[i<span class="number">-1</span>], ans[i<span class="number">-2</span>]) + cost[i];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> min(ans[n<span class="number">-1</span>], ans[n<span class="number">-2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="DP优化"><a href="#DP优化" class="headerlink" title="DP优化"></a>DP优化</h2><p>虽然使用dp数组求解起来很方便，但是从实现上可以看出，每个阶梯的花费只与它前两个阶梯的花费有关，所以使用一个长度为N的数组在空间上有些浪费，其实只要两个变量就可以了，我们用 <code>first</code> 和 <code>second</code> 两个变量分别表示某个阶梯前两个阶梯的花费，可以实现如下代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minCostClimbingStairs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; cost)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = cost.size(), first = cost[<span class="number">0</span>], second = cost[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = min(first, second) + cost[i];</span><br><span class="line">            first = second;</span><br><span class="line">            second = temp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> min(first, second);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="利用tie进行写法优化"><a href="#利用tie进行写法优化" class="headerlink" title="利用tie进行写法优化"></a>利用tie进行写法优化</h2><p>使用两个变量优化之后这个算法变成了 O(1) 的空间复杂度，但是在 for 循环中的写法还是有些啰嗦，其实这种写法和交换两个变量值过程非常相似，在GO语言中可以写成 <code>a,b = b,a</code> 来完成交换，但是在C++中这样的写法是错误的，不管是引入第三个变量，还是通过异或解决都需要写三条语句，但是这种情况在遇到 <code>std::tie</code> 函数之后有望得到改变，上面的写法利用 <code>std::tie</code> 可以改写如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minCostClimbingStairs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; cost)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = cost.size(), first = cost[<span class="number">0</span>], second = cost[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; i++) tie(first, second) = make_tuple(second, min(first, second) + cost[i]);</span><br><span class="line">        <span class="keyword">return</span> min(first, second);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="std-tuple"><a href="#std-tuple" class="headerlink" title="std::tuple"></a>std::tuple</h1><p>在学习 <code>std::tie</code> 的作用方式之前，先来看一下 <code>std::tuple</code> 是什么。如果你对这个结构有些陌生，可以先想想 <code>std::pair</code> 这个结构。首先 <code>std::tuple</code> 是一个类模板，同时他也是一个固定大小的由各种类型的值组成集合，是 <code>std::pair</code> 的一种泛化实现。</p><p><code>std::pair</code> 中包含两个元素，而 <code>std::tuple</code> 可以同时包含多个元素，它拥有 struct 的表现，但是无需定义实际的 struct，在函数返回多个值时拥有良好的表现。</p><h2 id="std-tuple的访问"><a href="#std-tuple的访问" class="headerlink" title="std::tuple的访问"></a>std::tuple的访问</h2><ol><li>利用 <code>std::get</code> 函数通过下标访问（C++11）</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> t = <span class="built_in">std</span>::make_tuple(<span class="number">110</span>, <span class="string">"excellent"</span>, <span class="number">3.14</span>);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"("</span> &lt;&lt; <span class="built_in">std</span>::get&lt;<span class="number">0</span>&gt;(t) &lt;&lt; <span class="string">", "</span> &lt;&lt; <span class="built_in">std</span>::get&lt;<span class="number">1</span>&gt;(t)</span><br><span class="line">        &lt;&lt; <span class="string">", "</span> &lt;&lt; <span class="built_in">std</span>::get&lt;<span class="number">2</span>&gt;(t) &lt;&lt; <span class="string">")"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><ol><li>利用 <code>std::tie</code> 函数进行参数解绑（C++11)</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> t = <span class="built_in">std</span>::make_tuple(<span class="number">110</span>, <span class="string">"excellent"</span>, <span class="number">3.14</span>);</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> s;</span><br><span class="line"><span class="keyword">float</span> d;</span><br><span class="line"><span class="built_in">std</span>::tie(n, s, d) = t;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"("</span> &lt;&lt; n &lt;&lt; <span class="string">", "</span> &lt;&lt; s &lt;&lt; <span class="string">", "</span> &lt;&lt; d &lt;&lt; <span class="string">")"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><ol><li>利用 <code>std::get</code> 函数通过类型访问（C++14），这种使用方式如果每种类型不唯一会出现编译错误</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> t = <span class="built_in">std</span>::make_tuple(<span class="number">110</span>, <span class="string">"excellent"</span>, <span class="number">3.14</span>);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"("</span> &lt;&lt; <span class="built_in">std</span>::get&lt;<span class="keyword">int</span>&gt;(t) &lt;&lt; <span class="string">", "</span> &lt;&lt; <span class="built_in">std</span>::get&lt;<span class="keyword">const</span> <span class="keyword">char</span>*&gt;(t)</span><br><span class="line">        &lt;&lt; <span class="string">", "</span> &lt;&lt; <span class="built_in">std</span>::get&lt;<span class="keyword">double</span>&gt;(t) &lt;&lt; <span class="string">")"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><ol><li>利用结构化绑定的方式来访问（C++17）</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> t = <span class="built_in">std</span>::make_tuple(<span class="number">110</span>, <span class="string">"excellent"</span>, <span class="number">3.14</span>);</span><br><span class="line"><span class="keyword">auto</span> [n, s, d] = t;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"("</span> &lt;&lt; n &lt;&lt; <span class="string">", "</span> &lt;&lt; s &lt;&lt; <span class="string">", "</span> &lt;&lt; d &lt;&lt; <span class="string">")"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>以上的几个例子的输出结果都是 <code>(110, excellent, 3.14)</code></p><h2 id="std-tie函数中使用std-ignore占位"><a href="#std-tie函数中使用std-ignore占位" class="headerlink" title="std::tie函数中使用std::ignore占位"></a>std::tie函数中使用std::ignore占位</h2><p>使用 <code>std::tie</code> 函数来获取 <code>std::tuple</code> 参数时，有时不需要所有的参数，这种情况下可以使用 <code>td::ignore</code> 来占位，代替那些不关心的参数，比如 <code>std::set</code> 结构中 <code>insert</code> 函数的返回值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::pair&lt;<span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator, <span class="keyword">bool</span>&gt; sp1 = st.insert(<span class="number">4</span>);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *sp1.first &lt;&lt; <span class="string">" "</span> &lt;&lt; sp1.second &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::pair&lt;<span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator, <span class="keyword">bool</span>&gt; sp2 = st.insert(<span class="number">4</span>);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *sp2.first &lt;&lt; <span class="string">" "</span> &lt;&lt; sp2.second &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">4 1</span><br><span class="line">4 0</span><br></pre></td></tr></table></figure><p>如果我们不关心插入的元素是什么，只想知道此次插入操作是否成功，可以利用 <code>std::tie</code> 和 <code>std::ignore</code> 来实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line"><span class="keyword">bool</span> inserted = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::tie(<span class="built_in">std</span>::ignore, inserted) = st.insert(<span class="number">4</span>);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; inserted &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::tie(<span class="built_in">std</span>::ignore, inserted) = st.insert(<span class="number">4</span>);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; inserted &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">0</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li><code>std::tuple</code> 是 <code>std::pair</code> 一种更加通用的实现，<code>std::pair</code> 只能包含两个元素，而 <code>std::tuple</code> 可以包含多个任意类型的元素</li><li>tie 本意是系牢、约束、连接、束缚的意思，用在 <code>std::tuple</code> 上却是用来解绑参数的，含义恰好相反了，很有趣是不是</li><li>实际上 <code>std::tie</code> 这个函数的作用是把一些左值绑定到 <code>std::tuple</code> 来达到解析参数的目的，函数作用还是 “tie”</li><li><code>std::ignore</code> 可以用在 <code>std::tie</code> 函数中作为占位符，用来替代一些不关心的参数</li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/119523587" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>有些事情反过来想一想，问题可能很快就解决了——记一次拼图游戏中一个对手的高谈阔论</p><p>2021-8-15 23:48:37</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;今天主要学习一下 &lt;code&gt;std::tie&lt;/code&gt; 函数的使用方法，之前看到 &lt;code&gt;tie&lt;/code&gt; 函数是和 IO 绑定的，最近发现它是和 &lt;code&gt;std::tuple&lt;/code&gt; 绑定的，查询资料后发现两个函数虽然名字相同，但是在不同的作用域下，今天学一下和 tuple 有关的这个 &lt;code&gt;tie&lt;/code&gt; 函数，不过在学习之前先看一道小题。&lt;/p&gt;
    
    </summary>
    
      <category term="C/C++" scheme="http://AlbertGithubHome.github.io/blog/categories/C-C/"/>
    
    
      <category term="C/C++" scheme="http://AlbertGithubHome.github.io/blog/tags/C-C/"/>
    
      <category term="tie" scheme="http://AlbertGithubHome.github.io/blog/tags/tie/"/>
    
      <category term="动态规划" scheme="http://AlbertGithubHome.github.io/blog/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="DP" scheme="http://AlbertGithubHome.github.io/blog/tags/DP/"/>
    
      <category term="tuple" scheme="http://AlbertGithubHome.github.io/blog/tags/tuple/"/>
    
  </entry>
  
  <entry>
    <title>C++中使用std::sort自定义排序规则时要注意的崩溃问题</title>
    <link href="http://AlbertGithubHome.github.io/blog/2021/08/07/C-%E4%B8%AD%E4%BD%BF%E7%94%A8std-sort%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%92%E5%BA%8F%E8%A7%84%E5%88%99%E6%97%B6%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E5%B4%A9%E6%BA%83%E9%97%AE%E9%A2%98/"/>
    <id>http://AlbertGithubHome.github.io/blog/2021/08/07/C-中使用std-sort自定义排序规则时要注意的崩溃问题/</id>
    <published>2021-08-07T15:42:27.000Z</published>
    <updated>2021-08-08T15:57:54.194Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>看到这个标题应该会有很多人一下子就懂了，也会有些人感到迷惑，简简单单排序怎么会奔溃呢？我第一次接触这个问题还是很久以前刚刚参加工作的时候，当时也是写出了导致程序崩溃的代码，通过上网查询解决了问题，至此以后就对这个 <code>sort</code> 函数警惕了一些，一直记得就是在sort的自定义函数中判断条件不要加等号，至于本质的原因一直没有去探究，正好最近又改了一个相关的问题，所以决定从源码和定义的角度来看看为什么会出现这个问题。</p><a id="more"></a><h1 id="sort的使用"><a href="#sort的使用" class="headerlink" title="sort的使用"></a>sort的使用</h1><p>sort函数真的挺好用，比如像下面这样：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; values&#123;<span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="built_in">std</span>::sort(values.begin(), values.end());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> v : values) <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; v &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只是 <code>std::sort(values.begin(), values.end());</code> 这样简简单单的一句就完成了vector数据从小到达的排序，运行结果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:/data/cpp$ g++ testsort.cpp --std=c++11</span><br><span class="line">albert@home-pc:/data/cpp$ ./a.out</span><br><span class="line">1</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">5</span><br></pre></td></tr></table></figure><h1 id="自定义比较函数"><a href="#自定义比较函数" class="headerlink" title="自定义比较函数"></a>自定义比较函数</h1><p>上面举的例子是从小到大排序，这是 sort 函数的默认行为，所以不需要额外的参数，如果是想从大到小排序，那么就需要定义一个比较函数了，方法也比较简单，写一个lambda表达式就可以了，比如像下面这样：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; values&#123;<span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="built_in">std</span>::sort(values.begin(), values.end(), [](<span class="keyword">int</span> v1, <span class="keyword">int</span> v2)&#123;</span><br><span class="line">        <span class="keyword">return</span> v1 &gt;= v2;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> v : values) <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; v &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按照比较函数定义，我们把数据按照前面大于等于后面的方式排序就完成了从大到小的排序的要求，看看这样写有没有什么问题？如果这里的等号 <code>=</code> 已经引起了你的不适，说明你可能踩过这里的坑，是的，这样写容易造成崩溃，我们来运行一下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:/data/cpp$ g++ testsort.cpp --std=c++11</span><br><span class="line">albert@home-pc:/data/cpp$ ./a.out</span><br><span class="line">5</span><br><span class="line">5</span><br><span class="line">4</span><br><span class="line">4</span><br><span class="line">3</span><br><span class="line">1</span><br></pre></td></tr></table></figure><p>咦？怎么没事，我之前用MSVC测试还会崩溃的，难道和编译器有关？</p><p>当我们增大数据量</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; values&#123;<span class="number">3</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行结果如下</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">albert@home-pc:/data/cpp$ g++ testsort.cpp --<span class="built_in">std</span>=c++<span class="number">11</span> -g</span><br><span class="line">albert@home-pc:/data/cpp$ ./a.out</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line">*** Error in `./a.out': <span class="keyword">double</span> <span class="built_in">free</span> <span class="keyword">or</span> corruption (out): <span class="number">0x0000000002016c20</span> ***</span><br><span class="line">======= Backtrace: =========</span><br><span class="line">/lib/x86_64-linux-gnu/libc.so<span class="number">.6</span>(+<span class="number">0x777f5</span>)[<span class="number">0x7ff5ffef77f5</span>]</span><br><span class="line">/lib/x86_64-linux-gnu/libc.so<span class="number">.6</span>(+<span class="number">0x8038a</span>)[<span class="number">0x7ff5fff0038a</span>]</span><br><span class="line">/lib/x86_64-linux-gnu/libc.so<span class="number">.6</span>(cfree+<span class="number">0x4c</span>)[<span class="number">0x7ff5fff0458c</span>]</span><br><span class="line">./a.out[<span class="number">0x4024e2</span>]</span><br><span class="line">./a.out[<span class="number">0x4023ab</span>]</span><br><span class="line">./a.out[<span class="number">0x402226</span>]</span><br><span class="line">./a.out[<span class="number">0x4020a1</span>]</span><br><span class="line">./a.out[<span class="number">0x401edb</span>]</span><br><span class="line">./a.out[<span class="number">0x400c67</span>]</span><br><span class="line">/lib/x86_64-linux-gnu/libc.so<span class="number">.6</span>(__libc_start_main+<span class="number">0xf0</span>)[<span class="number">0x7ff5ffea0840</span>]</span><br><span class="line">./a.out[<span class="number">0x400a39</span>]</span><br><span class="line">======= Memory <span class="built_in">map</span>: ========</span><br><span class="line"><span class="number">00400000</span><span class="number">-00403000</span> r-xp <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">212044</span>                     /mnt/d/data/cpp/testsort/a.out</span><br><span class="line"><span class="number">00403000</span><span class="number">-00404000</span> r-xp <span class="number">00003000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">212044</span>                     /mnt/d/data/cpp/testsort/a.out</span><br><span class="line"><span class="number">00603000</span><span class="number">-00604000</span> r--p <span class="number">00003000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">212044</span>                     /mnt/d/data/cpp/testsort/a.out</span><br><span class="line"><span class="number">00604000</span><span class="number">-00605000</span> rw-p <span class="number">00004000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">212044</span>                     /mnt/d/data/cpp/testsort/a.out</span><br><span class="line"><span class="number">02005000</span><span class="number">-02037000</span> rw-p <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span>                          [heap]</span><br><span class="line"><span class="number">7f</span>f5f8000000<span class="number">-7f</span>f5f8021000 rw-p <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span></span><br><span class="line"><span class="number">7f</span>f5f8021000<span class="number">-7f</span>f5fc000000 ---p <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span></span><br><span class="line"><span class="number">7f</span>f5ffb70000<span class="number">-7f</span>f5ffc78000 r-xp <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">243923</span>             /lib/x86_64-linux-gnu/libm<span class="number">-2.23</span>.so</span><br><span class="line"><span class="number">7f</span>f5ffc78000<span class="number">-7f</span>f5ffc7a000 ---p <span class="number">00108000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">243923</span>             /lib/x86_64-linux-gnu/libm<span class="number">-2.23</span>.so</span><br><span class="line"><span class="number">7f</span>f5ffc7a000<span class="number">-7f</span>f5ffe77000 ---p <span class="number">0010</span>a000 <span class="number">00</span>:<span class="number">00</span> <span class="number">243923</span>             /lib/x86_64-linux-gnu/libm<span class="number">-2.23</span>.so</span><br><span class="line"><span class="number">7f</span>f5ffe77000<span class="number">-7f</span>f5ffe78000 r--p <span class="number">00107000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">243923</span>             /lib/x86_64-linux-gnu/libm<span class="number">-2.23</span>.so</span><br><span class="line"><span class="number">7f</span>f5ffe78000<span class="number">-7f</span>f5ffe79000 rw-p <span class="number">00108000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">243923</span>             /lib/x86_64-linux-gnu/libm<span class="number">-2.23</span>.so</span><br><span class="line"><span class="number">7f</span>f5ffe80000<span class="number">-7f</span>f600040000 r-xp <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">243912</span>             /lib/x86_64-linux-gnu/libc<span class="number">-2.23</span>.so</span><br><span class="line"><span class="number">7f</span>f600040000<span class="number">-7f</span>f600049000 ---p <span class="number">001</span>c0000 <span class="number">00</span>:<span class="number">00</span> <span class="number">243912</span>             /lib/x86_64-linux-gnu/libc<span class="number">-2.23</span>.so</span><br><span class="line"><span class="number">7f</span>f600049000<span class="number">-7f</span>f600240000 ---p <span class="number">001</span>c9000 <span class="number">00</span>:<span class="number">00</span> <span class="number">243912</span>             /lib/x86_64-linux-gnu/libc<span class="number">-2.23</span>.so</span><br><span class="line"><span class="number">7f</span>f600240000<span class="number">-7f</span>f600244000 r--p <span class="number">001</span>c0000 <span class="number">00</span>:<span class="number">00</span> <span class="number">243912</span>             /lib/x86_64-linux-gnu/libc<span class="number">-2.23</span>.so</span><br><span class="line"><span class="number">7f</span>f600244000<span class="number">-7f</span>f600246000 rw-p <span class="number">001</span>c4000 <span class="number">00</span>:<span class="number">00</span> <span class="number">243912</span>             /lib/x86_64-linux-gnu/libc<span class="number">-2.23</span>.so</span><br><span class="line"><span class="number">7f</span>f600246000<span class="number">-7f</span>f60024a000 rw-p <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span></span><br><span class="line"><span class="number">7f</span>f600250000<span class="number">-7f</span>f600266000 r-xp <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">180347</span>             /lib/x86_64-linux-gnu/libgcc_s.so<span class="number">.1</span></span><br><span class="line"><span class="number">7f</span>f600266000<span class="number">-7f</span>f600465000 ---p <span class="number">00016000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">180347</span>             /lib/x86_64-linux-gnu/libgcc_s.so<span class="number">.1</span></span><br><span class="line"><span class="number">7f</span>f600465000<span class="number">-7f</span>f600466000 rw-p <span class="number">00015000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">180347</span>             /lib/x86_64-linux-gnu/libgcc_s.so<span class="number">.1</span></span><br><span class="line"><span class="number">7f</span>f600470000<span class="number">-7f</span>f6005e2000 r-xp <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">189413</span>             /usr/lib/x86_64-linux-gnu/libstdc++.so<span class="number">.6</span><span class="number">.0</span><span class="number">.21</span></span><br><span class="line"><span class="number">7f</span>f6005e2000<span class="number">-7f</span>f6005ef000 ---p <span class="number">00172000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">189413</span>             /usr/lib/x86_64-linux-gnu/libstdc++.so<span class="number">.6</span><span class="number">.0</span><span class="number">.21</span></span><br><span class="line"><span class="number">7f</span>f6005ef000<span class="number">-7f</span>f6007e2000 ---p <span class="number">0017f</span>000 <span class="number">00</span>:<span class="number">00</span> <span class="number">189413</span>             /usr/lib/x86_64-linux-gnu/libstdc++.so<span class="number">.6</span><span class="number">.0</span><span class="number">.21</span></span><br><span class="line"><span class="number">7f</span>f6007e2000<span class="number">-7f</span>f6007ec000 r--p <span class="number">00172000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">189413</span>             /usr/lib/x86_64-linux-gnu/libstdc++.so<span class="number">.6</span><span class="number">.0</span><span class="number">.21</span></span><br><span class="line"><span class="number">7f</span>f6007ec000<span class="number">-7f</span>f6007ee000 rw-p <span class="number">0017</span>c000 <span class="number">00</span>:<span class="number">00</span> <span class="number">189413</span>             /usr/lib/x86_64-linux-gnu/libstdc++.so<span class="number">.6</span><span class="number">.0</span><span class="number">.21</span></span><br><span class="line"><span class="number">7f</span>f6007ee000<span class="number">-7f</span>f6007f2000 rw-p <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span></span><br><span class="line"><span class="number">7f</span>f600800000<span class="number">-7f</span>f600825000 r-xp <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">243945</span>             /lib/x86_64-linux-gnu/ld<span class="number">-2.23</span>.so</span><br><span class="line"><span class="number">7f</span>f600825000<span class="number">-7f</span>f600826000 r-xp <span class="number">00025000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">243945</span>             /lib/x86_64-linux-gnu/ld<span class="number">-2.23</span>.so</span><br><span class="line"><span class="number">7f</span>f600a25000<span class="number">-7f</span>f600a26000 r--p <span class="number">00025000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">243945</span>             /lib/x86_64-linux-gnu/ld<span class="number">-2.23</span>.so</span><br><span class="line"><span class="number">7f</span>f600a26000<span class="number">-7f</span>f600a27000 rw-p <span class="number">00026000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">243945</span>             /lib/x86_64-linux-gnu/ld<span class="number">-2.23</span>.so</span><br><span class="line"><span class="number">7f</span>f600a27000<span class="number">-7f</span>f600a28000 rw-p <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span></span><br><span class="line"><span class="number">7f</span>f600b70000<span class="number">-7f</span>f600b71000 rw-p <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span></span><br><span class="line"><span class="number">7f</span>f600b80000<span class="number">-7f</span>f600b82000 rw-p <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span></span><br><span class="line"><span class="number">7f</span>f600b90000<span class="number">-7f</span>f600b91000 rw-p <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span></span><br><span class="line"><span class="number">7f</span>f600ba0000<span class="number">-7f</span>f600ba1000 rw-p <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span></span><br><span class="line"><span class="number">7f</span>f600bb0000<span class="number">-7f</span>f600bb1000 rw-p <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span></span><br><span class="line"><span class="number">7f</span>f600bc0000<span class="number">-7f</span>f600bc1000 rw-p <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span></span><br><span class="line"><span class="number">7f</span>ffc026e000<span class="number">-7f</span>ffc0a6e000 rw-p <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span>                  [<span class="built_in">stack</span>]</span><br><span class="line"><span class="number">7f</span>ffc10b8000<span class="number">-7f</span>ffc10b9000 r-xp <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span>                  [vdso]</span><br><span class="line">Aborted (core dumped)</span><br></pre></td></tr></table></figure><p>这次终于崩溃了，但显示确实内存越界问题，并且排序后第一个元素是0，这不是我们vector中的元素啊，看来肯定是出问题了</p><p>反复尝试几次又找到一个测试用例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;values&#123;<span class="number">3</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br></pre></td></tr></table></figure><p>运行之后直接得到了 <code>Segmentation fault (core dumped)</code> 错误，没错，这就是我想要的，来从 <code>sort</code> 源码中看看为什么加了 <code>=</code> 就会出现崩溃</p><h1 id="sort源码崩溃分析"><a href="#sort源码崩溃分析" class="headerlink" title="sort源码崩溃分析"></a>sort源码崩溃分析</h1><p>sort 函数的源码还不算太长，我就一点点来看了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _RandomAccessIterator, <span class="keyword">typename</span> _Compare&gt;</span><br><span class="line">  <span class="keyword">inline</span> <span class="keyword">void</span></span><br><span class="line">  sort(_RandomAccessIterator __first, _RandomAccessIterator __last,</span><br><span class="line">   _Compare __comp)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// concept requirements</span></span><br><span class="line">    __glibcxx_function_requires(_Mutable_RandomAccessIteratorConcept&lt;</span><br><span class="line">      _RandomAccessIterator&gt;)</span><br><span class="line">    __glibcxx_function_requires(_BinaryPredicateConcept&lt;_Compare,</span><br><span class="line">      <span class="keyword">typename</span> iterator_traits&lt;_RandomAccessIterator&gt;::value_type,</span><br><span class="line">      <span class="keyword">typename</span> iterator_traits&lt;_RandomAccessIterator&gt;::value_type&gt;)</span><br><span class="line">    __glibcxx_requires_valid_range(__first, __last);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::__sort(__first, __last, __gnu_cxx::__ops::__iter_comp_iter(__comp));</span><br></pre></td></tr></table></figure><p>这算是个入口函数，做了一些类型检查，然后就调用了内部的 <code>std::__sort</code> 函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _RandomAccessIterator, <span class="keyword">typename</span> _Compare&gt;</span><br><span class="line">  <span class="keyword">inline</span> <span class="keyword">void</span></span><br><span class="line">  __sort(_RandomAccessIterator __first, _RandomAccessIterator __last,</span><br><span class="line">     _Compare __comp)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (__first != __last)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">std</span>::__introsort_loop(__first, __last,</span><br><span class="line">              <span class="built_in">std</span>::__lg(__last - __first) * <span class="number">2</span>,</span><br><span class="line">              __comp);</span><br><span class="line">      <span class="built_in">std</span>::__final_insertion_sort(__first, __last, __comp);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>当排序范围不为空时，函数会对传入的范围进行排序，为了最大程度的提高效率，结合了快排、堆排和插入排序等多种排序方法，分为 <code>std::__introsort_loop</code> 和 <code>std::__final_insertion_sort</code> 两个阶段。</p><p>第一阶段使用“快排+堆排”的方法，当元素个数小于等于 <code>_S_threshold</code>（<code>enum { _S_threshold = 16 }</code>）时，不做处理，交给第二阶段来做，对于元素个数大于_S_threshold的序列，执行快排，当快排的递归深入到一定深度 <code>__depth_limit</code>（通过元素个数计算出来的）时，不再递归深入，对待排序元素执行堆排序，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// This is a helper function for the sort routine.</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _RandomAccessIterator, <span class="keyword">typename</span> _Size, <span class="keyword">typename</span> _Compare&gt;</span><br><span class="line">  <span class="keyword">void</span></span><br><span class="line">  __introsort_loop(_RandomAccessIterator __first,</span><br><span class="line">           _RandomAccessIterator __last,</span><br><span class="line">           _Size __depth_limit, _Compare __comp)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">while</span> (__last - __first &gt; <span class="keyword">int</span>(_S_threshold))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (__depth_limit == <span class="number">0</span>)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">std</span>::__partial_sort(__first, __last, __last, __comp);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      --__depth_limit;</span><br><span class="line">      _RandomAccessIterator __cut =</span><br><span class="line">        <span class="built_in">std</span>::__unguarded_partition_pivot(__first, __last, __comp);</span><br><span class="line">      <span class="built_in">std</span>::__introsort_loop(__cut, __last, __depth_limit, __comp);</span><br><span class="line">      __last = __cut;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>第二阶段使用“插入排序”，当元素个数小于等于 <code>_S_threshold</code>（<code>enum { _S_threshold = 16 }</code>）时，执行普通的插入排序，当大于 <code>_S_threshold</code> 时，执行两次的“插入”排序操作，首先使用普通的插入排序来排 <code>[first, _S_threshold)</code> 这个范围的元素，然后使用无保护的插入排序，完成 <code>[_S_threshold, last)</code> 这个范围的排序。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _RandomAccessIterator, <span class="keyword">typename</span> _Compare&gt;</span><br><span class="line">  <span class="keyword">void</span></span><br><span class="line">  __final_insertion_sort(_RandomAccessIterator __first,</span><br><span class="line">             _RandomAccessIterator __last, _Compare __comp)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (__last - __first &gt; <span class="keyword">int</span>(_S_threshold))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">std</span>::__insertion_sort(__first, __first + <span class="keyword">int</span>(_S_threshold), __comp);</span><br><span class="line">      <span class="built_in">std</span>::__unguarded_insertion_sort(__first + <span class="keyword">int</span>(_S_threshold), __last,</span><br><span class="line">                      __comp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="built_in">std</span>::__insertion_sort(__first, __last, __comp);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>其中的普通插入排序没有什么特别的地方，就是遍历前边小于等于<code>_S_threshold</code>个元素进行普通的插入排序，而后面这个无保护的插入排序 <code>std::__unguarded_insertion_sort</code> 往往就是出现问题的地方，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _RandomAccessIterator, <span class="keyword">typename</span> _Compare&gt;</span><br><span class="line">  <span class="keyword">inline</span> <span class="keyword">void</span></span><br><span class="line">  __unguarded_insertion_sort(_RandomAccessIterator __first,</span><br><span class="line">                 _RandomAccessIterator __last, _Compare __comp)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span> (_RandomAccessIterator __i = __first; __i != __last; ++__i)</span><br><span class="line">  <span class="built_in">std</span>::__unguarded_linear_insert(__i,</span><br><span class="line">              __gnu_cxx::__ops::__val_comp_iter(__comp));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _RandomAccessIterator, <span class="keyword">typename</span> _Compare&gt;</span><br><span class="line">  <span class="keyword">void</span></span><br><span class="line">  __unguarded_linear_insert(_RandomAccessIterator __last,</span><br><span class="line">                _Compare __comp)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">typename</span> iterator_traits&lt;_RandomAccessIterator&gt;::value_type</span><br><span class="line">    __val = _GLIBCXX_MOVE(*__last);</span><br><span class="line">    _RandomAccessIterator __next = __last;</span><br><span class="line">    --__next;</span><br><span class="line">    <span class="keyword">while</span> (__comp(__val, __next))</span><br><span class="line">    &#123;</span><br><span class="line">      *__last = _GLIBCXX_MOVE(*__next);</span><br><span class="line">      __last = __next;</span><br><span class="line">      --__next;</span><br><span class="line">    &#125;</span><br><span class="line">    *__last = _GLIBCXX_MOVE(__val);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>这段代码看 <code>__unguarded_insertion_sort</code> 还没有什么问题，但是 <code>__unguarded_linear_insert</code> 中的逻辑就比较迷幻了，只有当 <code>__comp(__val, __next)</code> 的值为false时才会停止。</p><p>其中 <code>__comp</code> 就是我们之前自定义的lambda表达式，我们当时写的是 <code>return v1 &gt;= v2;</code>，翻译过来也就是当<code>!(val &gt;= __next)</code> 时，即后一个元素小于前一个元素的时候停止，那么为什么会出问题呢？</p><p>我们知道前<code>_S_threshold</code>个元素我们之前已经按照从大到小排好序了，那么按道理遍历到这个区域就会找到后一个元素小于前一个元素的情况，也就是插入排序遍历到这就会停止，等等！好像有什么不对劲，如果这里的元素都相等就找不到停止的情况了，这就会造成访问的越界，这就是程序崩溃的本质原因了。</p><p>那么去掉等号会是个什么情况呢？运行到这里就是要找到满足条件的 <code>!(val &gt; __next)</code>元素时停止，也就是找到后一个元素<strong>小于等于</strong>前一个元素的时候停止，因为前<code>_S_threshold</code>个元素已经排好序，这个条件是肯定满足的，所以不会出现越界情况，这就是为什么自定义比较函数中，两个元素相等时一定要返回false了。</p><h1 id="为什么使用无保护的插入排序"><a href="#为什么使用无保护的插入排序" class="headerlink" title="为什么使用无保护的插入排序"></a>为什么使用无保护的插入排序</h1><p>既然这里这么容易越界，为什么不判断一下边界条件来防止越界，而是用这种无保护的插入排序呢？</p><p>这里使用无保护的插入排序原因很简单，就是为了提升效率，因为省略掉越界的检查，少了很多次的比较操作，效率肯定有了提升，它的前提是左边必须有已经排好序的元素，所以在函数 <code>__unguarded_insertion_sort</code> 函数之前先调用 <code>__insertion_sort</code> 来完成了<code>[0, _S_threshold)</code> 这个范围的元素排序，便是为了后面这个无保护插入排序的使用。</p><h1 id="C-标准要求"><a href="#C-标准要求" class="headerlink" title="C++标准要求"></a>C++标准要求</h1><p>说到这里sort函数的自定义比较函数还是太容易出错了，有没有什么实现标准呢？其实标准中对这个比较函数的要求写的很详细，具体可以参考 <a href="https://en.cppreference.com/w/cpp/named_req/Compare" target="_blank" rel="noopener">Compare的实现要求</a>。</p><p><strong>Compare</strong> 是一些标准库函数针对用户提供的函数对象类型所期待的一组要求，其实就是要满足严格若排序关系，翻译成人话就是自定义的比较函数 <code>comp</code> 需要下面三条要求：</p><ol><li>对于任意元素a，需满足 <code>comp(a, a) == true</code></li><li>对于任意两个元素a和b，若 <code>comp(a, b)==true</code> 则要满足 <code>comp(b, a)==false</code></li><li>对于任意三个元素a、b和c，<code>若 comp(a, b)==true</code> 且 <code>comp(b, c)==true</code> 则需要满足 <code>comp(a, c)==true</code></li></ol><p>从这条规则也能看出我们之前定义的问题：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::sort(values.begin(), values.end(), [](<span class="keyword">int</span> v1, <span class="keyword">int</span> v2)&#123;</span><br><span class="line">    <span class="keyword">return</span> v1 &gt;= v2;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这个自定义的比较函数，当 v1 和 v2 相等时，<code>comp(v1, v2)==true</code>， 但是 <code>comp(v2, v1)</code>的值也是 <code>true</code>，当我们把代码中的等号 <code>=</code> 去掉以后，也就满足了条件2，另外在复杂的比价逻辑中，条件3的传递性问题也是需要注意的问题。</p><h1 id="构造一个崩溃的示例"><a href="#构造一个崩溃的示例" class="headerlink" title="构造一个崩溃的示例"></a>构造一个崩溃的示例</h1><p>理解了前面崩溃的原因，我们就不需要猜了，可以直接构造一个百分之百奔溃的测试用例，因为前16（<code>_S_threshold</code>）个元素会使用正常的插入排序，后面的元素才会使用无保护的插入排序，我们其实构造一个17个相同元素的vector就可以了，下面我们来试一下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; values&#123;<span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>&#125;;</span><br><span class="line">    <span class="built_in">std</span>::sort(values.begin(), values.end(), [](<span class="keyword">int</span> v1, <span class="keyword">int</span> v2)&#123;</span><br><span class="line">        <span class="keyword">return</span> v1 &gt;= v2;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> v : values) <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; v &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:/data/cpp$ g++ testsort.cpp --<span class="built_in">std</span>=c++<span class="number">11</span> -g</span><br><span class="line">albert@home-pc:/data/cpp$ ./a.out</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line">*** Error in `./a.out': <span class="keyword">double</span> <span class="built_in">free</span> <span class="keyword">or</span> corruption (out): <span class="number">0x0000000001fd9c20</span> ***</span><br><span class="line">======= Backtrace: =========</span><br><span class="line">/lib/x86_64-linux-gnu/libc.so<span class="number">.6</span>(+<span class="number">0x777f5</span>)[<span class="number">0x7feaf8ef77f5</span>]</span><br><span class="line">/lib/x86_64-linux-gnu/libc.so<span class="number">.6</span>(+<span class="number">0x8038a</span>)[<span class="number">0x7feaf8f0038a</span>]</span><br><span class="line">/lib/x86_64-linux-gnu/libc.so<span class="number">.6</span>(cfree+<span class="number">0x4c</span>)[<span class="number">0x7feaf8f0458c</span>]</span><br><span class="line">./a.out[<span class="number">0x402446</span>]</span><br><span class="line">./a.out[<span class="number">0x40230f</span>]</span><br><span class="line">./a.out[<span class="number">0x40218a</span>]</span><br><span class="line">./a.out[<span class="number">0x402005</span>]</span><br><span class="line">./a.out[<span class="number">0x401e65</span>]</span><br><span class="line">./a.out[<span class="number">0x400bf1</span>]</span><br><span class="line">/lib/x86_64-linux-gnu/libc.so<span class="number">.6</span>(__libc_start_main+<span class="number">0xf0</span>)[<span class="number">0x7feaf8ea0840</span>]</span><br><span class="line">./a.out[<span class="number">0x4009e9</span>]</span><br><span class="line">======= Memory <span class="built_in">map</span>: ========</span><br><span class="line"><span class="number">00400000</span><span class="number">-00403000</span> r-xp <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">211636</span>                     /mnt/d/data/cpp/testsort/a.out</span><br><span class="line"><span class="number">00403000</span><span class="number">-00404000</span> r-xp <span class="number">00003000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">211636</span>                     /mnt/d/data/cpp/testsort/a.out</span><br><span class="line"><span class="number">00603000</span><span class="number">-00604000</span> r--p <span class="number">00003000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">211636</span>                     /mnt/d/data/cpp/testsort/a.out</span><br><span class="line"><span class="number">00604000</span><span class="number">-00605000</span> rw-p <span class="number">00004000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">211636</span>                     /mnt/d/data/cpp/testsort/a.out</span><br><span class="line"><span class="number">01f</span>c8000<span class="number">-01f</span>fa000 rw-p <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span>                          [heap]</span><br><span class="line"><span class="number">7f</span>eaf4000000<span class="number">-7f</span>eaf4021000 rw-p <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span></span><br><span class="line"><span class="number">7f</span>eaf4021000<span class="number">-7f</span>eaf8000000 ---p <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span></span><br><span class="line"><span class="number">7f</span>eaf8b70000<span class="number">-7f</span>eaf8c78000 r-xp <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">243923</span>             /lib/x86_64-linux-gnu/libm<span class="number">-2.23</span>.so</span><br><span class="line"><span class="number">7f</span>eaf8c78000<span class="number">-7f</span>eaf8c7a000 ---p <span class="number">00108000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">243923</span>             /lib/x86_64-linux-gnu/libm<span class="number">-2.23</span>.so</span><br><span class="line"><span class="number">7f</span>eaf8c7a000<span class="number">-7f</span>eaf8e77000 ---p <span class="number">0010</span>a000 <span class="number">00</span>:<span class="number">00</span> <span class="number">243923</span>             /lib/x86_64-linux-gnu/libm<span class="number">-2.23</span>.so</span><br><span class="line"><span class="number">7f</span>eaf8e77000<span class="number">-7f</span>eaf8e78000 r--p <span class="number">00107000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">243923</span>             /lib/x86_64-linux-gnu/libm<span class="number">-2.23</span>.so</span><br><span class="line"><span class="number">7f</span>eaf8e78000<span class="number">-7f</span>eaf8e79000 rw-p <span class="number">00108000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">243923</span>             /lib/x86_64-linux-gnu/libm<span class="number">-2.23</span>.so</span><br><span class="line"><span class="number">7f</span>eaf8e80000<span class="number">-7f</span>eaf9040000 r-xp <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">243912</span>             /lib/x86_64-linux-gnu/libc<span class="number">-2.23</span>.so</span><br><span class="line"><span class="number">7f</span>eaf9040000<span class="number">-7f</span>eaf9049000 ---p <span class="number">001</span>c0000 <span class="number">00</span>:<span class="number">00</span> <span class="number">243912</span>             /lib/x86_64-linux-gnu/libc<span class="number">-2.23</span>.so</span><br><span class="line"><span class="number">7f</span>eaf9049000<span class="number">-7f</span>eaf9240000 ---p <span class="number">001</span>c9000 <span class="number">00</span>:<span class="number">00</span> <span class="number">243912</span>             /lib/x86_64-linux-gnu/libc<span class="number">-2.23</span>.so</span><br><span class="line"><span class="number">7f</span>eaf9240000<span class="number">-7f</span>eaf9244000 r--p <span class="number">001</span>c0000 <span class="number">00</span>:<span class="number">00</span> <span class="number">243912</span>             /lib/x86_64-linux-gnu/libc<span class="number">-2.23</span>.so</span><br><span class="line"><span class="number">7f</span>eaf9244000<span class="number">-7f</span>eaf9246000 rw-p <span class="number">001</span>c4000 <span class="number">00</span>:<span class="number">00</span> <span class="number">243912</span>             /lib/x86_64-linux-gnu/libc<span class="number">-2.23</span>.so</span><br><span class="line"><span class="number">7f</span>eaf9246000<span class="number">-7f</span>eaf924a000 rw-p <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span></span><br><span class="line"><span class="number">7f</span>eaf9250000<span class="number">-7f</span>eaf9266000 r-xp <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">180347</span>             /lib/x86_64-linux-gnu/libgcc_s.so<span class="number">.1</span></span><br><span class="line"><span class="number">7f</span>eaf9266000<span class="number">-7f</span>eaf9465000 ---p <span class="number">00016000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">180347</span>             /lib/x86_64-linux-gnu/libgcc_s.so<span class="number">.1</span></span><br><span class="line"><span class="number">7f</span>eaf9465000<span class="number">-7f</span>eaf9466000 rw-p <span class="number">00015000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">180347</span>             /lib/x86_64-linux-gnu/libgcc_s.so<span class="number">.1</span></span><br><span class="line"><span class="number">7f</span>eaf9470000<span class="number">-7f</span>eaf95e2000 r-xp <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">189413</span>             /usr/lib/x86_64-linux-gnu/libstdc++.so<span class="number">.6</span><span class="number">.0</span><span class="number">.21</span></span><br><span class="line"><span class="number">7f</span>eaf95e2000<span class="number">-7f</span>eaf95ef000 ---p <span class="number">00172000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">189413</span>             /usr/lib/x86_64-linux-gnu/libstdc++.so<span class="number">.6</span><span class="number">.0</span><span class="number">.21</span></span><br><span class="line"><span class="number">7f</span>eaf95ef000<span class="number">-7f</span>eaf97e2000 ---p <span class="number">0017f</span>000 <span class="number">00</span>:<span class="number">00</span> <span class="number">189413</span>             /usr/lib/x86_64-linux-gnu/libstdc++.so<span class="number">.6</span><span class="number">.0</span><span class="number">.21</span></span><br><span class="line"><span class="number">7f</span>eaf97e2000<span class="number">-7f</span>eaf97ec000 r--p <span class="number">00172000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">189413</span>             /usr/lib/x86_64-linux-gnu/libstdc++.so<span class="number">.6</span><span class="number">.0</span><span class="number">.21</span></span><br><span class="line"><span class="number">7f</span>eaf97ec000<span class="number">-7f</span>eaf97ee000 rw-p <span class="number">0017</span>c000 <span class="number">00</span>:<span class="number">00</span> <span class="number">189413</span>             /usr/lib/x86_64-linux-gnu/libstdc++.so<span class="number">.6</span><span class="number">.0</span><span class="number">.21</span></span><br><span class="line"><span class="number">7f</span>eaf97ee000<span class="number">-7f</span>eaf97f2000 rw-p <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span></span><br><span class="line"><span class="number">7f</span>eaf9800000<span class="number">-7f</span>eaf9825000 r-xp <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">243945</span>             /lib/x86_64-linux-gnu/ld<span class="number">-2.23</span>.so</span><br><span class="line"><span class="number">7f</span>eaf9825000<span class="number">-7f</span>eaf9826000 r-xp <span class="number">00025000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">243945</span>             /lib/x86_64-linux-gnu/ld<span class="number">-2.23</span>.so</span><br><span class="line"><span class="number">7f</span>eaf9a25000<span class="number">-7f</span>eaf9a26000 r--p <span class="number">00025000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">243945</span>             /lib/x86_64-linux-gnu/ld<span class="number">-2.23</span>.so</span><br><span class="line"><span class="number">7f</span>eaf9a26000<span class="number">-7f</span>eaf9a27000 rw-p <span class="number">00026000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">243945</span>             /lib/x86_64-linux-gnu/ld<span class="number">-2.23</span>.so</span><br><span class="line"><span class="number">7f</span>eaf9a27000<span class="number">-7f</span>eaf9a28000 rw-p <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span></span><br><span class="line"><span class="number">7f</span>eaf9bc0000<span class="number">-7f</span>eaf9bc1000 rw-p <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span></span><br><span class="line"><span class="number">7f</span>eaf9bd0000<span class="number">-7f</span>eaf9bd2000 rw-p <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span></span><br><span class="line"><span class="number">7f</span>eaf9be0000<span class="number">-7f</span>eaf9be1000 rw-p <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span></span><br><span class="line"><span class="number">7f</span>eaf9bf0000<span class="number">-7f</span>eaf9bf1000 rw-p <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span></span><br><span class="line"><span class="number">7f</span>eaf9c00000<span class="number">-7f</span>eaf9c01000 rw-p <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span></span><br><span class="line"><span class="number">7f</span>eaf9c10000<span class="number">-7f</span>eaf9c11000 rw-p <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span></span><br><span class="line"><span class="number">7f</span>fffb85e000<span class="number">-7f</span>fffc05e000 rw-p <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span>                  [<span class="built_in">stack</span>]</span><br><span class="line"><span class="number">7f</span>fffc61d000<span class="number">-7f</span>fffc61e000 r-xp <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span>                  [vdso]</span><br><span class="line">Aborted (core dumped)</span><br></pre></td></tr></table></figure><p>完全符合预期，如果再删除vector中的一个元素就不会崩溃了。</p><h1 id="平台差异"><a href="#平台差异" class="headerlink" title="平台差异"></a>平台差异</h1><p>这篇文章的代码编译和运行都是在Linux下完成的，但是我之前在Windows上测试时，可不需要最少17个元素的前提，这是为什么呢？因为在微软这一套编译环境下，直接检测了Compare中的条件2，并且是以断言的方式给出提示的，所以与Linux上的运行表现还有一些差异。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>使用 <code>std::sort</code> 函数自定义比较函数时，需要满足严格弱排序性，若 <code>comp(a, b)==true</code> 则 <code>comp(b, a)==false</code>，那么在比较函数中两个元素相等的情况要返回false</li><li>使用 <code>std::sort</code> 函数出现崩溃是往往是不满足严格若排序性，但是在复杂的比较函数中也可能不满足传递性</li><li><code>std::sort</code> 为了把排序效率提高到极致，综合使用了快排、堆排、插入排序等多种排序方法</li><li><code>std::sort</code> 在不同的平台实现不同，当比较函数不满足严格若排序时，gcc环境下至少有17个元素才会崩溃，而 <code>MSVC</code> 则在Debug时没有元素个数限制，会通过断言直接判断这个条件是否满足</li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/119090991" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>可是啊 总有那风吹不散的认真 总有大雨也不能抹去的泪痕~</p><p>2021-8-8 23:57:53</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;看到这个标题应该会有很多人一下子就懂了，也会有些人感到迷惑，简简单单排序怎么会奔溃呢？我第一次接触这个问题还是很久以前刚刚参加工作的时候，当时也是写出了导致程序崩溃的代码，通过上网查询解决了问题，至此以后就对这个 &lt;code&gt;sort&lt;/code&gt; 函数警惕了一些，一直记得就是在sort的自定义函数中判断条件不要加等号，至于本质的原因一直没有去探究，正好最近又改了一个相关的问题，所以决定从源码和定义的角度来看看为什么会出现这个问题。&lt;/p&gt;
    
    </summary>
    
      <category term="C/C++" scheme="http://AlbertGithubHome.github.io/blog/categories/C-C/"/>
    
    
      <category term="C/C++" scheme="http://AlbertGithubHome.github.io/blog/tags/C-C/"/>
    
      <category term="sort" scheme="http://AlbertGithubHome.github.io/blog/tags/sort/"/>
    
      <category term="lambda" scheme="http://AlbertGithubHome.github.io/blog/tags/lambda/"/>
    
      <category term="crash" scheme="http://AlbertGithubHome.github.io/blog/tags/crash/"/>
    
  </entry>
  
  <entry>
    <title>使用box2dweb做一个下落的小球，宝宝玩的不亦乐乎</title>
    <link href="http://AlbertGithubHome.github.io/blog/2021/07/21/%E4%BD%BF%E7%94%A8box2dweb%E5%81%9A%E4%B8%80%E4%B8%AA%E4%B8%8B%E8%90%BD%E7%9A%84%E5%B0%8F%E7%90%83%EF%BC%8C%E5%AE%9D%E5%AE%9D%E7%8E%A9%E7%9A%84%E4%B8%8D%E4%BA%A6%E4%B9%90%E4%B9%8E/"/>
    <id>http://AlbertGithubHome.github.io/blog/2021/07/21/使用box2dweb做一个下落的小球，宝宝玩的不亦乐乎/</id>
    <published>2021-07-21T15:26:57.000Z</published>
    <updated>2021-08-07T17:03:01.583Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>红球球~ 蓝球球~</p><p>家里的宝宝就喜欢玩球球，特别是蓝色的，而最近正好找到了一个优秀的物理引擎，就拿它来做了一个下落的小球，宝宝玩的不亦乐乎~</p><p>起初我是想模拟一个小球在不同曲线上的运动状态，一直在找一个简易的重力引擎，找了一段时间没有什么收获，也想过自己写个重力系统，可是仔细想想觉得有点太麻烦，后来玩了一些flash游戏，发现这类依靠重力的作为主要玩法的游戏还真不少，肯定有一个好的引擎可以直接拿来用，然后就发现了 <code>Box2D</code> 这个物理引擎，不但带有重力系统，还支持碰撞。</p><a id="more"></a><h1 id="box2dweb"><a href="#box2dweb" class="headerlink" title="box2dweb"></a>box2dweb</h1><p>其实 cocos2dx 和 unity 中都有使用 <code>Box2D</code> 引擎，只不过自己进行了封装，如果使用这些客户端引擎做出来的东西依赖性比较强，还好顺着 <code>Box2D</code> 这条线发现了一个 <code>box2dweb</code> 引擎，是一个 <code>Box2D</code> 的 js 版本，这就非常方便了，有个浏览器就可以直接运行了，还免去了编译安装的麻烦。</p><h1 id="下落的小球"><a href="#下落的小球" class="headerlink" title="下落的小球"></a>下落的小球</h1><p>开局一张图，后面接着编。。。</p><p><img src="https://img-blog.csdnimg.cn/bcb3268fa5ce4401923b9222e8653973.gif?" alt="下落的小球"></p><p>把这个下落的小球叫做一个游戏确实有些勉强，但是宝宝就是很喜欢玩啊，游戏本来就是让人开心的，开心就好咯！接下来记录一下这个小球是怎么实现的吧~</p><h1 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h1><h2 id="下载引擎"><a href="#下载引擎" class="headerlink" title="下载引擎"></a>下载引擎</h2><p><code>box2dweb</code> 引擎只有一个js文件，可以在github上搜索下载 <a href="https://github.com/hecht-software/box2dweb" target="_blank" rel="noopener">hecht-software/<br>box2dweb</a> ，不过最近访问缓慢，也可以下载这个我备份的版本 <a href="https://download.csdn.net/download/shihengzhen101/20417213" target="_blank" rel="noopener">Box2dWeb-2.1.a.3.min.js</a>，下载之后直接引用即可。</p><h2 id="引入js引擎"><a href="#引入js引擎" class="headerlink" title="引入js引擎"></a>引入js引擎</h2><p>新建一个 html 文件命名为 <code>fallball-game.html</code>，编写如下内容，引入 <code>Box2dWeb-2.1.a.3.min.js</code> 文件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>fall ball game<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"./Box2dWeb-2.1.a.3.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"./fallball.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">"mycanvas"</span> <span class="attr">width</span>=<span class="string">"1600"</span> <span class="attr">height</span>=<span class="string">"900"</span>&gt;</span><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="编写小球逻辑"><a href="#编写小球逻辑" class="headerlink" title="编写小球逻辑"></a>编写小球逻辑</h2><p>在上面的 html 文件中不仅引入了 <code>Box2dWeb-2.1.a.3.min.js</code> 这个物理引擎，还引入了一个 <code>fallball.js</code> 文件，这是一个新建的自定义的js文件，需要我们在这个文件中编写小球的逻辑。</p><h3 id="引入常用类型并简写"><a href="#引入常用类型并简写" class="headerlink" title="引入常用类型并简写"></a>引入常用类型并简写</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> b2Vec2 = Box2D.Common.Math.b2Vec2</span><br><span class="line">, b2AABB = Box2D.Collision.b2AABB</span><br><span class="line">, b2BodyDef = Box2D.Dynamics.b2BodyDef</span><br><span class="line">, b2Body = Box2D.Dynamics.b2Body</span><br><span class="line">, b2FixtureDef = Box2D.Dynamics.b2FixtureDef</span><br><span class="line">, b2Fixture = Box2D.Dynamics.b2Fixture</span><br><span class="line">, b2World = Box2D.Dynamics.b2World</span><br><span class="line">, b2MassData = Box2D.Collision.Shapes.b2MassData</span><br><span class="line">, b2PolygonShape = Box2D.Collision.Shapes.b2PolygonShape</span><br><span class="line">, b2CircleShape = Box2D.Collision.Shapes.b2CircleShape</span><br><span class="line">, b2DebugDraw = Box2D.Dynamics.b2DebugDraw</span><br><span class="line">, b2MouseJointDef =  Box2D.Dynamics.Joints.b2MouseJointDef</span><br><span class="line">, b2RayCastInput = Box2D.Collision.b2RayCastInput</span><br><span class="line">, b2RayCastOutput = Box2D.Collision.b2RayCastOutput</span><br></pre></td></tr></table></figure><p>以上这些都是 <code>Box2D</code> 引擎中常用的类，使用简写的变量来引用这些类，这样在后面使用时会方便很多。</p><h3 id="创建Box2D世界"><a href="#创建Box2D世界" class="headerlink" title="创建Box2D世界"></a>创建Box2D世界</h3><p><code>b2World</code> 是 <code>Box2D</code> 系统模拟物理世界的核心，可以想象成我们生活中的地球，在地球上有各种各样的物理环境，比如从空中自由落体的小球，在水中航行的轮船等等，使用 <code>b2World</code> 就可以创建这样一个世界。</p><p>在物理世界中首先需要的是重力，那么先定义一个有方向的力：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> gravity = <span class="keyword">new</span> b2Vec2(<span class="number">0</span>, <span class="number">9.8</span>);</span><br></pre></td></tr></table></figure><p>作为一个模拟物理环境的引擎，效率使我们需要考虑的问题，对于静止不动的对象，最好不进行模拟计算来节省CPU运算，这种静止的对象可以让他们在 Box2D 环境中睡觉。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> doSleep = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure></p><p>需要的参数都准备好了，这样可以new出一个Box2D世界了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> world = <span class="keyword">new</span> b2World(gravity, doSleep);</span><br></pre></td></tr></table></figure><h3 id="创建一个小球"><a href="#创建一个小球" class="headerlink" title="创建一个小球"></a>创建一个小球</h3><ol><li>先创建一个物体</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> bodydef = <span class="keyword">new</span> b2BodyDef();</span><br><span class="line"><span class="comment">// 物体类型定义，基本上常用的有两种定义：b2_staticBody 静态物体; b2_dynimacBod动态物体</span></span><br><span class="line">bodydef.type= b2Body.b2_staticBody;</span><br><span class="line"><span class="comment">// 定义物体位置</span></span><br><span class="line">bodydef.position.Set(<span class="number">0</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><ol><li>再创建一个材质</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fixDef = <span class="keyword">new</span> b2FixtureDef();</span><br><span class="line">fixDef.density = <span class="number">1.0</span>; <span class="comment">// desity 密度，如果密度为0或者null，该物体则为一个静止对象</span></span><br><span class="line">fixDef.friction = <span class="number">0.5</span>; <span class="comment">//摩擦力（0~1）</span></span><br><span class="line">fixDef.restitution = <span class="number">0.2</span>;<span class="comment">// 弹性（0~1）</span></span><br></pre></td></tr></table></figure><ol><li>为材质添加一个形状并创建小球</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fixDef.shape = <span class="keyword">new</span> b2CircleShape(<span class="number">0.5</span>);</span><br><span class="line"></span><br><span class="line">bodyDef.type = b2Body.b2_dynamicBody;</span><br><span class="line">bodyDef.position.Set(<span class="number">3</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bomb = world.CreateBody(bodyDef);</span><br><span class="line">bomb.userData = <span class="string">"iambomb"</span>;</span><br><span class="line">bomb.CreateFixture(fixDef)</span><br></pre></td></tr></table></figure><blockquote><ol><li>b2PolygonShape为多边形，设置形状大小时对应着SetAsBox(halfWidth, halfHeight)函数，参数半长和半宽，如果自定义多边形可以使用一个SetAsArray(vertexArray,vertexCount)，其中vertexArray为顶点矢量（b2Vec2）数组，vertexCount为顶点数，最多8个</li><li>b2CircleSharp为圆形，对应的设置属性为半径，函数为SetRadius(radius)</li><li>需要注意的是Box2d中的单位是米，1米是30像素，在绘制材质图片时需注意单位换算</li><li>使用 bomb.ApplyForce(force, point); 可以添加一个外力，force是一个b2Vec2的向量代表外力，point一个b2Vec2的向量代表物体的着力点。使用 bomb.SetMassFromShapes(); 可以根据形状计算质量</li></ol></blockquote><h3 id="创建背景刚体物理"><a href="#创建背景刚体物理" class="headerlink" title="创建背景刚体物理"></a>创建背景刚体物理</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> vertices = [</span><br><span class="line">    <span class="keyword">new</span> b2Vec2(<span class="number">0</span>, <span class="number">0</span>),</span><br><span class="line">    <span class="keyword">new</span> b2Vec2(<span class="number">20</span>, <span class="number">10</span>),</span><br><span class="line">    <span class="keyword">new</span> b2Vec2(<span class="number">0</span>, <span class="number">10</span>),</span><br><span class="line">]</span><br><span class="line">fixDef.shape = <span class="keyword">new</span> b2PolygonShape.AsArray(vertices, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//fixDef.shape = new b2PolygonShape();</span></span><br><span class="line"><span class="comment">//fixDef.shape.SetAsBox(30, 1);</span></span><br><span class="line"></span><br><span class="line">bodyDef.type = b2Body.b2_staticBody;</span><br><span class="line">bodyDef.position.Set(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">world.CreateBody(bodyDef).CreateFixture(fixDef);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> vertices2 = [</span><br><span class="line">    <span class="keyword">new</span> b2Vec2(<span class="number">19</span>, <span class="number">10</span>),</span><br><span class="line">    <span class="keyword">new</span> b2Vec2(<span class="number">40</span>, <span class="number">0</span>),</span><br><span class="line">    <span class="keyword">new</span> b2Vec2(<span class="number">40</span>, <span class="number">10</span>),</span><br><span class="line">]</span><br><span class="line">fixDef.shape = <span class="keyword">new</span> b2PolygonShape.AsArray(vertices2, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">bodyDef.type = b2Body.b2_staticBody;</span><br><span class="line">bodyDef.position.Set(<span class="number">0</span>, <span class="number">5</span>);</span><br><span class="line">world.CreateBody(bodyDef).CreateFixture(fixDef);</span><br></pre></td></tr></table></figure><p>参照小球创建的方式创建两个三角形物体，这里注意一个问题，三角形的坐标需要顺时针给出，否则两个刚体的碰撞会出现问题。</p><h3 id="创建调试环境"><a href="#创建调试环境" class="headerlink" title="创建调试环境"></a>创建调试环境</h3><p>实际上，Box2D只是集成了各种算法，对b2Body对象进行物理模拟计算，并将计算结果存储到这个对象中，但是它并不是DisplayObject的子类，也就意味着我们无法通过addChild()将它添加到舞台上，这时可以借助b2DebugDraw类，绑定一个Sprite对象，Box2D就能帮我们在这个Sprite中，用绘图API绘制出模拟图形，方便我们进行调试。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> debugDraw = <span class="keyword">new</span> b2DebugDraw();</span><br><span class="line">debugDraw.SetSprite(<span class="built_in">document</span>.getElementById(<span class="string">"mycanvas"</span>).getContext(<span class="string">"2d"</span>));</span><br><span class="line">debugDraw.SetDrawScale(<span class="number">30.0</span>);</span><br><span class="line">debugDraw.SetFillAlpha(<span class="number">0.5</span>);</span><br><span class="line">debugDraw.SetLineThickness(<span class="number">1.0</span>);</span><br><span class="line">debugDraw.SetFlags(</span><br><span class="line">    b2DebugDraw.e_shapeBit | b2DebugDraw.e_jointBit | b2DebugDraw.e_controllerBit | b2DebugDraw.e_pairBit);</span><br><span class="line">world.SetDebugDraw(debugDraw);</span><br></pre></td></tr></table></figure><h2 id="世界更新"><a href="#世界更新" class="headerlink" title="世界更新"></a>世界更新</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">update</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    world.Step(<span class="number">1</span> / <span class="number">60</span>,  <span class="comment">//frame-rate</span></span><br><span class="line">                   <span class="number">10</span>,  <span class="comment">//velocity iterations</span></span><br><span class="line">                   <span class="number">10</span>); <span class="comment">//position iterations</span></span><br><span class="line">    world.DrawDebugData();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> b = world.m_bodyList; b != <span class="literal">null</span>; b = b.m_next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b.GetUserData()) &#123;</span><br><span class="line">            context.save();</span><br><span class="line">            context.translate(b.GetPosition().x * <span class="number">30</span>, b.GetPosition().y * <span class="number">30</span>);</span><br><span class="line">            context.rotate(b.GetAngle());</span><br><span class="line">            context.drawImage(b.GetUserData(), -b.GetUserData().width / <span class="number">2</span>, -b.GetUserData().height / <span class="number">2</span>);</span><br><span class="line">            context.restore();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    world.ClearForces();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setInterval(update, <span class="number">1000</span> / <span class="number">60</span>);</span><br></pre></td></tr></table></figure><p>定义更新函数，注册定时器，用来定时更新。物理引擎的 <code>world.Step</code> 函数是整个 <code>Box2D</code> 引擎的核心, 它驱动了物理世界的运行。而上述代码中 <code>for</code> 循环的部分处理了材质跟随刚体运动的逻辑，可以自定义显示图片，这个已经实验成功，改天可以接着写一写。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li><code>Box2D</code> 是一个优秀易用的物理引擎，而 <code>box2dweb</code> 是一个js版本，可以很方便的在html引入使用</li><li><code>box2dweb</code> 不仅能模拟重力环境，还能模拟物体之间的碰撞，可以通过参数调整物体的密度、摩擦力和弹力</li><li>物体的形状可以多边形，可以通过给出顶点坐标的形式设置，不过要注意按照顺时针方向给出，否则碰撞失败，具体原因还不太清楚</li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/118886009" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>这个世界上，还有很多不被认可的梦想，不被祝福的感情，不被眷顾的孩子，他们不曾犯错，却只能颤颤巍巍，单薄地行走在路上。你我都一样 要承认 我们都很平凡 并且在负重~</p><p>2021-7-25 18:59:01</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;红球球~ 蓝球球~&lt;/p&gt;
&lt;p&gt;家里的宝宝就喜欢玩球球，特别是蓝色的，而最近正好找到了一个优秀的物理引擎，就拿它来做了一个下落的小球，宝宝玩的不亦乐乎~&lt;/p&gt;
&lt;p&gt;起初我是想模拟一个小球在不同曲线上的运动状态，一直在找一个简易的重力引擎，找了一段时间没有什么收获，也想过自己写个重力系统，可是仔细想想觉得有点太麻烦，后来玩了一些flash游戏，发现这类依靠重力的作为主要玩法的游戏还真不少，肯定有一个好的引擎可以直接拿来用，然后就发现了 &lt;code&gt;Box2D&lt;/code&gt; 这个物理引擎，不但带有重力系统，还支持碰撞。&lt;/p&gt;
    
    </summary>
    
      <category term="Game" scheme="http://AlbertGithubHome.github.io/blog/categories/Game/"/>
    
    
      <category term="Game" scheme="http://AlbertGithubHome.github.io/blog/tags/Game/"/>
    
      <category term="JS" scheme="http://AlbertGithubHome.github.io/blog/tags/JS/"/>
    
      <category term="物理引擎" scheme="http://AlbertGithubHome.github.io/blog/tags/%E7%89%A9%E7%90%86%E5%BC%95%E6%93%8E/"/>
    
      <category term="box2dweb" scheme="http://AlbertGithubHome.github.io/blog/tags/box2dweb/"/>
    
  </entry>
  
  <entry>
    <title>C/C++中的数据类型转换static_cast/dynamic_cast/const_cast/reinterpret_cast</title>
    <link href="http://AlbertGithubHome.github.io/blog/2021/07/10/C-C-%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"/>
    <id>http://AlbertGithubHome.github.io/blog/2021/07/10/C-C-中的数据类型转换/</id>
    <published>2021-07-10T09:06:15.000Z</published>
    <updated>2021-07-11T16:28:07.032Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>C/C++属于静态语言，也就是在编译时变量的数据类型即可确定的强类型语言。当不同的数据类型在一起运算或者相互赋值的时候，就需要进行数据类型转换。不同数据类型占用的内存空间不同，而各种数据类型的转换时有规则的，一种通用的规则就是“小转大”自动进行，“大转小”需要强制执行。这里的“大”和“小”指的是数据范围。</p><a id="more"></a><p>为什么会有数据范围大小的区别呢？这就和饭店里的盘子一样，不同的菜肴通常使用不同的盘子，盘子有大有小，如果把小盘子里的菜装到大盘子里没有问题，但是把大盘子里的菜放到小盘子中就会溢出来，假设都使用大盘子就不会产生溢出的问题，但是这样会产生空间的浪费。而C/C++中不同类型的变量占用的内存空间不同与这些盘子非常相似，当范围小的变量赋值给范围大的变量时没有问题，但是反过来也会出现溢出。</p><h1 id="数据类型自动转换"><a href="#数据类型自动转换" class="headerlink" title="数据类型自动转换"></a>数据类型自动转换</h1><p>当不同类型的变量同时运算时就会发生数据类型的自动转换，以常见的 <code>char</code>、<code>short</code>、<code>int</code>、<code>long</code>、<code>float</code>、<code>double</code> 这些类型为例，如果 <code>char</code> 和 <code>int</code> 两个类型的变量相加时，就会把 <code>char</code> 先转换成 <code>int</code> 再进行加法运算，如果是 <code>int</code> 和 <code>double</code> 类型的变量相乘就会把 <code>int</code> 转换成 <code>double</code> 再进行运算。</p><p>自动转换的行为如下图所示，方向是从左往右自动进行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">    A((char))--&gt;C(unsigned/int)</span><br><span class="line">    B((short))--&gt;C(unsigned/int)</span><br><span class="line">    C(unsigned/int)--&gt;D(unsigned/long)</span><br><span class="line">    D(unsigned/long)--&gt;F[double]</span><br><span class="line">    E(float)--&gt;F[double]</span><br></pre></td></tr></table></figure><h1 id="C语言中的强制类型转换"><a href="#C语言中的强制类型转换" class="headerlink" title="C语言中的强制类型转换"></a>C语言中的强制类型转换</h1><p>前面说了自动转换，从这里开始聊聊强制类型转换，需要强制类型转换往往程序不那么智能了，需要人工进行干预。比如把一个<code>int</code> 类型的变量赋值给 <code>char</code> 类型的变量，或者说把两个 <code>int</code> 相乘时可能会得到一个很大的数，所以需要先把 <code>int</code> 强制转换成 <code>double</code> 计算防止溢出。</p><p>强制类型转换的格式为：<code>(new_type_name) expression</code>，其中 <code>new_type_name</code> 为新类型名称，<code>expression</code>为表达式。例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">int</span> val = <span class="number">65535</span>;</span><br><span class="line"><span class="keyword">char</span> ch = (<span class="keyword">char</span>)val;</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> m = <span class="number">2147483647</span>, n = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">double</span> result = (<span class="keyword">double</span>)m * n;</span><br></pre></td></tr></table></figure><p>无论是自动的类型转换还是强制类型转换，都只是为了本次操作或运算而进行的临时转换，转换的结果也会保存到临时的内存空间内，不会改变数据本来的类型或者具体的值。</p><p>有些强制类型转换是对原有数据的重新解释，比如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">void</span>* p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>* buffer = (<span class="keyword">char</span>*)p;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>void*</code> 类型的变量p，经过强制类型转换以后变成了<code>char</code>类型的指针，此后就可以把这段内存空间当成字符数组来处理了。</p><h1 id="C-中的强制类型转换"><a href="#C-中的强制类型转换" class="headerlink" title="C++中的强制类型转换"></a>C++中的强制类型转换</h1><p>在C++语言中新增了四个用于强制类型转换的关键字，分别是 <code>static_cast</code>、 <code>dynamic_cast</code>, <code>const_cast</code>、 和 <code>reinterpret_cast</code>，使用语法为 <code>xxxx_cast&lt;new_type_name&gt;(expression)</code>。</p><p>相比于C语言中使用小括号<code>()</code>来完成强制类型转换，C++中这几个关键字的引入能更清晰的表明它要完成强制类型转换的意图，容易暴露出隐藏的问题。</p><p>其实很长一段时间以来，我对于这四种强转方式区分的不是很清晰，其中 <code>const_cast</code> 的功能还比较容易辨别，但是另外3种经常混作一团，所以才有了这篇总结，而仔细学习后才发现，这4种强转关键字的区别就在他们的名字上，下面逐个来看一下。</p><h2 id="static-cast"><a href="#static-cast" class="headerlink" title="static_cast"></a>static_cast</h2><p>这个关键字的作用主要表现在 <code>static</code> 上，是一种静态的转换，在编译期就能确定的转换，可以完成C语言中的强制类型转换中的大部分工作，但需要注意的是，它不能转换掉表达式的 <code>const</code>、<code>volitale</code> 或者 <code>__unaligned</code> 属性。</p><p>它主要有以下几种用法：</p><ol><li><p>用于基本数据类型之间的转换，如把<code>int</code>转换成<code>char</code>，把<code>int</code>转换成<code>double</code>等。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> val = <span class="number">110119</span>;</span><br><span class="line"><span class="keyword">char</span> c = <span class="keyword">static_cast</span>&lt;<span class="keyword">char</span>&gt;(val);</span><br><span class="line"><span class="keyword">double</span> d = <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(val);</span><br></pre></td></tr></table></figure></li><li><p>将表达式转换成<code>void</code>类型，并将转换后的结果丢弃</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> val = <span class="number">110119</span>;</span><br><span class="line"><span class="keyword">static_cast</span>&lt;<span class="keyword">void</span>&gt;(val);</span><br></pre></td></tr></table></figure></li><li><p>可以用于<code>void*</code> 和其他指针类类型之间的转换，但是不能用于两个无关指针类型的直接转换</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正常转换</span></span><br><span class="line"><span class="keyword">int</span> *p = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line"><span class="keyword">void</span>* p1 = <span class="keyword">static_cast</span>&lt;<span class="keyword">void</span>*&gt;(p);</span><br><span class="line"><span class="keyword">char</span>* p2 =  <span class="keyword">static_cast</span>&lt;<span class="keyword">char</span>*&gt;(p1);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译失败 //error: invalid static_cast from type ‘int*’ to type ‘char*’</span></span><br><span class="line"><span class="keyword">char</span>* p3 =  <span class="keyword">static_cast</span>&lt;<span class="keyword">char</span>*&gt;(p);</span><br></pre></td></tr></table></figure></li><li><p>可以用于类继承结构中基类和派生类之间指针或引用的转换，向上转型安全，向下转型由于没有动态类型检查，是不安全的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span> &#123;</span> &#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">D</span> :</span> B &#123; &#125;;</span><br><span class="line"></span><br><span class="line">D d;</span><br><span class="line">B&amp; rb = d;</span><br><span class="line">D&amp; rd = <span class="keyword">static_cast</span>&lt;D&amp;&gt;(rb);</span><br></pre></td></tr></table></figure></li><li><p>如果涉及左值到右值、数组到指针或函数到指针的转换，也可以通过static_cast显式执行。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">typename</span> <span class="built_in">std</span>::remove_reference&lt;_Tp&gt;::type&amp;&amp;</span><br><span class="line">move(_Tp&amp;&amp; <span class="keyword">__t</span>)</span><br><span class="line">&#123; <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">typename</span> <span class="built_in">std</span>::remove_reference&lt;_Tp&gt;::type&amp;&amp;&gt;(<span class="keyword">__t</span>); &#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="dynamic-cast"><a href="#dynamic-cast" class="headerlink" title="dynamic_cast"></a>dynamic_cast</h2><p>从名字上看，这个关键字与 <code>static_cast</code> 的静态转换是对立的，这是一个“动态”转换函数，只能对指针和引用的进行转换，并且只用于类继承结构中基类和派生类之间指针或引用的转换，可以进行向上、向下，或者横向的转换。</p><p>相比于 <code>static_cast</code> 的编译时转换， <code>dynamic_cast</code> 的转换还会在运行时进行类型检查，转换的条件也比较苛刻，必须有继承关系的类之间才能转换，并且在基类中有虚函数才可以，有一种特殊的情况就是可以把类指针转换成 <code>void*</code> 类型。</p><p>关于使用中的常见问题，参考以下几种情况：</p><ol><li><p>普通类型的指针无法转换</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> val = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> *p = &amp;val;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译失败 //error: cannot dynamic_cast ‘p’ (of type ‘int*’) to type ‘char*’ (target is not pointer or reference to class)</span></span><br><span class="line"><span class="keyword">char</span>* pc =  <span class="keyword">dynamic_cast</span>&lt;<span class="keyword">char</span>*&gt;(p);</span><br></pre></td></tr></table></figure></li><li><p>继承结构中基类里面没有虚函数无法转换</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span> &#123;</span> &#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">D</span> :</span> B &#123; &#125;;</span><br><span class="line"></span><br><span class="line">D d;</span><br><span class="line">B* pb = &amp;d;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译失败 //error: cannot dynamic_cast ‘pb’ (of type ‘struct test1()::B*’) to type ‘struct test1()::D*’ (source type is not polymorphic)</span></span><br><span class="line">D* pd = <span class="keyword">dynamic_cast</span>&lt;D*&gt;(pb)</span><br></pre></td></tr></table></figure></li><li><p>指针或引用转换的类型不是正确的类型，如果参数类型是指针会返回目标类型空指针，如果参数类型是引用则会抛出 <code>std::bad_cast</code> 异常。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span> &#123;</span> <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;&#125; &#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">D</span> :</span> B &#123; &#125;;</span><br><span class="line"></span><br><span class="line">B d;</span><br><span class="line">B* pb = &amp;d;</span><br><span class="line">D* pd = <span class="keyword">dynamic_cast</span>&lt;D*&gt;(pb);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译成功，但是pb指针指向的类型是 B，向下转型失败，输出结果是0，也就是空指针</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; pd &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure></li><li><p>一个正常转换的例子，包含向上、向下、横向转换</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span> &#123;</span> <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;&#125; &#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">D1</span> :</span> <span class="keyword">virtual</span> B &#123; &#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">D2</span> :</span> <span class="keyword">virtual</span> B &#123; &#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MD</span> :</span> D1, D2 &#123; &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">D1* pd1 = <span class="keyword">new</span> MD();</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; pd1 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向上转型</span></span><br><span class="line">B* pb = <span class="keyword">dynamic_cast</span>&lt;B*&gt;(pd1);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; pb &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向下转型</span></span><br><span class="line">MD* pmd = <span class="keyword">dynamic_cast</span>&lt;MD*&gt;(pd1);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; pmd &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 横向转型</span></span><br><span class="line">D2* pd2 = <span class="keyword">dynamic_cast</span>&lt;D2*&gt;(pd1);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; pd2 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>运行结果如下，在横向转换时指针发生了变化，可以看出 <code>dynamic_cast</code> 不是简单的数据强转，还进行了指针的偏移：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:/mnt/d/testconvert$ g++ cppconvert.cpp</span><br><span class="line">albert@home-pc:/mnt/d/testconvert$ ./a.out</span><br><span class="line">0x15c0c40</span><br><span class="line">0x15c0c40</span><br><span class="line">0x15c0c40</span><br><span class="line">0x15c0c48</span><br></pre></td></tr></table></figure></li></ol><h2 id="const-cast"><a href="#const-cast" class="headerlink" title="const_cast"></a>const_cast</h2><p>在C/C++中，const限定符通常被用来限定变量，用于表示该变量的值不能被修改，这种限定可以避免程序员犯一些初级错误，但同时也造成了一些不便，比如一些已有函数要求非常量指针，但是掉用这些函数的接口函数中都传递了常量指针，这时候就要对指针类型去常量化。</p><p>但需要特别注意的是 <code>const_cast</code> 不能去除变量的常量性，只能用来去除指向常数对象的指针或引用的常量性，且去除常量性的对象必须为指针或引用。</p><p>常量指针被转化成非常量指针，并且仍然指向原来的对象，常量引用被转换成非常量引用，并且仍然指向原来的对象；常量对象<strong>可能</strong>被转换成非常量对象。</p><ol><li><p>尝试去除非指针和引用的类型的常量性会编译失败</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> i = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译错误 //</span></span><br><span class="line"><span class="keyword">int</span> j = <span class="keyword">const_cast</span>&lt;<span class="keyword">int</span>&gt;(i);</span><br></pre></td></tr></table></figure></li><li><p>企图用一个指针来修改常量：</p></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> val = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//编译错误 //error: invalid conversion from ‘const int*’ to ‘int*’ [-fpermissive]</span></span><br><span class="line"><span class="keyword">int</span>* cp = &amp;val;</span><br></pre></td></tr></table></figure><ol><li><p>修改一个指针的常量性：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> val = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"&amp;val="</span> &lt;&lt; &amp;val &lt;&lt; <span class="string">", val="</span> &lt;&lt; val &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>* cp = &amp;val;</span><br><span class="line"><span class="keyword">int</span> *p = <span class="keyword">const_cast</span>&lt;<span class="keyword">int</span>*&gt;(cp);</span><br><span class="line">*p = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"&amp;val="</span> &lt;&lt; &amp;val &lt;&lt; <span class="string">", val="</span> &lt;&lt; val &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"p="</span> &lt;&lt; p &lt;&lt; <span class="string">", *p="</span> &lt;&lt; *p &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure></li></ol><p>运行结果如下：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&amp;val=0x7ffff7446bd4, val=6</span><br><span class="line">&amp;val=0x7ffff7446bd4, val=6</span><br><span class="line">p=0x7ffff7446bd4, *p=2</span><br></pre></td></tr></table></figure><p>运行之后，变量 <code>p</code> 指向了变量<code>val</code>地址，并改变了地址所指向的内存数据，但是打印 <code>val</code> 的值并没有发生变化，这是因为 <code>val</code> 作为常量在编译期使用它的地方就进行了替换，接下来再看另一种情况。</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> init = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> val = init;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"&amp;val="</span> &lt;&lt; &amp;val &lt;&lt; <span class="string">", val="</span> &lt;&lt; val &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>* cp = &amp;val;</span><br><span class="line"><span class="keyword">int</span> *p = <span class="keyword">const_cast</span>&lt;<span class="keyword">int</span>*&gt;(cp);</span><br><span class="line">*p = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"&amp;val="</span> &lt;&lt; &amp;val &lt;&lt; <span class="string">", val="</span> &lt;&lt; val &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"p="</span> &lt;&lt; p &lt;&lt; <span class="string">", *p="</span> &lt;&lt; *p &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>代码逻辑不变，只在开始的位置使用 <code>init</code> 这个变量来代替 <code>6</code> 这个常数，运行结果如下：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">val=0x7fffe8c71fa0, val=6</span><br><span class="line">&amp;val=0x7fffe8c71fa0, val=2</span><br><span class="line">p=0x7fffe8c71fa0, *p=2</span><br></pre></td></tr></table></figure><p>运行之后 <code>val</code> 本身的变化也应用到了使用它的地方，这里的编译器替换已经不起作用了。</p><p>实际上，使用const_cast通常是一种无奈之举，利用const_cast去掉指针或引用的常量性并且去修改原始变量的数值，这是一种非常不好的行为，如果可以的话，尽可能在程序设计阶段就规避这种情况。</p><h2 id="reinterpret-cast"><a href="#reinterpret-cast" class="headerlink" title="reinterpret_cast"></a>reinterpret_cast</h2><p>它被用于不同类型指针或引用之间的转换，或者指针和整数之间的转换，是对比特位的简单拷贝并重新解释，因此在使用过程中需要特别谨慎，比如前面提到的一个例子，<code>static_cast</code> 不能将 <code>int*</code> 直接强转成 <code>char*</code>，使用reinterpret_cast就可以办到。</p><ol><li><p>不同基础类型指针类型之间转换：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译失败 //error: invalid static_cast from type ‘int*’ to type ‘char*’</span></span><br><span class="line"><span class="keyword">char</span>* p1 =  <span class="keyword">static_cast</span>&lt;<span class="keyword">char</span>*&gt;(p);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译成功</span></span><br><span class="line"><span class="keyword">char</span>* p2 =  <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">char</span>*&gt;(p1);</span><br></pre></td></tr></table></figure></li><li><p>基础类型指针与类对象指针之间的转换：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span> &#123;</span> <span class="keyword">int</span> val;&#125;;</span><br><span class="line"></span><br><span class="line">B b&#123;<span class="number">100</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"b.val="</span> &lt;&lt; b.val &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>* p = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">int</span>*&gt;(&amp;b);</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"*p="</span> &lt;&lt; *p &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure></li></ol><p>运行之后可以得到 <code>*p</code> 的值为100，也就是重新解释了变量 <code>b</code> 的地址为整型指针。</p><ol><li><p>将地址值转换成整数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span> &#123;</span> <span class="keyword">int</span> val;&#125;;</span><br><span class="line"></span><br><span class="line">B b&#123;<span class="number">101</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"&amp;b="</span> &lt;&lt; &amp;b &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> addr = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">long</span>&gt;(&amp;b);</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"addr="</span> &lt;&lt; addr &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure></li></ol><p>运行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&amp;b=0x7ffffdc4f270</span><br><span class="line">addr=140737450930800</span><br></pre></td></tr></table></figure><p>这里的地址 <code>0x7ffffdc4f270</code> 被解释成了整数 <code>140737450930800</code>，因为涉及到字节序，这也是很多文章提到的 <code>reinterpret_cast</code> 不具备一致性的问题，我们需要知道这一个点，只要代码不依赖主机字节序就没有问题。</p><h2 id="强转关键字的选择"><a href="#强转关键字的选择" class="headerlink" title="强转关键字的选择"></a>强转关键字的选择</h2><p>好几个关键字，并且有些功能还是重复的，那么究竟该选哪一个呢？这个真得按照经验来选，我建议使用排除法，按照 <code>const_cast -&gt; dynamic_cast -&gt; reinterpret_cast -&gt; static_cast</code> 的顺序带入选择。</p><ol><li><p>先看是不是要去掉指针或引用的常量属性，如果是只能选择 <code>const_cast</code></p></li><li><p>再看转换的是不是继承体系下的多态结构，如果是这种结构下的指针和引用的转换最好使用 <code>dynamic_cast</code></p></li><li><p>接着看是不是偏底层的代码，需要将无关类型指针进行转换，或者指针与整数之间进行转换，如果是则选择 <code>reinterpret_cast</code></p></li><li><p>前三种情况都不满足，那就只能使用 <code>static_cast</code> 了</p></li></ol><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>C/C++中不同数据类型进行运算或者赋值的时候会发生数据转换，这种转换有些是自动进行的，有些需要进行显示的强制类型转换</li><li>在C语言中强制类型转换写成<code>(new_type_name) expression</code>的形式，<code>new_type_name</code> 是要转换的目标类型，<code>expression</code> 是待转换的表达式</li><li>在C++中强制类型转换通过更明显的关键字来完成，分别是<code>static_cast</code>、 <code>dynamic_cast</code>, <code>const_cast</code>、 和 <code>reinterpret_cast</code></li><li><code>static_cast</code> 是静态转换，在编译期完成完成转换，与C语言中的强制类型转换重合度最高</li><li><code>dynamic_cast</code> 是动态转换，在运行时转换会进行检查，必须用在有继承关系的多态结构中</li><li><code>const_cast</code> 是常量转换，用于取出指针或引用的常量属性，但是尽量通过设计杜绝它的使用场景</li><li><code>reinterpret_cast</code> 是一种内存数据的重新解释，比较原始，开发者使用它的时候应该明确的知道自己在做什么</li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/118470962" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>今夜的雨，好美~</p><p>2021-7-12 00:18:13</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;C/C++属于静态语言，也就是在编译时变量的数据类型即可确定的强类型语言。当不同的数据类型在一起运算或者相互赋值的时候，就需要进行数据类型转换。不同数据类型占用的内存空间不同，而各种数据类型的转换时有规则的，一种通用的规则就是“小转大”自动进行，“大转小”需要强制执行。这里的“大”和“小”指的是数据范围。&lt;/p&gt;
    
    </summary>
    
      <category term="C/C++" scheme="http://AlbertGithubHome.github.io/blog/categories/C-C/"/>
    
    
      <category term="C/C++" scheme="http://AlbertGithubHome.github.io/blog/tags/C-C/"/>
    
      <category term="数据转换" scheme="http://AlbertGithubHome.github.io/blog/tags/%E6%95%B0%E6%8D%AE%E8%BD%AC%E6%8D%A2/"/>
    
      <category term="自动" scheme="http://AlbertGithubHome.github.io/blog/tags/%E8%87%AA%E5%8A%A8/"/>
    
      <category term="强制类型转换" scheme="http://AlbertGithubHome.github.io/blog/tags/%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"/>
    
  </entry>
  
  <entry>
    <title>换个角度来看看C++中的左值、右值、左值引用、右值引用</title>
    <link href="http://AlbertGithubHome.github.io/blog/2021/07/04/%E6%8D%A2%E4%B8%AA%E8%A7%92%E5%BA%A6%E6%9D%A5%E7%9C%8B%E7%9C%8BC-%E4%B8%AD%E7%9A%84%E5%B7%A6%E5%80%BC%E3%80%81%E5%8F%B3%E5%80%BC%E3%80%81%E5%B7%A6%E5%80%BC%E5%BC%95%E7%94%A8%E3%80%81%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8/"/>
    <id>http://AlbertGithubHome.github.io/blog/2021/07/04/换个角度来看看C-中的左值、右值、左值引用、右值引用/</id>
    <published>2021-07-04T09:06:54.000Z</published>
    <updated>2021-07-04T16:37:51.353Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>对于左值和右值有一个不太严谨的定义——在赋值表达式 <code>=</code> 左侧是的左值，而在 <code>=</code> 右侧的是右值。通过不断学习和尝试，最近我发现一个新的说法更加贴切，那就是“左值是容器，右值是东西”。对于这个定义我们可以类比一下水杯和水，通过水杯可以操作水杯中的水，操作过程中的中间结果如果想要进一步操作，可以将其放入其他的水杯，如果没有水杯就无法找到曾经操作过的水了，也就无法继续操作了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">int</span> c = a + b;</span><br></pre></td></tr></table></figure><p>在这个例子中，变量 <code>a</code>，<code>b</code>, <code>c</code> 都是水杯，而 <code>2</code>、<code>6</code>、<code>a + b</code> 都是被用来操作的水，只有把这些“水”放到“水杯”中才能被找到，才可以进行下一步操作。</p><a id="more"></a><p>关于左值、右值、左值引用和右值引用的概念可以看看之前的总结：</p><ul><li><a href="https://blog.csdn.net/albertsh/article/details/105756674" target="_blank" rel="noopener">简单聊聊C/C++中的左值和右值</a></li><li><a href="https://blog.csdn.net/albertsh/article/details/105941232" target="_blank" rel="noopener">C++11在左值引用的基础上增加右值引用</a></li></ul><p>虽然温故不一定知新，但绝对可以增强记忆，参照着之前的理解，今天来换一种窥探本质的方式。</p><h1 id="汇编代码初探"><a href="#汇编代码初探" class="headerlink" title="汇编代码初探"></a>汇编代码初探</h1><p>为了熟悉一下汇编代码，我们先写个简单的例子，内容就是上述提到的那一段，新建一个文件 <code>main.cpp</code>，然后编写如下代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">6</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> c = a + b;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行 <code>g++ main.cpp --std=c++11 -S -o main.s</code> 编译这段代码，生成汇编文件 <code>main.s</code>，打开文件内容如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">    .file   <span class="string">"main.cpp"</span></span><br><span class="line">    .text</span><br><span class="line">    .globl  main</span><br><span class="line">    .type   main, @function</span><br><span class="line">main:</span><br><span class="line">.LFB0:</span><br><span class="line">    .cfi_startproc</span><br><span class="line">    pushq   %rbp</span><br><span class="line">    .cfi_def_cfa_offset <span class="number">16</span></span><br><span class="line">    .cfi_offset <span class="number">6</span>, <span class="number">-16</span></span><br><span class="line">    movq    %rsp, %rbp</span><br><span class="line">    .cfi_def_cfa_register <span class="number">6</span></span><br><span class="line">    movl    $<span class="number">6</span>, <span class="number">-12</span>(%rbp)</span><br><span class="line">    movl    $<span class="number">2</span>, <span class="number">-8</span>(%rbp)</span><br><span class="line">    movl    <span class="number">-12</span>(%rbp), %edx</span><br><span class="line">    movl    <span class="number">-8</span>(%rbp), %eax</span><br><span class="line">    addl    %edx, %eax</span><br><span class="line">    movl    %eax, <span class="number">-4</span>(%rbp)</span><br><span class="line">    movl    $<span class="number">0</span>, %eax</span><br><span class="line">    popq    %rbp</span><br><span class="line">    .cfi_def_cfa <span class="number">7</span>, <span class="number">8</span></span><br><span class="line">    ret</span><br><span class="line">    .cfi_endproc</span><br><span class="line">.LFE0:</span><br><span class="line">    .size   main, .-main</span><br><span class="line">    .ident  <span class="string">"GCC: (Ubuntu 5.4.0-6ubuntu1~16.04.12) 5.4.0 20160609"</span></span><br><span class="line">    .section        .note.GNU-<span class="built_in">stack</span>,<span class="string">""</span>,@progbits</span><br></pre></td></tr></table></figure><p>其中代表定义变量和做加法的语句转换成汇编代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">movl    $<span class="number">6</span>, <span class="number">-12</span>(%rbp)       <span class="comment">// 把立即数6放到内存地址为-12(%rbp)的位置，也就是变量a中</span></span><br><span class="line">movl    $<span class="number">2</span>, <span class="number">-8</span>(%rbp)        <span class="comment">// 把立即数2放到内存地址为-8(%rbp)的位置，也就是变量b中</span></span><br><span class="line">movl    <span class="number">-12</span>(%rbp), %edx     <span class="comment">// 把内存地址为-12(%rbp)的位置（变量a）的数据放到寄存器%edx中</span></span><br><span class="line">movl    <span class="number">-8</span>(%rbp), %eax      <span class="comment">// 把内存地址为-8(%rbp)的位置（变量b）的数据放到寄存器%eax中</span></span><br><span class="line">addl    %edx, %eax          <span class="comment">// 把寄存器%edx中的数据加到寄存器%eax中</span></span><br><span class="line">movl    %eax, <span class="number">-4</span>(%rbp)      <span class="comment">// 把寄存器%eax中的计算所得结果数据放到内存地址为-4(%rbp)的位置，也就是变量c中</span></span><br></pre></td></tr></table></figure><h1 id="指针变量"><a href="#指针变量" class="headerlink" title="指针变量"></a>指针变量</h1><p>首先来看看通过指针来修改变量值的过程，测试代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">int</span>* p = &amp;a;</span><br><span class="line">*p = <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>转换成汇编代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">movl    $<span class="number">6</span>, <span class="number">-20</span>(%rbp)       <span class="comment">// 把立即数6放到内存地址为-20(%rbp)的位置，也就是变量a中</span></span><br><span class="line">leaq    <span class="number">-20</span>(%rbp), %rax     <span class="comment">// 把这个内存地址-20(%rbp)，也就是变量a的地址保存在寄存器%rax中</span></span><br><span class="line">movq    %rax, <span class="number">-16</span>(%rbp)     <span class="comment">// 把寄存器%rax中的保存的变量a的地址，放到内存地址为-16(%rbp)的位置，也就是变量p中</span></span><br><span class="line">movq    <span class="number">-16</span>(%rbp), %rax     <span class="comment">// 把内存地址为-16(%rbp)的位置（变量p）的数据放到寄存器%rax中</span></span><br><span class="line">movl    $<span class="number">2</span>, (%rax)          <span class="comment">// 把立即数2放在寄存器%rax中保存的地址位置中，也就是p所指向的地址，即变量a中</span></span><br></pre></td></tr></table></figure><p>通过汇编代码可以发现，通过指针修改变量的值实际上是在指针变量中保存变量的地址值，修改变量时是通过指针变量直接找到变量所在内存，然后直接修改完成的。</p><h1 id="左值引用"><a href="#左值引用" class="headerlink" title="左值引用"></a>左值引用</h1><p>接着来看下通过引用来修改变量值的过程，测试代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">int</span>&amp; r = a;</span><br><span class="line">r = <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>转换成汇编代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">movl    $<span class="number">6</span>, <span class="number">-20</span>(%rbp)</span><br><span class="line">leaq    <span class="number">-20</span>(%rbp), %rax</span><br><span class="line">movq    %rax, <span class="number">-16</span>(%rbp)</span><br><span class="line">movq    <span class="number">-16</span>(%rbp), %rax</span><br><span class="line">movl    $<span class="number">2</span>, (%rax)</span><br></pre></td></tr></table></figure><p>看到这里是不是有点意思了，这几行通过引用修改变量值的代码转换成汇编代码以后，居然和之前通过指针修改变量值的汇编代码一模一样。咦？仿佛发现了引用的本质呀！</p><h1 id="常量引用"><a href="#常量引用" class="headerlink" title="常量引用"></a>常量引用</h1><p>在传统C++中我们知道，引用变量不能引用一个右值，但是常引用可以办到这一点，测试代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>&amp; a = <span class="number">6</span>;</span><br></pre></td></tr></table></figure><p>转换成汇编代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">movl    $<span class="number">6</span>, %eax            <span class="comment">//把立即数放到寄存器%eax中</span></span><br><span class="line">movl    %eax, <span class="number">-20</span>(%rbp)     <span class="comment">//把寄存器%eax中的数字6放到内存地址为-20(%rbp)的位置，一个临时变量中</span></span><br><span class="line">leaq    <span class="number">-20</span>(%rbp), %rax     <span class="comment">//把临时变量的内存地址-20(%rbp)放到寄存器%rax中</span></span><br><span class="line">movq    %rax, <span class="number">-16</span>(%rbp)     <span class="comment">//把寄存器%rax中存储的临时变量的内存地址-20(%rbp)放到内存地址为-16(%rbp)的位置</span></span><br></pre></td></tr></table></figure><p>这段代码的翻译结果与前面指针变量的例子很像，首先有一个变量（匿名变量）来存储值，然后是一个新的内存地址来保存之前变量的地址。</p><h1 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h1><p>右值引用需要C++11才能使用，与常引用对比的优点就是可以修改右值，实际上我认为还是修改的左值！测试代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>&amp;&amp; a = <span class="number">6</span>;</span><br><span class="line">a = <span class="number">2</span></span><br></pre></td></tr></table></figure><p>转换成汇编代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">movl    $<span class="number">6</span>, %eax            <span class="comment">//把立即数放到寄存器%eax中</span></span><br><span class="line">movl    %eax, <span class="number">-20</span>(%rbp)     <span class="comment">//把寄存器%eax中的数字6放到内存地址为-20(%rbp)的位置，一个临时变量中</span></span><br><span class="line">leaq    <span class="number">-20</span>(%rbp), %rax     <span class="comment">//把临时变量的内存地址-20(%rbp)放到寄存器%rax中</span></span><br><span class="line">movq    %rax, <span class="number">-16</span>(%rbp)     <span class="comment">//把寄存器%rax中存储的临时变量的内存地址-20(%rbp)放到内存地址为-16(%rbp)的位置</span></span><br><span class="line">movq    <span class="number">-16</span>(%rbp), %rax     <span class="comment">// 把内存地址为-16(%rbp)的位置（变量p）的数据放到寄存器%rax中</span></span><br><span class="line">movl    $<span class="number">2</span>, (%rax)          <span class="comment">// 把立即数2放在寄存器%rax中保存的地址位置中，也就是p所指向的地址，即变量a中</span></span><br></pre></td></tr></table></figure><p>这段汇编代码与常量引用相比只缺少赋值的部分，与左值引用相比几乎一样，只有在最开始立即数6的处理上有一点点差异，是不是感觉很神奇？</p><h1 id="一点点惊奇"><a href="#一点点惊奇" class="headerlink" title="一点点惊奇"></a>一点点惊奇</h1><p>对比了前面这些代码的汇编指令后有没有什么想法？什么常量引用，什么右值引用，这些不过都是“愚弄”程序员的把戏，但这些概念的出现并不是为了给程序员们带来麻烦，相反它们的出现使得程序编写更加可控，通过编译器帮助“粗心”的开发者们先暴露了一波问题。</p><p>通过汇编代码来看，常量引用其实引用的并非常量，而是引用了一个变量；右值引用引用的也并非右值，同样是一个保存了右值的变量。这年头常量都能变，还有什么不能变的呢？</p><p>来看看下面这段代码，仔细想想常量真的变了吗？运行之后各个变量的值是多少呢？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> a = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">int</span> *p = <span class="keyword">const_cast</span>&lt;<span class="keyword">int</span>*&gt;(&amp;a);</span><br><span class="line">*p = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> b = *p;</span><br><span class="line"><span class="keyword">int</span> c = a;</span><br></pre></td></tr></table></figure><p>这段代码运行之后的打印结果：a=6, b=2, c=6，变量a作为一个常量没有被改变，貌似常量还是有点用的，哈哈~</p><p>这段代码转换成汇编代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">movl    $<span class="number">6</span>, <span class="number">-28</span>(%rbp)</span><br><span class="line">leaq    <span class="number">-28</span>(%rbp), %rax</span><br><span class="line">movq    %rax, <span class="number">-16</span>(%rbp)</span><br><span class="line">movq    <span class="number">-16</span>(%rbp), %rax</span><br><span class="line">movl    $<span class="number">2</span>, (%rax)</span><br><span class="line">movq    <span class="number">-16</span>(%rbp), %rax</span><br><span class="line">movl    (%rax), %eax</span><br><span class="line">movl    %eax, <span class="number">-24</span>(%rbp)</span><br><span class="line">movl    $<span class="number">6</span>, <span class="number">-20</span>(%rbp)</span><br></pre></td></tr></table></figure><p>通过汇编来看你会发现，其实变量a的值已经通过指针 <code>p</code> 修改过了，只不过后面引用a变量的地方，因为它是常量，直接使用立即数6替换了。</p><p>改写一下代码，将常量6换成一个变量：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> a = i;</span><br><span class="line"><span class="keyword">int</span> *p = <span class="keyword">const_cast</span>&lt;<span class="keyword">int</span>*&gt;(&amp;a);</span><br><span class="line">*p = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> b = *p;</span><br><span class="line"><span class="keyword">int</span> c = a;</span><br></pre></td></tr></table></figure><p>转换成汇编代码为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">movl    $<span class="number">3</span>, <span class="number">-28</span>(%rbp)</span><br><span class="line">movl    <span class="number">-28</span>(%rbp), %eax</span><br><span class="line">movl    %eax, <span class="number">-32</span>(%rbp)</span><br><span class="line">leaq    <span class="number">-32</span>(%rbp), %rax</span><br><span class="line">movq    %rax, <span class="number">-16</span>(%rbp)</span><br><span class="line">movq    <span class="number">-16</span>(%rbp), %rax</span><br><span class="line">movl    $<span class="number">2</span>, (%rax)</span><br><span class="line">movq    <span class="number">-16</span>(%rbp), %rax</span><br><span class="line">movl    (%rax), %eax</span><br><span class="line">movl    %eax, <span class="number">-24</span>(%rbp)</span><br><span class="line">movl    <span class="number">-32</span>(%rbp), %eax</span><br><span class="line">movl    %eax, <span class="number">-20</span>(%rbp)</span><br></pre></td></tr></table></figure><p>这段代码运行的结果为：i=3, a=2, b=2, c=2，看来常量也禁不住我们这么折腾啊</p><p>所以从这一点可以看出C++代码中无常量，只要是定义出的变量都可以修改，而常量只是给编译器优化提供一份指导，比如可以把一些字面量在编译期间替换，但是运行时的常量还是能改的。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>左值和右值更像是容器与数据的关系，不过C++11提出的将亡值的概念又模糊这两者的界限，将亡值可以看成是即将失去容器的数据</li><li>在Ubuntu16.04、GCC5.4.0的环境下，通过左值引用和指针修改一个变量值生成的汇编代码完全一致</li><li>C++11中右值引用与常量引用生成的汇编代码一致，与左值引用生成的代码只在初始化时有一点差异</li><li>常量并非不可修改，它只是一种“君子协定”，你要知道什么情况下可以改，什么情况下绝对不可以改</li><li><code>const_cast</code> 目的并不是让你去修改一个本身被定义为const的值，这样修改后果是可能是无法预期的，它存在的目的是调整一些指针、引用的权限，比如在函数传递参数的时候</li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/118257275" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>身上若无千斤担，谁拿生命赌明天~<br>世间唯一不变的就是变化</p><p>2021-7-5 00:36:29</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;对于左值和右值有一个不太严谨的定义——在赋值表达式 &lt;code&gt;=&lt;/code&gt; 左侧是的左值，而在 &lt;code&gt;=&lt;/code&gt; 右侧的是右值。通过不断学习和尝试，最近我发现一个新的说法更加贴切，那就是“左值是容器，右值是东西”。对于这个定义我们可以类比一下水杯和水，通过水杯可以操作水杯中的水，操作过程中的中间结果如果想要进一步操作，可以将其放入其他的水杯，如果没有水杯就无法找到曾经操作过的水了，也就无法继续操作了。&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; a = &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; b = &lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; c = a + b;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在这个例子中，变量 &lt;code&gt;a&lt;/code&gt;，&lt;code&gt;b&lt;/code&gt;, &lt;code&gt;c&lt;/code&gt; 都是水杯，而 &lt;code&gt;2&lt;/code&gt;、&lt;code&gt;6&lt;/code&gt;、&lt;code&gt;a + b&lt;/code&gt; 都是被用来操作的水，只有把这些“水”放到“水杯”中才能被找到，才可以进行下一步操作。&lt;/p&gt;
    
    </summary>
    
      <category term="C/C++" scheme="http://AlbertGithubHome.github.io/blog/categories/C-C/"/>
    
    
      <category term="C++" scheme="http://AlbertGithubHome.github.io/blog/tags/C/"/>
    
      <category term="C++11" scheme="http://AlbertGithubHome.github.io/blog/tags/C-11/"/>
    
      <category term="左值" scheme="http://AlbertGithubHome.github.io/blog/tags/%E5%B7%A6%E5%80%BC/"/>
    
      <category term="右值" scheme="http://AlbertGithubHome.github.io/blog/tags/%E5%8F%B3%E5%80%BC/"/>
    
      <category term="右值引用" scheme="http://AlbertGithubHome.github.io/blog/tags/%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>C++11中std::move和std::forward到底干了啥</title>
    <link href="http://AlbertGithubHome.github.io/blog/2021/07/04/C-11%E4%B8%ADstd-move%E5%92%8Cstd-forward%E5%88%B0%E5%BA%95%E5%B9%B2%E4%BA%86%E5%95%A5/"/>
    <id>http://AlbertGithubHome.github.io/blog/2021/07/04/C-11中std-move和std-forward到底干了啥/</id>
    <published>2021-07-03T16:28:50.000Z</published>
    <updated>2021-07-21T15:37:58.987Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>C++11中的右值引用的出现，在特定情况下减少了对象的拷贝，提升了C++程序的效率，伴随而来的 <code>std::move</code> 和 <code>std::forward</code> 也大量出现在程序代码中，但是这两个函数究竟干了啥呢？其实他们的本质都是转换函数，也就是完成左值和右值之间的转换，需要注意的是左值可以转换成右值，但是右值无法转换成左值。</p><a id="more"></a><p>关于左值、右值、左值引用和右值引用的概念可以看看之前的总结：</p><ul><li><a href="https://blog.csdn.net/albertsh/article/details/105756674" target="_blank" rel="noopener">简单聊聊C/C++中的左值和右值</a></li><li><a href="https://blog.csdn.net/albertsh/article/details/105941232" target="_blank" rel="noopener">C++11在左值引用的基础上增加右值引用</a></li></ul><p>虽然温故不一定知新，但绝对可以增强记忆，本章的内容说起来很绕，我也是边学边总结，有不对的地方还请大佬们指出来。</p><h1 id="左值引用和右值引用"><a href="#左值引用和右值引用" class="headerlink" title="左值引用和右值引用"></a>左值引用和右值引用</h1><p>了解过基础的引用知识之后我们都知道左值引用的形式为 <code>T&amp; t</code>，一般会像成下面这样使用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(A&amp; obj)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">A obj;</span><br><span class="line">test(obj);</span><br></pre></td></tr></table></figure><p>而右值引用是在左值引用的基础上多加一个<code>&amp;</code>，形式变为 <code>T&amp;&amp; t</code>，使用方式如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(A&amp;&amp; obj)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test(A());</span><br></pre></td></tr></table></figure><p>这种通过 <code>&amp;</code> 的个数区分左值引用和右值引用的方法，在大多数的普通函数中没有问题，但是放到模板参数或者 <code>auto</code> 关键字之后的位置就不太灵了，因为这些地方会推导实际的类型，正是有了参数推导，才使得模板中出现了“万能引用”的说法，也就是下面这样：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(T&amp;&amp; val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; val &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> year = <span class="number">2020</span>;</span><br><span class="line">    func(year);</span><br><span class="line">    func(<span class="number">2020</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数 <code>func</code> 即能接受变量 <code>year</code> 这样的左值作为参数，也能接受 <code>2020</code> 这样的常数作为右值，简直太完美。那么这里是怎样推导的呢？这就要请出一个引用的“折叠”规则了，描述如下：</p><blockquote><p>A&amp; &amp; 折叠成 A&amp;<br>  A&amp; &amp;&amp; 折叠成 A&amp;<br>  A&amp;&amp; &amp; 折叠成 A&amp;<br>  A&amp;&amp; &amp;&amp; 折叠成 A&amp;&amp;</p></blockquote><p>根据这个规则，<code>func</code> 函数在接受 <code>year</code> 作为参数时应该是一个左值引用，那么模板参数 <code>T</code> 会被推到为 <code>A&amp;</code> 与后面的 <code>&amp;&amp;</code> 折叠为 <code>A&amp;</code>，接受 <code>year</code> 没问题。而这个函数在接受 <code>2020</code> 作为参数时应该是一个右值引用，那么模板参数 <code>T</code> 会被推导成 <code>A</code>，与后面的 <code>&amp;&amp;</code> 形成 <code>A&amp;&amp;</code>，可以接受右值，知道了这些基础知识我们接着往后看。</p><h1 id="std-move"><a href="#std-move" class="headerlink" title="std::move"></a>std::move</h1><p>这个函数听起来好像是一个小人移动时调用的函数，但它却是一个把左值转化成右值的转化函数，我们看一下 <code>std::move</code> 函数的实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  @brief  Convert a value to an rvalue.</span></span><br><span class="line"><span class="comment"> *  @param  __t  A thing of arbitrary type.</span></span><br><span class="line"><span class="comment"> *  @return The parameter cast to an rvalue-reference to allow moving it.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line">  <span class="keyword">constexpr</span> <span class="keyword">typename</span> <span class="built_in">std</span>::remove_reference&lt;_Tp&gt;::type&amp;&amp;</span><br><span class="line">  move(_Tp&amp;&amp; <span class="keyword">__t</span>) <span class="keyword">noexcept</span></span><br><span class="line">  &#123; <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">typename</span> <span class="built_in">std</span>::remove_reference&lt;_Tp&gt;::type&amp;&amp;&gt;(<span class="keyword">__t</span>); &#125;</span><br></pre></td></tr></table></figure><p>这是一个模板函数，一共才4行，好像最麻烦的就是这个 <code>std::remove_reference&lt;_Tp&gt;::type&amp;&amp;</code> 了，先来看看它是什么，其实它的作用就是，<strong>移除类型的引用，返回原始类型。</strong></p><h2 id="std-remove-reference"><a href="#std-remove-reference" class="headerlink" title="std::remove_reference"></a>std::remove_reference</h2><p>它的可能实现如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">remove_reference</span> &#123;</span></span><br><span class="line">    <span class="keyword">using</span> type = T;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="comment">// 模板特化</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">remove_reference</span>&lt;T&amp;&gt; &#123;</span></span><br><span class="line">    <span class="keyword">using</span> type = T;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="comment">// 模板特化</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">remove_reference</span>&lt;T&amp;&amp;&gt; &#123;</span></span><br><span class="line">    <span class="keyword">using</span> type = T;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>它的作用可以参考 <a href="https://en.cppreference.com/w/cpp/types/remove_reference" target="_blank" rel="noopener">cppreference.com - remove_reference</a>，示例如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt; // std::cout</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;type_traits&gt; // std::is_same</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="title">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">print_is_same</span>() &#123;</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::is_same&lt;T1, T2&gt;() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::boolalpha;</span><br><span class="line"></span><br><span class="line">  print_is_same&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;();</span><br><span class="line">  print_is_same&lt;<span class="keyword">int</span>, <span class="keyword">int</span> &amp;&gt;();</span><br><span class="line">  print_is_same&lt;<span class="keyword">int</span>, <span class="keyword">int</span> &amp;&amp;&gt;();</span><br><span class="line"></span><br><span class="line">  print_is_same&lt;<span class="keyword">int</span>, <span class="built_in">std</span>::remove_reference&lt;<span class="keyword">int</span>&gt;::type&gt;();</span><br><span class="line">  print_is_same&lt;<span class="keyword">int</span>, <span class="built_in">std</span>::remove_reference&lt;<span class="keyword">int</span> &amp;&gt;::type&gt;();</span><br><span class="line">  print_is_same&lt;<span class="keyword">int</span>, <span class="built_in">std</span>::remove_reference&lt;<span class="keyword">int</span> &amp;&amp;&gt;::type&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">true</span><br><span class="line">false</span><br><span class="line">false</span><br><span class="line">true</span><br><span class="line">true</span><br><span class="line">true</span><br></pre></td></tr></table></figure><p>从这个例子可以清晰的看出 <code>std::remove_reference</code> 就是返回去掉引用的原始类型。</p><h2 id="static-cast"><a href="#static-cast" class="headerlink" title="static_cast"></a>static_cast</h2><p>明白了上面 <code>std::remove_reference</code> 的作用，整个 <code>std::move</code> 函数就剩下一个 <code>static_cast</code> 函数了，其实到这里也就清晰了，<code>std::move</code> 函数的作用就先通过 <code>std::remove_reference</code> 函数得到传入参数的原始类型 <code>X</code>，然后再把参数强转成 <code>X&amp;&amp;</code> 返回即可，参数的 <code>_Tp</code> 的推导参考引用折叠规则。</p><h2 id="std-move-到底干了啥"><a href="#std-move-到底干了啥" class="headerlink" title="std::move 到底干了啥"></a>std::move 到底干了啥</h2><p>通过前面的一通分析我们发现，<code>std::move</code> 的内部只做了一个强制类型转换，除此之外啥也没干，其实就是对传入的参数重新解释了一下，并没有实质性的动作。</p><p>那么为什么要使用 <code>std::move</code> 这个名字呢？这个名字更多的是起到提醒的作用，告诉使用者这里可能进行了到右值的转化，相关的对象后续可能发生移动，“被掏空”了，如果你继续使用这个对象，行为是未定义的，后果自负。</p><h1 id="std-forward"><a href="#std-forward" class="headerlink" title="std::forward"></a>std::forward</h1><p><code>std::forward</code> 被称为完美转发，听起来和 “万能引用”一样厉害，使用的头文件为 <code>&lt;utility&gt;</code>，在 <code>/usr/include/c++/5/bits/move.h</code> 文件中的定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  @brief  Forward an lvalue.</span></span><br><span class="line"><span class="comment"> *  @return The parameter cast to the specified type.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  This function is used to implement "perfect forwarding".</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line">  <span class="keyword">constexpr</span> _Tp&amp;&amp;</span><br><span class="line">  forward(<span class="keyword">typename</span> <span class="built_in">std</span>::remove_reference&lt;_Tp&gt;::type&amp; <span class="keyword">__t</span>) <span class="keyword">noexcept</span></span><br><span class="line">  &#123; <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;_Tp&amp;&amp;&gt;(<span class="keyword">__t</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  @brief  Forward an rvalue.</span></span><br><span class="line"><span class="comment"> *  @return The parameter cast to the specified type.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  This function is used to implement "perfect forwarding".</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line">  <span class="keyword">constexpr</span> _Tp&amp;&amp;</span><br><span class="line">  forward(<span class="keyword">typename</span> <span class="built_in">std</span>::remove_reference&lt;_Tp&gt;::type&amp;&amp; <span class="keyword">__t</span>) <span class="keyword">noexcept</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">static_assert</span>(!<span class="built_in">std</span>::is_lvalue_reference&lt;_Tp&gt;::value, <span class="string">"template argument"</span></span><br><span class="line">          <span class="string">" substituting _Tp is an lvalue reference type"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;_Tp&amp;&amp;&gt;(<span class="keyword">__t</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><code>std::forward</code> 用于函数模板中完成参数转发任务，我们必须在相应实参为左值，该形参成为左值引用时把它转发成左值，在相应实参为右值，该形参成为右值引用时把它转发成右值。</p><p>有了前面的铺垫我们直接来分析代码吧，第一个版本接受参数苏为左值引用的情况，因为 <code>std::remove_reference&lt;_Tp&gt;::type</code> 是 <code>_Tp</code> 的原始类型，所以 <code>t</code> 就是左值引用类型，调用这个函数时，<code>_Tp</code> 为 <code>X&amp;</code> 类型，经过引用这的 <code>_Tp&amp;&amp; =&gt; X&amp; &amp;&amp; =&gt; X&amp;</code>，所以返回值也是左值引用。</p><p>同理，第二个版本接受右值引用参数，返回值也是一个右值引用。</p><p>从目前的情况来看，<code>std::forward</code> 好像什么也没做，只是将参数强转以后返回，如果不使用这个函数会有什么问题呢？</p><h2 id="必要性"><a href="#必要性" class="headerlink" title="必要性"></a>必要性</h2><p>为什么要使用 <code>std::forward</code> 我们可以通过一个例子来看一下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">(<span class="keyword">int</span>&amp; val)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"lvalue refrence: val="</span> &lt;&lt; val &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">(<span class="keyword">int</span>&amp;&amp; val)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"rvalue refrence: val="</span> &lt;&lt; val &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TPrint</span><span class="params">(T &amp;&amp;t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Print(t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> date = <span class="number">1021</span>;</span><br><span class="line">    TPrint(date);</span><br><span class="line">    TPrint(<span class="number">501</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到这个例子可以先思考一下，运行结果会是什么呢？可能和你想的有点不一样哦，看看下面的答案：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lvalue refrence: val=1021</span><br><span class="line">lvalue refrence: val=501</span><br></pre></td></tr></table></figure><p>有点出乎意料啊，为什么 <code>Print(int&amp;&amp; val)</code> 这个函数没有被调用呢？原因在于“右值引用是一个左值”，很懵对不对，接着往下看：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">101</span>;</span><br><span class="line"><span class="keyword">int</span>&amp; li = i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>&amp;&amp; ri = <span class="number">120</span>;</span><br></pre></td></tr></table></figure><p>这段代码中哪些是左值，哪些是右值呢？可以肯定的是 <code>i</code>、<code>li</code> 是左值， <code>101</code>、<code>120</code> 是右值，而<code>ri</code>也是左值，因为它也一个可以取地址并长期有效的变量啊，只不过这个左值引用了一个右值而已。</p><p>接着回到刚才的例子，<code>TPrint(501);</code> 调用模板函数时，T被推导为 <code>int</code>，所以模板被实例化为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TPrint</span><span class="params">(<span class="keyword">int</span>&amp;&amp; t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Print(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行到这里，<code>t</code> 实际上是一个左值，所以调用了 <code>void Print(int&amp; val)</code> 这个函数，那么怎样才能调用 <code>void Print(int&amp;&amp; val)</code> 这个版本呢？是时候请出 <code>std::forward</code> 函数了，将模板函数进行如下修改：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TPrint</span><span class="params">(T&amp;&amp; t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Print(<span class="built_in">std</span>::forward&lt;T&gt;(t));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改之后再来分析一下，<code>TPrint(501);</code> 调用模板函数时，T被推导为 <code>int</code>，所以模板被实例化为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TPrint</span><span class="params">(<span class="keyword">int</span>&amp;&amp; t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Print(<span class="built_in">std</span>::forward&lt;<span class="keyword">int</span>&gt;(t));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里会调用 <code>std::forward</code> 的这个版本：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line">  <span class="keyword">constexpr</span> _Tp&amp;&amp;</span><br><span class="line">  forward(<span class="keyword">typename</span> <span class="built_in">std</span>::remove_reference&lt;_Tp&gt;::type&amp;&amp; <span class="keyword">__t</span>) <span class="keyword">noexcept</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">static_assert</span>(!<span class="built_in">std</span>::is_lvalue_reference&lt;_Tp&gt;::value, <span class="string">"template argument"</span></span><br><span class="line">          <span class="string">" substituting _Tp is an lvalue reference type"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;_Tp&amp;&amp;&gt;(<span class="keyword">__t</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>函数的返回类型为 <code>int&amp;&amp;</code>，然后就调用了 <code>void Print(int&amp;&amp; val)</code> 这个版本的打印函数。</p><h2 id="疑惑"><a href="#疑惑" class="headerlink" title="疑惑"></a>疑惑</h2><p>可能有人会说，这不对啊，使用 <code>std::forward</code> 修改之前函数参数就是 <code>int&amp;&amp;</code> 类型，修改之后得到的返回值还是 <code>int&amp;&amp;</code> 类型，这有什么区别吗？</p><p>这里的区别就在于，使用 <code>std::forward</code> 之前的 <code>int&amp;&amp;</code> 是有名字的变量 <code>t</code>，它是一个左值，而使用 <code>std::forward</code> 之后的 <code>int&amp;&amp;</code> 是有个匿名变量，它是一个右值，真正的差距就在这里。</p><h2 id="std-forward-到底干了啥"><a href="#std-forward-到底干了啥" class="headerlink" title="std::forward 到底干了啥"></a>std::forward 到底干了啥</h2><p>它和 <code>std::move</code> 一样，<code>std::forward</code> 也是做了一个强制类型转换，当形参成为左值引用时把它转换成左值引用返回，当形参成为右值引用时把它转换成右值引用返回。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li><code>std::move</code> 并没有实际的“移动”操作，只是在内部进行了强制类型转换，返回一个相关类型的右值引用</li><li><code>std::move</code> 的名字主要标识它后续可能会被其他人“掏空”，调用它之后如果继续使用，行为未定义，后果自负</li><li><code>std::forward</code> 的本质也是进行强制类型转换，形参为左值时返回左值引用，形参为右值时返回右值引用</li><li>从定义入手可以理解很多花里胡哨的东西，透过现象看其本质。</li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/118663176" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>日拱一卒无有尽，功不唐捐终入海~</p><p>我们追求的样子：十分沉静，九分气质，八分资产，七分现实，三分颜值，二分糊涂，一份自知之明。</p><p>2021-7-18 21:23:01</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;C++11中的右值引用的出现，在特定情况下减少了对象的拷贝，提升了C++程序的效率，伴随而来的 &lt;code&gt;std::move&lt;/code&gt; 和 &lt;code&gt;std::forward&lt;/code&gt; 也大量出现在程序代码中，但是这两个函数究竟干了啥呢？其实他们的本质都是转换函数，也就是完成左值和右值之间的转换，需要注意的是左值可以转换成右值，但是右值无法转换成左值。&lt;/p&gt;
    
    </summary>
    
      <category term="C/C++" scheme="http://AlbertGithubHome.github.io/blog/categories/C-C/"/>
    
    
      <category term="C++" scheme="http://AlbertGithubHome.github.io/blog/tags/C/"/>
    
      <category term="C++11" scheme="http://AlbertGithubHome.github.io/blog/tags/C-11/"/>
    
      <category term="move" scheme="http://AlbertGithubHome.github.io/blog/tags/move/"/>
    
      <category term="forward" scheme="http://AlbertGithubHome.github.io/blog/tags/forward/"/>
    
      <category term="完美转发" scheme="http://AlbertGithubHome.github.io/blog/tags/%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>手把手搭建一个redis集群</title>
    <link href="http://AlbertGithubHome.github.io/blog/2021/06/26/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AAredis%E9%9B%86%E7%BE%A4/"/>
    <id>http://AlbertGithubHome.github.io/blog/2021/06/26/手把手搭建一个redis集群/</id>
    <published>2021-06-26T02:42:50.000Z</published>
    <updated>2021-06-26T16:43:52.076Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>所谓“难者不会，会者不难”，这不只是一句简简单单的俗语，而是历经人类进化史而得到的历史经验，只有亲身体会过才会越发了解这句话的意义。当你苦思冥想几天几夜难以解决的问题，一句过来人的点拨便可瞬间化解，这是人生路上的需要经历的，愿每个人在关键时刻都能得到善良人的点拨。</p><p>人生有四个境界：①不知道自己不知道；②知道自己不知道；③不知道自己知道，④知道自己知道。不同的境界对应着不同的人生，仔细想想这四种境界并没有哪一种是绝对的好与坏，具体怎么选择取决于你想要什么样的人生，想想坐井观天的那只青蛙，属于“不知道自己不知道”的典型，如果它每天逍遥快活，完全没必要非得跳出井来卷入井外的纷争。</p><p>长久以来自给自足的小农经济，如果没有战乱，没有暴政，没有入侵，耕田织布的生活不也挺好，但是人性是贪婪的，欲望促使人们侵略、扩张，使得一些人进入了“知道自己不知道”的境界，于是加速了人与人之间的交流。进入现代社会以后，信息爆炸，越来越多的人“觉醒”了，但只是“觉醒”而不付出努力就会使自己陷入焦虑，其实焦虑不可怕，重要的是你要采取什么措施来缓解焦虑。</p><p>题外话扯多了，回归正题，写这篇总结的主要还是一个学习记录，也希望这样的记录可以解决一些人的困惑，这些东西并不复杂，也许只是我这个初学者才会关心的问题，但是现在有一种现象，就是大佬们不愿写基础的东西，而小白们想成为大佬从基础学习，却发现路上的坑让他们头破血流。一句学神们口中的“不难证明”，可能你几个月都证明不出来，这个问题是双方面的，一方面小白认为这东西很难，不知道怎么入手，另一方面大神感觉这东西这么简单还需要学？</p><p>屠龙勇士中成恶龙，大神们经过时间的洗礼，很多人已经忘记了自己曾经的头破血流，忘记了自己怎么从小白一步步走来，所以遇到困惑的人不要先入为主，不要认为这个东西太简单了怎么可能有人不会？耐心聆听给出建议，或许可以瞬间打通他的任督二脉。</p><p>好了，好了，又跑题了，拉回来，我们从头来搭建一个redis集群，不过搭建之前我们先来看看“安装”这个词。</p><h1 id="安装的含义"><a href="#安装的含义" class="headerlink" title="安装的含义"></a>安装的含义</h1><p>安装软件、安装程序、安装APP，自从电子设备飞入寻常百姓家，我们每天都在安装、安装、安装。但是这个词并不是电子设备出现后才诞生的。这个词自古就有，安装——本意是：把机件、器材等固定在一定的位置。那么软件、APP的安装就是把它们放在一定的位置。</p><p>软件是什么？至今我都记得初中的一道计算机的题目，我是04年在学校机房第一次接触到真的计算机，当时有一道题是问：Windows是系统软件，还是应用软件？当时这种题目真的是死记硬背啊，脑子里完全没有概念，每周只有一节课，还不一定每个人都有机器，那时的软件对我来说就是一个迷。</p><p>现在接触计算机也这么多年了，对软件也有了一些认识。软件可以说是用来向发出计算机发出任务的东西，当我们对一个人发号任务指令时，能通过声音传递给人，然后接到指令的人可以完成相应的任务，当我们给计算机发送指令时，可以通过键盘、鼠标等把指令输进去，也可以运行软件来完成某些计算机任务，其实软件就是一些提前编好的任务指令的集合。</p><p>那么安装软件就是把软件放到对应的地方，为什么要安装？为什么要放到指定的地方？随便放有什么问题？其实还是为了方便。就像生活中我们把床安装在卧室，把马桶安装在厕所一样，大家都是这样，已经成了习惯。如果你把床安装在厕所，并不是不能用来睡觉，只是其他人在来到厕所睡觉这件事上有些不太习惯。</p><p>因为软件并不只是一个东西，他还有数据啊、配置啊、服务啊等等，所以这些东西都要放在相应的位置，并且做一个登记，就像你把床放到厕所一样，这种不一样的习惯更要登记下来，否则对于一个普通人来说，肯定会去卧室找床，而不是厕所。</p><p>windows中软件的傻瓜式安装降低了软件的安装难度，它有一个注册表，里面记录了很多奇奇怪怪的东西，在windows上安装软件也就是把软件的各部分发到对应的位置，然后通过注册表这个总管登记入册，但是有些软件不太友好，安装的时候一顿乱放，卸载的时候不自己清理干净，导致出现很多问题，比如当年的SQLServer和3DMax，当时为了再次安装不得不重做了好多次系统。</p><p>在linux中安装软件就没有注册表这个东西，只要把软件各部分按照类型分别放好就行，比如可执行程序放<code>/usr/bin/</code>，库文件放<code>/usr/lib</code>，配置文件放 <code>/etc/</code>等等，卸载就是把这些新加的东西删除就可以了，相比windows的注册表要简单一些。</p><p>好了，接下来我们就来安装配置一下redis-cluster，看了一下，本地机器真的很干净，什么都没有，现在从安装redis开始吧。</p><h1 id="安装redis"><a href="#安装redis" class="headerlink" title="安装redis"></a>安装redis</h1><ol><li>系统是ubuntu16.04，偷个懒，直接通过命令 <code>sudo apt-get install redis-server</code> 安装吧，当然你也可以通过源码编译安装，这都是可以的，输出信息如下：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:/usr/src$$ sudo apt-get install redis-server</span><br><span class="line">Reading package lists... Done</span><br><span class="line">Building dependency tree</span><br><span class="line">Reading state information... Done</span><br><span class="line">The following additional packages will be installed:</span><br><span class="line">  libjemalloc1 redis-tools</span><br><span class="line">Suggested packages:</span><br><span class="line">  ruby-redis</span><br><span class="line">The following NEW packages will be installed:</span><br><span class="line">  libjemalloc1 redis-server redis-tools</span><br><span class="line">0 upgraded, 3 newly installed, 0 to remove and 125 not upgraded.</span><br><span class="line">Need to get 519 kB of archives.</span><br><span class="line">After this operation, 1,507 kB of additional disk space will be used.</span><br><span class="line">Do you want to <span class="built_in">continue</span>? [Y/n] Y</span><br><span class="line">Get:1 http://mirrors.tuna.tsinghua.edu.cn/ubuntu xenial/universe amd64 libjemalloc1 amd64 3.6.0-9ubuntu1 [78.9 kB]</span><br><span class="line">Get:2 http://mirrors.tuna.tsinghua.edu.cn/ubuntu xenial-updates/universe amd64 redis-tools amd64 2:3.0.6-1ubuntu0.4 [95.5 kB]</span><br><span class="line">Get:3 http://mirrors.tuna.tsinghua.edu.cn/ubuntu xenial-updates/universe amd64 redis-server amd64 2:3.0.6-1ubuntu0.4 [344 kB]</span><br><span class="line">Fetched 519 kB <span class="keyword">in</span> 13s (38.0 kB/s)</span><br><span class="line">Selecting previously unselected package libjemalloc1.</span><br><span class="line">(Reading database ... 33895 files and directories currently installed.)</span><br><span class="line">Preparing to unpack .../libjemalloc1_3.6.0-9ubuntu1_amd64.deb ...</span><br><span class="line">Unpacking libjemalloc1 (3.6.0-9ubuntu1) ...</span><br><span class="line">Selecting previously unselected package redis-tools.</span><br><span class="line">Preparing to unpack .../redis-tools_2%3a3.0.6-1ubuntu0.4_amd64.deb ...</span><br><span class="line">Unpacking redis-tools (2:3.0.6-1ubuntu0.4) ...</span><br><span class="line">Selecting previously unselected package redis-server.</span><br><span class="line">Preparing to unpack .../redis-server_2%3a3.0.6-1ubuntu0.4_amd64.deb ...</span><br><span class="line">Unpacking redis-server (2:3.0.6-1ubuntu0.4) ...</span><br><span class="line">Processing triggers <span class="keyword">for</span> libc-bin (2.23-0ubuntu11) ...</span><br><span class="line">Processing triggers <span class="keyword">for</span> man-db (2.7.5-1) ...</span><br><span class="line">Processing triggers <span class="keyword">for</span> ureadahead (0.100.0-19.1) ...</span><br><span class="line">Processing triggers <span class="keyword">for</span> systemd (229-4ubuntu21.27) ...</span><br><span class="line">Setting up libjemalloc1 (3.6.0-9ubuntu1) ...</span><br><span class="line">Setting up redis-tools (2:3.0.6-1ubuntu0.4) ...</span><br><span class="line">Setting up redis-server (2:3.0.6-1ubuntu0.4) ...</span><br><span class="line">invoke-rc.d: could not determine current runlevel</span><br><span class="line">Processing triggers <span class="keyword">for</span> libc-bin (2.23-0ubuntu11) ...</span><br><span class="line">Processing triggers <span class="keyword">for</span> ureadahead (0.100.0-19.1) ...</span><br><span class="line">Processing triggers <span class="keyword">for</span> systemd (229-4ubuntu21.27) ...</span><br><span class="line">albert@home-pc:/usr/src$</span><br></pre></td></tr></table></figure><ol><li>安装完查找一下命令安装的位置，redis服务器和客户端应该都在 <code>/usr/bin/</code></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:/usr/src$ <span class="built_in">which</span> redis-server</span><br><span class="line">/usr/bin/redis-server</span><br><span class="line">albert@home-pc:/usr/src$ <span class="built_in">which</span> redis-cli</span><br><span class="line">/usr/bin/redis-cli</span><br></pre></td></tr></table></figure><ol><li>修改配置文件，设置密码，通过 <code>sudo vim /etc/redis/redis.conf</code> 命令打开文件搜索 requirepass 找到下面这一行，把前面的#去掉，requirepass 后面的就是密码，可以自己修改。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># Warning: since Redis is pretty fast an outside user can try up to</span><br><span class="line"># 150k passwords per second against a good box. This means that you should</span><br><span class="line"># use a very strong password otherwise it will be very easy to break.</span><br><span class="line">#</span><br><span class="line"># requirepass foobared  #把这一行前面的&apos;#&apos;去掉就行，密码我就不改了</span><br><span class="line"></span><br><span class="line"># Command renaming.</span><br></pre></td></tr></table></figure><ol><li>启动redis，直接运行 <code>sudo redis-server /etc/redis/redis.conf</code>，redis服务器就起来了</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:/mnt/c/Users/Albert$ sudo redis-server /etc/redis/redis.conf</span><br><span class="line">albert@home-pc:/mnt/c/Users/Albert$ ps -ef | grep redis</span><br><span class="line">root       663     1  0 13:52 ?        00:00:00 redis-server 127.0.0.1:6379</span><br></pre></td></tr></table></figure><ol><li>启动客户端使用redis，连接默认的6379端口，密码<code>foobared</code></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:/mnt/c/Users/Albert$ redis-cli -a foobared -p 6379</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> name redis-test</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get name</span><br><span class="line"><span class="string">"redis-test"</span></span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> age 18</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get age</span><br><span class="line"><span class="string">"18"</span></span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure><ol><li>至此redis就可以使用了，测试了<code>set</code>和<code>get</code>两个命令如上</li></ol><h1 id="redis编译安装"><a href="#redis编译安装" class="headerlink" title="redis编译安装"></a>redis编译安装</h1><p>忽然发现Ubuntu16.04自带的 <code>redis3.0.6</code> 版本太低了，无法自动配置集群，所以决定编译安装，如果自动安装完redis版本在5以上，那就不需要编译安装了。</p><ol><li>新建<code>/usr/local/redis/</code>目录并进入，然后下载redis源码<a href="https://download.redis.io/releases/redis-6.2.4.tar.gz" target="_blank" rel="noopener">redis-6.2.4.tar.gz</a></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:/usr/<span class="built_in">local</span>$ mkdir redis</span><br><span class="line">albert@home-pc:/usr/<span class="built_in">local</span>$ sudo mkdir redis</span><br><span class="line">albert@home-pc:/usr/<span class="built_in">local</span>$ <span class="built_in">cd</span> redis/</span><br><span class="line">albert@home-pc:/usr/<span class="built_in">local</span>/redis$ sudo wget https://download.redis.io/releases/redis-6.2.4.tar.gz</span><br><span class="line">--2021-06-26 14:10:42--  https://download.redis.io/releases/redis-6.2.4.tar.gz</span><br><span class="line">Resolving download.redis.io (download.redis.io)... 45.60.125.1</span><br><span class="line">Connecting to download.redis.io (download.redis.io)|45.60.125.1|:443... connected.</span><br><span class="line">HTTP request sent, awaiting response... 200 OK</span><br><span class="line">Length: 2457940 (2.3M) [application/octet-stream]</span><br><span class="line">Saving to: ‘redis-6.2.4.tar.gz’</span><br><span class="line"></span><br><span class="line">redis-6.2.4.tar.gz               100%[========================================&gt;]   2.34M  45.4KB/s    <span class="keyword">in</span> 54s</span><br><span class="line"></span><br><span class="line">2021-06-26 14:11:37 (44.3 KB/s) - ‘redis-6.2.4.tar.gz’ saved [2457940/2457940]</span><br><span class="line"></span><br><span class="line">albert@home-pc:/usr/<span class="built_in">local</span>/redis$</span><br></pre></td></tr></table></figure><ol><li><p>运行 <code>sudo tar -zxvf redis-6.2.4.tar.gz</code> 命令解压文件</p></li><li><p>运行 <code>cd redis-6.2.4</code> 进入 redis-6.2.4 目录</p></li><li><p>直接运行 <code>sudo make &amp;&amp; make install</code> 即可，如果遇到了 ‘/bin/sh: 1: pkg-config: not found’ 错误，先通过 <code>sudo apt-get install pkg-config</code> 安装 <code>pkg-config</code>，再运行 <code>make</code> 即可。</p></li><li><p>这次 <code>redis-server</code> 和 <code>redis-cli</code> 都被安装到了 <code>/usr/local/bin/</code> 目录，版本是 <code>6.2.4</code>，接下来我们就用这个版本来搭建redis集群</p></li></ol><h1 id="redis集群"><a href="#redis集群" class="headerlink" title="redis集群"></a>redis集群</h1><p>为什么要用redis集群？很直接的原因就是一个redis不够用了，需要使用好几个来组合分摊数据量和压力，那么搭建redis集群其实就是启动多个redis程序实例，让他们配合工作就好了，他们之间的配合是redis本身实现的，我们只需要配置启动多个实例就行了，因为redis集群最少需要三主三从，所以我们启动6个实例，：</p><ol><li>新建 <code>/usr/local/redis-cluster</code> 目录并进入</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:/usr/<span class="built_in">local</span>$ sudo mkdir redis-cluster</span><br><span class="line">albert@home-pc:/usr/<span class="built_in">local</span>$ <span class="built_in">cd</span> redis-cluster/</span><br></pre></td></tr></table></figure><ol><li>为了彼此的配置、数据、日志不相互影响，6个实例需要分别配置，我们建立如下的目录结构，按照端口号配置6个配置文件</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── conf</span><br><span class="line">│   ├── redis-6301.conf</span><br><span class="line">│   ├── redis-6302.conf</span><br><span class="line">│   ├── redis-6303.conf</span><br><span class="line">│   ├── redis-6304.conf</span><br><span class="line">│   ├── redis-6305.conf</span><br><span class="line">│   └── redis-6306.conf</span><br><span class="line">├── data</span><br><span class="line">│   ├── redis-6301</span><br><span class="line">│   ├── redis-6302</span><br><span class="line">│   ├── redis-6303</span><br><span class="line">│   ├── redis-6304</span><br><span class="line">│   ├── redis-6305</span><br><span class="line">│   └── redis-6306</span><br><span class="line">└── <span class="built_in">log</span></span><br></pre></td></tr></table></figure><ol><li>修改redis配置文件，需要修改的配置文件中的内容如下，首先把下面几项前面的#去掉，然后按照端口号命名相互影响的目录和文件名，以第一个实例端口6301为例：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pidfile /var/run/redis/redis-server.pid</span><br><span class="line">port 6379</span><br><span class="line">logfile /var/log/redis/redis-server.log</span><br><span class="line">dir /var/ilib/redis</span><br><span class="line">dbfilename dump.rdb</span><br><span class="line"></span><br><span class="line">#requirepass foobared</span><br><span class="line">#cluster-enabled yes</span><br><span class="line">#cluster-config-file nodes-6379.conf</span><br><span class="line">#cluster-node-timeout 15000</span><br></pre></td></tr></table></figure><p>文件 <code>redis-6301.conf</code> 修改后的文件内容如下，接下来5个配置文件分别按照6302, 6303, 6304, 6305, 6306来配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pidfile /var/run/redis/redis-6301-server.pid</span><br><span class="line">port 6301</span><br><span class="line">logfile /usr/local/redis-cluster/log/redis-6301-server.log</span><br><span class="line">dir /usr/local/redis-cluster/data/redis-6301</span><br><span class="line">dbfilename dump-6301.rdb</span><br><span class="line"></span><br><span class="line">requirepass foobared</span><br><span class="line">cluster-enabled yes</span><br><span class="line">cluster-config-file nodes-6301.conf</span><br><span class="line">cluster-node-timeout 15000</span><br></pre></td></tr></table></figure><ol><li>进入 <code>/usr/local/redis-cluster</code> 目录并启动实例：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:/usr/<span class="built_in">local</span>/redis-cluster$ sudo /usr/<span class="built_in">local</span>/bin/redis-server conf/redis-6301.conf</span><br><span class="line">albert@home-pc:/usr/<span class="built_in">local</span>/redis-cluster$ sudo /usr/<span class="built_in">local</span>/bin/redis-server conf/redis-6302.conf</span><br><span class="line">albert@home-pc:/usr/<span class="built_in">local</span>/redis-cluster$ sudo /usr/<span class="built_in">local</span>/bin/redis-server conf/redis-6303.conf</span><br><span class="line">albert@home-pc:/usr/<span class="built_in">local</span>/redis-cluster$ sudo /usr/<span class="built_in">local</span>/bin/redis-server conf/redis-6304.conf</span><br><span class="line">albert@home-pc:/usr/<span class="built_in">local</span>/redis-cluster$ sudo /usr/<span class="built_in">local</span>/bin/redis-server conf/redis-6305.conf</span><br><span class="line">albert@home-pc:/usr/<span class="built_in">local</span>/redis-cluster$ sudo /usr/<span class="built_in">local</span>/bin/redis-server conf/redis-6306.conf</span><br><span class="line">albert@home-pc:/usr/<span class="built_in">local</span>/redis-cluster$ ps -ef | grep redis</span><br><span class="line">root       663     1  0 13:52 ?        00:00:00 redis-server 127.0.0.1:6379</span><br><span class="line">root      5928     1  0 14:57 ?        00:00:00 /usr/<span class="built_in">local</span>/bin/redis-server 127.0.0.1:6301 [cluster]</span><br><span class="line">root      5935     1  0 14:57 ?        00:00:00 /usr/<span class="built_in">local</span>/bin/redis-server 127.0.0.1:6302 [cluster]</span><br><span class="line">root      5942     1  0 14:57 ?        00:00:00 /usr/<span class="built_in">local</span>/bin/redis-server 127.0.0.1:6303 [cluster]</span><br><span class="line">root      5949     1  0 14:57 ?        00:00:00 /usr/<span class="built_in">local</span>/bin/redis-server 127.0.0.1:6304 [cluster]</span><br><span class="line">root      5956     1  0 14:57 ?        00:00:00 /usr/<span class="built_in">local</span>/bin/redis-server 127.0.0.1:6305 [cluster]</span><br><span class="line">root      5963     1  0 14:57 ?        00:00:00 /usr/<span class="built_in">local</span>/bin/redis-server 127.0.0.1:6306 [cluster]</span><br></pre></td></tr></table></figure><p>此时查看目录已经生成了默认的节点文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:/usr/local/redis-cluster$ tree</span><br><span class="line">.</span><br><span class="line">├── conf</span><br><span class="line">│   ├── redis-6301.conf</span><br><span class="line">│   ├── redis-6302.conf</span><br><span class="line">│   ├── redis-6303.conf</span><br><span class="line">│   ├── redis-6304.conf</span><br><span class="line">│   ├── redis-6305.conf</span><br><span class="line">│   └── redis-6306.conf</span><br><span class="line">├── data</span><br><span class="line">│   ├── redis-6301</span><br><span class="line">│   │   └── nodes-6301.conf</span><br><span class="line">│   ├── redis-6302</span><br><span class="line">│   │   └── nodes-6302.conf</span><br><span class="line">│   ├── redis-6303</span><br><span class="line">│   │   └── nodes-6303.conf</span><br><span class="line">│   ├── redis-6304</span><br><span class="line">│   │   └── nodes-6304.conf</span><br><span class="line">│   ├── redis-6305</span><br><span class="line">│   │   └── nodes-6305.conf</span><br><span class="line">│   └── redis-6306</span><br><span class="line">│       └── nodes-6306.conf</span><br><span class="line">└── log</span><br><span class="line">    ├── redis-6301-server.log</span><br><span class="line">    ├── redis-6302-server.log</span><br><span class="line">    ├── redis-6303-server.log</span><br><span class="line">    ├── redis-6304-server.log</span><br><span class="line">    ├── redis-6305-server.log</span><br><span class="line">    └── redis-6306-server.log</span><br><span class="line"></span><br><span class="line">9 directories, 18 files</span><br></pre></td></tr></table></figure><ol><li>虽然实例都启动起来了，但是现在每个实例是单独的，需要把它们连接到一起，运行如下命令 <code>redis-cli -a foobared --cluster create 127.0.0.1:6301 127.0.0.1:6302 127.0.0.1:6303 127.0.0.1:6304 127.0.0.1:6305 127.0.0.1:6306 --cluster-replicas 1</code> 即可，命令中的 <code>--cluster-replicas 1</code> 表示为每个主节点都提供一个从节点，中间还需要输入 yes，这样运行完就形成了一个三主三从的redis集群：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:/usr/<span class="built_in">local</span>/redis-cluster$ redis-cli -a foobared --cluster create 127.0.0.1:6301 127.0.0.1:6302 127.0.0.1:6303 127.0.0.1:6304 127.0.0.1:6305 127.0.0.1:6306 --cluster-replicas 1</span><br><span class="line">Warning: Using a password with <span class="string">'-a'</span> or <span class="string">'-u'</span> option on the <span class="built_in">command</span> line interface may not be safe.</span><br><span class="line">&gt;&gt;&gt; Performing <span class="built_in">hash</span> slots allocation on 6 nodes...</span><br><span class="line">Master[0] -&gt; Slots 0 - 5460</span><br><span class="line">Master[1] -&gt; Slots 5461 - 10922</span><br><span class="line">Master[2] -&gt; Slots 10923 - 16383</span><br><span class="line">Adding replica 127.0.0.1:6305 to 127.0.0.1:6301</span><br><span class="line">Adding replica 127.0.0.1:6306 to 127.0.0.1:6302</span><br><span class="line">Adding replica 127.0.0.1:6304 to 127.0.0.1:6303</span><br><span class="line">&gt;&gt;&gt; Trying to optimize slaves allocation <span class="keyword">for</span> anti-affinity</span><br><span class="line">[WARNING] Some slaves are <span class="keyword">in</span> the same host as their master</span><br><span class="line">M: 5d60bdad15a6f8ceec188a1081e9381f181a5c5e 127.0.0.1:6301</span><br><span class="line">   slots:[0-5460] (5461 slots) master</span><br><span class="line">M: 8c814d4a32763d47723398fcf8f596d7b6340afc 127.0.0.1:6302</span><br><span class="line">   slots:[5461-10922] (5462 slots) master</span><br><span class="line">M: 7bc53b512772c3a1df3217facca283ff9564d32d 127.0.0.1:6303</span><br><span class="line">   slots:[10923-16383] (5461 slots) master</span><br><span class="line">S: b39bdb5b6e720e9fbedd43e58b57661910dcc3d7 127.0.0.1:6304</span><br><span class="line">   replicates 5d60bdad15a6f8ceec188a1081e9381f181a5c5e</span><br><span class="line">S: 5fef2bedd430bf86cdff63cb2f852aeb21e1b18f 127.0.0.1:6305</span><br><span class="line">   replicates 8c814d4a32763d47723398fcf8f596d7b6340afc</span><br><span class="line">S: 0123b160087743a5296807145b426d9b9cefcf21 127.0.0.1:6306</span><br><span class="line">   replicates 7bc53b512772c3a1df3217facca283ff9564d32d</span><br><span class="line">Can I <span class="built_in">set</span> the above configuration? (<span class="built_in">type</span> <span class="string">'yes'</span> to accept): yes</span><br><span class="line">&gt;&gt;&gt; Nodes configuration updated</span><br><span class="line">&gt;&gt;&gt; Assign a different config epoch to each node</span><br><span class="line">&gt;&gt;&gt; Sending CLUSTER MEET messages to join the cluster</span><br><span class="line">Waiting <span class="keyword">for</span> the cluster to join</span><br><span class="line">.</span><br><span class="line">&gt;&gt;&gt; Performing Cluster Check (using node 127.0.0.1:6301)</span><br><span class="line">M: 5d60bdad15a6f8ceec188a1081e9381f181a5c5e 127.0.0.1:6301</span><br><span class="line">   slots:[0-5460] (5461 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">S: b39bdb5b6e720e9fbedd43e58b57661910dcc3d7 127.0.0.1:6304</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates 5d60bdad15a6f8ceec188a1081e9381f181a5c5e</span><br><span class="line">M: 7bc53b512772c3a1df3217facca283ff9564d32d 127.0.0.1:6303</span><br><span class="line">   slots:[10923-16383] (5461 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">S: 5fef2bedd430bf86cdff63cb2f852aeb21e1b18f 127.0.0.1:6305</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates 8c814d4a32763d47723398fcf8f596d7b6340afc</span><br><span class="line">M: 8c814d4a32763d47723398fcf8f596d7b6340afc 127.0.0.1:6302</span><br><span class="line">   slots:[5461-10922] (5462 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">S: 0123b160087743a5296807145b426d9b9cefcf21 127.0.0.1:6306</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates 7bc53b512772c3a1df3217facca283ff9564d32d</span><br><span class="line">[OK] All nodes agree about slots configuration.</span><br><span class="line">&gt;&gt;&gt; Check <span class="keyword">for</span> open slots...</span><br><span class="line">&gt;&gt;&gt; Check slots coverage...</span><br><span class="line">[OK] All 16384 slots covered.</span><br></pre></td></tr></table></figure><h1 id="redis集群的使用"><a href="#redis集群的使用" class="headerlink" title="redis集群的使用"></a>redis集群的使用</h1><p>当使用<code>redis-cli</code>连接集群的时候，直接连3个主节点的任意一个就可以，把cluster当成一个整理来看待，测试如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:/usr/local/redis-cluster$ redis-cli -a foobared -p 6301</span><br><span class="line">Warning: Using a password with &apos;-a&apos; or &apos;-u&apos; option on the command line interface may not be safe.</span><br><span class="line">127.0.0.1:6301&gt; get name</span><br><span class="line">(error) MOVED 5798 127.0.0.1:6302</span><br><span class="line">127.0.0.1:6301&gt; set name cluster-test</span><br><span class="line">(error) MOVED 5798 127.0.0.1:6302</span><br><span class="line">127.0.0.1:6301&gt;</span><br></pre></td></tr></table></figure><p>我们发现测试Redis命令的时候报错了，显示 <code>(error) MOVED 5798 127.0.0.1:6302</code>，这说明 <code>name</code> 这个键不在端口为 6301 这个实例上，而在端口为 6302 这个实例上，使用 <code>cluster nodes</code> 命令可以查询集群的节点信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6301&gt; cluster nodes</span><br><span class="line">b39bdb5b6e720e9fbedd43e58b57661910dcc3d7 127.0.0.1:6304@16304 slave 5d60bdad15a6f8ceec188a1081e9381f181a5c5e 0 1624711999000 1 connected</span><br><span class="line">7bc53b512772c3a1df3217facca283ff9564d32d 127.0.0.1:6303@16303 master - 0 1624712000000 3 connected 10923-16383</span><br><span class="line">5fef2bedd430bf86cdff63cb2f852aeb21e1b18f 127.0.0.1:6305@16305 slave 8c814d4a32763d47723398fcf8f596d7b6340afc 0 1624711998971 2 connected</span><br><span class="line">5d60bdad15a6f8ceec188a1081e9381f181a5c5e 127.0.0.1:6301@16301 myself,master - 0 1624712000000 1 connected 0-5460</span><br><span class="line">8c814d4a32763d47723398fcf8f596d7b6340afc 127.0.0.1:6302@16302 master - 0 1624711999978 2 connected 5461-10922</span><br><span class="line">0123b160087743a5296807145b426d9b9cefcf21 127.0.0.1:6306@16306 slave 7bc53b512772c3a1df3217facca283ff9564d32d 0 1624712000991 3 connected</span><br></pre></td></tr></table></figure><p>这种情况下可以手动连接端口为6302的节点，也可以在连接 6301 时添加一个 <code>-c</code> 参数，这样在当前实例找不到指定的键时会自动切换，下面测试一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:/usr/local/redis-cluster$ redis-cli -a foobared -p 6301 -c</span><br><span class="line">Warning: Using a password with &apos;-a&apos; or &apos;-u&apos; option on the command line interface may not be safe.</span><br><span class="line">127.0.0.1:6301&gt; set name cluster666</span><br><span class="line">-&gt; Redirected to slot [5798] located at 127.0.0.1:6302</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6302&gt; get name</span><br><span class="line">&quot;cluster666&quot;</span><br><span class="line">127.0.0.1:6302&gt;</span><br></pre></td></tr></table></figure><p>自动跳转到了端口为6302的实例上，这波操作挺666</p><h1 id="C-工程连接使用redis-cluster"><a href="#C-工程连接使用redis-cluster" class="headerlink" title="C++工程连接使用redis-cluster"></a>C++工程连接使用redis-cluster</h1><p><code>redis-cli</code> 可以在集群的各个节点之间自动跳转，那是人家的本事，如果是你想自己连接集群，首先看看你使用的是那个库了。</p><p>如果使用的语言是C/C++，并且用的是最常见的hiredis，那么很抱歉它本身不提供集群的便利访问，像 <code>MGET</code>，<code>MSET</code> 这种操作多个键的命令得自己花点力气了，不过如果你考虑换一个库那么这些问题就解决了。</p><p><code>hiredis-vip</code> 是第一个选择，这个名字听起来好像充了前才能用，实际上是“唯品会 一家专门做特卖的网站”，它先搞出来开源的，可以把集群看成一个整体，连接任一节点就可以操作，但是这个库有个问题，不支持认证，所以后来人在这个基础上进行了二次开发。<a href="https://github.com/vipshop/hiredis-vip" target="_blank" rel="noopener">hiredis-vip源码</a></p><p><code>hiredis-cluster</code> 就是这个二次创作的产物，现在算是官方推荐产品了，如果你想方便的操作集群，不妨下载这个库<a href="https://github.com/Nordix/hiredis-cluster" target="_blank" rel="noopener">hiredis-cluster源码</a>试试，另外<a href="https://github.com/sewenew/redis-plus-plus" target="_blank" rel="noopener">redis-plus-plus</a>也属于官方推荐产品，有时间可以了解一下。</p><h2 id="hiredis-cluster"><a href="#hiredis-cluster" class="headerlink" title="hiredis-cluster"></a>hiredis-cluster</h2><p>今天拿 <code>hiredis-cluster</code> 开刀，看看它怎么用，改天再研究那个 <code>redis-plus-plus</code>。</p><ol><li>首先创建一个目录 <code>/usr/local/redis-cluster-cli</code>，进入目录下载源码：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:/usr/<span class="built_in">local</span>/redis-cluster$ sudo mkdir -p /usr/<span class="built_in">local</span>/redis-cluster-cli</span><br><span class="line">albert@home-pc:/usr/<span class="built_in">local</span>/redis-cluster$ <span class="built_in">cd</span> /usr/<span class="built_in">local</span>/redis-cluster-cli</span><br><span class="line">albert@home-pc:/usr/<span class="built_in">local</span>/redis-cluster-cli$ sudo wget https://github.com/Nordix/hiredis-cluster/archive/refs/tags/0.6.0.tar.gz</span><br><span class="line">--2021-06-26 22:01:15--  https://github.com/Nordix/hiredis-cluster/archive/refs/tags/0.6.0.tar.gz</span><br><span class="line">Resolving github.com (github.com)... 140.82.114.3</span><br><span class="line">Connecting to github.com (github.com)|140.82.114.3|:443... connected.</span><br><span class="line">HTTP request sent, awaiting response... 302 Found</span><br><span class="line">Location: https://codeload.github.com/Nordix/hiredis-cluster/tar.gz/refs/tags/0.6.0 [following]</span><br><span class="line">--2021-06-26 22:01:16--  https://codeload.github.com/Nordix/hiredis-cluster/tar.gz/refs/tags/0.6.0</span><br><span class="line">Resolving codeload.github.com (codeload.github.com)... 13.229.189.0</span><br><span class="line">Connecting to codeload.github.com (codeload.github.com)|13.229.189.0|:443... connected.</span><br><span class="line">HTTP request sent, awaiting response... 200 OK</span><br><span class="line">Length: unspecified [application/x-gzip]</span><br><span class="line">Saving to: ‘0.6.0.tar.gz’</span><br><span class="line"></span><br><span class="line">0.6.0.tar.gz       [        &lt;=&gt;                                      ]  69.58K  19.4KB/s    <span class="keyword">in</span> 3.6s</span><br><span class="line"></span><br><span class="line">2021-06-26 22:01:21 (19.4 KB/s) - ‘0.6.0.tar.gz’ saved [71249]</span><br></pre></td></tr></table></figure><ol><li>解压源码，进入目录hiredis-cluster-0.6.0</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:/usr/<span class="built_in">local</span>/redis-cluster-cli$ sudo tar -zxvf 0.6.0.tar.gz</span><br><span class="line">hiredis-cluster-0.6.0/</span><br><span class="line">hiredis-cluster-0.6.0/.clang-format</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">hiredis-cluster-0.6.0/tests/test_utils.h</span><br><span class="line">hiredis-cluster-0.6.0/win32.h</span><br><span class="line">albert@home-pc:/usr/<span class="built_in">local</span>/redis-cluster-cli$ ls</span><br><span class="line">0.6.0.tar.gz  hiredis-cluster-0.6.0</span><br><span class="line">albert@home-pc:/usr/<span class="built_in">local</span>/redis-cluster-cli$ <span class="built_in">cd</span> hiredis-cluster-0.6.0/</span><br><span class="line">albert@home-pc:/usr/<span class="built_in">local</span>/redis-cluster-cli/hiredis-cluster-0.6.0$</span><br></pre></td></tr></table></figure><ol><li>按照README文档编译库文件</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:/usr/local/redis-cluster-cli/hiredis-cluster-0.6.0$ sudo mkdir build &amp;&amp; cd build</span><br><span class="line">albert@home-pc:/usr/local/redis-cluster-cli/hiredis-cluster-0.6.0/build$ sudo cmake -DCMAKE_BUILD_TYPE=RelWithDebInfo -DDISABLE_TESTS=ON ..</span><br><span class="line">CMake Error at CMakeLists.txt:1 (cmake_minimum_required):</span><br><span class="line">  CMake 3.11 or higher is required.  You are running version 3.5.1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-- Configuring incomplete, errors occurred!</span><br></pre></td></tr></table></figure><p>oh no！要求cmake版本最低3.11，而我的ubuntu16.04自带的cmake是3.5.1，好吧我先去升个级</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ wget http://www.cmake.org/files/v3.11/cmake-3.11.3.tar.gz</span><br><span class="line">$ tar xf cmake-3.11.3.tar.gz</span><br><span class="line">$ <span class="built_in">cd</span> cmake-3.11.3</span><br><span class="line">$ ./configure</span><br><span class="line">$ make</span><br><span class="line">$ sudo make install</span><br></pre></td></tr></table></figure><ol><li>继续编译 hiredis-cluster 库，先运行cmake生成Makefile文件，然后运行 <code>make</code> 命令开始编译：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:/usr/<span class="built_in">local</span>/redis-cluster-cli/hiredis-cluster-0.6.0/build$ sudo cmake -DCMAKE_BUILD_TYPE=RelWithDebInfo -DDISABLE_TESTS=ON ..</span><br><span class="line">-- The C compiler identification is GNU 5.4.0</span><br><span class="line">-- The CXX compiler identification is GNU 5.4.0</span><br><span class="line">-- Check <span class="keyword">for</span> working C compiler: /usr/bin/cc</span><br><span class="line">-- Check <span class="keyword">for</span> working C compiler: /usr/bin/cc -- works</span><br><span class="line">-- Detecting C compiler ABI info</span><br><span class="line">-- Detecting C compiler ABI info - <span class="keyword">done</span></span><br><span class="line">-- Detecting C compile features</span><br><span class="line">-- Detecting C compile features - <span class="keyword">done</span></span><br><span class="line">-- Check <span class="keyword">for</span> working CXX compiler: /usr/bin/c++</span><br><span class="line">-- Check <span class="keyword">for</span> working CXX compiler: /usr/bin/c++ -- works</span><br><span class="line">-- Detecting CXX compiler ABI info</span><br><span class="line">-- Detecting CXX compiler ABI info - <span class="keyword">done</span></span><br><span class="line">-- Detecting CXX compile features</span><br><span class="line">-- Detecting CXX compile features - <span class="keyword">done</span></span><br><span class="line">Detected version: 0.5.0</span><br><span class="line">Downloading dependency <span class="string">'hiredis'</span>..</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">albert@home-pc:/usr/<span class="built_in">local</span>/redis-cluster-cli/hiredis-cluster-0.6.0/build$ sudo make</span><br><span class="line">Scanning dependencies of target hiredis_cluster</span><br><span class="line">[  5%] Building C object CMakeFiles/hiredis_cluster.dir/adlist.c.o</span><br><span class="line">[ 11%] Building C object CMakeFiles/hiredis_cluster.dir/command.c.o</span><br><span class="line">[ 17%] Building C object CMakeFiles/hiredis_cluster.dir/crc16.c.o</span><br><span class="line">[ 23%] Building C object CMakeFiles/hiredis_cluster.dir/dict.c.o</span><br><span class="line">[ 29%] Building C object CMakeFiles/hiredis_cluster.dir/hiarray.c.o</span><br><span class="line">[ 35%] Building C object CMakeFiles/hiredis_cluster.dir/hircluster.c.o</span><br><span class="line">[ 41%] Building C object CMakeFiles/hiredis_cluster.dir/hiutil.c.o</span><br><span class="line">[ 47%] Linking C shared library libhiredis_cluster.so</span><br><span class="line">[ 47%] Built target hiredis_cluster</span><br><span class="line">Scanning dependencies of target hiredis</span><br><span class="line">[ 52%] Building C object _deps/hiredis-build/CMakeFiles/hiredis.dir/alloc.c.o</span><br><span class="line">[ 58%] Building C object _deps/hiredis-build/CMakeFiles/hiredis.dir/async.c.o</span><br><span class="line">[ 64%] Building C object _deps/hiredis-build/CMakeFiles/hiredis.dir/dict.c.o</span><br><span class="line">[ 70%] Building C object _deps/hiredis-build/CMakeFiles/hiredis.dir/hiredis.c.o</span><br><span class="line">[ 76%] Building C object _deps/hiredis-build/CMakeFiles/hiredis.dir/net.c.o</span><br><span class="line">[ 82%] Building C object _deps/hiredis-build/CMakeFiles/hiredis.dir/read.c.o</span><br><span class="line">[ 88%] Building C object _deps/hiredis-build/CMakeFiles/hiredis.dir/sds.c.o</span><br><span class="line">[ 94%] Building C object _deps/hiredis-build/CMakeFiles/hiredis.dir/sockcompat.c.o</span><br><span class="line">[100%] Linking C shared library libhiredis.so</span><br><span class="line">[100%] Built target hiredis</span><br></pre></td></tr></table></figure><ol><li>进入 <code>/usr/local/redis-cluster-cli/hiredis-cluster-0.6.0</code> 目录，新建 <code>cluster-cli.cpp</code> 文件，编写测试代码如下：</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"hircluster.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">timeout</span> = &#123;</span><span class="number">1</span>, <span class="number">500000</span>&#125;; <span class="comment">// 1.5s</span></span><br><span class="line"></span><br><span class="line">    redisClusterContext *cc = redisClusterContextInit();</span><br><span class="line">    redisClusterSetOptionAddNodes(cc, <span class="string">"127.0.0.1:6301"</span>);</span><br><span class="line">    redisClusterSetOptionConnectTimeout(cc, timeout);</span><br><span class="line">    redisClusterSetOptionPassword(cc, <span class="string">"foobared"</span>);</span><br><span class="line">    redisClusterSetOptionRouteUseSlots(cc);</span><br><span class="line">    redisClusterConnect2(cc);</span><br><span class="line">    <span class="keyword">if</span> (cc &amp;&amp; cc-&gt;err) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Error: %s\n"</span>, cc-&gt;errstr);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    redisReply *reply =</span><br><span class="line">        (redisReply *)redisClusterCommand(cc, <span class="string">"SET %s %s"</span>, <span class="string">"name"</span>, <span class="string">"cluster999"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"SET: %s\n"</span>, reply-&gt;str);</span><br><span class="line">    freeReplyObject(reply);</span><br><span class="line"></span><br><span class="line">    redisReply *reply2 = (redisReply *)redisClusterCommand(cc, <span class="string">"GET %s"</span>, <span class="string">"name"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"GET: %s\n"</span>, reply2-&gt;str);</span><br><span class="line">    freeReplyObject(reply2);</span><br><span class="line"></span><br><span class="line">    redisClusterFree(cc);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>运行如下命令，编译代码，然后运行，结果和预期一致，虽然连接的是端口为6301的实例，也成功取到了端口为6302实例上的数据：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:/usr/<span class="built_in">local</span>/redis-cluster-cli/hiredis-cluster-0.6.0$ sudo gcc cluster-cli.cpp -I ./build/_deps/ -L ./build/ -Wl,-rpath=./build -lhiredis_cluster -L ./build/_deps/hiredis-build/ -Wl,-rpath=./build/_deps/hiredis-build/ -lhiredis -o cluster-cli</span><br><span class="line">albert@home-pc:/usr/<span class="built_in">local</span>/redis-cluster-cli/hiredis-cluster-0.6.0$ ./cluster-cli</span><br><span class="line">SET: OK</span><br><span class="line">GET: cluster999</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>安装软件其实就是把软件的各部分数据放到它该放的地方而已，卸载软件就是把这些数据删掉了</li><li>redis也是一款软件，与其他软件并无不同，想要使用多个同时使用，启动多个实例就好了，需要注意配置别冲突</li><li>单独运行的redis实例之间不会有沟通，想要这些实例联合起来工作，需要把它们组成一个集群</li><li><code>hiredis-cluster</code> 和 <code>cluster-plus-plus</code> 是使用的C/C++连接redis集的官方推荐库</li></ul><hr><h2 id="gt-gt-反爬链接，请勿点击，原地爆炸，概不负责！-lt-lt"><a href="#gt-gt-反爬链接，请勿点击，原地爆炸，概不负责！-lt-lt" class="headerlink" title=" ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== "></a><center><a href="https://blog.csdn.net/albertsh/article/details/107587859" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center></h2><blockquote><p>一念动山海，一念山海平~</p><p>2021-6-27 00:35:13</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;所谓“难者不会，会者不难”，这不只是一句简简单单的俗语，而是历经人类进化史而得到的历史经验，只有亲身体会过才会越发了解这句话的意义。当你苦思
      
    
    </summary>
    
      <category term="redis" scheme="http://AlbertGithubHome.github.io/blog/categories/redis/"/>
    
    
      <category term="redis" scheme="http://AlbertGithubHome.github.io/blog/tags/redis/"/>
    
      <category term="集群" scheme="http://AlbertGithubHome.github.io/blog/tags/%E9%9B%86%E7%BE%A4/"/>
    
      <category term="实践" scheme="http://AlbertGithubHome.github.io/blog/tags/%E5%AE%9E%E8%B7%B5/"/>
    
  </entry>
  
  <entry>
    <title>cpplint中filter参数的每个可选项的含义</title>
    <link href="http://AlbertGithubHome.github.io/blog/2021/06/17/cpplint%E4%B8%ADfilter%E5%8F%82%E6%95%B0%E7%9A%84%E6%AF%8F%E4%B8%AA%E5%8F%AF%E9%80%89%E9%A1%B9%E7%9A%84%E5%90%AB%E4%B9%89/"/>
    <id>http://AlbertGithubHome.github.io/blog/2021/06/17/cpplint中filter参数的每个可选项的含义/</id>
    <published>2021-06-16T16:31:29.000Z</published>
    <updated>2021-06-20T14:02:49.982Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><code>cpplint</code> 是一款优秀的代码格式检查工具，有了它可以统一整个团队的代码风格，完整的工具就是一个Python脚本，如果安装了Python环境，直接使用 <code>pip install cpplint</code> 命令就可以安装了，非常的方便。</p><a id="more"></a><p>具体的使用方法可以通过 <code>cpplint --help</code> 查询，语法如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Syntax: cpplint.py [--verbose=<span class="comment">#] [--output=emacs|eclipse|vs7|junit|sed|gsed]</span></span><br><span class="line">                   [--filter=-x,+y,...]</span><br><span class="line">                   [--counting=total|toplevel|detailed] [--root=subdir]</span><br><span class="line">                   [--repository=path]</span><br><span class="line">                   [--linelength=digits] [--headers=x,y,...]</span><br><span class="line">                   [--recursive]</span><br><span class="line">                   [--exclude=path]</span><br><span class="line">                   [--extensions=hpp,cpp,...]</span><br><span class="line">                   [--includeorder=default|standardcfirst]</span><br><span class="line">                   [--quiet]</span><br><span class="line">                   [--version]</span><br><span class="line">        &lt;file&gt; [file] ...</span><br><span class="line"></span><br><span class="line">  Style checker <span class="keyword">for</span> C/C++ <span class="built_in">source</span> files.</span><br><span class="line">  This is a fork of the Google style checker with minor extensions.</span><br></pre></td></tr></table></figure><p>其中有一句 <code>[--filter=-x,+y,...]</code> 就是本文总结的重点。</p><h1 id="filter是什么"><a href="#filter是什么" class="headerlink" title="filter是什么"></a>filter是什么</h1><p>这个filter究竟是什么呢？我将它强行解释成代码的“过滤器”，cpplint 是一款检查C++源代码风格的工具，遵循的是Google的编码风格，但是这些规则并不是对于所有人都合适，我们应该有目的进行选择，这个filter参数就是用来屏蔽或者启用一些规则的，我们还是从帮助文档里来看，其中有一段</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">filter=-x,+y,...</span><br><span class="line">  Specify a comma-separated list of category-filters to apply: only</span><br><span class="line">  error messages whose category names pass the filters will be printed.</span><br><span class="line">  (Category names are printed with the message and look like</span><br><span class="line">  <span class="string">"[whitespace/indent]"</span>.)  Filters are evaluated left to right.</span><br><span class="line">  <span class="string">"-FOO"</span> means <span class="string">"do not print categories that start with FOO"</span>.</span><br><span class="line">  <span class="string">"+FOO"</span> means <span class="string">"do print categories that start with FOO"</span>.</span><br><span class="line"></span><br><span class="line">  Examples: --filter=-whitespace,+whitespace/braces</span><br><span class="line">            --filter=-whitespace,-runtime/<span class="built_in">printf</span>,+runtime/printf_format</span><br><span class="line">            --filter=-,+build/include_what_you_use</span><br><span class="line"></span><br><span class="line">  To see a list of all the categories used <span class="keyword">in</span> cpplint, pass no arg:</span><br><span class="line">     --filter=</span><br></pre></td></tr></table></figure><p>这一段说明了filter参数的用法，就是以<code>+</code>或者 <code>-</code> 开头接着写规则名，就表示启用或者屏蔽这些规则，使用 <code>--filter=</code> 参数会列举出所有规则，我们来看一下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\Albert&gt;cpplint --filter=</span><br><span class="line">  build/class</span><br><span class="line">  build/c++11</span><br><span class="line">  build/c++14</span><br><span class="line">  build/c++tr1</span><br><span class="line">  build/deprecated</span><br><span class="line">  build/endif_comment</span><br><span class="line">  build/explicit_make_pair</span><br><span class="line">  build/forward_decl</span><br><span class="line">  build/header_guard</span><br><span class="line">  build/include</span><br><span class="line">  build/include_subdir</span><br><span class="line">  build/include_alpha</span><br><span class="line">  build/include_order</span><br><span class="line">  build/include_what_you_use</span><br><span class="line">  build/namespaces_headers</span><br><span class="line">  build/namespaces_literals</span><br><span class="line">  build/namespaces</span><br><span class="line">  build/printf_format</span><br><span class="line">  build/storage_class</span><br><span class="line">  legal/copyright</span><br><span class="line">  readability/alt_tokens</span><br><span class="line">  readability/braces</span><br><span class="line">  readability/casting</span><br><span class="line">  readability/check</span><br><span class="line">  readability/constructors</span><br><span class="line">  readability/fn_size</span><br><span class="line">  readability/inheritance</span><br><span class="line">  readability/multiline_comment</span><br><span class="line">  readability/multiline_string</span><br><span class="line">  readability/namespace</span><br><span class="line">  readability/nolint</span><br><span class="line">  readability/nul</span><br><span class="line">  readability/strings</span><br><span class="line">  readability/todo</span><br><span class="line">  readability/utf8</span><br><span class="line">  runtime/arrays</span><br><span class="line">  runtime/casting</span><br><span class="line">  runtime/explicit</span><br><span class="line">  runtime/int</span><br><span class="line">  runtime/init</span><br><span class="line">  runtime/invalid_increment</span><br><span class="line">  runtime/member_string_references</span><br><span class="line">  runtime/memset</span><br><span class="line">  runtime/indentation_namespace</span><br><span class="line">  runtime/operator</span><br><span class="line">  runtime/<span class="built_in">printf</span></span><br><span class="line">  runtime/printf_format</span><br><span class="line">  runtime/references</span><br><span class="line">  runtime/string</span><br><span class="line">  runtime/threadsafe_fn</span><br><span class="line">  runtime/vlog</span><br><span class="line">  whitespace/blank_line</span><br><span class="line">  whitespace/braces</span><br><span class="line">  whitespace/comma</span><br><span class="line">  whitespace/comments</span><br><span class="line">  whitespace/empty_conditional_body</span><br><span class="line">  whitespace/empty_if_body</span><br><span class="line">  whitespace/empty_loop_body</span><br><span class="line">  whitespace/end_of_line</span><br><span class="line">  whitespace/ending_newline</span><br><span class="line">  whitespace/forcolon</span><br><span class="line">  whitespace/indent</span><br><span class="line">  whitespace/line_length</span><br><span class="line">  whitespace/newline</span><br><span class="line">  whitespace/operators</span><br><span class="line">  whitespace/parens</span><br><span class="line">  whitespace/semicolon</span><br><span class="line">  whitespace/tab</span><br><span class="line">  whitespace/todo</span><br></pre></td></tr></table></figure><p>这些选项还挺多的，一共有69项，但是现在有一个问题，我就一直没找到这些选项都代表什么含义，有些从名字可以推断出来，比如 <code>whitespace/line_length</code> 应该是指每行的长度限制，但是 <code>whitespace/comma</code> 单单从名字你知道他们是什么意思吗？所以我想简单总结一下。</p><h1 id="一个小实验"><a href="#一个小实验" class="headerlink" title="一个小实验"></a>一个小实验</h1><p>都说cpplint非常好用，那么接下来我们看看这个工具要怎么用，先新建一个文件<code>teststyle</code>，在里面随便写一些C++代码，如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Style</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"This is style class"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">showName</span><span class="params">(<span class="built_in">string</span>&amp; extraMsg)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; extraMsg &lt;&lt; className &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">string</span> className;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Style s;</span><br><span class="line">    <span class="built_in">string</span> msg_fjakdjfkadjfkadjffjadfkasdjffajsdfkadvljakdjfakdfjkadfjkasdjfkasdfj=<span class="string">"class_name:"</span>;</span><br><span class="line">    s.showName( msg_fjakdjfkadjfkadjffjadfkasdjffajsdfkadvljakdjfakdfjkadfjkasdjfkasdfj );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(s.className == <span class="string">""</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"class name for s is empty."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段临时“发挥”的代码可以正常编译运行，然后用<code>cpplint</code>工具检测一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&gt; cpplint .\teststyle.cpp</span><br><span class="line">.\teststyle.cpp:0:  No copyright message found.  You should have a line: &quot;Copyright [year] &lt;Copyright Owner&gt;&quot;  [legal/copyright] [5]</span><br><span class="line">.\teststyle.cpp:3:  Do not use namespace using-directives.  Use using-declarations instead.  [build/namespaces] [5]</span><br><span class="line">.\teststyle.cpp:6:  &#123; should almost always be at the end of the previous line  [whitespace/braces] [4]</span><br><span class="line">.\teststyle.cpp:7:  public: should be indented +1 space inside class Style  [whitespace/indent] [3]</span><br><span class="line">.\teststyle.cpp:8:  Tab found; better to use spaces  [whitespace/tab] [1]</span><br><span class="line">.\teststyle.cpp:12:  Is this a non-const reference? If so, make const or use a pointer: string&amp; extraMsg  [runtime/references] [2]</span><br><span class="line">.\teststyle.cpp:13:  &#123; should almost always be at the end of the previous line  [whitespace/braces] [4]</span><br><span class="line">.\teststyle.cpp:16:  public: should be indented +1 space inside class Style  [whitespace/indent] [3]</span><br><span class="line">.\teststyle.cpp:21:  &#123; should almost always be at the end of the previous line  [whitespace/braces] [4]</span><br><span class="line">.\teststyle.cpp:23:  Lines should be &lt;= 80 characters long  [whitespace/line_length] [2]</span><br><span class="line">.\teststyle.cpp:23:  Missing spaces around =  [whitespace/operators] [4]</span><br><span class="line">.\teststyle.cpp:24:  Lines should be &lt;= 80 characters long  [whitespace/line_length] [2]</span><br><span class="line">.\teststyle.cpp:24:  Extra space after ( in function call  [whitespace/parens] [4]</span><br><span class="line">.\teststyle.cpp:24:  Extra space before )  [whitespace/parens] [2]</span><br><span class="line">.\teststyle.cpp:26:  Missing space before ( in if(  [whitespace/parens] [5]</span><br><span class="line">.\teststyle.cpp:27:  &#123; should almost always be at the end of the previous line  [whitespace/braces] [4]</span><br><span class="line">.\teststyle.cpp:32:  Could not find a newline character at the end of the file.  [whitespace/ending_newline] [5]</span><br><span class="line">Done processing .\teststyle.cpp</span><br><span class="line">Total errors found: 17</span><br></pre></td></tr></table></figure><p>这么一小段代码居然报出了17个错误，厉不厉害？刺不刺激？下面来逐个解释一下：</p><blockquote><p>.\teststyle.cpp:0:  No copyright message found.  You should have a line: “Copyright [year] <copyright owner="">“  [legal/copyright] [5]</copyright></p></blockquote><p><code>[legal/copyright]</code> 表示文件中应该有形如 <code>Copyright [year] &lt;Copyright Owner&gt;</code> 版权信息</p><blockquote><p>\teststyle.cpp:3:  Do not use namespace using-directives.  Use using-declarations instead.  [build/namespaces] [5]</p></blockquote><p><code>[legal/copyright]</code> 表示第3行 <code>using namespace std;</code> 应该使用 <code>using-declarations</code> 而不要使用 <code>using-directives</code>，这个规则可以简单的理解为使用命名空间，每次只引用其中的成员，而不要把整个命名空间都引入。</p><blockquote><p>.\teststyle.cpp:6:  { should almost always be at the end of the previous line  [whitespace/braces] [4]</p></blockquote><p><code>[whitespace/braces]</code> 表示第6行的大括号应该放在上一行末尾</p><blockquote><p>.\teststyle.cpp:7:  public: should be indented +1 space inside class Style  [whitespace/indent] [3]</p></blockquote><p><code>[whitespace/indent]</code> 表示第7行 <code>public:</code> 应该在行首只保留一个空格</p><blockquote><p>.\teststyle.cpp:8:  Tab found; better to use spaces  [whitespace/tab] [1]</p></blockquote><p><code>[whitespace/tab]</code> 表示代码中第8行出现了Tab字符，应该使用空格代替</p><blockquote><p>.\teststyle.cpp:12:  Is this a non-const reference? If so, make const or use a pointer: string&amp; extraMsg  [runtime/references] [2]</p></blockquote><p><code>[runtime/references]</code> 表示代码第12行建议使用常引用</p><blockquote><p>.\teststyle.cpp:23:  Lines should be &lt;= 80 characters long  [whitespace/line_length] [2]</p></blockquote><p><code>[whitespace/line_length]</code> 表示代码第23行长度超过了80个字符</p><blockquote><p>.\teststyle.cpp:23:  Missing spaces around =  [whitespace/operators] [4]</p></blockquote><p><code>[whitespace/operators]</code> 表示代码第23行在赋值符号 <code>=</code> 前后应该有一个空格</p><blockquote><p>.\teststyle.cpp:24:  Extra space after ( in function call  [whitespace/parens] [4]</p></blockquote><p><code>[whitespace/parens]</code> 表示代码第24行在小括号后面出现了多余的空格</p><blockquote><p>.\teststyle.cpp:26:  Missing space before ( in if(  [whitespace/parens] [5]</p></blockquote><p><code>[whitespace/parens]</code> 表示代码第26行if后面缺少空格</p><blockquote><p>.\teststyle.cpp:32:  Could not find a newline character at the end of the file.  [whitespace/ending_newline] [5]</p></blockquote><p><code>[whitespace/ending_newline]</code> 表示32行，文件末尾应该是一个空行</p><p>按照上面<code>cpplint</code>提示修改代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Copyright [2021] &lt;Copyright albert&gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Style</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"This is style class"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showName</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; extraMsg)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; extraMsg &lt;&lt; className &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">string</span> className;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Style s;</span><br><span class="line">    <span class="built_in">string</span> msg = <span class="string">"class_name:"</span>;</span><br><span class="line">    s.showName(msg);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (s.className == <span class="string">""</span>) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"class name for s is empty."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="自己指定筛选规则"><a href="#自己指定筛选规则" class="headerlink" title="自己指定筛选规则"></a>自己指定筛选规则</h1><p>有些人按照上面默认的规则修改代码之后感觉清爽了不少，而有些人却更加郁闷了，因为这些规则是google内部自己根据需要制定的，并不能满足所有人的需求，所以自己需要有目的的做出选择，比如我就决定项目中不写版权信息，那么再使用<code>cpplint</code> 时可以把检测版权信息的规则过滤掉：<code>cpplint --filter=&quot;-legal/copyright&quot; .\teststyle.cpp</code>。</p><h1 id="对照表格"><a href="#对照表格" class="headerlink" title="对照表格"></a>对照表格</h1><p>总体来说规则还是很多的，想要在一段代码中展示出所有的情况不太容易，所以整理了下面的表格，对一些规则做了解释，因为有些情况我也没有遇到，所以先空着，后面再慢慢补充，这也是做这篇总结的目的，当有一种规则需求时先来查一下，越来越完整。</p><table><thead><tr><th style="text-align:left">filter</th><th style="text-align:left">解释</th></tr></thead><tbody><tr><td style="text-align:left">build/class</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">build/c++11</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">build/c++14</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">build/c++tr1</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">build/deprecated</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">build/endif_comment</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">build/explicit_make_pair</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">build/forward_decl</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">build/header_guard</td><td style="text-align:left">①头文件需要添加只被包含一次的宏，<code>#ifndef</code>、<code>#define</code></td></tr><tr><td style="text-align:left">build/include</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">build/include_subdir</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">build/include_alpha</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">build/include_order</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">build/include_what_you_use</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">build/namespaces_headers</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">build/namespaces_literals</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">build/namespaces</td><td style="text-align:left">①不要引入整个命名空间，仅引入需要使用的成员</td></tr><tr><td style="text-align:left">build/printf_format</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">build/storage_class</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">legal/copyright</td><td style="text-align:left">①文件中缺少版权信息</td></tr><tr><td style="text-align:left">readability/alt_tokens</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">readability/braces</td><td style="text-align:left">①如果if一个分支包含大括号，那么其他分支也应该包括大括号</td></tr><tr><td style="text-align:left">readability/casting</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">readability/check</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">readability/constructors</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">readability/fn_size</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">readability/inheritance</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">readability/multiline_comment</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">readability/multiline_string</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">readability/namespace</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">readability/nolint</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">readability/nul</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">readability/strings</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">readability/todo</td><td style="text-align:left">①TODO注释中应包括用户名</td></tr><tr><td style="text-align:left">readability/utf8</td><td style="text-align:left">①文件应该使用utf8编码</td></tr><tr><td style="text-align:left">runtime/arrays</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">runtime/casting</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">runtime/explicit</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">runtime/int</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">runtime/init</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">runtime/invalid_increment</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">runtime/member_string_references</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">runtime/memset</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">runtime/indentation_namespace</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">runtime/operator</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">runtime/printf</td><td style="text-align:left">①使用sprintf替换strcpy、strcat</td></tr><tr><td style="text-align:left">runtime/printf_format</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">runtime/references</td><td style="text-align:left">①确认是否要使用常引用</td></tr><tr><td style="text-align:left">runtime/string</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">runtime/threadsafe_fn</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">runtime/vlog</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">whitespace/blank_line</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">whitespace/braces</td><td style="text-align:left">①左大括号应该放在上一行末尾</td></tr><tr><td style="text-align:left">whitespace/comma</td><td style="text-align:left">①逗号后面应该有空格</td></tr><tr><td style="text-align:left">whitespace/comments</td><td style="text-align:left">①//后应该紧跟着一个空格</td></tr><tr><td style="text-align:left">whitespace/empty_conditional_body</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">whitespace/empty_if_body</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">whitespace/empty_loop_body</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">whitespace/end_of_line</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">whitespace/ending_newline</td><td style="text-align:left">①文件末尾需要空行</td></tr><tr><td style="text-align:left">whitespace/forcolon</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">whitespace/indent</td><td style="text-align:left">①public、protected、private前需要1个空格</td></tr><tr><td style="text-align:left">whitespace/line_length</td><td style="text-align:left">①代码行长度有限制</td></tr><tr><td style="text-align:left">whitespace/newline</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">whitespace/operators</td><td style="text-align:left">①操作符前后需要有空格</td></tr><tr><td style="text-align:left">whitespace/parens</td><td style="text-align:left">①if、while、for、switch后的小括号前需要有空格。②小括号中的首个参数前和最后参数尾不应有空格</td></tr><tr><td style="text-align:left">whitespace/semicolon</td><td style="text-align:left">①分号后缺少空格，比如<code>{ return 1;}</code></td></tr><tr><td style="text-align:left">whitespace/tab</td><td style="text-align:left">①使用空格代替tab</td></tr><tr><td style="text-align:left">whitespace/todo</td><td style="text-align:left">①TODO注释前空格太多。②TODO注释中用户名后应该有一个空格</td></tr></tbody></table><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li><code>cpplint</code> 是一个检查c++代码风格的小工具</li><li><code>cpplint.py</code> 其实是一个Python脚本文件，使用前可以先安装Python环境</li><li>使用 <code>cpplint</code> 时默认遵循的是<a href="https://google.github.io/styleguide/cppguide.html" target="_blank" rel="noopener">Google的代码风格</a></li><li>为了让代码检测符合自己的习惯，需要使用<code>--filter=</code>参数选项，有多种规则可以选择或者忽略</li><li><code>--filter=</code>中的规则是一个大类，比如 <code>whitespace/parens</code> 既检查小括号前缺少空格的情况，也会检查小括号中多空格的情况</li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/117393224" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>生活中会有一些感悟的瞬间，娃娃哭闹时大人们总是按照自己的经验来出处理，碰上倔脾气小孩往往毫无作用。其实孩子是最单纯的，想要什么不想要什么都摆在脸上，愿望一旦被满足立马就不哭了，而大人才世界是难处理的，长大的人类善于隐藏和伪装，想要的不一定说出来，说出来不一定是想要的，所以很多人才会羡慕小孩子的天真和无邪~</p><p>努力吧！哪管什么真理无穷，进一步有进一步的欢喜</p><p>2021-6-20 18:46:45</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&lt;code&gt;cpplint&lt;/code&gt; 是一款优秀的代码格式检查工具，有了它可以统一整个团队的代码风格，完整的工具就是一个Python脚本，如果安装了Python环境，直接使用 &lt;code&gt;pip install cpplint&lt;/code&gt; 命令就可以安装了，非常的方便。&lt;/p&gt;
    
    </summary>
    
      <category term="C/C++" scheme="http://AlbertGithubHome.github.io/blog/categories/C-C/"/>
    
    
      <category term="C/C++" scheme="http://AlbertGithubHome.github.io/blog/tags/C-C/"/>
    
      <category term="Python" scheme="http://AlbertGithubHome.github.io/blog/tags/Python/"/>
    
      <category term="cpplint" scheme="http://AlbertGithubHome.github.io/blog/tags/cpplint/"/>
    
      <category term="filter" scheme="http://AlbertGithubHome.github.io/blog/tags/filter/"/>
    
  </entry>
  
  <entry>
    <title>C++对我来说简直就是星辰大海，为了避免翻船，我选择从小河沟出发</title>
    <link href="http://AlbertGithubHome.github.io/blog/2021/05/24/C-%E5%AF%B9%E6%88%91%E6%9D%A5%E8%AF%B4%E7%AE%80%E7%9B%B4%E5%B0%B1%E6%98%AF%E6%98%9F%E8%BE%B0%E5%A4%A7%E6%B5%B7/"/>
    <id>http://AlbertGithubHome.github.io/blog/2021/05/24/C-对我来说简直就是星辰大海/</id>
    <published>2021-05-24T14:36:30.000Z</published>
    <updated>2021-05-27T16:42:25.666Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>你学的越多，不懂的东西反而越多~</p></blockquote><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>以前觉得 C++ 并没有什么复杂的，不就是 C 语言加上类定义、模板、容器、算法函数这些就可以了吗，只要我不用，它就难不倒我，用到了查查文档也就搞定了，真的是年少轻狂啊。</p><a id="more"></a><p>随着学习的深入渐渐发现，即使抛开那些算法函数、那些冗长的模板，单单是 C++ 核心的概念和类型就够喝上好几壶的，随便罗列几个，像 <code>std::furnitrue</code>、<code>std::memory_order</code>、<code>std::packaged_task</code> 等等这些，之前都没听说过，特别是C++20的协程，到现在还是一头雾水。</p><p>C++ 缺少了 C 语言的纯粹，总是喜欢在编译时加点料，但是这个协程加的料超多，一时间还有点接受不了。</p><p>不过第一次听说协程这个词是在 Lua 中，全称被叫做协同程序，记得没错是在 《Lua程序设计》这本书中看到的，里面专门有一章是讲coroutine的，并且在 Lua 中定义和使用协程很方便，所以决定先复习一下 Lua 中的协程，然后对比着 C++的协程来进行拓展学习。</p><h1 id="进程-vs-线程-vs-协程"><a href="#进程-vs-线程-vs-协程" class="headerlink" title="进程 vs 线程 vs 协程"></a>进程 vs 线程 vs 协程</h1><p>这三者常常被拿来比较，而引入多进程、多线程、多协程有一个简单而纯粹的目的，那就是榨干CPU，不过这三者侧重还有所不同。</p><p>进程是资源分配最小单位，每个进程都有独立的地址空间，来维护代码段、堆栈段和数据段，但是创建和切换进程的开销较大，可以在多台物理机和多核CPU上提高效率，依靠管道（pipe）、命名管道（named pipe/FIFO）、信号量（semophore）、消息队列（message queue）、信号（sinal）、共享内存（shared memory）、套接字（socket）、全双工管道等途径来进行通信。</p><p>线程是任务调度和执行的最小单位，没有独立的地址空间，但有独立的运行栈和程序计数器（PC），创建和切换线程的开销相比进程来说要小得多，线程之间通信更加方便，除了可以使用进程间通信的方式，还可以简单地通过共享全局变量，静态变量等进行通信，但是需要锁机制、信号量机制、信号机制来控制线程间互斥。</p><p>协程这个概念就比较迷了，其实它不像多进程和多线程那样可以在多核机器上提供并行的能力，而是侧重于相互协作共同完成某个任务，同一个线程中可以启动多个协程，但这些协程同一时刻只能有一个在运行。</p><p>协程其实可以看成是一个可以被随时停止和唤醒的函数，使用协程是为了在用户层面来控制调用逻辑，对比于多线程程序的线程调度完全看操作系统的心情的处境，多协程的程序就比较自主了，可以由开发者来控制函数执行顺序。</p><p>还有一个特性很重要，就是使用协程可以实现用“同步”的方式来写“异步”的代码，这一点不理解没关系，以后会慢慢明白的。说到这，不得不说一下关于同步和异步、阻塞和非阻塞这几个概念，它们常常被大家混在一起来说，实际上只是从不同维度来描述了一件事情，下面简单叙述下。</p><h1 id="同步-vs-异步"><a href="#同步-vs-异步" class="headerlink" title="同步 vs 异步"></a>同步 vs 异步</h1><p>同步和异步指的是消息通信的机制，或者说得到结果的方式。</p><ul><li><p>同步：调用函数后就能返回想要的结果，有点像去食堂买饭，自己去食堂付完钱（调用），饭（结果）就可以被拿回来了，这就是同步调用的方式，与返回结果的时间长短无关，得到结果之后直接执行后面的逻辑（吃饭）就可以了，所以同步的逻辑是最好写的。</p></li><li><p>异步：调用函数后并不能直接得到想要的结果，需要通过回调或者其他消息来通知，这就有点像定外卖了，打开APP选好饭菜输入地址（注册回调），开始付钱（调用），此时并不能直接得到饭（结果），而是一段时间之后，有外卖小哥将饭（结果）给你送来，这时才能执行后面的逻辑（吃饭）。</p></li></ul><p>总结来说，需要自己取结果的就是同步，依靠别人送结果的就是异步。</p><h1 id="阻塞-vs-非阻塞"><a href="#阻塞-vs-非阻塞" class="headerlink" title="阻塞 vs 非阻塞"></a>阻塞 vs 非阻塞</h1><p>阻塞和非阻塞指的是程序在等待调用结果时的状态，强调在获得结果之前的表现。</p><ul><li><p>阻塞：调用函数后由于不满足某种条件（比如读socket但是没有数据）被挂起，当条件满足（socket来数据了）时被唤醒，并将结果返回。</p></li><li><p>非阻塞：调用函数后如果不满足指定条件（比如读socket但是没有数据）不挂起，而是返回一个表示没有取到结果的值，你可以按照某种间隔再次调用函数，直到取到结果为止，当然你也可以调用一次就结束了。</p></li></ul><p>总结来说，不满足条件时调用方被挂起就是阻塞调用，否则就是非阻塞调用。</p><h1 id="协程学习"><a href="#协程学习" class="headerlink" title="协程学习"></a>协程学习</h1><p>C++的协程是暂时学不明白了，为了不翻车，我还是从熟悉的 Lua 入手，来举例说明什么是协程？有什么用？为什么这样用？弄明白以后再慢慢用 C++ 来实现相同的目的，毕竟 C++ 这一块需要实现的内容也有点多。</p><h2 id="消费者-生产者"><a href="#消费者-生产者" class="headerlink" title="消费者-生产者"></a>消费者-生产者</h2><p>提到 Lua 的协程就会想到 “消费者-生产者”的例子，网上关于这个的实现有特别多的版本，整体上来说大同小异，基本上都是 《C++程序设计》这本书中的内容，但是这一部分我看了很多遍，感觉这个例子并不太好。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">receive</span><span class="params">(prod)</span></span>  <span class="comment">-- 激活协同程序</span></span><br><span class="line">  <span class="keyword">local</span> <span class="built_in">status</span>,value = coroutine.<span class="built_in">resume</span>(prod)</span><br><span class="line">  <span class="keyword">return</span> value</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">send</span><span class="params">(x)</span></span>  <span class="comment">-- 挂起协同程序</span></span><br><span class="line">  coroutine.<span class="built_in">yield</span>(x)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">producer</span><span class="params">()</span></span>  <span class="comment">-- 生产者</span></span><br><span class="line">  <span class="keyword">return</span> coroutine.<span class="built_in">create</span>(  <span class="comment">-- 创建协同程序</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">          <span class="keyword">while</span> <span class="literal">true</span> <span class="keyword">do</span></span><br><span class="line">              <span class="keyword">local</span> x = <span class="built_in">io</span>.<span class="built_in">read</span>()  <span class="comment">-- 产生新值</span></span><br><span class="line">              send(x)</span><br><span class="line">          <span class="keyword">end</span></span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">  )</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">filter</span><span class="params">(prod)</span></span>  <span class="comment">-- 过滤器</span></span><br><span class="line">  <span class="keyword">return</span> coroutine.<span class="built_in">create</span>(  <span class="comment">-- 创建协同程序</span></span><br><span class="line">      <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">          <span class="keyword">for</span> line = <span class="number">1</span>, <span class="built_in">math</span>.<span class="built_in">huge</span> <span class="keyword">do</span></span><br><span class="line">              <span class="keyword">local</span> x = receive(prod)  <span class="comment">-- 激活协同程序来获取新值</span></span><br><span class="line">              x = <span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">"%5d %s"</span>,line , x )  <span class="comment">-- 过滤规则</span></span><br><span class="line">              send(x)  <span class="comment">-- 挂起激活程序</span></span><br><span class="line">          <span class="keyword">end</span></span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">  )</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">consumer</span><span class="params">(prod)</span></span></span><br><span class="line">  <span class="keyword">while</span> <span class="literal">true</span> <span class="keyword">do</span></span><br><span class="line">      <span class="keyword">local</span> x = receive(prod) <span class="comment">-- 获取新值</span></span><br><span class="line">      <span class="built_in">io</span>.<span class="built_in">write</span>(x, <span class="string">"\n"</span>)       <span class="comment">-- 消费新值</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">p= producer()  <span class="comment">-- 初始化生产者</span></span><br><span class="line">f = filter(p)  <span class="comment">-- 初始化过滤器</span></span><br><span class="line">consumer(f)    <span class="comment">-- 初始化消费者并启动程序</span></span><br></pre></td></tr></table></figure><p>这就是一个消费者驱动的模型，首先由启动消费者，然后调用生产者来生产资源，接着消费者消耗掉新的资源，再控制生产者生产新的资源，以此方式循环往复，其实就是下面代码的复杂化：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">consumer_producer</span><span class="params">()</span></span></span><br><span class="line">  <span class="keyword">while</span> <span class="literal">true</span> <span class="keyword">do</span></span><br><span class="line">      <span class="keyword">local</span> x = <span class="built_in">io</span>.<span class="built_in">read</span>()  <span class="comment">-- 产生新值</span></span><br><span class="line">      <span class="built_in">io</span>.<span class="built_in">write</span>(x, <span class="string">"\n"</span>)    <span class="comment">-- 消费新值</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">consumer_producer() <span class="comment">-- 启动生产者消费者</span></span><br></pre></td></tr></table></figure><p>这个例子以我现在的菜鸟水平来看没啥用，但是有一点比较好，就是展示了可以用协程来控制程序执行顺序的强大功能，只是这个消费者和生产者强耦合的设计实在是看不明白。</p><h2 id="自己想个例子"><a href="#自己想个例子" class="headerlink" title="自己想个例子"></a>自己想个例子</h2><p>既然他们的例子我都不喜欢，那我就自己想一个，叮铃铃！下面我收到了一个新的需求：</p><blockquote><p>计算1+2+3+4+5+6+7+8+9+10的和，然后等待5秒钟后，将结果显示在控制台上。</p></blockquote><p>乍一听，这个需求太简单了吧，没有一点难度，其实不然，其中蕴含着大量玄机，简直就是一个万能句式：</p><blockquote><p>做一件事情A，然后等待某件事发生，再做一件事情B（可能与A相关）</p></blockquote><p>仔细想想，这样的“句式”在开发中，生活中是不是经常出现？</p><ol><li>下载电影，下载完成后，播放电影</li><li>开始加载场景，加载完成后，隐藏加载进度条</li><li>发送一个请求，收到回复时，将回复结果显示出来</li><li>…</li></ol><p>看了吧，现实中有很多这类需求，我们接下来尝试着实现一下</p><h3 id="常规写法"><a href="#常规写法" class="headerlink" title="常规写法"></a>常规写法</h3><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- lua 没有 sleep 函数，使用while循环模拟</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sleep</span><span class="params">(n)</span></span></span><br><span class="line">    <span class="keyword">local</span> t = <span class="built_in">os</span>.<span class="built_in">clock</span>()</span><br><span class="line">    <span class="keyword">while</span> <span class="built_in">os</span>.<span class="built_in">clock</span>() - t &lt;= n <span class="keyword">do</span> <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">task_method_1</span><span class="params">()</span></span></span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">"program start at %s"</span>, <span class="built_in">os</span>.<span class="built_in">date</span>(<span class="string">"%H:%M:%S"</span>)))</span><br><span class="line"></span><br><span class="line">    <span class="comment">-- 求和</span></span><br><span class="line">    <span class="keyword">local</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> i=<span class="number">1</span>,<span class="number">10</span> <span class="keyword">do</span></span><br><span class="line">        sum = sum + i;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">-- 等待</span></span><br><span class="line">    sleep(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">-- 展示</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">"program end at %s and sum = %d"</span>, <span class="built_in">os</span>.<span class="built_in">date</span>(<span class="string">"%H:%M:%S"</span>), sum))</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">main1</span><span class="params">()</span></span></span><br><span class="line">    task_method_1()</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">main1()</span><br></pre></td></tr></table></figure><p>代码很简单，为了看起来更连贯这里就不分段展示了，首先模拟一个 <code>sleep</code> 函数，然后实现 <code>task_method_1</code> 函数来完成原始需求——求和、等待、展示，最后通过主函数来调用就可以了。</p><p>运行结果如下:</p><blockquote><p>program start at 01:30:27<br>program end at 01:30:32 and sum = 55</p></blockquote><h3 id="进阶写法"><a href="#进阶写法" class="headerlink" title="进阶写法"></a>进阶写法</h3><p>看了上面的代码有没有发现什么问题？这是一种同步的实现方式，整个程序在中间等待的5秒钟什么都不能做，必须等倒计时结束才能做后面的事情，这要是购物APP点了5秒没反应就直接X掉了，这可是赤果果的金钱损失啊，绝不能让这种事情发生。</p><p>怎么办呢？我确实需要5秒钟的处理时间，但是又不能让用户卡在那，我可以显示一个进度条，进度一直再变化，用户就不会以为程序卡死了，如果进度走的比较慢，他可能以为手机老旧该换了，没准还促进了手机的销量呢！</p><p>顺着这个思路写出了下面这种实现，这是一种异步的实现方式，通过回调函数来通知最终要显示的结果。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">task_method_2</span><span class="params">()</span></span></span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">"program start at %s"</span>, <span class="built_in">os</span>.<span class="built_in">date</span>(<span class="string">"%H:%M:%S"</span>)))</span><br><span class="line"></span><br><span class="line">    <span class="comment">-- 求和</span></span><br><span class="line">    <span class="keyword">local</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> i=<span class="number">1</span>,<span class="number">10</span> <span class="keyword">do</span></span><br><span class="line">        sum = sum + i;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">-- 注册回调函数，进行等待</span></span><br><span class="line">    add_callback(<span class="number">5</span>, call_back_print, sum)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">call_back_print</span><span class="params">(data)</span></span></span><br><span class="line">    <span class="comment">--展示结果</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">"program end at %s and sum = %d"</span>, <span class="built_in">os</span>.<span class="built_in">date</span>(<span class="string">"%H:%M:%S"</span>), data))</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add_callback</span><span class="params">(inteval, func, data)</span></span></span><br><span class="line">    interval_time = inteval</span><br><span class="line">    call_back = func</span><br><span class="line">    msg_data = data</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">main2</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">local</span> t0 = <span class="built_in">os</span>.<span class="built_in">clock</span>();</span><br><span class="line">    <span class="keyword">local</span> t = t0;</span><br><span class="line"></span><br><span class="line">    task_method_2()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">true</span> <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">local</span> now = <span class="built_in">os</span>.<span class="built_in">clock</span>()</span><br><span class="line">        <span class="keyword">if</span> now - t &gt;= <span class="number">1</span> <span class="keyword">then</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">"program run %f seconds"</span>, now - t0))</span><br><span class="line">            t = now;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> interval_time <span class="keyword">and</span> call_back <span class="keyword">and</span> now - t0 &gt;= interval_time <span class="keyword">then</span></span><br><span class="line">                call_back(msg_data)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">main2()</span><br></pre></td></tr></table></figure><p>在函数 <code>task_method_2</code> 中计算完求和的结果，并没有等待，而是通过 <code>add_callback</code> 函数注册了等待时间、回调函数、以及回调展示的结果，然后直接返回了调用方，调用主函数 <code>main2</code> 中计算这时间差并展示进度，等倒计时一结束就执行回调函数，进而展示出结果。</p><p>运行结果如下，通过打印信息展示处理进度条:</p><blockquote><p>program start at 01:44:56<br>program run 1.000000 seconds<br>program run 2.001000 seconds<br>program run 3.001000 seconds<br>program run 4.001000 seconds<br>program run 5.001000 seconds<br>program end at 01:45:01 and sum = 55</p></blockquote><h3 id="协程写法"><a href="#协程写法" class="headerlink" title="协程写法"></a>协程写法</h3><p>卡顿的问题解决了，但是添加了一大堆额外的注册和回调函数，有些麻烦啊，怎么把它们去掉呢？</p><p>终于等到协程出场了，同步调用很卡、异步回调很烦，那么协程可以实现用“同步”的方式来写“异步”的代码，既不卡也不烦，下面来看一下实现。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">task_method_3</span><span class="params">()</span></span></span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">"program start at %s"</span>, <span class="built_in">os</span>.<span class="built_in">date</span>(<span class="string">"%H:%M:%S"</span>)))</span><br><span class="line"></span><br><span class="line">    <span class="comment">-- 求和</span></span><br><span class="line">    <span class="keyword">local</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> i=<span class="number">1</span>,<span class="number">10</span> <span class="keyword">do</span></span><br><span class="line">        sum = sum + i;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">-- 等待</span></span><br><span class="line">    coroutine.<span class="built_in">yield</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">-- 展示</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">"program end at %s and sum = %d"</span>, <span class="built_in">os</span>.<span class="built_in">date</span>(<span class="string">"%H:%M:%S"</span>), sum))</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">main3</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">local</span> t0 = <span class="built_in">os</span>.<span class="built_in">clock</span>();</span><br><span class="line">    <span class="keyword">local</span> t = t0;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">local</span> co = coroutine.<span class="built_in">create</span>(task_method_3)</span><br><span class="line">    <span class="keyword">local</span> <span class="built_in">status</span>, interval = coroutine.<span class="built_in">resume</span>(co)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">true</span> <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">local</span> now = <span class="built_in">os</span>.<span class="built_in">clock</span>()</span><br><span class="line">        <span class="keyword">if</span> now - t &gt;= <span class="number">1</span> <span class="keyword">then</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">"program run %f seconds"</span>, now - t0))</span><br><span class="line">            t = now;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> now - t0 &gt;= interval <span class="keyword">then</span></span><br><span class="line">                coroutine.<span class="built_in">resume</span>(co)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">main3()</span><br></pre></td></tr></table></figure><p>对比 <code>task_method_3</code> 和 <code>task_method_1</code> 函数，只是将 <code>sleep</code> 函数换成了 <code>coroutine.yield(5)</code>，整个需求函数很紧凑。</p><p>程序运行逻辑是这样的，先将 <code>task_method_3</code> 函数包装成协程 <code>co</code>，然后启动 <code>co</code> 执行求和逻辑，执行到 <code>coroutine.yield(5);</code> 这句，协程被暂停并将5返回，主函数 <code>main3</code> 中收到返回值5后开始计时并展示进度值，直到5秒等待期结束再次唤醒协程 <code>co</code>，<code>coroutine.yield(5);</code> 后面的代码继续执行，完成最后的展示需求。</p><p>运行结果如下：</p><blockquote><p>program start at 01:50:59<br>program run 1.000000 seconds<br>program run 2.000000 seconds<br>program run 3.000000 seconds<br>program run 4.000000 seconds<br>program run 5.000000 seconds<br>program end at 01:51:04 and sum = 55</p></blockquote><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>多进程/多线程的引入并不是总能降低任务消耗的时间，还要考虑到进程/线程切换的消耗问题，参考Redis实现</li><li>多协程的引入本质上是为了更好的控制程序运行的逻辑，虽然它往往也能带来效率上的提升</li><li><code>coroutine.yield</code> 是协程的中核心函数，主动让出CPU，如果协程不自己挂起，外部无法干预</li><li>知识的迁移是一项重要的技能，下一步要用C++协程来实现这个需求啦，边学边写喽</li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/116868211" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>拨开那一片云，是你未曾实现的梦想，岁月流转，梦想在变，有些事不得不放弃坚守（固执），珍惜眼前的一切，迎接明天的朝阳~</p><p>2021-5-28 00:27:18</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;你学的越多，不懂的东西反而越多~&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;以前觉得 C++ 并没有什么复杂的，不就是 C 语言加上类定义、模板、容器、算法函数这些就可以了吗，只要我不用，它就难不倒我，用到了查查文档也就搞定了，真的是年少轻狂啊。&lt;/p&gt;
    
    </summary>
    
      <category term="C/C++" scheme="http://AlbertGithubHome.github.io/blog/categories/C-C/"/>
    
    
      <category term="C/C++" scheme="http://AlbertGithubHome.github.io/blog/tags/C-C/"/>
    
      <category term="recursion" scheme="http://AlbertGithubHome.github.io/blog/tags/recursion/"/>
    
      <category term="C++20" scheme="http://AlbertGithubHome.github.io/blog/tags/C-20/"/>
    
      <category term="coruntine" scheme="http://AlbertGithubHome.github.io/blog/tags/coruntine/"/>
    
  </entry>
  
  <entry>
    <title>使用AddressSanitizer搭配addr2line查找C/C++内存泄漏问题</title>
    <link href="http://AlbertGithubHome.github.io/blog/2021/05/15/%E4%BD%BF%E7%94%A8AddressSanitizer%E6%90%AD%E9%85%8Daddr2line%E6%9F%A5%E6%89%BEC-C-%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E9%97%AE%E9%A2%98/"/>
    <id>http://AlbertGithubHome.github.io/blog/2021/05/15/使用AddressSanitizer搭配addr2line查找C-C-内存泄漏问题/</id>
    <published>2021-05-15T07:23:13.000Z</published>
    <updated>2021-07-10T08:37:32.945Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>指针是C/C++程序中的利器，同时也引入了风险，现代C++中增加了智能指针来降低使用“裸”指针带来的风险，但是智能指针不是一颗银弹，它不能解决所有的指针问题，内存泄漏在C/C++程序开发中依旧是值得注意的，学会合理、合适的方法来查找内存泄漏问题也是一项有用的技能。</p><p>通常内存泄漏问题会在开发到一定程度时集中检查，一些检测方法长时间不去使用难免会忘记，所以本文记录一种自己常用的检测方法，方便日后查阅。</p><a id="more"></a><h1 id="AddressSanitizer"><a href="#AddressSanitizer" class="headerlink" title="AddressSanitizer"></a>AddressSanitizer</h1><p>AddressSanitizer 是什么东西呢？从名字上直接翻译叫“地址消毒剂”，其实就是用来检查地址问题的。</p><p>它是一款地址问题检测工具，简称 <code>ASAN</code>，开源项目主地址为 <a href="https://github.com/google/sanitizers" target="_blank" rel="noopener">google/sanitizers</a>，是众多检测工具<code>AddressSanitizer</code>, <code>MemorySanitizer</code>, <code>ThreadSanitizer</code>, <code>LeakSanitizer</code> 中的一款，功能非常强大，可以检测出栈上缓冲区溢出、堆上缓冲区溢出、引用已释放内存、内存泄漏等多种地址问题。</p><p>今天想记录的是使用 <code>AddressSanitizer</code> 检测内存泄漏的步骤，其实检测内存泄漏的功能目前已经被基本独立成了 <a href="https://github.com/google/sanitizers/wiki/AddressSanitizerLeakSanitizer" target="_blank" rel="noopener">LeakSanitizer</a>，不过仍可以通过在 AddressSanitizer 工具中通过参数来开启和关闭使用。</p><h1 id="检测步骤"><a href="#检测步骤" class="headerlink" title="检测步骤"></a>检测步骤</h1><p>其实使用 ASAN 检测内存泄漏还是比较简单的，g++4.8 以上的版本自带了 ASAN 工具，只要编译时指定好参数，编译完成后正常启动运行程序就可以了，只不过有些情况下只从检测报告中无法准确定位问题，需要借助一些工具进一步缩小检测范围。</p><h2 id="泄漏发生在可执行程序本身"><a href="#泄漏发生在可执行程序本身" class="headerlink" title="泄漏发生在可执行程序本身"></a>泄漏发生在可执行程序本身</h2><p>这种情况检测起来比较容易，编写如下测试代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//test.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>* p = <span class="keyword">new</span> <span class="keyword">int</span>(); <span class="comment">// 内存泄漏的位置</span></span><br><span class="line">    p = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    func();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"test leak"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用g++进行编译，编译时添加参数 <code>-fsanitize=leak</code> 就可以了，启动后可以清晰的展示出内存泄漏的位置 <code>test.cpp:5</code>，也就是 test.cpp 文件的第5行。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:/mnt/d/data/cpp/testleak$ g++ test.cpp -g -o <span class="built_in">test</span> --std=c++11 -fsanitize=leak</span><br><span class="line">albert@home-pc:/mnt/d/data/cpp/testleak$ ./<span class="built_in">test</span></span><br><span class="line"><span class="built_in">test</span> leak</span><br><span class="line"></span><br><span class="line">=================================================================</span><br><span class="line">==344==ERROR: LeakSanitizer: detected memory leaks</span><br><span class="line"></span><br><span class="line">Direct leak of 4 byte(s) <span class="keyword">in</span> 1 object(s) allocated from:</span><br><span class="line">    <span class="comment">#0 0x7fc7d796d815 in operator new(unsigned long) (/usr/lib/x86_64-linux-gnu/liblsan.so.0+0xd815)</span></span><br><span class="line">    <span class="comment">#1 0x400967 in func() /mnt/d/data/cpp/testleak/test.cpp:5</span></span><br><span class="line">    <span class="comment">#2 0x400985 in main /mnt/d/data/cpp/testleak/test.cpp:11</span></span><br><span class="line">    <span class="comment">#3 0x7fc7d722083f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x2083f)</span></span><br><span class="line"></span><br><span class="line">SUMMARY: LeakSanitizer: 4 byte(s) leaked <span class="keyword">in</span> 1 allocation(s).</span><br><span class="line">albert@home-pc:/mnt/d/data/cpp/testleak$</span><br></pre></td></tr></table></figure><p>这里有个小意外，将 <code>int* p = new int();</code> 这句代码改成 <code>int* p = new int[10];</code> 可以检测出内存泄漏如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:/mnt/d/data/cpp/testleak$ g++ test.cpp -fsanitize=leak -g -o <span class="built_in">test</span> --std=c++11</span><br><span class="line">albert@home-pc:/mnt/d/data/cpp/testleak$ ./<span class="built_in">test</span></span><br><span class="line"><span class="built_in">test</span> leak</span><br><span class="line"></span><br><span class="line">=================================================================</span><br><span class="line">==416==ERROR: LeakSanitizer: detected memory leaks</span><br><span class="line"></span><br><span class="line">Direct leak of 400 byte(s) <span class="keyword">in</span> 1 object(s) allocated from:</span><br><span class="line">    <span class="comment">#0 0x7fdc0c16d975 in operator new[](unsigned long) (/usr/lib/x86_64-linux-gnu/liblsan.so.0+0xd975)</span></span><br><span class="line">    <span class="comment">#1 0x400967 in func() /mnt/d/data/cpp/testleak/test.cpp:5</span></span><br><span class="line">    <span class="comment">#2 0x40097f in main /mnt/d/data/cpp/testleak/test.cpp:11</span></span><br><span class="line">    <span class="comment">#3 0x7fdc0ba2083f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x2083f)</span></span><br><span class="line"></span><br><span class="line">SUMMARY: LeakSanitizer: 400 byte(s) leaked <span class="keyword">in</span> 1 allocation(s).</span><br><span class="line">albert@home-pc:/mnt/d/data/cpp/testleak$</span><br></pre></td></tr></table></figure><p>但是将 <code>int* p = new int();</code> 这句代码改成 <code>int* p = new int[1024];</code> 就无法检测是内存泄漏了，只能修改编译选项为 <code>-fsanitize=address</code> 才能检测出泄漏，目前还不知道真正的原因是什么。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:/mnt/d/data/cpp/testleak$ g++ test.cpp -fsanitize=address -g -o <span class="built_in">test</span> --std=c++11</span><br><span class="line">albert@home-pc:/mnt/d/data/cpp/testleak$ ./<span class="built_in">test</span></span><br><span class="line"><span class="built_in">test</span> leak</span><br><span class="line"></span><br><span class="line">=================================================================</span><br><span class="line">==432==ERROR: LeakSanitizer: detected memory leaks</span><br><span class="line"></span><br><span class="line">Direct leak of 4096 byte(s) <span class="keyword">in</span> 1 object(s) allocated from:</span><br><span class="line">    <span class="comment">#0 0x7f1d42b296b2 in operator new[](unsigned long) (/usr/lib/x86_64-linux-gnu/libasan.so.2+0x996b2)</span></span><br><span class="line">    <span class="comment">#1 0x400b27 in func() /mnt/d/data/cpp/testleak/test.cpp:5</span></span><br><span class="line">    <span class="comment">#2 0x400b3f in main /mnt/d/data/cpp/testleak/test.cpp:11</span></span><br><span class="line">    <span class="comment">#3 0x7f1d4235083f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x2083f)</span></span><br><span class="line"></span><br><span class="line">SUMMARY: AddressSanitizer: 4096 byte(s) leaked <span class="keyword">in</span> 1 allocation(s).</span><br><span class="line">albert@home-pc:/mnt/d/data/cpp/testleak$</span><br></pre></td></tr></table></figure><h2 id="泄漏发生在编译所需动态库中"><a href="#泄漏发生在编译所需动态库中" class="headerlink" title="泄漏发生在编译所需动态库中"></a>泄漏发生在编译所需动态库中</h2><p>如果内存泄漏发生在编译时使用的动态库中，那么这和上一种情况基本一致，可以直接编译后运行就能发现，测试代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// myadd.h</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// myadd.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"myadd.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>* p = <span class="keyword">new</span> <span class="keyword">int</span>(); <span class="comment">// 内存泄漏的位置</span></span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"myadd.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"519 + 1 = "</span> &lt;&lt; add(<span class="number">519</span>, <span class="number">1</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加编译选项 <code>-fsanitize=leak</code> 编译后运行，也可以直接显示出内存泄漏的位置，内存泄漏在 <code>libmyadd.so</code> 动态库中的 <code>add</code> 函数中。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:/mnt/d/data/cpp/testleak$ g++ -shared -fPIC -o libmyadd.so myadd.cpp</span><br><span class="line">albert@home-pc:/mnt/d/data/cpp/testleak$ g++ test3.cpp -L. -lmyadd -o <span class="built_in">test</span> -Wl,-rpath=. -fsanitize=leak</span><br><span class="line">albert@home-pc:/mnt/d/data/cpp/testleak$ ./<span class="built_in">test</span></span><br><span class="line">519 + 1 = 520</span><br><span class="line"></span><br><span class="line">=================================================================</span><br><span class="line">==493==ERROR: LeakSanitizer: detected memory leaks</span><br><span class="line"></span><br><span class="line">Direct leak of 4 byte(s) <span class="keyword">in</span> 1 object(s) allocated from:</span><br><span class="line">    <span class="comment">#0 0x7ff1aff6d815 in operator new(unsigned long) (/usr/lib/x86_64-linux-gnu/liblsan.so.0+0xd815)</span></span><br><span class="line">    <span class="comment">#1 0x7ff1afd506b7 in add(int, int) (libmyadd.so+0x6b7)</span></span><br><span class="line">    <span class="comment">#2 0x4009cd in main (/mnt/d/data/cpp/testleak/test+0x4009cd)</span></span><br><span class="line">    <span class="comment">#3 0x7ff1af61083f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x2083f)</span></span><br><span class="line"></span><br><span class="line">SUMMARY: LeakSanitizer: 4 byte(s) leaked <span class="keyword">in</span> 1 allocation(s).</span><br><span class="line">albert@home-pc:/mnt/d/data/cpp/testleak$</span><br></pre></td></tr></table></figure><h2 id="泄漏发生在自定义加载的动态库中"><a href="#泄漏发生在自定义加载的动态库中" class="headerlink" title="泄漏发生在自定义加载的动态库中"></a>泄漏发生在自定义加载的动态库中</h2><p>这种情况要想精确定位问题就麻烦一些了，下面是用来测试的代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// myadd.h</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> <span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// myadd.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"myadd.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> <span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>* p = <span class="keyword">new</span> <span class="keyword">int</span>(); <span class="comment">// 内存泄漏的位置</span></span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"myadd.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dlfcn.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*FUNC)</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">void</span>* handle = dlopen(<span class="string">"./libmyadd.so"</span>, RTLD_LAZY);</span><br><span class="line">    FUNC myadd = (FUNC)dlsym(handle,<span class="string">"add"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> nVal = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; nVal;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"519 + 1 = "</span> &lt;&lt; myadd(<span class="number">519</span>, <span class="number">1</span>) &lt;&lt; <span class="string">", input:"</span> &lt;&lt; nVal &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    dlclose(handle);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加编译选项 <code>-fsanitize=leak</code> 编译后运行，输入数字618，程序运行结束，显示内存泄漏出现在 <code>0x7fc88f0f06b7  (&lt;unknown module&gt;)</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:/mnt/d/data/cpp/testleak$ g++ -shared -fPIC -o libmyadd.so myadd.cpp -g</span><br><span class="line">albert@home-pc:/mnt/d/data/cpp/testleak$ g++ test.cpp -ldl -o <span class="built_in">test</span> -Wl,-rpath=. -g -fsanitize=leak</span><br><span class="line">albert@home-pc:/mnt/d/data/cpp/testleak$ ./<span class="built_in">test</span></span><br><span class="line">618</span><br><span class="line">519 + 1 = 520, input:618</span><br><span class="line"></span><br><span class="line">=================================================================</span><br><span class="line">==817==ERROR: LeakSanitizer: detected memory leaks</span><br><span class="line"></span><br><span class="line">Direct leak of 4 byte(s) <span class="keyword">in</span> 1 object(s) allocated from:</span><br><span class="line">    <span class="comment">#0 0x7fc89076d815 in operator new(unsigned long) (/usr/lib/x86_64-linux-gnu/liblsan.so.0+0xd815)</span></span><br><span class="line">    <span class="comment">#1 0x7fc88f0f06b7  (&lt;unknown module&gt;)</span></span><br><span class="line">    <span class="comment">#2 0x400bc2 in main (/mnt/d/data/cpp/testleak/test+0x400bc2)</span></span><br><span class="line">    <span class="comment">#3 0x7fc88fe1083f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x2083f)</span></span><br><span class="line"></span><br><span class="line">SUMMARY: LeakSanitizer: 4 byte(s) leaked <span class="keyword">in</span> 1 allocation(s).</span><br><span class="line">albert@home-pc:/mnt/d/data/cpp/testleak$</span><br></pre></td></tr></table></figure><h3 id="unknown-module"><a href="#unknown-module" class="headerlink" title="unknown module"></a>unknown module</h3><p>当使用 <code>dlopen</code> 的方式加载的动态库时，产生的内存泄漏常显示为 <code>(&lt;unknown module&gt;)</code>，那是因为内存检测工具在程序退出时分析泄漏情况，而这时自定义加载的动态库往往已经手动调用 <code>dlclose</code> 关闭了，这时就会显示成 <code>0x7fc88f0f06b7  (&lt;unknown module&gt;)</code> 的显示。</p><h3 id="maps"><a href="#maps" class="headerlink" title="maps"></a>maps</h3><p>针对于出现 <code>(&lt;unknown module&gt;)</code> 的这种情况，可以通过查询 /proc/pid/maps 来辅助查询，maps 文件显示进程映射后的内存区域和访问权限，是程序正在运行时的信息，数据格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">7f8c7adb6000-7f8c7adba000 rw-p 00000000 00:00 0</span><br><span class="line">7f8c7adc0000-7f8c7af32000 r-xp 00000000 00:00 189413             /usr/lib/x86_64-linux-gnu/libstdc++.so.6.0.21</span><br><span class="line">7f8c7af32000-7f8c7af3f000 ---p 00172000 00:00 189413             /usr/lib/x86_64-linux-gnu/libstdc++.so.6.0.21</span><br><span class="line">7f8c7af3f000-7f8c7b132000 ---p 0017f000 00:00 189413             /usr/lib/x86_64-linux-gnu/libstdc++.so.6.0.21</span><br><span class="line">7f8c7b132000-7f8c7b13c000 r--p 00172000 00:00 189413             /usr/lib/x86_64-linux-gnu/libstdc++.so.6.0.21</span><br><span class="line">7f8c7b13c000-7f8c7b13e000 rw-p 0017c000 00:00 189413             /usr/lib/x86_64-linux-gnu/libstdc++.so.6.0.21</span><br><span class="line">7f8c7b13e000-7f8c7b142000 rw-p 00000000 00:00 0</span><br><span class="line">7f8c7b150000-7f8c7b153000 r-xp 00000000 00:00 243909             /lib/x86_64-linux-gnu/libdl-2.23.so</span><br><span class="line">7f8c7b153000-7f8c7b154000 ---p 00003000 00:00 243909             /lib/x86_64-linux-gnu/libdl-2.23.so</span><br><span class="line">7f8c7b154000-7f8c7b352000 ---p 00004000 00:00 243909             /lib/x86_64-linux-gnu/libdl-2.23.so</span><br><span class="line">7f8c7b352000-7f8c7b353000 r--p 00002000 00:00 243909             /lib/x86_64-linux-gnu/libdl-2.23.so</span><br><span class="line">7f8c7b353000-7f8c7b354000 rw-p 00003000 00:00 243909             /lib/x86_64-linux-gnu/libdl-2.23.so</span><br><span class="line">7f8c7b360000-7f8c7b39f000 r-xp 00000000 00:00 247365             /usr/lib/x86_64-linux-gnu/liblsan.so.0.0.0</span><br><span class="line">7f8c7b39f000-7f8c7b3a2000 ---p 0003f000 00:00 247365             /usr/lib/x86_64-linux-gnu/liblsan.so.0.0.0</span><br><span class="line">7f8c7b3a2000-7f8c7b59e000 ---p 00042000 00:00 247365             /usr/lib/x86_64-linux-gnu/liblsan.so.0.0.0</span><br><span class="line">7f8c7b59e000-7f8c7b5a0000 r--p 0003e000 00:00 247365             /usr/lib/x86_64-linux-gnu/liblsan.so.0.0.0</span><br><span class="line">7f8c7b5a0000-7f8c7b5a1000 rw-p 00040000 00:00 247365             /usr/lib/x86_64-linux-gnu/liblsan.so.0.0.0</span><br><span class="line">7f8c7b5a1000-7f8c7c1f4000 rw-p 00000000 00:00 0</span><br><span class="line">7f8c7c200000-7f8c7c225000 r-xp 00000000 00:00 243945             /lib/x86_64-linux-gnu/ld-2.23.so</span><br><span class="line">7f8c7c225000-7f8c7c226000 r-xp 00025000 00:00 243945             /lib/x86_64-linux-gnu/ld-2.23.so</span><br></pre></td></tr></table></figure><ul><li>第一列：7f8c7b360000-7f8c7b39f000，表示本段内存映射的虚拟地址空间范围。</li><li>第二列：r-xp，表示此段虚拟地址空间的属性。<code>r</code>表示可读，<code>w</code>表示可写，<code>x</code>表示可执行，<code>p</code>和<code>s</code>共用一个字段，互斥关系，<code>p</code>表示私有段，<code>s</code>表示共享段，<code>-</code>表示没有权限。</li><li>第三列：00000000，表示映射偏移。对有名映射，表示此段虚拟内存起始地址在文件中以页为单位的偏移。对匿名映射，它等于0或者vm_start/PAGE_SIZE。</li><li>第四列：00:00，表示映射文件所属设备号。对有名映射来说，是映射的文件所在设备的设备号，对匿名映射来说，因为没有文件在磁盘上，所以没有设备号，始终为00:00。</li><li>第五列：247365，表示映射文件所属节点号。对有名映射来说，是映射的文件的节点号。对匿名映射来说，因为没有文件在磁盘上，所以没有节点号，始终为0。<br>第六列：/usr/lib/x86_64-linux-gnu/liblsan.so.0.0.0，表示映射文件名或堆、栈。对匿名映射来说，是此段虚拟内存在进程中的角色。[stack]表示在进程中作为栈使用，[heap]表示堆。对有名来说，是映射的文件名。其余情况则无显示。</li></ul><blockquote><p>7f8c7b360000-7f8c7b39f000 r-xp 00000000 00:00 247365             /usr/lib/x86_64-linux-gnu/liblsan.so.0.0.0</p></blockquote><p>这一行就展示了 <code>liblsan.so</code> 这个动态库映射的内存中位置和权限情况，<code>liblsan.so</code> 也就是 ASAN 工具用来检测内存泄漏的工具所依赖的动态库。</p><h3 id="具体操作"><a href="#具体操作" class="headerlink" title="具体操作"></a>具体操作</h3><ol><li>启动一个终端，然后运行 test 程序，因为程序中要求从控制台读取一个变量，所以运行后程序会一直停留在控制台等待输入</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:/mnt/d/data/cpp/testleak$ ./<span class="built_in">test</span></span><br></pre></td></tr></table></figure><ol><li>重新打开一个终端，查询 test 程序的进程id，然后拷贝对应的 maps 文件</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:/mnt/d/data/cpp/testleak$ ps -ef | grep <span class="built_in">test</span></span><br><span class="line">albert     986   889  0 21:42 pts/0    00:00:00 ./<span class="built_in">test</span></span><br><span class="line">albert     988   953  0 21:42 pts/1    00:00:00 grep --color=auto <span class="built_in">test</span></span><br><span class="line">albert@home-pc:/mnt/d/data/cpp/testleak$ cp /proc/986/maps testmaps</span><br></pre></td></tr></table></figure><ol><li>在第一个终端中输入数字，程序运行结束，显示出内存泄漏信息</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:/mnt/d/data/cpp/testleak$ ./<span class="built_in">test</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 以下为新的信息，输入了515</span></span><br><span class="line"></span><br><span class="line">515</span><br><span class="line">519 + 1 = 520, input:515</span><br><span class="line"></span><br><span class="line">=================================================================</span><br><span class="line">==986==ERROR: LeakSanitizer: detected memory leaks</span><br><span class="line"></span><br><span class="line">Direct leak of 4 byte(s) <span class="keyword">in</span> 1 object(s) allocated from:</span><br><span class="line">    <span class="comment">#0 0x7f8c7b36d815 in operator new(unsigned long) (/usr/lib/x86_64-linux-gnu/liblsan.so.0+0xd815)</span></span><br><span class="line">    <span class="comment">#1 0x7f8c79cf06b7  (&lt;unknown module&gt;)</span></span><br><span class="line">    <span class="comment">#2 0x400bc2 in main (/mnt/d/data/cpp/testleak/test+0x400bc2)</span></span><br><span class="line">    <span class="comment">#3 0x7f8c7aa1083f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x2083f)</span></span><br><span class="line"></span><br><span class="line">SUMMARY: LeakSanitizer: 4 byte(s) leaked <span class="keyword">in</span> 1 allocation(s).</span><br><span class="line">albert@home-pc:/mnt/d/data/cpp/testleak$</span><br></pre></td></tr></table></figure><ol><li>从检测报告中看到 <code>0x7f8c79cf06b7  (&lt;unknown module&gt;)</code>，在备份的 testmaps 文件中查找范围，发现处于下面一段之中</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">640000000000-640000003000 rw-p 00000000 00:00 0</span><br><span class="line">7f8c79cf0000-7f8c79cf1000 r-xp 00000000 00:00 282                /mnt/d/data/cpp/testleak/libmyadd.so</span><br><span class="line">7f8c79cf1000-7f8c79cf2000 ---p 00001000 00:00 282                /mnt/d/data/cpp/testleak/libmyadd.so</span><br><span class="line">7f8c79cf2000-7f8c79ef0000 ---p 00002000 00:00 282                /mnt/d/data/cpp/testleak/libmyadd.so</span><br><span class="line">7f8c79ef0000-7f8c79ef1000 r--p 00000000 00:00 282                /mnt/d/data/cpp/testleak/libmyadd.so</span><br><span class="line">7f8c79ef1000-7f8c79ef2000 rw-p 00001000 00:00 282                /mnt/d/data/cpp/testleak/libmyadd.so</span><br><span class="line">7f8c79f00000-7f8c7a000000 rw-p 00000000 00:00 0</span><br></pre></td></tr></table></figure><ol><li>至此发现问题出现在 <code>libmyadd.so</code> 这个动态库中，再用 <code>0x7f8c79cf06b7</code> 减去动态链接库基地址 <code>7f8c79cf0000</code>，得到偏移量为 <code>0x6b7</code>，此时使用 addr2line 工具进行转化。</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:/mnt/d/data/cpp/testleak$ addr2line  -C -f -e /mnt/d/data/cpp/testleak/libmyadd.so 0x6b7</span><br><span class="line">add</span><br><span class="line">/mnt/d/data/cpp/testleak/myadd.cpp:4</span><br></pre></td></tr></table></figure><ol><li>至此就找到了内存泄漏的确切位置，在/mnt/d/data/cpp/testleak/myadd.cpp文件第4行的 <code>add</code> 函数之中。</li></ol><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>在 C++11 之后尽可能使用智能指针来管理在堆上申请的内存，<code>shared_ptr</code>、<code>weak_ptr</code>、<code>unique_ptr</code> 能帮我们减少许多麻烦</li><li>想要检测程序内存用用问题， AddressSanitizer 是一个不错的选择，其中有关内存泄漏的检测已经被整合到 LeakSanitizer 工具中</li><li>当程序中的内存泄漏发生在 <code>dlopen</code> 加载的动态库中时，常常出现 <code>(&lt;unknown module&gt;)</code> 的情况，这时需要借助 <code>proc/pid/maps</code> 文件和 addr2line 工具来完成精确定位。</li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/116312788" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>祝融落地。一百年了，还没有什么事情是做不到的，我们需要的是时间，我等着看你们在真正的力量面前瑟瑟发抖~</p><p>2021-5-16 00:08:24</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;指针是C/C++程序中的利器，同时也引入了风险，现代C++中增加了智能指针来降低使用“裸”指针带来的风险，但是智能指针不是一颗银弹，它不能解决所有的指针问题，内存泄漏在C/C++程序开发中依旧是值得注意的，学会合理、合适的方法来查找内存泄漏问题也是一项有用的技能。&lt;/p&gt;
&lt;p&gt;通常内存泄漏问题会在开发到一定程度时集中检查，一些检测方法长时间不去使用难免会忘记，所以本文记录一种自己常用的检测方法，方便日后查阅。&lt;/p&gt;
    
    </summary>
    
      <category term="C/C++" scheme="http://AlbertGithubHome.github.io/blog/categories/C-C/"/>
    
    
      <category term="C/C++" scheme="http://AlbertGithubHome.github.io/blog/tags/C-C/"/>
    
      <category term="linux" scheme="http://AlbertGithubHome.github.io/blog/tags/linux/"/>
    
      <category term="AddressSanitizer" scheme="http://AlbertGithubHome.github.io/blog/tags/AddressSanitizer/"/>
    
      <category term="addr2line" scheme="http://AlbertGithubHome.github.io/blog/tags/addr2line/"/>
    
      <category term="内存泄漏" scheme="http://AlbertGithubHome.github.io/blog/tags/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>linux文件权限简单备忘知识点</title>
    <link href="http://AlbertGithubHome.github.io/blog/2021/04/30/linux%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E7%AE%80%E5%8D%95%E5%A4%87%E5%BF%98%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>http://AlbertGithubHome.github.io/blog/2021/04/30/linux文件权限简单备忘知识点/</id>
    <published>2021-04-29T16:25:12.000Z</published>
    <updated>2021-05-05T14:17:24.015Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>已经拖更好几天了，有些坚持的事情一旦中断便很难再捡起来了，所以还是尽可能的坚持下去，今天就简单记录一下文件权限相关的操作。</p><a id="more"></a><p><img src="https://img-blog.csdnimg.cn/2021050101315534.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NoaWhlbmd6aGVuMTAx,size_16,color_FFFFFF,t_70" alt="file_ls"></p><p>这里先扔出一张图，这么懒的我居然画了一张图！不过前几天感冒状态不太好，这张图画了好几晚上才完成，就凑活看吧。</p><p>基本上看注释就能明白各列的含义，关于“文件硬链接数”这一列还有点疑问，在CentOS上测试，确实如注释所言，普通文件显示的硬链接数，目录文件显示的是第一级子目录的个数，但是在WSL上却不符合这个说法，暂时还没有找到原因，接下来还是列举下文件权限相关的操作吧。</p><h1 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h1><p>在linux系统中的每个用户必须属于一个组，不能独立于组外。而每个文件的权限区分所有者、所在组、其它人，就像图片中展示的那样</p><ul><li>所有者：指创建文件的人，拥有第一组权限</li><li>所在组：指的是和所有者在同组的人，拥有第二组权限</li><li>其他人：指排除掉前两类的其他人，拥有第三组权限</li></ul><p>每组权限都分为读、写、执行三种具体权限，对应数字分别是4、2、1，字母表示为r、w、x，没有权限可以用<code>-</code>表示，也就是0，因为有这些表示方法，修改文件的命令形式也有很多种。</p><p>一个文件的访问权限是可以进行修改的，用户可以使用 <code>chmod</code> 命令来重新设定不同的访问权限，可以使用 <code>chown</code> 命令来更改某个文件或目录的所有者，也可以利用 <code>chgrp</code> 命令来更改某个文件或目录的用户组。</p><h1 id="chmod-命令"><a href="#chmod-命令" class="headerlink" title="chmod 命令"></a>chmod 命令</h1><p>上面说到文件的权限分为所有者、同组人、其他人三组，每组权限又有r、w、x三种权限，分别用数字4、2、1表示，举几个对照的例子如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rwx r-x r–x  755</span><br><span class="line">rw- r–- –--  640</span><br><span class="line">rw- rw- r–-  664</span><br></pre></td></tr></table></figure><p>因为表示的多样性，该命令有通常有字母表达式和数字表达式两种用法，格式如下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod ［who］ ［+ | – | =］ ［mode］ filename</span><br></pre></td></tr></table></figure><p>命令中各选项的含义为：</p><p>命令中的 <code>who</code> 可是下述字母中的任一个或者它们的组合：</p><ul><li><code>u</code> 表示所有者user</li><li><code>g</code> 表示同组用户group</li><li><code>o</code> 表示其他人other</li><li><code>a</code> 表示所有用户all，是系统默认值</li></ul><p>权限改变的符号可以是：</p><ul><li><code>+</code> 添加某个权限</li><li><code>–</code> 取消某个权限</li><li><code>=</code> 赋予给定权限并取消其他所有权限（如果有的话）</li></ul><p>命令中的 <code>mode</code> 所表示的权限可用下述字母的任意组合：</p><ul><li><code>r</code> 可读权限</li><li><code>w</code> 可写权限</li><li><code>x</code> 可执行权限</li><li><code>X</code> 只有目标文件对某些用户是可执行的或该目标文件是目录时才追加 x 属性</li><li><code>u</code> 与文件属主拥有一样的权限</li><li><code>g</code> 与和文件属主同组的用户拥有一样的权限</li><li><code>o</code> 与其他用户拥有一样的权限</li></ul><p>常见写法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ chmod a+x happy.txt</span><br><span class="line">$ chmod ug+w file.xml</span><br><span class="line">$ chmod 755 a.out</span><br></pre></td></tr></table></figure><h1 id="chgrp-命令"><a href="#chgrp-命令" class="headerlink" title="chgrp 命令"></a>chgrp 命令</h1><p>该命令能改变文件或目录所属的组，语法如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chgrp ［option］ group filename</span><br></pre></td></tr></table></figure><p>option参数可选：</p><pre><code>-f,–quiet,–silent:  不显示错误信息-R,–recursive:      递归处理，将指定目录下的所有文件及子目录一并处理-v,–verbose:        显示指令执行过程</code></pre><p>命令中group可以是用户组ID，也可以是/etc/group文件中用户组的组名。文件名是以空格分开的要改变属组的文件列表，支持通配符。如果用户不是该文件的属主或超级用户，则不能改变该文件的组的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$chgrp</span> -R mysql /opt/<span class="built_in">local</span>/my.ini</span><br></pre></td></tr></table></figure><h1 id="chown-命令"><a href="#chown-命令" class="headerlink" title="chown 命令"></a>chown 命令</h1><p>该命令可以更改某个文件或目录的属主，也就是所有者。语法如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chown ［option］ groupname|username filename</span><br></pre></td></tr></table></figure><p>chown可以将指定文件的拥有者改为指定的用户或组。用户可以是用户名或用户ID。组可以是组名或组ID。与 chgrp命令一样，参数文件也是以空格分开的要改变权限的文件列表，支持通配符。</p><p>option参数可选：</p><pre><code>-f: 若该文件拥有者无法被更改也不要显示错误讯息-h: 只对于连结(link)进行变更，而非该 link 真正指向的文件-v: 显示拥有者变更的详细资料-R: 对目前目录下的所有档案与子目录进行相同的拥有者变更(即以递回的方式逐个变更)</code></pre><p>修改文件所有者的例子如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ chown redis /ect/redis/redis.config</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li><code>ls -l</code> 命令执行后的第5列，表示文件的硬连接数</li><li><code>chmod a+x happy.txt</code> 可以修改文件的权限信息</li><li><code>chgrp a+x fruit.txt</code> 可以修改文件的所有组信息</li><li><code>chown redis /ect/redis/redis.config</code> 可以修改文件的所有者信息</li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/115842171" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>鲁迅先生说“我向来是不惮以最坏的恶意，来推测中国人的，然而我还不料，也不信竟会下劣凶残到这地步。”<br>其实黑暗中往往也透露着光明~</p><p>2021-5-1 01:26:36</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;已经拖更好几天了，有些坚持的事情一旦中断便很难再捡起来了，所以还是尽可能的坚持下去，今天就简单记录一下文件权限相关的操作。&lt;/p&gt;
    
    </summary>
    
      <category term="linux" scheme="http://AlbertGithubHome.github.io/blog/categories/linux/"/>
    
    
      <category term="linux" scheme="http://AlbertGithubHome.github.io/blog/tags/linux/"/>
    
      <category term="chmod" scheme="http://AlbertGithubHome.github.io/blog/tags/chmod/"/>
    
      <category term="文件" scheme="http://AlbertGithubHome.github.io/blog/tags/%E6%96%87%E4%BB%B6/"/>
    
      <category term="权限" scheme="http://AlbertGithubHome.github.io/blog/tags/%E6%9D%83%E9%99%90/"/>
    
  </entry>
  
  <entry>
    <title>protobuf中SerializeToString和SerializePartialToString的区别</title>
    <link href="http://AlbertGithubHome.github.io/blog/2021/04/18/protobuf%E4%B8%ADSerializeToString%E5%92%8CSerializePartialToString%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://AlbertGithubHome.github.io/blog/2021/04/18/protobuf中SerializeToString和SerializePartialToString的区别/</id>
    <published>2021-04-18T13:26:09.000Z</published>
    <updated>2021-04-18T15:00:50.810Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>protobuf是Google提出的序列化方案，此方案独立于语言和平台，目前提供了如c++、go、python等多种语言的实现，使用比较广泛，具有性能开销小，压缩率高等优点，是值得学习的优秀开源库。</p><a id="more"></a><p>protobuf有 v2 和 v3 两个主要的并且差异很大的版本，有一些关于protobuf的文章中并没有说明版本，有些描述的内容给人造成了疑惑，所以在使用protobuf前要明确自己使用的版本，查找对应的特性。</p><h1 id="proto2"><a href="#proto2" class="headerlink" title="proto2"></a>proto2</h1><p>这个版本在编写 <code>.proto</code> 文件时的字段有三种限定符，分别是<code>required</code>、<code>optional</code> 和 <code>repeated</code>。</p><ul><li>required：必须设置该字段，如果是在debug模式下编译 libprotobuf，则序列化一个未初始化（未对required字段赋值）的 message 将导致断言失败。在release模式的构建中，将跳过检查并始终写入消息，但解析未初始化的消息将返回false表示失败。</li><li>optional：可以设置也可以不设置该字段。如果未设置可选字段值，则使用默认值，也可以用[default = value]进行设置。</li><li>repeated：该字段可以重复任意次数（包括零次），可以将 repeated 字段视为动态大小的数组。</li></ul><h2 id="message定义"><a href="#message定义" class="headerlink" title="message定义"></a>message定义</h2><p>定义一个简单的 message 结构如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">message Person &#123;</span><br><span class="line">  required string name = 1;</span><br><span class="line">  optional string email = 2;</span><br><span class="line">  optional int age = 3 [default = 18];</span><br><span class="line">  repeated bytes phones = 4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>观察 message 定义可以看到每个字段后面都有 <code>= 1</code>、<code>= 2</code> 的标记，这些被称为 Tags，在 protobuf 中同一个 message 中的每个字段都需要有独一无二的tag，tag 为 1-15 的是单字节编码，16-2047 使用2字节编码，所以1-15应该给频繁使用的字段。</p><p>关于tag的取值，还有一种范围是[1,536870911]的说法，同时 19000 到 19999 之间的数字也不能使用，因为它们是 protobuf 的实现中保留的，也就是 <code>FieldDescriptor::kFirstReservedNumber</code> 到 <code>FieldDescriptor::kLastReservedNumber</code> 指定的范围，如果使用其中的数字，导出 .proto 文件时会报错，此处存疑，需要验证一下。</p><h2 id="message扩展"><a href="#message扩展" class="headerlink" title="message扩展"></a>message扩展</h2><p>在使用的了 protobuf 的项目发布以后，绝对会遇到扩展原有 message 结构的需求，这一点不可避免，除非发布后的项目不再升级维护了，要想扩展就需要兼容之前的代码逻辑，这里有一些必须遵守的规则，否则就达不到兼容的目的。</p><ul><li>不能更改任何现有字段的 tag</li><li>不能添加或删除任何 required 字段</li><li>可以删除 optional 或 repeated 的字段</li><li>可以添加新的 optional 或 repeated 字段，但必须使用新的tag，曾经使用过又删除的 tag 也不能再使用了</li></ul><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>proto2 中对 required 的使用永远都应该非常小心。如果想在某个时刻停止写入或发送 required 字段，直接将字段更改为可选字段将会有问题。一些工程师得出的经验是，使用 required 弊大于利，他们更喜欢只使用 optional 和 repeated。</p><h1 id="proto3"><a href="#proto3" class="headerlink" title="proto3"></a>proto3</h1><p>proto3 比 proto2 支持更多语言但更简洁，去掉了一些复杂的语法和特性。</p><ul><li>在第一行非空白非注释行，必须写：<code>syntax = &quot;proto3&quot;;</code></li><li>直接从语法层面上移除了 required 规则，取消了 required 限定词</li><li>增加了对 Go、Ruby、JavaNano 等语言的支持</li><li>移除了 default 选项，字段的默认值只能根据字段类型由系统决定</li></ul><h1 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h1><p>将 message 结构对象序列化的函数有很多，即使是序列化成字符串也有多个函数可以使用，比如 <code>SerializeToString</code>、<code>SerializePartialToString</code>、<code>SerializeAsString</code>、<code>SerializePartialAsString</code> 等等。</p><h2 id="SerializeToString和SerializeAsString区别"><a href="#SerializeToString和SerializeAsString区别" class="headerlink" title="SerializeToString和SerializeAsString区别"></a>SerializeToString和SerializeAsString区别</h2><p>这两个还是很好区分的，从源码角度一眼就能够分辨出来：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> MessageLite::SerializeAsString() <span class="keyword">const</span> &#123;</span><br><span class="line">  <span class="comment">// If the compiler implements the (Named) Return Value Optimization,</span></span><br><span class="line">  <span class="comment">// the local variable 'output' will not actually reside on the stack</span></span><br><span class="line">  <span class="comment">// of this function, but will be overlaid with the object that the</span></span><br><span class="line">  <span class="comment">// caller supplied for the return value to be constructed in.</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> output;</span><br><span class="line">  <span class="keyword">if</span> (!AppendToString(&amp;output)) output.clear();</span><br><span class="line">  <span class="keyword">return</span> output;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> MessageLite::SerializeToString(<span class="built_in">std</span>::<span class="built_in">string</span>* output) <span class="keyword">const</span> &#123;</span><br><span class="line">  output-&gt;clear();</span><br><span class="line">  <span class="keyword">return</span> AppendToString(output);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从源代码可以很容易看出，两者仅仅是参数和返回值的类型不同，其内部调用的函数都是一样的，<code>SerializePartialToString</code> 和 <code>SerializePartialAsString</code> 两个函数也是这种区别，可以根据外部逻辑所需来调用合适的函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> MessageLite::SerializePartialToString(<span class="built_in">std</span>::<span class="built_in">string</span>* output) <span class="keyword">const</span> &#123;</span><br><span class="line">  output-&gt;clear();</span><br><span class="line">  <span class="keyword">return</span> AppendPartialToString(output);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> MessageLite::SerializePartialAsString() <span class="keyword">const</span> &#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> output;</span><br><span class="line">  <span class="keyword">if</span> (!AppendPartialToString(&amp;output)) output.clear();</span><br><span class="line">  <span class="keyword">return</span> output;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="SerializeToString和SerializePartialToString区别"><a href="#SerializeToString和SerializePartialToString区别" class="headerlink" title="SerializeToString和SerializePartialToString区别"></a>SerializeToString和SerializePartialToString区别</h2><p>这两个函数的区别在于内部调用的函数不同，一个调用 <code>AppendToString</code>，另一个调用 <code>AppendPartialToString</code>，两个被调用函数的源代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> MessageLite::AppendToString(<span class="built_in">std</span>::<span class="built_in">string</span>* output) <span class="keyword">const</span> &#123;</span><br><span class="line">  GOOGLE_DCHECK(IsInitialized()) &lt;&lt; InitializationErrorMessage(<span class="string">"serialize"</span>, *<span class="keyword">this</span>);</span><br><span class="line">  <span class="keyword">return</span> AppendPartialToString(output);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> MessageLite::AppendPartialToString(<span class="built_in">std</span>::<span class="built_in">string</span>* output) <span class="keyword">const</span> &#123;</span><br><span class="line">  <span class="keyword">size_t</span> old_size = output-&gt;size();</span><br><span class="line">  <span class="keyword">size_t</span> byte_size = ByteSizeLong();</span><br><span class="line">  <span class="keyword">if</span> (byte_size &gt; INT_MAX) &#123;</span><br><span class="line">    GOOGLE_LOG(ERROR) &lt;&lt; GetTypeName()</span><br><span class="line">               &lt;&lt; <span class="string">" exceeded maximum protobuf size of 2GB: "</span> &lt;&lt; byte_size;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原来 <code>AppendToString</code> 函数调用了 <code>AppendPartialToString</code>, 只是在调用之前先执行了一句 <code>GOOGLE_DCHECK(IsInitialized()) &lt;&lt; InitializationErrorMessage(&quot;serialize&quot;, *this);</code> 这句话什么意思呢？</p><p>其实就是一个调试状态下的检查，类似于 assert 这个断言函数吧，检查的内容是判断这个 message 是否初始化，之前提到 <code>required</code> 修饰的字段必须要设置一个值，否者就是未初始化的状态，那么现在两个函数的区别就知道了，带有 “Partial” 函数其实是忽略 <code>required</code> 字段检查的，另外还有没有别的不同需要再进一步研究下源码了。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>protobuf有 v2 和 v3 两个主要的并且差异较大的版本，使用前请注意版本号</li><li>proto3 直接从语法层面上移除了 required 规则，移除了 default 选项，字段的默认值只能根据字段类型由系统决定</li><li>SerializeToString和SerializeAsString区别在于参数和返回值的不同，内部调用的函数是相同的</li><li>SerializeToString和SerializePartialToString区别在于SerializePartialToString会忽略 required 字段必须赋值的要求</li><li>在应用过程中尽可能重用 message 结构，这样protobuf内部实现中内存的重用</li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/115609690" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>没有什么捷径，继续努力就好了<br>短期内不会看到什么成果，甚至说一辈子都可能看不到，但只有努力了才有可能看得到</p><p>2021-4-18 21:31:34</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;protobuf是Google提出的序列化方案，此方案独立于语言和平台，目前提供了如c++、go、python等多种语言的实现，使用比较广泛，具有性能开销小，压缩率高等优点，是值得学习的优秀开源库。&lt;/p&gt;
    
    </summary>
    
      <category term="protobuf" scheme="http://AlbertGithubHome.github.io/blog/categories/protobuf/"/>
    
    
      <category term="C++" scheme="http://AlbertGithubHome.github.io/blog/tags/C/"/>
    
      <category term="protobuf" scheme="http://AlbertGithubHome.github.io/blog/tags/protobuf/"/>
    
      <category term="序列化" scheme="http://AlbertGithubHome.github.io/blog/tags/%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    
      <category term="required" scheme="http://AlbertGithubHome.github.io/blog/tags/required/"/>
    
      <category term="message" scheme="http://AlbertGithubHome.github.io/blog/tags/message/"/>
    
  </entry>
  
  <entry>
    <title>C++中一些可以在偷懒时直接使用的函数</title>
    <link href="http://AlbertGithubHome.github.io/blog/2021/04/11/C-%E4%B8%AD%E4%B8%80%E4%BA%9B%E5%8F%AF%E4%BB%A5%E5%9C%A8%E5%81%B7%E6%87%92%E6%97%B6%E7%9B%B4%E6%8E%A5%E4%BD%BF%E7%94%A8%E7%9A%84%E5%87%BD%E6%95%B0/"/>
    <id>http://AlbertGithubHome.github.io/blog/2021/04/11/C-中一些可以在偷懒时直接使用的函数/</id>
    <published>2021-04-11T10:07:17.000Z</published>
    <updated>2021-04-11T15:44:08.954Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在解决一些算法题时，会遇到一些“嵌套”问题，也就是一个题目中包含多个小的算法知识点，比如计算一个整数的二进制表示中1的个数，或者计算两个数的最大公约数，如果这些小问题本身就是题目，那么就只能“手撕”了。</p><a id="more"></a><p>但是如果这些内容只是解决题目中的一小部分，我们其实是可以偷个懒的，有很多函数已经被纳入函数库，可以直接拿过来使用，接下来我们可以简单看几个。</p><h1 id="求解最大公约数"><a href="#求解最大公约数" class="headerlink" title="求解最大公约数"></a>求解最大公约数</h1><h2 id="自定义实现"><a href="#自定义实现" class="headerlink" title="自定义实现"></a>自定义实现</h2><p>求最大公约数的一种常用方法叫做辗转相除法，又名欧几里德算法(Euclidean algorithm)，算法本身并不复杂，可以写成如下逻辑实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">my_gcd</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (y != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> z = x % y;</span><br><span class="line">        x = y;</span><br><span class="line">        y = z;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者简单写成递归的实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">my_gcd</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> y ? my_gcd(y, x%y) : x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为计算机处理加减法的性能要远高于计算乘除法，所以辗转相除法有很多变形实现，比如辗转相减、用移位运算代替除法计算等。</p><h2 id="库函数"><a href="#库函数" class="headerlink" title="库函数"></a>库函数</h2><p>其实在C++17中，最大公约数计算已经被加到了函数库中，头文件为 <code>&lt;numeric&gt;</code>，直接调用 <code>std::gcd()</code> 就可以了，本身是一个模板函数，定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt; <span class="class"><span class="keyword">class</span> <span class="title">M</span>, <span class="title">class</span> <span class="title">N</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">constexpr</span> <span class="title">std</span>:</span>:<span class="keyword">common_type_t</span>&lt;M, N&gt; gcd(M m, N n);</span><br></pre></td></tr></table></figure><h1 id="计算一个整数的二进制表示中有多少个1"><a href="#计算一个整数的二进制表示中有多少个1" class="headerlink" title="计算一个整数的二进制表示中有多少个1"></a>计算一个整数的二进制表示中有多少个1</h1><h2 id="自定义实现-1"><a href="#自定义实现-1" class="headerlink" title="自定义实现"></a>自定义实现</h2><p>这也是一道经典的算法题了，常见的实现如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">count1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        cnt++;</span><br><span class="line">        n &amp;= (n<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种实现方法不能说最优解法，但是也算的上是一个优秀的实现思路了。</p><h2 id="内建函数"><a href="#内建函数" class="headerlink" title="内建函数"></a>内建函数</h2><p>关于二进制的形式的各种操作，GCC提供了一系列的builtin函数，可以实现一些简单快捷的功能来方便程序编写，并且可用来优化编译结果。</p><h3 id="builtin-popcount"><a href="#builtin-popcount" class="headerlink" title="__builtin_popcount"></a>__builtin_popcount</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回n的二进制表示形式中1的个数</span></span><br><span class="line"><span class="keyword">int</span> __builtin_popcount(<span class="keyword">unsigned</span> <span class="keyword">int</span> n)</span><br></pre></td></tr></table></figure><h3 id="builtin-ffs"><a href="#builtin-ffs" class="headerlink" title="__builtin_ffs"></a>__builtin_ffs</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回n的二进制表示形式中最后一位1的是从后向前第几位</span></span><br><span class="line"><span class="keyword">int</span> __builtin_ffs(<span class="keyword">unsigned</span> <span class="keyword">int</span> n)</span><br></pre></td></tr></table></figure><h3 id="builtin-clz"><a href="#builtin-clz" class="headerlink" title="__builtin_clz"></a>__builtin_clz</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回n的二进制表示形式中前导0的个数</span></span><br><span class="line"><span class="keyword">int</span> __builtin_clz(<span class="keyword">unsigned</span> <span class="keyword">int</span> n)</span><br></pre></td></tr></table></figure><h3 id="builtin-ctz"><a href="#builtin-ctz" class="headerlink" title="__builtin_ctz"></a>__builtin_ctz</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回n的二进制表示形式中结尾0个个数</span></span><br><span class="line"><span class="keyword">int</span> __builtin_ctz(<span class="keyword">unsigned</span> <span class="keyword">int</span> n)</span><br></pre></td></tr></table></figure><h3 id="builtin-parity"><a href="#builtin-parity" class="headerlink" title="__builtin_parity"></a>__builtin_parity</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回n的奇偶校验位，即n的二进制表示形式中的1的个数模2的结果</span></span><br><span class="line"><span class="keyword">int</span> __builtin_parity(<span class="keyword">unsigned</span> <span class="keyword">int</span> n)</span><br></pre></td></tr></table></figure><p>上述列举的这些函数参数都是 <code>unsigned int</code> 类型，如果参数为 <code>usigned long</code> 或者 <code>usigned long long</code>，只需要在函数名后面加上 <code>l</code> 或 <code>ll</code> 就可以了，比如 <code>__builtin_popcountl</code>。</p><p>遗憾的是，这些builtin函数一般没有可移植性，使用时要注意。</p><h2 id="库函数-1"><a href="#库函数-1" class="headerlink" title="库函数"></a>库函数</h2><p>但值得庆幸的是，这些优秀的函数在C++20中得以转正，成为了C++的标准函数，比如 <code>std::popcount</code>，定义在头文件 <code>&lt;bit&gt;</code> 中，函数定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">constexpr</span> <span class="title">int</span> <span class="title">popcount</span>(<span class="title">T</span> <span class="title">x</span>) <span class="title">noexcept</span>;</span></span><br></pre></td></tr></table></figure><h2 id="更快速的源码"><a href="#更快速的源码" class="headerlink" title="更快速的源码"></a>更快速的源码</h2><p>计算一个整数的二进制表示中包含1的个数，除了前面提到的 <code>n &amp;= (n-1)</code> 外，还有下面这种变形的二分法实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">popcount</span> <span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    u = (u &amp; <span class="number">0x55555555</span>) + ((u &gt;&gt; <span class="number">1</span>) &amp; <span class="number">0x55555555</span>);</span><br><span class="line">    u = (u &amp; <span class="number">0x33333333</span>) + ((u &gt;&gt; <span class="number">2</span>) &amp; <span class="number">0x33333333</span>);</span><br><span class="line">    u = (u &amp; <span class="number">0x0F0F0F0F</span>) + ((u &gt;&gt; <span class="number">4</span>) &amp; <span class="number">0x0F0F0F0F</span>);</span><br><span class="line">    u = (u &amp; <span class="number">0x00FF00FF</span>) + ((u &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0x00FF00FF</span>);</span><br><span class="line">    u = (u &amp; <span class="number">0x0000FFFF</span>) + ((u &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0x0000FFFF</span>);</span><br><span class="line">    <span class="keyword">return</span> u;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>采用这种二分法的实现，基本上可以媲美单字节打表的速度了，上述二分法是利用变量u来分组统计1的个数，两两合并到一起进而得到最后结果的。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>计算两个数的最大公约数可以在C++17环境下使用 <code>std::gcd()</code> 函数</li><li>计算一个整数二进制表示中1的个数可以在C++20环境下使用 <code>std::popcount()</code> 函数</li><li><code>__builtin</code> 开头的函数是GCC提供的方便程序编写的函数，并且可用来优化编译结，但是使用时要注意不可移植性</li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/115435926" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>在繁华中自律<br>在落魄中自愈<br>谋生的路上不抛弃良知<br>谋爱的路上不抛弃尊严</p><p>2021-4-11 21:27:25</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;在解决一些算法题时，会遇到一些“嵌套”问题，也就是一个题目中包含多个小的算法知识点，比如计算一个整数的二进制表示中1的个数，或者计算两个数的最大公约数，如果这些小问题本身就是题目，那么就只能“手撕”了。&lt;/p&gt;
    
    </summary>
    
      <category term="C/C++" scheme="http://AlbertGithubHome.github.io/blog/categories/C-C/"/>
    
    
      <category term="C/C++" scheme="http://AlbertGithubHome.github.io/blog/tags/C-C/"/>
    
      <category term="语法糖" scheme="http://AlbertGithubHome.github.io/blog/tags/%E8%AF%AD%E6%B3%95%E7%B3%96/"/>
    
      <category term="函数" scheme="http://AlbertGithubHome.github.io/blog/tags/%E5%87%BD%E6%95%B0/"/>
    
      <category term="函数库" scheme="http://AlbertGithubHome.github.io/blog/tags/%E5%87%BD%E6%95%B0%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>写给自己的KMP——C++版本</title>
    <link href="http://AlbertGithubHome.github.io/blog/2021/04/04/%E5%86%99%E7%BB%99%E8%87%AA%E5%B7%B1%E7%9A%84KMP%E2%80%94%E2%80%94C-%E7%89%88%E6%9C%AC/"/>
    <id>http://AlbertGithubHome.github.io/blog/2021/04/04/写给自己的KMP——C-版本/</id>
    <published>2021-04-04T15:03:12.000Z</published>
    <updated>2021-04-05T08:21:26.046Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h1><p>又翻到了这个算法，一个常用的子串（子数组）匹配算法，看一遍学一遍，学一遍忘一遍，反反复复，不过每次回忆起来所用的时间越来少了，其本质上就是在暴力搜索的基础上加上 next 数组加速匹配，算法的关键在于 next 数组的理解和求解方法。</p><a id="more"></a><p>不想画图，缺少图解的算法很难给初学者讲清楚，所以本文也仅仅是个人的笔记而已，用于记录算法中关键点、帮助回忆或者理解其中的一些关键因素，如果想从头学习 <code>KMP</code>，还是去搜索其他资料吧，相关的内容有很多，有些文章写的很详细的。</p><p>今天的示例代码用C++来写，上一版的自己写的KMP我查了一下是C语言版本的，初看起来已经有点费劲了，随着时间的推移，我决定根据理解再写一次，写完才发现，和之前的风格判若两人。</p><h1 id="二、暴力搜索"><a href="#二、暴力搜索" class="headerlink" title="二、暴力搜索"></a>二、暴力搜索</h1><p>在原字符串中搜索模式串，最容易想到的就是暴力搜索，匹配则向后移动，不匹配则原串回溯，模式串归0，代码很容易实现，列举如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">violence_find</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = s.size(), n = p.size(), i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt; m &amp;&amp; j &lt; n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == p[j]) &#123; <span class="comment">// match character</span></span><br><span class="line">            ++i;</span><br><span class="line">            ++j;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// mismatch</span></span><br><span class="line">            i -= j - <span class="number">1</span>;</span><br><span class="line">            j = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> j == n ? i - j : <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(<span class="string">"abdfdjfdkekfdaa5gsdsf"</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">p</span><span class="params">(<span class="string">"fdkekfd"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; violence_find(s, p) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>典型的 <code>O(MN)</code> 解法，这种解法慢就慢在原字符串的回溯上，也就是语句 <code>i -= j - 1;</code> 的效果，当出现失配时，原字符串之前的匹配几乎“白费”，每次最多移动一个字符，而 KMP 算法决定利用之前的“努力成果”。</p><h1 id="三、KMP算法"><a href="#三、KMP算法" class="headerlink" title="三、KMP算法"></a>三、KMP算法</h1><p>在 KMP 算法中先利用模式串构建一个 next 数组，当出现失配情况时根据模式串前缀和后缀情况，最大程序利用已经匹配的部分来达到加速查找的目的，只需要求一个 next 数组，其他部分和暴力匹配的代码很像：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kmp_tmp</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = s.size(), n = p.size(), i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; next = <span class="built_in">std</span>::move(gen_next(p));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt; m &amp;&amp; j &lt; n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == p[j]) &#123;</span><br><span class="line">            ++i;</span><br><span class="line">            ++j;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// mismatch</span></span><br><span class="line">            j = next[j];</span><br><span class="line">            <span class="keyword">if</span> (j == <span class="number">-1</span>) &#123;</span><br><span class="line">                ++i;</span><br><span class="line">                j = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> j == n ? i - j : <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和暴力搜索的代码对照下，只有 <code>else</code> 中语句块不太一样，这个 <code>i</code> 只前进不后退了，其实这个里的 <code>j == -1</code> 语句可以合并到判定相等的 <code>if</code> 语句块中，完成 KMP 代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; gen_next(<span class="built_in">string</span> p) &#123;</span><br><span class="line">    <span class="keyword">int</span> n = p.size(), i = <span class="number">0</span>, j = <span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; next(n, <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt; n - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">-1</span> || p[i] == p[j]) &#123;</span><br><span class="line">            ++i;</span><br><span class="line">            ++j;</span><br><span class="line">            next[i] = j;</span><br><span class="line">        &#125; <span class="keyword">else</span> j = next[j]; <span class="comment">// mismatch, move j</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kmp</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = s.size(), n = p.size(), i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; next = <span class="built_in">std</span>::move(gen_next(p));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt; m &amp;&amp; j &lt; n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">-1</span> || s[i] == p[j]) &#123;</span><br><span class="line">            ++i;</span><br><span class="line">            ++j;</span><br><span class="line">        &#125; <span class="keyword">else</span> j = next[j]; <span class="comment">// mismatch, move j</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> j == n ? i - j : <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(<span class="string">"abdfdjfdkekfdaa5gsdsf"</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">p</span><span class="params">(<span class="string">"fdkekfd"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; kmp(s, p) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="四、关键点记录"><a href="#四、关键点记录" class="headerlink" title="四、关键点记录"></a>四、关键点记录</h1><ol><li><p>next[i] 中记录的实际上是 <code>p[0,i-1]</code> 这个字符串中所有前缀和所有后缀交集中最长字符串的长度，比如<code>&#39;fdkekfd&#39;</code> 这个字符串所有前缀和所有后缀交集中最长字符串是 <code>&#39;fd&#39;</code>，其长度是2。</p></li><li><p>字符串的前缀和后缀不包括字符串本身。</p></li><li><p><code>next[0]</code> 初始化成-1仅仅是一个编程技巧，你可以初始化成任意值，只要你分辨出是失配的情况即可，这里初始成 -1 正好可以和 <code>s[i] == p[j]</code> 这种情况合并，所以初始化成 -1 会常用一点。</p></li><li><p>在 KMP 算法中原串索引 <code>i</code> 比较傲娇，它只前进不会回溯，这也是 KMP 速度快的一个主要原因。</p></li><li><p>当出现失配时，模式子串的前缀和后缀有重合，可以直接移动模式串的前缀到刚刚匹配的后缀部分，但要记住如果没有重合的前缀和后缀，失配时移动模式串的速度会更快，这里容易弄反。</p></li></ol><h1 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h1><ul><li>KMP 算法的关键是求解 next 数组，是一个被称为部分匹配表(Partial Match Table)的数组</li><li>KMP 算法相比暴力匹配时间复杂度提升到了O(N+M)，但是并不是最优秀的字符串匹配算法</li><li>想要更快或者选择更合适的算法可以了解下从模式串的尾部开始匹配的 <code>BM算法</code>，以及从模式串的头部开始匹配的 <code>Sunday算法</code></li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/115290419" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>想要看到更高的风景，除了让自己跳的更高以外，还可以选一个更高的平台站上去。找到一个2米高的平台并努力爬上去，远比你原地起跳2米要容易的多~</p><p>2021-4-5 00:22:35</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;一、前言&lt;/h1&gt;&lt;p&gt;又翻到了这个算法，一个常用的子串（子数组）匹配算法，看一遍学一遍，学一遍忘一遍，反反复复，不过每次回忆起来所用的时间越来少了，其本质上就是在暴力搜索的基础上加上 next 数组加速匹配，算法的关键在于 next 数组的理解和求解方法。&lt;/p&gt;
    
    </summary>
    
      <category term="C/C++" scheme="http://AlbertGithubHome.github.io/blog/categories/C-C/"/>
    
    
      <category term="C/C++" scheme="http://AlbertGithubHome.github.io/blog/tags/C-C/"/>
    
      <category term="find" scheme="http://AlbertGithubHome.github.io/blog/tags/find/"/>
    
      <category term="算法" scheme="http://AlbertGithubHome.github.io/blog/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="KMP" scheme="http://AlbertGithubHome.github.io/blog/tags/KMP/"/>
    
  </entry>
  
  <entry>
    <title>C++中常见的字符判断与处理方法</title>
    <link href="http://AlbertGithubHome.github.io/blog/2021/03/28/C-%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84%E5%AD%97%E7%AC%A6%E5%88%A4%E6%96%AD%E4%B8%8E%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95/"/>
    <id>http://AlbertGithubHome.github.io/blog/2021/03/28/C-中常见的字符判断与处理方法/</id>
    <published>2021-03-28T10:01:24.000Z</published>
    <updated>2021-03-28T15:34:08.874Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>字符串处理是编程世界中一项基础技能，特别是对于C/C++的程序员们，远没有那么多华丽的工具可以使用，大多数时候都需要一个个字符来判断和处理，甚至对于C语言来说都没有字符串类型，字符数组是其常见的等价结构，所以稳扎稳打的基本功尤其重要。</p><a id="more"></a><p>对于C++而言，确实有<code>string</code>这个字符串类型，在使用的时候有一些技巧和函数可以使用，比C语言要方便许多了，只是有些时候我们并不知道可以这样用，有时一些很朴素的写法会让程序更加简洁，而一些技巧的表达当明白之后也会感叹自己曾经的无知。</p><h1 id="ASCII-码"><a href="#ASCII-码" class="headerlink" title="ASCII 码"></a>ASCII 码</h1><p>作为字符编码的基础，ASCII码是需要先弄明白的，即使不能把所有的ASCII码对应的字符都记住，也要把常见的字母、数字、特殊字符记住，这样在处理字符问题时可以得心应手，常见的ASCII码对照表如下：</p><p>其中需要注意的知识点：</p><ul><li>前32个为非打印控制字符，后面的字符为打印字符</li><li>数字字符 <code>&#39;0&#39;-&#39;9&#39;</code> 对应的ASCII码范围是48-57</li><li>大写字母 <code>&#39;A&#39;-&#39;Z&#39;</code> 对应的ASCII码范围是65-90</li><li>小写字母 <code>&#39;a&#39;-&#39;z&#39;</code> 对应的ASCII码范围是97-122</li><li><code>NULL</code> 对应ASCII码0，回车的ASCII码是13，换行的ASCII码是10</li></ul><p>仔细观察这个ASCII表你会发现很多“秘密”，比如 windows 中的文件放到 linux 上打开时常常显示许多的 <code>^M</code>，其实这就是<code>\r</code> 的表现，因为在 windows 上用 <code>\r\n</code> 表示换行，而 linux 上使用 <code>\n</code> 换行，那么多余的 <code>\r</code> 在 linux 上就会显示成 <code>^M</code>。</p><p>再比如小写字母 <code>a</code> 和大写字母 <code>A</code> 中间差了32，为什么不是26呢？为什么要在中间插入几个别的字符，搞成连续的不好吗？之前没想过这个问题，但是前两天看了一个高手的代码后，我大概明白了，这个32的差距应该是一种“炫技”的表现，它可以使得许多代码逻辑变得简单。</p><h1 id="判断字符范围的函数"><a href="#判断字符范围的函数" class="headerlink" title="判断字符范围的函数"></a>判断字符范围的函数</h1><h2 id="C-语言"><a href="#C-语言" class="headerlink" title="C 语言"></a>C 语言</h2><p>C语言中判断的字符范围的函数都在头文件 <code>&lt;ctype.h&gt;</code> 中，常见的有下面这些</p><ul><li><code>int isalnum(int c)</code>：检查所传的字符是否是字母和数字</li><li><code>int isalpha(int c)</code>：检查所传的字符是否是字母</li><li><code>int isdigit(int c)</code>：检查所传的字符是否是十进制数字</li><li><code>int islower(int c)</code>：检查所传的字符是否是小写字母</li><li><code>int isupper(int c)</code>：检查所传的字符是否是大写字母</li><li><code>int ispunct(int c)</code>：检查所传的字符是否是标点符号字符</li></ul><h2 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h2><p>C++ 中其实大部分还是引用C语言里的这些函数，但是头文件的名字为 <code>&lt;cctype&gt;</code>，在C++11中加了一个 <code>int isblank(int c)</code> 函数。</p><h1 id="字符判断技巧"><a href="#字符判断技巧" class="headerlink" title="字符判断技巧"></a>字符判断技巧</h1><h2 id="判断两个字符互为大小写"><a href="#判断两个字符互为大小写" class="headerlink" title="判断两个字符互为大小写"></a>判断两个字符互为大小写</h2><p>看到这个问题第一直觉是什么？很简单的问题有木有？因为知道一个字母的大小写差了32，所以会写出下面的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isOk</span><span class="params">(<span class="keyword">char</span> x, <span class="keyword">char</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x - y == <span class="number">32</span> || y - x == <span class="number">32</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过我前两天看到一段代码，它是这样写的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(x ^ <span class="number">32</span>) == y;</span><br></pre></td></tr></table></figure><p>看到这里你还以为 <code>A</code> 和 <code>a</code> 之间差32而不是26感到迷惑吗？简单的字符编排透露着巨大的智慧。</p><h2 id="哨兵的使用"><a href="#哨兵的使用" class="headerlink" title="哨兵的使用"></a>哨兵的使用</h2><p>比如取出一个字符串 <code>string s</code> 中所有的数字，问题很简单，但是结尾字符的处理往往体现了编程的功底，加上一个哨兵字符可以使得编程逻辑简单许多，无须再对结尾字符特殊判断。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">find</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">    s = s + <span class="string">'A'</span>;</span><br><span class="line">    <span class="built_in">string</span> ans;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> c : s) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isdigit</span>(c)) ans += c;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            ans = <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li><code>&#39;0&#39;</code> 的ASCII码是48，<code>&#39;A&#39;</code> 的ASCII码是65，<code>&#39;a&#39;</code> 的ASCII码是97</li><li><code>isdigit</code> 可以判断字符是否是数字，<code>isalpha</code> 可以判断字符是否为字母</li><li>一个字母的大小写对应的ASCII码正好差32，判断互为大小写时可以使用异或符号 <code>(x ^ 32) == y</code></li><li>字符串结尾加哨兵字符可以使得处理逻辑更加简单统一，这种编程技巧在其他结构中也常常出现</li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/115059262" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>今天看到一个一直作为榜样的知识输出者宣布财富自由，满心羡慕，是真的羡慕！关键人家比我年轻，比我工作时间还短，已经依靠短短4、5年的努力达到了自由状态，不过了解他的经历会发现他确实付出了很多，而我们大多数作为普通人太安于现状了，有时候选择比努力重要，如果选择对了又付出了加倍的努力，那……</p><p>2021-3-28 23:27:32</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;字符串处理是编程世界中一项基础技能，特别是对于C/C++的程序员们，远没有那么多华丽的工具可以使用，大多数时候都需要一个个字符来判断和处理，甚至对于C语言来说都没有字符串类型，字符数组是其常见的等价结构，所以稳扎稳打的基本功尤其重要。&lt;/p&gt;
    
    </summary>
    
      <category term="C/C++" scheme="http://AlbertGithubHome.github.io/blog/categories/C-C/"/>
    
    
      <category term="C/C++" scheme="http://AlbertGithubHome.github.io/blog/tags/C-C/"/>
    
      <category term="string" scheme="http://AlbertGithubHome.github.io/blog/tags/string/"/>
    
      <category term="char" scheme="http://AlbertGithubHome.github.io/blog/tags/char/"/>
    
      <category term="判断" scheme="http://AlbertGithubHome.github.io/blog/tags/%E5%88%A4%E6%96%AD/"/>
    
      <category term="查询" scheme="http://AlbertGithubHome.github.io/blog/tags/%E6%9F%A5%E8%AF%A2/"/>
    
  </entry>
  
  <entry>
    <title>C++中反向遍历map时怎样删除元素</title>
    <link href="http://AlbertGithubHome.github.io/blog/2021/03/21/C-%E4%B8%AD%E5%8F%8D%E5%90%91%E9%81%8D%E5%8E%86map%E6%97%B6%E6%80%8E%E6%A0%B7%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0/"/>
    <id>http://AlbertGithubHome.github.io/blog/2021/03/21/C-中反向遍历map时怎样删除元素/</id>
    <published>2021-03-21T07:08:49.000Z</published>
    <updated>2021-03-21T12:02:17.918Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>今天在解决一个问题 <a href="https://leetcode-cn.com/problems/number-of-orders-in-the-backlog/" target="_blank" rel="noopener">《5710. 积压订单中的订单总数》</a> 时用到了map的反向遍历，看到问题时首先想到了优先队列，但是需要维护一个大根堆和一个小根堆，感觉操作起来比较麻烦，突发奇想使用map就能够解决。map本身就是有序的，正向遍历可以得到从小到大的序列，而反向遍历就可以得到从大到小的序列，这个思路本身没有错，但是解题时卡在了反向遍历时如何删除元素的知识点上，特此记录一下。</p><a id="more"></a><h1 id="map的正向遍历"><a href="#map的正向遍历" class="headerlink" title="map的正向遍历"></a>map的正向遍历</h1><p>map的正向遍历是一个基础知识点了，先简单复习一下，不管是用 for 还是 while，只要控制迭代器持续前进就可以了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt; mp&#123;&#123;<span class="number">1</span>, <span class="string">"A"</span>&#125;, &#123;<span class="number">2</span>, <span class="string">"E"</span>&#125;, &#123;<span class="number">3</span>, <span class="string">"I"</span>&#125;, &#123;<span class="number">4</span>, <span class="string">"O"</span>&#125;, &#123;<span class="number">6</span>, <span class="string">"U"</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;::iterator it = mp.begin(); it != mp.end(); ++it) &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">" "</span> &lt;&lt; it-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 输出内容</span></span><br><span class="line"><span class="comment">1 A</span></span><br><span class="line"><span class="comment">2 E</span></span><br><span class="line"><span class="comment">3 I</span></span><br><span class="line"><span class="comment">4 O</span></span><br><span class="line"><span class="comment">6 U</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>引入 <code>auto</code> 关键字以后，定义表示式的时候会更加方便一点</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt; mp&#123;&#123;<span class="number">1</span>, <span class="string">"A"</span>&#125;, &#123;<span class="number">2</span>, <span class="string">"E"</span>&#125;, &#123;<span class="number">3</span>, <span class="string">"I"</span>&#125;, &#123;<span class="number">4</span>, <span class="string">"O"</span>&#125;, &#123;<span class="number">6</span>, <span class="string">"U"</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = mp.begin(); it != mp.end(); ++it) &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">" "</span> &lt;&lt; it-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>引入冒号以后表达式更加简短，要注意的是这里的 <code>it</code> 已经不是指针了，而是 <code>value_type</code> 类型，所以需要是用 <code>.</code> 来访问</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt; mp&#123;&#123;<span class="number">1</span>, <span class="string">"A"</span>&#125;, &#123;<span class="number">2</span>, <span class="string">"E"</span>&#125;, &#123;<span class="number">3</span>, <span class="string">"I"</span>&#125;, &#123;<span class="number">4</span>, <span class="string">"O"</span>&#125;, &#123;<span class="number">6</span>, <span class="string">"U"</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it : mp) &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; it.first &lt;&lt; <span class="string">" "</span> &lt;&lt; it.second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>引入了结构化绑定声明之后，遍历方式还可以写成下面这样</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt; mp&#123;&#123;<span class="number">1</span>, <span class="string">"A"</span>&#125;, &#123;<span class="number">2</span>, <span class="string">"E"</span>&#125;, &#123;<span class="number">3</span>, <span class="string">"I"</span>&#125;, &#123;<span class="number">4</span>, <span class="string">"O"</span>&#125;, &#123;<span class="number">6</span>, <span class="string">"U"</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; [a, b] : mp) &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="string">" "</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="map-遍历时删除元素"><a href="#map-遍历时删除元素" class="headerlink" title="map 遍历时删除元素"></a>map 遍历时删除元素</h1><p>map 遍历时删除需要注意迭代器失效问题，常用的有下面两种写法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">it = mp.erase(it);</span><br></pre></td></tr></table></figure><p>或者<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mp.erase(it++);</span><br></pre></td></tr></table></figure></p><p>遍历删除时的例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt; mp&#123;&#123;<span class="number">1</span>, <span class="string">"A"</span>&#125;, &#123;<span class="number">2</span>, <span class="string">"E"</span>&#125;, &#123;<span class="number">3</span>, <span class="string">"I"</span>&#125;, &#123;<span class="number">4</span>, <span class="string">"O"</span>&#125;, &#123;<span class="number">6</span>, <span class="string">"U"</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = mp.begin(); it != mp.end();) &#123;</span><br><span class="line">    <span class="keyword">if</span> (it-&gt;second == <span class="string">"I"</span>)</span><br><span class="line">        mp.erase(it++);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        it++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it : mp) <span class="built_in">cout</span> &lt;&lt; it.first &lt;&lt; <span class="string">" "</span> &lt;&lt; it.second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 输出内容</span></span><br><span class="line"><span class="comment">1 A</span></span><br><span class="line"><span class="comment">2 E</span></span><br><span class="line"><span class="comment">4 O</span></span><br><span class="line"><span class="comment">6 U</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h1 id="map-的反向遍历"><a href="#map-的反向遍历" class="headerlink" title="map 的反向遍历"></a>map 的反向遍历</h1><p>map 反向遍历时可以使用 <a href="https://en.cppreference.com/w/cpp/iterator/reverse_iterator" target="_blank" rel="noopener">reverse_iterator</a> 迭代器，配合 <code>rbegin()</code> 和 <code>rend()</code> 方法就可以完成反向遍历</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt; mp&#123;&#123;<span class="number">1</span>, <span class="string">"A"</span>&#125;, &#123;<span class="number">2</span>, <span class="string">"E"</span>&#125;, &#123;<span class="number">3</span>, <span class="string">"I"</span>&#125;, &#123;<span class="number">4</span>, <span class="string">"O"</span>&#125;, &#123;<span class="number">6</span>, <span class="string">"U"</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = mp.rbegin(); it != mp.rend(); it++) &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">" "</span> &lt;&lt; it-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 输出内容</span></span><br><span class="line"><span class="comment">6 U</span></span><br><span class="line"><span class="comment">4 O</span></span><br><span class="line"><span class="comment">3 I</span></span><br><span class="line"><span class="comment">2 E</span></span><br><span class="line"><span class="comment">1 A</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h1 id="map-反向遍历时删除元素"><a href="#map-反向遍历时删除元素" class="headerlink" title="map 反向遍历时删除元素"></a>map 反向遍历时删除元素</h1><p>一开始也是用 <code>erase</code> 函数来删除元素，但是会报下面的编译错误</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">error: no matching function <span class="keyword">for</span> call to ‘<span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">std</span>::__cxx11::basic_string&lt;<span class="keyword">char</span>&gt; &gt;::erase(</span><br><span class="line">    <span class="built_in">std</span>::reverse_iterator&lt;<span class="built_in">std</span>::_Rb_tree_iterator&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">const</span> <span class="keyword">int</span>, <span class="built_in">std</span>::__cxx11::basic_string&lt;<span class="keyword">char</span>&gt; &gt; &gt; &gt;)’</span><br><span class="line">    mp.erase(it++);</span><br></pre></td></tr></table></figure><p>查询文档发现，<code>erase</code> 函数重载只有下面几种实现:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">erase</span><span class="params">( iterator pos )</span></span>;                                     (until C++<span class="number">11</span>)</span><br><span class="line"><span class="function">iterator <span class="title">erase</span><span class="params">( const_iterator pos )</span></span>;                           (since C++<span class="number">11</span>)</span><br><span class="line"><span class="function">iterator <span class="title">erase</span><span class="params">( iterator pos )</span></span>;                                 (since C++<span class="number">17</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">erase</span><span class="params">( iterator first, iterator last )</span></span>;                    (until C++<span class="number">11</span>)</span><br><span class="line"><span class="function">iterator <span class="title">erase</span><span class="params">( const_iterator first, const_iterator last )</span></span>;    (since C++<span class="number">11</span>)</span><br><span class="line"></span><br><span class="line"><span class="function">size_type <span class="title">erase</span><span class="params">( <span class="keyword">const</span> key_type&amp; key )</span></span>;</span><br></pre></td></tr></table></figure><p>参数是迭代器的函数并不支持 <code>reverse_iterator</code>，需要将 <code>reverse_iterator</code> 转化成 <code>iterator</code> 才可以，这时就需要用到 <code>base</code> 函数，对 <code>reverse_iterator</code> 类型的迭代器使用 <code>base</code> 函数得到的是上一个元素“原始指针”，这一点比较有意思，具体的解释可以参考 <a href="https://en.cppreference.com/w/cpp/iterator/reverse_iterator/base" target="_blank" rel="noopener">《std::reverse_iterator<iter>::base》</iter></a>，这种操作决定了我们遍历删除的写法，应该是先自增再调用 <code>base</code> 函数，代码如下；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt; mp&#123;&#123;<span class="number">1</span>, <span class="string">"A"</span>&#125;, &#123;<span class="number">2</span>, <span class="string">"E"</span>&#125;, &#123;<span class="number">3</span>, <span class="string">"I"</span>&#125;, &#123;<span class="number">4</span>, <span class="string">"O"</span>&#125;, &#123;<span class="number">6</span>, <span class="string">"U"</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = mp.rbegin(); it != mp.rend();) &#123;</span><br><span class="line">    <span class="keyword">if</span> (it-&gt;second == <span class="string">"I"</span>) mp.erase((++it).base());</span><br><span class="line">    <span class="keyword">else</span> it++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = mp.rbegin(); it != mp.rend(); it++)</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">" "</span> &lt;&lt; it-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 输出内容</span></span><br><span class="line"><span class="comment">6 U</span></span><br><span class="line"><span class="comment">4 O</span></span><br><span class="line"><span class="comment">2 E</span></span><br><span class="line"><span class="comment">1 A</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>map 默认会按照 key 排序，是一个常用的有序容器</li><li>配合使用 <code>rbegin()</code> 和 <code>rend()</code> 函数可以完成 map 的反向遍历</li><li>对 <code>reverse_iterator</code> 类型迭代器使用 <code>base()</code> 函数，可以转化成 <code>iterator</code> 相关类型，然后进行删除操作</li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/114806994" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>搬起砖，我抱不了你，放下砖 … 我尽力！</p><p>2021-3-21 19:44:27</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;今天在解决一个问题 &lt;a href=&quot;https://leetcode-cn.com/problems/number-of-orders-in-the-backlog/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《5710. 积压订单中的订单总数》&lt;/a&gt; 时用到了map的反向遍历，看到问题时首先想到了优先队列，但是需要维护一个大根堆和一个小根堆，感觉操作起来比较麻烦，突发奇想使用map就能够解决。map本身就是有序的，正向遍历可以得到从小到大的序列，而反向遍历就可以得到从大到小的序列，这个思路本身没有错，但是解题时卡在了反向遍历时如何删除元素的知识点上，特此记录一下。&lt;/p&gt;
    
    </summary>
    
      <category term="C/C++" scheme="http://AlbertGithubHome.github.io/blog/categories/C-C/"/>
    
    
      <category term="C/C++" scheme="http://AlbertGithubHome.github.io/blog/tags/C-C/"/>
    
      <category term="iterator" scheme="http://AlbertGithubHome.github.io/blog/tags/iterator/"/>
    
      <category term="reverse_iterator" scheme="http://AlbertGithubHome.github.io/blog/tags/reverse-iterator/"/>
    
      <category term="base" scheme="http://AlbertGithubHome.github.io/blog/tags/base/"/>
    
  </entry>
  
  <entry>
    <title>解决git命令会将结果输出到单独窗口必须按q才能退出的问题</title>
    <link href="http://AlbertGithubHome.github.io/blog/2021/03/14/%E8%A7%A3%E5%86%B3git%E5%91%BD%E4%BB%A4%E4%BC%9A%E5%B0%86%E7%BB%93%E6%9E%9C%E8%BE%93%E5%87%BA%E5%88%B0%E5%8D%95%E7%8B%AC%E7%AA%97%E5%8F%A3%E5%BF%85%E9%A1%BB%E6%8C%89q%E6%89%8D%E8%83%BD%E9%80%80%E5%87%BA%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://AlbertGithubHome.github.io/blog/2021/03/14/解决git命令会将结果输出到单独窗口必须按q才能退出的问题/</id>
    <published>2021-03-14T08:19:15.000Z</published>
    <updated>2021-03-14T14:26:22.534Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>平时会在 windows+linux 两种环境下进行开发，版本控制软件用 git 比较多，但是一直有个小问题，在 windows 下使用 <code>git Bash</code> 比较顺手，但是在 linux 使用 git 部分命令的时候，常常会打开一个新的窗口，按q键才能退出，比如 <code>git branch</code>、<code>git log</code>、<code>git show</code> 等等。</p><a id="more"></a><p>如果是使用 <code>git log</code> 查询日志后想进行合并或者回退等操作时，因为日志信息已经退出没有显示在当前窗口，这种情况会比较麻烦，有时候还需要额外再查询一次，还有就是 <code>git branch</code> 命显示内容常常较少，单独打开一个窗口也没有必要，所以想单独设置这种情况，后来查询资料发现，这与 git 的 pager 设置有关，特此记录一下。</p><h1 id="什么是-pager"><a href="#什么是-pager" class="headerlink" title="什么是 pager"></a>什么是 pager</h1><p>pager 其实就是分页器，也就是对一大段内容进行分页显示的工具，git 在一些版本中默认使用的是 less 工具，不同的版本默认设置会有差异，这也就是造成我在 windows 下没有自动分页，而在 linux 下会打开新窗口进行分页的原因。</p><p>git 的分页器可以通过 <code>core.pager</code> 来进行设置，他会被 git 命令行解释，影响分页器的变量有多个，他们起作用的顺序依次是 <code>$GIT_PAGER</code> 环境变量，<code>core.pager</code> git配置，<code>$PAGER</code> 环境变量，如果这些都没有设置，默认会选择编译时的选项（通常为less），具体细节可以参考官方文档 <a href="https://git-scm.com/docs/git-config#Documentation/git-config.txt-corepager" target="_blank" rel="noopener">git core.pager</a>。</p><h1 id="设置-core-pager"><a href="#设置-core-pager" class="headerlink" title="设置 core.pager"></a>设置 core.pager</h1><p>了解了上面的原理，我们就知道只要单独修改 git 配置就可以了，默认的分页器是 less，我们只要设置了 <code>core.pager</code> 就可以影响结果，所以在 git Bash 中执行下面的语句即可。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global core.pager <span class="string">''</span></span><br></pre></td></tr></table></figure><p>其实就是将分页器清空就行了，这样再执行 <code>git branch</code> 的时候就不会出现分页的情况了。</p><h1 id="更精细的设置"><a href="#更精细的设置" class="headerlink" title="更精细的设置"></a>更精细的设置</h1><p>设置 <code>core.pager</code> 这项配置后对 less 分页器进行了全局屏蔽，虽然 <code>git branch</code> 这种显示内容少的命令比较方便了，但是执行 <code>git show</code> 的时候不分页反而会显得混乱，有没有单独设置每个 git 命令的配置呢？</p><p>答案当然是肯定的，比如上面提到的这种情况，我们只想屏蔽 <code>git branch</code> 命令的分页，而想保留<code>git show</code> 和 <code>git log</code> 的分页显示，就可以单独执行下面的命令。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global pager.branch <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>这样就可以达到只屏蔽 <code>git branch</code> 命令的分页结果了。</p><h1 id="less-and-more"><a href="#less-and-more" class="headerlink" title="less and more"></a>less and more</h1><p>临时插播个知识点，less 和 more 都是 linux 的文本显示工具，那么它们谁更厉害一点呢？从名字上来看应该是 more 更厉害，但实际上是 less 更厉害，less 在 more 的基础上加上了后退功能（据说最初版本more不能后退，现在的常见版本已经支持后退功能了），支持上下键翻页，并且速度更快一点，所以在 linux 的世界一直流传着 “less is more” 这句话。另外 more 退出后会在 shell 上留下刚显示的内容，而 less 不会。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>使用 <code>git config --global core.pager &#39;&#39;</code> 命令可以屏蔽 git 默认的分页器 less</li><li>使用 <code>git config --global pager.branch false</code> 命令可以只关闭 <code>git branch</code> 命令的分页显示</li><li>less 命令比 more 命令更加强大，支持上下键翻页，退出后不会在 shell 显示刚才的内容</li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/114465098" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>学而不思则罔，思而不学则殆。动而不思则徒，思而不动则颓。</p><p>2021-3-14 17:14:55</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;平时会在 windows+linux 两种环境下进行开发，版本控制软件用 git 比较多，但是一直有个小问题，在 windows 下使用 &lt;code&gt;git Bash&lt;/code&gt; 比较顺手，但是在 linux 使用 git 部分命令的时候，常常会打开一个新的窗口，按q键才能退出，比如 &lt;code&gt;git branch&lt;/code&gt;、&lt;code&gt;git log&lt;/code&gt;、&lt;code&gt;git show&lt;/code&gt; 等等。&lt;/p&gt;
    
    </summary>
    
      <category term="Git" scheme="http://AlbertGithubHome.github.io/blog/categories/Git/"/>
    
    
      <category term="git" scheme="http://AlbertGithubHome.github.io/blog/tags/git/"/>
    
      <category term="branch" scheme="http://AlbertGithubHome.github.io/blog/tags/branch/"/>
    
      <category term="log" scheme="http://AlbertGithubHome.github.io/blog/tags/log/"/>
    
      <category term="pager" scheme="http://AlbertGithubHome.github.io/blog/tags/pager/"/>
    
      <category term="config" scheme="http://AlbertGithubHome.github.io/blog/tags/config/"/>
    
  </entry>
  
  <entry>
    <title>Python中int、str、bytes相互转化，还有2进制、16进制表示，你想要的都在这里了</title>
    <link href="http://AlbertGithubHome.github.io/blog/2021/03/05/Python%E4%B8%ADint%E3%80%81str%E3%80%81byte%E7%9B%B8%E4%BA%92%E8%BD%AC%E5%8C%96%EF%BC%8C%E8%BF%98%E6%9C%892%E8%BF%9B%E5%88%B6%E3%80%8116%E8%BF%9B%E5%88%B6%E8%A1%A8%E7%A4%BA%EF%BC%8C%E4%BD%A0%E6%83%B3%E8%A6%81%E7%9A%84%E9%83%BD%E5%9C%A8%E8%BF%99%E9%87%8C%E4%BA%86/"/>
    <id>http://AlbertGithubHome.github.io/blog/2021/03/05/Python中int、str、byte相互转化，还有2进制、16进制表示，你想要的都在这里了/</id>
    <published>2021-03-04T16:04:47.000Z</published>
    <updated>2021-03-06T16:25:58.861Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>数据类型转换是个很基础的操作，很多语言中都要做这些转换，例如前一段时间刚刚总结了<a href="https://blog.csdn.net/albertsh/article/details/113765130" target="_blank" rel="noopener">《C/C++中string和int相互转换的常用方法》</a>，python 自从分离出 python3 版本之后，<code>str</code> 和 <code>bytes</code> 两个类型弄蒙了一大票人，在这两种类型的转换上我可是花了不少时间，记住一点，别随随便便使用 <code>str()</code> 函数，很多数据使用 <code>str()</code> 变成字符串之后再想恢复可就难了。</p><a id="more"></a><p>本文所有示例均在 <code>Python 3.7.5</code> 上测试，<code>Python2</code> 已经被我抛弃了，我来试着把常见的转换都放到一起，把踩过的坑拿来开心一下，如果有些常用的类型转换这里没有的话，也欢迎小伙伴们提出来，我将持续补充，好了，可以开始了。</p><h1 id="数据类型转化"><a href="#数据类型转化" class="headerlink" title="数据类型转化"></a>数据类型转化</h1><p>数字中除了整数，还有浮点数、复数等，但是 <code>int</code> 是最常见的类型，所有转换中的数字只涉及 <code>int</code> 数字类型。</p><h2 id="int-gt-str"><a href="#int-gt-str" class="headerlink" title="int -&gt; str"></a>int -&gt; str</h2><h3 id="使用-str-函数"><a href="#使用-str-函数" class="headerlink" title="使用 str() 函数"></a>使用 str() 函数</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">num = <span class="number">10</span></span><br><span class="line">val = str(<span class="number">10</span>)</span><br><span class="line">print(type(val), val)</span><br><span class="line"></span><br><span class="line"><span class="comment">#&lt;class 'str'&gt; 10</span></span><br></pre></td></tr></table></figure><h3 id="使用-format-函数"><a href="#使用-format-函数" class="headerlink" title="使用 format() 函数"></a>使用 format() 函数</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">num = <span class="number">10</span></span><br><span class="line">val = <span class="string">'&#123;0&#125;'</span>.format(num)</span><br><span class="line">print(type(val), val)</span><br><span class="line"></span><br><span class="line"><span class="comment">#&lt;class 'str'&gt; 10</span></span><br></pre></td></tr></table></figure><h3 id="使用-hex-转换成16进制形式"><a href="#使用-hex-转换成16进制形式" class="headerlink" title="使用 hex() 转换成16进制形式"></a>使用 hex() 转换成16进制形式</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">num = <span class="number">10</span></span><br><span class="line">val = hex(num)</span><br><span class="line">print(type(val), val)</span><br><span class="line"></span><br><span class="line"><span class="comment">#&lt;class 'str'&gt; 0xa</span></span><br></pre></td></tr></table></figure><h3 id="使用-bin-转换成2进制形式"><a href="#使用-bin-转换成2进制形式" class="headerlink" title="使用 bin() 转换成2进制形式"></a>使用 bin() 转换成2进制形式</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">num = <span class="number">10</span></span><br><span class="line">val = bin(num).replace(<span class="string">'0b'</span>,<span class="string">''</span>)</span><br><span class="line">print(type(val), val)</span><br><span class="line"></span><br><span class="line"><span class="comment">#&lt;class 'str'&gt; 1010</span></span><br></pre></td></tr></table></figure><h2 id="str-gt-int"><a href="#str-gt-int" class="headerlink" title="str -&gt; int"></a>str -&gt; int</h2><p>这个转换比较专一，只使用 <code>int()</code> 函数就可以了，这个函数实际上有两个参数，第二个参数表示进制，默认是10进制，你可以改成2进制或者16进制，甚至是3进制、5进制等等</p><h3 id="使用-int-进行各进制数字转换"><a href="#使用-int-进行各进制数字转换" class="headerlink" title="使用 int() 进行各进制数字转换"></a>使用 int() 进行各进制数字转换</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">val = int(<span class="string">'10'</span>)</span><br><span class="line">print(type(val), val)</span><br><span class="line"></span><br><span class="line">val = int(<span class="string">'0xa'</span>, <span class="number">16</span>)</span><br><span class="line">print(type(val), val)</span><br><span class="line">val = int(<span class="string">'a'</span>, <span class="number">16</span>)</span><br><span class="line">print(type(val), val)</span><br><span class="line"></span><br><span class="line">val = int(<span class="string">'0b1010'</span>, <span class="number">2</span>)</span><br><span class="line">print(type(val), val)</span><br><span class="line">val = int(<span class="string">'1010'</span>, <span class="number">2</span>)</span><br><span class="line">print(type(val), val)</span><br><span class="line"></span><br><span class="line">val = int(<span class="string">'101'</span>, <span class="number">3</span>)</span><br><span class="line">print(type(val), val)</span><br><span class="line"></span><br><span class="line">val = int(<span class="string">'60'</span>, <span class="number">5</span>)</span><br><span class="line">print(type(val), val)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果均为 &lt;class 'int'&gt; 10</span></span><br></pre></td></tr></table></figure><p>使用 <code>int()</code> 函数的时候要主要注意一点，如果提供的字符串不能转换成指定进制的数字，那么会报异常，就像下面这样，所以在使用这个函数的时候最好放到 <code>try</code> 语句中。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">val = int(<span class="string">'128'</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">Traceback (most recent call last):</span></span><br><span class="line"><span class="string">  File "D:\python\convert\convert.py", line 41, in &lt;module&gt;</span></span><br><span class="line"><span class="string">    val = int('128', 2)</span></span><br><span class="line"><span class="string">ValueError: invalid literal for int() with base 2: '128'</span></span><br><span class="line"><span class="string">[Finished in 0.1s with exit code 1]</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><h2 id="什么是bytes"><a href="#什么是bytes" class="headerlink" title="什么是bytes"></a>什么是bytes</h2><p>在列举 bytes 相关的转化前，我们来先认识一下这个类型，在 Python3 中 <code>int</code>、<code>str</code>、<code>bytes</code> 类型的变量实际上都是一个 “类” 的对象，而 <code>bytes</code> 相比 <code>str</code> 而言更接近底层数据，也更接近存储的形式，它其实是一个字节的数组，类似于 <code>C</code> 语言中的 <code>char []</code>，每个字节是一个范围在 0-255 的数字。</p><p><code>bytes</code> 其实就是这样一连串的数字，计算机世界所有的信息都可以用这样一串数字表示，一幅画，一首歌，一部电影等等，如果对编码感兴趣可以看看这篇<a href="https://blog.csdn.net/albertsh/article/details/110357193" target="_blank" rel="noopener">《简单聊聊01世界中编码和解码这对磨人的小妖儿》</a>，现在清楚bytes是什么了，我们可以看看和它相关的转化了。</p><h2 id="int-gt-bytes"><a href="#int-gt-bytes" class="headerlink" title="int -&gt; bytes"></a>int -&gt; bytes</h2><h3 id="使用-to-bytes-转换成定长bytes"><a href="#使用-to-bytes-转换成定长bytes" class="headerlink" title="使用 to_bytes() 转换成定长bytes"></a>使用 to_bytes() 转换成定长bytes</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">num = <span class="number">4665</span></span><br><span class="line">val = num.to_bytes(length=<span class="number">4</span>, byteorder=<span class="string">'little'</span>, signed=<span class="keyword">False</span>)</span><br><span class="line">print(type(val), val)</span><br><span class="line"></span><br><span class="line"><span class="comment">#&lt;class 'bytes'&gt; b'9\x12\x00\x00'</span></span><br></pre></td></tr></table></figure><p>这段代码就是把数字 4665 转化成定长的4个字节，字节序为小端，我们来简单看一下是怎么转换的：</p><p>上面我们提到 <code>bytes</code> 类型一串 0-255 范围的数字，4665 肯定超出了这个范围，可以先转化成256进制，就变成了 <18><57>，也就是 4665 = 18 * 256 + 57，我们发现两个字节就能存储这个数字，一个18，一个57，要想组成4个字节的数组需要补充两个空位，也就是补充两个0，这时就涉及到一个排列顺序，是 [0,0,18,57] 还是 [57, 18, 0, 0] 呢，这就是函数参数中的字节序 <code>byteorder</code>，little 表示小端，big 表示大端，这里选择的小端 [57, 18, 0, 0] 的排列。</57></18></p><p>看到这里可能会迷糊，好像和结果不一样啊，其实这只是一个表示问题，57 的 ASCII 码对应这个字符 ‘9’，18 表示成16进制就是 ‘0x12’，这里写成 b’9\x12\x00\x00’ 只是便于识别而已，实际上内存存储的就是 [57, 18, 0, 0] 这一串数字对应的二进制编码 ‘00111001 00010010 00000000 00000000’。</p><h3 id="使用-bytes-函数把int数组转成bytes"><a href="#使用-bytes-函数把int数组转成bytes" class="headerlink" title="使用 bytes() 函数把int数组转成bytes"></a>使用 bytes() 函数把int数组转成bytes</h3><p>参考上面的生成的数组，可以通过数组生成相同的结果</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">num_array = [<span class="number">57</span>, <span class="number">18</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">val = bytes(num_array)</span><br><span class="line">print(type(val), val)</span><br><span class="line"></span><br><span class="line"><span class="comment">#&lt;class 'bytes'&gt; b'9\x12\x00\x00'</span></span><br></pre></td></tr></table></figure><h3 id="使用-struct-pack-函数把数字转化成bytes"><a href="#使用-struct-pack-函数把数字转化成bytes" class="headerlink" title="使用 struct.pack() 函数把数字转化成bytes"></a>使用 struct.pack() 函数把数字转化成bytes</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">num = <span class="number">4665</span></span><br><span class="line">val = struct.pack(<span class="string">"&lt;I"</span>, num)</span><br><span class="line">print(type(val), val)</span><br><span class="line"></span><br><span class="line"><span class="comment">#&lt;class 'bytes'&gt; b'9\x12\x00\x00'</span></span><br></pre></td></tr></table></figure><p>这里的 <code>&quot;&lt;I&quot;</code> 表示将一个整数转化成小端字节序的4字节数组，其他的类型还有：</p><table><thead><tr><th style="text-align:left">参数</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:left">&gt;</td><td style="text-align:center">大端序</td></tr><tr><td style="text-align:left">&lt;</td><td style="text-align:center">小端序</td></tr><tr><td style="text-align:left">B</td><td style="text-align:center">uint8类型</td></tr><tr><td style="text-align:left">b</td><td style="text-align:center">int8类型</td></tr><tr><td style="text-align:left">H</td><td style="text-align:center">uint16类型</td></tr><tr><td style="text-align:left">h</td><td style="text-align:center">int16类型</td></tr><tr><td style="text-align:left">I</td><td style="text-align:center">uint32类型</td></tr><tr><td style="text-align:left">i</td><td style="text-align:center">int32类型</td></tr><tr><td style="text-align:left">L</td><td style="text-align:center">uint64类型</td></tr><tr><td style="text-align:left">l</td><td style="text-align:center">int64类型</td></tr><tr><td style="text-align:left">s</td><td style="text-align:center">ascii码，s前带数字表示个数</td></tr></tbody></table><h2 id="bytes-gt-int"><a href="#bytes-gt-int" class="headerlink" title="bytes -&gt; int"></a>bytes -&gt; int</h2><p>明白了上面的转化过程，从 bytes 转化到 int 只需要反着来就行了</p><h3 id="使用-from-bytes-把-bytes-转化成int"><a href="#使用-from-bytes-把-bytes-转化成int" class="headerlink" title="使用 from_bytes() 把 bytes 转化成int"></a>使用 from_bytes() 把 bytes 转化成int</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">bys = <span class="string">b'9\x12\x00\x00'</span></span><br><span class="line">val = int.from_bytes(bys, byteorder=<span class="string">'little'</span>, signed=<span class="keyword">False</span>)</span><br><span class="line">print(type(val), val)</span><br><span class="line"></span><br><span class="line"><span class="comment">#&lt;class 'int'&gt; 4665</span></span><br></pre></td></tr></table></figure><h3 id="使用-struct-unpack-把-bytes-转化成int"><a href="#使用-struct-unpack-把-bytes-转化成int" class="headerlink" title="使用 struct.unpack() 把 bytes 转化成int"></a>使用 struct.unpack() 把 bytes 转化成int</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">bys = <span class="string">b'9\x12\x00\x00'</span></span><br><span class="line">val = struct.unpack(<span class="string">"&lt;I"</span>, bys)</span><br><span class="line">print(type(val), val)</span><br><span class="line"></span><br><span class="line"><span class="comment">#&lt;class 'tuple'&gt; (4665,)</span></span><br></pre></td></tr></table></figure><h2 id="str-和-bytes"><a href="#str-和-bytes" class="headerlink" title="str 和 bytes"></a>str 和 bytes</h2><p>前面的这些转化还算清晰，到了字符串str 和字节串 bytes，就开始进入了混沌的状态，这里会出现各种编码，各种乱码，各种报错，牢记一点 str 到 bytes 是编码过程，需要使用 <code>encode()</code> 函数， bytes 到 str 是解码过程，需要使用 <code>decode()</code> 函数，请勿使用 <code>str</code> 函数，否则后果自负。</p><h3 id="使用-encode-函数完成-str-gt-bytes"><a href="#使用-encode-函数完成-str-gt-bytes" class="headerlink" title="使用 encode() 函数完成  str -&gt; bytes"></a>使用 encode() 函数完成  str -&gt; bytes</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">'大漠孤烟直qaq'</span></span><br><span class="line">val = s.encode(<span class="string">'utf-8'</span>)</span><br><span class="line">print(type(val), val)</span><br><span class="line"></span><br><span class="line"><span class="comment"># &lt;class 'bytes'&gt; b'\xe5\xa4\xa7\xe6\xbc\xa0\xe5\xad\xa4\xe7\x83\x9f\xe7\x9b\xb4qaq'</span></span><br></pre></td></tr></table></figure><h3 id="使用-decode-函数完成-bytes-gt-str"><a href="#使用-decode-函数完成-bytes-gt-str" class="headerlink" title="使用 decode() 函数完成  bytes -&gt; str"></a>使用 decode() 函数完成  bytes -&gt; str</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">bys = <span class="string">b'\xe5\xa4\xa7\xe6\xbc\xa0\xe5\xad\xa4\xe7\x83\x9f\xe7\x9b\xb4qaq'</span></span><br><span class="line">val = bys.decode(<span class="string">'utf-8'</span>)</span><br><span class="line">print(type(val), val)</span><br><span class="line"></span><br><span class="line"><span class="comment"># &lt;class 'str'&gt; 大漠孤烟直qaq</span></span><br></pre></td></tr></table></figure><h2 id="假如使用了-str-函数"><a href="#假如使用了-str-函数" class="headerlink" title="假如使用了 str() 函数"></a>假如使用了 str() 函数</h2><p>从上面来看字符串和字节串的转化蛮简单的，甚至比整数的转化都要简单，但是你如果把一个 bytes 变量用 str() 转化成字符串，你就得手动来处理了，这个函数写过n次了，暂时还没找到好的处理办法。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">bys = <span class="string">b'\xe5\xa4\xa7\xe6\xbc\xa0\xe5\xad\xa4\xe7\x83\x9f\xe7\x9b\xb4qaq'</span></span><br><span class="line">s = str(bys)</span><br><span class="line">print(type(s), s)</span><br><span class="line"><span class="comment">#&lt;class 'str'&gt; b'\xe5\xa4\xa7\xe6\xbc\xa0\xe5\xad\xa4\xe7\x83\x9f\xe7\x9b\xb4qaq'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">str2bytes</span><span class="params">(str_content)</span>:</span></span><br><span class="line">    result_list = [];</span><br><span class="line">    pos = <span class="number">0</span></span><br><span class="line">    str_content = str_content.replace(<span class="string">"\\n"</span>, <span class="string">"\n"</span>).replace(<span class="string">"\\t"</span>, <span class="string">"\t"</span>).replace(<span class="string">"\\r"</span>, <span class="string">"\r"</span>)</span><br><span class="line">    content_len = len(str_content)</span><br><span class="line">    <span class="keyword">while</span> pos &lt; content_len:</span><br><span class="line">        <span class="keyword">if</span> str_content[pos] == <span class="string">'\\'</span> <span class="keyword">and</span> pos + <span class="number">3</span> &lt; content_len <span class="keyword">and</span> str_content[pos + <span class="number">1</span>] == <span class="string">'x'</span>:</span><br><span class="line">            sub_str = str_content[pos + <span class="number">2</span>: pos + <span class="number">4</span>]</span><br><span class="line">            result_list.append(int(sub_str, <span class="number">16</span>))</span><br><span class="line">            pos = pos + <span class="number">4</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            result_list.append(ord(str_content[pos]))</span><br><span class="line">            pos = pos + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> bytes(result_list)</span><br><span class="line"></span><br><span class="line">val = str2bytes(s[<span class="number">2</span>:<span class="number">-1</span>])</span><br><span class="line">print(type(val), val)</span><br><span class="line"></span><br><span class="line"><span class="comment"># &lt;class 'bytes'&gt; b'\xe5\xa4\xa7\xe6\xbc\xa0\xe5\xad\xa4\xe7\x83\x9f\xe7\x9b\xb4qaq'</span></span><br></pre></td></tr></table></figure><p>什么时候会遇到这种情况，就是有些数据是以 bytes 的形式给的，但是经过中间人复制转发变成了字节流形式的字符串，格式还不统一，有些已经翻译成了字符，有些还保留了0x或者\x形式，这时就要手工处理了。</p><h1 id="转化表格"><a href="#转化表格" class="headerlink" title="转化表格"></a>转化表格</h1><p>上面的转化方式和解释穿插在一起有些乱，这里总结一个表格，便于今后拿来就用</p><table><thead><tr><th style="text-align:left">源类型</th><th style="text-align:center">目标类型</th><th style="text-align:center">方式</th><th style="text-align:center">结果</th></tr></thead><tbody><tr><td style="text-align:left">int</td><td style="text-align:center">str</td><td style="text-align:center"><code>str(10)</code>、<code>&#39;{0}&#39;.format(10)</code></td><td style="text-align:center"><code>10</code> =&gt; <code>&#39;10&#39;</code></td></tr><tr><td style="text-align:left">int</td><td style="text-align:center">str（16进制）</td><td style="text-align:center"><code>hex(10)</code></td><td style="text-align:center"><code>10</code> =&gt; <code>&#39;0xa&#39;</code></td></tr><tr><td style="text-align:left">int</td><td style="text-align:center">str（2进制）</td><td style="text-align:center"><code>bin(10).replace(&#39;0b&#39;,&#39;&#39;)</code></td><td style="text-align:center"><code>10</code> =&gt; <code>&#39;1010&#39;</code></td></tr><tr><td style="text-align:left">str</td><td style="text-align:center">int</td><td style="text-align:center"><code>int(&#39;10&#39;)</code></td><td style="text-align:center"><code>&#39;10&#39;</code> =&gt; <code>10</code></td></tr><tr><td style="text-align:left">str（16进制）</td><td style="text-align:center">int</td><td style="text-align:center"><code>int(&#39;0xa&#39;, 16)</code></td><td style="text-align:center"><code>&#39;0xa&#39;</code> =&gt; <code>10</code></td></tr><tr><td style="text-align:left">str（2进制）</td><td style="text-align:center">int</td><td style="text-align:center"><code>int(&#39;1010&#39;, 2)</code></td><td style="text-align:center"><code>&#39;1010&#39;</code> =&gt; <code>10</code></td></tr><tr><td style="text-align:left">int</td><td style="text-align:center">bytes</td><td style="text-align:center"><code>num.to_bytes(length=4, byteorder=&#39;little&#39;, signed=False)</code></td><td style="text-align:center"><code>4665</code> =&gt; <code>b&#39;9\x12\x00\x00&#39;</code></td></tr><tr><td style="text-align:left">int</td><td style="text-align:center">bytes</td><td style="text-align:center"><code>struct.pack(&quot;&lt;I&quot;, 4665)</code></td><td style="text-align:center"><code>4665</code> =&gt; <code>b&#39;9\x12\x00\x00&#39;</code></td></tr><tr><td style="text-align:left">bytes</td><td style="text-align:center">int</td><td style="text-align:center"><code>int.from_bytes(b&#39;9\x12\x00\x00&#39;, byteorder=&#39;little&#39;, signed=False)</code></td><td style="text-align:center"><code>b&#39;9\x12\x00\x00&#39;</code> =&gt; <code>4665</code></td></tr><tr><td style="text-align:left">bytes</td><td style="text-align:center">int</td><td style="text-align:center"><code>struct.unpack(&quot;&lt;I&quot;, b&#39;9\x12\x00\x00&#39;)</code></td><td style="text-align:center"><code>b&#39;9\x12\x00\x00&#39;</code> =&gt; <code>4665</code></td></tr><tr><td style="text-align:left">int[]</td><td style="text-align:center">bytes</td><td style="text-align:center"><code>bytes([57, 18, 0, 0])</code></td><td style="text-align:center"><code>[57, 18, 0, 0]</code> =&gt; <code>b&#39;9\x12\x00\x00&#39;</code></td></tr><tr><td style="text-align:left">bytes</td><td style="text-align:center">int[]</td><td style="text-align:center"><code>[x for x in b&#39;9\x12\x00\x00&#39;]</code></td><td style="text-align:center"><code>b&#39;9\x12\x00\x00&#39;</code> =&gt; <code>[57, 18, 0, 0]</code></td></tr><tr><td style="text-align:left">str</td><td style="text-align:center">bytes</td><td style="text-align:center"><code>&#39;美好&#39;.encode(&#39;utf-8&#39;)</code></td><td style="text-align:center"><code>&#39;美好&#39;</code> =&gt; <code>b&#39;\xe7\xbe\x8e\xe5\xa5\xbd&#39;</code></td></tr><tr><td style="text-align:left">str</td><td style="text-align:center">bytes</td><td style="text-align:center"><code>bytes(&#39;美好&#39;, &#39;utf-8&#39;)</code></td><td style="text-align:center"><code>&#39;美好&#39;</code> =&gt; <code>b&#39;\xe7\xbe\x8e\xe5\xa5\xbd&#39;</code></td></tr><tr><td style="text-align:left">bytes</td><td style="text-align:center">str</td><td style="text-align:center"><code>b&#39;\xe7\xbe\x8e\xe5\xa5\xbd&#39;.decode(&#39;utf-8&#39;)</code></td><td style="text-align:center"><code>b&#39;\xe7\xbe\x8e\xe5\xa5\xbd&#39;</code> =&gt; <code>&#39;美好&#39;</code></td></tr><tr><td style="text-align:left">bytes</td><td style="text-align:center">bytes（无\x）</td><td style="text-align:center"><code>binascii.b2a_hex(b&#39;\xe7\xbe\x8eqaq&#39;)</code></td><td style="text-align:center"><code>b&#39;\xe7\xbe\x8eqaq&#39;</code> =&gt; <code>b&#39;e7be8e716171&#39;</code></td></tr><tr><td style="text-align:left">bytes</td><td style="text-align:center">bytes（有\x）</td><td style="text-align:center"><code>binascii.a2b_hex(b&#39;e7be8e716171&#39;)</code></td><td style="text-align:center"><code>b&#39;e7be8e716171&#39;</code> =&gt; <code>b&#39;\xe7\xbe\x8eqaq&#39;</code></td></tr><tr><td style="text-align:left">bytes</td><td style="text-align:center">str（hex）</td><td style="text-align:center"><code>b&#39;\xe7\xbe\x8eqaq&#39;.hex()</code></td><td style="text-align:center"><code>b&#39;\xe7\xbe\x8eqaq&#39;</code> =&gt; <code>&#39;e7be8e716171&#39;</code></td></tr><tr><td style="text-align:left">str（hex）</td><td style="text-align:center">bytes</td><td style="text-align:center"><code>bytes.fromhex(&#39;e7be8e716171&#39;)</code></td><td style="text-align:center"><code>&#39;e7be8e716171&#39;</code> =&gt; <code>b&#39;\xe7\xbe\x8eqaq&#39;</code></td></tr></tbody></table><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>Python3 对字符串和二进制数据流做了明确的区分，不会以任意隐式的方式混用 <code>str</code> 和 <code>bytes</code></li><li><code>bytes</code> 类型是一种比特流，它的存在形式是 01010001110 的形式，需要解码成字符才容易被人理解</li><li>struct 模块中的 <code>pack()</code> 和 <code>unpack()</code> 可以实现任意类型和 <code>bytes</code> 之间的转换</li><li><code>binascii.b2a_hex</code> 和 <code>binascii.a2b_hex</code> 可以实现16进制 bytes 的不同形式转换，不过转换前后长度发生了变化</li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/114199056" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>初识不知曲中意，再闻已是曲中人</p><p>2021-3-6 20:36:10</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;数据类型转换是个很基础的操作，很多语言中都要做这些转换，例如前一段时间刚刚总结了&lt;a href=&quot;https://blog.csdn.net/albertsh/article/details/113765130&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《C/C++中string和int相互转换的常用方法》&lt;/a&gt;，python 自从分离出 python3 版本之后，&lt;code&gt;str&lt;/code&gt; 和 &lt;code&gt;bytes&lt;/code&gt; 两个类型弄蒙了一大票人，在这两种类型的转换上我可是花了不少时间，记住一点，别随随便便使用 &lt;code&gt;str()&lt;/code&gt; 函数，很多数据使用 &lt;code&gt;str()&lt;/code&gt; 变成字符串之后再想恢复可就难了。&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="http://AlbertGithubHome.github.io/blog/categories/Python/"/>
    
    
      <category term="int" scheme="http://AlbertGithubHome.github.io/blog/tags/int/"/>
    
      <category term="hex" scheme="http://AlbertGithubHome.github.io/blog/tags/hex/"/>
    
      <category term="Python" scheme="http://AlbertGithubHome.github.io/blog/tags/Python/"/>
    
      <category term="str" scheme="http://AlbertGithubHome.github.io/blog/tags/str/"/>
    
      <category term="bytes" scheme="http://AlbertGithubHome.github.io/blog/tags/bytes/"/>
    
  </entry>
  
</feed>
