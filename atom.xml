<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Albert World</title>
  <icon>https://www.gravatar.com/avatar/8ccc6291d5bfd34e7aaf601c4ebec7e1</icon>
  
  <link href="/blog/atom.xml" rel="self"/>
  
  <link href="http://AlbertGithubHome.github.io/blog/"/>
  <updated>2021-02-21T15:29:58.021Z</updated>
  <id>http://AlbertGithubHome.github.io/blog/</id>
  
  <author>
    <name>Albert Shi</name>
    <email>347070901@qq.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Go环境配置时遇到的GOPATH路径以及包管理问题</title>
    <link href="http://AlbertGithubHome.github.io/blog/2021/02/19/Go%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E6%97%B6%E9%81%87%E5%88%B0%E7%9A%84GOPATH%E8%B7%AF%E5%BE%84%E4%BB%A5%E5%8F%8A%E5%8C%85%E7%AE%A1%E7%90%86%E9%97%AE%E9%A2%98/"/>
    <id>http://AlbertGithubHome.github.io/blog/2021/02/19/Go环境配置时遇到的GOPATH路径以及包管理问题/</id>
    <published>2021-02-19T14:39:19.000Z</published>
    <updated>2021-02-21T15:29:58.021Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>过了个年回到工作岗位，发现之前好好的 <code>Go</code> 环境无法进行调试了，于是又重新配置了一次，弄好之后的新参数与原来有一些不一样的地方，甚至还有一些矛盾的地方，真搞不清楚原来的配置参数怎么能成功调试的，也是奇了怪了。配置过程中还遇到了一些问题，特别记录一下，防止今后遇到类似问题还要苦苦寻找。</p><a id="more"></a><h1 id="Go-的环境变量"><a href="#Go-的环境变量" class="headerlink" title="Go 的环境变量"></a>Go 的环境变量</h1><p>说起环境变量，写 <code>Java</code> 的时候倒是配置了不少，一般都需要配置 <code>JAVA_HOME</code> 和 <code>CLASSPATH</code>，后来 C/C++ 写的比较多，完全不需要这个东西，直接使用 <code>include</code> 把绝对路径或者相对路径引用进来就可以，或者使用VS的项目属性界面配置包含路径，也可以将包含路径写在 <code>CMakeLists.txt</code> 中。但是为了能找到和使用各种工具和软件，它们所在的路径一般会加到环境变量<code>Path</code>中。</p><p><code>Go</code> 中也有两个环境变量非常重要，它们分别是 <code>GOROOT</code> 和 <code>GOPATH</code>，其中 <code>GOROOT</code> 比较好理解，就是 <code>Go</code> 软件安装的目录，可以类比一下 <code>JAVA_HOME/bin</code>，而 <code>GOPATH</code> 就是一个神奇的存在，在go1.12版本之前，<code>Go</code> 语言编写的项目代码和下载的包都必须在 <code>GOPATH</code> 目录下，想像一下，在一个 <code>GOPATH</code> 目录下无数个项目go文件，那感觉真是酸爽。</p><h1 id="GOPATH-的设计"><a href="#GOPATH-的设计" class="headerlink" title="GOPATH 的设计"></a>GOPATH 的设计</h1><p><code>GOPATH</code>设计的出发点是好的，将代码包统一存储到一个目录下，直接引用包名就可以了，可是这样设计也缺少了自由，下载的第三方包和自己的项目文件混在一起虽然可以方便查看代码，但是结构看起来确实很乱。</p><p>什么？你说 <code>GOPATH</code> 可以指定多个目录，确实很多资料说 <code>GOPATH</code> 支持多个目录，下载的包会默认放在 <code>GOPATH</code> 指定的第一个目录下，需要注意的一个点是在windows下指定多个目录需要用分号分隔，而Linux下指定多个目录需要用冒号分隔，并且指定的目录需要是用绝对路径，如果指定的目录中包含相对路径，会报一个 <code>go: GOPATH entry is relative; must be absolute path: &quot;...</code> 错误，记得 <code>GOPATH</code> 变量末尾不要加 <code>:</code> 或者 <code>;</code>。</p><p>春节前我就是配置的多个目录，本来调试用的好好的，结果过完年现在不让用了，一调试就会报错 <code>unexpected directory layout:</code>，具体的报错内容结构如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">unexpected directory layout:</span><br><span class="line">        import path: _/go/src/firstgo</span><br><span class="line">        root: /go/src</span><br><span class="line">        dir: /go/src/firstgo</span><br><span class="line">        expand root: /go</span><br><span class="line">        expand dir: /go/src/firstgo</span><br><span class="line">        separator: /</span><br></pre></td></tr></table></figure><p>后来参考了下面两篇文章，把 <code>GOPATH</code> 改成单一目录就好了。</p><ul><li><a href="https://www.gitmemory.com/issue/golang/go/33752/523826861" target="_blank" rel="noopener">cmd/go: unexpected directory layout while building project</a></li><li><a href="https://www.jianshu.com/p/b226e1433bab" target="_blank" rel="noopener">go get 报错 unexpected directory layout</a></li></ul><p>也就是在linux下的 <code>~/.profile</code> 文件中把 <code>export GOPATH=/home/albert/go:/home/albert/WorkSpace/go</code> 改成 <code>export GOPATH=/home/albert/go</code> 就可以了。</p><h1 id="GOPATH-的发展"><a href="#GOPATH-的发展" class="headerlink" title="GOPATH 的发展"></a>GOPATH 的发展</h1><p>早期版本的 <code>GOPATH</code> 设计所有包下载到指定的目录，并且没有版本号，如果多个项目引用的同一个包的不同版本那就歇菜了，所以说这时的 <code>Go</code> 管理仅仅处于能用的状态，也就相当于一个下载器，达不到软件包管理器的及格水平，后来出现了一些例如 <code>dep</code>、<code>Godep</code> 的包管理工具，均属于官方推荐的第三方管理工具，都非 <code>Go</code> 语言自带。</p><p><code>Go</code> 的包管理工具并不像 Python 的 pip，或者 JS 的 npm 那样统一，本质上还是设计不同导致的，<code>Go</code> 想做的包管理是一种分布式的，没有Python 或者 JS 那种中心仓库，这样又带来了一个弊端，如果包的提供者频繁提交新版本怎么办，所以在包管理的工作中，版本号是必须要存在的。</p><p>关于之前GO项目为什么非要放在 <code>GOPATH</code> 下，以及 GO的包管理发展历程可以参考下面文章：</p><ul><li><a href="https://juejin.cn/post/6844903849916907534" target="_blank" rel="noopener">GO问答之为什么项目要在 GOPATH/src 目录下</a></li><li><a href="https://www.infoq.cn/article/history-go-package-management" target="_blank" rel="noopener">Go 包管理的前世今生</a></li></ul><p>直到 <code>go mod</code> 出现以后，在<code>Go</code> 中引入第三方模块算是方便了不少，参考<a href="https://segmentfault.com/a/1190000018690961" target="_blank" rel="noopener">《拜拜了，GOPATH君！新版本Golang的包管理入门教程》</a></p><ul><li><a href="https://www.jianshu.com/p/760c97ff644c" target="_blank" rel="noopener">go mod使用</a></li><li><a href="https://segmentfault.com/q/1010000020696591#" target="_blank" rel="noopener">go mod 怎么导入本地其它项目的包？</a></li><li><a href="https://studygolang.com/articles/25658" target="_blank" rel="noopener">谈谈go.sum</a></li></ul><h1 id="Go-的常用命令"><a href="#Go-的常用命令" class="headerlink" title="Go 的常用命令"></a>Go 的常用命令</h1><p><code>Go</code> 作为一种语言，同时也代表了一系列工具和生态环境，它的命令有不少，下面列举一些常见的：</p><ul><li><strong>go env</strong>: 打印go的环境信息</li><li><strong>go fmt</strong>: 运行gofmt对go代码进行格式化</li><li><strong>go build</strong>: 编译包和依赖</li><li><strong>go run</strong>: 编译并运行go程序</li><li><strong>go version</strong>: 显示go程序的版本</li><li><strong>go help</strong>: 打印命令的帮助信息</li><li><strong>go get</strong>: 下载并安装包和依赖（-v 显示操作流程的日志及信息；-u 下载丢失的包，但不会更新已经存在的包）</li></ul><p>其中 <code>go help</code> 不仅仅打印了这些命令的基本信息，还可以打印出一些概念的帮助信息， 例如 <code>go help gopath</code>，内容比较多，下面只列举一小部分:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">Here<span class="string">'s an example directory layout:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    GOPATH=/home/user/go</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    /home/user/go/</span></span><br><span class="line"><span class="string">        src/</span></span><br><span class="line"><span class="string">            foo/</span></span><br><span class="line"><span class="string">                bar/               (go code in package bar)</span></span><br><span class="line"><span class="string">                    x.go</span></span><br><span class="line"><span class="string">                quux/              (go code in package main)</span></span><br><span class="line"><span class="string">                    y.go</span></span><br><span class="line"><span class="string">        bin/</span></span><br><span class="line"><span class="string">            quux                   (installed command)</span></span><br><span class="line"><span class="string">        pkg/</span></span><br><span class="line"><span class="string">            linux_amd64/</span></span><br><span class="line"><span class="string">                foo/</span></span><br><span class="line"><span class="string">                    bar.a          (installed package object)</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="string">...</span></span><br></pre></td></tr></table></figure><p>运行 <code>go env</code> 展示一下当前使用的环境，方便以后做个对照：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">$ go env</span><br><span class="line">GO111MODULE=<span class="string">""</span></span><br><span class="line">GOARCH=<span class="string">"amd64"</span></span><br><span class="line">GOBIN=<span class="string">""</span></span><br><span class="line">GOCACHE=<span class="string">"/home/albert/.cache/go-build"</span></span><br><span class="line">GOENV=<span class="string">"/home/albert/.config/go/env"</span></span><br><span class="line">GOEXE=<span class="string">""</span></span><br><span class="line">GOFLAGS=<span class="string">""</span></span><br><span class="line">GOHOSTARCH=<span class="string">"amd64"</span></span><br><span class="line">GOHOSTOS=<span class="string">"linux"</span></span><br><span class="line">GOINSECURE=<span class="string">""</span></span><br><span class="line">GOMODCACHE=<span class="string">"/home/albert/WorkSpace/go1/pkg/mod"</span></span><br><span class="line">GONOPROXY=<span class="string">""</span></span><br><span class="line">GONOSUMDB=<span class="string">""</span></span><br><span class="line">GOOS=<span class="string">"linux"</span></span><br><span class="line">GOPATH=<span class="string">"/home/albert/WorkSpace/go1"</span></span><br><span class="line">GOPRIVATE=<span class="string">""</span></span><br><span class="line">GOPROXY=<span class="string">"https://proxy.golang.org,direct"</span></span><br><span class="line">GOROOT=<span class="string">"/usr/local/go"</span></span><br><span class="line">GOSUMDB=<span class="string">"sum.golang.org"</span></span><br><span class="line">GOTMPDIR=<span class="string">""</span></span><br><span class="line">GOTOOLDIR=<span class="string">"/usr/local/go/pkg/tool/linux_amd64"</span></span><br><span class="line">GCCGO=<span class="string">"gccgo"</span></span><br><span class="line">AR=<span class="string">"ar"</span></span><br><span class="line">CC=<span class="string">"gcc"</span></span><br><span class="line">CXX=<span class="string">"g++"</span></span><br><span class="line">CGO_ENABLED=<span class="string">"1"</span></span><br><span class="line">GOMOD=<span class="string">""</span></span><br><span class="line">CGO_CFLAGS=<span class="string">"-g -O2"</span></span><br><span class="line">CGO_CPPFLAGS=<span class="string">""</span></span><br><span class="line">CGO_CXXFLAGS=<span class="string">"-g -O2"</span></span><br><span class="line">CGO_FFLAGS=<span class="string">"-g -O2"</span></span><br><span class="line">CGO_LDFLAGS=<span class="string">"-g -O2"</span></span><br><span class="line">PKG_CONFIG=<span class="string">"pkg-config"</span></span><br><span class="line">GOGCCFLAGS=<span class="string">"-fPIC -m64 -pthread -fmessage-length=0</span></span><br><span class="line"><span class="string">    -fdebug-prefix-map=/tmp/go-build602227063=/tmp/go-build -gno-record-gcc-switches"</span></span><br></pre></td></tr></table></figure><h1 id="VSCode-Remote-时修改的环境变量不生效"><a href="#VSCode-Remote-时修改的环境变量不生效" class="headerlink" title="VSCode Remote 时修改的环境变量不生效"></a>VSCode Remote 时修改的环境变量不生效</h1><p>这个问题也是在这次配置 <code>Go</code> 调试环境时遇到的，我是在 <code>~/.profile</code> 文件中修改的 <code>GOPATH</code>的内容，但是在VSCode中调试时就是报错，其表现就跟修改的变量未生效一致，后来查资料发现，原来出现这种情况和配置文件的加载顺序有关，具体参考下列文章：</p><ul><li><a href="https://debug.fanzheng.org/post/vscode-remote-env-loading-sequel.html" target="_blank" rel="noopener">VSCode Remote环境变量加载——续</a></li><li><a href="https://github.com/microsoft/vscode-remote-release/issues/83" target="_blank" rel="noopener">remote-ssh: .profile not sourced for bash shells, only .bashrc? #83</a></li><li><a href="https://unix.stackexchange.com/questions/50665/what-is-the-difference-between-interactive-shells-login-shells-non-login-shell" target="_blank" rel="noopener">What is the difference between interactive shells, login shells, non-login shell and their use cases?</a></li></ul><p>其实在linux中的shell有 <code>interactive shell</code>、 <code>non-interactive shell</code>、 <code>login shell</code>、 <code>non-login shell</code> 的区分，每种情况下调用的初始化脚本不同，涉及到 <code>/etc/profile</code>、<code>~/.bash_profile</code> <code>~/.bash_login /</code> <code>~/.profile</code>等等，而在VSCode远程连接Linux时还会继承之前的环境，多次尝试之后还是不起效果，此时不得不高呼“重启大法好”，重启能解决80%的问题，剩下的20%只能靠重做系统来解决了。</p><p>在我这修改脚本内容不生效，脚本间调用还搞出了死循环的问题，不知道是不是因为我使用 <code>zsh</code> 这个 <code>shell</code>作为默认环境出的问题，但重启大法依然奏效，电脑重启后环境变量成功修改了。</p><h1 id="C-的包管理器"><a href="#C-的包管理器" class="headerlink" title="C++ 的包管理器"></a>C++ 的包管理器</h1><p>捣鼓这么久 <code>Go</code>，突然想到一个问题，<code>C++</code> 有没有包管理器呢？答案是有的，并且有很多，但是都存在着这样或那样的问题，可以重点看一下 <code>conan</code>，具体使用可以搜索官网，或者看看下面这些总结。</p><ul><li><a href="http://chu-studio.com/posts/2019/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84C++%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8CONAN%E4%B8%8A%E6%89%8B%E6%8C%87%E5%8D%97" target="_blank" rel="noopener">从零开始的C++包管理器CONAN上手指南</a></li><li><a href="https://www.cnblogs.com/xl2432/p/11873394.html" target="_blank" rel="noopener">conan使用(一)–安装和应用</a></li></ul><p><code>conan</code> 是一款使用 <code>python</code> 开发的包管理工具，所以需要依赖 <code>Python</code> 环境，CentOS 平台上安装 Python 环境可以参考 <a href="https://zhuanlan.zhihu.com/p/47508850" target="_blank" rel="noopener">Centos安装python3.6和pip步骤记录</a>，虽然CentOS即将被放弃，但是目前在各种云服务器上依旧是主流系统，安装 Python 环境时需要注意一步步跟着做，最好不要投机取巧，我就是因为少安装了一个依赖，导致我使用 <code>pip install conan</code>命令安装 <code>conan</code> 是报错 <code>ModuleNotFoundError: No module named &#39;_ctypes&#39;</code>，此时可以安装依赖，重新编译安装 ·conan· 就可以了，也就是运行 <code>yum install libffi-devel -y</code>，重新 <code>make clean &amp;&amp; make &amp;&amp; make install</code> 就可以了。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>Go 的项目在 1.12 版本之后不必放到 <code>GOPATH</code> 路径中了，灵活度大大提高</li><li>C++ 也是有包管理器的，其中 conan 排名比较靠前，它是由 Python 语言编写的</li><li><code>go get</code> 是安装依赖包常常要用到的 Go 命令， <code>go help</code> 会提供 Go 相关的许多知识</li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/113812016" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>有时正确的选择比刻苦努力更加重要，用战术上的勤奋来掩盖战略上的懒惰，其结果只是感动了自己，而不会带我们达到目标。将者，智信仁勇严也~</p><p>2021-2-21 01:19:01</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;过了个年回到工作岗位，发现之前好好的 &lt;code&gt;Go&lt;/code&gt; 环境无法进行调试了，于是又重新配置了一次，弄好之后的新参数与原来有一些不一样的地方，甚至还有一些矛盾的地方，真搞不清楚原来的配置参数怎么能成功调试的，也是奇了怪了。配置过程中还遇到了一些问题，特别记录一下，防止今后遇到类似问题还要苦苦寻找。&lt;/p&gt;
    
    </summary>
    
      <category term="Go" scheme="http://AlbertGithubHome.github.io/blog/categories/Go/"/>
    
    
      <category term="Go" scheme="http://AlbertGithubHome.github.io/blog/tags/Go/"/>
    
      <category term="GOPATH" scheme="http://AlbertGithubHome.github.io/blog/tags/GOPATH/"/>
    
      <category term="mod" scheme="http://AlbertGithubHome.github.io/blog/tags/mod/"/>
    
      <category term="包管理" scheme="http://AlbertGithubHome.github.io/blog/tags/%E5%8C%85%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>TCP/IP协议簇中的子网掩码有什么作用</title>
    <link href="http://AlbertGithubHome.github.io/blog/2021/02/14/TCP-IP%E5%8D%8F%E8%AE%AE%E7%B0%87%E4%B8%AD%E7%9A%84%E5%AD%90%E7%BD%91%E6%8E%A9%E7%A0%81%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8/"/>
    <id>http://AlbertGithubHome.github.io/blog/2021/02/14/TCP-IP协议簇中的子网掩码有什么作用/</id>
    <published>2021-02-14T15:55:30.000Z</published>
    <updated>2021-02-19T13:57:45.278Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>前几天在配置数据库主从结构时查询了一些IP配置，后来编写远程执行脚本时又配置了一些IP数据，在<code>linux</code>上使用 <code>ifconfig</code> 命令查询IP配置时发现子网掩码不是常用的3个255，而是 <code>255.255.254.0</code>，只是简单记得这样配置扩大了子网的范围，但是具体子网掩码怎么使用还是记不清楚了，所以查询了这些还给老师的知识，在此总结一下。</p><a id="more"></a><h1 id="IP地址分类"><a href="#IP地址分类" class="headerlink" title="IP地址分类"></a>IP地址分类</h1><p>关于IPv4的地址分类之前有专门的总结，可以参考这一篇<a href="https://blog.csdn.net/albertsh/article/details/88914811" target="_blank" rel="noopener">《IP地址常见分类：A类、B类、C类、D类、E类》</a>，其中常用到的也就是A类、B类、C类这三种，默认的子网掩码分别为 <code>255.0.0.0</code>、<code>255.255.0.0</code>、<code>255.255.255.0</code>，通过IP地址和子网掩码进行与运算可以得出IP地址所对应的网络地址。</p><h1 id="子网掩码"><a href="#子网掩码" class="headerlink" title="子网掩码"></a>子网掩码</h1><p>子网掩码通过它的名字来判断肯定和子网有关系，掩码又有遮遮掩掩之意，合在一起其实就是通过其作用来进行的命名，也就是对IP地址进行遮掩，然后得到子网地址的作用。</p><h2 id="掩码的作用"><a href="#掩码的作用" class="headerlink" title="掩码的作用"></a>掩码的作用</h2><p>刚刚说通过子网掩码和IP地址可以获得网络地址，那么没有子网掩码可不可以呢？实际上如果进行某些约定就可以不使用子网掩码来获得网络地址，比如IPv4是通过4个字节来表示一个IP地址的，分为网络号和主机号两部分，A类IP地址可以使用第一字节表示网络号，B类地址使用前两个字节表示网络号，C类地址使用前3个字节表示网络号，其实这也是默认的表示方法。</p><p>加入子网掩码只是为了更灵活的配置子网，如果都按照默认的“规矩”进行划分就太死板了，难以适应复杂的需求环境，比如一个A类地址 <code>10.0.48.36</code> 默认的子网 <code>10.0.0.0</code>，可以容纳16777214台主机，这样如果一个子网的所需IP数量远远小于这个数字就会产生巨大的浪费。</p><p>再比如一个C类地址 <code>192.168.0.1</code> 的默认子网是 <code>192.168.0.0</code>，可以容纳254台主机，如果一个公司或者组织有500人，那么一个C类的子网就无法满足要求，需要分配B类地址才能解决问题，所以才有了子网掩码的出现，可以使子网的划分更加合理。</p><h2 id="掩码表示"><a href="#掩码表示" class="headerlink" title="掩码表示"></a>掩码表示</h2><p>掩码的表示比较简单，它由四个字节构成，表示成二进制形式时为前1后0，可以像IP地址一样的格式来书写，也可以写出掩码中有多少个1，举个例子，下面表示一个IP和子网：</p><ul><li><code>192.168.1.1</code> 和 <code>255.255.254.0</code></li></ul><p>也可以将掩码中1的个数写在IP地址后面表示成：</p><ul><li><code>192.168.1.1/23</code></li></ul><h2 id="子网拆分"><a href="#子网拆分" class="headerlink" title="子网拆分"></a>子网拆分</h2><p>增加子网掩码中1的个数可以将子网进行拆分，比如地址 <code>192.168.1.1</code> 和 <code>192.168.1.130</code> 在子网掩码是 <code>255.255.255.0</code>时都属于 <code>192.168.1.0</code> 这个子网，但是将子网掩码换成 <code>255.255.255.128</code>， 那么这两个IP地址就分别属于 <code>192.168.1.0</code> 和 <code>192.168.1.128</code> 这两个子网。</p><h2 id="子网合并"><a href="#子网合并" class="headerlink" title="子网合并"></a>子网合并</h2><p>减少子网掩码中1的个数可以将子网进行合并，比如地址 <code>192.168.1.1</code> 和 <code>192.168.0.1</code> 在子网掩码是 <code>255.255.255.0</code>时分别属于 <code>192.168.1.0</code> 和 <code>192.168.0.0</code> 这两个子网，但是将子网掩码换成 <code>255.255.254.0</code>， 那么这两个IP地址就都属于 <code>192.168.0.0</code> 这个子网了。</p><h1 id="网络包的传播"><a href="#网络包的传播" class="headerlink" title="网络包的传播"></a>网络包的传播</h1><p>网络包在子网内是以广播的形式传播，靠的是MAC地址，通过ARP协议可以获得，但是子网间的传播依赖IP地址，需通过路由或者三层交换机才能实现。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>通过IP地址和子网掩码进行按位与运算可以计算出IP地址所在的网络地址</li><li>通过子网掩码可以更合理的划分子网，对默认子网进行拆分与合并，一定程度上减少浪费和拥堵</li><li>子网内通信需要MAC地址，广播的形式来传递消息，这就是为什么网卡设置为混合模式可以截获到发给他人的消息</li><li>子网间通信需要借助IP地址才能实现，不过MAC地址也是需要的，通常被设置为网管的MAC地址</li><li>平时使用的 <code>ping</code> 命令，其实是 <code>ICMP</code> 协议的一部分，它是TCP/IP协议族的一个子协议，用于在IP主机、路由器之间传递控制消息</li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/113765130" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>勤劳的人总能挤出时间来坚持自己的习惯，懒惰的人总能找到借口来逃避应该做的事情，认定的目标就要大胆的开始，无论什么想法只要迈出了第一步就不算晚~</p><p>2021-2-14 23:57:52</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;前几天在配置数据库主从结构时查询了一些IP配置，后来编写远程执行脚本时又配置了一些IP数据，在&lt;code&gt;linux&lt;/code&gt;上使用 &lt;code&gt;ifconfig&lt;/code&gt; 命令查询IP配置时发现子网掩码不是常用的3个255，而是 &lt;code&gt;255.255.254.0&lt;/code&gt;，只是简单记得这样配置扩大了子网的范围，但是具体子网掩码怎么使用还是记不清楚了，所以查询了这些还给老师的知识，在此总结一下。&lt;/p&gt;
    
    </summary>
    
      <category term="Network" scheme="http://AlbertGithubHome.github.io/blog/categories/Network/"/>
    
    
      <category term="network" scheme="http://AlbertGithubHome.github.io/blog/tags/network/"/>
    
      <category term="ip" scheme="http://AlbertGithubHome.github.io/blog/tags/ip/"/>
    
      <category term="ping" scheme="http://AlbertGithubHome.github.io/blog/tags/ping/"/>
    
      <category term="子网掩码" scheme="http://AlbertGithubHome.github.io/blog/tags/%E5%AD%90%E7%BD%91%E6%8E%A9%E7%A0%81/"/>
    
      <category term="MAC" scheme="http://AlbertGithubHome.github.io/blog/tags/MAC/"/>
    
  </entry>
  
  <entry>
    <title>C/C++中string和int相互转换的常用方法</title>
    <link href="http://AlbertGithubHome.github.io/blog/2021/02/08/C-C-%E4%B8%ADstring%E5%92%8Cint%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/"/>
    <id>http://AlbertGithubHome.github.io/blog/2021/02/08/C-C-中string和int相互转换的常用方法/</id>
    <published>2021-02-08T15:41:12.000Z</published>
    <updated>2021-02-08T16:49:27.058Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>字符串操作是各种算法题中的常客，很多数据常常以字符串形式给出，其中有的需要自己转化成整数，而一些整型数据有时转换成字符串处理起来更加方便，比如判断一个整数是否是回文数，所以字符串和整数的转换是一些问题处理的基础步骤，<code>C++</code> 在处理这类问题时并不像 <code>Python</code> 那样方便，但是也有许多方法能够实现，为了今后查找方便，整理如下。</p><a id="more"></a><h1 id="int-转-string"><a href="#int-转-string" class="headerlink" title="int 转 string"></a>int 转 string</h1><h2 id="通过-std-to-string-函数转换"><a href="#通过-std-to-string-函数转换" class="headerlink" title="通过 std::to_string() 函数转换"></a>通过 std::to_string() 函数转换</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">123</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::to_string(num);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方式在 C++11 中才能使用，编译时记得加上 <code>--std=c++11</code> 的选项</p><h2 id="通过-ostringstream-转换"><a href="#通过-ostringstream-转换" class="headerlink" title="通过 ostringstream 转换"></a>通过 ostringstream 转换</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">123</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">ostringstream</span> ss;</span><br><span class="line">    ss &lt;&lt; num;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ss.str();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一种通过字符流的方式将整数转换成字符串，这种方式在C++11之前也可以使用</p><h2 id="通过-sprintf-转换"><a href="#通过-sprintf-转换" class="headerlink" title="通过 sprintf 转换"></a>通过 sprintf 转换</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">123</span>;</span><br><span class="line">    <span class="keyword">char</span> buffer[<span class="number">256</span>];</span><br><span class="line">    <span class="built_in">sprintf</span>(buffer, <span class="string">"%d"</span>, num);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s"</span>, buffer);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一种C语言中的转换方式，<code>sprintf</code> 也可以换成更安全的 <code>snprintf</code> 函数</p><h1 id="string-转-int"><a href="#string-转-int" class="headerlink" title="string 转 int"></a>string 转 int</h1><h2 id="通过-istringstream-转换"><a href="#通过-istringstream-转换" class="headerlink" title="通过 istringstream 转换"></a>通过 istringstream 转换</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> str = <span class="string">"668"</span>;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="function"><span class="built_in">istringstream</span> <span class="title">ss</span><span class="params">(str)</span></span>;</span><br><span class="line">    ss &gt;&gt; num;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; num;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 <code>istringstream</code> 可以从字符流中读取整数，与 <code>ostringstream</code> 是一种相反的操作</p><h2 id="使用-sscanf-来转化"><a href="#使用-sscanf-来转化" class="headerlink" title="使用 sscanf 来转化"></a>使用 sscanf 来转化</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> str = <span class="string">"668"</span>;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sscanf</span>(str.c_str(), <span class="string">"%d"</span>, &amp;num);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; num;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意 <code>sscanf</code> 函数的第一个参数类型是 <code>const char *</code>，<code>string</code>类型的参数需要转换一下</p><h2 id="使用-atoi-转换"><a href="#使用-atoi-转换" class="headerlink" title="使用 atoi 转换"></a>使用 atoi 转换</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> str = <span class="string">"668"</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; atoi(str.c_str());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>atoi</code> 函数的头文件是 <code>stdlib.h</code>，同样是一个C语言中的函数</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li><code>itoa</code> 不是c语言标准函数，在跨平台的整数转字符串的代码中不要使用这个函数</li><li><code>atoi</code> 是一个标准函数，需要将它和 <code>itoa</code> 区别开来，这一点很容易记混的</li><li>如果是在C++环境中进行转换，推荐使用 <code>stringstream</code> 字符流的形式和 <code>to_string</code> 函数</li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/113487945" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>这个世界真的很有趣，只要活着，就会有无限可能~</p><p>2021-2-9 00:44:34</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;字符串操作是各种算法题中的常客，很多数据常常以字符串形式给出，其中有的需要自己转化成整数，而一些整型数据有时转换成字符串处理起来更加方便，比如判断一个整数是否是回文数，所以字符串和整数的转换是一些问题处理的基础步骤，&lt;code&gt;C++&lt;/code&gt; 在处理这类问题时并不像 &lt;code&gt;Python&lt;/code&gt; 那样方便，但是也有许多方法能够实现，为了今后查找方便，整理如下。&lt;/p&gt;
    
    </summary>
    
      <category term="C/C++" scheme="http://AlbertGithubHome.github.io/blog/categories/C-C/"/>
    
    
      <category term="C/C++" scheme="http://AlbertGithubHome.github.io/blog/tags/C-C/"/>
    
      <category term="string" scheme="http://AlbertGithubHome.github.io/blog/tags/string/"/>
    
      <category term="int" scheme="http://AlbertGithubHome.github.io/blog/tags/int/"/>
    
      <category term="相互转化" scheme="http://AlbertGithubHome.github.io/blog/tags/%E7%9B%B8%E4%BA%92%E8%BD%AC%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>C++中一些方便的算法函数和吃不够的语法糖</title>
    <link href="http://AlbertGithubHome.github.io/blog/2021/01/30/C-%E4%B8%AD%E4%B8%80%E4%BA%9B%E6%96%B9%E4%BE%BF%E7%9A%84%E7%AE%97%E6%B3%95%E5%87%BD%E6%95%B0%E5%92%8C%E5%90%83%E4%B8%8D%E5%A4%9F%E7%9A%84%E8%AF%AD%E6%B3%95%E7%B3%96/"/>
    <id>http://AlbertGithubHome.github.io/blog/2021/01/30/C-中一些方便的算法函数和吃不够的语法糖/</id>
    <published>2021-01-30T08:09:01.000Z</published>
    <updated>2021-01-31T15:53:29.537Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>C++由于其复杂性，学习成本很高。但是作为接近底层的语言，学会之后能做的事情相当多，C++给了开发者极大的自由，只要符合规范就可以尽情的折腾，不过对于日常使用来说确实不太“方便”，特别是相比于Python、JS这类脚本语言，处理一些小问题时前奏太长，很多常用操作都需要自己造轮子，这一点在刷题时感觉很明显，C++一碰到字符串分析就“头大”，Python用一行搞定，用C++则需要N行。</p><a id="more"></a><h1 id="变化"><a href="#变化" class="headerlink" title="变化"></a>变化</h1><p>其实很多人对C++的认识还停留在 <code>C++98</code> 或者 <code>C++03</code> 版本，然而从 <code>C++11</code> 版本开始C++就发生了翻天覆地的变化，近期在使用的过程中发现C++也有很多方便的函数，越高的版本越方便，语法糖也越多，今天先总结几个，后续再补充吧。</p><h1 id="优秀函数和语法糖"><a href="#优秀函数和语法糖" class="headerlink" title="优秀函数和语法糖"></a>优秀函数和语法糖</h1><h2 id="使用find系列实现trim函数"><a href="#使用find系列实现trim函数" class="headerlink" title="使用find系列实现trim函数"></a>使用find系列实现trim函数</h2><p><code>trim</code>函数在很多语言中都是内置函数，可以去除收尾两端的空格，在C++中是没有trim函数的，需要自己实现一下，需要用到的工具函数有下面两个：</p><ul><li><code>find_first_not_of</code>：在字符串s中找到第一个不等于指定字符序列<code>ACDE..</code>的位置</li><li><code>find_last_not_of</code>：在字符串s中找到最后一个不等于指定字符序列<code>ACDE..</code>的位置</li></ul><p><code>find_first_not_of(&quot;hello world&quot;, &quot;he&quot;)</code> 指的就是找到第一个不等于 <code>h</code> 且不等于 <code>e</code> 字母的字符位置，要想去除字符串首尾空格就需要找到第一个不等于空格的位置，和最后一个不等于空格的位置，保留这两个位置中的部分即可，实现如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="function"><span class="built_in">string</span>&amp; <span class="title">trim</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> &amp;s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s.empty()) <span class="keyword">return</span> s;</span><br><span class="line"></span><br><span class="line">    s.erase(<span class="number">0</span>, s.find_first_not_of(<span class="string">" "</span>));</span><br><span class="line">    <span class="keyword">return</span> s.erase(s.find_last_not_of(<span class="string">" "</span>) + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="function"><span class="built_in">string</span>&amp; <span class="title">trim</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> &amp;s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s.empty()) <span class="keyword">return</span> s;</span><br><span class="line"></span><br><span class="line">    s.erase(<span class="number">0</span>, s.find_first_not_of(<span class="string">" "</span>));</span><br><span class="line">    <span class="keyword">return</span> s.erase(s.find_last_not_of(<span class="string">" "</span>) + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(<span class="string">" Hello world  "</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"before trim ==&gt;"</span> &lt;&lt; s &lt;&lt; <span class="string">"&lt;&lt;=="</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"after trim ==&gt;"</span> &lt;&lt; trim(s) &lt;&lt; <span class="string">"&lt;&lt;=="</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:/mnt/d/data/cpp/cplusplusadvance$ g++ stringtrim.cpp -o stringtrim</span><br><span class="line">albert@home-pc:/mnt/d/data/cpp/cplusplusadvance$ ./stringtrim</span><br><span class="line">before trim ==&gt; Hello world  &lt;&lt;==</span><br><span class="line">after trim ==&gt;Hello world&lt;&lt;==</span><br></pre></td></tr></table></figure><h2 id="使用regex实现split函数"><a href="#使用regex实现split函数" class="headerlink" title="使用regex实现split函数"></a>使用regex实现split函数</h2><p><code>split</code> 也是一个常用但C++不提供的函数，在C语言和早期的C++中一般通过 <code>strtok</code> 函数来实现，但是从 <code>C++11</code> 开始可以通过 <code>regex</code> 来实现，可以看下面这个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;regex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(<span class="string">"c++11 test split"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">regex <span class="title">reg</span><span class="params">(<span class="string">" "</span>)</span></span>; <span class="comment">// "\\s+" for blank</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; v(sregex_token_iterator(s.begin(), s.end(), reg, <span class="number">-1</span>), sregex_token_iterator());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> str : v)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"==&gt;"</span> &lt;&lt; str &lt;&lt; <span class="string">"&lt;&lt;=="</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结构如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:/mnt/d/data/cpp/cplusplusadvance$ g++ stringsplit.cpp -o stringsplit --std=c++17</span><br><span class="line">albert@home-pc:/mnt/d/data/cpp/cplusplusadvance$ ./stringsplit</span><br><span class="line">==&gt;c++11&lt;&lt;==</span><br><span class="line">==&gt;<span class="built_in">test</span>&lt;&lt;==</span><br><span class="line">==&gt;split&lt;&lt;==</span><br></pre></td></tr></table></figure><h2 id="使用auto遍历map结构"><a href="#使用auto遍历map结构" class="headerlink" title="使用auto遍历map结构"></a>使用auto遍历map结构</h2><p>很早以前C++中遍历map、set等复杂结构的时候需要写很长的代码来定义迭代器，自从出现了auto之后这种遍历简单了许多，最近发现针对map的遍历还有更简单的方法，使用方法如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; m&#123;&#123;<span class="string">"tom"</span>, <span class="number">20</span>&#125;, &#123;<span class="string">"albert"</span>, <span class="number">18</span>&#125;, &#123;<span class="string">"bella"</span>, <span class="number">19</span>&#125;, &#123;<span class="string">"bily"</span>, <span class="number">30</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; [name, age] : m) &#123;</span><br><span class="line">        <span class="keyword">if</span> (age &gt; <span class="number">18</span>)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; name &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:/mnt/d/data/cpp/cplusplusadvance$ g++ autonew.cpp -o autonew --std=c++17</span><br><span class="line">albert@home-pc:/mnt/d/data/cpp/cplusplusadvance$ ./stringsplit</span><br><span class="line">bella</span><br><span class="line">bily</span><br><span class="line">tom</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li><code>find_first_not_of</code>、<code>find_last_not_of</code>、<code>find_first_of</code> 这系列函数功能虽简单，但是使用它们可以简化代码逻辑</li><li>正则表达式是处理字符串查找的强有力的工具，合理的使用正则表达式可以达到事半功倍的效果，C++中请使用 <code>std::regex</code></li><li><code>C++17</code>中引入了结构化绑定声明，可以使用auto来声明多个变量，所有变量都必须用中括号括起来</li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/113065257" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>做自己认为对的事情，剩下的交给时间~</p><p>2021-1-31 23:04:17</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;C++由于其复杂性，学习成本很高。但是作为接近底层的语言，学会之后能做的事情相当多，C++给了开发者极大的自由，只要符合规范就可以尽情的折腾，不过对于日常使用来说确实不太“方便”，特别是相比于Python、JS这类脚本语言，处理一些小问题时前奏太长，很多常用操作都需要自己造轮子，这一点在刷题时感觉很明显，C++一碰到字符串分析就“头大”，Python用一行搞定，用C++则需要N行。&lt;/p&gt;
    
    </summary>
    
      <category term="C/C++" scheme="http://AlbertGithubHome.github.io/blog/categories/C-C/"/>
    
    
      <category term="C/C++" scheme="http://AlbertGithubHome.github.io/blog/tags/C-C/"/>
    
      <category term="auto" scheme="http://AlbertGithubHome.github.io/blog/tags/auto/"/>
    
      <category term="algorithm" scheme="http://AlbertGithubHome.github.io/blog/tags/algorithm/"/>
    
      <category term="语法糖" scheme="http://AlbertGithubHome.github.io/blog/tags/%E8%AF%AD%E6%B3%95%E7%B3%96/"/>
    
  </entry>
  
  <entry>
    <title>启用make多任务参数让构建过程加速完成</title>
    <link href="http://AlbertGithubHome.github.io/blog/2021/01/23/%E5%90%AF%E7%94%A8make%E5%A4%9A%E4%BB%BB%E5%8A%A1%E5%8F%82%E6%95%B0%E8%AE%A9%E6%9E%84%E5%BB%BA%E8%BF%87%E7%A8%8B%E5%8A%A0%E9%80%9F%E5%AE%8C%E6%88%90/"/>
    <id>http://AlbertGithubHome.github.io/blog/2021/01/23/启用make多任务参数让构建过程加速完成/</id>
    <published>2021-01-23T06:23:05.000Z</published>
    <updated>2021-01-27T16:33:30.730Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>是不是有时候觉得使用make命令编译时太慢了，特别是紧急修改BUG的时候，恨不得钻进电脑里帮着编译器一起干活，其实make命令是可以加速的，使用 <code>-j</code> 选项即可指定make启动的任务数，它是 <code>--jobs[=jobs]</code> 的缩写形式，比如 <code>make -j4</code> 就表示同时启动4个任务并行构建，虽然达不到4倍的关系，但是要比原来快多了。</p><a id="more"></a><h1 id="寻找"><a href="#寻找" class="headerlink" title="寻找"></a>寻找</h1><p>寻找这样一个参数的原因还是觉得有时编译太慢了，特别是修改一个公共的头文件时，几乎要从头编译到尾，启用 <code>-j</code> 参数的过程异常顺利，没有任何报错，迅速的就构建完成，这让我想起了之前一个项目中遇到过的问题。</p><p>同样是编译过程比较慢，但是老大哥告诉我启用多线程编译会报错，作为新手小白的我就默默记住了，也没有过多的探究，毕竟编译的次数不是那么多，偶尔长时间编译一次也没有什么关系，但是现在突然想知道当时为什么使用多线程编译会报错呢？</p><h1 id="可能的原因"><a href="#可能的原因" class="headerlink" title="可能的原因"></a>可能的原因</h1><p>当知识渐渐丰富以后，面对这样的问题还是有些头绪的，启用 <code>make -jn</code>时被称为多任务并行构建，也有的文章会写多线程编译或者多进程编译，从表现来看至少是多进程的，因为在任务列表可以看到不同的进程id，不过这里的名字不是重点，重点是有多个任务在同时干活。</p><p>当启用多任务构建时原来的串行构建逻辑就变成了并行，那么此时构建失败多是由依赖关系指定不正确导致，这种依赖关系通常有两种：</p><ul><li>B模块编译需要用到A模块的函数</li><li>B模块构建过程中需要的临时数据由A模块构建时产生，两种共用临时数据，但是有序</li></ul><p>总结来说就是逻辑上需要A构建完了，才能开始构建B，如果此时先构建B任务就会导致出错，这就能解释为什么使用 <code>make</code> 可以成功，但是使用 <code>make -j4</code> 就构建失败，也能解释为什么失败之后，多次执行这个命令可能还会成功，因为多次执行以后可能会把A模块先构建完，这样后面再构建B就不会出错了。</p><h1 id="加速"><a href="#加速" class="headerlink" title="加速"></a>加速</h1><p>从上面的分析可以得知，模块间的依赖关系决定了多任务构建时应有的顺序，那么是不是所有的构建任务都可以通过 <code>-j</code> 来加速呢？答案当然是否定的，如果要构建项目的所有模块的依赖关系完全是线性的，那么就没有办法并行完成，比如下面这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">graph TB</span><br><span class="line">    A--&gt;B;</span><br><span class="line">    B--&gt;C;</span><br><span class="line">    C--&gt;D;</span><br><span class="line">    D--&gt;E;</span><br><span class="line">    E--&gt;F;</span><br></pre></td></tr></table></figure><p>但是整个任务如果可以进行拆分，整个依赖图中出现分叉，那么就可以通过这种方式来加速，比如像这样的依赖关系：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">graph TB</span><br><span class="line">    A--&gt;B;</span><br><span class="line">    A--&gt;C;</span><br><span class="line">    B--&gt;D;</span><br><span class="line">    B--&gt;E;</span><br><span class="line">    C--&gt;F;</span><br></pre></td></tr></table></figure><p>上面所表示的关系中，虽然 B 和 C 都需要依赖A完成，但是当 A 完成后，B 和 C 的构建就可以并行开始，这样就可以达到加速构建的目的。</p><h1 id="视网膜效应"><a href="#视网膜效应" class="headerlink" title="视网膜效应"></a>视网膜效应</h1><p>之前也没有注意到 <code>make</code> 命令这个 <code>-j</code> 的选项，自从在项目中使用了一次，我发现在很多项目说明中都看到了这个参数，比如安装 <code>global</code> 的时候，编译 <code>tendis</code> 的时候等等，之前也有这样的情况，就是当你刚接触一个事物，或者进入一个新领域的时候，发现其实周围很多人都在讨论这些事物，自己以前都没注意到，上网查了一下，原来这叫做视网膜效应。</p><p>视网膜效应这个学术名词用白话文来讲就是“心眼”，每一个人的眼睛，都是跟着心走！简单地说，这种效应的意思就是一个人的身心状况会影响他的视线，当他自己拥有一件东西或一项特征时，他就会比平常人更会注意到别人是否跟他一样具备这种特征，即越关注什么就越出现什么。</p><p>视网膜效应是一种狭隘视野与思维的反映，它会导致看问题不全面，甚至会出现牛走羊肠道、鼠钻牛角尖的极端现象。其实每个人的特质中，都有很多优点和缺点。当一个人只知道自己的缺点是什么，而不知发掘优点时，视网膜效应就会促使这个人发现他身边也有许多人拥有类似的缺点，进而使他的人际关系无法改善，生活也不会快乐。</p><h1 id="随便聊聊"><a href="#随便聊聊" class="headerlink" title="随便聊聊"></a>随便聊聊</h1><h2 id="make"><a href="#make" class="headerlink" title="make"></a>make</h2><p>从刚接触这个命令的时候就认为它是编译的意思，其实这是一种先入为主的思想，因为之前在linux安装软件时常需要下面这三步：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./configure</span><br><span class="line">./make</span><br><span class="line">./make install</span><br></pre></td></tr></table></figure><p>从源码安装软件就需要进行编译，所以一直认为这三步是配置、编译、安装的意思，其实 <code>make</code> 本身并不会编译，它只是编译命令的搬运工。</p><p>它的真实含义应该是构建，这个构建可不一定是编译，可以是任何逻辑化的事物，只不过常常用 <code>make</code> 来完成编译任务，所以把它和编译绑定到了一起，构建时需要图纸的，这个图纸就是 <code>Makefile</code> 文件，只要我们画好了Makefile图纸，那么 <code>make</code> 命令就可以根据它来完成任务。</p><p>所以当你运行 <code>make</code> 命令时，仿佛在说: “Here’s your drawing, go go go！”，又仿佛在说：“图纸搁这儿呢，可劲儿造吧”，以这个观点来看 <code>make</code> 的一系列命令就有意思了：</p><ul><li><code>make</code>：图纸搁这儿呢，可劲儿造吧</li><li><code>make clean</code>：把你弄得这堆破烂儿，拾掇拾掇</li><li><code>make install</code>：把你鼓捣出的那玩意，搬到旮旯去</li><li><code>make dist</code>：赶紧把那玩意打包拉走</li></ul><h2 id="cmake"><a href="#cmake" class="headerlink" title="cmake"></a>cmake</h2><p>既然 <code>make</code> 是编译命令的搬运工，那么 <code>cmake</code> 又是什么意思呢？大胆猜测他就是 <code>config make</code> 的意思，它的作用是生成 Makefile 文件，换句话来说就是给 <code>make</code> 造图纸的。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>使用 <code>make -j4</code> 命令可以开启4个任务并行构建，大大加快构建速度</li><li><code>make</code> 本身并不能进行编译，它只是各种编译命令的搬运工，需要Makefile图纸才能进行工作</li><li><code>cmake</code> 的作用是生成 <code>make</code> 所需的图纸，有了它可以更快更方便的生成一些规范的Makefile文件</li><li>视网膜效应指的是越关注什么就越出现什么的效应，是一种狭隘视野与思维的反映，会导致看问题不全面</li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/112727308" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>未经他人苦，莫劝他人善，世上总有一些你无法理解，但却真实存在的生活~</p><p>2021-1-23 17:24:15</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;是不是有时候觉得使用make命令编译时太慢了，特别是紧急修改BUG的时候，恨不得钻进电脑里帮着编译器一起干活，其实make命令是可以加速的，使用 &lt;code&gt;-j&lt;/code&gt; 选项即可指定make启动的任务数，它是 &lt;code&gt;--jobs[=jobs]&lt;/code&gt; 的缩写形式，比如 &lt;code&gt;make -j4&lt;/code&gt; 就表示同时启动4个任务并行构建，虽然达不到4倍的关系，但是要比原来快多了。&lt;/p&gt;
    
    </summary>
    
      <category term="linux" scheme="http://AlbertGithubHome.github.io/blog/categories/linux/"/>
    
    
      <category term="C++" scheme="http://AlbertGithubHome.github.io/blog/tags/C/"/>
    
      <category term="编译" scheme="http://AlbertGithubHome.github.io/blog/tags/%E7%BC%96%E8%AF%91/"/>
    
      <category term="linux" scheme="http://AlbertGithubHome.github.io/blog/tags/linux/"/>
    
      <category term="make" scheme="http://AlbertGithubHome.github.io/blog/tags/make/"/>
    
  </entry>
  
  <entry>
    <title>记一次解决Intel 9462无线网卡的笔记本安装Ubuntu16.04后无法连接WIFI问题的艰难历程</title>
    <link href="http://AlbertGithubHome.github.io/blog/2021/01/16/%E8%AE%B0%E4%B8%80%E6%AC%A1%E8%A7%A3%E5%86%B3Intel-9462%E6%97%A0%E7%BA%BF%E7%BD%91%E5%8D%A1%E7%9A%84%E7%AC%94%E8%AE%B0%E6%9C%AC%E5%AE%89%E8%A3%85Ubuntu16-04%E5%90%8E%E6%97%A0%E6%B3%95%E8%BF%9E%E6%8E%A5WIFI%E9%97%AE%E9%A2%98%E7%9A%84%E8%89%B0%E9%9A%BE%E5%8E%86%E7%A8%8B/"/>
    <id>http://AlbertGithubHome.github.io/blog/2021/01/16/记一次解决Intel-9462无线网卡的笔记本安装Ubuntu16-04后无法连接WIFI问题的艰难历程/</id>
    <published>2021-01-16T14:43:32.000Z</published>
    <updated>2021-01-23T11:21:46.708Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>一台新申请的ThinkPad-X390笔记本需要安装Ubuntu系统，为了统一工作开发环境，选择了大家一直都在使用Ubuntu16.04版本，虽然这个系统版本旧一点，不过同一个版本出现开发环境问题也好排查，但没想到的是这里埋下了一个坑，导致成功安装系统后却不能上网，足足折腾了一整天才搞定，记录一下，没事回来看看还能乐呵乐呵。</p><a id="more"></a><h1 id="安装环境"><a href="#安装环境" class="headerlink" title="安装环境"></a>安装环境</h1><ul><li>ThinkPad-X390 笔记本</li><li>Intel® Wireless-AC 9462 无线网卡</li><li>Ubuntu 16.04.7 系统</li></ul><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p>根本原因：Ubuntu 16.04内核版本太低，无法自动识别网卡，需要手动升级内核，安装无线网卡驱动。如果你遇到的情况也是新版本无线网卡，安装老版本系统时无法连接WIFI，请参考这个无私博主的解决方法，有这一篇足够了</p><p><a href="https://blog.csdn.net/dieju8330/article/details/101422743" target="_blank" rel="noopener">联想 Yoga C740：：关于Ubuntu16.04下无法识别Intel WIFI6 AX201无线网卡的解决方案，https://blog.csdn.net/dieju8330/article/details/101422743</a></p><h1 id="安装过程"><a href="#安装过程" class="headerlink" title="安装过程"></a>安装过程</h1><p>下面开始碎碎念内容，虽然现在看来只要是上面那一个链接就可以解决问题，但是这却是浏览了几百个网页后，不断尝试才证明它是有效的，所以我也简单记录一下这个过程，以下的内容可能对你解决问题可能没什么帮助了，不过你要是喜欢听故事倒是可以继续瞧瞧。</p><h2 id="初始环境"><a href="#初始环境" class="headerlink" title="初始环境"></a>初始环境</h2><p>一台预装了Win10系统的笔记本，连接WIFI可以正常上网，一开始是打算装双系统的，但是台式机是Win10，笔记本再保留一个Win10有些浪费空间，准备只安装一个Ubuntu算了。</p><p>又要装Ubuntu了，我在CSDN的第一篇文章的就是有关Ubuntu的，<a href="https://blog.csdn.net/albertsh/article/details/12302473" target="_blank" rel="noopener">《ubuntu 12.04系统黑屏，登录界面黑屏，命令行界面可用》</a>，当时靠着几个命令把问题解决了，这次解决问题同样需要几个命令，但是这个过程就复杂多了。</p><h2 id="安装Ubuntu16-04-2"><a href="#安装Ubuntu16-04-2" class="headerlink" title="安装Ubuntu16.04.2"></a>安装Ubuntu16.04.2</h2><p>本地找到了之前在虚拟机中安装使用过的 ubuntu-16.04.2-desktop-amd64.iso 镜像，使用UltraISO刻录U盘发现一直占用，遂改用rufus来刻录，发现这个软件操作也很方便，顺利完成启动盘制作，安装过程也比较顺利，网上很多大佬的教程都可以拿来参考，比如下面这几篇：</p><ul><li><a href="https://www.jb51.net/article/173277.htm" target="_blank" rel="noopener">《Win10 + Ubuntu 16.04双系统完美安装教程【详细】》</a></li><li><a href="https://www.cnblogs.com/masbay/p/10844857.html" target="_blank" rel="noopener">《Windows10安装ubuntu16.04双系统教程》</a></li><li><a href="https://blog.csdn.net/jeryjeryjery/article/details/80011447" target="_blank" rel="noopener">《卸载win10装Ubuntu笔记》</a></li></ul><p>注意，前两篇是装双系统的，和我们的只安装一个Ubuntu16.04的目标不太一致，但是绝大部分步骤都是一致的，网络上的知识就是这样，要想完全一样太难了，需要学会变通。</p><p>比较懒我就不截图了，去大佬文章里看吧，说一说其中的几个关键点：</p><ul><li>安装Ubuntu需要关闭BOIS中的Secure Boot 选项</li><li>注意一下安装双系统和单个系统时进行分区操作的差异，选对主分区和逻辑分区</li><li>烧制U盘和安装系统时涉及到分区表GPT和MBR的选择，烧制U盘与硬件分区模式一致就好，在windows通过命令或者“管理”都很容易查到</li><li>启动方式有Legacy和UEFI区别，记住UEFI是新的，能用它就用它，不行就换成Legacy，大不了重新装一次，当然你根据硬件情况能准确判断最好</li><li>安装过程中有一步是勾选“为图形或无线硬件…安装第三方软件”，看到很多教程都没勾选，我也没选（伏笔1），感觉我已经入坑了</li></ul><p>非常自信的干掉了Win10系统（伏笔2），干干净净的只安装了Ubuntu，安装很快完成，顺利进入系统，期间跳出来几行错误，我都没看清就闪过去了，应该是不重要，进去后准备部署开发环境，发现没有WIFI列表，这就奇怪了，网卡肯定没问题，之前Win10是可以上网的，肯定是设置的不对，上网查查为什么吧。</p><h2 id="硬件禁止问题"><a href="#硬件禁止问题" class="headerlink" title="硬件禁止问题"></a>硬件禁止问题</h2><p>这是我看到的第一个解决方案，需要改 <code>/etc/Network/NetworkManage.conf</code> 文件中的 <code>manage=false</code> 改成 <code>manage=true</code>, 参考下面这帖子</p><p><a href="https://blog.csdn.net/ye1391/article/details/83180774" target="_blank" rel="noopener">解决Ubuntu下的WiFi列表不显示问题（硬件禁止问题）</a></p><p>现在回过头来想想我根本就不是这个问题，很多特点都对不上，完全是病急乱投医的处理方式，使用 <code>rfkill list</code> 命令根本找不到我的网卡，这一点也是后来才发现的</p><h2 id="激活无线网卡"><a href="#激活无线网卡" class="headerlink" title="激活无线网卡"></a>激活无线网卡</h2><p>很多文章开局就是下面这两个命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install --reinstall bcmwl-kernel-source</span><br></pre></td></tr></table></figure><p>要知道使用 <code>sudo apt-get update</code> 是需要联网的，现在我连不上无线，不存在有线，所以上不去网，然后翻了N个页面之后找到了大神离线安装的方法，其实这个安装文件在镜像里就有，所以打开刚刚烧制的U盘就行了，但是直接安装会有依赖问题，解决这个问题就是一个个在镜像中找到，然后安装上。</p><ul><li><a href="https://blog.csdn.net/ifmvo/article/details/54023628" target="_blank" rel="noopener">《Ubuntu离线安装网卡驱动》</a></li><li><a href="https://www.jianshu.com/p/8b29954ab590" target="_blank" rel="noopener">《【菜鸟向】Ubuntu无法连接wifi问题的解决》</a></li></ul><p>一步步操作之后完全没有作用，现在来看如果能起作用还怪了，这是bcm博通网卡的处理方法，而我的网卡是Intel的，又是做了无用功</p><h2 id="更新软件列表附加驱动"><a href="#更新软件列表附加驱动" class="headerlink" title="更新软件列表附加驱动"></a>更新软件列表附加驱动</h2><p>这种解决方案网上流传的最多，其实就是依靠Ubuntu的软件仓库来解决</p><ul><li><a href="https://blog.csdn.net/weixin_41762173/article/details/79480609" target="_blank" rel="noopener">Ubuntu16.04无法连接Wifi解决方案 （绝对有效）</a></li><li><a href="https://www.cnblogs.com/oxspirt/p/10802163.html" target="_blank" rel="noopener">ubuntu16.04中不能连接无线网络</a></li></ul><p>解决这个问题的关键就是先联网，仿佛陷入了死循环，我现在就是要解决无线网卡连不上网的问题，你却让我先联网更新，其实对于可以连接有线网络的电脑来说没什么问题，但是我这里连不上有线网啊！</p><p>然后我就学到了一个逆天的操作，原来USB可以供网，可以通过USB线让笔记本使用手机的4G网络，瞬间打开了一扇大门，说干就干，先更新一下 Ubuntu 的软件源，可以参考下面这个文章，其实有很多源的，比如常用的清华源、阿里源等等，但是要注意版本，网上流传着一些错误版本的地址，需要自己甄别一下。</p><ul><li><a href="https://blog.csdn.net/Liangontheway/article/details/103509635" target="_blank" rel="noopener">Ubuntu16.04更换国内源</a></li></ul><p>这个软件源其实类似于应用商店的地址，换了软件源就相当于换了一个应用商店，还完源更新之后就可以从软件仓库中有哪些软件，下次再安装软件时就可以找到了，在这列举一个常用的Ubuntu16.04的软件源，替换 <code>/etc/apt/source.list</code> 文件内容就好了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial main</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ xenial main</span><br><span class="line"></span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial-updates main</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ xenial-updates main</span><br><span class="line"></span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial universe</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ xenial universe</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial-updates universe</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ xenial-updates universe</span><br><span class="line"></span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial-security main</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ xenial-security main</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial-security universe</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ xenial-security universe</span><br></pre></td></tr></table></figure><p>准备就绪，USB连接手机，然后共享网络，执行 <code>sudo apt-get update</code> 命令，照着教程操作一通，发现并没有在附加驱动选项卡中发现可用的驱动，失败了，同时耗费了1G流量导致手机网络报警。</p><p>还是回过头来看看，很多人说这种方式解决了问题，但我没有成功，看看成功的那些截图还是博通的网卡，而我这个Intel的网卡有点难搞啊</p><h2 id="更新内核1"><a href="#更新内核1" class="headerlink" title="更新内核1"></a>更新内核1</h2><p>从现在开始渐渐步入正确轨道了，因为我发现的网上各种设置网卡参数的命令在我这没有任何反应，比如执行 <code>rfkill list</code> 结果显示根本没有网卡，只有两个蓝牙，执行 <code>lshw -c network</code> 之后发现 <code>*-network UNCLAIMED</code> 内容，开始搜索相关内容，然后发现了下面的帖子：</p><ul><li><a href="https://askubuntu.com/questions/1052311/network-unclaimed-on-ubuntu" target="_blank" rel="noopener">Network unclaimed on Ubuntu</a></li></ul><p>提问者根据回答人提供的步骤一步步解决了自己的问题，而我在安装这个内核版本时提示已经最新无法继续安装，并且在回答中提到安装 <code>16.04.4</code> 版本的镜像不需要做任何设置就可以使用无线网了，想到自己安装的是 16.04.2，就怀疑是这里的问题，准备安装高版本镜像</p><h2 id="安装Ubuntu16-04-7"><a href="#安装Ubuntu16-04-7" class="headerlink" title="安装Ubuntu16.04.7"></a>安装Ubuntu16.04.7</h2><p>由于Ubuntu官网下载比较慢，所以找了国内的镜像网站下载了 16.04.7版本，刻录U盘启动盘，准备安装</p><ul><li><a href="http://mirrors.ustc.edu.cn/ubuntu-releases/" target="_blank" rel="noopener">中科大ubuntu镜像站</a></li><li><a href="https://blog.csdn.net/Miklechun/article/details/89742372" target="_blank" rel="noopener">几个ubuntu16.04镜像下载地址</a></li></ul><p>这次安装的熟练了一些，完成后进入系统并未有什么改变，依旧连不上网，尝试更新软件试试，于是再一次连接手机USB网络，执行下面命令</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get upgrade</span><br></pre></td></tr></table></figure><p>又是几百兆流量进去了，依然没有效果</p><h2 id="查找网卡版本"><a href="#查找网卡版本" class="headerlink" title="查找网卡版本"></a>查找网卡版本</h2><p>至此虽然已经连不上网，但是基本确定了问题的原因，不是网卡设置的问题，而是驱动版本不对，系统无法识别网卡型号，没有办法正常工作。</p><p>可是怎么才能知道网卡的型号呢？如果正常驱动的无线网卡可以使用 <code>lspci | grep Net</code> 这个命令，但是我这里不行，只显示Intel设备，无法显示设备类型和具体型号，倘若我的win10还在，直接在设备管理器中查就可以了，但是他已经被我自信的格式化了，此处捶胸顿足。</p><p>那怎么办呢？问问旁边的小伙伴？关键电脑型号不一样啊！撬开电脑后盖？估计无线网卡在哪我都找不到。对了，去联想官网看看配置，应该能找到的吧！</p><p>说干就干，打开联想官网居然找不到这个具体的型号，只能找到 ThinkPad-X390 系列，而我这个子系列是20SD，官网上有20SC、20SX、20Q0等等，就是没有20SD，没办法了，看看这个相似的这几个无线网卡都是什么型号吧，发现大多数都是 <code>Intel® 9560AC</code>，部分提到了 <code>Intel® Wi-Fi 6 AX200</code>，这两个网卡差的可是有点多，需求的Ubuntu内核版本差了一个大版本，他们的对应关系可以参考Intel提供的这个文档</p><p><a href="https://www.intel.com/content/www/us/en/support/articles/000005511/network-and-io/wireless.html" target="_blank" rel="noopener">Linux* Support for Intel® Wireless Adapters</a></p><p>联想的官网只提供Windows上的驱动下载，Linux版本只能自己去Intel上找了，现在需要确定网卡版本来下载相应的驱动，但是目前查不到这个网卡的具体型号，还能怎么办呢？去找联想客服吧！</p><p>在联想的官网上找到了联想的售前，说明问题后给出的答案是大概率是 <code>Intel® 9560AC</code> 型号，然后转接技术处理，等待N久之后查了SN码说应该是 <code>Intel® 9560AC</code>，但是我认为应该是网卡型号应该是 <code>Intel® Wi-Fi 6 AX200</code>，如果是 <code>Intel® 9560AC</code> 型号的网卡，需要 Ubuntu<br>的内核是 <code>4.14+</code>，而我安装的内核版本是 <code>4.15.7</code>，系统没理由不认识这个网卡。</p><p>想想还有什么办法查网卡型号呢？既然windows上可以看，那我省点事安装个WinPE进系统看一下。下载常用的微PE工具箱，烧制U盘后进了系统，点开设备管理器，一大串设备都带着问号，原来在WinPE里也没有这些设备的驱动，我又跑去联想官网下载了Windows上的网卡驱动，放到WinPE上安装，结果因缺少DLL而失败，这条路也行不通了。</p><p>只能重新做个win10的系统看看了，再次对删除win10前没看网卡型号而捶胸顿足，下载了5个多G的镜像文件，刻录Win10启动盘，然后安装发现引导不进去，也是醉了，应该是文件系统格式不正确，导致系统无法引导，算了，死马当活马医吧，我直接把无线网卡当成最高的版本，按照<code>Intel® Wi-Fi 6 AX200</code>进行处理，把内核升级了应该就可以了</p><h2 id="更新内核2"><a href="#更新内核2" class="headerlink" title="更新内核2"></a>更新内核2</h2><p>WinPE方式失败后决定升级内核，于是按照文章开头提供的那篇<a href="https://blog.csdn.net/dieju8330/article/details/101422743" target="_blank" rel="noopener">解决方案</a>来处理，但是内核文件安装失败了，无法升级，内心崩溃……</p><p><a href="https://blog.csdn.net/CGJustDoIT/article/details/103363622" target="_blank" rel="noopener">Ubuntu应用—安装 Intel Wireless-AC 9462 无线网卡驱动（无法连接wifi，完美解决）</a></p><p>这一篇也是类似的，同样无法成功更新。</p><h2 id="安装Ubuntu20-04-1"><a href="#安装Ubuntu20-04-1" class="headerlink" title="安装Ubuntu20.04.1"></a>安装Ubuntu20.04.1</h2><p>既然升级内核失败了，我干脆安装个自带高内核版本的系统算了，下载了 Ubuntu20.04.1 的镜像</p><p><a href="https://mirrors.tuna.tsinghua.edu.cn/ubuntu-releases/" target="_blank" rel="noopener">清华大学开源软件镜像站</a></p><p>经过漫长的等待下载完成，刻录Ubuntu启动盘，安装设置一气呵成，搞定了，无线网的小雨伞出现了，简直泪流满面…</p><p>然后通过 <code>lspci | grep Net</code> 来查看网卡型号，结果出现了 <code>Intel Corporation Wireless-AC 9462</code>，看到这里我都惊呆了，原来这个网卡比 <code>Intel® 9560AC</code> 版本还要低，联想客服的回答是错误的，Intel官方驱动的对应关系也不准确，真是没什么可信的了。</p><h2 id="安装Ubuntu18-04-5"><a href="#安装Ubuntu18-04-5" class="headerlink" title="安装Ubuntu18.04.5"></a>安装Ubuntu18.04.5</h2><p>既然无线网卡都可以识别了，为什么还要折腾呢？因为Ubuntu20.04.1这个版本跟周围小伙伴使用的系统版本差的有点多，并且之前出现过项目编译问题，所以换个低一点的版本试试。</p><p>下载镜像，刻录U盘，安装系统轻车熟路，真是越来越顺利了，安装完成后WIFI正常，果然是内核版本的事情，高版本的系统直接就可以使用，根本不需要任何设置。</p><h2 id="再次安装Ubuntu16-04-7"><a href="#再次安装Ubuntu16-04-7" class="headerlink" title="再次安装Ubuntu16.04.7"></a>再次安装Ubuntu16.04.7</h2><p>因为不服输，我又折腾回来了，既然是内核版本的问题，我就再试试在这个低版本系统上升级内核，这次安装时勾选了“为图形或无线硬件…安装第三方软件”，因为我突然意识到其他教程不让勾选都是台式机，而我是笔记本，我的个乖乖啊，感觉被坑了。</p><p>这次一步步操作，安装完系统就不再做任何设置，直接升级内核，访问<a href="https://kernel.ubuntu.com/~kernel-ppa/mainline/v5.2.16/" target="_blank" rel="noopener">内核软件网站</a>，下载下面4个包：</p><ul><li><a href="https://kernel.ubuntu.com/~kernel-ppa/mainline/v5.2.16/linux-headers-5.2.16-050216_5.2.16-050216.201909190832_all.deb" target="_blank" rel="noopener">linux-headers-5.2.16-050216_5.2.16-050216.201909190832_all.deb</a></li><li><a href="https://kernel.ubuntu.com/~kernel-ppa/mainline/v5.2.16/linux-headers-5.2.16-050216-generic_5.2.16-050216.201909190832_amd64.deb" target="_blank" rel="noopener">linux-headers-5.2.16-050216-generic_5.2.16-050216.201909190832_amd64.deb</a></li><li><a href="https://kernel.ubuntu.com/~kernel-ppa/mainline/v5.2.16/linux-image-unsigned-5.2.16-050216-generic_5.2.16-050216.201909190832_amd64.deb" target="_blank" rel="noopener">linux-image-unsigned-5.2.16-050216-generic_5.2.16-050216.201909190832_amd64.deb</a></li><li><a href="https://kernel.ubuntu.com/~kernel-ppa/mainline/v5.2.16/linux-modules-5.2.16-050216-generic_5.2.16-050216.201909190832_amd64.deb" target="_blank" rel="noopener">linux-modules-5.2.16-050216-generic_5.2.16-050216.201909190832_amd64.deb</a></li></ul><p>依次按照下面的命令安装，这次居然成功了</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo sudo dpkg -i linux-headers-5.2.16-050216_5.2.16-050216.201909190832_all.deb</span><br><span class="line">sudo sudo dpkg -i linux-headers-5.2.16-050216-generic_5.2.16-050216.201909190832_amd64.deb</span><br><span class="line">sudo sudo dpkg -i linux-modules-5.2.16-050216-generic_5.2.16-050216.201909190832_amd64.deb</span><br><span class="line">sudo sudo dpkg -i linux-image-unsigned-5.2.16-050216-generic_5.2.16-050216.201909190832_amd64.deb</span><br></pre></td></tr></table></figure><p>然后从<a href="http://ftp.sjtu.edu.cn/ubuntu/pool/main/l/linux-firmware/" target="_blank" rel="noopener">网站</a>下载linux固件版本</p><p><a href="http://ftp.sjtu.edu.cn/ubuntu/pool/main/l/linux-firmware/linux-firmware_1.190_all.deb" target="_blank" rel="noopener">linux-firmware_1.190_all.deb</a></p><p>使用如下命令安装成功</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo sudo dpkg -i linux-firmware_1.190_all.deb</span><br></pre></td></tr></table></figure><p>reboot重启系统，WIFI的小雨伞终于出现了，功夫不负有心人，彻底搞定了，至于WIFI可用却连不上公司的无线网，那就是另一个悲伤的故事了，和技术无关，就不在此展开了。</p><h2 id="踩过的其他坑"><a href="#踩过的其他坑" class="headerlink" title="踩过的其他坑"></a>踩过的其他坑</h2><p>其实整个过程远不止上面提到的这些，安装了10几次系统，至少翻了几百个页面，有一些处理方式尝试过但没有什么效果，也列举在这里，留个纪念</p><ul><li><a href="https://blog.csdn.net/qq_45252077/article/details/106541604" target="_blank" rel="noopener">Ubuntu16.04无附加驱动无法连接WiFi总结</a></li><li><a href="https://blog.csdn.net/vesper305/article/details/9324567" target="_blank" rel="noopener">Ubuntu-server 10.04.4查看无线网卡型号</a></li><li><a href="https://blog.csdn.net/weixin_42101286/article/details/89239105" target="_blank" rel="noopener">Ubuntu安装后未发现wifi适配器解决</a></li><li><a href="https://blog.csdn.net/weixin_40955254/article/details/87992051" target="_blank" rel="noopener">ubuntu16.04+intel无线网卡无法连接WiFi解决方法，下载驱动，升级内核（亲测有效）</a></li><li><a href="https://www.cnblogs.com/superxuezhazha/p/11989882.html" target="_blank" rel="noopener">ubuntu18.04 无法连接有线</a></li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>现在安装Ubuntu特别溜，刻录U盘启动盘+安装完系统也就10分钟</li><li>手机通过USB连接笔记本可以直接给笔记本提供网络，这波操作有点优秀</li><li>认识了一堆之前没用过的命令，特别是 <code>lspci</code> 显示设备信息和 <code>iwconfig</code> 管理无线网络</li><li>出现问题时还是要找到根本原因，不能病急乱投医，一些博通网卡的处理方式用到Intel上显然不合适</li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/112419216" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>当个人实力撑不起自己的野心时，需埋下头来刻苦修炼，当目前的能力无法满足自己的欲望时，需抑制一些不切实际的想法，但愿多年之后回想这些隐忍的瞬间能内心充满感恩而不是悔恨~</p><p>2021-1-16 22:48:02</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;一台新申请的ThinkPad-X390笔记本需要安装Ubuntu系统，为了统一工作开发环境，选择了大家一直都在使用Ubuntu16.04版本，虽然这个系统版本旧一点，不过同一个版本出现开发环境问题也好排查，但没想到的是这里埋下了一个坑，导致成功安装系统后却不能上网，足足折腾了一整天才搞定，记录一下，没事回来看看还能乐呵乐呵。&lt;/p&gt;
    
    </summary>
    
      <category term="linux" scheme="http://AlbertGithubHome.github.io/blog/categories/linux/"/>
    
    
      <category term="linux" scheme="http://AlbertGithubHome.github.io/blog/tags/linux/"/>
    
      <category term="ubuntu" scheme="http://AlbertGithubHome.github.io/blog/tags/ubuntu/"/>
    
      <category term="系统" scheme="http://AlbertGithubHome.github.io/blog/tags/%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="WIFI" scheme="http://AlbertGithubHome.github.io/blog/tags/WIFI/"/>
    
  </entry>
  
  <entry>
    <title>搬迁声明</title>
    <link href="http://AlbertGithubHome.github.io/blog/2021/01/12/%E6%90%AC%E8%BF%81%E5%A3%B0%E6%98%8E/"/>
    <id>http://AlbertGithubHome.github.io/blog/2021/01/12/搬迁声明/</id>
    <published>2021-01-12T14:52:21.000Z</published>
    <updated>2021-01-12T14:54:27.541Z</updated>
    
    <content type="html"><![CDATA[<p>我的博客即将同步至 OSCHINA 社区，这是我的 OSCHINA ID：osc_57262839，邀请大家一同入驻：<a href="https://www.oschina.net/sharing-plan/apply" target="_blank" rel="noopener">https://www.oschina.net/sharing-plan/apply</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我的博客即将同步至 OSCHINA 社区，这是我的 OSCHINA ID：osc_57262839，邀请大家一同入驻：&lt;a href=&quot;https://www.oschina.net/sharing-plan/apply&quot; target=&quot;_blank&quot; rel=&quot;noop
      
    
    </summary>
    
      <category term="Thinking" scheme="http://AlbertGithubHome.github.io/blog/categories/Thinking/"/>
    
    
      <category term="工作" scheme="http://AlbertGithubHome.github.io/blog/tags/%E5%B7%A5%E4%BD%9C/"/>
    
      <category term="学习" scheme="http://AlbertGithubHome.github.io/blog/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>在比较Linux和Windows命令差异时意外发现了Windows Terminal</title>
    <link href="http://AlbertGithubHome.github.io/blog/2021/01/05/%E5%9C%A8%E6%AF%94%E8%BE%83Linux%E5%92%8CWindows%E5%91%BD%E4%BB%A4%E5%B7%AE%E5%BC%82%E6%97%B6%E6%84%8F%E5%A4%96%E5%8F%91%E7%8E%B0%E4%BA%86Windows-Terminal/"/>
    <id>http://AlbertGithubHome.github.io/blog/2021/01/05/在比较Linux和Windows命令差异时意外发现了Windows-Terminal/</id>
    <published>2021-01-05T15:48:57.000Z</published>
    <updated>2021-01-27T15:18:11.653Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>目前工作时的开发环境是 <code>Windows</code> + <code>Linux</code>，常常需要切换测试环境，比如写一个脚本既要在 Windows 使用，同时也要在 Linux 下运行，命令的使用是 Linux 的强项，它自带了很多方便的命令程序，比如过滤字符串的 <code>grep</code>，统计文件行数的 <code>wc</code>，查看目录文件的 <code>ls</code> 等等，如果要在 Windows 中运行相同逻辑的脚本，那我们需要先找到这些命令在 Windows 上的等价写法。</p><a id="more"></a><h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><p>下面列举几个常见的命令，功能上基本等价，如果有更好的写法也欢迎小伙伴们留言补充呀，有些命令在命令框里执行感觉没有作用，但是放到脚本中就很方便了，比如下面第一个：</p><h2 id="显示当前目录"><a href="#显示当前目录" class="headerlink" title="显示当前目录"></a>显示当前目录</h2><ul><li>linux 中的 <code>pwd</code></li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:/mnt/d/app/ScreenToGif/Logs$ <span class="built_in">pwd</span></span><br><span class="line">/mnt/d/app/ScreenToGif/Logs</span><br></pre></td></tr></table></figure><ul><li>windows 中 <code>cd</code></li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">D:\app\ScreenToGif\Logs&gt;<span class="built_in">cd</span></span><br><span class="line">D:\app\ScreenToGif\Logs</span><br></pre></td></tr></table></figure><p>这个显示当前目录的命令在这来看确实没什么用，因为在命令提示框里已经显示的当前所在的目录，但是用到脚本中时就可以发挥作用了，windows 中的 <code>cd</code> 命令不仅可以切换目录，当命令后面不接任何参数时就可以显示当前所在的目录位置。</p><h2 id="显示目录下内容"><a href="#显示目录下内容" class="headerlink" title="显示目录下内容"></a>显示目录下内容</h2><ul><li>linux 中的 <code>ls</code></li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:/mnt/d/app/ScreenToGif/Logs$ ls</span><br><span class="line">20_04_06 11_09_57_942.txt  20_04_06 11_09_58_049.txt  20_04_06.txt</span><br></pre></td></tr></table></figure><ul><li>windows 中 <code>dir</code></li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">D:\app\ScreenToGif\Logs&gt;dir</span><br><span class="line"> 驱动器 D 中的卷没有标签。</span><br><span class="line"> 卷的序列号是 0E68-747E</span><br><span class="line"></span><br><span class="line"> D:\app\ScreenToGif\Logs 的目录</span><br><span class="line"></span><br><span class="line">2020/04/06  23:09    &lt;DIR&gt;          .</span><br><span class="line">2020/04/06  23:09    &lt;DIR&gt;          ..</span><br><span class="line">2020/04/06  23:09               507 20_04_06 11_09_57_942.txt</span><br><span class="line">2020/04/06  23:09               518 20_04_06 11_09_58_049.txt</span><br><span class="line">2020/04/06  23:10             2,754 20_04_06.txt</span><br><span class="line">               3 个文件          3,779 字节</span><br><span class="line">               2 个目录 56,929,013,760 可用字节</span><br></pre></td></tr></table></figure><p>这两个命令都可以显示当前目录下的内容，但是windows下的 <code>dir</code> 更详细一些，当然，linux 下的 <code>ls</code> 命令也可以附加一些参数来达到显示详细信息的目的。</p><h2 id="过滤文本"><a href="#过滤文本" class="headerlink" title="过滤文本"></a>过滤文本</h2><ul><li>linux 中的 <code>grep</code></li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:/mnt/d/app/ScreenToGif/Logs$ ls -l | grep 09_</span><br><span class="line">-rwxrwxrwx 1 albert albert  507 Apr  6  2020 20_04_06 11_09_57_942.txt</span><br><span class="line">-rwxrwxrwx 1 albert albert  518 Apr  6  2020 20_04_06 11_09_58_049.txt</span><br></pre></td></tr></table></figure><ul><li>windows 中 <code>findstr</code></li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">D:\app\ScreenToGif\Logs&gt;dir | findstr 09_</span><br><span class="line">2020/04/06  23:09               507 20_04_06 11_09_57_942.txt</span><br><span class="line">2020/04/06  23:09               518 20_04_06 11_09_58_049.txt</span><br></pre></td></tr></table></figure><p>这两个命令基本上是一样的，都是按行过滤文本，当不加参数时效果基本一致</p><h2 id="查看文件内容"><a href="#查看文件内容" class="headerlink" title="查看文件内容"></a>查看文件内容</h2><ul><li>linux 中的 <code>cat</code></li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:/mnt/d/app/ScreenToGif/Logs$ cat <span class="string">"20_04_06 11_09_57_942.txt"</span></span><br><span class="line">► Title -</span><br><span class="line">        Automatic feedback</span><br><span class="line">▬ Message -</span><br><span class="line">        Value cannot be null.</span><br><span class="line">Parameter name: path1</span><br><span class="line">○ Type -</span><br><span class="line">        System.ArgumentNullException</span><br><span class="line">♦ [Version] Date/Hour -</span><br><span class="line">        [2.14.1] 04/06/2020 23:09:57</span><br><span class="line">▲ Source -</span><br><span class="line">        mscorlib</span><br><span class="line">▼ TargetSite -</span><br><span class="line">        System.String Combine(System.String, System.String, System.String)</span><br><span class="line">♠ StackTrace -</span><br><span class="line">   at System.IO.Path.Combine(String path1, String path2, String path3)</span><br><span class="line">   at ScreenToGif.Model.ApplicationViewModel.SendFeedback()</span><br><span class="line"></span><br><span class="line">----------------------------------</span><br></pre></td></tr></table></figure><ul><li>windows 中 <code>type</code></li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">D:\app\ScreenToGif\Logs&gt;<span class="built_in">type</span> <span class="string">"20_04_06 11_09_57_942.txt"</span></span><br><span class="line">► Title -</span><br><span class="line">        Automatic feedback</span><br><span class="line">▬ Message -</span><br><span class="line">        Value cannot be null.</span><br><span class="line">Parameter name: path1</span><br><span class="line">○ Type -</span><br><span class="line">        System.ArgumentNullException</span><br><span class="line">♦ [Version] Date/Hour -</span><br><span class="line">        [2.14.1] 04/06/2020 23:09:57</span><br><span class="line">▲ Source -</span><br><span class="line">        mscorlib</span><br><span class="line">▼ TargetSite -</span><br><span class="line">        System.String Combine(System.String, System.String, System.String)</span><br><span class="line">♠ StackTrace -</span><br><span class="line">   at System.IO.Path.Combine(String path1, String path2, String path3)</span><br><span class="line">   at ScreenToGif.Model.ApplicationViewModel.SendFeedback()</span><br><span class="line"></span><br><span class="line">----------------------------------</span><br></pre></td></tr></table></figure><h2 id="统计文件行数"><a href="#统计文件行数" class="headerlink" title="统计文件行数"></a>统计文件行数</h2><ul><li>linux 中的 <code>wc -l</code></li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:/mnt/d/app/ScreenToGif/Logs$ cat <span class="string">"20_04_06 11_09_57_942.txt"</span> | wc -l</span><br><span class="line">19</span><br></pre></td></tr></table></figure><ul><li>windows 中 <code>find /c /v &quot;&quot;</code></li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">D:\app\ScreenToGif\Logs&gt;<span class="built_in">type</span> <span class="string">"20_04_06 11_09_57_942.txt"</span> | find /c /v <span class="string">""</span></span><br><span class="line">19</span><br></pre></td></tr></table></figure><p><code>wc</code> 这个命令没什么好说的，专门为统计字符数、字节数、行数而生的，而 windows 下的 <code>find</code> 命令通过 <code>/c</code> 显示匹配函数，<code>/v &quot;&quot;</code> 查找非空行这样的参数组合也能达到统计行数的目的。</p><h2 id="计算文件摘要"><a href="#计算文件摘要" class="headerlink" title="计算文件摘要"></a>计算文件摘要</h2><ul><li>linux 中的 <code>[md5sum|sha1sum|sha256] 文件名</code></li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:/mnt/d/data/cpp$ md5sum simple.cpp</span><br><span class="line">a00eba0276e396de58fabc92b325672a  simple.cpp</span><br><span class="line">albert@home-pc:/mnt/d/data/cpp$ sha1sum simple.cpp</span><br><span class="line">7acf1e59ca2608b7591ec526d48ce041cddf49d2  simple.cpp</span><br><span class="line">albert@home-pc:/mnt/d/data/cpp$ sha256sum simple.cpp</span><br><span class="line">f07bcd585fa7e49897676105797dd984c12f63411f0ba8db62a57f6ef03bbaec  simple.cpp</span><br><span class="line">albert@home-pc:/mnt/d/data/cpp$</span><br></pre></td></tr></table></figure><ul><li>windows 中 <code>certutil -hashfile 文件名 [MD5|SHA1|SHA256]</code></li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">d:\data\cpp&gt;certutil -hashfile simple.cpp MD5</span><br><span class="line">MD5 的 simple.cpp 哈希:</span><br><span class="line">a00eba0276e396de58fabc92b325672a</span><br><span class="line">CertUtil: -hashfile 命令成功完成。</span><br><span class="line"></span><br><span class="line">d:\data\cpp&gt;certutil -hashfile simple.cpp SHA1</span><br><span class="line">SHA1 的 simple.cpp 哈希:</span><br><span class="line">7acf1e59ca2608b7591ec526d48ce041cddf49d2</span><br><span class="line">CertUtil: -hashfile 命令成功完成。</span><br><span class="line"></span><br><span class="line">d:\data\cpp&gt;certutil -hashfile simple.cpp SHA256</span><br><span class="line">SHA256 的 simple.cpp 哈希:</span><br><span class="line">f07bcd585fa7e49897676105797dd984c12f63411f0ba8db62a57f6ef03bbaec</span><br><span class="line">CertUtil: -hashfile 命令成功完成。</span><br></pre></td></tr></table></figure><p>在 linux 上不同的摘要算法对应着不同的程序，但是在 windows 上是同一个程序有着不同的参数。</p><h2 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h2><table><thead><tr><th style="text-align:left">功能</th><th style="text-align:center">linux命令</th><th style="text-align:center">windows命令</th></tr></thead><tbody><tr><td style="text-align:left">拷贝</td><td style="text-align:center"><code>cp</code></td><td style="text-align:center"><code>copy</code>/<code>xcopy</code></td></tr><tr><td style="text-align:left">移动</td><td style="text-align:center"><code>mv</code></td><td style="text-align:center"><code>move</code>/<code>rename</code></td></tr><tr><td style="text-align:left">删除</td><td style="text-align:center"><code>rm</code></td><td style="text-align:center"><code>del</code>/<code>rd</code></td></tr><tr><td style="text-align:left">创建目录</td><td style="text-align:center"><code>mkdir</code></td><td style="text-align:center"><code>md</code>/<code>mkdir</code></td></tr></tbody></table><p>先整理这么多，后续用到新的等价命令再补充吧！</p><h1 id="半路杀出个PowerShell"><a href="#半路杀出个PowerShell" class="headerlink" title="半路杀出个PowerShell"></a>半路杀出个PowerShell</h1><p>一开始接触 PowerShell 把它认为是 cmd 的升级版，感觉就是原来的 cmd 太寒酸了，然后又搞出个 PowerShell 稍微好看了一点，功能又增加了一些而已，但是随着使用次数的增多，我发现之前的理解不太对，PowerShell 和 cmd 它俩完全没关系啊，唯一的相同点就是都被叫做命令行而已。</p><p>PowerShell 通常被描述成是面向对象的脚本语言，并且是在 .Net公共语言运行时(CLR-Common Language Runtime)和.Net Framework的基础上构建的，可以接受和返回.Net对象，引入了cmdlet的概念，是cmd的超集。</p><p>看到一些说法提到“cmd命令都可以在Powershell中执行”，但事实并非如此，比如我最近发现在cmd运行的 <code>type a.txt | find /c /v &quot;&quot;</code> 统计行数的命令在 PowerShell 中就不管用了，所以我认为把 PowerShell 作为 cmd 的升级不太准确。</p><p>PowerShell完全是一个新发明的东西，它里面有一些原来cmd中常用的命令，比如 <code>cd</code>、<code>dir</code>，同时它还兼容了一些 Linux 上的常用命令，比如 <code>ls</code>、<code>man</code> 等，关于这些可以简单看几个例子。</p><h2 id="显示目录下内容-1"><a href="#显示目录下内容-1" class="headerlink" title="显示目录下内容"></a>显示目录下内容</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc D:\app\ScreenToGif\Logs&gt; ls</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    目录: D:\app\ScreenToGif\Logs</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Mode                LastWriteTime         Length Name</span><br><span class="line">----                -------------         ------ ----</span><br><span class="line">-a----         2020/4/6     23:09            507 20_04_06 11_09_57_942.txt</span><br><span class="line">-a----         2020/4/6     23:09            518 20_04_06 11_09_58_049.txt</span><br><span class="line">-a----         2020/4/6     23:10           2754 20_04_06.txt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">albert@home-pc D:\app\ScreenToGif\Logs&gt; dir</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    目录: D:\app\ScreenToGif\Logs</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Mode                LastWriteTime         Length Name</span><br><span class="line">----                -------------         ------ ----</span><br><span class="line">-a----         2020/4/6     23:09            507 20_04_06 11_09_57_942.txt</span><br><span class="line">-a----         2020/4/6     23:09            518 20_04_06 11_09_58_049.txt</span><br><span class="line">-a----         2020/4/6     23:10           2754 20_04_06.txt</span><br></pre></td></tr></table></figure><p>我们可以看到这两个命令在 PowerShell 中执行之后结构完全一样，然后我们使用 <code>man</code> 命令来查看一下两个命令的帮助文档</p><h2 id="查看帮助文档"><a href="#查看帮助文档" class="headerlink" title="查看帮助文档"></a>查看帮助文档</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc D:\app\ScreenToGif\Logs&gt; man dir</span><br><span class="line"></span><br><span class="line">名称</span><br><span class="line">    Get-ChildItem</span><br><span class="line"></span><br><span class="line">语法</span><br><span class="line">    Get-ChildItem [[-Path] &lt;string[]&gt;] [[-Filter] &lt;string&gt;]  [&lt;CommonParameters&gt;]</span><br><span class="line"></span><br><span class="line">    Get-ChildItem [[-Filter] &lt;string&gt;]  [&lt;CommonParameters&gt;]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">别名</span><br><span class="line">    gci</span><br><span class="line">    ls</span><br><span class="line">    dir</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">备注</span><br><span class="line">    Get-Help 在此计算机上找不到该 cmdlet 的帮助文件。它仅显示部分帮助。</span><br><span class="line">        -- 若要下载并安装包含此 cmdlet 的模块的帮助文件，请使用 Update-Help。</span><br><span class="line">        -- 若要联机查看此 cmdlet 的帮助主题，请键入: <span class="string">"Get-Help Get-ChildItem -Online"</span> 或</span><br><span class="line">           转到 https://go.microsoft.com/fwlink/?LinkID=113308。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">albert@home-pc D:\app\ScreenToGif\Logs&gt; man ls</span><br><span class="line"></span><br><span class="line">名称</span><br><span class="line">    Get-ChildItem</span><br><span class="line"></span><br><span class="line">语法</span><br><span class="line">    Get-ChildItem [[-Path] &lt;string[]&gt;] [[-Filter] &lt;string&gt;]  [&lt;CommonParameters&gt;]</span><br><span class="line"></span><br><span class="line">    Get-ChildItem [[-Filter] &lt;string&gt;]  [&lt;CommonParameters&gt;]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">别名</span><br><span class="line">    gci</span><br><span class="line">    ls</span><br><span class="line">    dir</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">备注</span><br><span class="line">    Get-Help 在此计算机上找不到该 cmdlet 的帮助文件。它仅显示部分帮助。</span><br><span class="line">        -- 若要下载并安装包含此 cmdlet 的模块的帮助文件，请使用 Update-Help。</span><br><span class="line">        -- 若要联机查看此 cmdlet 的帮助主题，请键入: <span class="string">"Get-Help Get-ChildItem -Online"</span> 或</span><br><span class="line">           转到 https://go.microsoft.com/fwlink/?LinkID=113308。</span><br></pre></td></tr></table></figure><p>结果还是完全一样，原来在PowerShell中，<code>ls</code> 和 <code>dir</code> 都是命令 <code>Get-ChildItem</code> 的别名，这时我才发现，原来PowerShell自己的命令其实都是这种动宾短语的形式，原来 cmd 中的命令和一些扩展的 Linux 命令大多是以别名的形式存在的。</p><p>所以从这里来看，PowerShell是一款新产品，并不是cmd的简单升级，只是这个新的产物将原来大部分的cmd命令以别名的方式进行了兼容处理而已</p><h1 id="统一命令行的渴望"><a href="#统一命令行的渴望" class="headerlink" title="统一命令行的渴望"></a>统一命令行的渴望</h1><p>上面提到了 cmd、PowerShell、linux Shell 等等，每天使用这些工具时都要开很多窗口，比较麻烦，有没什么途径把它们统一一下呢？这里的统一只是想使用的更方便而已，语法上暂时没办法统一了，偶然间发现了 <code>Windows Terminal</code> 这个工具，一下子打开了新的世界。</p><h1 id="Windows-Terminal"><a href="#Windows-Terminal" class="headerlink" title="Windows Terminal"></a>Windows Terminal</h1><p>Windows Terminal 是一个全新的、功能强大的命令行终端工具。包含多 Tab 支持、富文本、多语言支持、可配置、主题和样式等诸多特性，并且属于微软的亲儿子，支持的力度你懂得。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>直接在 Windows 上打开应用商店安装即可，这时我第二次打开应用商店了，上一次是安装 WSL 的时候。</p><p><img src="https://cdn.jsdelivr.net/gh/albertgithubhome/cdn/img/tools/wt.png" alt="wt"></p><p>官方提供的截图也很炫酷：</p><p><img src="https://cdn.jsdelivr.net/gh/albertgithubhome/cdn/img/tools/wt2.png" alt="wt2"></p><p>我自己也尝试着美化了一下，效果还不错</p><p><img src="https://cdn.jsdelivr.net/gh/albertgithubhome/cdn/img/tools/powershell.png" alt="powershell"></p><h2 id="命令行窗口的统一"><a href="#命令行窗口的统一" class="headerlink" title="命令行窗口的统一"></a>命令行窗口的统一</h2><p>确实不想开很多个命令窗口，比如执行windows脚本命令的cmd、PowerShell，版本管理工具git bash，windows子系统WSL命令行，远程服务器命令行工具XShell等，要是把它们都放在一起就好了，使用Windows Terminal可以轻松实现这个愿望，其中cmd、PowerShell、WSL命令行都是Windows Terminal自带的，git bash 要想显示在 Windows Terminal 中需要手动配置下，运行效果如下：</p><p><img src="https://cdn.jsdelivr.net/gh/albertgithubhome/cdn/img/tools/multiwindow.png" alt="multiwindow"></p><p>配置和美化方法比较简单，网上搜索会有很多教程可以学习</p><h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><p>目前使用 Windows Terminal 替代各种命令行工具只遇到了一个问题，就是它不知道 Zmodem 协议，所以无法使用 <code>sz</code>、<code>rz</code>，对于我这种需要经常上传脚本文件到服务器的人来说不太方便。</p><p>好消息是在2019年的时候已经有人在 Windows Terminal 的 github 项目中提了<a href="https://github.com/microsoft/terminal/issues/1999" target="_blank" rel="noopener">issue</a>，据说会考虑这个功能，但是还得评估下，但是目前已经1年多过去了还没有反馈，焦急等待中，有了它就可以不使用XShell了。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li><code>cmd</code> 和 <code>PowerShell</code> 是两个不相同的命令行程序，有些cmd命令无法直接在PowerShell中运行</li><li><code>cmd</code> 能做的 <code>PowerShell</code> 几乎都能做，但是不能直接拿过来就运行，有时需要简单的改写才可以</li><li><code>PowerShell</code> 的命令采用动宾的格式，并且使用别名的形式兼容 <code>cmd</code> 命令和一些 Linux 命令</li><li><code>Windows Terminal</code> 目前来看很优秀，可以将cmd、PowerShell、WSL Shell等运行在同一个窗口中</li><li>由于 <code>Windows Terminal</code> 不支持 Zmodem 协议，所以暂时还不能使用 <code>sz</code>、<code>rz</code> 命令来传送文件</li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/112057093" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>不过是大梦一场空，不过是孤影照惊鸿，不过是白驹之过一场梦，梦里有一些相逢……歌词写的真好！</p><p>2021-1-10 00:33:11</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;目前工作时的开发环境是 &lt;code&gt;Windows&lt;/code&gt; + &lt;code&gt;Linux&lt;/code&gt;，常常需要切换测试环境，比如写一个脚本既要在 Windows 使用，同时也要在 Linux 下运行，命令的使用是 Linux 的强项，它自带了很多方便的命令程序，比如过滤字符串的 &lt;code&gt;grep&lt;/code&gt;，统计文件行数的 &lt;code&gt;wc&lt;/code&gt;，查看目录文件的 &lt;code&gt;ls&lt;/code&gt; 等等，如果要在 Windows 中运行相同逻辑的脚本，那我们需要先找到这些命令在 Windows 上的等价写法。&lt;/p&gt;
    
    </summary>
    
      <category term="windows" scheme="http://AlbertGithubHome.github.io/blog/categories/windows/"/>
    
    
      <category term="linux" scheme="http://AlbertGithubHome.github.io/blog/tags/linux/"/>
    
      <category term="windows" scheme="http://AlbertGithubHome.github.io/blog/tags/windows/"/>
    
      <category term="ternimal" scheme="http://AlbertGithubHome.github.io/blog/tags/ternimal/"/>
    
      <category term="powershell" scheme="http://AlbertGithubHome.github.io/blog/tags/powershell/"/>
    
  </entry>
  
  <entry>
    <title>2020年终总结！新的起航，新的征程</title>
    <link href="http://AlbertGithubHome.github.io/blog/2020/12/27/2020%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93%EF%BC%81%E6%96%B0%E7%9A%84%E8%B5%B7%E8%88%AA%EF%BC%8C%E6%96%B0%E7%9A%84%E5%BE%81%E7%A8%8B/"/>
    <id>http://AlbertGithubHome.github.io/blog/2020/12/27/2020年终总结！新的起航，新的征程/</id>
    <published>2020-12-27T12:25:12.000Z</published>
    <updated>2020-12-31T14:57:04.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>奇变偶不变，符号看象限，真正的知识就是这么朴实无华~</p></blockquote><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>从2019年开始意识到年终总结的意义，通过反思自己的得失进而确定今后的方向，既然去年开了头，今年也不能中断，依旧写写每天的流水账，细数最近一年发生的故事。</p><a id="more"></a><p>今年最直观的、印象最深的感受就是时间不够用，一首《时间都去哪了》旋律时常出现在脑海中，对比之前长久不变的工作环境，今年确实紧张了许多，习惯了原来的安逸，对各种可能发生的问题轻车熟路的就能解决掉，但来到新环境，一切变得不是那么轻松了。</p><h1 id="回顾2020"><a href="#回顾2020" class="headerlink" title="回顾2020"></a>回顾2020</h1><p>毕竟到了年终时刻，之前的flag可不能忘，依旧是从工作、学习、生活三个方面来回忆一下去年flag的完成情况。</p><h2 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h2><blockquote><p>2020 flag：新的一年不能再碌碌无为，真的需要去闯一闯了</p><p>完成度：95%</p></blockquote><p>年初如愿的换了一份新工作，之前的公司呆的时间太长了，工作内容单一，熟悉了安逸的环境，虽然每天也在学习，但是进步缓慢，在2019年末开始寻找新的发展环境，在2020初就成功找到了新的工作机会，提前完成flag内容。</p><p>与老东家分手过程可以说不太愉快，给不了梦想，撑不起现实，一味的拖着可不是解决问题的办法，不过事情已经过去，不想再提，毕竟也为之奋斗过，近2000个日日夜夜，梦开始的地方，也是认清现实的地方。</p><p>离开原公司来到新公司算是无缝衔接吧，中间在家只待了3天，如果能早点意识到离职流程这么狗血，我真应该在家躺一个月，不过新公司的入职流程还真是暖心，提前先网上入职，帮我把社保问题解决了，感谢流程中出现的每一个人。</p><p>新的工作内容刚开始肯定要吃力一些，首先是熟悉开发环境，大体和原来相同，不过复杂的申请制度较原来规范了许多，同时也麻烦了许多，版本控制是一个重要的改变，之前主要使用SVN，如今换成了 Git + SVN，以前经常使用的 git 三部曲——add、commit、push 已经不够用了，随着不断的使用学习，渐渐熟悉了 <code>checkout</code>、<code>merge</code>、<code>rebase</code>、<code>cherry-pick</code> <code>reset</code> 等等子命令，还是那句话多用才能学会，如果只停留在纸面上，只是眼睛学会了，闭上眼睛就忘记了。</p><p>选择这份新的工作也是想拓宽自己的知识面，之前一直在做分区分服的游戏，想学习一下分布式游戏的开发和一些需要需要注意的问题，所以说这份工作是用来补充我这方面知识短板的，从学习了一年的结果来看，确实达到了这个目的，虽然现在的规模还没有那么大，有些逻辑来不太完善，但是这已经给我做出了示范，在今后的一段时间内，将沿着这条路不断的前行，去探索自己未知的领域。</p><p>新的工作认识新的伙伴，大家相处起来还是很友好的，一年来的工作算是中规中矩，不过年底这俩月有点滑铁卢的味道，接连在同一个位置摔倒几次，还是老大给背了锅，内心愧疚不已，无以为报，愿以更饱满的热情投入工作中，实践当初并肩战斗的诺言，得一伙伴不易，愿共同进步。</p><p>今年的工作强度明显高于以往，倒不是工作时间长了，而是在新环境中，长时间聚精会神的盯在一件事上本来就很累，头发掉的明显比之前多了，眼睛的视力也下降的厉害，这两点要注意一下了，可以调整一下工作的节奏，注意劳逸结合，我可不想“聪明绝顶”。</p><div align="center"><br><img src="https://cdn.jsdelivr.net/gh/albertgithubhome/cdn/img/summary/2020/pressure.png" alt="pressure"><br></div><h2 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h2><blockquote><p>2020 flag：看两本有关分布式知识的图书，多看一些开源项目的代码</p><p>完成度：85%</p></blockquote><p>有关分布式架构的书今年只看了一本，另外基本都是和育儿知识相关，他们分别是：</p><ul><li>从零开始学架构 ——照着做，你也能称为架构师</li><li>你就是孩子最好的玩具</li><li>正面管教</li><li>小狗钱钱2</li></ul><p>今年的1本技术书籍对比去年的7本少了很多，一方面换了新工作后需要花很多时间来熟悉新的业务逻辑，用来读书的时间被侵占了一部分，另一方面宝宝一天天长大，需要花些时间去陪伴她，虽然技术书读的少了，可是故事书我可没少读，一年读了好几十本：</p><div align="center"><br><img src="https://cdn.jsdelivr.net/gh/albertgithubhome/cdn/img/summary/2020/story.jpg" alt="story"><br></div><p>这些故事书中描述的故事小时候没觉得有什么不妥，不过以现在成年人的身份来看，有些故事太离奇了，比如大灰狼和七只小羊的故事，山羊妈妈居然剪开狼的肚皮救出了被吃掉的六只小山羊，然后在狼的肚子里装满石头缝上了，整个过程大灰狼都没有醒，我感觉山羊妈妈可能是个麻醉科的护士。</p><p>虽然故事内容离奇，但是并不妨碍小娃娃听到津津有味，小孩子的世界还真是单纯，有故事听就老老实实的等着，而我化身为一个播报员，一遍一遍的重复着书中的故事。</p><p>博客总结今年也没有丢，一共写了45篇，比去年还要多几篇，总体来看类别很多，总结的内容并不难懂，写到博客中主要是为了方便日后的查找，这一年的总结绝大部分都是晚上和周末花时间写的，只有尝试过才明白，想写好一篇总结需要花费很多很多时间，今年的成长可以对比两年数据来看一下。</p><div align="center"><br><img src="https://cdn.jsdelivr.net/gh/albertgithubhome/cdn/img/20191231csdn.png" alt="20191231csdn"><br></div><br><div align="center"><br><img src="https://cdn.jsdelivr.net/gh/albertgithubhome/cdn/img/summary/2020/csdn.png" alt="csdn"><br></div><p>C++11的使用在这一年里变得更加熟练，之前的项目中无法使用C++11的特性，所以很多知识都是自己额外花时间来测试学习，来到新项目可以参考已有的代码，进一步巩固C++11的使用，知识还是越用掌握的越好。</p><p>语言方面还有Python今年用的比较多，得益于工作中的多次锻炼，一些常用的函数，类型可以很熟练的写出来了，虽然没有用来写过什么大的软件，但是也在不断尝试着使代码更规范，比如使用class、装饰器、继承、记录运行日志等等。</p><p>Go语言今年算是简单入门吧，之前只能算是听说过，今年快速的浏览了一遍Go语言的语法，编写了一些测试程序，但是对于Go语言的条条框框还是不太习惯，需要慢慢适应下。</p><p>刷题今年一直在坚持着，之前使用的国际账号一时找不到了，今年新注册了国内版LeetCode账号，本着刷简单冲中等的态度，一直在默默的洗刷刷，不过今年参加了几次竞赛，一直是两题选手，只有一次题比较简单全答出来了，当时还是很开心的，继续加油吧。</p><div align="center"><br><img src="https://cdn.jsdelivr.net/gh/albertgithubhome/cdn/img/summary/2020/leetcode.png" alt="leetcode"><br></div><p>阅读开源项目源码方面，今年也有了很大的进步，在新项目中接触了好几个之前没有使用过的开源库，虽然没有完全整明白，但最起码开阔了眼界，比如 <code>easyloging++</code>、<code>nolhmann json</code>库等等，另外今年还意外获得了 Github 的 <code>Arctic Code Vault Contributor</code> 勋章，看来我写的BUG要被雪藏千年了，哈哈。</p><h2 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h2><blockquote><p>2020 flag：尽最大可能陪陪家人、投资达到2019的水平</p><p>完成度：55%</p></blockquote><p>多陪陪家人这一项今年应该算完成了，因为疫情今年也没有出去疯，就是出门买买菜，其他的闲暇时间都和家人在一起，天气好的时候去附近的公园逛逛，对比2019年，每天晚上回家的时间晚了一点，但是多了每周多了一整天可以和家人一起度过。</p><p>现在每天还是很充实的，早上起来妈妈已经做好早饭，赶紧洗漱和家人一起吃个早饭，然后和宝宝告别去上班。晚上回来大多数情况宝宝已经睡了，不过有时候也能挺到我回家，和我玩一会再睡。周末陪宝宝出去玩，透透新鲜空气，等宝宝睡觉的时候对近期所学的知识做一个总结，基本上周末的时间陪娃、总结55开吧。</p><p>这个flag完成度不高主要是投资理财这块今天基本上是停滞了，未达到2019年水平，每天除了工作就是学习，账户情况没怎么看，整个一个过山车行情，所以基本上处于不赔不赚的情况。</p><p>节前的最后一天是大涨行情，算是一个好的结尾，全年放养的状态收益率3个多点，勉强跑赢余额宝的收益，估计跑不过今年的通货膨胀了！</p><div align="center"><br><img src="https://cdn.jsdelivr.net/gh/albertgithubhome/cdn/img/summary/2020/stock.jpg" alt="stock"><br></div><p>目前的生活状况就是每天都相似，但确实很满足，早上起床一家人吃早饭，和宝宝告别后送媳妇上班，然后自己骑个自行车来公司上班，努力完成一天的工作再骑个小车回家，如果宝宝没睡还可以陪她玩一会儿，等宝宝睡着开始一天的总结，温暖而又充实。</p><p>2020年初养了一年的栀子花开花了，正好在我过年回老家的时候开的花，之前我好好浇水通风的时候它却连个花骨朵都没有，好像再告诉我只要我不管它就能好好开花，可是在10月份的时候枯死了。还有一盆文竹在夏天涨势良好，修剪了几次，但没有熬过寒冷的冬天，在11月份左右干枯了。</p><p>在上两盆花相继离开之后，我赶紧又补充了新的生机，一盆栀子花和一盆茉莉花，目前长势良好，茉莉花已经开花了，希望它俩在新的一年里花香不断。</p><div align="center"><br><img src="https://cdn.jsdelivr.net/gh/albertgithubhome/cdn/img/summary/2020/flower.jpg" alt="flower"><br></div><h1 id="展望2021"><a href="#展望2021" class="headerlink" title="展望2021"></a>展望2021</h1><h2 id="工作-1"><a href="#工作-1" class="headerlink" title="工作"></a>工作</h2><ul><li>脚踏实地做好本职工作</li><li>额外挤出时间去尝试技术提升（优化、解决痛点）</li><li>在熟悉业务的同时更多参与设计的工作，拓宽自己的认知范围</li></ul><h2 id="学习-1"><a href="#学习-1" class="headerlink" title="学习"></a>学习</h2><ul><li>博客总结继续，基本保持在1周一篇，可以适当偷懒，一年懒10次可以产出40篇</li><li>开源代码还是要继续学习，libevent需要详细看一下，今年的出镜率太高</li><li>读2本技术类书籍，可以是开阔眼界的，也可以是现有技能提升的</li><li>读2本经济学、金融理财相关的书籍</li></ul><h2 id="生活-1"><a href="#生活-1" class="headerlink" title="生活"></a>生活</h2><ul><li>陪娃娃，陪家人，工作内容适应后可以多拿出一点时间和家人在一起（需要比2020多一些）</li><li>投资理财还是要多花一点时间研究下，目标7%（靠工资是不可能财富自由的，必须开源才行）</li><li>注重身体的保养，身体是本钱，可不能把身体搞垮了，愿丢掉体检时的小毛病~</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>2020年在工作上是一个新的开始，同时也面临着新的挑战</li><li>2020年的flag完成度大概70%，大部分愿望已经实现，未实现部分还需努力</li><li>2021年已经悄然开始，新的flag已经在路上，为了新的目标加油努力吧</li></ul><div align="center"><br><img src="https://cdn.jsdelivr.net/gh/albertgithubhome/cdn/img/summary/2020/fighting.gif" alt="fighting"><br></div><hr><center><a href="https://blog.csdn.net/albertsh/article/details/111148573" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>人生旅途中运气与实力都很重要，但是强大的实力可以帮助你提升运气，减少不确定性（记一次事故后提心吊胆的等待），比如买一注彩票中一千万很难，但是如果你的实力可以强大到买下大部分甚至是所有的组合，那么要中一千万只需要等到开奖就可以了~</p><p>凡是过去，皆为序幕</p><p>2020-12-27 00:32:07</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;奇变偶不变，符号看象限，真正的知识就是这么朴实无华~&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;从2019年开始意识到年终总结的意义，通过反思自己的得失进而确定今后的方向，既然去年开了头，今年也不能中断，依旧写写每天的流水账，细数最近一年发生的故事。&lt;/p&gt;
    
    </summary>
    
      <category term="Thinking" scheme="http://AlbertGithubHome.github.io/blog/categories/Thinking/"/>
    
    
      <category term="总结" scheme="http://AlbertGithubHome.github.io/blog/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="工作" scheme="http://AlbertGithubHome.github.io/blog/tags/%E5%B7%A5%E4%BD%9C/"/>
    
      <category term="学习" scheme="http://AlbertGithubHome.github.io/blog/tags/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="生活" scheme="http://AlbertGithubHome.github.io/blog/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>system_clock::now()和time()时间函数混用带来的踩坑经历</title>
    <link href="http://AlbertGithubHome.github.io/blog/2020/12/13/%E6%97%B6system-clock-now-%E5%92%8Ctime-%E6%97%B6%E9%97%B4%E5%87%BD%E6%95%B0%E6%B7%B7%E7%94%A8%E5%B8%A6%E6%9D%A5%E7%9A%84%E8%B8%A9%E5%9D%91%E7%BB%8F%E5%8E%86/"/>
    <id>http://AlbertGithubHome.github.io/blog/2020/12/13/时system-clock-now-和time-时间函数混用带来的踩坑经历/</id>
    <published>2020-12-13T15:16:17.000Z</published>
    <updated>2020-12-27T12:42:21.486Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>时间是一个可怕的东西，听说能用来杀猪。在编程世界中，时间也控制着一个维度，常常伴随着程序运行而流逝，有时也会影响着程序的运行的逻辑，所以在程序中处理时间时还是要仔细一些，最近连续踩坑，总结一下给自己提个醒，有些逻辑还是需要抱着怀疑的态度去看待。</p><a id="more"></a><h1 id="时间函数混用"><a href="#时间函数混用" class="headerlink" title="时间函数混用"></a>时间函数混用</h1><p>我们在写一个小程序时基本不会去混用时间函数，比如只用 <code>time(NULL)</code> 去控制时间，或者只使用 <code>chrono::system_clock::now()</code> 来记录时间消耗，关于 <code>chrono</code> 的用法，之前简单总结过，可传送至 <a href="https://blog.csdn.net/albertsh/article/details/105468687" target="_blank" rel="noopener">C++11中的时间库std::chrono</a>。</p><p>但是当程序变得复杂起来，这个时间函数混用的高压线还是有可能触碰到的，当程序逻辑对时间要求越发精确时，混用所带来的后果将越发严重。在此记录一个结果：连续调用 <code>time(NULL)</code> 和 <code>chrono::system_clock::now()</code> 两个函数得到的时间戳可能是不同的。</p><p>可能你会说，函数是先后调用的，肯定是不同的，后面的函数调用时的时间戳要比前面的大，但事实却是两个函数所取得的时间戳大小不确定，可能是第一个函数的时间戳比较大，也可能是第二个时间戳更大一些。</p><h1 id="测试的例子"><a href="#测试的例子" class="headerlink" title="测试的例子"></a>测试的例子</h1><p>下面展示一段代码，先后调用两个时间函数，打印所获得的时间戳，可以看看有什么特点：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int64_t</span> t1, t2;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        t1 = chrono::duration_cast&lt;chrono::milliseconds&gt;(chrono::system_clock::now().time_since_epoch()).count();</span><br><span class="line">        t2 = time(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (t1/<span class="number">1000</span> != t2) <span class="built_in">cout</span> &lt;&lt; t1 &lt;&lt; <span class="string">" "</span> &lt;&lt; t2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译运行结果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:testtime$ g++ testtime.cpp -std=c++11</span><br><span class="line">albert@home-pc:testtime$ ./a.out</span><br><span class="line">1607779917993 1607779918</span><br><span class="line">1607779957999 1607779958</span><br><span class="line">1607780080001 1607780079</span><br><span class="line">1607780103001 1607780102</span><br><span class="line">1607780150001 1607780149</span><br><span class="line">1607780202001 1607780201</span><br><span class="line">1607780327999 1607780328</span><br><span class="line">1607780440001 1607780439</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>运行之后很快就出现了一些不一致，对比可以发现，两个时间戳一个是毫秒，一个是秒，同时把单位转化成秒来比较时，两者大小不定，从仅有的这几行结果来看，最大的误差是7毫秒。</p><h1 id="再加一个时间函数"><a href="#再加一个时间函数" class="headerlink" title="再加一个时间函数"></a>再加一个时间函数</h1><p>除了上面提到的两个函数，还有一个 <code>gettimeofday()</code> 函数也是在获取时间时常常使用的，把它也放到测试函数中对比一下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int64_t</span> t1, t2, t = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>;</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        t1 = chrono::duration_cast&lt;chrono::milliseconds&gt;(chrono::system_clock::now().time_since_epoch()).count();</span><br><span class="line">        t2 = time(<span class="number">0</span>);</span><br><span class="line">        gettimeofday(&amp;tv, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (t1/<span class="number">1000</span> != t2 || t2 != tv.tv_sec)</span><br><span class="line">            <span class="keyword">if</span> (t != t1) <span class="built_in">cout</span> &lt;&lt; t1 &lt;&lt; <span class="string">" "</span> &lt;&lt; t2 &lt;&lt; <span class="string">" "</span> &lt;&lt; tv.tv_sec &lt;&lt; <span class="string">","</span> &lt;&lt; tv.tv_usec &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">        t = t1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行后查看结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">albert@DESKTOP-6746UC3:/mnt/d/data/cpp/testtime$ g++ testtime.cpp --std=c++11</span><br><span class="line">albert@DESKTOP-6746UC3:/mnt/d/data/cpp/testtime$ ./a.out</span><br><span class="line">1607876993000 1607876992 1607876993,2</span><br><span class="line">1607876994000 1607876993 1607876994,3</span><br><span class="line">1607876995000 1607876994 1607876995,3</span><br><span class="line">1607876996000 1607876995 1607876996,2</span><br><span class="line">1607876997000 1607876996 1607876997,1</span><br><span class="line">1607876998000 1607876997 1607876998,2</span><br><span class="line">1607876999000 1607876998 1607876999,2</span><br><span class="line">1607877000000 1607876999 1607877000,3</span><br><span class="line">1607877001000 1607877000 1607877001,1</span><br><span class="line">1607877002000 1607877001 1607877002,3</span><br><span class="line">1607877003000 1607877002 1607877003,2</span><br><span class="line">1607877004000 1607877003 1607877004,2</span><br><span class="line">1607877005000 1607877004 1607877005,1</span><br><span class="line">1607877006000 1607877005 1607877006,3</span><br><span class="line">1607877007000 1607877006 1607877007,2</span><br><span class="line">1607877008000 1607877007 1607877008,11</span><br><span class="line">1607877009000 1607877008 1607877009,3</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>真是各不相同，这要是在发射火箭时混用两个时间函数，那估计探月卫星就凉凉了……</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>常用来获取时间戳的函数有 <code>time()</code>、<code>chrono::system_clock::now()</code> 和 <code>gettimeofday()</code></li><li>时间函数不要混用，否则会给精密计算带来巨大的麻烦，造成计算结果的不可控</li><li>测试发现 <code>chrono::system_clock::now()</code> 和 <code>gettimeofday()</code> 时间非常接近，有微秒级别的误差，但也不建议混用</li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/109976348" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>有的人走了只留下一撮灰烬，有的人离开却千古留名，但在时间长河中就是那么一瞬，意义何在，有差吗？</p><p>2020-12-14 00:12:01</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;时间是一个可怕的东西，听说能用来杀猪。在编程世界中，时间也控制着一个维度，常常伴随着程序运行而流逝，有时也会影响着程序的运行的逻辑，所以在程序中处理时间时还是要仔细一些，最近连续踩坑，总结一下给自己提个醒，有些逻辑还是需要抱着怀疑的态度去看待。&lt;/p&gt;
    
    </summary>
    
    
      <category term="C++" scheme="http://AlbertGithubHome.github.io/blog/tags/C/"/>
    
      <category term="时间" scheme="http://AlbertGithubHome.github.io/blog/tags/%E6%97%B6%E9%97%B4/"/>
    
      <category term="time" scheme="http://AlbertGithubHome.github.io/blog/tags/time/"/>
    
      <category term="system_clock" scheme="http://AlbertGithubHome.github.io/blog/tags/system-clock/"/>
    
  </entry>
  
  <entry>
    <title>C/C++中有符号数隐式类型转换成无符号数需注意的问题</title>
    <link href="http://AlbertGithubHome.github.io/blog/2020/12/07/C-C-%E4%B8%AD%E6%9C%89%E7%AC%A6%E5%8F%B7%E6%95%B0%E9%9A%90%E5%BC%8F%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E6%88%90%E6%97%A0%E7%AC%A6%E5%8F%B7%E6%95%B0%E9%9C%80%E6%B3%A8%E6%84%8F%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://AlbertGithubHome.github.io/blog/2020/12/07/C-C-中有符号数隐式类型转换成无符号数需注意的问题/</id>
    <published>2020-12-07T15:11:16.000Z</published>
    <updated>2020-12-27T12:40:29.832Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>隐式类型转换转换是一个挺基础的概念，即使对于初学者来说都不会陌生，一般情况下是指数据类型的转换是由编译系统自动进行的，不需要人工干预的类型转换方式。与之相对的是强制类型转换，在进行转换时必须使用强制类型转换运算符进行转换，这种也被称为显式转换。</p><a id="more"></a><h1 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h1><h2 id="隐式转换"><a href="#隐式转换" class="headerlink" title="隐式转换"></a>隐式转换</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">short</span> sn = <span class="number">999</span>;</span><br><span class="line"><span class="keyword">int</span> n = sn;</span><br></pre></td></tr></table></figure><h2 id="显示转换"><a href="#显示转换" class="headerlink" title="显示转换"></a>显示转换</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> f = <span class="number">110.741f</span>;</span><br><span class="line"><span class="keyword">int</span> n = (<span class="keyword">int</span>)f;</span><br></pre></td></tr></table></figure><p>这两种转换方式平时经常用到，不管是函数传参时进行转换，还是数学计算时进行强转，一直也没有发现有什么问题，直到昨天遇到了一个有符号数隐式转换成无符号数时，才发现这里也是一个知识盲点，当时脑瓜儿嗡嗡的，怎么连隐式类型转换也这么陌生了呢？</p><p>其实隐式类型转换一般发生在小类型转换成大类型时，有个常用的关系链 <code>char -&gt; short -&gt; int -&gt; long -&gt; float -&gt; double</code>，当关系链条中出现无符号数字时，情况有些难以理解了（实际上是有符号数字的锅）。</p><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>看一下这几行代码，如果你能准确说出程序的输出值，那么你已经掌握了这个知识点，后面的内容可以不用看了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c = <span class="number">128</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> n = c;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码的输出值是 <code>4294967168</code>，发生了啥？也就是说老板给你发工资时，本来想发128块，但是发工资的函数参数是 <code>unsigned int</code> 类型的，结果就给你发了 4294967168，一下就实现了40多个小目标。</p><h1 id="查找原因"><a href="#查找原因" class="headerlink" title="查找原因"></a>查找原因</h1><p>针对上面的代码我们改写一下，把变量 c 换成无符号类型：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> c = <span class="number">128</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> n = c;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这次的输出值变成了 <code>128</code>, 符合我们的预期，回过头来再看看刚才出错的代码，区别就是变量c是否有符号，结果差了好几十亿。</p><p>这里导致结果差异的原因实际上是符号位引起的，如果是无符号数字，从小类型到大类型隐式类型转换的结果数字都不会变，但是如果是有符号的数字，在转换成大类型数字的时候就要考虑符号位了，就以第一段代码为例来解释这个现象。</p><p><code>char c = 128;</code> 这一句实际上已经超出了变量 c 的范围，因为变量c是有符号数字，所以它的范围是-128~127，这里赋值成128，实际在内存中的bit排列是 <code>10000000</code>，而有符号数的第一位bit表示正负号，这里是1表示这是一个负数，计算机存储负数是以补码的形式存储的，那么把这个数据按位取反再加1，得到 <code>1000000</code> 还是原来的数字，好神奇哦！</p><p>不过这里就可以计算出 c 实际上代表-128，那么它在隐式类型转换成更大的有符号数字时，需要保证值不变，一个int的-128怎么表示呢？根据补码的定义应该是<code>11111111 11111111 11111111 10000000</code>，这个数字再转换成 <code>unsigned int</code> 就是前面提到的 4294967168 啦。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>有符号数字在转换成范围更大的无符号数字时需要注意转换所得数值是否正确，失之毫厘差之千里。</li><li>总结一个规律，有符号的整形数字在进行隐式类型转换时实际上是在数字的二进制表示前面补充符号位。</li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/110357193" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>一个人不能做完所有的事情，但是所有人都可以做一些事情，怕什么真理无穷，进一寸有进有一寸的欢喜~</p><p>2020-12-8 00:04:05</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;隐式类型转换转换是一个挺基础的概念，即使对于初学者来说都不会陌生，一般情况下是指数据类型的转换是由编译系统自动进行的，不需要人工干预的类型转换方式。与之相对的是强制类型转换，在进行转换时必须使用强制类型转换运算符进行转换，这种也被称为显式转换。&lt;/p&gt;
    
    </summary>
    
      <category term="C/C++" scheme="http://AlbertGithubHome.github.io/blog/categories/C-C/"/>
    
    
      <category term="C/C++" scheme="http://AlbertGithubHome.github.io/blog/tags/C-C/"/>
    
      <category term="符号" scheme="http://AlbertGithubHome.github.io/blog/tags/%E7%AC%A6%E5%8F%B7/"/>
    
      <category term="隐式类型" scheme="http://AlbertGithubHome.github.io/blog/tags/%E9%9A%90%E5%BC%8F%E7%B1%BB%E5%9E%8B/"/>
    
      <category term="转换" scheme="http://AlbertGithubHome.github.io/blog/tags/%E8%BD%AC%E6%8D%A2/"/>
    
  </entry>
  
  <entry>
    <title>简单聊聊01世界中编码和解码这对磨人的小妖儿</title>
    <link href="http://AlbertGithubHome.github.io/blog/2020/11/28/%E7%AE%80%E5%8D%95%E8%81%8A%E8%81%8A01%E4%B8%96%E7%95%8C%E4%B8%AD%E7%BC%96%E7%A0%81%E5%92%8C%E8%A7%A3%E7%A0%81%E8%BF%99%E5%AF%B9%E7%A3%A8%E4%BA%BA%E7%9A%84%E5%B0%8F%E5%A6%96%E5%84%BF/"/>
    <id>http://AlbertGithubHome.github.io/blog/2020/11/28/简单聊聊01世界中编码和解码这对磨人的小妖儿/</id>
    <published>2020-11-28T11:28:30.000Z</published>
    <updated>2020-12-27T12:41:11.250Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在程序员生活的01世界中有两大Boss级难题，分别是缓存失效和命名问题，对比这两大难题来说，编码和解码只能算是小妖儿了，只不过这两个小妖儿出镜率很高，有时确实很磨人的，得多花些时间捋顺一下。</p><a id="more"></a><p>编码问题不仅仅出现在计算机中，广义的说，编码问题涉及到人类社会的方方面面，比如古人规定指定长度是一寸，然后规定十寸为一尺，其实就是当时人们对长度的一种编码，但是由于每个地方的编码不统一，导致人们在交流的时候出现了很多问题，直到秦始皇统一了文字、度量衡，相当于统一了描述当时社会的编码，使得知识和文明得以快速传播。</p><h1 id="计算机中的编码"><a href="#计算机中的编码" class="headerlink" title="计算机中的编码"></a>计算机中的编码</h1><p>今天想说的编码和解码特指计算中使用的编码和解码，通俗点说：编码是给计算机看的，解码是为了让人能看懂的。可能大家对这句话还不太理解，不过没关系，这个说法本身不太严谨，也可以举出一些反例，但是大部分情况下确实是这样的。</p><p>为什么要编码，想想谍战片里近代社会中的发电报过程，滴答、滴滴答、滴滴滴答答就这个样子，怎么来表达“敌人发动进攻了”，这时候就用到了编码，提前约定好“滴答”代表“敌”，“滴滴答”代表“人”，这样在收到“滴答、滴滴答”你就知道了“敌人”这个信息，那个密码本记录的内容和规则其实就是对所有电传信息的一种编码。</p><p>计算机中的编码也是一样的，从我们开始接触到计算机的时候就听说过计算机只认识0和1，虽然现代计算机技术发展迅速，但是计算机只认识0和1这一点一直未变，所以你想让他看懂你的信息，保存你的数据，就要把这些信息和数据编码成0和1，计算机才能进行处理和存储。</p><p>所以计算机中为什么要对数据进行编码，这里可以给一个狭义的理解：计算机编码是为了让数据便于传输、存储和处理。</p><p>那有为什么要进行解码呢？其实就是为了人能看懂，给你一串二进制 <code>01010111100011111111...</code>，相信你即使有最强大脑也不能迅速把所有数据解开，这可能是一篇优美的散文、一幅美丽的图画，或者是一部励志的电影，这一切都需要解码后才能知道。</p><p>本来想画一幅“编码”和“解码”这两个小妖的画像，但是作为灵魂画手的我还没构思好，此处留空，后面补充。。。</p><hr><p>补上了&gt;&gt;</p><p><img src="https://img-blog.csdnimg.cn/20201129230755158.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9hbGJlcnRnaXRodWJob21lLmdpdGh1Yi5pby9ibG9nL2Fib3V0,size_12,color_FFFFFF,t_70#pic_center" alt="encoding"></p><h1 id="初识编码问题"><a href="#初识编码问题" class="headerlink" title="初识编码问题"></a>初识编码问题</h1><p>自从接触计算机就开始接触编码问题，比如你抄同学发来的作业文档，打开后却发现是一堆乱码，那时仅仅知道是编码错了，但是不知道怎么解决，或者直接让同学再发一份算了，后来在工作中需要做游戏多语言版本时才真正开始处理编码问题。</p><p>解决第一个编码问题大概是14年，当时做上线游戏的多语言版本、配置文件中的中文保存为 <code>ANSI</code> 编码，相同的配置文件放到日韩的系统上居然变成了其他的含义，查询解决方案决定使用 <code>UTF-8</code> 编码来保存配置文件，所以当时利用工具将所有的配置文件转换成了UTF-8编码，也是那个时候第一次接触到了Python，转换之后将其中的中文翻译成日韩的语言，从此知道了 <code>UTF-8</code> 这个编码方式，也清楚了在中日韩、越南、缅甸这个圈做产品，千万要远离 <code>ANSI</code> 编码。</p><p>其实 <code>ANSI</code> 并不是某一种特定的字符编码，而是一个编码集合，在不同的系统中，可以表示不同的编码，比如英文系统中的 <code>ASCII</code>编码，简体中文系统中的 <code>GBK</code>编码，韩文系统中 <code>EUC-KR</code> 编码等等</p><h2 id="编码变迁小八卦"><a href="#编码变迁小八卦" class="headerlink" title="编码变迁小八卦"></a>编码变迁小八卦</h2><p>计算机是美国人发明用于科学计算的，所以他们也是第一批考虑编码的，而英文只有26个字母，所以他们发明了ASCII码，只使用了0-127这128个空间就表示了所有可能用的字符，但后来计算机技术飞速发展，已经不仅仅用于科学计算，已经融入到社会的方方面面，并且迅速在全球流行。</p><p>随着计算机火遍全球，其它国家发现自己国家经常使用的字符，在 ASCII 码中找不到啊，于是就有人想啊，ASCII 码中的一个字节中不是才用了一半吗，我们使用这个最高位来扩展把，于是很多国家就开始用最高位来扩展这个 ASCII 编码以便能够表示自己国家的一些字符，但是对于我博大精深的中国文化来说，这一个字节远远不够啊，我们的汉字那可就有好几万个，你就给我一个字节，我肯定不干。</p><p>既然一个字节搞不定，那我们就用两个字节好了，我们规定一个小于等于127的字符的意义与原来相同，此处为了兼容ASCII码，但两个大于127的字符连在一起时，就表示一个汉字，前一个字节从0xA1用到0xF7，后面一个字节从0xA1到0xFE，我们将常用的6000多汉字在这个范围内定义代码点，并将这种编码方式称为 <code>GB2312</code>。</p><p>在 GB2312 这种编码中我们考虑了数学符号、希腊字母、全角标点等等，但是只有简体字没有繁体字啊，这下对面海岸的同胞们不乐意了，自己搞了一套 <code>Big5</code> 编码，用来处理繁体字。</p><p>后来随着电脑深入各个领域，常用汉字已经不能满足使用需求了，所以又把 GB2312 编码中没有使用的位置拿出来又进行代码点定义，处理了20000多个汉字，发明了 <code>GBK</code> 编码，但没过多久（2000年）发现还是不够用，又提出了变长的 <code>GB18030</code> 编码，每个字符占用1、2、4个字节。</p><h1 id="大统一的Unicode"><a href="#大统一的Unicode" class="headerlink" title="大统一的Unicode"></a>大统一的Unicode</h1><p>刚刚简单提到了在中日韩这个圈里，每个国家都对 <code>ASCII</code>编码进行了扩充，也就是对 <code>ANSI</code> 编码进行了自己的定义，通常是用两个字节来表示一个文字和符号，这样就出现了一种情况，相同的两个字节在不同的系统上显示了不同的文字，如果每个国家的人只使用自己的语言也是没问题的，但是当中日韩文字混排的时候就出现了问题，这两个字节到底应该转换成中日韩哪个国家的符号呢？</p><p>为了解决这种混乱的局面，大佬们设计了一种名为 <code>Unicode</code> 的字符集，又称万国码或者统一码。Unicode 的诞生是为整合全世界的所有语言文字。理论上任何字符在Unicode中都对应一个值，这个值被称为代码点，通常写成 <code>\uABCD</code> 的格式。</p><h2 id="UCS-4-和-UCS-2"><a href="#UCS-4-和-UCS-2" class="headerlink" title="UCS-4 和 UCS-2"></a>UCS-4 和 UCS-2</h2><p>起初使用两个字节来表示代码点，其取值范围为 \u0000～\uFFFF，这种文字和代码点之间的对应关系被描述为UCS-2，也就是 Universal Character Set Coded in 2 octets 的缩写，最多可以记录65536个字符的代码点。</p><p>后来为了能表示更多的文字，人们又提出了UCS-4，即用四个字节表示代码点。它的范围为 \u00000000～\u7FFFFFFF，其中 \u00000000～\u0000FFFF和UCS-2是一样的。</p><p>从这里可以看出 UCS-4 与 UCS-2 只是一种扩展的关系，UCS-4 是兼容 UCS-2 的，在 UCS-2 的每个代码点加入两个值为0的字节就变成了 UCS-4。</p><h2 id="UCS-2-LE-和-UCS-2-BE"><a href="#UCS-2-LE-和-UCS-2-BE" class="headerlink" title="UCS-2 LE 和 UCS-2 BE"></a>UCS-2 LE 和 UCS-2 BE</h2><p>这里的 <code>LE</code> 和 <code>BE</code> 指的是计算机中常提到的小端字节序和大端字节序，因为 UCS-4 是 UCS-2 的扩展，所以 UCS-4 也存在大端和小端的问题。</p><p>小端字节序，是指数据的高字节保存在内存的高地址中，而数据的低字节保存在内存的低地址中，而大端字节序，是指数据的高字节保存在内存的低地址中，而数据的低字节保存在内存的高地址中，这和我们平时的阅读习惯一致。</p><p>如果没接触过大端和小端可能会有点懵，举个例子就明白了，C++中一个int类型的数字通常占4个字节，假如一个int类型的变量值是256，那么他再内存中是怎样表示的呢？我们知道计算机中除了1就是0，这在计算机中对应一个bit，而计算机中表示数据的单位是字节，每个字节有8个bit大小，那么int变量值 256 翻译成二进制是 <code>00000000 00000000 00000001 00000000</code> 一共占用4个字节。</p><p>对照前面大端和小端的定义，这4个字节在内存中如果从高到低排列，就是小端字节序，如果这4个字节在内存中如果从低到高排列，就是大端字节序。因为UCS-2是两个字节表示一个代码点，所以在表示的时候存在字节排列顺序问题，对于值为 256 的这个代码点，可以是0x0100，也可以是0x0001。</p><h2 id="Unicode-和-UCS-2"><a href="#Unicode-和-UCS-2" class="headerlink" title="Unicode 和 UCS-2"></a>Unicode 和 UCS-2</h2><p>Unicode 是一个字符集，这一点应该很好理解，它表示的是字符和代码点的对应关系，比如简体字“汉”对应的Unicode代码点是 <code>\u6C49</code>，而 UCS-2 究竟是一种字符集还是一种编码方式呢？</p><p>我个人偏向于它是一种编码方式，因为它存在大端、小端这种说法，如果是一种字符集只会考虑对应关系，不会考虑字节序，这只是我个人观点，有些软件上确实是这样标注的，但有些文章也会把UCS-2当成一种字符集，这样也能说的通，不用太纠结这里的区别。</p><p>其实 UCS-2 编码对应的字符集是UCS，这些是历史原因导致的，一方面国际标准化组织（ISO）于1984年创建ISO/IEC JTC1/SC2/WG2工作组，试图制定一份通用字符集（Universal Character Set，简称UCS），并最终制定了ISO 10646标准。<br>而另一方面统一码联盟，也很想做这个统一编码的武林盟主，由Xerox、Apple等软件制造商于1988年组成，并且开发了Unicode标准。</p><p>然后1991年左右，两个项目的参与者都认识到，世界不需要两个不兼容的字符集。于是，它们开始合并双方的工作成果，并为创立一个单一编码表而协同工作。从Unicode 2.0开始，Unicode采用了与ISO 10646-1相同的字库和字码。ISO也承诺，ISO 10646将不会替超出\u10FFFF的UCS-4编码赋值，以使得两者保持一致。两个项目仍都独立存在，并独立地公布各自的标准。不过由于Unicode这一名字名字起的好，比较好记，因而它使用更为广泛。</p><p>从这段历史我们可以看到，虽然 UCS-4 将 UCS-2 从2个字节扩展成了4个字节，但是范围并没到使用到 \u00000000～\uFFFFFFFF，而是将范围集中到 \u000000～\u10FFFF 内，保证了 UCS 和 Unicode 各个字符代码点的统一，也奠定了UTF-8实现标准Unicode时最多需要4个字节的基础。</p><h1 id="UTF-8-的诞生"><a href="#UTF-8-的诞生" class="headerlink" title="UTF-8 的诞生"></a>UTF-8 的诞生</h1><p>按理说 Unicode 已经给世界范围内的所有字符定义了代码点，无论是什么字符，使用4个字节都能表示出来，为什么要搞出一个UTF-8呢？是因为使用者发现，对于ASCII码范围内的字符，本来1个字节就能正确表示，现在居然要4个字节表示，即使使用 UCS-2编码，占用的空间也扩大了1倍，有些太浪费了。</p><p>为了解决这种空间浪费问题，就出现了一类变长的通用转换格式，即UTF（Universal Transformation Format），常见的UTF格式有：UTF-7，UTF-7.5，UTF-8，UTF-16 以及 UTF-32。</p><p>这类格式中最常见的就是 UTF-8 编码了，UTF-8 是针对于 Unicode 字符集中各个代码点的编码方式，是一种 Unicode 字符的实现方式，采用变长字节来表示Unicode编码，最长使用4个字节来表示标准的Unicode代码点，在有些资料中可能会看到5、6个字节的编码方式，这些都是非标准的Unicode代码点，根据规范，这些字节值将无法出现在合法 UTF-8序列中。</p><h2 id="Unicode-和-UTF-8"><a href="#Unicode-和-UTF-8" class="headerlink" title="Unicode 和 UTF-8"></a>Unicode 和 UTF-8</h2><p>UTF-8在对标准Unicode字符编码时最多使用4个字节，其代码点范围与UTF-8编码后的形式对应如下：</p><table><thead><tr><th style="text-align:center"><strong>Unicode/UCS-4</strong>（十六进制）</th><th style="text-align:center">字节数</th><th style="text-align:left">UTF-8编码格式（二进制）</th></tr></thead><tbody><tr><td style="text-align:center">000000-00007F</td><td style="text-align:center">1</td><td style="text-align:left">0xxxxxxx</td></tr><tr><td style="text-align:center">000080-0007FF</td><td style="text-align:center">2</td><td style="text-align:left">110xxxxx 10xxxxxx</td></tr><tr><td style="text-align:center">000800-00FFFF</td><td style="text-align:center">3</td><td style="text-align:left">1110xxxx 10xxxxxx 10xxxxxx</td></tr><tr><td style="text-align:center">010000-10FFFF</td><td style="text-align:center">4</td><td style="text-align:left">11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</td></tr></tbody></table><h2 id="UTF-8编码示例"><a href="#UTF-8编码示例" class="headerlink" title="UTF-8编码示例"></a>UTF-8编码示例</h2><p>只看上面这种对应关系，可能还不太清楚是怎样表示，接下来可以举一个例子试一下，比如一个常用的简体中文字——“好”，查询它的Unicode代码点是 <code>\u597D</code>，对照上面的表格发现在 000800-00FFFF 这个范围，应该采用3个字节的表现形式。</p><p>先把这个数值翻译成二进制为 <code>0101100101111101</code>，然后按照3个字节的形式分成3组，<code>0101</code>、<code>100101</code> 和 <code>111101</code>，把这些内容天填充到xxx这样的空位中就得到了“好”这个字的UTF-8编码—— <code>11100101 10100101 10111101</code>，表示成十六进制就是 <code>0xE5A5BD</code>。</p><p>这个过程还是比较简单的，其他编码要转换成UTF-8编码都要经过Unicode这一步中转，先通过转换表查到其他编码对应字符的Unicode编码，然后再转换成UTF-8的表示格式。</p><h2 id="优点和缺点"><a href="#优点和缺点" class="headerlink" title="优点和缺点"></a>优点和缺点</h2><p>根据 UTF-8 的编码规则，任何一个 byte 漏传，多传，传错只影响当前字符，前后字符都不受影响，而 Unicode 如果从一个字的中间截断会导致接下来所有的字符解析都是错的，这使得UTF-8编码的数据在不够可靠的网络传输中是有利的。</p><p>兼容ASCII，并且是字节顺序无关的。它的字节顺序在所有系统中都是一样的，因此它实际上并不需要BOM，不过在文件开头常常保存 0xEFBBBF 三个字节来表明文件编码是UTF-8。</p><p>缺点是因为UTF-8是一种变长编码，无法从直接从Unicode字符直接判断出UTF-8文本的字节数。除了ASCII字符集内的字符，其他情况实际上都增加了固定的头数据，占用了无效空间。</p><h1 id="编码和解码在编程中的应用"><a href="#编码和解码在编程中的应用" class="headerlink" title="编码和解码在编程中的应用"></a>编码和解码在编程中的应用</h1><p>编码和解码在网站页面和数据库存储时用的非常多，一不小心就搞出一堆乱码，这种编码和解码操作在Python3中很直观，Python2中 string 和 bytes 混合在一起，编码和解码操作不太明显，而在python3中 string 和 bytes 是完全不同的两个类型，string编码成bytes，而bytes解码成string。</p><p>相比于python3中的编码、解码对应两个类型，C++中的编码和解码操作的前后都是字符串，这在一定程度上会给人造成误解，接下来我们使用Python3来简单测试一下编码和解码操作。</p><h2 id="编码操作"><a href="#编码操作" class="headerlink" title="编码操作"></a>编码操作</h2><p>编码通常是把人类可以理解的字符转换成计算机可以认识二进制数据，这个过程在python3中对应的是把string转化成bytes，测试如下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">word = <span class="string">'好好'</span></span><br><span class="line">print(type(word), word)</span><br><span class="line"></span><br><span class="line">result = word.encode(<span class="string">'utf-8'</span>)</span><br><span class="line">print(type(result), result)</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;class &apos;str&apos;&gt; 好好</span><br><span class="line">&lt;class &apos;bytes&apos;&gt; b&apos;\xe5\xa5\xbd\xe5\xa5\xbd&apos;</span><br></pre></td></tr></table></figure><h2 id="解码操作"><a href="#解码操作" class="headerlink" title="解码操作"></a>解码操作</h2><p>解码操作通常是把计算机中存储和传输的数据转换成人类能看懂的字符，这个过程在python3中对应的是把bytes转化成string，测试如下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">data = <span class="string">b'\xe5\xa5\xbd\xe5\xa5\xbd'</span></span><br><span class="line">print(type(data), data)</span><br><span class="line"></span><br><span class="line">result = data.decode(<span class="string">'utf-8'</span>)</span><br><span class="line">print(type(result), result)</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;class &apos;bytes&apos;&gt; b&apos;\xe5\xa5\xbd\xe5\xa5\xbd&apos;</span><br><span class="line">&lt;class &apos;str&apos;&gt; 好好</span><br></pre></td></tr></table></figure><h2 id="乱码产生"><a href="#乱码产生" class="headerlink" title="乱码产生"></a>乱码产生</h2><p>从上面的两个例子来看编码和解码非常简单，那怎么还能出现乱码呢？计算机说到底还是一种工具，你在把可见字符编码后交给计算机存储和传输时，你要记住这些二进制的编码方式，在你想看这些数据时还要用相反的方式进行解码，否则就会出现乱码，比如下面这种使用 utf-8 编码，却使用 gbk 这种方式来解码，就得不到你想要的数据。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">word = <span class="string">'好好'</span></span><br><span class="line">print(type(word), word)</span><br><span class="line"></span><br><span class="line">result = word.encode(<span class="string">'utf-8'</span>)</span><br><span class="line">print(type(result), result)</span><br><span class="line"></span><br><span class="line">new_word = result.decode(<span class="string">'gbk'</span>)</span><br><span class="line">print(type(new_word), new_word)</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;class &apos;str&apos;&gt; 好好</span><br><span class="line">&lt;class &apos;bytes&apos;&gt; b&apos;\xe5\xa5\xbd\xe5\xa5\xbd&apos;</span><br><span class="line">&lt;class &apos;str&apos;&gt; 濂藉ソ</span><br></pre></td></tr></table></figure><p>虽然结果是可以看得见的字符，但是这不是我们想要的数据，所以 <code>濂藉ソ</code> 对于我们来说也是一种乱码，在处理字符编码时我们必须清楚知道要用什么方式来进行编码和解码，如果编码和解码的方式不一致，那么就会产生乱码现象。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li><code>Unicode</code> 是一种字符集，描述了人类范围内用于交流的所有字符的代码点，给与唯一的数字进行对应</li><li><code>Unicode</code> 规定的代码点范围是 \u000000-\u10FFFF，这与 UCS-4 规定的范围达成了统一，共定义了17个Plan</li><li><code>UTF-8</code> 是Unicode字符集的一种实现，采用变长的方式，标准规范最多使用4个字节表示一个Unicode字符</li><li>编码是为了把人类用来交流的字符转换成二进制数据便于存储和传输</li><li>解码是为了把存储在计算机中的二进制数据转换成人们能看得懂的字符</li><li>编码和解码不一致时就会造成乱码，比如使用UTF-8编码，使用GBK来解码就会造成乱码现象</li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/109976348" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>对未知的事物充满恐惧，过于保守的看待当下的一切，有时候太稳反而会失去很多~</p><p>2020-11-29 19:23:13</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;在程序员生活的01世界中有两大Boss级难题，分别是缓存失效和命名问题，对比这两大难题来说，编码和解码只能算是小妖儿了，只不过这两个小妖儿出镜率很高，有时确实很磨人的，得多花些时间捋顺一下。&lt;/p&gt;
    
    </summary>
    
      <category term="Thinking" scheme="http://AlbertGithubHome.github.io/blog/categories/Thinking/"/>
    
    
      <category term="Python" scheme="http://AlbertGithubHome.github.io/blog/tags/Python/"/>
    
      <category term="编码" scheme="http://AlbertGithubHome.github.io/blog/tags/%E7%BC%96%E7%A0%81/"/>
    
      <category term="解码" scheme="http://AlbertGithubHome.github.io/blog/tags/%E8%A7%A3%E7%A0%81/"/>
    
      <category term="encode" scheme="http://AlbertGithubHome.github.io/blog/tags/encode/"/>
    
      <category term="decode" scheme="http://AlbertGithubHome.github.io/blog/tags/decode/"/>
    
  </entry>
  
  <entry>
    <title>linux环境下使用netstat命令查看网络信息</title>
    <link href="http://AlbertGithubHome.github.io/blog/2020/11/22/linux%E7%8E%AF%E5%A2%83%E4%B8%8B%E4%BD%BF%E7%94%A8netstat%E5%91%BD%E4%BB%A4%E6%9F%A5%E7%9C%8B%E7%BD%91%E7%BB%9C%E4%BF%A1%E6%81%AF/"/>
    <id>http://AlbertGithubHome.github.io/blog/2020/11/22/linux环境下使用netstat命令查看网络信息/</id>
    <published>2020-11-22T15:05:55.000Z</published>
    <updated>2021-02-21T15:17:30.019Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><code>netstat</code> 这个命令一直以为是 net status 的缩写，今天一查发现并没有找到官方的这种说法，然后参考了 man 手册，发现这个词更像是 net statistics 的缩写，命令的作用是显示网络连接、路由表、接口连接、无效连接和多播成员关系的，man 手册中描述这个命令如下：</p><a id="more"></a><blockquote><p>netstat - Print network connections, routing tables, interface statistics, masquerade connections, and multicast memberships</p></blockquote><p>这个命令很强大，但是我经常使用的参数很简单，通常用来查询端口占用问题，命令为 <code>netstat -anp | grep xxxPORT</code>，因为在我测试自己项目程序的时候，总有一些进程企图占用我使用的端口，比如那个 被我 kill 了 n 次的 TIM 客户端，使用 netstat 可以方便的找到是哪个进程占用了你的端口。</p><p>虽然这个命令经常使用，但是其中的这些参数含义却不是很清楚，所以特地总结一下，综合其他常见的用法，记录下来以备后续查找使用。</p><h1 id="参数选项"><a href="#参数选项" class="headerlink" title="参数选项"></a>参数选项</h1><ul><li><strong>-a</strong>：显示所有连接，包括 LISTEN 状态的连接</li><li><strong>-l</strong>：仅显示 LISTEN 状态的连接</li><li><strong>-t</strong>：仅显示tcp相关选项</li><li><strong>-u</strong>：仅显示udp相关选项</li><li><strong>-n</strong>：拒绝显示别名，能显示数字的全部转化成数字</li><li><strong>-o</strong>：显示信息中包括与网络计时器相关的信息</li><li><strong>-e</strong>：显示扩展信息，例如uid等</li><li><strong>-p</strong>：显示建立相关链接的程序名</li><li><strong>-r</strong>：显示路由信息，路由表</li><li><strong>-s</strong>：按各个协议进行统计</li><li><strong>-c</strong>：每隔一个固定时间，执行该netstat命令。</li></ul><h1 id="无参数执行"><a href="#无参数执行" class="headerlink" title="无参数执行"></a>无参数执行</h1><p>该命令无参数执行时显示数据会少一些，便于我们看清命令执行的结果，内容如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[root@node1 ~]<span class="comment"># netstat</span></span><br><span class="line">Active Internet connections (w/o servers)</span><br><span class="line">Proto Recv-Q Send-Q Local Address           Foreign Address         State</span><br><span class="line">tcp        0      0 192.168.0.201:ssh       178.129.126.124.b:19450 ESTABLISHED</span><br><span class="line">tcp        0     52 192.168.0.201:ssh       178.129.126.124.b:17626 ESTABLISHED</span><br><span class="line">tcp        0      0 192.168.0.201:57784     101.200.35.175:https    TIME_WAIT</span><br><span class="line">tcp        0      0 192.168.0.201:42298     100.125.2.72:https      ESTABLISHED</span><br><span class="line">Active UNIX domain sockets (w/o servers)</span><br><span class="line">Proto RefCnt Flags       Type       State         I-Node   Path</span><br><span class="line">unix  2      [ ]         DGRAM                    11550    /run/systemd/shutdownd</span><br><span class="line">unix  2      [ ]         DGRAM                    13355412 /var/run/chrony/chronyd.sock</span><br><span class="line">unix  3      [ ]         DGRAM                    1228     /run/systemd/notify</span><br><span class="line">unix  2      [ ]         DGRAM                    1230     /run/systemd/cgroups-agent</span><br><span class="line">unix  5      [ ]         DGRAM                    1241     /run/systemd/journal/socket</span><br><span class="line">unix  16     [ ]         DGRAM                    1243     /dev/<span class="built_in">log</span></span><br><span class="line">unix  3      [ ]         STREAM     CONNECTED     15663</span><br><span class="line">unix  3      [ ]         STREAM     CONNECTED     15662</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>输出结果可以分为 <code>Active Internet connections</code> 和 <code>Active UNIX domain sockets</code> 两个部分：</p><p>Active Internet connections 指有效的网络连接，默认显示6列内容：</p><ul><li>Proto：协议名字，包括tcp, udp, udpl, raw等</li><li>Recv-Q：表示网络接收队列，表示收到的数据已经在本地接收缓冲，还有多少没有被应用程序取走</li><li>Send-Q：表示网络发送队列，表示存在本地缓冲区，但对方没有收到的数据或者没有 ACK 的</li><li>Local Address：本地IP地址和端口</li><li>Foreign Address：外部IP地址和端口</li><li>State：网络连接状态，包括 ESTABLISHED、SYN_SENT、SYN_RECV、FIN_WAIT1、FIN_WAIT2、TIME_WAIT、CLOSE、CLOSE_WAIT、LAST_ACK、LISTEN、CLOSING、UNKNOWN 等状态</li></ul><p>Active UNIX domain sockets 是指本地套接口，我们知道 socket 也可用于同一台主机的进程间（IPC）通讯，但是 socket 用于IPC更有效率：不需要经过网络协议栈，不需要打包拆包、计算校验和、维护序号和应答等，只是将应用层数据从一个进程拷贝到另一个进程<br>并且它是是全双工的，API接口语义丰富，相比其它进程间通信机制有明显的优越性。</p><h1 id="常用命令组合"><a href="#常用命令组合" class="headerlink" title="常用命令组合"></a>常用命令组合</h1><h2 id="查询端口占用"><a href="#查询端口占用" class="headerlink" title="查询端口占用"></a>查询端口占用</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@node1 /]<span class="comment"># netstat -anp | grep 8889</span></span><br><span class="line">tcp        0      0 0.0.0.0:8889            0.0.0.0:*               LISTEN      27584/tinyproxy</span><br></pre></td></tr></table></figure><p>这是我目前最常用的命令，在windows可以改为 <code>netstat -ano | findstr 8889</code></p><h2 id="显示tcp连接"><a href="#显示tcp连接" class="headerlink" title="显示tcp连接"></a>显示tcp连接</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@node1 /]<span class="comment"># netstat -at</span></span><br><span class="line">Active Internet connections (servers and established)</span><br><span class="line">Proto Recv-Q Send-Q Local Address           Foreign Address         State</span><br><span class="line">tcp        0      0 0.0.0.0:ddi-tcp-2       0.0.0.0:*               LISTEN</span><br><span class="line">tcp        0      0 localhost:smtp          0.0.0.0:*               LISTEN</span><br><span class="line">tcp        0      0 0.0.0.0:ssh             0.0.0.0:*               LISTEN</span><br><span class="line">tcp        0     52 192.168.0.201:ssh       178.129.126.124.b:19450 ESTABLISHED</span><br><span class="line">tcp        0      0 192.168.0.201:ssh       178.129.126.124.b:17626 ESTABLISHED</span><br><span class="line">tcp        0      0 192.168.0.201:42298     100.125.2.72:https      ESTABLISHED</span><br><span class="line">tcp6       0      0 [::]:squid              [::]:*                  LISTEN</span><br><span class="line">tcp6       0      0 localhost:smtp          [::]:*                  LISTEN</span><br><span class="line">tcp6       0      0 [::]:ssh                [::]:*                  LISTEN</span><br></pre></td></tr></table></figure><h2 id="显示处于-LISTEN-状态的端口"><a href="#显示处于-LISTEN-状态的端口" class="headerlink" title="显示处于 LISTEN 状态的端口"></a>显示处于 LISTEN 状态的端口</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[root@node1 /]<span class="comment"># netstat -l</span></span><br><span class="line">Active Internet connections (only servers)</span><br><span class="line">Proto Recv-Q Send-Q Local Address           Foreign Address         State</span><br><span class="line">tcp        0      0 0.0.0.0:ddi-tcp-2       0.0.0.0:*               LISTEN</span><br><span class="line">tcp        0      0 localhost:smtp          0.0.0.0:*               LISTEN</span><br><span class="line">tcp        0      0 0.0.0.0:ssh             0.0.0.0:*               LISTEN</span><br><span class="line">tcp6       0      0 [::]:squid              [::]:*                  LISTEN</span><br><span class="line">tcp6       0      0 localhost:smtp          [::]:*                  LISTEN</span><br><span class="line">tcp6       0      0 [::]:ssh                [::]:*                  LISTEN</span><br><span class="line">udp        0      0 0.0.0.0:bootpc          0.0.0.0:*</span><br><span class="line">udp        0      0 0.0.0.0:ntp             0.0.0.0:*</span><br><span class="line">udp        0      0 localhost:323           0.0.0.0:*</span><br><span class="line">udp        0      0 0.0.0.0:56034           0.0.0.0:*</span><br><span class="line">udp6       0      0 [::]:42035              [::]:*</span><br><span class="line">udp6       0      0 localhost:323           [::]:*</span><br><span class="line">Active UNIX domain sockets (only servers)</span><br><span class="line">Proto RefCnt Flags       Type       State         I-Node   Path</span><br><span class="line">unix  2      [ ACC ]     STREAM     LISTENING     11533    /run/lvm/lvmpolld.socket</span><br><span class="line">unix  2      [ ACC ]     STREAM     LISTENING     6848304  /var/run/rpcbind.sock</span><br><span class="line">unix  2      [ ACC ]     STREAM     LISTENING     11584    /run/lvm/lvmetad.socket</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h2 id="分类统计每种协议的信息"><a href="#分类统计每种协议的信息" class="headerlink" title="分类统计每种协议的信息"></a>分类统计每种协议的信息</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">[root@node1 /]<span class="comment"># netstat -s</span></span><br><span class="line">Ip:</span><br><span class="line">    7902622 total packets received</span><br><span class="line">    60675 forwarded</span><br><span class="line">    127 with unknown protocol</span><br><span class="line">    0 incoming packets discarded</span><br><span class="line">    7841813 incoming packets delivered</span><br><span class="line">    7270606 requests sent out</span><br><span class="line">    8 dropped because of missing route</span><br><span class="line">Icmp:</span><br><span class="line">    928210 ICMP messages received</span><br><span class="line">    25426 input ICMP message failed.</span><br><span class="line">    InCsumErrors: 8</span><br><span class="line">    ICMP input histogram:</span><br><span class="line">        destination unreachable: 71154</span><br><span class="line">        timeout <span class="keyword">in</span> transit: 484</span><br><span class="line">        <span class="built_in">echo</span> requests: 856165</span><br><span class="line">        <span class="built_in">echo</span> replies: 337</span><br><span class="line">        timestamp request: 54</span><br><span class="line">    896502 ICMP messages sent</span><br><span class="line">    0 ICMP messages failed</span><br><span class="line">    ICMP output histogram:</span><br><span class="line">        destination unreachable: 40039</span><br><span class="line">        <span class="built_in">echo</span> request: 244</span><br><span class="line">        <span class="built_in">echo</span> replies: 856165</span><br><span class="line">        timestamp replies: 54</span><br><span class="line">Tcp:</span><br><span class="line">    274517 active connections openings</span><br><span class="line">    66347 passive connection openings</span><br><span class="line">    187800 failed connection attempts</span><br><span class="line">    90950 connection resets received</span><br><span class="line">    3 connections established</span><br><span class="line">    6359177 segments received</span><br><span class="line">    5808198 segments send out</span><br><span class="line">    494062 segments retransmited</span><br><span class="line">    4 bad segments received.</span><br><span class="line">    452720 resets sent</span><br><span class="line">Udp:</span><br><span class="line">    539313 packets received</span><br><span class="line">    14902 packets to unknown port received.</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h2 id="每秒显示一次信息"><a href="#每秒显示一次信息" class="headerlink" title="每秒显示一次信息"></a>每秒显示一次信息</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@node1 /]<span class="comment"># netstat -c</span></span><br><span class="line">Active Internet connections (w/o servers)</span><br><span class="line">Proto Recv-Q Send-Q Local Address           Foreign Address         State</span><br><span class="line">tcp        0     52 192.168.0.201:ssh       178.129.126.124.b:19450 ESTABLISHED</span><br><span class="line">tcp        0      0 192.168.0.201:ssh       178.129.126.124.b:17626 ESTABLISHED</span><br><span class="line">tcp        0      0 192.168.0.201:42298     100.125.2.72:https      ESTABLISHED</span><br><span class="line">Active UNIX domain sockets (w/o servers)</span><br><span class="line">Proto RefCnt Flags       Type       State         I-Node   Path</span><br><span class="line">unix  2      [ ]         DGRAM                    11550    /run/systemd/shutdownd</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h2 id="显示核心路由信息"><a href="#显示核心路由信息" class="headerlink" title="显示核心路由信息"></a>显示核心路由信息</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@node1 /]<span class="comment"># netstat -r</span></span><br><span class="line">Kernel IP routing table</span><br><span class="line">Destination     Gateway         Genmask         Flags   MSS Window  irtt Iface</span><br><span class="line">default         192.168.0.1     0.0.0.0         UG        0 0          0 eth0</span><br><span class="line">169.254.169.254 192.168.0.254   255.255.255.255 UGH       0 0          0 eth0</span><br><span class="line">172.17.0.0      0.0.0.0         255.255.0.0     U         0 0          0 docker0</span><br><span class="line">192.168.0.0     0.0.0.0         255.255.255.0   U         0 0          0 eth0</span><br></pre></td></tr></table></figure><h2 id="显示网络接口列表"><a href="#显示网络接口列表" class="headerlink" title="显示网络接口列表"></a>显示网络接口列表</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@node1 /]<span class="comment"># netstat -i</span></span><br><span class="line">Kernel Interface table</span><br><span class="line">Iface             MTU    RX-OK RX-ERR RX-DRP RX-OVR    TX-OK TX-ERR TX-DRP TX-OVR Flg</span><br><span class="line">docker0          1500    36248      0      0 0         33647      0      0      0 BMU</span><br><span class="line">eth0             1500  9119246      0      0 0       8277212      0      0      0 BMRU</span><br><span class="line">lo              65536    27700      0      0 0         27700      0      0      0 LRU</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li><code>netstat -anp | grep 8889</code> 命令可用于查询8889端口被哪个进程占用了，在Windows上翻译为 <code>netstat -ano | findstr 8889</code></li><li>netstat 命令查询出的网络连接信息中，<code>Recv-Q</code> 和 <code>Send-Q</code> 通常应该为0，如果长时间不为0可能是有问题的，需要尽快排查</li><li>如果 <code>Recv-Q</code> 数值一直处于不为0的状态，可能是遭受了拒绝服务 DOS 攻击，导致本地消息处理过慢</li><li>如果 <code>Send-Q</code> 数值一直处于不为0的状态，可能是有应用向外发送数据包过快，或者是对方接收处理数据包不够快</li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/109712347" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>以史为鉴可以知兴替，以铜为鉴可以正衣冠，以人为鉴可以明得失。人的成长需要对比，总有人比你更加优秀~</p><p>2020-11-23 01:17:59</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&lt;code&gt;netstat&lt;/code&gt; 这个命令一直以为是 net status 的缩写，今天一查发现并没有找到官方的这种说法，然后参考了 man 手册，发现这个词更像是 net statistics 的缩写，命令的作用是显示网络连接、路由表、接口连接、无效连接和多播成员关系的，man 手册中描述这个命令如下：&lt;/p&gt;
    
    </summary>
    
      <category term="linux" scheme="http://AlbertGithubHome.github.io/blog/categories/linux/"/>
    
    
      <category term="排序" scheme="http://AlbertGithubHome.github.io/blog/tags/%E6%8E%92%E5%BA%8F/"/>
    
      <category term="linux" scheme="http://AlbertGithubHome.github.io/blog/tags/linux/"/>
    
      <category term="sort" scheme="http://AlbertGithubHome.github.io/blog/tags/sort/"/>
    
  </entry>
  
  <entry>
    <title>学习cmake从成功编译一个小程序开始</title>
    <link href="http://AlbertGithubHome.github.io/blog/2020/11/14/%E5%AD%A6%E4%B9%A0cmake%E4%BB%8E%E6%88%90%E5%8A%9F%E7%BC%96%E8%AF%91%E4%B8%80%E4%B8%AA%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%A7%8B/"/>
    <id>http://AlbertGithubHome.github.io/blog/2020/11/14/学习cmake从成功编译一个小程序开始/</id>
    <published>2020-11-14T15:59:17.000Z</published>
    <updated>2020-12-27T12:40:05.821Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在 Windows上开发我使用最多的IDE还是 Visual Studio，编写、编译一条龙服务，导致了不少编译流程知识的缺失，这种大型的IDE确实好用，诸多配置通过在界面上勾选一下就可以了，但是在编译细节的掌握上还是漏掉了一些知识。</p><a id="more"></a><p>在 linux 开发环境下通常会使用 gcc 或者 g++ 进行编译，可是编译选项有点多，当工程非常大的时候需要写的编译参数太多了，这时可以使用make命令来帮助我们编译 C++ 程序，编译时依赖一些规则，这些规则就写在一个叫 Makefile 的文件中。</p><p>后来发现写 Makefile 还是太麻烦了，这个文件也相当大。于是“懒惰”的程序员们又开发出了各种各样的工具用来生成 Makefile 文件，我使用过的目前就只有 <code>automake</code> 和 <code>cmake</code>。</p><h1 id="生成Makefile"><a href="#生成Makefile" class="headerlink" title="生成Makefile"></a>生成Makefile</h1><p>之前使用的生成 Makefile 文件的工具是 <code>automake</code>，被称为是“八股文”一样的操作，每次操作都是固定的几个步骤，比如每次都要运行 <code>autoscan</code>、<code>aclocal</code>、<code>autoconf</code>、<code>automake</code>、<code>./confiugre</code>等命令，需要个人发挥的地方并不多，之前使用的时候也不是完全从0开始一点点写的，往往是写一个项目模板之后，对照着在Makefile.am文件中修改几个参数就好了。</p><p>现在新的工作内容中使用 cmake 来生成 Makefile，这个 cmake 之前还确实接触过一些，大概是2012年的时候，那时在编译 OpenCV 库还有增强现实插件的时候用过几次，当时感觉安装起来太麻烦了，对那个红绿蓝的图标记忆犹新，感觉和当时的新闻联播的图标有些亲戚关系。</p><p>其实当时根本分不清什么是编译器，什么是 Makefile，对于各种库文件的编译完全是按照文档来操作，现在回过头来看看 cmake 生成 Makefile 还是比较简单的，最起码要比 automake 省了很多步骤，只要编写一个 CMakeLists.txt 文件就好了。</p><h1 id="编写CMakeLists-txt生成Makefile"><a href="#编写CMakeLists-txt生成Makefile" class="headerlink" title="编写CMakeLists.txt生成Makefile"></a>编写CMakeLists.txt生成Makefile</h1><p>为了练习使用编写CMakeLists.txt生成Makefile，进而编译C++项目，我们可以从头来实现一个小例子，目标是编写一个计算加法的静态库和一个计算减法静态库，然后实现一个测试工程来使用这两个函数库，整个工程使用 cmake 来生成 Makefile，然后使用 make 命令完成编译。</p><h2 id="实现简单的代码文件"><a href="#实现简单的代码文件" class="headerlink" title="实现简单的代码文件"></a>实现简单的代码文件</h2><p>加法和减法都是常用的简单计算，用来举例子很容易理解，接下来展示要用到的几个文件内容，每个文件只有几行，只为了说明问题，文件内容如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//myadd.h</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//myadd.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"myadd.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//mysub.h</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sub</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//mysub.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mysub.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sub</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a - b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//test.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"myadd.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mysub.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"happy birthday!"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"519 + 1 = "</span> &lt;&lt; add(<span class="number">519</span>, <span class="number">1</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"1320 - 6 = "</span> &lt;&lt; sub(<span class="number">1320</span>, <span class="number">6</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用常规方法编译"><a href="#使用常规方法编译" class="headerlink" title="使用常规方法编译"></a>使用常规方法编译</h2><p>首先使用最简单 g++ 命令来编译这个样例程序：</p><ol><li>查看目录下文件</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:testcmake$ ls</span><br><span class="line">myadd.cpp  myadd.h  mysub.cpp  mysub.h  test.cpp</span><br></pre></td></tr></table></figure><ol><li>将 <code>myadd.h</code> 和 <code>myadd.cpp</code> 编译成静态库 <code>libmyadd.a</code></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:testcmake$ g++ -c myadd.cpp</span><br><span class="line">albert@home-pc:testcmake$ ar crv libmyadd.a myadd.o</span><br><span class="line">a - myadd.o</span><br><span class="line">albert@home-pc:testcmake$ ls</span><br><span class="line">libmyadd.a  myadd.cpp  myadd.h  myadd.o  mysub.cpp  mysub.h  test.cpp</span><br></pre></td></tr></table></figure><ol><li>将 <code>mysub.h</code> 和 <code>mysub.cpp</code> 编译成静态库 <code>libmysub.so</code></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:testcmake$ g++ -c mysub.cpp</span><br><span class="line">albert@home-pc:testcmake$ g++ -shared -fPIC -o libmysub.so mysub.o</span><br><span class="line">albert@home-pc:testcmake$ ls</span><br><span class="line">libmyadd.a  libmysub.so  myadd.cpp  myadd.h  myadd.o  mysub.cpp  mysub.h  mysub.o  test.cpp</span><br></pre></td></tr></table></figure><ol><li>编译链接静态库 <code>libmyadd.a</code>、动态库 <code>libmysub.so</code> 和测试文件生成可执行程序 <code>test</code></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:testcmake$ g++ test.cpp libmyadd.a -L. -lmysub -o <span class="built_in">test</span> -Wl,-rpath=.</span><br><span class="line">albert@home-pc:testcmake$ ls</span><br><span class="line">libmyadd.a  libmysub.so  myadd.cpp  myadd.h  myadd.o  mysub.cpp  mysub.h  mysub.o  <span class="built_in">test</span>  test.cpp</span><br></pre></td></tr></table></figure><ol><li>运行查看结果，成功计算表达式的值</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:testcmake$ ./<span class="built_in">test</span></span><br><span class="line">happy birthday!</span><br><span class="line">519 + 1 = 520</span><br><span class="line">1320 - 6 = 1314</span><br></pre></td></tr></table></figure><h2 id="使用cmake方式"><a href="#使用cmake方式" class="headerlink" title="使用cmake方式"></a>使用cmake方式</h2><p>上面展示了最原始的编译方法，每次都要敲这些命令，接下来编写一个 CMakeLists 文件，使用 cmake 生成Makefile，以后只要运行 make 命令就可以完成编译了。</p><p>调整一下目录结构如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:testcmake$ tree</span><br><span class="line">.</span><br><span class="line">|-- myadd</span><br><span class="line">|   |-- myadd.cpp</span><br><span class="line">|   `-- myadd.h</span><br><span class="line">|-- mysub</span><br><span class="line">|   |-- mysub.cpp</span><br><span class="line">|   `-- mysub.h</span><br><span class="line">`-- test.cpp</span><br></pre></td></tr></table></figure><ol><li>进入 myadd 目录新建 CMakeLists.txt 编写内容如下：</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">aux_source_directory(. SRC_LIST)        <span class="comment">#将此目录的源文件集合设置为变量SRC_LIST</span></span><br><span class="line">add_library(myadd STATIC <span class="variable">$&#123;SRC_LIST&#125;</span>)   <span class="comment">#库的名称，库的类型，静态库的源文件列表</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span>(LIBRARY_OUTPUT_PATH <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/lib)  <span class="comment">#库的输出路径为根目录下的lib文件夹</span></span><br></pre></td></tr></table></figure><ol><li>进入 mysub 目录新建 CMakeLists.txt 编写内容如下：</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">aux_source_directory(. SRC_LIST)        <span class="comment">#将此目录的源文件集合设置为变量SRC_LIST</span></span><br><span class="line">add_library(mysub SHARED <span class="variable">$&#123;SRC_LIST&#125;</span>)   <span class="comment">#库的名称，库的类型，动态库的源文件列表</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span>(LIBRARY_OUTPUT_PATH <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/lib)  <span class="comment">#库的输出路径为根目录下的lib文件夹</span></span><br></pre></td></tr></table></figure><ol><li>在工程主目录下新建 CMakeLists.txt 编写内容如下：</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 指定cmake版本</span></span><br><span class="line">cmake_minimum_required(VERSION 3.5)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定项目的名称，一般和项目的文件夹名称对应</span></span><br><span class="line">project(testcmake)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定子目录</span></span><br><span class="line">add_subdirectory(myadd)</span><br><span class="line">add_subdirectory(mysub)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加c++ 11标准支持</span></span><br><span class="line"><span class="built_in">set</span>(CMAKE_CXX_FLAGS <span class="string">"-std=c++11"</span> )</span><br><span class="line"></span><br><span class="line"><span class="comment"># 特殊宏，之前编译mysqlcppconn8用到过</span></span><br><span class="line">add_definitions(-DGLIBCXX_USE_CXX11_ABI)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 头文件目录</span></span><br><span class="line">include_directories(myadd mysub)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 源文件目录</span></span><br><span class="line">aux_source_directory(. DIR_SRCS)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置环境变量，编译用到的源文件全部都要放到这</span></span><br><span class="line"><span class="built_in">set</span>(TEST_MATH <span class="variable">$&#123;DIR_SRCS&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 库文件目录</span></span><br><span class="line">link_directories(lib)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加要编译的可执行文件</span></span><br><span class="line">add_executable(<span class="variable">$&#123;PROJECT_NAME&#125;</span> <span class="variable">$&#123;TEST_MATH&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加可执行文件所需要的库</span></span><br><span class="line">target_link_libraries(<span class="variable">$&#123;PROJECT_NAME&#125;</span> myadd)</span><br><span class="line">target_link_libraries(<span class="variable">$&#123;PROJECT_NAME&#125;</span> mysub)</span><br></pre></td></tr></table></figure><ol><li>新建build目录和lib目录，整个工程目录关系如下：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:testcmake$ tree</span><br><span class="line">.</span><br><span class="line">|-- CMakeLists.txt</span><br><span class="line">|-- build</span><br><span class="line">|-- lib</span><br><span class="line">|-- myadd</span><br><span class="line">|   |-- CMakeLists.txt</span><br><span class="line">|   |-- myadd.cpp</span><br><span class="line">|   `-- myadd.h</span><br><span class="line">|-- mysub</span><br><span class="line">|   |-- CMakeLists.txt</span><br><span class="line">|   |-- mysub.cpp</span><br><span class="line">|   `-- mysub.h</span><br><span class="line">`-- test.cpp</span><br><span class="line"></span><br><span class="line">4 directories, 8 files</span><br></pre></td></tr></table></figure><ol><li>进入 build 目录下依次运行 <code>cmake ..</code> 和 <code>make</code> 命令</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:testcmake/build$ cmake ..</span><br><span class="line">-- The C compiler identification is GNU 5.4.0</span><br><span class="line">-- The CXX compiler identification is GNU 5.4.0</span><br><span class="line">-- Check <span class="keyword">for</span> working C compiler: /usr/bin/cc</span><br><span class="line">-- Check <span class="keyword">for</span> working C compiler: /usr/bin/cc -- works</span><br><span class="line">-- Detecting C compiler ABI info</span><br><span class="line">-- Detecting C compiler ABI info - <span class="keyword">done</span></span><br><span class="line">-- Detecting C compile features</span><br><span class="line">-- Detecting C compile features - <span class="keyword">done</span></span><br><span class="line">-- Check <span class="keyword">for</span> working CXX compiler: /usr/bin/c++</span><br><span class="line">-- Check <span class="keyword">for</span> working CXX compiler: /usr/bin/c++ -- works</span><br><span class="line">-- Detecting CXX compiler ABI info</span><br><span class="line">-- Detecting CXX compiler ABI info - <span class="keyword">done</span></span><br><span class="line">-- Detecting CXX compile features</span><br><span class="line">-- Detecting CXX compile features - <span class="keyword">done</span></span><br><span class="line">-- Configuring <span class="keyword">done</span></span><br><span class="line">-- Generating <span class="keyword">done</span></span><br><span class="line">-- Build files have been written to: testcmake/build</span><br><span class="line">albert@home-pc:testcmake/build$ make</span><br><span class="line">Scanning dependencies of target mysub</span><br><span class="line">[ 16%] Building CXX object mysub/CMakeFiles/mysub.dir/mysub.cpp.o</span><br><span class="line">[ 33%] Linking CXX shared library ../../lib/libmysub.so</span><br><span class="line">[ 33%] Built target mysub</span><br><span class="line">Scanning dependencies of target myadd</span><br><span class="line">[ 50%] Building CXX object myadd/CMakeFiles/myadd.dir/myadd.cpp.o</span><br><span class="line">[ 66%] Linking CXX static library ../../lib/libmyadd.a</span><br><span class="line">[ 66%] Built target myadd</span><br><span class="line">Scanning dependencies of target testcmake</span><br><span class="line">[ 83%] Building CXX object CMakeFiles/testcmake.dir/test.cpp.o</span><br><span class="line">[100%] Linking CXX executable testcmake</span><br><span class="line">[100%] Built target testcmake</span><br><span class="line">albert@home-pc:testcmake/build$ ./testcmake</span><br><span class="line">happy birthday!</span><br><span class="line">519 + 1 = 520</span><br><span class="line">1320 - 6 = 1314</span><br><span class="line">albert@home-pc:testcmake/build$</span><br></pre></td></tr></table></figure><p>至此，使用cmake方式编译工程的例子就写完了。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol><li><code>cmake</code> 和 <code>automake</code> 本身不提供编译功能，只是可以按照编写的 CMakeLists.txt 文件生成 Makefile</li><li><code>make</code> 可以根据 Makefile 文件调用 gcc/g++ 命令对源代码进行编译工作</li><li><code>-Wl,-rpath=.</code> 这个选项可以指定可执行文件查找动态库的路径，感觉比 <code>export LD_LIBRARY_PATH</code> 要方便一点</li><li><code>-DGLIBCXX_USE_CXX11_ABI</code> 这个宏可坑了我不少时间，编译使用libmysqlcppconn8的时候，如果不禁用会报编译错误</li></ol><hr><center><a href="https://blog.csdn.net/albertsh/article/details/109553923" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>有你，真好~</p><p>2020-11-15 23:55:35</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;在 Windows上开发我使用最多的IDE还是 Visual Studio，编写、编译一条龙服务，导致了不少编译流程知识的缺失，这种大型的IDE确实好用，诸多配置通过在界面上勾选一下就可以了，但是在编译细节的掌握上还是漏掉了一些知识。&lt;/p&gt;
    
    </summary>
    
      <category term="linux" scheme="http://AlbertGithubHome.github.io/blog/categories/linux/"/>
    
    
      <category term="C++" scheme="http://AlbertGithubHome.github.io/blog/tags/C/"/>
    
      <category term="编译" scheme="http://AlbertGithubHome.github.io/blog/tags/%E7%BC%96%E8%AF%91/"/>
    
      <category term="linux" scheme="http://AlbertGithubHome.github.io/blog/tags/linux/"/>
    
      <category term="cmake" scheme="http://AlbertGithubHome.github.io/blog/tags/cmake/"/>
    
  </entry>
  
  <entry>
    <title>linux环境下sed命令的基础用法</title>
    <link href="http://AlbertGithubHome.github.io/blog/2020/11/07/linux%E7%8E%AF%E5%A2%83%E4%B8%8Bsed%E5%91%BD%E4%BB%A4%E7%9A%84%E5%9F%BA%E7%A1%80%E7%94%A8%E6%B3%95/"/>
    <id>http://AlbertGithubHome.github.io/blog/2020/11/07/linux环境下sed命令的基础用法/</id>
    <published>2020-11-07T06:37:04.000Z</published>
    <updated>2020-12-27T12:39:42.310Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>每次看到sed这个词就想起“种子”，心里明知道是把它和seed弄混了，但是先入为主的思想怕是改不过来了，不过现在还好，虽然把第一印象的意思弄错了，但还是很快能反应过来这是一个很“厉害”的linux命令，也有一些网友评论到，每次看到这个命令就双腿发抖，我虽然没抖，但是谈到这个命令还是有些挠头，心里有些发怵。</p><a id="more"></a><p>一味地逃避困难是不可取的，虽然心里感觉这是个很难的命令，但是今天还是要硬着头皮学一下，边学边记录，易于下次复习，那些打败不了我的困难终将使我更加强大。</p><h1 id="sed功能"><a href="#sed功能" class="headerlink" title="sed功能"></a>sed功能</h1><p>其实sed并不是一个单词，而是 stream editor 的缩写，本意为面向字符流的编辑器，说白了sed就是用来编辑文件的命令，编辑文件是我们每天经常做的工作，但是如果每天的编辑工作都类似，我们就要考虑使用sed工具来提高工作效率了，比如说把今天新增的100个文件的第一行都加上版本信息，虽然手动编辑也能做，但是你想体验一下敲个命令瞬间搞定这件事情的快感吗，我们来学习sed命令吧？</p><h2 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed [OPTION]... &#123;script-only-if-no-other-script&#125; [input-file]</span><br></pre></td></tr></table></figure><p>sed 的选项不是太多，最常用的有下面两种形式：</p><ul><li><code>sed -e &#39;sed命令脚本&#39; input-file</code></li><li><code>sed -f &#39;sed命令脚本文件&#39; input-file</code></li></ul><h2 id="命令选项"><a href="#命令选项" class="headerlink" title="命令选项"></a>命令选项</h2><ul><li><strong>-e</strong> ：命令行模式，选项后直接跟sed编辑脚本，在只有一组脚本的情况下可以省略</li><li><strong>-f</strong> ：脚本文件模式，选项后跟写有sed编辑脚本的文件名，运行后会执行脚本文件内的编辑动作</li><li><strong>-i</strong> ：直接修改文件内容，如果不加这个选项是不修改源文件的，只将修改后的文件输出</li><li><strong>-n</strong> ：只打印模式匹配的行，便于查看所作修改</li></ul><p>以上列举只是一些常见选项，还有些比如 <code>-l</code> 指定每行长度，<code>-s</code> 指定换行的分隔符等等，用到了再来分析学习。</p><h2 id="寻找匹配"><a href="#寻找匹配" class="headerlink" title="寻找匹配"></a>寻找匹配</h2><p>既然是编辑文件，首先要找到需要编辑的位置，在sed命令中可以使用行号，或者字符查找等方式找到需要修改的位置，然后再执行编辑动作，常见的范围：</p><ul><li><strong>x</strong>：指定的行号，表示第x行</li><li><strong>x,y</strong>：指定的行号范围，表示第x行到y行</li><li><strong>/pattern</strong>：查询到包含指定模式的行</li><li><strong>x,y!</strong>：指定的行号范围，表示不包括第x行到y行</li></ul><h1 id="sed操作"><a href="#sed操作" class="headerlink" title="sed操作"></a>sed操作</h1><p>sed几乎可以实现文件的所有编辑工作，接下来尝试一些常见的用法：</p><h2 id="打印内容"><a href="#打印内容" class="headerlink" title="打印内容"></a>打印内容</h2><p>使用编辑命令 <code>p</code>，可以向匹配行后面插入内容。</p><ul><li>打印文件第2行和第3行的内容，命令为<code>sed -n &#39;2,3p&#39; data.txt</code></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">albert@DESKTOP-6746UC3:/mnt/d/data/shell$ cat data.txt</span><br><span class="line">1234</span><br><span class="line">abc</span><br><span class="line">xyz</span><br><span class="line">1==</span><br><span class="line">123</span><br><span class="line">albert@DESKTOP-6746UC3:/mnt/d/data/shell$ sed -n <span class="string">'2,3p'</span> data.txt</span><br><span class="line">abc</span><br><span class="line">xyz</span><br></pre></td></tr></table></figure><h2 id="追加内容"><a href="#追加内容" class="headerlink" title="追加内容"></a>追加内容</h2><p>使用编辑命令 <code>a</code>，可以向匹配行后面插入内容。</p><ul><li>在第2行后面添加文本<code>newline</code>，命令为<code>sed &#39;2anewline&#39; data.txt</code></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">albert@DESKTOP-6746UC3:/mnt/d/data/shell$ cat data.txt</span><br><span class="line">1234</span><br><span class="line">abc</span><br><span class="line">xyz</span><br><span class="line">1==</span><br><span class="line">123</span><br><span class="line">albert@DESKTOP-6746UC3:/mnt/d/data/shell$ sed <span class="string">'2anewline'</span> data.txt</span><br><span class="line">1234</span><br><span class="line">abc</span><br><span class="line">newline</span><br><span class="line">xyz</span><br><span class="line">1==</span><br><span class="line">123</span><br></pre></td></tr></table></figure><ul><li>在最后一行后面添加文本<code>endline</code>，命令为<code>sed &#39;$aendline&#39; data.txt</code></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">albert@DESKTOP-6746UC3:/mnt/d/data/shell$ cat data.txt</span><br><span class="line">1234</span><br><span class="line">abc</span><br><span class="line">xyz</span><br><span class="line">1==</span><br><span class="line">123</span><br><span class="line">albert@DESKTOP-6746UC3:/mnt/d/data/shell$ sed <span class="string">'$aendline'</span> data.txt</span><br><span class="line">1234</span><br><span class="line">abc</span><br><span class="line">xyz</span><br><span class="line">1==</span><br><span class="line">123</span><br><span class="line">endline</span><br><span class="line">albert@DESKTOP-6746UC3:/mnt/d/data/shell$</span><br></pre></td></tr></table></figure><h2 id="插入内容"><a href="#插入内容" class="headerlink" title="插入内容"></a>插入内容</h2><p>使用编辑命令 <code>i</code>，可以在匹配的那一行插入内容。</p><ul><li>在第1行插入文本<code>firstline</code>，命令为<code>sed &#39;1ifirstline&#39; data.txt</code></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">albert@DESKTOP-6746UC3:/mnt/d/data/shell$ cat data.txt</span><br><span class="line">1234</span><br><span class="line">abc</span><br><span class="line">xyz</span><br><span class="line">1==</span><br><span class="line">123</span><br><span class="line">albert@DESKTOP-6746UC3:/mnt/d/data/shell$ sed <span class="string">'1ifirstline'</span> data.txt</span><br><span class="line">firstline</span><br><span class="line">1234</span><br><span class="line">abc</span><br><span class="line">xyz</span><br><span class="line">1==</span><br><span class="line">123</span><br></pre></td></tr></table></figure><ul><li>在包含文本 “123” 的行插入文本<code>insertline</code>，命令为<code>sed &#39;/123/iinsertline&#39; data.txt</code></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">albert@DESKTOP-6746UC3:/mnt/d/data/shell$ cat data.txt</span><br><span class="line">1234</span><br><span class="line">abc</span><br><span class="line">xyz</span><br><span class="line">1==</span><br><span class="line">123</span><br><span class="line">albert@DESKTOP-6746UC3:/mnt/d/data/shell$ sed <span class="string">'/123/iinsertline'</span> data.txt</span><br><span class="line">insertline</span><br><span class="line">1234</span><br><span class="line">abc</span><br><span class="line">xyz</span><br><span class="line">1==</span><br><span class="line">insertline</span><br><span class="line">123</span><br></pre></td></tr></table></figure><h2 id="更改行内容"><a href="#更改行内容" class="headerlink" title="更改行内容"></a>更改行内容</h2><p>使用编辑命令 <code>c</code>，可以修改匹配行的内容。</p><ul><li>将包含文本 “123” 的行替换为 “456”，命令为<code>sed &#39;/123/c456&#39; data.txt</code></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">albert@DESKTOP-6746UC3:/mnt/d/data/shell$ cat data.txt</span><br><span class="line">1234</span><br><span class="line">abc</span><br><span class="line">xyz</span><br><span class="line">1==</span><br><span class="line">123</span><br><span class="line">albert@DESKTOP-6746UC3:/mnt/d/data/shell$ sed <span class="string">'/123/c456'</span> data.txt</span><br><span class="line">456</span><br><span class="line">abc</span><br><span class="line">xyz</span><br><span class="line">1==</span><br><span class="line">456</span><br></pre></td></tr></table></figure><ul><li>将3、4、5行内容更改为newworld，命令为<code>sed &#39;3,5cneworld&#39; data.txt</code></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">albert@DESKTOP-6746UC3:/mnt/d/data/shell$ cat data.txt</span><br><span class="line">1234</span><br><span class="line">abc</span><br><span class="line">xyz</span><br><span class="line">1==</span><br><span class="line">123</span><br><span class="line">albert@DESKTOP-6746UC3:/mnt/d/data/shell$ sed <span class="string">'3,5cneworld'</span> data.txt</span><br><span class="line">1234</span><br><span class="line">abc</span><br><span class="line">neworld</span><br></pre></td></tr></table></figure><h2 id="替换行内容"><a href="#替换行内容" class="headerlink" title="替换行内容"></a>替换行内容</h2><p>使用编辑命令 <code>s</code>，可以替换匹配行的内容，需要注意和 <code>c</code> 的区别，<code>c</code> 是整行的内容都改变，而 <code>s</code> 是只替换命令中指定的部分。</p><ul><li>将文件中的文本 “123” 替换为 “456”，命令为<code>sed &#39;s/123/456/g&#39; data.txt</code></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">albert@DESKTOP-6746UC3:/mnt/d/data/shell$ cat data.txt</span><br><span class="line">1234</span><br><span class="line">abc</span><br><span class="line">xyz</span><br><span class="line">1==</span><br><span class="line">123</span><br><span class="line">albert@DESKTOP-6746UC3:/mnt/d/data/shell$ sed <span class="string">'s/123/456/g'</span> data.txt</span><br><span class="line">4564</span><br><span class="line">abc</span><br><span class="line">xyz</span><br><span class="line">1==</span><br><span class="line">456</span><br></pre></td></tr></table></figure><h1 id="综合运用"><a href="#综合运用" class="headerlink" title="综合运用"></a>综合运用</h1><ul><li>删除空行并给所有内容是 “123” 的文本加上小括号</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">albert@DESKTOP-6746UC3:/mnt/d/data/shell$ cat data.txt</span><br><span class="line">1234</span><br><span class="line">abc</span><br><span class="line">xyz</span><br><span class="line"></span><br><span class="line">1==</span><br><span class="line">123</span><br><span class="line">albert@DESKTOP-6746UC3:/mnt/d/data/shell$ sed -e <span class="string">'s/123/(&amp;)/g'</span> -e <span class="string">'/^$/d'</span> data.txt</span><br><span class="line">(123)4</span><br><span class="line">abc</span><br><span class="line">xyz</span><br><span class="line">1==</span><br><span class="line">(123)</span><br></pre></td></tr></table></figure><h2 id="删除内容"><a href="#删除内容" class="headerlink" title="删除内容"></a>删除内容</h2><p>使用编辑命令 <code>c</code>，可以删除匹配行。</p><ul><li>删除空行，命令为<code>sed &#39;/^$/d&#39; data.txt</code></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">albert@DESKTOP-6746UC3:/mnt/d/data/shell$ cat data.txt</span><br><span class="line">1234</span><br><span class="line"></span><br><span class="line">abc</span><br><span class="line">xyz</span><br><span class="line">1==</span><br><span class="line">123</span><br><span class="line">albert@DESKTOP-6746UC3:/mnt/d/data/shell$ sed <span class="string">'/^$/d'</span> data.txt</span><br><span class="line">1234</span><br><span class="line">abc</span><br><span class="line">xyz</span><br><span class="line">1==</span><br><span class="line">123</span><br></pre></td></tr></table></figure><ul><li>从第一行开始，每两行删除掉一行，命令为<code>sed &#39;1~2d&#39; data.txt</code></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">albert@DESKTOP-6746UC3:/mnt/d/data/shell$ cat data.txt</span><br><span class="line">1234</span><br><span class="line">abc</span><br><span class="line">xyz</span><br><span class="line">1==</span><br><span class="line">123</span><br><span class="line">albert@DESKTOP-6746UC3:/mnt/d/data/shell$ sed <span class="string">'1~2d'</span> data.txt</span><br><span class="line">abc</span><br><span class="line">1==</span><br></pre></td></tr></table></figure><ul><li>删除2行和3行以外的行，命令为<code>sed &#39;2,3!d&#39; data.txt</code></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">albert@DESKTOP-6746UC3:/mnt/d/data/shell$ cat data.txt</span><br><span class="line">1234</span><br><span class="line">abc</span><br><span class="line">xyz</span><br><span class="line">1==</span><br><span class="line">123</span><br><span class="line">albert@DESKTOP-6746UC3:/mnt/d/data/shell$ sed <span class="string">'2,3!d'</span> data.txt</span><br><span class="line">abc</span><br><span class="line">xyz</span><br></pre></td></tr></table></figure><ul><li>删除指定行数范围内的匹配行，命令为<code>sed &#39;1,3{/123/d}&#39; data.txt</code></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">albert@DESKTOP-6746UC3:/mnt/d/data/shell$ cat data.txt</span><br><span class="line">1234</span><br><span class="line">abc</span><br><span class="line">xyz</span><br><span class="line">1==</span><br><span class="line">123</span><br><span class="line">albert@DESKTOP-6746UC3:/mnt/d/data/shell$ sed <span class="string">'1,3&#123;/123/d&#125;'</span> data.txt</span><br><span class="line">abc</span><br><span class="line">xyz</span><br><span class="line">1==</span><br><span class="line">123</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li><code>sed</code> 是 stream editor 的缩写，表示为面向字符流的编辑器</li><li><code>sed</code> 命令常用的几个选项，<code>-e</code>、<code>-f</code>、<code>-i</code>、<code>-n</code></li><li><code>sed</code> 命令常用的几个编辑动作，也就是选项后的常用命令有 <code>p（打印）</code>、<code>a（追加）</code>、<code>i（插入）</code>、<code>c（改变）</code>、<code>s（替换）</code>、<code>d（删除）</code></li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/109267664" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>不能打败我的困难终将使我更加强大，绊不倒我的石头最后只会被拿来踩踏，拥抱一个个困难，生活本来就是一条打怪升级之路，那有什么一帆风顺~</p><p>2020-11-7 22:47:01</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;每次看到sed这个词就想起“种子”，心里明知道是把它和seed弄混了，但是先入为主的思想怕是改不过来了，不过现在还好，虽然把第一印象的意思弄错了，但还是很快能反应过来这是一个很“厉害”的linux命令，也有一些网友评论到，每次看到这个命令就双腿发抖，我虽然没抖，但是谈到这个命令还是有些挠头，心里有些发怵。&lt;/p&gt;
    
    </summary>
    
      <category term="linux" scheme="http://AlbertGithubHome.github.io/blog/categories/linux/"/>
    
    
      <category term="linux" scheme="http://AlbertGithubHome.github.io/blog/tags/linux/"/>
    
      <category term="sed" scheme="http://AlbertGithubHome.github.io/blog/tags/sed/"/>
    
      <category term="文件" scheme="http://AlbertGithubHome.github.io/blog/tags/%E6%96%87%E4%BB%B6/"/>
    
      <category term="编辑" scheme="http://AlbertGithubHome.github.io/blog/tags/%E7%BC%96%E8%BE%91/"/>
    
  </entry>
  
  <entry>
    <title>关于数据一致性的思考</title>
    <link href="http://AlbertGithubHome.github.io/blog/2020/10/24/%E5%85%B3%E4%BA%8E%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7%E7%9A%84%E6%80%9D%E8%80%83/"/>
    <id>http://AlbertGithubHome.github.io/blog/2020/10/24/关于数据一致性的思考/</id>
    <published>2020-10-24T14:11:21.000Z</published>
    <updated>2020-10-25T16:28:58.522Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>也不知道是谁这么有才，居然发明了1024这个程序员的节日，其他的节日都是买买买，唯独这个节日促销活动少的可怜，连早上买菜都是占了第二天重阳节的便宜，除了程序员们自嗨，也没人来给码农们庆祝了。</p><a id="more"></a><p>今天也嗨了一把，程序员的节日必须在工位上，飞速的敲着代码才是对1024最大的尊重，在这一天的结尾之际还是聊聊最近开发中的一些问题，其中数据一致性的问题确实需要梳理一下。</p><h1 id="什么是一致性"><a href="#什么是一致性" class="headerlink" title="什么是一致性"></a>什么是一致性</h1><p>关于一致性常常在两个地方听到，一个是数据库，另一个是分布式，两者都叫一致性，但是含义却不同。</p><h2 id="数据库一致性"><a href="#数据库一致性" class="headerlink" title="数据库一致性"></a>数据库一致性</h2><p>数据库中的一致性其实代表不破坏完整性，所有的数据从一个状态转化到另一个状态时不发生逻辑问题，比如说A通过手机银行给B转了100万，这件事情发生后A账户少了100万，B账户多了100万，这样就保证了数据的一致，如果转账结束A账户的钱少了100万，B账户却只多了100块，那完蛋了，A和B肯定一起去找银行打架去了。</p><h2 id="分布式一致性"><a href="#分布式一致性" class="headerlink" title="分布式一致性"></a>分布式一致性</h2><p>很多资料对于分布式一致性理解的都是数据冗余副本，当所有副本的数据一样时，那么此时的状态就是一致的。按照我自己的理解，这里的冗余副本不一定指的是数据形式完全一样，比如玩家在游戏服拥有金币资产200万，然后全服排行榜上的展示面板上显示资产也是200万，可能具体数据的形式不同，但这应该也是一种数据一致性的表现。</p><p>两个概念容易混淆，因为经常在分布式的架构下更新数据库，两种一致性也常常在同一个操作中有所体现。其实我也经常混着用，反正知道这个意思就好了，最近遇到的问题也是两个概念的集合，不过还是先来理解一下分布式的一致性吧</p><h1 id="分布式一致性分类"><a href="#分布式一致性分类" class="headerlink" title="分布式一致性分类"></a>分布式一致性分类</h1><ul><li><strong>强一致性：</strong> 要求无论更新操作是在哪一个节点副本上执行，之后获取的数据都是最新的。</li><li><strong>弱一致性：</strong> 能容忍部分或全部节点都看不到最新数据，数据改变时尽量通知可能多的节点。</li><li><strong>最终一致性：</strong> 是弱一致性的一种特例表现，需要保证用户最终能够读取到最新的数据。</li></ul><p>我们当然希望能实现强一致性，但这样需要付出相当大的代价，往往要通过牺牲可用性才能达到。</p><h1 id="一致性的保证"><a href="#一致性的保证" class="headerlink" title="一致性的保证"></a>一致性的保证</h1><p>如果要想达到强一致性，那么就得保证任何数据在改变之后必须通知所有节点，等待所有节点更新完毕后才能给用户提供服，这就要在开始更新时加一把大锁，先锁住数据，等待所有节点完成更新时释放锁，这样才能提供数据的强一致性保证。</p><p>如果节点太多的话，这个锁的机制将会消耗大量的时间来等待，可能导致应用长时间不能提供正常服务，在一些应用上显然是不合适的，所以是否要保证强一致性需要根据具体的业务逻辑来选择。</p><p>还有一个经常听到的观点就是在分布式系统中一致性和可用性我们只能选择一个，这一般是从CAP理论中得到的结论，但是这样说是不准确的，关于CAP理论最初版的大意为：“对于一个分布式计算系统，不可能同时满足一致性（Consistence）、可用性（Availability）、分区容错性（Partition Tolerance ）三个设计约束”。</p><p>通过CAP理论告诉我们分布式系统只能选择CP或者AP，但其实这里的前提是分布式系统发生了“分区”现象。如果当前系统没有发生分区现象，我们没有必要放弃C或者A，应该C和A都可以保证。</p><p>还有一点个人的理解，由于数据传输是需要时间的，那么当一个节点修改了数据同步到另一个节点时不可能瞬间完成，所以数据不一致总是时刻存在，而我们前面提到的数据一致总是指对用户而言的，虽然数据在传输过程中是不一致的，但是我们可以规定在数据完成同步前，用户看到的都是旧数据，这样就对用户而言数据就是一致的。</p><p>而数据同步过程中的不一致，如果在不一致期间还发生了中断、崩溃等问题，就必须通过日志来恢复了，个人觉得，总是有那么一种极限情况，连日志都救不了你，毕竟记录日志的也是一种程序，但是这类事情发生的概率也比较小了。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>程序世界的一致性常常指数据库中的一致性和分布式中的一致性</li><li>CAP理论告诉我们分布式系统在发生了分区现象时，才需要选择CP或者AP，否则应该可以保证CA</li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/109145949" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>欲穷千里目，更上一层楼。最近越来越发现古诗的精妙之处了，随着阅历的增加，之前背诵的古诗有些突然就明白了，不知道应该开心还是难过~</p><p>2020-10-26 00:27:02</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;也不知道是谁这么有才，居然发明了1024这个程序员的节日，其他的节日都是买买买，唯独这个节日促销活动少的可怜，连早上买菜都是占了第二天重阳节的便宜，除了程序员们自嗨，也没人来给码农们庆祝了。&lt;/p&gt;
    
    </summary>
    
      <category term="Thinking" scheme="http://AlbertGithubHome.github.io/blog/categories/Thinking/"/>
    
    
      <category term="游戏" scheme="http://AlbertGithubHome.github.io/blog/tags/%E6%B8%B8%E6%88%8F/"/>
    
      <category term="架构设计" scheme="http://AlbertGithubHome.github.io/blog/tags/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    
      <category term="一致性" scheme="http://AlbertGithubHome.github.io/blog/tags/%E4%B8%80%E8%87%B4%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>linux环境下使用sort命令完成常见排序操作</title>
    <link href="http://AlbertGithubHome.github.io/blog/2020/10/14/linux%E7%8E%AF%E5%A2%83%E4%B8%8B%E4%BD%BF%E7%94%A8sort%E5%91%BD%E4%BB%A4%E5%AE%8C%E6%88%90%E5%B8%B8%E8%A7%81%E6%8E%92%E5%BA%8F%E6%93%8D%E4%BD%9C/"/>
    <id>http://AlbertGithubHome.github.io/blog/2020/10/14/linux环境下使用sort命令完成常见排序操作/</id>
    <published>2020-10-14T15:46:28.000Z</published>
    <updated>2020-12-27T12:39:23.893Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>linux 系统下的命令常常给人一种短小精悍的感觉，使用起来就像一把把锋利的小刀，在自己专注的领域做到极致，今天要聊的就是 linux 环境下的排序命令 <code>sort</code>，处理文本按列排序非常方便，最近使用 <code>sort</code>命令来排序日志查找问题，为了防止一段时间不用又会忘记，所以记录下来便于下次查找。</p><a id="more"></a><h1 id="命令作用"><a href="#命令作用" class="headerlink" title="命令作用"></a>命令作用</h1><p><code>sort</code> 命令默认会将待排序内容以空格划分为多个列，然后对内容进行按列排序，命令本身不会修改待排序内容，而是将排序结果重新输出，如果想修改待排序源文件的内容，可以通过重定向命令来实现。</p><p>命令格式为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sort [选项] 文件名</span><br></pre></td></tr></table></figure><h1 id="常见选项"><a href="#常见选项" class="headerlink" title="常见选项"></a>常见选项</h1><p><code>sort</code> 作为一个强大的命令，参数选项还挺多的，不过我只列举一些常见的参数，方便日常使用即可。</p><ul><li><strong>-k：</strong> 指定排序依据的列数，可以分多次指定</li><li><strong>-o：</strong> 将排序后的结果存入指定文件</li><li><strong>-c：</strong> 检查指定文件是否已经排好序</li><li><strong>-u：</strong> 删除所有重复行</li><li><strong>-b：</strong> 忽略每行或字段前面开始出的空格字符</li><li><strong>-f：</strong> 排序比较时忽略大小写</li><li><strong>-n：</strong> 转化为数字，按照数值的大小排序</li><li><strong>-r：</strong> 反向排序，从大到小</li><li><strong>-t：</strong> 指定排序时划分列数的分隔字符</li></ul><h1 id="数据文件"><a href="#数据文件" class="headerlink" title="数据文件"></a>数据文件</h1><p>为了展示 <code>sort</code> 命令的作用，专门利用 <code>ls</code> 命令产生了一段数据，并保存在了 data.txt 文件中，之后会利用这个文件来展示 <code>sort</code> 的用法，文件内容展示如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:~$ cat data.txt</span><br><span class="line">-rwxrwxr-x 1 albert albert  9272 Jul 18 22:27 a.out*</span><br><span class="line">-rw------- 1 albert albert  7064 Oct 17 22:14 .bash_history</span><br><span class="line">-rw-r--r-- 1 albert albert   220 Jul 16 00:52 .bash_logout</span><br><span class="line">-rw-r--r-- 1 albert albert  3771 Jul 16 00:52 .bashrc</span><br><span class="line">drwxrwxrwx 1 albert albert  4096 Jul 16 01:10 .cache/</span><br><span class="line">drwx------ 1 albert albert  4096 Jul 16 00:52 .config/</span><br><span class="line">-rw------- 1 albert albert    35 Jul 19 14:14 .lesshst</span><br><span class="line">-rwxrwxr-x 1 albert albert 20328 Jul 18 19:49 mainpro*</span><br><span class="line">-rw-rw-r-- 1 albert albert   195 Jul 18 22:27 mainpro.cpp</span><br><span class="line">-rw-r--r-- 1 albert albert   655 Jul 16 00:52 .profile</span><br><span class="line">-rw-r--r-- 1 albert albert     0 Jul 16 00:52 .sudo_as_admin_successful</span><br><span class="line">-rw------- 1 root   root    2257 Jul 16 01:10 .viminfo</span><br><span class="line">drwxrwxrwx 1 albert albert  4096 Jul 19 21:19 .vscode-server/</span><br><span class="line">-rw------- 1 albert albert    61 Sep 20 09:42 .Xauthority</span><br></pre></td></tr></table></figure><p>这个文件中的内容在使用 <code>sort</code> 命令排序时默认以空格分割，所以共有9列，在指定列数时从1开始，接下来我们用这些数据来测试一下排序命令的用法。</p><h1 id="核心参数"><a href="#核心参数" class="headerlink" title="核心参数"></a>核心参数</h1><p>对于我来说 <code>sort</code> 命令的核心参数是 <code>-k</code>，其完整的参数列表为 <code>-k START_F[.START_C][OPTIONS][,END_F[.END_C][OPTIONS]]</code>，参数列表很长，但是不要恐惧，逐步分析就可以了。</p><p><code>-k</code> 后面这已打算都是用来指定排序依据的范围的，其中 <code>START_F</code> 和 <code>END_F</code> 表示开始和结束的字段，也就是列数，<code>.START_C</code> 和 <code>.END_C</code> 表示指定字段开始和结束的字符数，<code>OPTIONS</code> 是由一个或多个单个字母排序的选项[bdfgiMhnRrV]，这些选项中常用的已经列举在前面了，写在此处的选项会覆盖全局排序选项。</p><p>这样文字叙述有些枯燥，可以看下这个参数 <code>-k 6.2b,6.3b</code>，这个排序选项的含义是把内容按照第6列的第2个字符到第6列的第3个字符排序，查找字符位置的时候要去掉前面的空白。</p><h1 id="用法展示"><a href="#用法展示" class="headerlink" title="用法展示"></a>用法展示</h1><p>看了以上的参数可能还是不太清楚具体怎样用，所以举了下面这些例子，可以方便的处理常用的排序工作。</p><h2 id="按照指定列排序"><a href="#按照指定列排序" class="headerlink" title="按照指定列排序"></a>按照指定列排序</h2><p>这是最普通的排序要求了，也是我用的最多的情况，需要使用-k参数</p><ul><li>按照第3列排序</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:~$ sort -k3,3 data.txt</span><br><span class="line">drwx------ 1 albert albert  4096 Jul 16 00:52 .config/</span><br><span class="line">drwxrwxrwx 1 albert albert  4096 Jul 16 01:10 .cache/</span><br><span class="line">drwxrwxrwx 1 albert albert  4096 Jul 19 21:19 .vscode-server/</span><br><span class="line">-rw------- 1 albert albert    35 Jul 19 14:14 .lesshst</span><br><span class="line">-rw------- 1 albert albert    61 Sep 20 09:42 .Xauthority</span><br><span class="line">-rw------- 1 albert albert  7064 Oct 17 22:14 .bash_history</span><br><span class="line">-rw-r--r-- 1 albert albert     0 Jul 16 00:52 .sudo_as_admin_successful</span><br><span class="line">-rw-r--r-- 1 albert albert   220 Jul 16 00:52 .bash_logout</span><br><span class="line">-rw-r--r-- 1 albert albert  3771 Jul 16 00:52 .bashrc</span><br><span class="line">-rw-r--r-- 1 albert albert   655 Jul 16 00:52 .profile</span><br><span class="line">-rw-rw-r-- 1 albert albert   195 Jul 18 22:27 mainpro.cpp</span><br><span class="line">-rwxrwxr-x 1 albert albert 20328 Jul 18 19:49 mainpro*</span><br><span class="line">-rwxrwxr-x 1 albert albert  9272 Jul 18 22:27 a.out*</span><br><span class="line">-rw------- 1 root   root    2257 Jul 16 01:10 .viminfo</span><br></pre></td></tr></table></figure><blockquote><p>root 已经被排到了所有albert的后面</p></blockquote><h2 id="将排序结果存入指定文件"><a href="#将排序结果存入指定文件" class="headerlink" title="将排序结果存入指定文件"></a>将排序结果存入指定文件</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:~$ sort -k3,3 data.txt -o dst.txt</span><br><span class="line">albert@home-pc:~$ cat dst.txt</span><br><span class="line">drwx------ 1 albert albert  4096 Jul 16 00:52 .config/</span><br><span class="line">drwxrwxrwx 1 albert albert  4096 Jul 16 01:10 .cache/</span><br><span class="line">drwxrwxrwx 1 albert albert  4096 Jul 19 21:19 .vscode-server/</span><br><span class="line">-rw------- 1 albert albert    35 Jul 19 14:14 .lesshst</span><br><span class="line">-rw------- 1 albert albert    61 Sep 20 09:42 .Xauthority</span><br><span class="line">-rw------- 1 albert albert  7064 Oct 17 22:14 .bash_history</span><br><span class="line">-rw-r--r-- 1 albert albert     0 Jul 16 00:52 .sudo_as_admin_successful</span><br><span class="line">-rw-r--r-- 1 albert albert   220 Jul 16 00:52 .bash_logout</span><br><span class="line">-rw-r--r-- 1 albert albert  3771 Jul 16 00:52 .bashrc</span><br><span class="line">-rw-r--r-- 1 albert albert   655 Jul 16 00:52 .profile</span><br><span class="line">-rw-rw-r-- 1 albert albert   195 Jul 18 22:27 mainpro.cpp</span><br><span class="line">-rwxrwxr-x 1 albert albert 20328 Jul 18 19:49 mainpro*</span><br><span class="line">-rwxrwxr-x 1 albert albert  9272 Jul 18 22:27 a.out*</span><br><span class="line">-rw------- 1 root   root    2257 Jul 16 01:10 .viminfo</span><br></pre></td></tr></table></figure><blockquote><p>排序结果已经被存储到了文件 dst.txt 中，其实这个命令还可以改写成 <code>sort data.txt &gt; dst.txt</code></p></blockquote><h2 id="查看文件是否已经排序好"><a href="#查看文件是否已经排序好" class="headerlink" title="查看文件是否已经排序好"></a>查看文件是否已经排序好</h2><ul><li>测试没排好序的文件</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:~$ sort -k3,3 data.txt -c</span><br><span class="line">sort: data.txt:2: disorder: -rw------- 1 albert albert  7064 Oct 17 22:14 .bash_history</span><br></pre></td></tr></table></figure><ul><li>测试已经排序的文件</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:~$ sort -k3,3 dst.txt -c</span><br><span class="line">albert@home-pc:~$</span><br></pre></td></tr></table></figure><blockquote><p>对于已经拍好序的文件使用 -c 参数没有任何输出，如果是未排序的文件则会给出提示</p></blockquote><h2 id="去掉排序结果中的重复行"><a href="#去掉排序结果中的重复行" class="headerlink" title="去掉排序结果中的重复行"></a>去掉排序结果中的重复行</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:~$ sort -k3,3 data.txt -u</span><br><span class="line">-rwxrwxr-x 1 albert albert  9272 Jul 18 22:27 a.out*</span><br><span class="line">-rw------- 1 root   root    2257 Jul 16 01:10 .viminfo</span><br></pre></td></tr></table></figure><blockquote><p>这里的重复行参考是你指定排序依据的列数，也就是第3列如果重复就会认为是重复行，结果中只能出现一次</p></blockquote><h2 id="按照数值结果进行排序"><a href="#按照数值结果进行排序" class="headerlink" title="按照数值结果进行排序"></a>按照数值结果进行排序</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:~$ sort -k5n,5 data.txt</span><br><span class="line">-rw-r--r-- 1 albert albert     0 Jul 16 00:52 .sudo_as_admin_successful</span><br><span class="line">-rw------- 1 albert albert    35 Jul 19 14:14 .lesshst</span><br><span class="line">-rw------- 1 albert albert    61 Sep 20 09:42 .Xauthority</span><br><span class="line">-rw-rw-r-- 1 albert albert   195 Jul 18 22:27 mainpro.cpp</span><br><span class="line">-rw-r--r-- 1 albert albert   220 Jul 16 00:52 .bash_logout</span><br><span class="line">-rw-r--r-- 1 albert albert   655 Jul 16 00:52 .profile</span><br><span class="line">-rw------- 1 root   root    2257 Jul 16 01:10 .viminfo</span><br><span class="line">-rw-r--r-- 1 albert albert  3771 Jul 16 00:52 .bashrc</span><br><span class="line">drwx------ 1 albert albert  4096 Jul 16 00:52 .config/</span><br><span class="line">drwxrwxrwx 1 albert albert  4096 Jul 16 01:10 .cache/</span><br><span class="line">drwxrwxrwx 1 albert albert  4096 Jul 19 21:19 .vscode-server/</span><br><span class="line">-rw------- 1 albert albert  7064 Oct 17 22:14 .bash_history</span><br><span class="line">-rwxrwxr-x 1 albert albert  9272 Jul 18 22:27 a.out*</span><br><span class="line">-rwxrwxr-x 1 albert albert 20328 Jul 18 19:49 mainpro*</span><br></pre></td></tr></table></figure><blockquote><p>这里使用了 -k5n,5 作为排序选项，其中的 n 表示以数值方式排序，如果不加 n 的排序结果如下：</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:~$ sort -k5,5 data.txt</span><br><span class="line">-rw-r--r-- 1 albert albert     0 Jul 16 00:52 .sudo_as_admin_successful</span><br><span class="line">-rw-rw-r-- 1 albert albert   195 Jul 18 22:27 mainpro.cpp</span><br><span class="line">-rwxrwxr-x 1 albert albert 20328 Jul 18 19:49 mainpro*</span><br><span class="line">-rw-r--r-- 1 albert albert   220 Jul 16 00:52 .bash_logout</span><br><span class="line">-rw------- 1 root   root    2257 Jul 16 01:10 .viminfo</span><br><span class="line">-rw------- 1 albert albert    35 Jul 19 14:14 .lesshst</span><br><span class="line">-rw-r--r-- 1 albert albert  3771 Jul 16 00:52 .bashrc</span><br><span class="line">drwx------ 1 albert albert  4096 Jul 16 00:52 .config/</span><br><span class="line">drwxrwxrwx 1 albert albert  4096 Jul 16 01:10 .cache/</span><br><span class="line">drwxrwxrwx 1 albert albert  4096 Jul 19 21:19 .vscode-server/</span><br><span class="line">-rw------- 1 albert albert    61 Sep 20 09:42 .Xauthority</span><br><span class="line">-rw-r--r-- 1 albert albert   655 Jul 16 00:52 .profile</span><br><span class="line">-rw------- 1 albert albert  7064 Oct 17 22:14 .bash_history</span><br><span class="line">-rwxrwxr-x 1 albert albert  9272 Jul 18 22:27 a.out*</span><br></pre></td></tr></table></figure><blockquote><p>数据看起来很乱，其实也是按照第5列排好序的，仔细分析你会发现是把这些数字当成字符串排的序</p></blockquote><h2 id="反向排序"><a href="#反向排序" class="headerlink" title="反向排序"></a>反向排序</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:~$ sort -k3,3 data.txt -r</span><br><span class="line">-rw------- 1 root   root    2257 Jul 16 01:10 .viminfo</span><br><span class="line">-rwxrwxr-x 1 albert albert  9272 Jul 18 22:27 a.out*</span><br><span class="line">-rwxrwxr-x 1 albert albert 20328 Jul 18 19:49 mainpro*</span><br><span class="line">-rw-rw-r-- 1 albert albert   195 Jul 18 22:27 mainpro.cpp</span><br><span class="line">-rw-r--r-- 1 albert albert   655 Jul 16 00:52 .profile</span><br><span class="line">-rw-r--r-- 1 albert albert  3771 Jul 16 00:52 .bashrc</span><br><span class="line">-rw-r--r-- 1 albert albert   220 Jul 16 00:52 .bash_logout</span><br><span class="line">-rw-r--r-- 1 albert albert     0 Jul 16 00:52 .sudo_as_admin_successful</span><br><span class="line">-rw------- 1 albert albert  7064 Oct 17 22:14 .bash_history</span><br><span class="line">-rw------- 1 albert albert    61 Sep 20 09:42 .Xauthority</span><br><span class="line">-rw------- 1 albert albert    35 Jul 19 14:14 .lesshst</span><br><span class="line">drwxrwxrwx 1 albert albert  4096 Jul 19 21:19 .vscode-server/</span><br><span class="line">drwxrwxrwx 1 albert albert  4096 Jul 16 01:10 .cache/</span><br><span class="line">drwx------ 1 albert albert  4096 Jul 16 00:52 .config/</span><br></pre></td></tr></table></figure><blockquote><p>按照第3列反向排序，root就排到了所有albert的前面</p></blockquote><h2 id="自定义分割字符"><a href="#自定义分割字符" class="headerlink" title="自定义分割字符"></a>自定义分割字符</h2><p><code>sort</code> 命令默认是以空格作为列的分割符号的，可以使用 <code>-t</code> 选项自定义分割符，比如我们使用 <code>:</code> 作为分隔符，然后以第二列进行排序</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:~$ sort -t <span class="string">":"</span> -k2,2 data.txt</span><br><span class="line">drwxrwxrwx 1 albert albert  4096 Jul 16 01:10 .cache/</span><br><span class="line">-rw------- 1 root   root    2257 Jul 16 01:10 .viminfo</span><br><span class="line">-rw------- 1 albert albert  7064 Oct 17 22:14 .bash_history</span><br><span class="line">-rw------- 1 albert albert    35 Jul 19 14:14 .lesshst</span><br><span class="line">drwxrwxrwx 1 albert albert  4096 Jul 19 21:19 .vscode-server/</span><br><span class="line">-rwxrwxr-x 1 albert albert  9272 Jul 18 22:27 a.out*</span><br><span class="line">-rw-rw-r-- 1 albert albert   195 Jul 18 22:27 mainpro.cpp</span><br><span class="line">-rw------- 1 albert albert    61 Sep 20 09:42 .Xauthority</span><br><span class="line">-rwxrwxr-x 1 albert albert 20328 Jul 18 19:49 mainpro*</span><br><span class="line">-rw-r--r-- 1 albert albert   220 Jul 16 00:52 .bash_logout</span><br><span class="line">-rw-r--r-- 1 albert albert  3771 Jul 16 00:52 .bashrc</span><br><span class="line">drwx------ 1 albert albert  4096 Jul 16 00:52 .config/</span><br><span class="line">-rw-r--r-- 1 albert albert   655 Jul 16 00:52 .profile</span><br><span class="line">-rw-r--r-- 1 albert albert     0 Jul 16 00:52 .sudo_as_admin_successful</span><br></pre></td></tr></table></figure><blockquote><p>结果是以分钟数进行的排序</p></blockquote><h1 id="综合排序"><a href="#综合排序" class="headerlink" title="综合排序"></a>综合排序</h1><p>学习了上面这么多参数，可以做一个综合的例子，以第6列的月份从小到大排序，以第5列文件大小逆序排列，通过组合上面的参数，可以使用下面的命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:~$ sort -k6,6 -k5rn,5 data.txt</span><br><span class="line">-rwxrwxr-x 1 albert albert 20328 Jul 18 19:49 mainpro*</span><br><span class="line">-rwxrwxr-x 1 albert albert  9272 Jul 18 22:27 a.out*</span><br><span class="line">drwx------ 1 albert albert  4096 Jul 16 00:52 .config/</span><br><span class="line">drwxrwxrwx 1 albert albert  4096 Jul 16 01:10 .cache/</span><br><span class="line">drwxrwxrwx 1 albert albert  4096 Jul 19 21:19 .vscode-server/</span><br><span class="line">-rw-r--r-- 1 albert albert  3771 Jul 16 00:52 .bashrc</span><br><span class="line">-rw------- 1 root   root    2257 Jul 16 01:10 .viminfo</span><br><span class="line">-rw-r--r-- 1 albert albert   655 Jul 16 00:52 .profile</span><br><span class="line">-rw-r--r-- 1 albert albert   220 Jul 16 00:52 .bash_logout</span><br><span class="line">-rw-rw-r-- 1 albert albert   195 Jul 18 22:27 mainpro.cpp</span><br><span class="line">-rw------- 1 albert albert    35 Jul 19 14:14 .lesshst</span><br><span class="line">-rw-r--r-- 1 albert albert     0 Jul 16 00:52 .sudo_as_admin_successful</span><br><span class="line">-rw------- 1 albert albert  7064 Oct 17 22:14 .bash_history</span><br><span class="line">-rw------- 1 albert albert    61 Sep 20 09:42 .Xauthority</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li><code>sort</code> 命令中的 <code>-k</code> 选项是最重要的参数，可以指定排序依据的列数</li><li><code>sort</code> 命令中的 <code>-n</code> 选项也是常用的参数，可以进行数值比较</li><li>在实际问题中常常需要综合运用这些参数，参考综合例子中的方式逐步确定参数选项就可以了。</li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/109020024" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>业精于勤，荒于嬉；行成于思，毁于随。没有人能随随便便成功~</p><p>2020-10-18 15:43:51</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;linux 系统下的命令常常给人一种短小精悍的感觉，使用起来就像一把把锋利的小刀，在自己专注的领域做到极致，今天要聊的就是 linux 环境下的排序命令 &lt;code&gt;sort&lt;/code&gt;，处理文本按列排序非常方便，最近使用 &lt;code&gt;sort&lt;/code&gt;命令来排序日志查找问题，为了防止一段时间不用又会忘记，所以记录下来便于下次查找。&lt;/p&gt;
    
    </summary>
    
      <category term="linux" scheme="http://AlbertGithubHome.github.io/blog/categories/linux/"/>
    
    
      <category term="排序" scheme="http://AlbertGithubHome.github.io/blog/tags/%E6%8E%92%E5%BA%8F/"/>
    
      <category term="linux" scheme="http://AlbertGithubHome.github.io/blog/tags/linux/"/>
    
      <category term="sort" scheme="http://AlbertGithubHome.github.io/blog/tags/sort/"/>
    
  </entry>
  
  <entry>
    <title>Go语言在解决实际问题时的优点与不便</title>
    <link href="http://AlbertGithubHome.github.io/blog/2020/10/14/Go%E8%AF%AD%E8%A8%80%E5%9C%A8%E8%A7%A3%E5%86%B3%E5%AE%9E%E9%99%85%E9%97%AE%E9%A2%98%E6%97%B6%E7%9A%84%E4%BC%98%E7%82%B9%E4%B8%8E%E4%B8%8D%E4%BE%BF/"/>
    <id>http://AlbertGithubHome.github.io/blog/2020/10/14/Go语言在解决实际问题时的优点与不便/</id>
    <published>2020-10-14T15:19:16.000Z</published>
    <updated>2020-10-14T15:20:52.573Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><code>Go</code>语言，全称<code>golang</code>，是Google开发的一种静态强类型、编译型、并发型并具有垃圾回收功能的编程语言。 从2007年末由 Robert Griesemer、Rob Pike、Ken Thompson 主持开发，其中的 Ken Thompson 可是和 Dennis Ritchie 一起发明了C语言的大佬。Go 语言于2009年11月正式宣布成为开放源代码项目， 并在2012年初，发布了Go 1.0稳定版本，此后便开启了稳步发展的道路。</p><a id="more"></a><h1 id="Go-语言"><a href="#Go-语言" class="headerlink" title="Go 语言"></a>Go 语言</h1><p>作为一个从2007年开始诞生的语言，在庞大的语言家族中算是一个晚辈，和C++、Python这种老牌语言相比查了将近20年，和 C 语言相比资历就更低了，但是这个新晋的语言在 Google 光环的强大加持下也在飞速发展着，由于前辈们在发展的途中趟了很多坑，所以 Go 在发明之初就避免了其他语言的很多不便，可以说是站在巨人的肩膀上发展起来的。</p><p>但是即便这样，Go 语言的特点也不能被所有人喜欢，和许多人一样，我在学习这门语言的过程中也发现一些很方便特性和一些不太方便的特点，下面简单说几个点，有不对的地方希望小伙伴能及时指出，防止我在错误的思想上越走越远（怎么有种新闻发言稿的感觉~）。</p><h1 id="不便之处"><a href="#不便之处" class="headerlink" title="不便之处"></a>不便之处</h1><p>这里的不便之处只是我在使用过程中感觉不太方便，可能很多人并没有这个感觉，或许还有很多其他的解决方法和替代方案，烦请小伙伴能指点一下。</p><h2 id="三目运算符"><a href="#三目运算符" class="headerlink" title="三目运算符"></a>三目运算符</h2><p>这个三目运算符是个很常用的逻辑处理部件，也是我在逻辑中经常使用到的，在Python、Lua等语言中也不存在，但是我都找到了简单的替代方式，但是在Go 中不得不写成中规中矩的 <code>if</code> 条件判断，这让很多算法的解题代码看起来并不那么优雅，比如一个简单的约瑟夫环问题：</p><blockquote><p>N个人围成一圈，从第一个人从开始报数，报到m的人出圈，剩下的人继续从1开始报数，报到m的人出圈；如此往复，直到所有人出圈，输出最后一个出圈人最初始的编号。</p></blockquote><p>这个问题的解法最简单的是模拟法，使用数组模拟一个环来按照规则运行，最后一个出圈的人的编号就可以输出到结果，还有一种思路就是找规律，可以找到出圈前后的序号对应关系，进而写出一行代码的解决方案。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 索引从0开始，只要对结果加1就好了</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">joseph_ring</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n == <span class="number">1</span> ? <span class="number">0</span> : (joseph_ring(n - <span class="number">1</span>, m) + m) % n</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是在没有三目运算符的 Go 中要实现这个算法，就不得不多写几行了，和 C 语言相比就没有那么简洁了。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">joseph_ring</span><span class="params">(n <span class="keyword">int</span>, m <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (joseph_ring(n - <span class="number">1</span>, m) + m) % n</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="if-单行语句也要加大括号"><a href="#if-单行语句也要加大括号" class="headerlink" title="if 单行语句也要加大括号"></a>if 单行语句也要加大括号</h2><p>Go 语言本身带有自己的格式化命令，可以保证编写时不同的缩进样式格式化之后得到相同的代码，<code>if</code> 后面的条件语句可以不加小括号，但是后面的语句块必须加大括号，这样的规定对于我经常写的代码有点不太友好，比如下面这些C++代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (a &gt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (b &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span>;</span><br></pre></td></tr></table></figure><p>有时候为了看起来紧凑，可能会写成这样：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (a &gt; <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">if</span> (b &lt; <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span> (c == <span class="number">0</span>) <span class="keyword">return</span>;</span><br></pre></td></tr></table></figure><p>但是放到 Go 语言中，就不得不写成好几行了，并且还要加大括号，看起来代码有些松散。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> a &gt; <span class="number">0</span> &#123;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> b &lt; <span class="number">0</span> &#123;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> c == <span class="number">0</span> &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="优秀特性"><a href="#优秀特性" class="headerlink" title="优秀特性"></a>优秀特性</h1><p>上面提到了 Go 语言中不方便的地方，现在可以来说说 Go 语言相对于 C、C++ 更优越的特性：</p><h2 id="多个变量同时赋值"><a href="#多个变量同时赋值" class="headerlink" title="多个变量同时赋值"></a>多个变量同时赋值</h2><p>在 C++ 中交换两个变量的通常使用中间变量来完成，比如交换 <code>a</code>、<code>b</code> 两个变量的值：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> tmp = a;</span><br><span class="line">a = b;</span><br><span class="line">b = tmp;</span><br></pre></td></tr></table></figure><p>针对于这种整形的变量，一些大牛们发明了特殊的算法来处理，避免使用中间变量：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>,;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">a = a ^ b</span><br><span class="line">b = b ^ a</span><br><span class="line">a = a ^ b</span><br></pre></td></tr></table></figure><p>但是在 Go语言中这种情况非常好处理，直接从左到右依次赋值就好了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var a <span class="keyword">int</span> = <span class="number">1</span></span><br><span class="line">var b <span class="keyword">int</span> = <span class="number">6</span></span><br><span class="line"></span><br><span class="line">b, a = a, b</span><br></pre></td></tr></table></figure><h2 id="defer-声明"><a href="#defer-声明" class="headerlink" title="defer 声明"></a>defer 声明</h2><p><code>defer</code> 可以用于在当前函数返回前执行一些清理代码，而不管此函数如何退出。defer 在函数中可以随时出现，这使得清理代码可以尽可能在需要清理的地方运行，比如我们常常要释放申请的资源，常见的需要释放的资源有文件描述符：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">file, err := os.Open(fileName)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> file.Close()</span><br></pre></td></tr></table></figure><p>有了 defer 终于不再在担心，资源没回收的问题，也不用在各个提前返回的条件分支中添加释放资源的重复代码了。</p><h2 id="goroutine-并发"><a href="#goroutine-并发" class="headerlink" title="goroutine 并发"></a>goroutine 并发</h2><p><code>goroutine</code> 是Go并行设计的核心，说到底其实就是协程，但是它比线程更小并且在Go语言内部帮你实现了这些 goroutine 之间的内存共享。执行 goroutine 只需要极少的栈内存，可同时运行成千上万个并发任务。goroutine 一定程度上比 thread 更易用、更高效、更轻便。</p><p>使用起来也非常方便，创建 goroutine 只需在函数调用语句前添加 go 关键字，就可以创建并发执行单元。开发人员无需了解任何执行细节，调度器会自动将其安排到合适的系统线程上执行，这是解放生产力的又一创举，简单示例代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">new_task</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        fmt.Println(<span class="string">"this is a newTask"</span>)</span><br><span class="line">        time.Sleep(time.Second) <span class="comment">//延时1s</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> new_task() <span class="comment">//新建一个协程， 新建一个任务</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    time.Sleep(time.Second * <span class="number">15</span>) <span class="comment">//延时15s</span></span><br><span class="line">    fmt.Println(<span class="string">"this is a main goroutine"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>Go 语言作为编程语言中的新晋小弟，吸收了前人的经验，现阶段发展迅猛</li><li>虽然 Go 出于一些目的规定了语言的标准，但是类似于没有三目运算符这种特点还是有些不方便</li><li>Go 这门语言还很年轻，相信随着不断发展它会越来越优秀，但没有任何语言是完美无缺的</li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/108819869" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>陪伴是最长情的告白，而守护是最沉默的陪伴。国庆中秋双节合并，放假了，陪家人待在一起真的很开心，什么都不用做，就静静的待在一起很满足，聊聊天、抬抬杠，假期嗖嗖嗖地溜掉了~</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&lt;code&gt;Go&lt;/code&gt;语言，全称&lt;code&gt;golang&lt;/code&gt;，是Google开发的一种静态强类型、编译型、并发型并具有垃圾回收功能的编程语言。 从2007年末由 Robert Griesemer、Rob Pike、Ken Thompson 主持开发，其中的 Ken Thompson 可是和 Dennis Ritchie 一起发明了C语言的大佬。Go 语言于2009年11月正式宣布成为开放源代码项目， 并在2012年初，发布了Go 1.0稳定版本，此后便开启了稳步发展的道路。&lt;/p&gt;
    
    </summary>
    
      <category term="Go" scheme="http://AlbertGithubHome.github.io/blog/categories/Go/"/>
    
    
      <category term="C++" scheme="http://AlbertGithubHome.github.io/blog/tags/C/"/>
    
      <category term="Go" scheme="http://AlbertGithubHome.github.io/blog/tags/Go/"/>
    
      <category term="优点" scheme="http://AlbertGithubHome.github.io/blog/tags/%E4%BC%98%E7%82%B9/"/>
    
      <category term="缺点" scheme="http://AlbertGithubHome.github.io/blog/tags/%E7%BC%BA%E7%82%B9/"/>
    
  </entry>
  
  <entry>
    <title>使用Spreadsheet Compare工具对比Excel文件差异</title>
    <link href="http://AlbertGithubHome.github.io/blog/2020/10/04/%E4%BD%BF%E7%94%A8Spreadsheet-Compare%E5%B7%A5%E5%85%B7%E5%AF%B9%E6%AF%94Excel%E6%96%87%E4%BB%B6%E5%B7%AE%E5%BC%82/"/>
    <id>http://AlbertGithubHome.github.io/blog/2020/10/04/使用Spreadsheet-Compare工具对比Excel文件差异/</id>
    <published>2020-10-04T15:09:33.000Z</published>
    <updated>2020-10-14T15:22:01.216Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>与 <code>Spreadsheet Compare</code> 这个工具的相遇是通过 TortoiseSVN 来牵线的，在使用 SVN 管理 Excel 表格时发现，TortoiseSVN自带的比较工具不能对比Excel文件的版本差异，这对于通过日志查找问题来说非常不方便，通过搜索发现了 <code>Spreadsheet Compare</code> 这款优秀的工具，特此记录一下，方便日后查找并快速配置。</p><a id="more"></a><h1 id="Spreadsheet-Compare"><a href="#Spreadsheet-Compare" class="headerlink" title="Spreadsheet Compare"></a>Spreadsheet Compare</h1><p><code>Spreadsheet Compare</code> 是 Microsoft Office 自带的一款工具软件（2013版本以后），可以用来比较不同 Excel 表格的差异，既能显示数据的不同，也可以显示出表结构的不同。这是一款带界面的工具软件，布局分为左右两部分，与 Beyond Compare 这个工具界面类似，但是功能更加强大。</p><p>Beyond Compare 也可以用来对比表格差异，但是只能比较两个Excel的当前工作表，如果每个 Excel 文件中包含多个工作表时就会对比错误的情况，而 <code>Spreadsheet Compare</code> 在这一点上更加优秀，可以对比多个表格数据。</p><p><code>Spreadsheet Compare</code> 使用起来也非常简单，可以操作的按钮很少，界面简洁， 启动软件后单击左上角的 <code>Compare Files</code> 按钮，选择要对比的文件即可，非常方便，数据差异、结构差异等都会用不同的颜色标记出来，还可以导出对比结果。</p><h1 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h1><p>这种模式对于是提供给 TortoiseSVN 使用的前提，因为 TortoiseSVN 无法像人一样一步步操作选择待比较的 Excel 表格，而是需要一个命令脚本，将要比较的参数传给 <code>Spreadsheet Compare</code> 工具进而完成比较工作。</p><h2 id="找到工具"><a href="#找到工具" class="headerlink" title="找到工具"></a>找到工具</h2><p>想要编写命令脚本，首先要找到这个比较的工具，我找到的路径是在 <code>&quot;C:\Program Files (x86)\Microsoft Office\Root\Office16\DCF\SPREADSHEETCOMPARE.EXE&quot;</code>，相信大家的路径都差不多，在 Office 工具目录下应该就能找到了，可以在开始菜单中找到工具，然后通过属性找到可执行程序所在目录，工具的可执行文件名字叫做 <code>SPREADSHEETCOMPARE.EXE</code>。</p><h2 id="编写脚本"><a href="#编写脚本" class="headerlink" title="编写脚本"></a>编写脚本</h2><p>编写脚本之前有一点需要强调一下，<code>SPREADSHEETCOMPARE.EXE</code> 有点奇怪，大多数软件在比较差异的时候会将两个文件作为参数使用，但是 <code>SPREADSHEETCOMPARE.EXE</code> 在比较之前，需要将两个待比较的文件名分成两行写入一个文件，再将这个文件作为参数传给工具使用，比如要比较 ExcelA.xlsx 和 ExcelB.xlsx 两个文件，需要将两个文件写入一个临时文件 ExcelCompare.txt 中:</p><blockquote><p>ExcelA.xlsx<br>ExcelB.xlsx</p></blockquote><p>然后再把这个文件作为参数传给工具：</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SPREADSHEETCOMPARE.EXE ExcelCompare.txt</span><br></pre></td></tr></table></figure><h2 id="脚本内容"><a href="#脚本内容" class="headerlink" title="脚本内容"></a>脚本内容</h2><p>有了上面的说明，我们就可以写出一个较为通用的版本，比如我的脚本名字是 SC.bat，内容如下：</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line"><span class="built_in">chcp</span> <span class="number">65001</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> batpath=%~dp0</span><br><span class="line"><span class="built_in">echo</span> %~<span class="number">1</span>&gt; "<span class="variable">%batpath%</span>ExcelCompare.txt"</span><br><span class="line"><span class="built_in">echo</span> %~<span class="number">2</span>&gt;&gt; "<span class="variable">%batpath%</span>ExcelCompare.txt"</span><br><span class="line">"C:\\Program Files (x86)\\Microsoft Office\\Root\\Office16\\DCF\\SPREADSHEETCOMPARE.EXE" "<span class="variable">%batpath%</span>ExcelCompare.txt"</span><br></pre></td></tr></table></figure><h2 id="脚本执行"><a href="#脚本执行" class="headerlink" title="脚本执行"></a>脚本执行</h2><p>直接在 cmd 命令行中输入以下命令就可以对比 ExcelA.xlsx 和 ExcelB.xlsx 两个文件了：</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">D:\<span class="title">data</span>\<span class="title">bat</span>&gt;</span></span><br><span class="line"><span class="function"><span class="title">D</span>:\<span class="title">data</span>\<span class="title">bat</span>&gt;<span class="title">SC.bat</span> <span class="title">ExcelA.xlsx</span> <span class="title">ExcelB.xlsx</span></span></span><br></pre></td></tr></table></figure><h2 id="供给SVN调用"><a href="#供给SVN调用" class="headerlink" title="供给SVN调用"></a>供给SVN调用</h2><p>个人比较懒，不喜欢截图，在 TortoiseSVN 工具的设置中找到“差异查看器”选项，选择该选项然后点击界面上的高级设置，点击增加按钮，增加根据扩展名指定差异比较程序，填写 <code>.xlsx</code> 和所需命令 <code>D:\data\bat&gt;SC.bat %base %mine</code></p><p>命令中的 <code>%base</code> 和 <code>%mine</code> 参数是 TortoiseSVN 提供的，代表原始文件和自己修改的文件，这次再通过 SVN 查看表格差异就可以启动 <code>Spreadsheet Compare</code> 程序方便地查看两个表格的差异啦。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li><code>Spreadsheet Compare</code> 是一款强大的表格比较工具，在表格比较时比 Beyond Compare 还要优秀</li><li>脚本调用 <code>SPREADSHEETCOMPARE.EXE</code> 程序时参数是一个包含了待比较文件名的临时文件，这一点和其他的比较工具有些不同</li><li>脚本中我们生成的临时文件无需手动处理，再打开待比较文件后会自动删除</li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/108920923" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>急需找到一个看得见摸得着的目标为之努力，不然真的有点止步不前了，至今还未找到可以废寝忘食之事，长此以往终将碌碌无为，继续找寻，此事可以不伟大，但应该有趣~</p><p>2020-10-12 00:16:52</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;与 &lt;code&gt;Spreadsheet Compare&lt;/code&gt; 这个工具的相遇是通过 TortoiseSVN 来牵线的，在使用 SVN 管理 Excel 表格时发现，TortoiseSVN自带的比较工具不能对比Excel文件的版本差异，这对于通过日志查找问题来说非常不方便，通过搜索发现了 &lt;code&gt;Spreadsheet Compare&lt;/code&gt; 这款优秀的工具，特此记录一下，方便日后查找并快速配置。&lt;/p&gt;
    
    </summary>
    
      <category term="Tools" scheme="http://AlbertGithubHome.github.io/blog/categories/Tools/"/>
    
    
      <category term="Excel" scheme="http://AlbertGithubHome.github.io/blog/tags/Excel/"/>
    
      <category term="Spreadsheet-Compare" scheme="http://AlbertGithubHome.github.io/blog/tags/Spreadsheet-Compare/"/>
    
      <category term="SVN" scheme="http://AlbertGithubHome.github.io/blog/tags/SVN/"/>
    
  </entry>
  
  <entry>
    <title>东拉西扯01世界的沧海桑田</title>
    <link href="http://AlbertGithubHome.github.io/blog/2020/09/26/%E4%B8%9C%E6%8B%89%E8%A5%BF%E6%89%AF01%E4%B8%96%E7%95%8C%E7%9A%84%E6%B2%A7%E6%B5%B7%E6%A1%91%E7%94%B0/"/>
    <id>http://AlbertGithubHome.github.io/blog/2020/09/26/东拉西扯01世界的沧海桑田/</id>
    <published>2020-09-26T14:47:01.000Z</published>
    <updated>2020-10-14T15:21:05.336Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>此篇非技术总结，但却与技术相关，写这篇总结的起因是前两天看了一节关于虚幻四的公开课，这节课也不是讲开发技术，更多的是讲创作艺术，课程开始前看到虚幻编辑器的画面，还是有一种很熟悉的感觉，毕竟使用了3年多的时间，外观几乎没有变化，使用方式依旧是原来的步骤，但随着课程的进行，我发现它变了。</p><a id="more"></a><p>其中有一段内容提到，虚幻四已经不再将自己作为一款游戏开发引擎，而是定位成一个艺术创作和开发的平台，也就是说它不仅仅可以做游戏，同时可以用来出影视剧、国漫、特定素材等等，它已经将自己的势力范围扩张，变得丰富而强大，后来又提到虚幻五带来的种种提升。</p><p>什么？虚幻五已经出了，这是我之前不知道的，我知道今年 Redis 出了最新的 6.0 版本，MySQL 一跃发行了 8.0 版本，IOS 也更新到的 14.0.1 版本，似乎各种技术都在飞速的发展着，但是人的精力毕竟有限，很难把它们成长历程尽收眼底，一不留神就发现某种技术已经悄悄从你身边跨了过去。</p><h1 id="技术的发展"><a href="#技术的发展" class="headerlink" title="技术的发展"></a>技术的发展</h1><p>记得我第一篇博客记录的是处理 Ubuntu 黑屏的解决方案，我去翻了翻当时记录的版本是 12.04，时间已经过去了7年，Ubuntu 20.04 已经发行，当年解决黑屏的经验或许已经毫无用处。</p><p>10年接触的第一种计算机编程语言是 C 语言，当时开发环境是 Turbe C 2.0，后来使用 VC++6.0，接着就是VS系列，期间用过 Dev-C++、CodeBlocks等编辑器，但是 VS 还是用的最多的，直到目前使用的 VS2017，可是刚刚一个好学的小朋友问我 VS2019 相关的问题，我发现这款用了这么久的工具，之前一直无变化的菜单布局在 VS2019 版本上发生了改变。</p><p>之前一直号称单线程内存数据库 Redis 在今年5月份发布的 6.0 版本中，加入了网络多线程，使得整体性能提升近一倍，这被认为是 Redis 最大的一次改版。</p><p>MySQL 直接从 5.7 版本跳到了 8.0 版本，因为之前一直是 5.6 、5.7 这样的小版本提升，一跃跳到 8.0 一时让人好奇到底改了什么？其实 6.0 是一个过渡版本，而 7.0 是作为集群的保留版本，所以这次直接到了 8.0。其中一个亮点增加了 MySQL 文档存储，可以存储 json 格式，开始支持向 NoSQL 格式转化。</p><p>差点忘了C++，这个庞然大物目前已经从最开始的 C++98，发展到现在的 C++20，我在想它如果真的存活到 2098 年，应该怎么命名它呢？新标准的内容很长，需要慢慢来消化，可以发现一些很好玩的东西，比如三向比较运算符 <code>&lt;=&gt;</code>，也叫飞船运算符，感兴趣的可以去了解下。</p><p>经历的和未经历的变化还有很多，想好了再来补充。。。</p><h1 id="技术公司的发展"><a href="#技术公司的发展" class="headerlink" title="技术公司的发展"></a>技术公司的发展</h1><p>当年找工作的听说过的巨头就是 BAT，而今天晚上问一个即将毕业进入工作岗位的同学，哪些是他心目中的大厂，他给出了四个名字，“阿里、腾讯、字节、美团”，很明显百度已经掉队，但是瘦死的骆驼比马大，短时间内百度的技术底蕴不会消失殆尽，这些手握资源和技术的大厂很早就给自己挖好了护城河，一般企业很难追赶的上。</p><p>相比早期的 BAT，我感觉后来的字节、美团能够赶上他们实属不易，记得当年开玩笑说 TX 除了发明了一套钻石收费系统，其他的都是抄的，任何公司有了好点子，不是被他合并了就是被他抄走了，所以说能在某个它无法掌控的赛道上超越它也是非常厉害了。</p><p>有些东西是其他公司无法做到的，比如疫情期间的健康宝，每天上班、去商场、去公园都要看，都要打开微信和支付宝的APP，这个日活的数据放到其他任意一款软件上都是庞大的数字，可是他们就在这两大巨头这自然的发生着。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>技术每时每刻都在发展，有时你发现它陌生了，其实只是你关注的少了</li><li>好的赛道大多数已被别人占领，从夹缝中寻找到机会还需好好把握，才能做出一定的成绩</li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/108691877" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>年年岁岁花相似，岁岁年年人不同</p><p>2020-9-27 00:20:42</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;此篇非技术总结，但却与技术相关，写这篇总结的起因是前两天看了一节关于虚幻四的公开课，这节课也不是讲开发技术，更多的是讲创作艺术，课程开始前看到虚幻编辑器的画面，还是有一种很熟悉的感觉，毕竟使用了3年多的时间，外观几乎没有变化，使用方式依旧是原来的步骤，但随着课程的进行，我发现它变了。&lt;/p&gt;
    
    </summary>
    
      <category term="Thinking" scheme="http://AlbertGithubHome.github.io/blog/categories/Thinking/"/>
    
    
      <category term="技术" scheme="http://AlbertGithubHome.github.io/blog/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="计算机" scheme="http://AlbertGithubHome.github.io/blog/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
  </entry>
  
</feed>
