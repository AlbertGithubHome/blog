<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Albert World</title>
  <icon>https://www.gravatar.com/avatar/8ccc6291d5bfd34e7aaf601c4ebec7e1</icon>
  
  <link href="/blog/atom.xml" rel="self"/>
  
  <link href="http://AlbertGithubHome.github.io/blog/"/>
  <updated>2024-02-19T15:27:44.989Z</updated>
  <id>http://AlbertGithubHome.github.io/blog/</id>
  
  <author>
    <name>Albert Shi</name>
    <email>347070901@qq.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>在golang语言中简单使用protobuf时遭遇go_package困难重重</title>
    <link href="http://AlbertGithubHome.github.io/blog/2024/02/18/%E5%9C%A8golang%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8protobuf%E6%97%B6%E9%81%AD%E9%81%87go-package%E5%9B%B0%E9%9A%BE%E9%87%8D%E9%87%8D/"/>
    <id>http://AlbertGithubHome.github.io/blog/2024/02/18/在golang语言中简单使用protobuf时遭遇go-package困难重重/</id>
    <published>2024-02-18T13:00:00.000Z</published>
    <updated>2024-02-19T15:27:44.989Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Protobuf，全称Protocol Buffers，是一种由Google开发的用于序列化结构化数据的开源数据交换格式，Golang作为一种后端语言，免不了使用protobuf这种数据交换格式，本来打算写个小例子展示一下怎样在go语言中使用protobuf，结果遇到的问题到不少，特别是这个go_package的要求，也是之前在项目开发过程中遇到的，这次就查找一下具体原因以及怎么使用吧。</p><a id="more"></a><h1 id="编写示例"><a href="#编写示例" class="headerlink" title="编写示例"></a>编写示例</h1><p>为了能对这个示例有一个整体的轮廓，我先把编写好的目录结构展示一下，后面再逐步实现</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ tree lib_protobuf</span><br><span class="line">lib_protobuf</span><br><span class="line">├── go.mod</span><br><span class="line">├── go.sum</span><br><span class="line">├── lib_protobuf.go</span><br><span class="line">├── msgproto</span><br><span class="line">│   └── examplemsg.pb.go</span><br><span class="line">└── srcproto</span><br><span class="line">    └── examplemsg.proto</span><br></pre></td></tr></table></figure><p>简单解释下，<code>examplemsg.proto</code> proto源文件，<code>examplemsg.pb.go</code> 是proto导出文件，<code>lib_protobuf.go</code> 是proto协议使用和测试文件</p><h2 id="示例初始化"><a href="#示例初始化" class="headerlink" title="示例初始化"></a>示例初始化</h2><p>执行下面的命令，创建示例基础目录文件结构</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir lib_protobuf</span><br><span class="line">$ <span class="built_in">cd</span> lib_protobuf</span><br><span class="line">$ mkdir srcproto</span><br><span class="line">$ touch srcproto/examplremsg.proto</span><br><span class="line">$ touch lib_protobuf.go</span><br><span class="line">$ go mod init lib_protobuf</span><br><span class="line">go: creating new go.mod: module lib_protobuf</span><br><span class="line">go: to add module requirements and sums:</span><br><span class="line">        go mod tidy</span><br><span class="line"></span><br><span class="line">$ go mod tidy</span><br><span class="line">$ ls</span><br><span class="line">go.mod  lib_protobuf.go  srcproto</span><br></pre></td></tr></table></figure><h2 id="编写协议文件内容"><a href="#编写协议文件内容" class="headerlink" title="编写协议文件内容"></a>编写协议文件内容</h2><p>先编写proto文件，文件内容如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">"proto3"</span>;</span><br><span class="line"></span><br><span class="line">message Person &#123;</span><br><span class="line">    <span class="keyword">string</span> name = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int32</span> age = <span class="number">2</span>;</span><br><span class="line">    repeated <span class="keyword">string</span> hobbies = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个协议文件只定义了一个名为 <code>Person</code> 的结构，其中包括 <code>name</code> 、<code>age</code>、<code>hobbies</code> 三个字段</p><h2 id="导出协议文件"><a href="#导出协议文件" class="headerlink" title="导出协议文件"></a>导出协议文件</h2><p>这是本文的重点，至于怎么用proto文件定义结构，各个语言都是相通的，但是在导出时遇到 <code>go_package</code> 文件却是 golang 语言特有的，所以本文重点在这部分多花些篇幅，解释一下遇到的各种问题</p><h3 id="protoc-和-protoc-gen-go"><a href="#protoc-和-protoc-gen-go" class="headerlink" title="protoc 和 protoc-gen-go"></a>protoc 和 protoc-gen-go</h3><p>导出时需要是使用工具 <code>protoc</code>，而平时你可能听说过或者在.pb.go文件中看到过 <code>protoc-gen-go</code> 这个工具的名字，其实 <code>protoc-gen-go</code> 是一个用于生成 Go 代码的插件，它是 Protocol Buffers 编译器 <code>protoc</code> 的一部分。当您使用 <code>protoc</code> 编译 <code>.proto</code> 文件时，可以通过指定 <code>--go_out</code> 标志来指定要使用的 <code>protoc-gen-go</code> 插件，从而生成对应的 Go 代码文件。这个插件会根据 <code>.proto</code> 文件中定义的消息和服务等内容，生成与之对应的 Go 结构体、接口和方法等代码。因此，<code>protoc-gen-go</code> 和 <code>protoc</code> 是紧密相关的，它们共同用于将 Protocol Buffers 文件编译为 Go 语言中的数据结构和服务定义。</p><h3 id="执行导出命令"><a href="#执行导出命令" class="headerlink" title="执行导出命令"></a>执行导出命令</h3><p>使用<code>protoc</code>将proto文件导出golang可用的文件最重要的两个参数如下：</p><p><code>--proto_path</code>：proto源文件所在文件夹<br><code>--go_out</code>：proto文件导出的目标文件夹</p><p>执行命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> lib_protobuf</span><br><span class="line">$ protoc --proto_path=srcproto --go_out=. examplemsg.proto</span><br><span class="line">protoc-gen-go: unable to determine Go import path <span class="keyword">for</span> <span class="string">"examplemsg.proto"</span></span><br><span class="line"></span><br><span class="line">Please specify either:</span><br><span class="line">        • a <span class="string">"go_package"</span> option <span class="keyword">in</span> the .proto <span class="built_in">source</span> file, or</span><br><span class="line">        • a <span class="string">"M"</span> argument on the <span class="built_in">command</span> line.</span><br><span class="line"></span><br><span class="line">See https://developers.google.com/protocol-buffers/docs/reference/go-generated<span class="comment">#package for more information.</span></span><br><span class="line"></span><br><span class="line">--go_out: protoc-gen-go: Plugin failed with status code 1.</span><br></pre></td></tr></table></figure><p>不出意外的果然出意外了，告诉我不能确定 <code>examplemsg.proto</code> 文件的导入路径，换句话说就是现在这样不能导出一个可以被正常导入的包，有两种解决办法，第一种就是在.proto文件中添加 <code>go_package</code> 选项，第二种是在执行导出的命令行中添加<code>M</code>参数，详细的解释参考链接 <a href="https://developers.google.com/protocol-buffers/docs/reference/go-generated#package" target="_blank" rel="noopener">https://developers.google.com/protocol-buffers/docs/reference/go-generated#package</a></p><p>官方推荐是用第一种方式，也就是直接在.proto文件中添加 <code>go_package</code> 选项，假如我们这样写：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">option go_package = <span class="string">"msgproto"</span>;</span><br></pre></td></tr></table></figure><p>然后直接导出会遇到新的错误，提示”msgproto”并不是文件”examplemsg.proto”的一个有效的导入路径</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ protoc --proto_path=srcproto --go_out=. examplemsg.proto</span><br><span class="line">protoc-gen-go: invalid Go import path <span class="string">"msgproto"</span> <span class="keyword">for</span> <span class="string">"examplemsg.proto"</span></span><br><span class="line"></span><br><span class="line">The import path must contain at least one period (<span class="string">'.'</span>) or forward slash (<span class="string">'/'</span>) character.</span><br><span class="line"></span><br><span class="line">See https://developers.google.com/protocol-buffers/docs/reference/go-generated<span class="comment">#package for more information.</span></span><br><span class="line"></span><br><span class="line">--go_out: protoc-gen-go: Plugin failed with status code 1.</span><br></pre></td></tr></table></figure><p>要求必须至少包含一个 <code>.</code> 或者 <code>/</code>，那么把选项改成下面这样就可以了</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">option go_package = <span class="string">"./msgproto"</span>;</span><br></pre></td></tr></table></figure><p>有时为了在当前目录下生成，又要指定包名，可以写成这样：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">option go_package = <span class="string">"./;msgproto"</span>;</span><br></pre></td></tr></table></figure><p>使用分号将包路径和包名分开，但这种方法官方并不推荐，因为按照golang的包管理习惯，文件夹下的所有文件包名应该与文件名相同，通过包的路径能够推测是包名才对，否则写成 <code>option go_package = &quot;./msgprotoA;msgprotoB&quot;;</code> 就很奇怪了</p><p>关于go_package至少包含一个 <code>.</code> 或者 <code>/</code>的要求，据说v1.4.0以上的版本就要求必须加<code>/</code>了，最近查了一些资料，解释如下：</p><blockquote><p>在 Protocol Buffers（Protobuf）中，go_package 选项用于指定生成的 Go 代码的包名和导入路径。要求导入路径（import path）必须包含至少一个点（.）或正斜杠（/）的原因与 Go 语言的模块系统和包导入机制有关</p><p>这个要求是因为在导出时，<code>protoc</code> 需要能够将生成的代码文件放置在文件系统的适当位置，并且需要能够以合适的包路径来导入这些生成的代码。在大多数情况下，包路径应该具有与文件系统路径相对应的结构，因此至少需要包含一个句点（<code>.</code>）或正斜杠（<code>/</code>）字符来指示层次结构。</p><p>如果导入路径不包含这些字符，那么生成的代码文件将无法以合适的方式组织和导入，可能会导致编译器无法正确识别代码的位置和包结构。因此，为了确保生成的代码能够被正确导入和使用，<code>protoc</code> 对导入路径设置了这个最低要求。</p></blockquote><p>但是我觉得这个解释不能让人信服，我把go_package的值写成 <code>.msgproto</code>、<code>msgproto.</code> 或者 <code>..msgproto</code> 都是能正常导出的，并没有看到这种限制的好处，其中深层次的原因还得在今后的使用过程中慢慢体会了</p><h2 id="编写协议使用文件"><a href="#编写协议使用文件" class="headerlink" title="编写协议使用文件"></a>编写协议使用文件</h2><p>在文件 lib_protobuf.go 中编写如下内容，执行 <code>go mod tidy</code> 和 <code>go run .</code> 查看输出结果</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">"fmt"</span></span><br><span class="line">   <span class="string">"log"</span></span><br><span class="line"></span><br><span class="line">   msg <span class="string">"lib_protobuf/msgproto"</span></span><br><span class="line"></span><br><span class="line">   <span class="string">"google.golang.org/protobuf/proto"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   p := &amp;msg.Person&#123;</span><br><span class="line">      Name:    <span class="string">"Alice"</span>,</span><br><span class="line">      Age:     <span class="number">30</span>,</span><br><span class="line">      Hobbies: []<span class="keyword">string</span>&#123;<span class="string">"reading"</span>, <span class="string">"running"</span>&#125;,</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 序列化</span></span><br><span class="line">   data, err := proto.Marshal(p)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      log.Fatalf(<span class="string">"Failed to encode person: %v"</span>, err)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 反序列化</span></span><br><span class="line">   newP := &amp;msg.Person&#123;&#125;</span><br><span class="line">   err = proto.Unmarshal(data, newP)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      log.Fatalf(<span class="string">"Failed to decode person: %v"</span>, err)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   fmt.Println(<span class="string">"Original Person:"</span>, p)</span><br><span class="line">   fmt.Println(<span class="string">"Decoded Person:"</span>, newP)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ go run .</span><br><span class="line">Original Person: name:<span class="string">"Alice"</span>  age:30  hobbies:<span class="string">"reading"</span>  hobbies:<span class="string">"running"</span></span><br><span class="line">Decoded Person: name:<span class="string">"Alice"</span>  age:30  hobbies:<span class="string">"reading"</span>  hobbies:<span class="string">"running"</span></span><br></pre></td></tr></table></figure><h1 id="体会"><a href="#体会" class="headerlink" title="体会"></a>体会</h1><p>有关 <code>go_package</code> 值官方给出的示例是这种 <code>example.com/project/protos/fizz</code>，这就跟go.mod文件中的module定义一样，比如 <code>module github.com/tealeg/xlsx</code> 或 <code>module github.com/peterbourgon/diskv/v3</code>，提供的是一种导出之后的引用写法</p><p>但是 <code>go_package</code> 和 <code>module</code> 还确实有一些不同，因为它在导出时真的会根据 <code>go_package</code> 生成相应的路径，所以针对这些去情况我觉得一种比较好的写法是从项目根目录开始写，导出的目录也是根目录，这样在引用时直接写 <code>go_package</code> 就可以了，但是具体情况还需灵活应对</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">option go_package = <span class="string">"lib_protobuf/msgproto"</span>;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ lib_protobuf</span><br><span class="line">$ protoc --proto_path=srcproto --go_out=.. examplemsg.proto</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">"fmt"</span></span><br><span class="line">   <span class="string">"log"</span></span><br><span class="line"></span><br><span class="line">   msg <span class="string">"lib_protobuf/msgproto"</span></span><br><span class="line"></span><br><span class="line">   <span class="string">"google.golang.org/protobuf/proto"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>Protobuf是一种由Google开发的用于序列化结构化数据的开源数据交换格式</li><li>使用<code>protoc</code> 工具可以将 <code>.proto</code> 文件导出成golang可用的数据交换文件</li><li><code>protoc-gen-go</code> 是一个用于生成 Go 代码的插件，它是 Protocol Buffers 编译器 <code>protoc</code> 的一部分</li><li>.proto文件中的<code>go_package</code>选项的值至少需要包含一个 <code>.</code> 或者 <code>/</code></li><li><code>go_package</code> 的值官方给出的示例是这种类似module名的写法 <code>example.com/project/protos/fizz</code></li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/136074333" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>仰天大笑出门去，我辈岂是蓬蒿人。不好意思，我们绝大多数都是蓬蒿人，都是陪跑的NPC，只是在穷尽一生的努力想做一颗稍微不那么矮的蓬蒿而已~</p><p>2024-2-18 16:44:18</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;Protobuf，全称Protocol Buffers，是一种由Google开发的用于序列化结构化数据的开源数据交换格式，Golang作为一种后端语言，免不了使用protobuf这种数据交换格式，本来打算写个小例子展示一下怎样在go语言中使用protobuf，结果遇到的问题到不少，特别是这个go_package的要求，也是之前在项目开发过程中遇到的，这次就查找一下具体原因以及怎么使用吧。&lt;/p&gt;
    
    </summary>
    
      <category term="Go" scheme="http://AlbertGithubHome.github.io/blog/categories/Go/"/>
    
    
      <category term="开发语言" scheme="http://AlbertGithubHome.github.io/blog/tags/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/"/>
    
      <category term="golang" scheme="http://AlbertGithubHome.github.io/blog/tags/golang/"/>
    
      <category term="protobuf" scheme="http://AlbertGithubHome.github.io/blog/tags/protobuf/"/>
    
      <category term="protoc" scheme="http://AlbertGithubHome.github.io/blog/tags/protoc/"/>
    
      <category term="go_package" scheme="http://AlbertGithubHome.github.io/blog/tags/go-package/"/>
    
  </entry>
  
  <entry>
    <title>简单聊聊go语言中引用模块的版本控制以及invalid: should be v0 or v1, not v2问题的解决</title>
    <link href="http://AlbertGithubHome.github.io/blog/2024/02/09/%E7%AE%80%E5%8D%95%E8%81%8A%E8%81%8Ago%E8%AF%AD%E8%A8%80%E4%B8%AD%E5%BC%95%E7%94%A8%E6%A8%A1%E5%9D%97%E7%9A%84%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E4%BB%A5%E5%8F%8Ainvalid-should-be-v0-or-v1-not-v2%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3/"/>
    <id>http://AlbertGithubHome.github.io/blog/2024/02/09/简单聊聊go语言中引用模块的版本控制以及invalid-should-be-v0-or-v1-not-v2问题的解决/</id>
    <published>2024-02-08T16:45:00.000Z</published>
    <updated>2024-02-19T15:25:15.277Z</updated>
    
    <content type="html"><![CDATA[<p>@[toc]</p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>如果你接触go语言比较早，一定有过当年所有go源码全部放入 <code>GOPATH</code> 下的混乱经历，不过发展到今天，go的包管理使用 <code>go.mod</code> 和 <code>go.work</code> 已经能得心应手，满足绝大多数的开发不成问题，其实在 <code>go.mod</code> 引入之后，go的包管理就有了明显的改善，再也不像原来那样好似闹着玩一样了，关于go.mod使用和管理我也是一知半解，想要教程可去官网或者查找各种详解资料，只是最近有点疑惑，这个go.mod以及go.sum要不要自己手动管理，带着这个疑问我做了一些测试可以得出，go.mod 的最初不需要手动管理，如果后来需要调整引入包的版本，可以手动调整。</p><a id="more"></a><p>以下是来自ChatGPT的关于 <code>go.mod</code> 和 <code>go.sum</code> 作用的回答，还是比较清晰的，如果还不太明白可以看看后面的例子感受一下</p><blockquote><p><code>go.mod</code> 和 <code>go.sum</code> 文件是 Go Modules 的重要组成部分，用于管理项目的依赖关系。共同为 Go 项目提供了依赖管理的基础，确保了项目的稳定性和可维护性：</p><ol><li><p><strong>go.mod</strong>：</p><ul><li>定义了项目的模块信息，包括模块名称、版本和依赖项等。</li><li>确定了项目的模块根目录。</li><li>记录了项目所依赖的其他模块及其版本信息。</li><li>提供了一种清晰的方式来管理项目的依赖关系，使得项目的构建和维护更加可靠和可控。</li></ul></li><li><p><strong>go.sum</strong>：</p><ul><li>记录了每个依赖模块的哈希值，以保证项目的构建是可复现的。</li><li>确保了项目依赖项的完整性，防止恶意篡改或不完整的依赖项被用于构建项目。</li><li>当使用 <code>go mod verify</code> 命令时，<code>go.sum</code> 文件会被用来验证依赖项的完整性。</li></ul></li></ol></blockquote><p>&gt;</p><blockquote><p>通常情况下，<code>go.mod</code> 文件是由 <code>go</code> 工具自动生成和管理的，不需要手动修改。当你执行一些与模块相关的操作时（例如使用 <code>go get</code> 安装新的依赖、使用 <code>go mod tidy</code> 整理依赖、或者更新依赖版本等），<code>go</code> 工具会自动更新 <code>go.mod</code> 文件以反映这些变化，但是，在某些特定情况下，你可能需要手动编辑 <code>go.mod</code> 文件，例如：</p><ol><li><p>手动添加或删除依赖项：你可能希望手动添加新的依赖项，或者删除不再需要的依赖项。在这种情况下，你需要手动编辑 <code>go.mod</code> 文件，并执行 <code>go mod tidy</code> 命令以确保依赖关系的一致性。</p></li><li><p>手动指定依赖版本：有时你可能希望显式地指定某个依赖项的特定版本。在这种情况下，你需要编辑 <code>go.mod</code> 文件，并指定对应的版本号。</p></li></ol><p>总的来说，虽然 <code>go.mod</code> 文件通常是由 <code>go</code> 工具自动维护的，但在某些情况下手动编辑是必要的。在编辑 <code>go.mod</code> 文件时，确保遵循 Go 模块的规范，并注意保持文件的格式正确和依赖关系的一致性。</p></blockquote><h1 id="具体示例"><a href="#具体示例" class="headerlink" title="具体示例"></a>具体示例</h1><p>假设有一个需求，要读取 <code>.xlsx</code> 格式表格文件的所有页签名，解析Excel文件这么基础的工作肯定有人写好了，我们直接引入module不需要重新再写一遍了，我们新建一个包含go.mod的工程来使用它</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir lib_xlsx</span><br><span class="line">$ <span class="built_in">cd</span> lib_xlsx</span><br><span class="line">$ go mod init lib_xlsx</span><br><span class="line">go: creating new go.mod: module lib_xlsx</span><br><span class="line"></span><br><span class="line">$ touch lib_xlsx.go</span><br><span class="line">$ ls</span><br><span class="line">go.mod  lib_xlsx.go</span><br></pre></td></tr></table></figure><p>go.mod的初始文件内容为</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">module lib_xlsx</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="number">1.19</span></span><br></pre></td></tr></table></figure><p>打开 <code>lib_xlsx.go</code> 文件编写如下代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">"fmt"</span></span><br><span class="line">   <span class="string">"log"</span></span><br><span class="line"></span><br><span class="line">   <span class="string">"github.com/tealeg/xlsx"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">   xlFile, err := xlsx.OpenFile(<span class="string">"example.xlsx"</span>)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      log.Fatalf(<span class="string">"Error opening file: %s"</span>, err)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> _, sheet := <span class="keyword">range</span> xlFile.Sheets &#123;</span><br><span class="line">      fmt.Println(<span class="string">"Sheet Name:"</span>, sheet.Name)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码是不是很简单，此时不出意外IDE会提醒你 <code>could not import github.com/tealeg/xlsx</code> 的错误，因为我们还没下载这个包，只需要在命令行执行 <code>go get github.com/tealeg/xlsx</code> 既可下载，同时会自动更新 <code>go.mod</code> 和 <code>go.sum</code> 文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ go get github.com/tealeg/xlsx</span><br><span class="line">go: added github.com/tealeg/xlsx v1.0.5</span><br></pre></td></tr></table></figure><p>自动更新后的 go.mod 文件内容，引用了 <code>github.com/tealeg/xlsx</code> 库的 <code>v1.0.5</code> 版本</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">module lib_xlsx</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="number">1.19</span></span><br><span class="line"></span><br><span class="line">require github.com/tealeg/xlsx v1<span class="number">.0</span><span class="number">.5</span></span><br></pre></td></tr></table></figure><p>自动更新后的 go.sum 文件内容，记录了各个依赖库、间接依赖库以及项目go.mod文件的hash值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">github.com/kr/pretty v0<span class="number">.1</span><span class="number">.0</span> h1:L/CwN0zerZDmRFUapSPitk6f+Q3+<span class="number">0</span>za1rQkzVuMiMFI=</span><br><span class="line">github.com/kr/pretty v0<span class="number">.1</span><span class="number">.0</span>/<span class="keyword">go</span>.mod h1:dAy3ld7l9f0ibDNOQOHHMYYIIbhfbHSm3C4ZsoJORNo=</span><br><span class="line">github.com/kr/pty v1<span class="number">.1</span><span class="number">.1</span>/<span class="keyword">go</span>.mod h1:pFQYn66WHrOpPYNljwOMqo10TkYh1fy3cYio2l3bCsQ=</span><br><span class="line">github.com/kr/text v0<span class="number">.1</span><span class="number">.0</span> h1:<span class="number">45s</span>CR5RtlFHMR4UwH9sdQ5TC8v0qDQCHnXt+kaKSTVE=</span><br><span class="line">github.com/kr/text v0<span class="number">.1</span><span class="number">.0</span>/<span class="keyword">go</span>.mod h1:<span class="number">4</span>Jbv+DJW3UT/LiOwJeYQe1efqtUx/iVham/<span class="number">4</span>vfdArNI=</span><br><span class="line">github.com/tealeg/xlsx v1<span class="number">.0</span><span class="number">.5</span> h1:+f8oFmvY8Gw1iUXzPk+kz+<span class="number">4</span>GpbDZPK1FhPiQRd+ypgE=</span><br><span class="line">github.com/tealeg/xlsx v1<span class="number">.0</span><span class="number">.5</span>/<span class="keyword">go</span>.mod h1:btRS8dz54TDnvKNosuAqxrM1QgN1udgk9O34bDCnORM=</span><br><span class="line">gopkg.in/check.v1 v1<span class="number">.0</span><span class="number">.0</span><span class="number">-20190902080502</span><span class="number">-41f</span>04d3bba15 h1:YR8cESwS4TdDjEe65xsg0ogRM/Nc3DYOhEAlW+xobZo=</span><br><span class="line">gopkg.in/check.v1 v1<span class="number">.0</span><span class="number">.0</span><span class="number">-20190902080502</span><span class="number">-41f</span>04d3bba15/<span class="keyword">go</span>.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=</span><br></pre></td></tr></table></figure><p>此时程序已经写完，依赖关系也已经下载好了，直接运行就可以</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ go run .</span><br><span class="line">Sheet Name: Sheet1</span><br><span class="line">Sheet Name: Sheet2</span><br><span class="line">Sheet Name: Sheet3</span><br></pre></td></tr></table></figure><p>因为 <code>go.mod</code> 和 <code>go.sum</code> 文件共同为这个项目提供了依赖管理，别人在下载你这份<a href="https://github.com/AlbertGithubHome/go/tree/master/lib_xlsx" target="_blank" rel="noopener">源码</a>时，先执行 <code>go mod tidy</code> 根据依赖关系下载正确的版本库，之后就可以直接编译运行了</p><h1 id="手动升级依赖库"><a href="#手动升级依赖库" class="headerlink" title="手动升级依赖库"></a>手动升级依赖库</h1><p>到目前为止，我们并没有手动编辑过 go.mod 文件，只是在使用 <code>go get github.com/tealeg/xlsx</code> 自动更新了这个文件，假设这个例子的需求要扩展，引用的 <code>github.com/tealeg/xlsx</code> 功能是在<code>v1.0.6</code> 版本新加的，那么我么只需要将 <code>go.mod</code> 文件中的 <code>v1.0.5</code> 替换成 <code>v1.0.6</code>，然后执行 <code>go mod tidy</code> 即可下载正确的依赖库。</p><p>但如果要引用的依赖库版本不是 <code>v0</code> 或者 <code>v1</code> 版本的就不能这么处理了，具体做法看下面的问题。</p><h1 id="should-be-v0-or-v1-not-v2"><a href="#should-be-v0-or-v1-not-v2" class="headerlink" title="should be v0 or v1, not v2"></a>should be v0 or v1, not v2</h1><p>当你手动把 <code>go.mod</code> 文件中的 <code>v1.0.5</code> 替换成 <code>v2.x.x</code> 执行 <code>go mod tidy</code> 时就会报一个错误</p><blockquote><p>errors parsing go.mod: /xxx/lib_xlsx/go.mod:5: require github.com/tealeg/xlsx: version “v2.0.0” invalid: should be v0 or v1, not v2</p></blockquote><p>问题的原因及细节可以参考这篇文档<a href="https://mileslin.github.io/2020/08/Golang/%E5%88%B0%E5%BA%95-go-get-%E7%9A%84%E7%89%88%E8%99%9F%E6%80%8E%E9%BA%BC%E9%81%8B%E4%BD%9C%E7%9A%84/" target="_blank" rel="noopener">《[Go] 到底 go get 的版號怎麼運作的?》</a>中关于“Semantic import version”的描述</p><p>复杂的原因简单说：Go有一个规范，就是在启用了Go Module的仓库上如果想使用 v2 及以上版本，需要在原引用库上添加版本标识简写，比如这个例子中，我们需要将 <code>lib_xlsx.go</code> 文件中引用包的代码改成下面这样</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">"fmt"</span></span><br><span class="line">   <span class="string">"log"</span></span><br><span class="line"></span><br><span class="line">   <span class="string">"github.com/tealeg/xlsx/v3"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>执行 <code>go mod tidy</code> 命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ go mod tidy</span><br><span class="line">go: finding module <span class="keyword">for</span> package github.com/tealeg/xlsx/v3</span><br><span class="line">go: found github.com/tealeg/xlsx/v3 <span class="keyword">in</span> github.com/tealeg/xlsx/v3 v3.3.5</span><br></pre></td></tr></table></figure><p>如果遇到下面这个问题，确认修改无误的话多尝试几次</p><blockquote><p>$ go mod tidy<br>go: finding module for package github.com/tealeg/xlsx/v3<br>lib_xlsx imports<br>       github.com/tealeg/xlsx/v3: module github.com/tealeg/xlsx/v3: Get “<a href="https://proxy.golang.org/github.com/tealeg/xlsx/v3/@v/list" target="_blank" rel="noopener">https://proxy.golang.org/github.com/tealeg/xlsx/v3/@v/list</a>“: EOF</p></blockquote><p>执行过后 go.mod 和 go.sum 两个文件改变后的内容如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">module lib_xlsx</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="number">1.19</span></span><br><span class="line"></span><br><span class="line">require github.com/tealeg/xlsx/v3 v3<span class="number">.3</span><span class="number">.5</span></span><br><span class="line"></span><br><span class="line">require (</span><br><span class="line">   github.com/frankban/quicktest v1<span class="number">.14</span><span class="number">.6</span> <span class="comment">// indirect</span></span><br><span class="line">   github.com/google/btree v1<span class="number">.0</span><span class="number">.0</span> <span class="comment">// indirect</span></span><br><span class="line">   github.com/google/<span class="keyword">go</span>-cmp v0<span class="number">.5</span><span class="number">.9</span> <span class="comment">// indirect</span></span><br><span class="line">   github.com/kr/pretty v0<span class="number">.3</span><span class="number">.1</span> <span class="comment">// indirect</span></span><br><span class="line">   github.com/kr/text v0<span class="number">.2</span><span class="number">.0</span> <span class="comment">// indirect</span></span><br><span class="line">   github.com/peterbourgon/diskv/v3 v3<span class="number">.0</span><span class="number">.1</span> <span class="comment">// indirect</span></span><br><span class="line">   github.com/rogpeppe/fastuuid v1<span class="number">.2</span><span class="number">.0</span> <span class="comment">// indirect</span></span><br><span class="line">   github.com/rogpeppe/<span class="keyword">go</span>-internal v1<span class="number">.9</span><span class="number">.0</span> <span class="comment">// indirect</span></span><br><span class="line">   github.com/shabbyrobe/xmlwriter v0<span class="number">.0</span><span class="number">.0</span><span class="number">-20200208144257</span><span class="number">-9f</span>ca06d00ffa <span class="comment">// indirect</span></span><br><span class="line">   golang.org/x/text v0<span class="number">.3</span><span class="number">.8</span> <span class="comment">// indirect</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">github.com/creack/pty v1<span class="number">.1</span><span class="number">.9</span>/<span class="keyword">go</span>.mod h1:oKZEueFk5CKHvIhNR5MUki03XCEU+Q6VDXinZuGJ33E=</span><br><span class="line">github.com/frankban/quicktest v1<span class="number">.14</span><span class="number">.6</span> h1:<span class="number">7</span>Xjx+VpznH+oBnejlPUj8oUpdxnVs4f8XU8WnHkI4W8=</span><br><span class="line">github.com/frankban/quicktest v1<span class="number">.14</span><span class="number">.6</span>/<span class="keyword">go</span>.mod h1:<span class="number">4</span>ptaffx2x8+WTWXmUCuVU6aPUX1/Mz7zb5vbUoiM6w0=</span><br><span class="line">github.com/google/btree v1<span class="number">.0</span><span class="number">.0</span> h1:<span class="number">0</span>udJVsspx3VBr5FwtLhQQtuAsVc79tTq0ocGIPAU6qo=</span><br><span class="line">github.com/google/btree v1<span class="number">.0</span><span class="number">.0</span>/<span class="keyword">go</span>.mod h1:lNA+<span class="number">9</span>X1NB3Zf8V7Ke586lFgjr2dZNuvo3lPJSGZ5JPQ=</span><br><span class="line">github.com/google/<span class="keyword">go</span>-cmp v0<span class="number">.5</span><span class="number">.9</span> h1:O2Tfq5qg4qc4AmwVlvv0oLiVAGB7enBSJ2x2DqQFi38=</span><br><span class="line">github.com/google/<span class="keyword">go</span>-cmp v0<span class="number">.5</span><span class="number">.9</span>/<span class="keyword">go</span>.mod h1:<span class="number">17d</span>UlkBOakJ0+DkrSSNjCkIjxS6bF9zb3elmeNGIjoY=</span><br><span class="line">github.com/kr/pretty v0<span class="number">.3</span><span class="number">.1</span> h1:flRD4NNwYAUpkphVc1HcthR4KEIFJ65n8Mw5qdRn3LE=</span><br><span class="line">github.com/kr/pretty v0<span class="number">.3</span><span class="number">.1</span>/<span class="keyword">go</span>.mod h1:hoEshYVHaxMs3cyo3Yncou5ZscifuDolrwPKZanG3xk=</span><br><span class="line">github.com/kr/text v0<span class="number">.2</span><span class="number">.0</span> h1:<span class="number">5</span>Nx0Ya0ZqY2ygV366QzturHI13Jq95ApcVaJBhpS+AY=</span><br><span class="line">github.com/kr/text v0<span class="number">.2</span><span class="number">.0</span>/<span class="keyword">go</span>.mod h1:eLer722TekiGuMkidMxC/pM04lWEeraHUUmBw8l2grE=</span><br><span class="line">github.com/niemeyer/pretty v0<span class="number">.0</span><span class="number">.0</span><span class="number">-20200227124842</span>-a10e7caefd8e h1:fD57ERR4JtEqsWbfPhv4DMiApHyliiK5xCTNVSPiaAs=</span><br><span class="line">github.com/peterbourgon/diskv/v3 v3<span class="number">.0</span><span class="number">.1</span> h1:x06SQA46+PKIUftmEujdwSEpIx8kR+M9eLYsUxeYveU=</span><br><span class="line">github.com/peterbourgon/diskv/v3 v3<span class="number">.0</span><span class="number">.1</span>/<span class="keyword">go</span>.mod h1:kJ5Ny7vLdARGU3WUuy6uzO6T0nb/<span class="number">2</span>gWcT1JiBvRmb5o=</span><br><span class="line">github.com/pkg/diff v0<span class="number">.0</span><span class="number">.0</span><span class="number">-20210226163009</span><span class="number">-20</span>ebb0f2a09e/<span class="keyword">go</span>.mod h1:pJLUxLENpZxwdsKMEsNbx1VGcRFpLqf3715MtcvvzbA=</span><br><span class="line">github.com/pkg/profile v1<span class="number">.5</span><span class="number">.0</span> h1:<span class="number">042</span>Buzk+NhDI+DeSAA62RwJL8VAuZUMQZUjCsRz1Mug=</span><br><span class="line">github.com/rogpeppe/fastuuid v1<span class="number">.2</span><span class="number">.0</span> h1:Ppwyp6VYCF1nvBTXL3trRso7mXMlRrw9ooo375wvi2s=</span><br><span class="line">github.com/rogpeppe/fastuuid v1<span class="number">.2</span><span class="number">.0</span>/<span class="keyword">go</span>.mod h1:jVj6XXZzXRy/MSR5jhDC/<span class="number">2</span>q6DgLz+nrA6LYCDYWNEvQ=</span><br><span class="line">github.com/rogpeppe/<span class="keyword">go</span>-internal v1<span class="number">.9</span><span class="number">.0</span> h1:<span class="number">73</span>kH8U+JUqXU8lRuOHeVHaa/SZPifC7BkcraZVejAe8=</span><br><span class="line">github.com/rogpeppe/<span class="keyword">go</span>-internal v1<span class="number">.9</span><span class="number">.0</span>/<span class="keyword">go</span>.mod h1:WtVeX8xhTBvf0smdhujwtBcq4Qrzq/fJaraNFVN+nFs=</span><br><span class="line">github.com/shabbyrobe/xmlwriter v0<span class="number">.0</span><span class="number">.0</span><span class="number">-20200208144257</span><span class="number">-9f</span>ca06d00ffa h1:<span class="number">2</span>cO3RojjYl3hVTbEvJVqrMaFmORhL6O06qdW42toftk=</span><br><span class="line">github.com/shabbyrobe/xmlwriter v0<span class="number">.0</span><span class="number">.0</span><span class="number">-20200208144257</span><span class="number">-9f</span>ca06d00ffa/<span class="keyword">go</span>.mod h1:Yjr3bdWaVWyME1kha7X0jsz3k2DgXNa1Pj3XGyUAbx8=</span><br><span class="line">github.com/tealeg/xlsx/v3 v3<span class="number">.3</span><span class="number">.5</span> h1:dzmns01jRf0SveBe7VqkcO2LCLOcypcDI6H66PiZycQ=</span><br><span class="line">github.com/tealeg/xlsx/v3 v3<span class="number">.3</span><span class="number">.5</span>/<span class="keyword">go</span>.mod h1:KV4FTFtvGy0TBlOivJLZu/YNZk6e0Qtk7eOSglWksuA=</span><br><span class="line">golang.org/x/text v0<span class="number">.3</span><span class="number">.2</span>/<span class="keyword">go</span>.mod h1:bEr9sfX3Q8Zfm5fL9x+<span class="number">3i</span>togRgK3+ptLWKqgva+<span class="number">5d</span>Ak=</span><br><span class="line">golang.org/x/text v0<span class="number">.3</span><span class="number">.8</span> h1:nAL+RVCQ9uMn3vJZbV+MRnydTJFPf8qqY42YiA6MrqY=</span><br><span class="line">golang.org/x/text v0<span class="number">.3</span><span class="number">.8</span>/<span class="keyword">go</span>.mod h1:E6s5w1FMmriuDzIBO73fBruAKo1PCIq6d2Q6DHfQ8WQ=</span><br><span class="line">golang.org/x/tools v0<span class="number">.0</span><span class="number">.0</span><span class="number">-20180917221912</span><span class="number">-90f</span>a682c2a6e/<span class="keyword">go</span>.mod h1:n7NCudcB/nEzxVGmLbDWY5pfWTLqBcC2KZ6jyYvM4mQ=</span><br><span class="line">gopkg.in/check.v1 v1<span class="number">.0</span><span class="number">.0</span><span class="number">-20200902074654</span><span class="number">-038f</span>dea0a05b h1:QRR6H1YWRnHb4Y/HeNFCTJLFVxaq6wH4YuVdsUOr75U=</span><br></pre></td></tr></table></figure><p>将 github.com/tealeg/xlsx 从 <code>v1.0.5</code> 升级到 <code>v3.3.5</code> 真是加了不少间接依赖库啊</p><p>至此 go.mod 文件的自动更新和手动维护我们就都尝试过了</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li><code>go.mod</code> 和 <code>go.sum</code> 文件是 Go Modules 的重要组成部分，用于管理项目的依赖关系</li><li><code>go.mod</code> 文件是由 <code>go</code> 工具自动生成和管理的，不需要手动修改，常用命令 <code>go get xxx</code> 和 <code>go mod tidy</code></li><li>如果想显式地指定某个依赖项的特定版本才需要手动编辑 <code>go.mod</code> 文件</li><li><code>go.sum</code> 文件记录了每个依赖模块的哈希值，以保证项目的构建是可复现的</li><li>如果在启用了Go Module的仓库想使用 v2 及以上版本，需要在原引用库路径末尾添加版本标识简写，比如v2、v3等</li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/135922149" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>穷则独善其身，达则兼济天下，如今在这纷繁的世间，独善其身已实属不易，天下交给你们，我自顺其自然吧~</p><p>2024-2-8 15:59:19</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;@[toc]&lt;/p&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;如果你接触go语言比较早，一定有过当年所有go源码全部放入 &lt;code&gt;GOPATH&lt;/code&gt; 下的混乱经历，不过发展到今天，go的包管理使用 &lt;code&gt;go.mod&lt;/code&gt; 和 &lt;code&gt;go.work&lt;/code&gt; 已经能得心应手，满足绝大多数的开发不成问题，其实在 &lt;code&gt;go.mod&lt;/code&gt; 引入之后，go的包管理就有了明显的改善，再也不像原来那样好似闹着玩一样了，关于go.mod使用和管理我也是一知半解，想要教程可去官网或者查找各种详解资料，只是最近有点疑惑，这个go.mod以及go.sum要不要自己手动管理，带着这个疑问我做了一些测试可以得出，go.mod 的最初不需要手动管理，如果后来需要调整引入包的版本，可以手动调整。&lt;/p&gt;
    
    </summary>
    
      <category term="Go" scheme="http://AlbertGithubHome.github.io/blog/categories/Go/"/>
    
    
      <category term="Go" scheme="http://AlbertGithubHome.github.io/blog/tags/Go/"/>
    
      <category term="mod" scheme="http://AlbertGithubHome.github.io/blog/tags/mod/"/>
    
      <category term="import" scheme="http://AlbertGithubHome.github.io/blog/tags/import/"/>
    
      <category term="xlsx" scheme="http://AlbertGithubHome.github.io/blog/tags/xlsx/"/>
    
      <category term="依赖库版本" scheme="http://AlbertGithubHome.github.io/blog/tags/%E4%BE%9D%E8%B5%96%E5%BA%93%E7%89%88%E6%9C%AC/"/>
    
  </entry>
  
  <entry>
    <title>使用nslookup命令查询域名系统的信息</title>
    <link href="http://AlbertGithubHome.github.io/blog/2024/01/29/%E4%BD%BF%E7%94%A8nslookup%E5%91%BD%E4%BB%A4%E6%9F%A5%E8%AF%A2%E5%9F%9F%E5%90%8D%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BF%A1%E6%81%AF/"/>
    <id>http://AlbertGithubHome.github.io/blog/2024/01/29/使用nslookup命令查询域名系统的信息/</id>
    <published>2024-01-29T14:11:51.000Z</published>
    <updated>2024-02-19T15:22:29.280Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这个命令出现在与运维同学沟通过程中，在此之前要是问我一个域名对应的服务器是IP地址是什么，我肯定优先想到的是 <code>ping</code> 这个命令，这个命令确实可以在回复的信息中看到IP地址，但是不全面，有时一个域名对应不止一个IP地址，这时就要用到 nslookup 命令了，这也是在沟通中学到的新知识点。</p><a id="more"></a><h1 id="常规使用"><a href="#常规使用" class="headerlink" title="常规使用"></a>常规使用</h1><p>学这个命令就是拿来用的，最常见的用法就是 <code>nslookup 域名</code> 来查询域名对应的IP，并且这个用法在Windows(cmd)、Mac、Linux下都是通用的，算是一个不错的跨平台命令，对比一下 <code>ping</code> 看看有什么区别：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\Administrator&gt;ping a1.easemob.com</span><br><span class="line"></span><br><span class="line">正在 Ping a1-v2.easemob.com.x.easeslb.com [47.93.162.59] 具有 32 字节的数据:</span><br><span class="line">来自 47.93.162.59 的回复: 字节=32 时间=7ms TTL=88</span><br><span class="line">来自 47.93.162.59 的回复: 字节=32 时间=7ms TTL=88</span><br><span class="line">来自 47.93.162.59 的回复: 字节=32 时间=6ms TTL=88</span><br><span class="line">来自 47.93.162.59 的回复: 字节=32 时间=6ms TTL=88</span><br><span class="line"></span><br><span class="line">47.93.162.59 的 Ping 统计信息:</span><br><span class="line">    数据包: 已发送 = 4，已接收 = 4，丢失 = 0 (0% 丢失)，</span><br><span class="line">往返行程的估计时间(以毫秒为单位):</span><br><span class="line">    最短 = 6ms，最长 = 7ms，平均 = 6ms</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\Administrator&gt;nslookup a1.easemob.com</span><br><span class="line">服务器:  UnKnown</span><br><span class="line">Address:  10.20.30.40</span><br><span class="line"></span><br><span class="line">名称:    a1-v2.easemob.com.x.easeslb.com</span><br><span class="line">Addresses:  2408:4000:200::c5</span><br><span class="line">          2408:4000:200::17</span><br><span class="line">          47.93.162.59</span><br><span class="line">          39.97.9.52</span><br><span class="line">Aliases:  a1.easemob.com</span><br></pre></td></tr></table></figure><p>以上都是在cmd下执行的，如果在PowerShell中有一个名叫 <code>Resolve-DnsName</code> 的替代命令，执行结果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\Administrator&gt; Resolve-DnsName a1.easemob.com</span><br><span class="line"></span><br><span class="line">Name                           Type   TTL   Section    NameHost</span><br><span class="line">----                           ----   ---   -------    --------</span><br><span class="line">a1.easemob.com                 CNAME  0     Answer     a1-v2.easemob.com.x.easeslb.com</span><br><span class="line"></span><br><span class="line">Name       : a1-v2.easemob.com.x.easeslb.com</span><br><span class="line">QueryType  : AAAA</span><br><span class="line">TTL        : 0</span><br><span class="line">IP6Address : 2408:4000:200::17</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Name       : a1-v2.easemob.com.x.easeslb.com</span><br><span class="line">QueryType  : AAAA</span><br><span class="line">TTL        : 0</span><br><span class="line">Section    : Answer</span><br><span class="line">IP6Address : 2408:4000:200::c5</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">QueryType  : A</span><br><span class="line">TTL        : 0</span><br><span class="line">Section    : Answer</span><br><span class="line">IP4Address : 47.93.162.59</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Name       : a1-v2.easemob.com.x.easeslb.com</span><br><span class="line">QueryType  : A</span><br><span class="line">TTL        : 0</span><br><span class="line">Section    : Answer</span><br><span class="line">IP4Address : 39.97.9.213</span><br></pre></td></tr></table></figure><p>对于上述 <code>Resolve-DnsName</code> 命令的输出的结果解释如下：</p><ol><li><p><strong>CNAME 记录：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a1.easemob.com                 CNAME  0     Answer     a1-v2.easemob.com.x.easeslb.com</span><br></pre></td></tr></table></figure><p>这一行表示 <code>a1.easemob.com</code> 是一个别名（CNAME）记录，指向了 <code>a1-v2.easemob.com.x.easeslb.com</code>。</p></li><li><p><strong>AAAA 记录（IPv6 地址）：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Name       : a1-v2.easemob.com.x.easeslb.com</span><br><span class="line">QueryType  : AAAA</span><br><span class="line">TTL        : 0</span><br><span class="line">Section    : Answer</span><br><span class="line">IP6Address : 2408:4000:200::17</span><br></pre></td></tr></table></figure><p>这一行表示 <code>a1-v2.easemob.com.x.easeslb.com</code> 对应的 IPv6 地址是 <code>2408:4000:200::17</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Name       : a1-v2.easemob.com.x.easeslb.com</span><br><span class="line">QueryType  : AAAA</span><br><span class="line">TTL        : 0</span><br><span class="line">Section    : Answer</span><br><span class="line">IP6Address : 2408:4000:200::c5</span><br></pre></td></tr></table></figure><p>这一行表示 <code>a1-v2.easemob.com.x.easeslb.com</code> 对应的另一个 IPv6 地址是 <code>2408:4000:200::c5</code>。</p></li><li><p><strong>A 记录（IPv4 地址）：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Name       : a1-v2.easemob.com.x.easeslb.com</span><br><span class="line">QueryType  : A</span><br><span class="line">TTL        : 0</span><br><span class="line">Section    : Answer</span><br><span class="line">IP4Address : 47.93.162.59</span><br></pre></td></tr></table></figure><p>这一行表示 <code>a1-v2.easemob.com.x.easeslb.com</code> 对应的 IPv4 地址是 <code>47.93.162.59</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Name       : a1-v2.easemob.com.x.easeslb.com</span><br><span class="line">QueryType  : A</span><br><span class="line">TTL        : 0</span><br><span class="line">Section    : Answer</span><br><span class="line">IP4Address : 39.97.9.213</span><br></pre></td></tr></table></figure><p>这一行表示 <code>a1-v2.easemob.com.x.easeslb.com</code> 对应的另一个 IPv4 地址是 <code>39.97.9.213</code>。</p></li></ol><p>综上所述，查询结果显示了域名 <code>a1.easemob.com</code> 的别名记录（CNAME）以及对应的IPv6和IPv4地址。IPv6地址有两个，分别是 <code>2408:4000:200::17</code> 和 <code>2408:4000:200::c5</code>，而IPv4地址有两个，分别是 <code>47.93.162.59</code> 和 <code>39.97.9.213</code>。</p><h1 id="再从linux环境下学点不一样的"><a href="#再从linux环境下学点不一样的" class="headerlink" title="再从linux环境下学点不一样的"></a>再从linux环境下学点不一样的</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ nslookup a1.easemob.com</span><br><span class="line">Server:         127.0.0.53</span><br><span class="line">Address:        127.0.0.53<span class="comment">#53</span></span><br><span class="line"></span><br><span class="line">Non-authoritative answer:</span><br><span class="line">a1.easemob.com  canonical name = a1-v2.easemob.com.x.easeslb.com.</span><br><span class="line">Name:   a1-v2.easemob.com.x.easeslb.com</span><br><span class="line">Address: 39.97.9.213</span><br><span class="line">Name:   a1-v2.easemob.com.x.easeslb.com</span><br><span class="line">Address: 47.93.162.59</span><br><span class="line">Name:   a1-v2.easemob.com.x.easeslb.com</span><br><span class="line">Address: 2408:4000:200::17</span><br><span class="line">Name:   a1-v2.easemob.com.x.easeslb.com</span><br><span class="line">Address: 2408:4000:200::c5</span><br></pre></td></tr></table></figure><p>在linux环境下使用基础命令，还在cmd环境下的输出结果类似，但是比<code>Resolve-DnsName</code>命令输出的结果要简陋许多，但是可以通过添加参数来扩展命令。</p><h2 id="type选项"><a href="#type选项" class="headerlink" title="type选项"></a>type选项</h2><p><code>nslookup</code> 命令中的 <code>type</code> 参数用于指定查询的记录类型，即你想要获取的特定 DNS 记录的类型。以下是一些常见的 <code>type</code> 参数及其解释：</p><ul><li><p><strong>A (Address Record):</strong><code>nslookup example.com type=A</code> 查询域名 <code>example.com</code> 的 IPv4 地址</p></li><li><p><strong>AAAA (IPv6 Address Record):</strong><code>nslookup example.com type=AAAA</code> 查询域名 <code>example.com</code> 的 IPv6 地址</p></li><li><p><strong>CNAME (Canonical Name Record):</strong><code>nslookup example.com type=CNAME</code> 查询域名 <code>example.com</code> 的别名记录</p></li><li><p><strong>MX (Mail Exchange Record):</strong><code>nslookup example.com type=MX</code> 查询域名 <code>example.com</code> 的邮件交换记录</p></li><li><p><strong>NS (Name Server Record):</strong><code>nslookup example.com type=NS</code> 查询域名 <code>example.com</code> 的域名服务器记录</p></li><li><p><strong>PTR (Pointer Record):</strong><code>nslookup 192.168.1.1 type=PTR</code> 查询 IP 地址 <code>192.168.1.1</code> 对应的域名</p></li><li><p><strong>SOA (Start of Authority Record):</strong><code>nslookup example.com type=SOA</code> 查询域名 <code>example.com</code> 的权威区域起始记录</p></li><li><p><strong>TXT (Text Record):</strong><code>nslookup example.com type=TXT</code> 查询域名 <code>example.com</code> 的文本记录</p></li><li><p><strong>SRV (Service Record):</strong><code>nslookup _ldap._tcp.example.com type=SRV</code> 查询服务记录，例如 LDAP 服务</p></li><li><p><strong>ANY (Any Record):</strong><code>nslookup example.com type=ANY</code>   查询域名 <code>example.com</code> 的所有记录类型</p></li></ul><p>这些是常见的 <code>type</code> 参数，可以根据需要选择合适的类型来获取特定类型的 DNS 记录信息。在命令中，<code>type</code> 参数通常是可选的，如果不指定，默认为 <code>A</code> 记录</p><h2 id="retry选项"><a href="#retry选项" class="headerlink" title="retry选项"></a>retry选项</h2><p>该参数用于设置在没有收到响应时的重试次数。如果发送的 DNS 查询请求没有得到响应，<code>nslookup</code> 将会尝试重新发送请求，次数由 <code>-retry</code> 指定</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nslookup -retry=3 example.com</span><br></pre></td></tr></table></figure><p>  这个示例中，<code>-retry=3</code> 表示设置重试次数为3次。如果第一次查询没有得到响应，<code>nslookup</code> 将尝试再次发送查询请求，最多重试3次</p><h2 id="timeout选项"><a href="#timeout选项" class="headerlink" title="timeout选项"></a>timeout选项</h2><p>该参数用于设置等待响应的超时时间，以秒为单位。如果在指定的超时时间内没有收到响应，<code>nslookup</code> 将认为查询失败</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nslookup -timeout=5 example.com</span><br></pre></td></tr></table></figure><p>  这个示例中，<code>-timeout=5</code> 表示设置超时时间为5秒。如果在5秒内没有收到查询响应，<code>nslookup</code> 将认为查询失败</p><h1 id="使用更强大的dig命令"><a href="#使用更强大的dig命令" class="headerlink" title="使用更强大的dig命令"></a>使用更强大的dig命令</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">$ dig a1.easemob.com</span><br><span class="line"></span><br><span class="line">; &lt;&lt;&gt;&gt; DiG 9.16.1-Ubuntu &lt;&lt;&gt;&gt; a1.easemob.com</span><br><span class="line">;; global options: +cmd</span><br><span class="line">;; Got answer:</span><br><span class="line">;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 1464</span><br><span class="line">;; flags: qr rd ra; QUERY: 1, ANSWER: 3, AUTHORITY: 0, ADDITIONAL: 1</span><br><span class="line"></span><br><span class="line">;; OPT PSEUDOSECTION:</span><br><span class="line">; EDNS: version: 0, flags:; udp: 65494</span><br><span class="line">;; QUESTION SECTION:</span><br><span class="line">;a1.easemob.com.                        IN      A</span><br><span class="line"></span><br><span class="line">;; ANSWER SECTION:</span><br><span class="line">a1.easemob.com.         0       IN      CNAME   a1-v2.easemob.com.x.easeslb.com.</span><br><span class="line">a1-v2.easemob.com.x.easeslb.com. 0 IN   A       47.93.162.59</span><br><span class="line">a1-v2.easemob.com.x.easeslb.com. 0 IN   A       39.97.9.213</span><br><span class="line"></span><br><span class="line">;; Query time: 0 msec</span><br><span class="line">;; SERVER: 127.0.0.53<span class="comment">#53(127.0.0.53)</span></span><br><span class="line">;; WHEN: 一 1月 29 21:53:40 CST 2024</span><br><span class="line">;; MSG SIZE  rcvd: 117</span><br></pre></td></tr></table></figure><p>上述 <code>dig</code> 命令对域名 <code>a1.easemob.com</code> 进行查询的输出结构的含义解释如下：</p><ol><li><p><strong>头部信息 (<code>HEADER</code> 部分):</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 1464</span><br></pre></td></tr></table></figure><ul><li><code>opcode</code>: 查询操作的类型，这里是 <code>QUERY</code> 表示标准查询。</li><li><code>status</code>: 查询的状态，<code>NOERROR</code> 表示没有错误。</li><li><code>id</code>: 查询的唯一标识符，这里是 1464。</li></ul></li><li><p><strong>标志部分 (<code>flags</code> 部分):</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">;; flags: qr rd ra; QUERY: 1, ANSWER: 3, AUTHORITY: 0, ADDITIONAL: 1</span><br></pre></td></tr></table></figure><ul><li><code>qr</code>: 查询响应标志位，这里是 <code>qr</code> 表示响应。</li><li><code>rd</code>: 递归查询标志位，这里是 <code>rd</code> 表示递归查询。</li><li><code>ra</code>: 递归可用标志位，这里是 <code>ra</code> 表示递归可用。</li><li><code>QUERY: 1</code>: 查询的问题部分包含1个查询。</li><li><code>ANSWER: 3</code>: 响应部分包含3个回答。</li><li><code>AUTHORITY: 0</code>: 授权部分不包含任何信息。</li><li><code>ADDITIONAL: 1</code>: 附加部分包含1个附加记录。</li></ul></li><li><p><strong>OPT PSEUDOSECTION 部分:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">; EDNS: version: 0, flags:; udp: 65494</span><br></pre></td></tr></table></figure><ul><li><code>EDNS</code>: 扩展域名系统 (Extended DNS) 的信息。</li><li><code>version: 0</code>: EDNS 的版本。</li><li><code>flags:;</code>: EDNS 标志，这里为空。</li><li><code>udp: 65494</code>: 用于 DNS 查询和响应的最大 UDP 数据包大小。</li></ul></li><li><p><strong>请求部分 (<code>QUESTION SECTION</code>):</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">;; QUESTION SECTION:</span><br><span class="line">;a1.easemob.com.                        IN      A</span><br></pre></td></tr></table></figure><ul><li>查询的问题部分，这里是查询域名 <code>a1.easemob.com</code> 的 <code>A</code> 记录。</li></ul></li><li><p><strong>应答部分 (<code>ANSWER SECTION</code>):</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">;; ANSWER SECTION:</span><br><span class="line">a1.easemob.com.         0       IN      CNAME   a1-v2.easemob.com.x.easeslb.com.</span><br><span class="line">a1-v2.easemob.com.x.easeslb.com. 0 IN   A       47.93.162.59</span><br><span class="line">a1-v2.easemob.com.x.easeslb.com. 0 IN   A       39.97.9.213</span><br></pre></td></tr></table></figure><ul><li>响应部分包含了查询的回答，这里包含了3个记录。</li><li><code>CNAME</code> 记录：<code>a1.easemob.com</code> 是一个别名，指向 <code>a1-v2.easemob.com.x.easeslb.com</code>。</li><li><code>A</code> 记录：<code>a1-v2.easemob.com.x.easeslb.com</code> 对应两个IPv4地址，分别是 <code>47.93.162.59</code> 和 <code>39.97.9.213</code>。</li></ul></li><li><p><strong>查询时间 (<code>Query time</code>):</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">;; Query time: 0 msec</span><br></pre></td></tr></table></figure><ul><li>响应的查询时间，这里是 0 毫秒。</li></ul></li><li><p><strong>DNS 服务器信息 (<code>SERVER</code> 和 <code>WHEN</code> 部分):</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">;; SERVER: 127.0.0.53#53(127.0.0.53)</span><br><span class="line">;; WHEN: 一 1月 29 21:53:40 CST 2024</span><br></pre></td></tr></table></figure><ul><li><code>SERVER</code>: 显示响应的 DNS 服务器的IP地址和端口号。</li><li><code>WHEN</code>: 显示响应的时间戳。</li></ul></li><li><p><strong>消息大小 (<code>MSG SIZE</code>):</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">;; MSG SIZE  rcvd: 117</span><br></pre></td></tr></table></figure><ul><li>响应消息的大小，这里是 117 字节。</li></ul></li></ol><p>综上所述，这个 <code>dig</code> 查询输出提供了关于域名 <code>a1.easemob.com</code> 的详细信息，包括查询问题、响应部分（包括 CNAME 和 A 记录）、查询时间、DNS 服务器信息以及响应消息的大小。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>使用 <code>nslookup</code> 命令可以用来查询域名对应的IP <code>nslookup a1.easemob.com</code></li><li>使用 <code>nslookup</code> 命令也可以用来查询IP对应的域名 <code>nslookup 8.8.8.8 -ty=PTR 1.1.1.1</code></li><li><code>nslookup</code> 是一个跨平台的命令，Windows(cmd)、Mac、Linux都可以使用</li><li>在PowerShell中等价的命令是 <code>Resolve-DnsName</code>，默认输出信息较为详细</li><li><code>dig</code> 命令也可用于查询域名的详细信息 <code>dig a1.easemob.com</code></li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/135734670" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>曾经沧海难为水，除却巫山不是云，可以被压缩的时间才是生活，不得不花费的时间只是为了活着~</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;这个命令出现在与运维同学沟通过程中，在此之前要是问我一个域名对应的服务器是IP地址是什么，我肯定优先想到的是 &lt;code&gt;ping&lt;/code&gt; 这个命令，这个命令确实可以在回复的信息中看到IP地址，但是不全面，有时一个域名对应不止一个IP地址，这时就要用到 nslookup 命令了，这也是在沟通中学到的新知识点。&lt;/p&gt;
    
    </summary>
    
      <category term="Network" scheme="http://AlbertGithubHome.github.io/blog/categories/Network/"/>
    
    
      <category term="linux" scheme="http://AlbertGithubHome.github.io/blog/tags/linux/"/>
    
      <category term="Tools" scheme="http://AlbertGithubHome.github.io/blog/tags/Tools/"/>
    
      <category term="nslookup" scheme="http://AlbertGithubHome.github.io/blog/tags/nslookup/"/>
    
  </entry>
  
  <entry>
    <title>一个golang小白使用vscode搭建Ununtu20.04下的go开发环境</title>
    <link href="http://AlbertGithubHome.github.io/blog/2024/01/21/%E4%B8%80%E4%B8%AAgolang%E5%B0%8F%E7%99%BD%E4%BD%BF%E7%94%A8vscode%E6%90%AD%E5%BB%BAgo%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"/>
    <id>http://AlbertGithubHome.github.io/blog/2024/01/21/一个golang小白使用vscode搭建go开发环境/</id>
    <published>2024-01-21T05:13:55.000Z</published>
    <updated>2024-01-21T13:01:35.484Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>先交代一下背景，距离正式接触golang这门语言已经有5年时间，平时偶尔也会用go写写工具和功能，但其实充其量就是语言小白，基本上就是按照教程配置好环境，按照需求写写逻辑，能跑起来就行了。golang随着这几年的变化，这门语言的变化还是非常大的，之前写过一篇<a href="https://blog.csdn.net/albertsh/article/details/113907051" target="_blank" rel="noopener">《Go环境配置时遇到的GOPATH路径以及包管理问题》</a>，可以看出之前配置的变量很像Java早期的配置环境，从1.11 版本之后go工程不必放到 <code>GOPATH</code> 路径中了，通过go.mod文件来标记并跟踪每个软件包的版本，灵活度大大提高，从此 <code>GOPATH</code> 概念逐渐淡化，在1.18版本新引入一个新功能<code>go.work</code>，它被设计为解决在同一工作空间中处理多个模块的问题，使得go工程的模块管理更加方便。</p><a id="more"></a><p>简单描述下我的开发环境，<code>Windows10</code> + <code>VSCode1.58.0</code> + <code>WLS1.0 - Ubuntu20.04</code>，平时工作都是在Ubuntu上，习惯了在Linux上的开发，所以即使是自己家的电脑也安装了子系统，就当成<code>Ubuntu</code> 来用就行了，Vscode安装在Windows上，直接连接到子系统上进行代码编写，以上是前提，本文的重点是在Ubuntu20.04系统上安装go的编译和运行环境。</p><h1 id="搭建go环境"><a href="#搭建go环境" class="headerlink" title="搭建go环境"></a>搭建go环境</h1><p>我选择的go版本是1.19，已经支持 <code>go.sum</code> 和 <code>go.work</code>，同时也为了和工作开发保持一致，没必要用太新的特性，现在的go包管理已经不想早期的Java，不再依赖 <code>GOPATH</code>，和 Python3.x 更像了，只管下载包然后在各自的工程目录下使用就行了，必要时需要指定使用库的版本。</p><h2 id="下载go安装包"><a href="#下载go安装包" class="headerlink" title="下载go安装包"></a>下载go安装包</h2><p>go语言的官网是 <a href="https://golang.google.cn/dl/" target="_blank" rel="noopener">https://golang.google.cn/dl/</a>，下载1.19版本的Linux包<a href="https://golang.google.cn/dl/go1.19.linux-amd64.tar.gz" target="_blank" rel="noopener">go1.19.linux-amd64.tar.gz</a>，这个网址通常下载很慢，可以改为go语言中文网<a href="https://studygolang.com/dl" target="_blank" rel="noopener">https://studygolang.com/dl</a>来下载1.19版本<a href="https://studygolang.com/dl/golang/go1.19.linux-amd64.tar.gz" target="_blank" rel="noopener">go1.19.linux-amd64.tar.gz</a></p><p>可以通过浏览器下载拷贝到指定位置，也可以通过<code>wget</code>命令下载</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">alberts@home-pc:~$ wget https://golang.google.cn/dl/go1.19.linux-amd64.tar.gz</span><br><span class="line">--2024-01-21 17:22:11--  https://golang.google.cn/dl/go1.19.linux-amd64.tar.gz</span><br><span class="line">Resolving golang.google.cn (golang.google.cn)... 203.208.50.34</span><br><span class="line">Connecting to golang.google.cn (golang.google.cn)|203.208.50.34|:443... connected.</span><br><span class="line">HTTP request sent, awaiting response... 302 Found</span><br><span class="line">Location: https://dl.google.com/go/go1.19.linux-amd64.tar.gz [following]</span><br><span class="line">--2024-01-21 17:22:12--  https://dl.google.com/go/go1.19.linux-amd64.tar.gz</span><br><span class="line">Resolving dl.google.com (dl.google.com)... 220.181.174.161, 2401:3800:4001:807::1001</span><br><span class="line">Connecting to dl.google.com (dl.google.com)|220.181.174.161|:443... connected.</span><br><span class="line">HTTP request sent, awaiting response... 200 OK</span><br><span class="line">Length: 148796421 (142M) [application/x-gzip]</span><br><span class="line">Saving to: ‘go1.19.linux-amd64.tar.gz’</span><br><span class="line"></span><br><span class="line">go1.19.linux-amd64.tar.gz      100%[==============================&gt;] 141.90M  3.62MB/s    <span class="keyword">in</span> 31s</span><br><span class="line"></span><br><span class="line">2024-01-21 17:22:43 (4.54 MB/s) - ‘go1.19.linux-amd64.tar.gz’ saved [148796421/148796421]</span><br></pre></td></tr></table></figure><h2 id="解压go压缩包完成安装"><a href="#解压go压缩包完成安装" class="headerlink" title="解压go压缩包完成安装"></a>解压go压缩包完成安装</h2><p>go的运行环境直接解压拷贝到指定位置就可以了，我把go解压安装到了 <code>/usr/local/go</code> 目录，解压之前也清理掉老的目录，如果之前没安装过，<code>rm</code>这条命令可以不使用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo su</span><br><span class="line">rm -rf /usr/<span class="built_in">local</span>/go</span><br><span class="line">tar -C /usr/<span class="built_in">local</span> -xzf go1.19.linux-amd64.tar.gz</span><br></pre></td></tr></table></figure><h2 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h2><p>这一步有点类似Windows中的修改注册表，我安装了新的程序，需要通知系统当使用 <code>go</code> 命令时需要去哪个目录下寻找可执行程序，具体操作如下</p><ul><li><p>使用vim编辑.bashrc文件</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alberts@home-pc:~$ vim ~/.bashrc</span><br></pre></td></tr></table></figure></li><li><p>到文件的末尾添加以下代码</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alberts@home-pc:~$ <span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:/usr/<span class="built_in">local</span>/go/bin</span><br></pre></td></tr></table></figure></li><li><p>重新加载配置文件</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alberts@home-pc:~$ <span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure></li><li><p>查看版本是否安装成功</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alberts@home-pc:~$ go version</span><br><span class="line">go version go1.19 linux/amd64</span><br></pre></td></tr></table></figure></li></ul><p>查看版本显示出 <code>go1.19 linux/amd64</code>, 至此go语言的基础开发环境就配置好了</p><h2 id="编写一个helloword程序"><a href="#编写一个helloword程序" class="headerlink" title="编写一个helloword程序"></a>编写一个helloword程序</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">alberts@home-pc:/mnt/g$ mkdir wlsworkspace</span><br><span class="line">alberts@home-pc:/mnt/g$ <span class="built_in">cd</span> wlsworkspace</span><br><span class="line">alberts@home-pc:/mnt/g/wlsworkspace$ mkdir hello</span><br><span class="line">alberts@home-pc:/mnt/g/wlsworkspace$ <span class="built_in">cd</span> hello/</span><br><span class="line">alberts@home-pc:/mnt/g/wlsworkspace/hello$ go mod init github.com/alberts/go/hello</span><br><span class="line">go: creating new go.mod: module github.com/alberts/go/hello</span><br><span class="line">alberts@home-pc:/mnt/g/wlsworkspace/hello$ touch hello.go</span><br><span class="line">alberts@home-pc:/mnt/g/wlsworkspace/hello$ ls</span><br><span class="line">go.mod  hello.go</span><br></pre></td></tr></table></figure><p>打开 <code>hello.go</code> 文件编写以下内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line">func <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">    fmt.Println(<span class="string">"Hello,World!"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>保存文件后使用 <code>go run</code> 命令运行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alberts@home-pc:/mnt/g/wlsworkspace/hello$ go run hello.go</span><br><span class="line">Hello,World!</span><br></pre></td></tr></table></figure><h1 id="安装VSCode插件"><a href="#安装VSCode插件" class="headerlink" title="安装VSCode插件"></a>安装VSCode插件</h1><h2 id="安装智能提示插件"><a href="#安装智能提示插件" class="headerlink" title="安装智能提示插件"></a>安装智能提示插件</h2><p>为了编写go代码方便，可以安装这个名为<code>Go</code>的插件，这个插件不是必须安装的，但是你在写go代码时VSCode会自动提示你安装这个插件，为了实现Go语法只能提醒，我们可以直接点击提示安装，或者在插件市场里搜索安装</p><p>go插件</p><p>插件安装完成后会提示下面的报错</p><blockquote><p>The “gopls” command is not available. Run “go get -v golang.org/x/tools/gopls” to install.</p></blockquote><p>说明安装这个插件需要依赖 <code>golang.org/x/tools/gopls</code> 这个包，我们可以根据提示安装</p><h2 id="安装go依赖包"><a href="#安装go依赖包" class="headerlink" title="安装go依赖包"></a>安装go依赖包</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alberts@home-pc:/mnt/g/wlsworkspace/hello$ go get -v golang.org/x/tools/gopls</span><br><span class="line">go: module golang.org/x/tools/gopls: Get <span class="string">"https://proxy.golang.org/golang.org/x/tools/gopls/@v/list"</span>: dial tcp 142.251.42.241:443: connect: connection refused</span><br></pre></td></tr></table></figure><p>直接安装通常会因无法下载而失败，需要修改代理来改变下载地址</p><h2 id="修改代理并重新安装依赖包"><a href="#修改代理并重新安装依赖包" class="headerlink" title="修改代理并重新安装依赖包"></a>修改代理并重新安装依赖包</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">alberts@home-pc:/mnt/g/wlsworkspace/hello$ go env -w GO111MODULE=on</span><br><span class="line">alberts@home-pc:/mnt/g/wlsworkspace/hello$ go env -w GOPROXY=https://goproxy.cn,direct</span><br><span class="line">alberts@home-pc:/mnt/g/wlsworkspace/hello$ go env -w GOSUMDB=<span class="string">"sum.golang.org"</span></span><br></pre></td></tr></table></figure><p>安装依赖包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">alberts@home-pc:/mnt/g/wlsworkspace/hello$ go get -v golang.org/x/tools/gopls</span><br><span class="line">go: downloading golang.org/x/tools v0.17.0</span><br><span class="line">go: downloading golang.org/x/tools/gopls v0.14.2</span><br><span class="line">go: downloading golang.org/x/tools v0.14.1-0.20231114185516-c9d3e7de13fd</span><br><span class="line">go: downloading golang.org/x/telemetry v0.0.0-20231114163143-69313e640400</span><br><span class="line">go: downloading github.com/sergi/go-diff v1.1.0</span><br><span class="line">go: downloading honnef.co/go/tools v0.4.5</span><br><span class="line">go: downloading mvdan.cc/gofumpt v0.4.0</span><br><span class="line">go: downloading mvdan.cc/xurls/v2 v2.4.0</span><br><span class="line">go: downloading golang.org/x/mod v0.14.0</span><br><span class="line">go: downloading golang.org/x/sync v0.4.0</span><br><span class="line">go: downloading golang.org/x/text v0.13.0</span><br><span class="line">go: downloading golang.org/x/exp/typeparams v0.0.0-20221212164502-fae10dda9338</span><br><span class="line">go: downloading golang.org/x/sys v0.14.0</span><br><span class="line">go: downloading golang.org/x/vuln v1.0.1</span><br><span class="line">go: downloading github.com/google/go-cmp v0.5.9</span><br><span class="line">go: downloading github.com/BurntSushi/toml v1.2.1</span><br><span class="line">go: added github.com/BurntSushi/toml v1.2.1</span><br><span class="line">go: added github.com/google/go-cmp v0.5.9</span><br><span class="line">go: added github.com/sergi/go-diff v1.1.0</span><br><span class="line">go: added golang.org/x/exp/typeparams v0.0.0-20221212164502-fae10dda9338</span><br><span class="line">go: added golang.org/x/mod v0.14.0</span><br><span class="line">go: added golang.org/x/sync v0.4.0</span><br><span class="line">go: added golang.org/x/sys v0.14.0</span><br><span class="line">go: added golang.org/x/telemetry v0.0.0-20231114163143-69313e640400</span><br><span class="line">go: added golang.org/x/text v0.13.0</span><br><span class="line">go: added golang.org/x/tools v0.14.1-0.20231114185516-c9d3e7de13fd</span><br><span class="line">go: added golang.org/x/tools/gopls v0.14.2</span><br><span class="line">go: added golang.org/x/vuln v1.0.1</span><br><span class="line">go: added honnef.co/go/tools v0.4.5</span><br><span class="line">go: added mvdan.cc/gofumpt v0.4.0</span><br><span class="line">go: added mvdan.cc/xurls/v2 v2.4.0</span><br></pre></td></tr></table></figure><p>这次安装成功了，这些依赖包默认安装到了 <code>~/go/pkg</code>目录下，使用时直接在go文件中引用就行了 <code>import golang.org/x/sys</code></p><p>以上这些包是Go语言的依赖管理工具，它们的作用如下：</p><ul><li>golang.org/x/tools: 提供了一系列用于开发Go语言的工具，如gopls等</li><li>golang.org/x/tools/gopls: 是一个基于Go语言的代码补全和导航工具，它可以帮助开发者更高效地编写和调试Go代码</li><li>golang.org/x/telemetry: 提供了一套用于收集和分析应用程序性能数据的库</li><li>github.com/sergi/go-diff: 是一个用于比较两个Go源代码文件差异的工具</li><li>honnef.co/go/tools: 提供了一些用于处理Go源代码的工具，如goimports（自动导入缺失的包）等</li><li>mvdan.cc/gofumpt: 是一个用于格式化Go源代码的工具，它可以自动调整代码格式以符合Go语言的最佳实践</li><li>mvdan.cc/xurls/v2: 是一个用于解析URL的库，它可以将URL分解为各个组成部分，方便开发者处理</li><li>golang.org/x/mod: 是一个用于管理Go模块的库，它可以帮助你更好地组织和管理项目的依赖关系</li><li>golang.org/x/sync: 提供了一组同步原语，如互斥锁、条件变量等，用于实现多线程编程中的同步机制</li><li>golang.org/x/text: 提供了一个用于处理Unicode文本的库，它可以帮助你更方便地处理和操作文本数据</li><li>golang.org/x/exp/typeparams: 提供了一个用于处理类型参数的库，它可以帮助你更方便地处理泛型编程中的类型参数问题</li><li>golang.org/x/sys: 提供了一个用于访问操作系统功能的库，它可以帮助你更方便地处理操作系统相关的任务</li><li>golang.org/x/vuln: 提供了一个用于管理已知安全漏洞的库，它可以帮助你更容易地识别和修复项目中的安全漏洞</li><li>github.com/stamblerre/gocode: 提供Go语言的代码自动补全功能，用于IDEs和编辑器</li><li>github.com/uudashr/gopkgs/v2/cmd/gopkgs: 命令行工具，帮助发现和使用Go语言软件包</li><li>github.com/ramya-rao-a/go-outline: VSCode插件，为Go源代码文件生成结构大纲以便于导航</li></ul><p>总结一下需要安装的依赖包</p><blockquote><p>go get -v golang.org/x/tools/gopls<br>go get -v github.com/stamblerre/gocode<br>go get -v github.com/uudashr/gopkgs/v2/cmd/gopkgs<br>go get -v github.com/ramya-rao-a/go-outline</p></blockquote><p>根据VSCode提示安装后续的Tools，得到的控制台输出信息如下</p><blockquote><p>Tools environment: GOPATH=/home/alberts/go<br>Installing 6 tools at /home/alberts/go/bin in module mode.<br> gopkgs<br> go-outline<br> dlv<br> dlv-dap<br> staticcheck<br> gopls</p><p>Installing github.com/uudashr/gopkgs/v2/cmd/gopkgs (gopkgs) SUCCEEDED<br>Installing github.com/ramya-rao-a/go-outline (go-outline) SUCCEEDED<br>Installing github.com/go-delve/delve/cmd/dlv (dlv) SUCCEEDED<br>Installing github.com/go-delve/delve/cmd/dlv@master (/home/alberts/go/bin/dlv-dap) SUCCEEDED<br>Installing honnef.co/go/tools/cmd/staticcheck (staticcheck) SUCCEEDED<br>Installing golang.org/x/tools/gopls (gopls) SUCCEEDED</p><p>All tools successfully installed. You are ready to Go :).</p></blockquote><h1 id="go-mod-和-go-work"><a href="#go-mod-和-go-work" class="headerlink" title="go.mod 和 go.work"></a>go.mod 和 go.work</h1><h2 id="go-mod"><a href="#go-mod" class="headerlink" title="go.mod"></a>go.mod</h2><p><strong>Go语言从1.11版本开始引入了Go Modules，这个版本之后不再需要将项目放到GOPATH中</strong>。</p><p>Go Modules是Go语言的依赖管理工具，它改变了之前必须使用GOPATH来管理依赖的模式。在Go 1.11及之后的版本中，通过go.mod文件来标记并跟踪每个软件包的版本，这意味着开发者可以在任何地方创建项目，而不必遵循GOPATH目录结构。</p><p>此外，Go团队还增加了一个环境变量<code>GO111MODULE</code>来控制模块支持的启用和禁用。这个环境变量的命名中的”111”象征着它是在Go 1.11版本中引入的。</p><p>总的来说，Go语言自1.11版本起，通过引入Go Modules，使得开发者不再受限于GOPATH，可以更加灵活地管理项目和依赖。这一变化被广泛认为是Go语言发展中的一个重大改进。</p><h2 id="go-work"><a href="#go-work" class="headerlink" title="go.work"></a>go.work</h2><p>“go.work” 是Go 1.18版本新引入的一个功能，它被设计为解决在同一工作空间中处理多个模块的问题。在之前的版本中，开发者常常会遇到路径问题、版本冲突问题等挑战。为了应对这些情况，他们可能需要对每个模块的go.mod文件进行手动修改，过程繁琐且容易出错。</p><p>“go.work”文件的主要作用就是来解决这些问题。它是一个特殊的文件，其中包含了use和replace指令，这些指令会覆盖工作区目录下的每个Go Module的go.mod文件中的内容。因此，开发者无需再对每个Go Module的go.mod文件进行手动修改，极大地简化了操作流程并提高了效率。</p><p>此外，”go.work”文件的优先级高于go.mod文件中的定义。也就是说，如果在go.work和go.mod中同时指定了不同的代码仓库路径，那么go.work中的设置将会被优先采用。这一特性进一步加强了”go.work”文件在依赖管理中的重要性。</p><h2 id="小试一下go-work"><a href="#小试一下go-work" class="headerlink" title="小试一下go.work"></a>小试一下go.work</h2><p>当前工作目录下有 <code>base</code> 和 <code>hello</code> 两个包含go.mod的工程，使用 <code>go work init</code> 命令可以初始化一个工作空间</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">alberts@home-pc:/mnt/g/wlsworkspace$ ls</span><br><span class="line">base  hello</span><br><span class="line">alberts@home-pc:/mnt/g/wlsworkspace$ go work init base hello</span><br><span class="line">alberts@home-pc:/mnt/g/wlsworkspace$ cat go.work</span><br><span class="line">go 1.19</span><br><span class="line"></span><br><span class="line">use (</span><br><span class="line">        ./base</span><br><span class="line">        ./hello</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>初始化之后工程之间就可以相互引用彼此对外的包内容了</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>下载go压缩包 <code>wget https://golang.google.cn/dl/go1.19.linux-amd64.tar.gz</code></li><li>初始化工程目录hello <code>go mod init github.com/alberts/go/hello</code>，包名通常是支持https访问的网络地址</li><li>初始化工作空间 <code>go work init base hello</code>，base 和 hello 都是包含go.mod文件的go工程</li><li>安装依赖包 <code>go get -v golang.org/x/tools/gopls</code></li><li>安装依赖包 <code>github.com/stamblerre/gocode</code></li><li>安装依赖包 <code>github.com/uudashr/gopkgs/v2/cmd/gopkgs</code></li><li>安装依赖包 <code>github.com/ramya-rao-a/go-outline</code></li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/135586502" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>放下助人情节，尊重他人命运~</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;先交代一下背景，距离正式接触golang这门语言已经有5年时间，平时偶尔也会用go写写工具和功能，但其实充其量就是语言小白，基本上就是按照教程配置好环境，按照需求写写逻辑，能跑起来就行了。golang随着这几年的变化，这门语言的变化还是非常大的，之前写过一篇&lt;a href=&quot;https://blog.csdn.net/albertsh/article/details/113907051&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《Go环境配置时遇到的GOPATH路径以及包管理问题》&lt;/a&gt;，可以看出之前配置的变量很像Java早期的配置环境，从1.11 版本之后go工程不必放到 &lt;code&gt;GOPATH&lt;/code&gt; 路径中了，通过go.mod文件来标记并跟踪每个软件包的版本，灵活度大大提高，从此 &lt;code&gt;GOPATH&lt;/code&gt; 概念逐渐淡化，在1.18版本新引入一个新功能&lt;code&gt;go.work&lt;/code&gt;，它被设计为解决在同一工作空间中处理多个模块的问题，使得go工程的模块管理更加方便。&lt;/p&gt;
    
    </summary>
    
      <category term="Go" scheme="http://AlbertGithubHome.github.io/blog/categories/Go/"/>
    
    
      <category term="Go" scheme="http://AlbertGithubHome.github.io/blog/tags/Go/"/>
    
      <category term="golang" scheme="http://AlbertGithubHome.github.io/blog/tags/golang/"/>
    
      <category term="vscode" scheme="http://AlbertGithubHome.github.io/blog/tags/vscode/"/>
    
      <category term="proxy" scheme="http://AlbertGithubHome.github.io/blog/tags/proxy/"/>
    
  </entry>
  
  <entry>
    <title>推荐一款通过ssh连接linux服务的开源工具WindTerm</title>
    <link href="http://AlbertGithubHome.github.io/blog/2024/01/14/%E6%8E%A8%E8%8D%90%E4%B8%80%E6%AC%BE%E9%80%9A%E8%BF%87ssh%E8%BF%9E%E6%8E%A5linux%E6%9C%8D%E5%8A%A1%E7%9A%84%E5%BC%80%E6%BA%90%E5%B7%A5%E5%85%B7WindTerm/"/>
    <id>http://AlbertGithubHome.github.io/blog/2024/01/14/推荐一款通过ssh连接linux服务的开源工具WindTerm/</id>
    <published>2024-01-14T11:39:08.000Z</published>
    <updated>2024-01-21T12:47:38.943Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>工作一入门便是游戏服务器开发，所以常常有连接Linux服务器的需求，之前用的最多的是Xshell，最近这个软件个人版只能免费使用一个月了，超过时间会提示更新无法正常使用，工作当中用的最多的是SecureCRT，不过这个软件是收费的，公司买了授权，可以正常用，但是在家时就不行了，最近我找到了WindTerm这个软件，用起来还不错，记录一下。</p><a id="more"></a><h1 id="WindTerm介绍"><a href="#WindTerm介绍" class="headerlink" title="WindTerm介绍"></a>WindTerm介绍</h1><blockquote><p>A Quicker and better SSH/Telnet/Serial/Shell/Sftp client for DevOps.</p></blockquote><p>WindTerm一款使用使用C语言开发的跨平台SSH客户端WindTerm，完全免费开源，软件包只有20多M，性能很好，Windows、Linux、Mac均提供程序包下载，免按照，下载解压即可使用，官方地址为 <a href="https://github.com/kingToolbox/WindTerm/releases" target="_blank" rel="noopener">https://github.com/kingToolbox/WindTerm/releases</a>，最新版本为2.6.0</p><p><img src="https://img-blog.csdnimg.cn/direct/675fda112cc34909909ad7647c3fce5e.png#pic_center" alt="windterm download">最近github访问又变慢了，如果你下载不下来，可以从这个平台地址下载<a href="https://download.csdn.net/download/shihengzhen101/88740938" target="_blank" rel="noopener">CSDN下载-WindTerm_2.6.0_Prerelease_7_Windows_Portable_x86_64.zip</a>，我已经设置成免积分了，方便有需要的人直接取用，简单罗列下它的功能。</p><ul><li>多平台支持Linux，Mac，Win，免安装解压即可使用</li><li>实施了 SSH v2、Telnet、Raw Tcp、串行、Shell 协议</li><li>会话认证时支持 SSH 自动执行</li><li>支持 SSH ProxyCommand 或 ProxyJump</li><li>支持SSH代理转发。</li><li>支持使用密码、公钥、键盘交互、gssapi-with-mic 的 SSH 自动登录</li><li>支持直接/本地端口转发、反向/远程端口转发和动态端口转发</li><li>支持 XModem、YModem 和 ZModem，可以使用rz、sz上传和下载文件</li><li>集成sftp、scp客户端，支持下载、上传、删除、重命名、新建文件/目录</li><li>集成本地文件管理器，支持移动到、复制到、复制自、删除、重命名、新建文件/目录</li><li>支持 Windows Cmd、PowerShell 和 Cmd、PowerShell 作为管理员</li><li>支持Linux bash、zsh、powershell core</li><li>支持 MacOS bash、zsh、powershell core</li><li>有较好的操作界面</li></ul><h1 id="WindTerm使用"><a href="#WindTerm使用" class="headerlink" title="WindTerm使用"></a>WindTerm使用</h1><p>下载WindTerm_2.6.0_Prerelease_7_Windows_Portable_x86_64.zip 后解压，双击WindTerm.exe即可打开软件，会弹出下面的界面，提示存储配置文件的地方，我就选择放到应用程序目录了</p><p><img src="https://img-blog.csdnimg.cn/direct/cdbbedbd143f4841bc4575ca9b6c37d4.png#pic_center" alt="windterm open"></p><p>直接通过【会话】-&gt;【新建会话】便可以建立连接Linux服务器的通道，这与之前用的软件都大同小异，基本没有差别，输入主机地址点击【连接】，后续再输入密码就可以开始连接了</p><p><img src="https://img-blog.csdnimg.cn/direct/f387f7832a1549bf93726ab773c611a6.png" alt="new session">如果是第一个使用的时候，会弹出下面这个界面，让自定义一个主密码，其实就是这个软件的使用密码，后续锁屏或者更新会话信息时会用到。</p><p><img src="https://img-blog.csdnimg.cn/direct/a22b701407c24290be4b440aa906d879.png#pic_center" alt="main password"></p><p>因为我是自己在家使用，我就不设置主密码了，直接点击OK完成，后面会让输入Linux账户和密码，到这一步相信大家都会用了。</p><h1 id="主密码和锁屏"><a href="#主密码和锁屏" class="headerlink" title="主密码和锁屏"></a>主密码和锁屏</h1><p>这个问题我也是查了一些资料才解决的，因为我没有输入主密码，所以每次锁屏时我只要回车就可以了，如果想修改锁屏时间，在【会话】-&gt;【首选项】-&gt;【设置】中可以找到</p><p><img src="https://img-blog.csdnimg.cn/direct/e143aec960c4491fb4fcc22d14ca502a.png#pic_center" alt="windterm setting"><br>也可以直接通过配置文件修改，找到刚启动软件时你选择的目录 <code>D:\app\WindTerm_2.6.0\.wind\profiles\default.v10</code>，直接修改配置文件内容，通过字段名也很清楚要改哪些值</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"application.fingerprint"</span> : <span class="string">"c5QR13M1iEkNPGlVNjDBWadi1uS0PiXR4Y+79cp09PAXr7G6WQxg/7WFj9RJ9dIsKKOWqm5Xq2N6w5Jx4v2mTw=="</span>,</span><br><span class="line">    <span class="attr">"application.language"</span> : <span class="string">"zh-CN"</span>,</span><br><span class="line">    <span class="attr">"application.lockScreenTimeout"</span> : <span class="number">1</span>,</span><br><span class="line">    <span class="attr">"application.masterPassword"</span> : <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">"terminal.loginWizard.defaultAuthType"</span> : <span class="string">"Account"</span>,</span><br><span class="line">    <span class="attr">"terminal.reimportShellSessions"</span> : <span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>application.lockScreenTimeout</code>：是控制锁屏时间的</li><li><code>application.masterPassword</code>：是代表是否有主密码的</li></ul><p>整个页面布局和配色还是挺漂亮的，不喜欢可以自己调整的哈</p><p><img src="https://img-blog.csdnimg.cn/direct/ea41dd99bf6b430ba5023eb358cd5752.png#pic_center" alt="windterm shell"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>WindTerm是一款可以通过ssh连接Linux服务器的客户端工具</li><li>WindTerm免费开源，支持Windows、Linux、Mac系统，无需安装，解压即可使用</li><li>WindTerm集成sftp、scp客户端，支持下载、上传、删除、重命名、新建文件/目录</li><li>WindTerm默认需要指定一个主密码，相当于验证使用者身份的功能，当然也可以为空</li><li>WindTerm的锁屏时间可以通过首选项菜单设置，也可通过配置修改</li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/135315104" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>人生就是一本账，欠下的东西总要还的，茫茫人生路之后，你是想在历史长河中留下一笔，还是“隐藏”的毫无痕迹呢？</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;工作一入门便是游戏服务器开发，所以常常有连接Linux服务器的需求，之前用的最多的是Xshell，最近这个软件个人版只能免费使用一个月了，超过时间会提示更新无法正常使用，工作当中用的最多的是SecureCRT，不过这个软件是收费的，公司买了授权，可以正常用，但是在家时就不行了，最近我找到了WindTerm这个软件，用起来还不错，记录一下。&lt;/p&gt;
    
    </summary>
    
      <category term="linux" scheme="http://AlbertGithubHome.github.io/blog/categories/linux/"/>
    
    
      <category term="linux" scheme="http://AlbertGithubHome.github.io/blog/tags/linux/"/>
    
      <category term="运维" scheme="http://AlbertGithubHome.github.io/blog/tags/%E8%BF%90%E7%BB%B4/"/>
    
      <category term="ssh" scheme="http://AlbertGithubHome.github.io/blog/tags/ssh/"/>
    
      <category term="windterm" scheme="http://AlbertGithubHome.github.io/blog/tags/windterm/"/>
    
      <category term="免安装" scheme="http://AlbertGithubHome.github.io/blog/tags/%E5%85%8D%E5%AE%89%E8%A3%85/"/>
    
  </entry>
  
  <entry>
    <title>2023年终总结——你相信光吗</title>
    <link href="http://AlbertGithubHome.github.io/blog/2024/01/01/2023%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93%E2%80%94%E2%80%94%E4%BD%A0%E7%9B%B8%E4%BF%A1%E5%85%89%E5%90%97/"/>
    <id>http://AlbertGithubHome.github.io/blog/2024/01/01/2023年终总结——你相信光吗/</id>
    <published>2023-12-31T16:02:35.000Z</published>
    <updated>2024-01-14T11:49:26.200Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>不断追求利益的经济冲动，不停侵蚀人们的生活，压垮、吞噬并统治生活本身，无法言喻的不安和看不到明天的混沌感，让我们在现有社会经济条件下，沦为被金钱和物质所统治的行尸走肉~</p></blockquote><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近在看一本叫《饱食穷民》的书，讲述的是泡沫经济年代的日本社会，宛如梦幻泡影一样变化无常，又像断梗浮萍一样飘忽不定，到处充斥着不安的色彩，我试图从中寻找一些当前现实问题的解决方案，上段文字也是出自此书之中，阅读之后我大受震撼，其中描述的有关软件工程师的篇章，简直就是我的复刻版，无论是心境、情感、还是所面临的问题都如出一辙，读完觉得背后隐隐发凉，因为最终那些令人无法接受的结局，确实是我不想看到的。</p><a id="more"></a><p>2023年要结束了，今年的时光过的格外的快，突然想起大年初二时半夜更新游戏版本好像还是昨天发生的事情，结果一眨眼就来到了2023的尾巴，2022年末的时候大家对2023年的发展充满了希望，结果今年快过完了，发现比之前“三年”更难了，零下20度的温度配合着各种“毕业”的声音，让不安的情绪充斥着每一个打工人的内心。</p><p>面对除夕上班的决定，一开始大家还是强烈反对，但是渐渐的情绪发生了逆转，除夕上班说明还有工作，很多人在这个寒冷的冬天已经“提前放假”，没有打工的机会了，在这个寒冷的冬天，你还相信光吗？</p><h1 id="回顾2023"><a href="#回顾2023" class="headerlink" title="回顾2023"></a>回顾2023</h1><p>回顾这一年忙忙碌碌，高强度的工作却没取得预想的成果，各种Flag完成情况更是惨不忍睹。</p><h2 id="工作上"><a href="#工作上" class="headerlink" title="工作上"></a>工作上</h2><blockquote><p>FLAG</p><ul><li>适应自己身份的转变，提升自己的管理技能，做一名合格的管理者</li><li>继续做好本职可开发工作，做好工作内容的总结，推动新项目顺利上线</li><li>根据自己的技能树框架，查漏补缺，有针对性的学习和探索</li></ul><p>完成度 ：80%</p></blockquote><p>作为一个入门的管理者，今年见识到了更多更复杂的管理情景，Hire and Fire 全都经历过了，管理经验更加完整，尝试跨过了之前一直无法逾越的坎，为了能生存下去，有时不得不做出取舍，参加了一系列的管理课程，学习后发现万物皆可为工具，招人的工具、提升效率的工具、提升凝聚力的工具、提高团队氛围的工具、优化团队的工具，学习过后内心不禁生出一丝悲凉。</p><p>本职工作继续充当牛马，还真是个踏踏实实的老黄牛，推动项目一步步往前走，但目前项目暂时停滞了，今年上线是不可能了，不过经历了一次完整的测试过程，算是在失望之中获得了一点点慰藉。</p><p>今年的工作强度依旧很大，前三季度基本上12点左右回家，个别时候会工作到后半夜，比上一年能好一点，但是最终的结果却不尽如人意。</p><p>技能树框架基本荒废，因为没时间往里边填东西，基本上是被项目推着走，缺什么就补什么，nginx测试和调整配置有了一定的经验，linux系统参数的调优也在压测是接触了不少，还有网络参数配置等等。</p><p>对于这一项来说，努力到位了，结果并不能说明什么，可能还是缺少一点点运气了。</p><h2 id="学习上"><a href="#学习上" class="headerlink" title="学习上"></a>学习上</h2><blockquote><p>FLAG</p><ul><li>继续博客总结，40篇是基础线，2023要超过这个值，尽量一周一篇，放假可休息</li><li>新的一年依旧很忙，刷题不强制要求，每周最好有贡献，每月必须有输出</li><li>在现有的技能树框架上继续丰富，做到枝繁叶茂，试试找点副业</li><li>开源代码还是以项目为驱动，选取经典实现，比如kafka</li><li>继续读书，今年书也买好了，数量不多，下半年应该还会买一批</li></ul><p>完成度 ：70%</p></blockquote><p>博客总结目标达成，今年在CSDN共有42篇总结，较40篇的及格线多了一点点，年初有篇关于ChatGPT的博文一开始阅读量刷刷刷的涨，后来判定违规就被吞了，整体上博客内容比较基础，大多数来源于工作之中的知识点，也有一些是平时的思考和感悟，以下是近两年的数据对比。</p><p><img src="https://img-blog.csdnimg.cn/direct/6b8bf36d48904677a5bc85c80ac6e31e.png#pic_center" alt="vs-csdn"></p><a href="!--![2022csdn](https://img-blog.csdnimg.cn/direct/1b019f2ab6114156874451c0f6f20ad7.png#pic_center)![2023csdn](https://img-blog.csdnimg.cn/direct/77a16b7b2d6c406f9c30eda21fc529bc.png#pic_center)--">!--![2022csdn](https://img-blog.csdnimg.cn/direct/1b019f2ab6114156874451c0f6f20ad7.png#pic_center)![2023csdn](https://img-blog.csdnimg.cn/direct/77a16b7b2d6c406f9c30eda21fc529bc.png#pic_center)--</a><p>2023年一年的博客访问量突破了60万，相比于去年的40多万上升了不少，文章基数增多了应该是主要原因，去年的10W+文章<a href="https://blog.csdn.net/albertsh/article/details/92385277" target="_blank" rel="noopener">《float的精度和取值范围》</a> 一年就上涨了6万多，看来高质量的内容才是吸引人的关键，并且会形成头部效应，马太效应，出现强者恒强的情况。</p><p>今年的CSDN活动依旧不少，但是我已经很少参加了，一方面没有那么多时间，还有就是看不懂规则，年终的博客之星评选，由于博文的数量没有达标，连报名的资格都没有，有点遗憾。</p><p>关于刷题这个Flag约等于没有，别说刷题了，忙的连账号都没登录几次，刚刚看了看提交记录，仅在前两个月提交了十几道题，图我就不截了，有点磕碜，不过新的一年中可能需要多一点了，毕竟工作都不稳定了，得准备准备练练手感了。</p><p>技能树框架秃了，其实我也不想秃，但是每天回家总是很晚，我实在是懒得补充了，这明显是一个借口，但却是一个事实，心里知道这个事情要做，所以换了一种方式，改为记笔记的方式来弥补，一开始准备每天问自己一个问题，后来坚持不下来，但是每次有空闲想起来就会认真回答一次，然后就是将工作中遇到的盲点和知识点记录下来，为技能树积累素材。</p><p>阅读经典代码这部分还是以项目驱动为主，比如修改easyloging++文件描述符不释放的问题，分析libevent网络数据读取缓慢的问题，扩展框架支持 websocket 连接等，都是从项目需求实际出发，当然也看了一些帧同步小游戏的示例代码，有C#的也有JS的，暂时没有找到能明显解决我对帧同步疑问的项目，目前还在学习和寻找中。</p><p>读书一直没有停，由于每天大强度的工作时间，休息之余我已经不读技术类书籍了，现在读的更多是传记、小说、散文等等，通过一页页纸张回顾历史长河，窥探他人的一生。</p><p>有的人纷繁的一生落在纸上不过一页，而绝大多数人根部就不会在书本上留下痕迹。以下便是2023年阅读的书籍内容：</p><ul><li>时间从来不语却回答了所有问题（2023-2-12 13:56）<ul><li>一本杂记，更多的是晚年的人生</li></ul></li><li>苏东坡传 —— 一蓑烟雨任平生（2023-2-26 23:57）<ul><li>人身缘何不快乐，只因未读苏东坡</li></ul></li><li>知行合一王阳明（2023-3-12 20:43）<ul><li>良知源自内心，无需外求。功名利禄，本是外在的，得之我幸，不得我命。</li></ul></li><li>别让孩子伤在敏感期（2023-3-19 16:32:23）<ul><li>在孩子处于各种敏感期时，学会给予尊重，顺其自然，适时引导</li><li>不要规划孩子必须在哪一个领域取得成就，但只要她喜欢，就提供一个舞台，让她尽情去发挥</li></ul></li><li>我是猫（2023-6-25 00:48:05）<ul><li>两年的猫生戛然而止，古怪的苦沙弥高朋满座</li></ul></li><li>人间失格（2023-6-24 13:30:50）<ul><li>一个从小就将自己伪装起来的孩子着实令人害怕，让人回忆起了令人心酸的表哥</li><li>虽然一切都已经过去，但还是有些记忆片段会在读书是产生共鸣，从记忆深处涌上来</li><li>《斜阳》中的我是贵族是对时代的呐喊，回不去也融不进</li><li>《GoodBye》更是写成了幻想小说的范畴</li></ul></li><li>罗生门（2023-8-7 23:13:34）<ul><li>怪诞、讽刺、描写细致的短篇小说，不过有些故事的寓意看不太懂</li></ul></li><li>浮生六记（2023-11-26 22:35:23）<ul><li>初中时的课文《童趣》居然来自这本书，据说后两记是伪写的，但最后一记《养生记道》却多次引起共鸣，可能我正处在迷茫期吧。“五百年谪在红尘，略成游戏。三千里击开沧海，便是逍遥。”</li></ul></li><li>月亮与六便士（2023-12-10 17:00:27）<ul><li>一个完全不顾他人感受的人是否能称之为伟大，疯子还差不多</li></ul></li></ul><p>《苏东坡传》描写了苏东坡的一生，他虽狂放不羁，但有个一直拯救他的弟弟却是它一生的幸福，“人身缘何不快乐，只因未读苏东坡”，其实不止是苏东坡，很多大人物的一生就极其坎坷，如果看看他们的经历，我们的人生才刚刚开始，而如今这个浮躁的社会已经很难让人平静的接受这一切了。</p><p>《月亮与六便士》是一本很出名的书籍，从听说这本书到真正的开始读跨过了大概6、7年的时间，但如今读过之后却让与我的预想差距太大，我没想到这是一篇小说，斯特里克兰简直是一个变态，全文描述了他不顾一切的追求艺术，将其称之为伟大，但我觉得这样的伟大毫无意义，即使他的绘画技艺已经出神入化，世界也不缺他一个，但他却真实的伤害了周围的每一个人。</p><h2 id="投资上"><a href="#投资上" class="headerlink" title="投资上"></a>投资上</h2><blockquote><p>FLAG</p><ul><li>定投和智能条件单保持现状，ETF追加1~2个新的行业赛道</li><li>股票池还有几个垃圾票要找机会清理掉，手里的价投股票适当做做趋势</li><li>保持对新年经济的乐观，目标收益10个点</li></ul><p>完成度 ：50%</p></blockquote><p>今年除了少量增持了之前的“三傻”和科技股之外，追加了医药ETF和光伏ETF，设置了定投单和网格条件单，持仓的FLAG的是达到了，但收益有点一言难尽，手中的垃圾票清掉了部分，有些垃圾真得再等几年，这种票已经不关注了，就留在持仓列表里做个提醒好了。</p><p>工业富联算是今天收获颇丰的一个票，也是唯一一个高额正收益的票，去年的FLAG是【目标收益10个点】，可能这个愿望描述的不够具体，就像雍和宫许愿一样，被调剂成了负的，结果股票加基金损失了10个点左右，真是令人头大。</p><p><img src="https://img-blog.csdnimg.cn/direct/dcf20fef8ab34e2cac9bf3a3676c6be4.png#pic_center" alt="2023finance"></p><p>本来前10个月收益基本达标，但最后这一个季度，行情急转直下，价值投资带头向下俯冲，毫无招架之力。</p><h2 id="生活上"><a href="#生活上" class="headerlink" title="生活上"></a>生活上</h2><blockquote><p>FLAG</p><ul><li>疫情放开了，有事没事都趁着假期回家看看</li><li>身体很重要，锻炼的很费时，中和一下，可以跳跳绳</li><li>周末了陪娃耍一耍，工作尽量不占用周末的时间</li></ul><p>完成度 ：70%</p></blockquote><p>今年回家的次数也不是太多，元旦、春节、劳动节、国庆中秋节总计21天，比2022年的14天多了不少，主要差在了国庆假期上，回家正好收玉米，赶上了丰收的季节。</p><p>身体锻炼几乎没有，全年跳绳不超过3次，不过脂肪肝和高尿酸的情况都有所减轻，每天真的懒得不想动。</p><p>2023年的周末和工作日分的还是比较清晰的，工作日强度很大，但周末工作的时间很少了，真的是在家陪家人和或者一起出去逛逛，一家人去了之前谈论了8年还没去过的香山公园，看了一圈几乎还没红的枫叶。</p><p>去年的<a href="https://blog.csdn.net/albertsh/article/details/128509220" target="_blank" rel="noopener">总结</a>中给我养的<a href="https://img-blog.csdnimg.cn/ce62daf422b44245899491810d55e7d4.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9hbGJlcnRnaXRodWJob21lLmdpdGh1Yi5pby9ibG9nL2Fib3V0,size_14,color_FFFFFF,t_70#pic_center" target="_blank" rel="noopener">花花拍了照片</a>，今年对比了一下发现一年的时间长了很多，再拍一张照片看看。</p><p><img src="https://img-blog.csdnimg.cn/direct/0db1f97f7cdc4b40b0b3b3cec886986b.png#pic_center" alt="2023flower"></p><p>2023年初还补充了几盆多肉，从最开始的柔弱养成了郁郁葱葱的“绿油油”，这一年个头没少长，都窜的老高，就是不上颜色，可能是光照太少了？</p><p><img src="https://img-blog.csdnimg.cn/direct/2266494abc084622a2df361b00673cd6.png#pic_center" alt="2023flower2"></p><p>年初文章总结了<a href="https://blog.csdn.net/albertsh/article/details/128892715" target="_blank" rel="noopener">《工作十年对游戏看法的转变历程》</a>，文中提到我买了8090掌上游戏机玩俄罗斯方块，后来趁娃不在又买了Switch准备寻找灵感，但结果就是海关发货太慢了，等娃回来正好赶上游戏机送到，最后Switch就成了她的玩具。</p><p><img src="https://img-blog.csdnimg.cn/direct/422325b949a046fd9dcbc03a3364d5a5.png#pic_center" alt="在2023game"></p><p>现在每天没时间玩也不敢玩，和娃约定好了周末才可以玩一会，每周末充一次电，和宝宝一起玩一会赛车还是很有意思的，偶尔自己偷偷玩玩塞尔达，似乎这些才能被称之为真正的游戏，哪些哪里亮就点哪里的游戏真的能被称为游戏吗？自己对这类游戏有些厌倦了。</p><h1 id="展望2024"><a href="#展望2024" class="headerlink" title="展望2024"></a>展望2024</h1><h2 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h2><ul><li>今年的工作环境极其复杂，切换了新的赛道，工作内容繁杂，需要逐步将内容理顺</li><li>继续培养管理技能，面对不同的人采取不同的策略，尝试向上管理的方法</li><li>补充技能树框架，采取提问和总结的方式，有针对性的学习和探索，为新的工作机会打好基础</li></ul><h2 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h2><ul><li>40篇以上博客总结，尽量一周一篇，放假休息，保持知识库一直更新</li><li>刷题不要求每周有贡献了，不切实际的FLAG没有意义，希望每月有贡献吧</li><li>采取提问回答方式补充技能树，利用好别人总结好的知识，很多知识点没必要从头开始</li><li>阅读开源代码解决实际问题，今年想尝试的知识点有【帧同步】和【共享内存】</li><li>继续保持读书的习惯，今年的图书已经到位，类型多是历史、传记和小说</li></ul><p><img src="https://img-blog.csdnimg.cn/direct/453197020ff14f48b865f2a23e884d61.png#pic_center" alt="2023book"></p><h2 id="投资"><a href="#投资" class="headerlink" title="投资"></a>投资</h2><ul><li>垃圾票适时出清</li><li>保持定投和智能条件单策略，重点放在科技和医药赛道，光伏赛道等待产能出清，持续观望</li><li>环境很差，但依旧相信国运，考虑今年的进入低位，2024年目标正收益15个点（可得说清楚，避免调剂）</li></ul><h2 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h2><ul><li>假期回家时间不低于去年的21天</li><li>想跑跑步，目前仅停留在脑海里，每周末下楼去转转</li><li>养养花，新年不打算买新的花了，好好把目前的多肉养出状态</li><li>周末陪陪家人，希望不要被家里的神仙宝贝娃娃气炸</li></ul><p><img src="https://img-blog.csdnimg.cn/direct/aa6573e7bb8b455eb5cf55b441e9f0b0.png#pic_center" alt="在2023home"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>2023年作为魔幻的一年，本来被给予了美好的希望，没想到放开之后，情况变得越发糟糕，打破了人们的预期，报复性的反弹没有如约而至，很多事情在封闭期间没有发生，却在这个寒冷的冬天尝了个遍，HR在得知自己毕业消息后，需要在临行前通知其他小伙伴毕业，主管实在不想开人，最终不得不自己离开，这些事情听起来很新奇，却在这个寒冬中显得那么的习以为常。</p><p>最近看了一些书籍和记录片，已经渐渐的体会到，做人不能太明白，有时糊里糊涂的反而更幸福，如果作为一个明白人还能收放自如的糊里糊涂，那便是境界升华了。</p><p>你还相信光吗？<strong>我依旧相信</strong>！<strong><em>虽然深处寒冬，我心依旧向往光明</em></strong>，信仰的力量支撑着我们前进，不管现在的真实情况是向上还是向下，我相信总有一天会向上突破的，期待这一天早点到来~</p><p><img src="https://img-blog.csdnimg.cn/direct/d22fca83d9324df8bc6ddd91ec70a75f.png#pic_center" alt="2023life"></p><hr><center><a href="https://blog.csdn.net/albertsh/article/details/135161723" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>旧年伊始志气豪，万物焕新气宇高。<br>谁料寒冬多磨难，心怀光明盼春晓。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;不断追求利益的经济冲动，不停侵蚀人们的生活，压垮、吞噬并统治生活本身，无法言喻的不安和看不到明天的混沌感，让我们在现有社会经济条件下，沦为被金钱和物质所统治的行尸走肉~&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;最近在看一本叫《饱食穷民》的书，讲述的是泡沫经济年代的日本社会，宛如梦幻泡影一样变化无常，又像断梗浮萍一样飘忽不定，到处充斥着不安的色彩，我试图从中寻找一些当前现实问题的解决方案，上段文字也是出自此书之中，阅读之后我大受震撼，其中描述的有关软件工程师的篇章，简直就是我的复刻版，无论是心境、情感、还是所面临的问题都如出一辙，读完觉得背后隐隐发凉，因为最终那些令人无法接受的结局，确实是我不想看到的。&lt;/p&gt;
    
    </summary>
    
      <category term="Thinking" scheme="http://AlbertGithubHome.github.io/blog/categories/Thinking/"/>
    
    
      <category term="总结" scheme="http://AlbertGithubHome.github.io/blog/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="工作" scheme="http://AlbertGithubHome.github.io/blog/tags/%E5%B7%A5%E4%BD%9C/"/>
    
      <category term="学习" scheme="http://AlbertGithubHome.github.io/blog/tags/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="生活，投资" scheme="http://AlbertGithubHome.github.io/blog/tags/%E7%94%9F%E6%B4%BB%EF%BC%8C%E6%8A%95%E8%B5%84/"/>
    
  </entry>
  
  <entry>
    <title>Linux环境下通过journal命令查看和管理日志</title>
    <link href="http://AlbertGithubHome.github.io/blog/2023/12/22/Linux%E7%8E%AF%E5%A2%83%E4%B8%8B%E9%80%9A%E8%BF%87journal%E5%91%BD%E4%BB%A4%E6%9F%A5%E7%9C%8B%E5%92%8C%E7%AE%A1%E7%90%86%E6%97%A5%E5%BF%97/"/>
    <id>http://AlbertGithubHome.github.io/blog/2023/12/22/Linux环境下通过journal命令查看和管理日志/</id>
    <published>2023-12-22T14:03:50.000Z</published>
    <updated>2024-01-14T11:45:50.130Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>就在半月之前，负责打包更新的服务器突然登录不上去了，赶紧找来运维的同事帮忙解决，发现系统日志中有很多 <code>systemd-journald[424]: Failed to open runtime journal: No space left on device</code> 字样的错误，被告知磁盘满了需要清理，但是我当时登录不上去，只能让他们帮忙重启后利用单用户模式上去删除临时文件试试，但重启后发现问题解决了，很是诧异，查询服务器后台监控平台，发现磁盘空间还有50%，inode只占用了0.02%，这怎么会磁盘满了呢？</p><a id="more"></a><h1 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h1><p>后来经过分析，应该是journal默认将系统日志存储在/run/log/journal目录中，而 <code>/run</code>是一个临时文件系统，通常挂载在内存中，用于存储运行时产生的临时文件，如进程 ID 文件、锁文件等，如果登录所需的文件或进程受到 <code>/run</code> 空间不足的影响，可能会导致登录问题。例如，如果 <code>sshd</code> 进程的运行所需的文件被存储在 <code>/run</code> 中并且空间不足，那么可能无法正常登录。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ df -h</span><br><span class="line">Filesystem      Size  Used Avail Use% Mounted on</span><br><span class="line">devtmpfs        7.8G     0  7.8G   0% /dev</span><br><span class="line">tmpfs           7.8G  868K  7.8G   1% /run</span><br></pre></td></tr></table></figure><p>所以系统重启后，这个空间释放了也就能通过ssh登录了，并且重启后journal日志清空也证实了这一点。</p><p>关于这个空间限制多数说的是10%，但是如果真是的所处分区的10%，那么不会导致我登录不上的，所以我倾向于是系统内存10%或者硬盘最大10%，默认最大限制4G，具体限制等我有空时查查文档吧，先贴一段看起来很靠谱的描述</p><blockquote><p>SystemMaxUse=, SystemKeepFree=, SystemMaxFileSize=, SystemMaxFiles=, RuntimeMaxUse=, RuntimeKeepFree=, RuntimeMaxFileSize=, RuntimeMaxFiles=<br>限制日志文件的 大小上限。 以 “System” 开头的选项用于限制磁盘使用量， 也就是 /var/log/journal 的使用量。 以 “Runtime” 开头的选项用于限制内存使用量， 也就是 /run/log/journal 的使用量。 以 “System” 开头的选项仅在 /var/log/journal 目录确实存在且可写时才有意义。 但以 “Runtime” 开头的选项永远有意义。 也就是说， 在系统启动早期 /var 尚未挂载时、 或者系统管理员禁止在磁盘上存储日志的时候， 仅有 “Runtime” 开头的选项有意义。 journalctl 与 systemd-journald 工具会忽略日志目录中 所有后缀名不等于 “.journal” 或 “.journal~” 的文件。 换句话说，日志目录中不应该存在后缀名不等于 “.journal” 或 “.journal~” 的文件， 因为这些文件 永远不会被清理。</p><p>SystemMaxUse= 与 RuntimeMaxUse= 限制全部日志文件加在一起最多可以占用多少空间。 SystemKeepFree= 与 RuntimeKeepFree= 表示除日志文件之外，至少保留多少空间给其他用途。 systemd-journald 会同时考虑这两个因素， 并且尽量限制日志文件的总大小，以同时满足这两个限制。</p><p>SystemMaxUse= 与 RuntimeMaxUse= 的默认值是10%空间与4G空间两者中的较小者； SystemKeepFree= 与 RuntimeKeepFree= 的默认值是15%空间与4G空间两者中的较大者； 如果在 systemd-journald 启动时，文件系统即将被填满并且已经超越了 SystemKeepFree= 或 RuntimeKeepFree= 的限制，那么日志记录将被暂停。 也就是说，如果在创建日志文件时，文件系统有充足的空闲空间， 但是后来文件系统被其他非日志文件过多占用， 那么 systemd-journald 只会立即暂停日志记录， 但不会删除已经存在的日志文件。 注意，只会删除已归档的日志文件以释放空间。 也就是说，即使在完成日志清理之后， 日志所占用的空间仍然可能大于 SystemMaxUse= 或 RuntimeMaxUse= 的限制。</p><p>SystemMaxFileSize= 与 RuntimeMaxFileSize= 限制单个日志文件的最大体积， 到达此限制后日志文件将会自动滚动。 默认值是对应的 SystemMaxUse= 与 RuntimeMaxUse= 值的1/8 ， 这也意味着日志滚动 默认保留7个历史文件。</p><p>日志大小 可以使用以1024为基数的 K, M, G, T, P, E 后缀， 分别对应于 1024, 1024², … 字节。</p><p>SystemMaxFiles= 与 RuntimeMaxFiles= 限制最多允许同时存在多少个日志文件， 超出此限制后， 最老的日志文件将被删除， 而当前的活动日志文件 则不受影响。 默认值为100个。</p></blockquote><p>以上描述来自 <a href="https://www.jinbuguo.com/systemd/journald.conf.html" target="_blank" rel="noopener">《journald.conf 中文手册》</a>，另外 <a href="https://www.cnblogs.com/morgan363/p/13957565.html" target="_blank" rel="noopener">《Systemd日志管理服务：Journald以及重要配置选项》</a> 这篇博文也提到了默认日志数据将仅存储在内存中，在系统关闭时会删除该数据。</p><h1 id="journal-和-syslog-对比"><a href="#journal-和-syslog-对比" class="headerlink" title="journal 和 syslog 对比"></a>journal 和 syslog 对比</h1><p>提到系统日志除了journal比较常见以外，还有 syslog 也是比较基础的服务，两者都是日志服务，并且在系统中合理分工，相互配合，它们服务于不同的目标并且具有不同的特性。syslog是Linux系统的一套日志框架，它既可以记录日志到本地文件，也可以通过网络发送到接收syslog的服务器，以实现对多个设备的syslog消息进行统一的存储或解析。而journal是改进型的日志管理服务，主要收集来自内核、系统早期的启动阶段的日志以及系统守护进程在启动和运行中的标准输出和错误。</p><p>在CentOS 7及更高版本中，journalctl成为了查看和管理系统日志的主要工具，它从/var/log/journal/和/run/log/journal/等路径获取日志信息。同时，systemd-journald会将日志信息写入到socket文件/run/systemd/journal/syslog中，然后由rsyslog服务监听这个socket文件，从而实现对日志的统一管理和处理。因此，可以说syslog和journalctl在日志管理中各司其职，共同保障了Linux系统日志的完整性和可用性。</p><p>以上提到了一些名词，先说明一下来清楚其中的关系，journal日志使用journalctl工具管理，依赖<code>systemd-journald</code>服务，syslog日志可以用文本工具来查看，view、more、cat等命令都可以用，也可以借助其他工具查看特定信息，比如用dmesg命令查看syslog中内核相关日志，syslog依赖的服务名通常是 <code>rsyslogd</code></p><p><code>journalctl</code> 和 <code>syslog</code> 都是 Linux 系统中用于处理和查看系统日志的工具，我们从以下几个方面来对比下两者的区别：</p><ul><li><p><strong>存储方式：</strong></p><ul><li><code>syslog</code> 使用文本文件来存储日志信息，可以通过文本编辑器查看，通常存储在 <code>/var/log/syslog</code> 或 <code>/var/log/message</code></li><li><code>journalctl</code> 使用 <code>systemd-journald</code> 服务来存储二进制格式的日志文件。通常存储在 <code>/run/log/journal/</code> 或 <code>/var/log/journal/</code></li></ul></li><li><p><strong>日志内容：</strong></p><ul><li><code>syslog</code> 使用文本格式，记录在文本文件中。日志信息包含时间戳、主机名、应用程序名等</li><li><code>journalctl</code> 使用二进制格式，可以存储更多的元数据，例如进程 ID、用户 ID、SELinux 上下文等。这使得日志更加结构化，支持更高级的查询和过滤</li></ul></li><li><p><strong>查询和过滤：</strong></p><ul><li><code>syslog</code> 的查询和过滤通常使用命令行工具（例如 <code>grep</code>）或者专用的工具（例如 <code>logrotate</code>）</li><li><code>journalctl</code> 提供了更丰富和强大的查询和过滤功能，可以按时间、服务单元、日志级别等多个条件进行过滤。这使得查找和分析特定事件更加方便</li></ul></li><li><p><strong>实时查看：</strong></p><ul><li><code>syslog</code> 通常使用 <code>tail</code> 命令实时查看日志文件的末尾</li><li><code>journalctl</code> 可以使用 <code>-f</code> 或 <code>--follow</code> 选项来实时查看最新的日志</li></ul></li><li><p><strong>服务和依赖关系：</strong></p><ul><li><code>syslog</code> 是一个通用的日志服务，可以由多个日志守护进程（如 <code>rsyslog</code>、<code>syslog-ng</code>）实现</li><li><code>journalctl</code> 是 <code>systemd</code> 系统中的一部分，依赖于 <code>systemd-journald</code> 服务</li></ul></li><li><p><strong>配置文件的路径：</strong></p><ul><li><code>syslog</code> 的配置文件在 <code>/etc/rsyslog.conf</code></li><li><code>journalctl</code> 的配置文件在 <code>/etc/systemd/journald.conf</code></li></ul></li></ul><p>总体而言，<code>journalctl</code> 是 <code>systemd</code> 系统的一部分，提供了更现代化、结构化和强大的日志管理功能，但这并不意味着 <code>syslog</code> 是过时的。在一些系统中，两者可能同时存在，而且一些工具和服务可能仍然使用传统的 <code>syslog</code>。选择使用哪一个取决于系统的需求和管理员的偏好。</p><p>下面分别展示一下<code>systemd-journald</code> 和 <code>rsyslogd</code> 两个服务查询信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[root@demo ~]<span class="comment"># systemctl status systemd-journald</span></span><br><span class="line">● systemd-journald.service - Journal Service</span><br><span class="line">   Loaded: loaded (/usr/lib/systemd/system/systemd-journald.service; static; vendor preset: disabled)</span><br><span class="line">   Active: active (running) since Mon 2023-12-04 20:26:34 CST; 2 weeks 3 days ago</span><br><span class="line">     Docs: man:systemd-journald.service(8)</span><br><span class="line">           man:journald.conf(5)</span><br><span class="line"> Main PID: 7099 (systemd-journal)</span><br><span class="line">   Status: <span class="string">"Processing requests..."</span></span><br><span class="line">   CGroup: /system.slice/systemd-journald.service</span><br><span class="line">           └─7099 /usr/lib/systemd/systemd-journald</span><br><span class="line"></span><br><span class="line">Dec 04 20:26:34 demo systemd-journal[7099]: Permanent journal is using 8.0M (max allowed 4.0G, trying to leave 4.0G free of 183.5G available → c…imit 4.0G).</span><br><span class="line">Dec 04 20:26:34 demo systemd-journal[7099]: Time spent on flushing to /var is 21.108ms <span class="keyword">for</span> 1873 entries.</span><br><span class="line">Dec 04 20:26:34 demo systemd-journal[7099]: Journal started</span><br><span class="line">Hint: Some lines were ellipsized, use -l to show <span class="keyword">in</span> full.</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[root@demo ~]<span class="comment"># systemctl status rsyslogd</span></span><br><span class="line">Unit rsyslogd.service could not be found.</span><br><span class="line">[root@demo ~]<span class="comment"># systemctl status rsyslog</span></span><br><span class="line">● rsyslog.service - System Logging Service</span><br><span class="line">   Loaded: loaded (/usr/lib/systemd/system/rsyslog.service; enabled; vendor preset: enabled)</span><br><span class="line">   Active: active (running) since Mon 2023-12-04 19:46:04 CST; 2 weeks 3 days ago</span><br><span class="line">     Docs: man:rsyslogd(8)</span><br><span class="line">           http://www.rsyslog.com/doc/</span><br><span class="line"> Main PID: 913 (rsyslogd)</span><br><span class="line">   CGroup: /system.slice/rsyslog.service</span><br><span class="line">           └─913 /usr/sbin/rsyslogd -n</span><br><span class="line"></span><br><span class="line">Dec 04 19:46:04 demo systemd[1]: Starting System Logging Service...</span><br><span class="line">Dec 04 19:46:04 demo rsyslogd[913]:  [origin software=<span class="string">"rsyslogd"</span> swVersion=<span class="string">"8.24.0-57.el7_9.3"</span> x-pid=<span class="string">"913"</span> x-info=<span class="string">"http://www.rsyslog.com"</span>] start</span><br><span class="line">Dec 04 19:46:04 demo systemd[1]: Started System Logging Service.</span><br><span class="line">Dec 04 20:26:34 demo rsyslogd[913]: imjournal: journal reloaded... [v8.24.0-57.el7_9.3 try http://www.rsyslog.com/e/0 ]</span><br><span class="line">Dec 10 03:22:01 demo rsyslogd[913]:  [origin software=<span class="string">"rsyslogd"</span> swVersion=<span class="string">"8.24.0-57.el7_9.3"</span> x-pid=<span class="string">"913"</span> x-info=<span class="string">"http://www.rsyslog.com"</span>] rsys...was HUPed</span><br><span class="line">Dec 15 01:35:01 demo rsyslogd[913]: imjournal: journal reloaded... [v8.24.0-57.el7_9.3 try http://www.rsyslog.com/e/0 ]</span><br><span class="line">Dec 17 03:07:01 demo rsyslogd[913]:  [origin software=<span class="string">"rsyslogd"</span> swVersion=<span class="string">"8.24.0-57.el7_9.3"</span> x-pid=<span class="string">"913"</span> x-info=<span class="string">"http://www.rsyslog.com"</span>] rsys...was HUPed</span><br><span class="line">Hint: Some lines were ellipsized, use -l to show <span class="keyword">in</span> full.</span><br></pre></td></tr></table></figure><h1 id="journal-和-syslog-配置"><a href="#journal-和-syslog-配置" class="headerlink" title="journal 和 syslog 配置"></a>journal 和 syslog 配置</h1><p>两个服务的配置文件都有很多内容，在此只展示其中部分重要的参数，先看一下 <code>/etc/systemd/journald.conf</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[Journal]</span><br><span class="line">Storage=persistent              <span class="comment">#开启持久化存储</span></span><br><span class="line"><span class="comment">#Compress=yes                   #开启压缩功能</span></span><br><span class="line"><span class="comment">#Seal=yes</span></span><br><span class="line">SystemMaxUse=40%                <span class="comment">#设置系统最大占用率为40%</span></span><br><span class="line">StorageOption=size              <span class="comment">#设置存储选项为按大小进行存储</span></span><br><span class="line">StorageOption=autorotate        <span class="comment">#设置存储选项为自动轮换</span></span><br><span class="line">StoragePath=/<span class="built_in">export</span>/<span class="built_in">log</span>/journal <span class="comment">#设置日志文件的存储路径</span></span><br></pre></td></tr></table></figure><p>再看一下 <code>/etc/rsyslog.conf</code> 配置文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Include all config files in /etc/rsyslog.d/</span></span><br><span class="line"><span class="variable">$IncludeConfig</span> /etc/rsyslog.d/*.conf <span class="comment">#将包含 `/etc/rsyslog.d/` 目录下的所有以 `.conf` 结尾的配置文件，可以将配置分散到多个文件使得管理更加灵活</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Turn off message reception via local log socket;</span></span><br><span class="line"><span class="comment"># local messages are retrieved through imjournal now.</span></span><br><span class="line"><span class="variable">$OmitLocalLogging</span> on <span class="comment">#不再通过本地日志套接字接收消息，本地消息现在通过 `imjournal`（Journal 日志服务）来检索</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#### RULES ####</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Log all kernel messages to the console.</span></span><br><span class="line"><span class="comment"># Logging much else clutters up the screen.</span></span><br><span class="line"><span class="comment">#kern.*                                                 /dev/console</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Log anything (except mail) of level info or higher.</span></span><br><span class="line"><span class="comment"># Don't log private authentication messages!</span></span><br><span class="line">*.info;mail.none;authpriv.none;cron.none                /var/<span class="built_in">log</span>/messages <span class="comment">#将所有信息级别（info）以及除了邮件、认证、和 cron 之外的其他日志，都记录到 `/var/log/messages` 文件中</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The authpriv file has restricted access.</span></span><br><span class="line">authpriv.*                                              /var/<span class="built_in">log</span>/secure <span class="comment">#将所有 authpriv（私密认证）级别的日志记录到 `/var/log/secure` 文件中</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Log all the mail messages in one place.</span></span><br><span class="line">mail.*                                                  -/var/<span class="built_in">log</span>/maillog <span class="comment">#将所有邮件相关的日志记录到 `/var/log/maillog` 文件中</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Log cron stuff</span></span><br><span class="line">cron.*                                                  /var/<span class="built_in">log</span>/cron <span class="comment">#将所有 cron 服务相关的日志记录到 `/var/log/cron` 文件中</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Everybody gets emergency messages</span></span><br><span class="line">*.emerg                                                 :omusrmsg:*     <span class="comment">#将所有紧急级别（emergency）的日志消息发送到用户消息队列</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Save news errors of level crit and higher in a special file.</span></span><br><span class="line">uucp,news.crit                                          /var/<span class="built_in">log</span>/spooler <span class="comment">#将所有 uucp 和 news 的 crit 级别及更高级别的日志记录到 `/var/log/spooler` 文件中</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Save boot messages also to boot.log</span></span><br><span class="line">local7.*                                                /var/<span class="built_in">log</span>/boot.log <span class="comment">#表示保存启动消息到boot.log文件中</span></span><br></pre></td></tr></table></figure><h1 id="使用journalctl查看和管理日志"><a href="#使用journalctl查看和管理日志" class="headerlink" title="使用journalctl查看和管理日志"></a>使用journalctl查看和管理日志</h1><h2 id="查看日志"><a href="#查看日志" class="headerlink" title="查看日志"></a>查看日志</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看所有日志（默认情况下只保存本次启动的日志）</span></span><br><span class="line">$ sudo journalctl</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示尾部指定行数的日志，默认10行</span></span><br><span class="line">$ sudo journalctl -n 20</span><br><span class="line"></span><br><span class="line"><span class="comment"># 实时滚动显示最新日志</span></span><br><span class="line">$ sudo journalctl -f</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看指定时间的日志</span></span><br><span class="line">$ sudo journalctl --since yesterday</span><br><span class="line">$ sudo journalctl --since=<span class="string">"2023-12-22 16:52:18"</span></span><br><span class="line">$ sudo journalctl --since <span class="string">"30 min ago"</span></span><br><span class="line">$ sudo journalctl --since <span class="string">"2023-12-22 16:52:18"</span> --until <span class="string">"2023-12-22 23:52:18"</span></span><br><span class="line">$ sudo journalctl --since 09:00 --until <span class="string">"1 hour ago"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看内核日志，过滤掉应用日志</span></span><br><span class="line">$ sudo journalctl -k</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看系统本次启动的日志</span></span><br><span class="line">$ sudo journalctl -b</span><br><span class="line">$ sudo journalctl -b -0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看上一次启动的日志</span></span><br><span class="line">$ sudo journalctl -b -1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看指定优先级及其以上级别的日志，共有8级 0: emerg 1: alert 2: crit 3: err 4: warning 5: notice 6: info 7: debug</span></span><br><span class="line"><span class="comment"># -b 不加任何参数时，表示显示当前引导周期的日志。这意味着只显示自最近一次启动以来的日志。</span></span><br><span class="line"><span class="comment"># -b N： N 是一个整数，表示要显示第 N 个引导周期的日志。例如，-b 0 表示显示最新的引导周期，-b 1 表示显示上一个引导周期，以此类推</span></span><br><span class="line">$ sudo journalctl -p err -b</span><br><span class="line"></span><br><span class="line"><span class="comment"># 日志默认分页输出，--no-pager 改为正常的标准输出</span></span><br><span class="line">$ sudo journalctl --no-pager</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以单行 JSON 格式输出</span></span><br><span class="line">$ sudo journalctl -b -u nginx.service -o json</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以多行 JSON 可读性更好的格式输出</span></span><br><span class="line">$ sudo journalctl -b -u nginx.service  -o json-pretty</span><br></pre></td></tr></table></figure><h2 id="查看指定服务日志"><a href="#查看指定服务日志" class="headerlink" title="查看指定服务日志"></a>查看指定服务日志</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 查看指定服务的日志</span></span><br><span class="line">$ sudo journalctl /usr/sbin/sshd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看指定进程的日志</span></span><br><span class="line">$ sudo journalctl _PID=1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看某个路径的脚本的日志</span></span><br><span class="line">$ sudo journalctl /bin/bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看指定用户的日志</span></span><br><span class="line">$ sudo journalctl _UID=1000 --since today</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看某个 Unit 的日志</span></span><br><span class="line"><span class="comment"># 单元（unit）通常是 systemd 服务的一个抽象，用于表示系统中正在运行的各种服务或任务</span></span><br><span class="line">$ sudo journalctl -u nginx.service</span><br><span class="line">$ sudo journalctl -u nginx.service --since today</span><br><span class="line"></span><br><span class="line"><span class="comment"># 合并显示多个 Unit 的日志</span></span><br><span class="line">$ journalctl -u nginx.service -u ssh.service --since today</span><br></pre></td></tr></table></figure><h2 id="查看调整存储"><a href="#查看调整存储" class="headerlink" title="查看调整存储"></a>查看调整存储</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 显示日志占据的硬盘空间</span></span><br><span class="line">$ sudo journalctl --disk-usage</span><br><span class="line"></span><br><span class="line"><span class="comment"># 仅保留500MB大小的日志文减</span></span><br><span class="line">$ sudo journalctl --vacuum-size=500M</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定日志文件保存多久</span></span><br><span class="line">$ sudo journalctl --vacuum-time=1years</span><br><span class="line"></span><br><span class="line"><span class="comment"># 仅保留最近一个月的日志文件</span></span><br><span class="line">$ sudo journalctl --vacuum-time=1m</span><br><span class="line"></span><br><span class="line"><span class="comment"># 仅保留最近2天的日志文件</span></span><br><span class="line">$ sudo journalctl --vacuum-time=2d</span><br></pre></td></tr></table></figure><h1 id="回到文章开头的问题"><a href="#回到文章开头的问题" class="headerlink" title="回到文章开头的问题"></a>回到文章开头的问题</h1><p>通过梳理知识，我发现通过 <code>systemctl</code> 命令查询 <code>systemd-journald</code> 服务状态可以看到日志存储路径和存储限制，分别展示一下，先看存储到内存的：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">root@demo1:~<span class="comment"># systemctl status systemd-journald</span></span><br><span class="line">● systemd-journald.service - Journal Service</span><br><span class="line">   Loaded: loaded (/lib/systemd/system/systemd-journald.service; static; vendor preset: enabled)</span><br><span class="line">   Active: active (running) since Fri 2023-12-22 10:25:43 CST; 10h ago</span><br><span class="line">     Docs: man:systemd-journald.service(8)</span><br><span class="line">           man:journald.conf(5)</span><br><span class="line"> Main PID: 1132 (systemd-journal)</span><br><span class="line">   Status: <span class="string">"Processing requests..."</span></span><br><span class="line">    Tasks: 1</span><br><span class="line">   Memory: 272.0K</span><br><span class="line">      CPU: 204ms</span><br><span class="line">   CGroup: /system.slice/systemd-journald.service</span><br><span class="line">           └─1132 /lib/systemd/systemd-journald</span><br><span class="line"></span><br><span class="line">Dec 22 10:25:43 demo1 systemd-journald[1132]: Runtime journal (/run/<span class="built_in">log</span>/journal/) is 8.0M, max 159.9M, 151.9M free.</span><br><span class="line">Dec 22 10:25:43 demo1 systemd-journald[1132]: Journal started</span><br><span class="line">root@demo1:~<span class="comment"># df -h</span></span><br><span class="line">Filesystem      Size  Used Avail Use% Mounted on</span><br><span class="line">udev            7.8G     0  7.8G   0% /dev</span><br><span class="line">tmpfs           1.6G  9.3M  1.6G   1% /run</span><br><span class="line">/dev/sda1        83G   29G   51G  36% /</span><br><span class="line">tmpfs           7.9G     0  7.9G   0% /dev/shm</span><br><span class="line">tmpfs           5.0M     0  5.0M   0% /run/lock</span><br><span class="line">tmpfs           7.9G     0  7.9G   0% /sys/fs/cgroup</span><br><span class="line">/dev/sdb       1017G  903G  115G  89% /<span class="built_in">export</span></span><br><span class="line">tmpfs           1.6G     0  1.6G   0% /run/user/111</span><br><span class="line">tmpfs           1.6G     0  1.6G   0% /run/user/1001</span><br></pre></td></tr></table></figure><p>默认存储到 /run/log/journal/中，分区一共1.6G，最大max 159.9M，当前用了 8.0M，按这个来推算果然限制是10%，再看看持久化的情况</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">root@jenkins2004:~<span class="comment"># systemctl status systemd-journald</span></span><br><span class="line">● systemd-journald.service - Journal Service</span><br><span class="line">     Loaded: loaded (/lib/systemd/system/systemd-journald.service; static; vendor preset: enabled)</span><br><span class="line">     Active: active (running) since Sun 2023-08-27 09:24:15 CST; 3 months 26 days ago</span><br><span class="line">TriggeredBy: ● systemd-journald-dev-log.socket</span><br><span class="line">             ● systemd-journald.socket</span><br><span class="line">             ● systemd-journald-audit.socket</span><br><span class="line">       Docs: man:systemd-journald.service(8)</span><br><span class="line">             man:journald.conf(5)</span><br><span class="line">   Main PID: 375 (systemd-journal)</span><br><span class="line">     Status: <span class="string">"Processing requests..."</span></span><br><span class="line">      Tasks: 1 (<span class="built_in">limit</span>: 19123)</span><br><span class="line">     Memory: 42.7M</span><br><span class="line">     CGroup: /system.slice/systemd-journald.service</span><br><span class="line">             └─375 /lib/systemd/systemd-journald</span><br><span class="line"></span><br><span class="line">8月 27 09:24:15 jenkins2004 systemd-journald[375]: Journal started</span><br><span class="line">8月 27 09:24:15 jenkins2004 systemd-journald[375]: Time spent on flushing to /var/<span class="built_in">log</span>/journal/cc9ad539032546a1bd39a773d37e415f is 613.827ms <span class="keyword">for</span> 1229 entries.</span><br><span class="line">8月 27 09:24:15 jenkins2004 systemd-journald[375]: System Journal (/var/<span class="built_in">log</span>/journal/cc9ad539032546a1bd39a773d37e415f) is 1.4G, max 4.0G, 2.5G free.</span><br><span class="line">8月 27 09:24:22 jenkins2004 systemd-journald[375]: Forwarding to syslog missed 1 messages.</span><br><span class="line">8月 27 09:24:53 jenkins2004 systemd-journald[375]: Forwarding to syslog missed 80 messages.</span><br><span class="line">Warning: journal has been rotated since unit was started, output may be incomplete.</span><br><span class="line">root@jenkins2004:~<span class="comment"># df -h | grep -v snap</span></span><br><span class="line">Filesystem      Size  Used Avail Use% Mounted on</span><br><span class="line">udev            7.8G     0  7.8G   0% /dev</span><br><span class="line">tmpfs           1.6G  1.6M  1.6G   1% /run</span><br><span class="line">/dev/sda5       590G  369G  191G  66% /</span><br><span class="line">tmpfs           7.9G     0  7.9G   0% /dev/shm</span><br><span class="line">tmpfs           5.0M     0  5.0M   0% /run/lock</span><br><span class="line">tmpfs           7.9G     0  7.9G   0% /sys/fs/cgroup</span><br><span class="line">/dev/sda1       511M  4.0K  511M   1% /boot/efi</span><br><span class="line">tmpfs           1.6G   36K  1.6G   1% /run/user/125</span><br><span class="line">tmpfs           1.6G  4.0K  1.6G   1% /run/user/1002</span><br></pre></td></tr></table></figure><p>看起来存到了 <code>var/log/journal</code>，最大可用空间居然到了4G，这样来分析这次的问题可能不是journal日志搞的鬼，而是很多进程吧/run目录写满了，导致journal写不进去报了开头的错误，进而引发的无法登录。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>syslog和journal在日志管理中各司其职，共同保障了Linux系统日志的完整性和可用性</li><li>journal默认将系统日志存储在/run/log/journal目录中，而 <code>/run</code> 通常挂载在内存中，当此目录被写满时可能导致ssh无法登录</li><li>将 <code>/etc/systemd/journald.conf</code> 配置中的 Storage 字段设置为 <code>persistent</code> 可以开启日志持久化</li><li><code>sudo journalctl -n 20</code> 可以显示显示尾部最新的20行日志，-n后不加参数默认10行</li><li><code>sudo journalctl -u nginx.service</code> 查看ssh服务器的日志</li><li><code>sudo journalctl --since=&quot;2023-12-22 16:52:18&quot;</code> 查看指定时间以后的日志</li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/135094892" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>寒意一波接着一波，总会有看见“光”的时候（30厘米的下跌，摔得可真疼）</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;就在半月之前，负责打包更新的服务器突然登录不上去了，赶紧找来运维的同事帮忙解决，发现系统日志中有很多 &lt;code&gt;systemd-journald[424]: Failed to open runtime journal: No space left on device&lt;/code&gt; 字样的错误，被告知磁盘满了需要清理，但是我当时登录不上去，只能让他们帮忙重启后利用单用户模式上去删除临时文件试试，但重启后发现问题解决了，很是诧异，查询服务器后台监控平台，发现磁盘空间还有50%，inode只占用了0.02%，这怎么会磁盘满了呢？&lt;/p&gt;
    
    </summary>
    
      <category term="linux" scheme="http://AlbertGithubHome.github.io/blog/categories/linux/"/>
    
    
      <category term="linux" scheme="http://AlbertGithubHome.github.io/blog/tags/linux/"/>
    
      <category term="运维" scheme="http://AlbertGithubHome.github.io/blog/tags/%E8%BF%90%E7%BB%B4/"/>
    
      <category term="服务器" scheme="http://AlbertGithubHome.github.io/blog/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
      <category term="journalctl" scheme="http://AlbertGithubHome.github.io/blog/tags/journalctl/"/>
    
      <category term="syslog" scheme="http://AlbertGithubHome.github.io/blog/tags/syslog/"/>
    
  </entry>
  
  <entry>
    <title>gitlab修改代码库的名称、路径和分组</title>
    <link href="http://AlbertGithubHome.github.io/blog/2023/12/19/gitlab%E4%BF%AE%E6%94%B9%E4%BB%A3%E7%A0%81%E5%BA%93%E7%9A%84%E5%90%8D%E7%A7%B0%E3%80%81%E8%B7%AF%E5%BE%84%E5%92%8C%E5%88%86%E7%BB%84/"/>
    <id>http://AlbertGithubHome.github.io/blog/2023/12/19/gitlab修改代码库的名称、路径和分组/</id>
    <published>2023-12-19T14:20:24.000Z</published>
    <updated>2023-12-19T16:13:09.824Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>工作项目的源码使用gitlab进行管理，通常情况下不会修改代码库和路径，但是非一般的情况总是存在，比如刚刚立项时多次调整项目名，甚至改变管理层级，所以还是有这类需求的，一开始我本打算将旧的代码库和提交记录推送到新的地址和分组，后来在gitlab后台里翻了翻，结合网络大神们的指点，发现可以直接修改代码库的名称和分组，总共需要修改3个配置，一起来看下。</p><a id="more"></a><h1 id="修改过程"><a href="#修改过程" class="headerlink" title="修改过程"></a>修改过程</h1><h2 id="具体需求"><a href="#具体需求" class="headerlink" title="具体需求"></a>具体需求</h2><p>假设需求是将项目名从 <code>A</code> 改为 <code>B</code>，同时将访问路径从 <code>git@gitlab.example.cn:APrject/AGroup/A.git</code> 改为 <code>git@gitlab.example.cn:APrject/AGroup/B.git</code>，这里一共有三处需要修改：项目名、访问路径、以及分组，下面依次列举出修改的方法：</p><h2 id="修改项目名"><a href="#修改项目名" class="headerlink" title="修改项目名"></a>修改项目名</h2><p>导航路径【Settings】-&gt;【General】-&gt;【Naming, topics, avatar】-&gt;【Project name】，只需填入新的项目名，点击 “Save changes” 按钮即可，页面展示如下：</p><p><img src="https://img-blog.csdnimg.cn/direct/9f3e4a5c908f479e918ee20fdb86e14c.png" alt="Project name"></p><h2 id="修改访问路径"><a href="#修改访问路径" class="headerlink" title="修改访问路径"></a>修改访问路径</h2><p>做完上一步只是修改了项目名字，如果使用 <code>git clone</code> 命令下载整个库，路径是没有发生变化的，修改访问路径需要调整 “Path”</p><p>导航路径【Settings】-&gt;【General】-&gt;【Advanced】-&gt;【Expand】-&gt;【Change path】，只能修改最后一段Path，其中不能再包含 <code>/</code>，修改后点击 “Change path” 即可，页面展示如下：</p><p><img src="https://img-blog.csdnimg.cn/direct/1568d9ff2cbf4dd0b82ca05e235371f9.png" alt="Change path1"></p><p><img src="https://img-blog.csdnimg.cn/direct/80006b8b2fb84ea1bc493a6668e2f960.png" alt="Change path2"></p><h2 id="修改分组"><a href="#修改分组" class="headerlink" title="修改分组"></a>修改分组</h2><p>上面修改路径这一步只允许修改Path的最后一段，不能直接调整分组路径，想要调整前面的路径需要调整分组</p><p>导航路径【Settings】-&gt;【General】-&gt;【Advanced】-&gt;【Expand】-&gt;【Transfer project】，这一步只能选择已有的分组，选择好目标分组，点击 “Transfer project” 按钮即可，页面展示如下：</p><p><img src="https://img-blog.csdnimg.cn/direct/20dac08bf02049bf9b6f4fcb8f00a637.png" alt="Transfer project"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>gitlab后台可以直接修改代码库的名称、路径和分组等信息，不必重新创建项目</li><li>在修改名称、路径和分组等信息后需要相关人员更新对原有代码库的引用，否则会找不到</li><li>使用 <code>git remote set-url origin &lt;new-url&gt;</code> 命令可以更新已有仓库的URL</li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/134981708" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>对未来的迷茫以及内心的不安，让我们在现有社会经济条件下，沦为被金钱和物质所统治的行尸走肉</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;工作项目的源码使用gitlab进行管理，通常情况下不会修改代码库和路径，但是非一般的情况总是存在，比如刚刚立项时多次调整项目名，甚至改变管理层级，所以还是有这类需求的，一开始我本打算将旧的代码库和提交记录推送到新的地址和分组，后来在gitlab后台里翻了翻，结合网络大神们的指点，发现可以直接修改代码库的名称和分组，总共需要修改3个配置，一起来看下。&lt;/p&gt;
    
    </summary>
    
      <category term="Git" scheme="http://AlbertGithubHome.github.io/blog/categories/Git/"/>
    
    
      <category term="git" scheme="http://AlbertGithubHome.github.io/blog/tags/git/"/>
    
      <category term="gitlab" scheme="http://AlbertGithubHome.github.io/blog/tags/gitlab/"/>
    
      <category term="修改项目名" scheme="http://AlbertGithubHome.github.io/blog/tags/%E4%BF%AE%E6%94%B9%E9%A1%B9%E7%9B%AE%E5%90%8D/"/>
    
      <category term="修改路径" scheme="http://AlbertGithubHome.github.io/blog/tags/%E4%BF%AE%E6%94%B9%E8%B7%AF%E5%BE%84/"/>
    
      <category term="修改分组" scheme="http://AlbertGithubHome.github.io/blog/tags/%E4%BF%AE%E6%94%B9%E5%88%86%E7%BB%84/"/>
    
      <category term="后台管理" scheme="http://AlbertGithubHome.github.io/blog/tags/%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>利用websockify将websocket通信转换成tcp</title>
    <link href="http://AlbertGithubHome.github.io/blog/2023/12/13/%E5%88%A9%E7%94%A8websockify%E5%B0%86websocket%E9%80%9A%E4%BF%A1%E8%BD%AC%E6%8D%A2%E6%88%90tcp/"/>
    <id>http://AlbertGithubHome.github.io/blog/2023/12/13/利用websockify将websocket通信转换成tcp/</id>
    <published>2023-12-13T14:30:05.000Z</published>
    <updated>2023-12-19T16:11:09.636Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>目前遇到一个问题，原本的服务都是利用tcp通信的，但是某些平台只支持websocket，是不是要从头实现一套websocket网络收发逻辑呢？短时间内有没有替代方案呢？在经过一番寻找之后发现了websockify这个神器，可以将websocket协议转换成tcp协议，从而实现不修改应用服务就支持tcp协议的目的，接下来就说说它怎么用，以及探索的过程。</p><a id="more"></a><h1 id="websockify"><a href="#websockify" class="headerlink" title="websockify"></a>websockify</h1><h2 id="websockify-介绍"><a href="#websockify-介绍" class="headerlink" title="websockify 介绍"></a>websockify 介绍</h2><p><a href="https://github.com/novnc/websockify/tree/master" target="_blank" rel="noopener">websockify</a> 是一个用于将 WebSocket 流量转发到其他协议的工具，它的主要用途之一是将 WebSockets 转发到基于 TCP 的协议，例如 VNC（Virtual Network Computing），以下是它的一些关键特点和用途：</p><ul><li><p><strong>WebSocket 转发：</strong> <code>websockify</code> 允许你将 WebSocket 流量转发到其他类型的网络服务，使得你可以通过 WebSocket 连接访问这些服务。</p></li><li><p><strong>VNC 转发：</strong> <code>websockify</code> 最常用于将 WebSocket 转发到 VNC 服务器。这使得你可以通过 Web 浏览器访问运行 VNC 服务的远程计算机的桌面。</p></li><li><p><strong>安全性：</strong> <code>websockify</code> 支持加密通信，因此可以在安全连接上运行，提供更好的数据保护。</p></li><li><p><strong>协议适配：</strong> <code>websockify</code> 提供了一个通用的桥接机制，允许你将 WebSocket 连接转发到支持其他协议的服务，而不仅仅是 VNC。</p></li><li><p><strong>JavaScript 客户端：</strong> <code>websockify</code> 还包括一个 JavaScript 客户端库，可以直接在浏览器中使用，无需额外的插件。</p></li></ul><p>使用 websockify 的典型场景包括在 Web 浏览器中访问远程计算机的桌面，或者通过 WebSocket 连接到其他需要 TCP 连接的服务，在实际应用中，你可以通过命令行使用 websockify，也可以将其嵌入到其他应用程序中。</p><h2 id="websockify-使用"><a href="#websockify-使用" class="headerlink" title="websockify 使用"></a>websockify 使用</h2><p>在Ubuntu系统下可以直接使用以下安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt install websockify</span><br></pre></td></tr></table></figure><p>下面是一个使用示例，作用是将原本连接到8765的websocket请求转换成tcp请求，TCP端口4321</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ websockify 8765 127.0.0.1:12346</span><br></pre></td></tr></table></figure><p>启动后原本仅支持TCP协议的服务就可以通过websockify实现对websocket的支持了</p><h1 id="探索的过程"><a href="#探索的过程" class="headerlink" title="探索的过程"></a>探索的过程</h1><p>虽然是短短的一条 <code>websockify 8765 127.0.0.1:12346</code> 命令就可以实现从websocket到tcp的转换，但是探索的过程却不顺利，在发现<code>websockify</code>这个神器之后，首先是测试它是否能满足我们的需求，是否好用，但是直接在原有的服务上测试太费时间，所以尝试写了几个模拟的脚本。</p><h2 id="提供基础TCP服务"><a href="#提供基础TCP服务" class="headerlink" title="提供基础TCP服务"></a>提供基础TCP服务</h2><p>最基本的我们需要一个很能提供TCP服务的程序，这里我使用python写了一个回显的服务器 echoserver.py，绑定本地的12346端口</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 创建一个TCP套接字</span></span><br><span class="line">    server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 绑定IP地址和端口</span></span><br><span class="line">    server_socket.bind((<span class="string">'127.0.0.1'</span>, <span class="number">12346</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 监听连接</span></span><br><span class="line">    server_socket.listen(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">    print(<span class="string">"服务器已启动，等待客户端连接..."</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        <span class="comment"># 接受客户端连接</span></span><br><span class="line">        client_socket, client_address = server_socket.accept()</span><br><span class="line">        print(<span class="string">f"客户端<span class="subst">&#123;client_address&#125;</span>已连接"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 接收客户端发送的数据</span></span><br><span class="line">        data = client_socket.recv(<span class="number">1024</span>)</span><br><span class="line">        print(<span class="string">f"收到来自<span class="subst">&#123;client_address&#125;</span>的数据： <span class="subst">&#123;data.decode(<span class="string">'utf-8'</span>)&#125;</span>"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 将接收到的数据发送回客户端</span></span><br><span class="line">        client_socket.send(data)</span><br><span class="line">        print(<span class="string">f"已将数据发送回<span class="subst">&#123;client_address&#125;</span>"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 关闭客户端套接字</span></span><br><span class="line">        client_socket.close()</span><br><span class="line">        print(<span class="string">f"客户端<span class="subst">&#123;client_address&#125;</span>已断开连接"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h3 id="测试可用"><a href="#测试可用" class="headerlink" title="测试可用"></a>测试可用</h3><ul><li>启动服务</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ python3 echoserver.py</span><br><span class="line">服务器已启动，等待客户端连接...</span><br></pre></td></tr></table></figure><ul><li>用nc命令发送tcp数据</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">"Hello server"</span> | nc 127.0.0.1 12346</span><br><span class="line">Hello server</span><br></pre></td></tr></table></figure><ul><li>TCP服务器看到的内容</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">服务器已启动，等待客户端连接...</span><br><span class="line">客户端(<span class="string">'127.0.0.1'</span>, 59214)已连接</span><br><span class="line">收到来自(<span class="string">'127.0.0.1'</span>, 59214)的数据： Hello server</span><br><span class="line"></span><br><span class="line">已将数据发送回(<span class="string">'127.0.0.1'</span>, 59214)</span><br><span class="line">客户端(<span class="string">'127.0.0.1'</span>, 59214)已断开连接</span><br></pre></td></tr></table></figure><p>TCP服务一切正常</p><h2 id="实现Websocket客户端"><a href="#实现Websocket客户端" class="headerlink" title="实现Websocket客户端"></a>实现Websocket客户端</h2><p>因为python的运行环境是现成的，所以我又用它写了一个websocket客户端 wsclient.py 来发送数据，想运行的话得安装几个包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python3 -m pip install websocket</span><br><span class="line">python3 -m pip install websocket-client</span><br></pre></td></tr></table></figure><blockquote><p>真实的情况下我是用websocket客户端连接nginx，然后将nginx转发到websockify监听端口，然后websockify将数据转成tcp连接应用服务，但是这个过程太复杂了，不利于说明问题，所以后面的内容我省掉nginx，假装它不存在，直接用websocket客户端连接websockify监听端口</p></blockquote><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># 运行websocket服务器</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> websocket</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_message</span><span class="params">(ws, message)</span>:</span></span><br><span class="line">    print(<span class="string">f"Received message: <span class="subst">&#123;message&#125;</span>"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_error</span><span class="params">(ws, error)</span>:</span></span><br><span class="line">    print(<span class="string">f"Error: <span class="subst">&#123;error&#125;</span>"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_close</span><span class="params">(ws, close_status_code, close_msg)</span>:</span></span><br><span class="line">    print(<span class="string">f"Connection closed with status code <span class="subst">&#123;close_status_code&#125;</span>"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_open</span><span class="params">(ws)</span>:</span></span><br><span class="line">    print(<span class="string">"Connection opened"</span>)</span><br><span class="line">    <span class="comment"># 在连接建立后发送一条消息</span></span><br><span class="line">    ws.send(<span class="string">"abcd"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="comment"># WebSocket 服务器地址</span></span><br><span class="line">    ws_url = <span class="string">"ws://10.10.49.172:8765"</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建 WebSocket 连接</span></span><br><span class="line">    ws = websocket.WebSocketApp(ws_url,</span><br><span class="line">                                on_message=on_message,</span><br><span class="line">                                on_error=on_error,</span><br><span class="line">                                on_close=on_close)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 设置连接建立时的回调函数</span></span><br><span class="line">    ws.on_open = on_open</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 启动 WebSocket 连接</span></span><br><span class="line">    ws.run_forever()</span><br></pre></td></tr></table></figure><p>为了websocket客户端的测试，我写了一个websocket服务器 wsserver.py 来接收数据，不过这不是一开始就测试了，而是在后面发现转换TCP失败查找原因，按流程分段测试时补充的脚本内容</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> websockets</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">echo</span><span class="params">(websocket, path)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">async</span> <span class="keyword">for</span> message <span class="keyword">in</span> websocket:</span><br><span class="line">            print(<span class="string">f"Received message: <span class="subst">&#123;message&#125;</span>"</span>)</span><br><span class="line">            <span class="keyword">await</span> websocket.send(message)</span><br><span class="line">    <span class="keyword">except</span> websockets.exceptions.ConnectionClosed:</span><br><span class="line">        print(<span class="string">"WebSocket connection closed"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    server = <span class="keyword">await</span> websockets.serve(echo, <span class="string">"0.0.0.0"</span>, <span class="number">12346</span>)</span><br><span class="line"></span><br><span class="line">    print(<span class="string">"WebSocket server is running..."</span>)</span><br><span class="line">    <span class="keyword">await</span> server.wait_closed()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    asyncio.run(main())</span><br></pre></td></tr></table></figure><p>测试结果websocket客户端发送的数据，websocket服务器可以正常收到。</p><h2 id="开始测试websockify功能"><a href="#开始测试websockify功能" class="headerlink" title="开始测试websockify功能"></a>开始测试websockify功能</h2><ul><li>启动tcp服务echoserver，监听12346端口</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ python3 echoserver.py</span><br><span class="line">服务器已启动，等待客户端连接...</span><br></pre></td></tr></table></figure><ul><li>启动tcp服务websockify，监听8765端口，转换到12346端口</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ websockify 8765 127.0.0.1:12346</span><br><span class="line">WebSocket server settings:</span><br><span class="line">  - Listen on :8765</span><br><span class="line">  - No SSL/TLS support (no cert file)</span><br><span class="line">  - proxying from :8765 to 127.0.0.1:12346</span><br></pre></td></tr></table></figure><ul><li>运行websocket客户端发送的数据</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ python3 ./wsclient.py</span><br><span class="line">Connection opened</span><br><span class="line">Connection closed with status code 1003</span><br></pre></td></tr></table></figure><p>报错了！！！</p><p>再看echoserver输出，虽然连接成功，但是收到的数据为空</p><blockquote><p>客户端(‘127.0.0.1’, 55032)已连接<br>收到来自(‘127.0.0.1’, 55032)的数据：<br>已将数据发送回(‘127.0.0.1’, 55032)<br>客户端(‘127.0.0.1’, 55032)已断开连接</p></blockquote><p>然后看下websockify输出，显示转发连接12346端口成功了，但是没有后续输出</p><blockquote><p>$ websockify 8765 127.0.0.1:12346<br>WebSocket server settings:</p><ul><li>Listen on :8765</li><li>No SSL/TLS support (no cert file)</li><li>proxying from :8765 to 127.0.0.1:12346<br>10.2.48.36 - - [13/Dec/2023 20:03:11] 10.2.48.36: Plain non-SSL (ws://) WebSocket connection<br>10.2.48.36 - - [13/Dec/2023 20:03:11] connecting to: 127.0.0.1:12346</li></ul></blockquote><p>定位问题吧，期间不断调整nginx配置，查看nginx和websockify日志，调整wsclient写法，调整echoserver写法，分步测试wsclient和echoserver功能都没发现问题，具体测试细节暂且不表，后来我发现可以修改websockify启动参数输出更详细的日志，测试过程如下</p><h3 id="再次启动websockify"><a href="#再次启动websockify" class="headerlink" title="再次启动websockify"></a>再次启动websockify</h3><p>启动websockify再次使用wsclient测试，输出了额外的信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$ websockify 8765 127.0.0.1:12346 --<span class="built_in">log</span>-file /tmp/ws.log -v --traffic</span><br><span class="line">WebSocket server settings:</span><br><span class="line">  - Listen on :8765</span><br><span class="line">  - No SSL/TLS support (no cert file)</span><br><span class="line">  - proxying from :8765 to 127.0.0.1:12346</span><br><span class="line">10.2.48.36: new handler Process</span><br><span class="line">10.2.48.36 - - [13/Dec/2023 20:13:42] <span class="string">"GET / HTTP/1.1"</span> 101 -</span><br><span class="line">10.2.48.36 - - [13/Dec/2023 20:13:42] 10.2.48.36: Plain non-SSL (ws://) WebSocket connection</span><br><span class="line">10.2.48.36 - - [13/Dec/2023 20:13:42] connecting to: 127.0.0.1:12346</span><br><span class="line"></span><br><span class="line">Traffic Legend:</span><br><span class="line">    &#125;  - Client receive</span><br><span class="line">    &#125;. - Client receive partial</span><br><span class="line">    &#123;  - Target receive</span><br><span class="line"></span><br><span class="line">    &gt;  - Target send</span><br><span class="line">    &gt;. - Target send partial</span><br><span class="line">    &lt;  - Client send</span><br><span class="line">    &lt;. - Client send partial</span><br><span class="line">&#125;.10.2.48.36 - - [13/Dec/2023 20:13:42] 127.0.0.1:12346: Client closed connection</span><br><span class="line">10.2.48.36 - - [13/Dec/2023 20:13:42] 127.0.0.1:12346: Closed target</span><br></pre></td></tr></table></figure><p>顺着结尾的两条日志 <code>Client closed connection</code>，我找到了这一篇问题 <a href="https://github.com/novnc/websockify/issues/365" target="_blank" rel="noopener"><br>websockify - Client disconnects immediately after connection #365</a> 结论说是websockify不支持发送文本了</p><blockquote><p>Hmm… Are you trying to send text over that socket? We dropped support for text frames in the big cleanup.</p><p>Could you print the code and reason from the close in your close handler?</p></blockquote><p>我一看我的wsclient.py可不就是发送的文本嘛，看来有救了，赶紧改成了发送bytes <code>ws.send(b&#39;\x01\x02\x03\x04&#39;)</code>，但错误依旧，尝试各种发送函数无果，我严重怀疑我的换个python的websockets包有问题，所以我用html写了一个wsclient.html：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>WebSocket Binary Data Example<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">        <span class="comment">// 替换为你的 WebSocket 服务器地址</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">const</span> socket = <span class="keyword">new</span> WebSocket(<span class="string">"ws://10.10.49.172:8765"</span>);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">        <span class="comment">// 监听连接打开事件</span></span></span><br><span class="line"><span class="javascript">        socket.addEventListener(<span class="string">"open"</span>, (event) =&gt; &#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">"WebSocket connection opened."</span>);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">            <span class="comment">// 构造二进制数据，这里使用一个简单的示例</span></span></span><br><span class="line"><span class="javascript">            <span class="keyword">const</span> binaryData = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>([<span class="number">49</span>, <span class="number">50</span>, <span class="number">51</span>, <span class="number">52</span>]);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">            <span class="comment">// 发送二进制数据</span></span></span><br><span class="line"><span class="undefined">            socket.send(binaryData);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">"Binary data sent successfully."</span>);</span></span><br><span class="line"><span class="undefined">        &#125;);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">        <span class="comment">// 监听接收消息事件</span></span></span><br><span class="line"><span class="javascript">        socket.addEventListener(<span class="string">"message"</span>, (event) =&gt; &#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">"Received message:"</span>, event.data);</span></span><br><span class="line"><span class="undefined">        &#125;);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">        <span class="comment">// 监听连接关闭事件</span></span></span><br><span class="line"><span class="javascript">        socket.addEventListener(<span class="string">"close"</span>, (event) =&gt; &#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">"WebSocket connection closed."</span>);</span></span><br><span class="line"><span class="undefined">        &#125;);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">        <span class="comment">// 监听错误事件</span></span></span><br><span class="line"><span class="javascript">        socket.addEventListener(<span class="string">"error"</span>, (event) =&gt; &#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.error(<span class="string">"WebSocket error:"</span>, event);</span></span><br><span class="line"><span class="undefined">        &#125;);</span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这次终于正常了，websockify输出变成了由应用服务主动断开</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$ websockify 8765 127.0.0.1:12346 --<span class="built_in">log</span>-file /tmp/ws.log -v --traffic</span><br><span class="line">WebSocket server settings:</span><br><span class="line">  - Listen on :8765</span><br><span class="line">  - No SSL/TLS support (no cert file)</span><br><span class="line">  - proxying from :8765 to 127.0.0.1:12346</span><br><span class="line">10.2.48.36: new handler Process</span><br><span class="line">10.2.48.36 - - [13/Dec/2023 20:24:29] <span class="string">"GET / HTTP/1.1"</span> 101 -</span><br><span class="line">10.2.48.36 - - [13/Dec/2023 20:24:29] 10.2.48.36: Plain non-SSL (ws://) WebSocket connection</span><br><span class="line">10.2.48.36 - - [13/Dec/2023 20:24:29] connecting to: 127.0.0.1:12346</span><br><span class="line"></span><br><span class="line">Traffic Legend:</span><br><span class="line">    &#125;  - Client receive</span><br><span class="line">    &#125;. - Client receive partial</span><br><span class="line">    &#123;  - Target receive</span><br><span class="line"></span><br><span class="line">    &gt;  - Target send</span><br><span class="line">    &gt;. - Target send partial</span><br><span class="line">    &lt;  - Client send</span><br><span class="line">    &lt;. - Client send partial</span><br><span class="line">&#125;&gt;&#123;&lt;10.2.48.36 - - [13/Dec/2023 20:24:29] 127.0.0.1:12346: Target closed connection</span><br><span class="line">10.2.48.36 - - [13/Dec/2023 20:24:29] 127.0.0.1:12346: Closed target</span><br></pre></td></tr></table></figure><p>echoserver也看到了发送的内容【1234】：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ python3 echoserver.py</span><br><span class="line">服务器已启动，等待客户端连接...</span><br><span class="line">客户端(<span class="string">'127.0.0.1'</span>, 37438)已连接</span><br><span class="line">收到来自(<span class="string">'127.0.0.1'</span>, 37438)的数据： 1234</span><br><span class="line">已将数据发送回(<span class="string">'127.0.0.1'</span>, 37438)</span><br><span class="line">客户端(<span class="string">'127.0.0.1'</span>, 37438)已断开连接</span><br></pre></td></tr></table></figure><h3 id="单独实现一个js版本websocket客户端"><a href="#单独实现一个js版本websocket客户端" class="headerlink" title="单独实现一个js版本websocket客户端"></a>单独实现一个js版本websocket客户端</h3><p>刚刚用html里的js发送了websocket数据，需要浏览器的帮助，如果是在服务器上局限性很大，所以我调整了一下，改成了js版本websocket客户端，用node.js运行，wsclient.js内容如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> WebSocket = <span class="built_in">require</span>(<span class="string">'ws'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 替换为你的 WebSocket 服务器地址</span></span><br><span class="line"><span class="keyword">const</span> socket = <span class="keyword">new</span> WebSocket(<span class="string">"ws://10.10.49.172:8765"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听连接打开事件</span></span><br><span class="line">socket.addEventListener(<span class="string">"open"</span>, (event) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"WebSocket connection opened."</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造二进制数据，这里使用一个简单的示例</span></span><br><span class="line">    <span class="keyword">const</span> binaryData = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>([<span class="number">49</span>, <span class="number">50</span>, <span class="number">51</span>, <span class="number">52</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送二进制数据</span></span><br><span class="line">    socket.send(binaryData);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Binary data sent successfully."</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听接收消息事件</span></span><br><span class="line">socket.addEventListener(<span class="string">"message"</span>, (event) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Received message:"</span>, event.data);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听连接关闭事件</span></span><br><span class="line">socket.addEventListener(<span class="string">"close"</span>, (event) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"WebSocket connection closed."</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听错误事件</span></span><br><span class="line">socket.addEventListener(<span class="string">"error"</span>, (event) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(<span class="string">"WebSocket error:"</span>, event);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ node wsclient.js</span><br><span class="line">WebSocket connection opened.</span><br><span class="line">Binary data sent successfully.</span><br><span class="line">Received message: &lt;Buffer 31 32 33 34&gt;</span><br><span class="line">WebSocket connection closed.</span><br></pre></td></tr></table></figure><p>至此，websockify的测试就结束了，它可以满足我们的需求，将websocket请求转换成tcp请求</p><h1 id="什么是VNC"><a href="#什么是VNC" class="headerlink" title="什么是VNC"></a>什么是VNC</h1><p>前面在介绍websockify多次提到VNC，其实VNC (Virtual Network Computing) 是一种远程桌面协议，允许用户在一个计算机上通过网络远程控制另一个计算机的桌面。VNC 提供了一种在远程计算机上查看和操作桌面的方式，就像你坐在那台计算机前一样，以下是关于 VNC 的一些关键概念：</p><ul><li><p>Server：在 VNC 中，远程计算机上运行的应用程序称为 VNC 服务器。该服务器负责监听连接请求，并将计算机的桌面图像发送给连接的客户端。</p></li><li><p>Viewer：连接到 VNC 服务器的应用程序称为 VNC 查看器。这是用户使用的远程桌面客户端，允许他们查看和操作远程计算机的桌面。</p></li><li><p>Port：VNC 服务器通过一个特定的网络端口监听连接请求。通常，VNC 默认使用 5900 端口。如果有多个 VNC 服务器在同一台计算机上运行，它们可能使用不同的端口（5901、5902 等）。</p></li><li><p>Security：VNC 提供了一些安全性选项，如密码保护和加密。这有助于确保在远程访问时保护计算机的安全。</p></li><li><p>Authentication：VNC 服务器和查看器之间的连接通常需要身份验证。这可以是使用密码进行简单的身份验证，也可以是更复杂的加密和密钥交换过程。</p></li><li><p>websockify：对于一些场景，特别是在 Web 浏览器中访问 VNC，你可能会使用工具如 <code>websockify</code> 将 VNC 的协议转换为 WebSocket 协议，以便在浏览器中实现 VNC 远程桌面访问。</p></li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>websockify可以轻松实现从websocket请求向tcp请求的转换，使用很方便</li><li>转换路径 wsclient <code>--ws--&gt;</code> websockify <code>--tcp--&gt;</code> tcp application <code>--tcp--&gt;</code> websockify <code>--ws--&gt;</code> wsclient</li><li>wss对应的是ws的加密版本，他们的关系是wss=ws+SSL/TSL，类似的https=http+SSL/TSL</li><li>无论是nginx还是websockify都可以配置服务器证书，将应用服务器从SSL/TSL中解脱出来</li><li>VNC是一种远程桌面协议，允许用户在一个计算机上通过网络远程控制另一个计算机的桌面</li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/134888966" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>迈出这一步确实不太容易，一旦行动了就会发现没有想象中的那么难，我们都没有预知未来的能力，无法判定目前的选择是对还是错，既然选择了就要努力走下去</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;目前遇到一个问题，原本的服务都是利用tcp通信的，但是某些平台只支持websocket，是不是要从头实现一套websocket网络收发逻辑呢？短时间内有没有替代方案呢？在经过一番寻找之后发现了websockify这个神器，可以将websocket协议转换成tcp协议，从而实现不修改应用服务就支持tcp协议的目的，接下来就说说它怎么用，以及探索的过程。&lt;/p&gt;
    
    </summary>
    
      <category term="Nginx" scheme="http://AlbertGithubHome.github.io/blog/categories/Nginx/"/>
    
    
      <category term="Nginx" scheme="http://AlbertGithubHome.github.io/blog/tags/Nginx/"/>
    
      <category term="网络协议" scheme="http://AlbertGithubHome.github.io/blog/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    
      <category term="websockify" scheme="http://AlbertGithubHome.github.io/blog/tags/websockify/"/>
    
      <category term="websocket" scheme="http://AlbertGithubHome.github.io/blog/tags/websocket/"/>
    
      <category term="tcp/ip" scheme="http://AlbertGithubHome.github.io/blog/tags/tcp-ip/"/>
    
      <category term="NVC" scheme="http://AlbertGithubHome.github.io/blog/tags/NVC/"/>
    
  </entry>
  
  <entry>
    <title>nginx配置自建SSL证书</title>
    <link href="http://AlbertGithubHome.github.io/blog/2023/12/08/nginx%E9%85%8D%E7%BD%AE%E8%87%AA%E5%BB%BASSL%E8%AF%81%E4%B9%A6/"/>
    <id>http://AlbertGithubHome.github.io/blog/2023/12/08/nginx配置自建SSL证书/</id>
    <published>2023-12-08T15:24:23.000Z</published>
    <updated>2023-12-19T16:09:06.362Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>之前的一篇文章<a href="https://blog.csdn.net/albertsh/article/details/134724042" target="_blank" rel="noopener">《自建CA并生成自签名SSL证书》</a>中讲到为什么要自建CA和自签名SSL证书，是因为买证书得花钱，对于内部或小规模项目，使用自建SSL证书可能更为方便，不需要支付费用，而且不涉及复杂的验证过程。正式对外的服务一般都是要买公共证书颁发机构（CA）签发的SSL证书的，但是在对外发布前可以先使用自建证书打通流程</p><a id="more"></a><h1 id="配置SSL证书"><a href="#配置SSL证书" class="headerlink" title="配置SSL证书"></a>配置SSL证书</h1><p>创建SSL证书的流程参考上文中提到的文章吧，本文只讲怎样把自建SSL证书配置到nginx，实际上非常简单。</p><p>假设我们的自建证书是 <code>/root/ca/server.crt</code>，服务器私钥是 <code>/root/ca/server.key</code>，nginx配置文件我以<a href="https://blog.csdn.net/albertsh/article/details/129543700" target="_blank" rel="noopener">《记录一下第一次安装和配置Nginx》</a> 这篇文章的配置文件为例，初始配置为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">upstream go_entrance &#123;</span><br><span class="line">    server localhost:4101;</span><br><span class="line">    server localhost:4102;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen       4100;</span><br><span class="line">    server_name  localhost;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line"></span><br><span class="line">        proxy_pass http://go_entrance;</span><br><span class="line">        proxy_set_header Host <span class="variable">$host</span>;</span><br><span class="line">        proxy_set_header X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">        proxy_set_header X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4100端口监听http协议转发到本机的4101端口和4102端口，如果把SSL证书配置到这个端口上，就相当于这个端口支持了https，配置修改如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">upstream go_entrance &#123;</span><br><span class="line">    server localhost:4101;</span><br><span class="line">    server localhost:4102;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen 4100 ssl;</span><br><span class="line">    server_name  localhost;</span><br><span class="line"></span><br><span class="line">    ssl_certificate /root/ca/server.crt;</span><br><span class="line">    ssl_certificate_key /root/ca/server.key;</span><br><span class="line"></span><br><span class="line">    ssl_session_cache shared:SSL:10m;</span><br><span class="line">    ssl_session_timeout 10m;</span><br><span class="line"></span><br><span class="line">    ssl_protocols TLSv1 TLSv1.1 TLSv1.2;</span><br><span class="line">    ssl_ciphers HIGH:!aNULL:!MD5;</span><br><span class="line">    ssl_prefer_server_ciphers on;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_pass http://go_entrance;</span><br><span class="line">        proxy_set_header Host <span class="variable">$host</span>;</span><br><span class="line">        proxy_set_header X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">        proxy_set_header X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只需要将4100端口后面加上 ssl，再配置几个ssl相关的参数就可以了，含义如下：</p><ul><li><p><code>ssl_certificate</code>： 指定 SSL 证书文件路径 /root/ca/server.crt</p></li><li><p><code>ssl_certificate_key</code>： 指定私钥文件路径 /root/ca/server.key</p></li><li><p><code>ssl_session_cache</code>： 配置用于存储 SSL 会话的缓存。shared:SSL:10m 表示使用共享的内存区域，最大占用内存为 10MB</p></li><li><p><code>ssl_session_timeout</code>： 配置 SSL 会话的超时时间，这里设置为 10 分钟</p></li><li><p><code>ssl_protocols</code>： 指定支持的 SSL/TLS 协议版本，这里包括 TLSv1、TLSv1.1 和 TLSv1.2</p></li><li><p><code>ssl_ciphers</code>： 指定支持的加密套件，这里配置为 HIGH:!aNULL:!MD5，表示使用高强度的加密套件，不支持空加密和 MD5</p></li></ul><h1 id="SSL证书放在-Nginx-而不放在应用服务器上的好处"><a href="#SSL证书放在-Nginx-而不放在应用服务器上的好处" class="headerlink" title="SSL证书放在 Nginx 而不放在应用服务器上的好处"></a>SSL证书放在 Nginx 而不放在应用服务器上的好处</h1><p>正如上面的配置一样，4100端口收到https请求后转发到4101和4102上的是http协议，说明使用这种方式一些仅支持http协议的应用服务也可以通过nginx配置证书来达到支持https的目的，具体好处如下：</p><ul><li><p><strong>集中管理：</strong> 使用反向代理服务器管理 SSL 证书可以实现集中式管理。这意味着你可以在一个地方管理证书，而不需要在每个应用服务器上都安装和维护证书。这样能够简化证书的更新和维护流程。</p></li><li><p><strong>简化配置：</strong> 通过在反向代理服务器上配置 SSL，你可以简化应用服务器的配置。应用服务器可以专注于处理应用程序逻辑，而无需关心 SSL 配置。这样有助于提高系统的可维护性和简化配置过程。</p></li><li><p><strong>负载均衡和扩展：</strong> 如果你使用负载均衡，SSL终止（SSL Termination）在负载均衡器上执行可以减轻应用服务器的负担。负载均衡器负责处理SSL握手，将非加密的请求转发给后端应用服务器。这样，后端服务器就可以专注于处理业务逻辑，而无需处理加密和解密操作。</p></li><li><p><strong>性能优化：</strong> SSL 握手和加解密操作可能是计算密集型的任务，将这些任务从应用服务器中移除，可以在 SSL 握手和加解密方面提高性能。</p></li><li><p><strong>统一的安全策略：</strong> 通过在反向代理服务器上管理 SSL，可以实施统一的安全策略，确保所有传入和传出的流量都经过相同的安全设置。</p></li></ul><h1 id="Nginx只能转发http协议吗"><a href="#Nginx只能转发http协议吗" class="headerlink" title="Nginx只能转发http协议吗"></a>Nginx只能转发http协议吗</h1><p>不，Nginx 不仅仅能够转发 HTTP 协议，还支持其他多种协议的代理转发。主要的协议包括：</p><ul><li><p><strong>HTTPS协议：</strong> 通过在配置中启用 SSL/TLS，Nginx 可以用作安全的 HTTPS 服务器和反向代理，处理加密的 HTTP 流量。</p>  <figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">listen</span> <span class="number">443</span> ssl;</span><br><span class="line"><span class="attribute">ssl_certificate</span> /path/to/certificate.crt;</span><br><span class="line"><span class="attribute">ssl_certificate_key</span> /path/to/private-key.key;</span><br><span class="line"></span><br><span class="line"><span class="attribute">location</span> / &#123;</span><br><span class="line">    <span class="attribute">proxy_pass</span> https://backend_server;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>TCP协议：</strong> 从1.9版本开始 Nginx 可以用于代理 TCP 流量，例如数据库连接、消息队列等。</p>  <figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">stream</span> &#123;</span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span> <span class="number">3306</span>;</span><br><span class="line">        <span class="attribute">proxy_pass</span> backend_server:<span class="number">3306</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>UDP协议：</strong> 从Nginx 1.9.13版本开始，开始支持 UDP 代理。这使得它可以用于代理 UDP 流量，如 DNS 请求等。</p>  <figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">stream</span> &#123;</span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span> <span class="number">53</span> udp;</span><br><span class="line">        <span class="attribute">proxy_pass</span> backend_dns_server:<span class="number">53</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>WebSocket协议：</strong> WebSocket 是一种在单个 TCP 连接上提供全双工通信的协议，常用于实时应用程序，如在线游戏、聊天应用等。</p>  <figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">map</span> <span class="variable">$http_upgrade</span> <span class="variable">$connection_upgrade</span> &#123;</span><br><span class="line">    <span class="attribute">default</span> upgrade;</span><br><span class="line">    ''      close;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">server_name</span> your_domain.com;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">location</span> /websocket &#123;</span><br><span class="line">        <span class="attribute">proxy_pass</span> http://backend_server;</span><br><span class="line">        <span class="attribute">proxy_http_version</span> <span class="number">1</span>.<span class="number">1</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> Upgrade <span class="variable">$http_upgrade</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> Connection <span class="variable">$connection_upgrade</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="Nginx转发TCP协议会收到端口限制吗"><a href="#Nginx转发TCP协议会收到端口限制吗" class="headerlink" title="Nginx转发TCP协议会收到端口限制吗"></a>Nginx转发TCP协议会收到端口限制吗</h1><p>是的，TCP是一种面向连接的全双工通信的协议，当转发TCP消息时，Nginx不仅是一个服务器接受客户端的连接，再它连接应用服务器时还表现成一个客户端，每个连接需要消耗一个端口，以理论值65535个端口来计算，nginx最多转发65535个连接，但是可以通过 <code>proxy_bind</code> 来突破限制，或者配置多个IP或虚拟IP也可以。</p><p>这种方式还没测过，感兴趣可以参考官方说明的看一下 <a href="https://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_bind" target="_blank" rel="noopener">https://nginx.org/r/proxy_bind</a></p><h1 id="Nginx本身能将Websocket数据转化成TCP数据吗"><a href="#Nginx本身能将Websocket数据转化成TCP数据吗" class="headerlink" title="Nginx本身能将Websocket数据转化成TCP数据吗"></a>Nginx本身能将Websocket数据转化成TCP数据吗</h1><p>只使用Nginx是做不到的，但是搭配Websockify就可以做到WSS（WebSocket Secure）到 TCP 的转发</p><ol><li><p><strong>安装 Nginx：</strong><br>确保你的系统上已经安装了 Nginx。你可以使用系统包管理器或从 Nginx 官方网站下载并安装</p></li><li><p><strong>安装 Websockify：</strong><br>安装 Websockify，可以使用 pip 执行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install websockify</span><br></pre></td></tr></table></figure></li><li><p><strong>创建 Websockify 启动脚本：</strong><br>创建一个用于启动 Websockify 的脚本，例如 <code>start_websockify.sh</code>。脚本内容可能如下所示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">websockify --web /path/to/webroot 1234 localhost:5678</span><br></pre></td></tr></table></figure><p>这里 <code>1234</code> 是用于 WebSocket 连接的端口，<code>localhost:5678</code> 是实际 TCP 服务的地址</p></li><li><p><strong>配置 Nginx：</strong><br>修改 Nginx 配置文件，将 WSS 请求转发到 Websockify 启动脚本。示例配置如下：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">443</span> ssl;</span><br><span class="line">    <span class="attribute">server_name</span> your_domain.com;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">ssl_certificate</span> /root/ca/server.crt;</span><br><span class="line">    <span class="attribute">ssl_certificate_key</span> /root/ca/server.key;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">location</span> / &#123;</span><br><span class="line">        <span class="attribute">proxy_pass</span> http://localhost:1234;</span><br><span class="line">        <span class="attribute">proxy_http_version</span> <span class="number">1</span>.<span class="number">1</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> Upgrade <span class="variable">$http_upgrade</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> Connection <span class="string">"upgrade"</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> Host <span class="variable">$host</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的 <code>listen 443</code> 表示监听 HTTPS 请求，<code>proxy_pass http://localhost:1234</code> 将请求代理到 Websockify 启动脚本</p></li><li><p><strong>启动服务：</strong><br>启动 Websockify 服务：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod +x start_websockify.sh</span><br><span class="line">./start_websockify.sh</span><br></pre></td></tr></table></figure><p>启动 Nginx 服务：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start nginx</span><br></pre></td></tr></table></figure></li><li><p><strong>测试：</strong><br>使用支持 WebSocket 的客户端连接到 WSS 地址，例如 <code>wss://your_domain.com</code>，并验证是否成功将 WebSocket 请求转发到 TCP 服务</p></li></ol><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>nginx配置自建SSL证书，只需要修改nginx配置文件，在端口后配置添加 ssl 并指定证书和私钥路径即可</li><li>nginx上配置SSL证书可以将证书统一管理，减轻应用服务器加密解密的负担，专注于业务逻辑开发</li><li>nginx不仅支持http协议转发，还支持https、tcp、udp、websocket等协议的转发</li><li>nginx转发tcp协议时会收到端口号个数限制，理论上限6万，通过proxy_bind可以突破上限</li><li>nginx搭配websockify可以做到WSS 到 TCP 的转发</li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/134818171" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>寒风终究是刮到我这里了</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;之前的一篇文章&lt;a href=&quot;https://blog.csdn.net/albertsh/article/details/134724042&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《自建CA并生成自签名SSL证书》&lt;/a&gt;中讲到为什么要自建CA和自签名SSL证书，是因为买证书得花钱，对于内部或小规模项目，使用自建SSL证书可能更为方便，不需要支付费用，而且不涉及复杂的验证过程。正式对外的服务一般都是要买公共证书颁发机构（CA）签发的SSL证书的，但是在对外发布前可以先使用自建证书打通流程&lt;/p&gt;
    
    </summary>
    
      <category term="Nginx" scheme="http://AlbertGithubHome.github.io/blog/categories/Nginx/"/>
    
    
      <category term="运维" scheme="http://AlbertGithubHome.github.io/blog/tags/%E8%BF%90%E7%BB%B4/"/>
    
      <category term="Nginx" scheme="http://AlbertGithubHome.github.io/blog/tags/Nginx/"/>
    
      <category term="nginx ssl" scheme="http://AlbertGithubHome.github.io/blog/tags/nginx-ssl/"/>
    
      <category term="https" scheme="http://AlbertGithubHome.github.io/blog/tags/https/"/>
    
      <category term="websockify" scheme="http://AlbertGithubHome.github.io/blog/tags/websockify/"/>
    
  </entry>
  
  <entry>
    <title>怎么验证公钥和私钥是一对</title>
    <link href="http://AlbertGithubHome.github.io/blog/2023/12/05/%E6%80%8E%E4%B9%88%E9%AA%8C%E8%AF%81%E5%85%AC%E9%92%A5%E5%92%8C%E7%A7%81%E9%92%A5%E6%98%AF%E4%B8%80%E5%AF%B9/"/>
    <id>http://AlbertGithubHome.github.io/blog/2023/12/05/怎么验证公钥和私钥是一对/</id>
    <published>2023-12-05T15:20:43.000Z</published>
    <updated>2023-12-19T16:06:33.640Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>公钥和私钥都是一串字符，长得也没有什么关联性，那么当拿到一个公钥和一个私钥后怎么验证它们两个是一对呢？先说说为什么会有这个疑问，最近在对接一些SDK时经常需要做签名和验证签名的工作，双方要相互提供公钥来完成后续的身份验证，测试过程中生成了多个密钥对，当时就在想如果我用错了怎样才能发现呢？有没有什么方法可以验证公钥和私钥是一对呢？再寻找方法的过程中发现 <code>ssh-keygen</code> 和 <code>openssl</code> 生成的密钥对差别居然这么大，但后来又发现他们居然还有联系，所以本文将刚刚提到的问题都总结一下，方便日后查阅。</p><a id="more"></a><p>解决这个问题的思路我么可以从密钥使用的方式入手，私钥加密公钥解密可以验证身份，公钥加密私钥解密可以秘密传递数据，也就是说公钥和私钥是配合工作的，如果我们用私钥加密一个数据，公钥可以解开就说明他们两个是一对的的。</p><p>其实还有一个更简单的办法，公钥是可以从私钥中提取出来的，反之则不行。在公钥密码学中，私钥和公钥之间的关系是一种数学上的单向函数。这种函数的特性使得从私钥生成公钥是可行的，而从公钥还原私钥是非常困难的，这被称为一个单向函数或单向映射，因此被认为是安全的。</p><p>有了这个前提我们就可以这样做，从私钥中提取出公钥，然后和要比对的公钥进行比较，如果一致就说明原来的公钥和私钥是一对啦。</p><h1 id="ssh-keygen-和-openssl"><a href="#ssh-keygen-和-openssl" class="headerlink" title="ssh-keygen 和 openssl"></a>ssh-keygen 和 openssl</h1><p><code>ssh-keygen</code> 和 <code>openssl</code> 是两个不同的工具，它们分别用于生成和处理不同类型的密钥和证书。以下是它们的一些主要区别：</p><ol><li><p><strong>功能和用途：</strong></p><ul><li><code>ssh-keygen</code>：主要用于生成和管理SSH密钥对，包括RSA、DSA、ECDSA和Ed25519密钥。</li><li><code>openssl</code>：是一个通用的密码学工具，可以用于生成和管理多种密码学对象，包括SSL/TLS证书、密钥、摘要和数字签名等。</li></ul></li><li><p><strong>支持的算法：</strong></p><ul><li><code>ssh-keygen</code>：专注于SSH密钥生成，支持多种SSH密钥算法。</li><li><code>openssl</code>：支持广泛的密码学算法，包括RSA、DSA、ECDSA、Diffie-Hellman、AES、SHA等，用于生成和操作各种密码学对象。</li></ul></li><li><p><strong>密钥格式：</strong></p><ul><li><code>ssh-keygen</code>：生成的SSH密钥通常以OpenSSH格式存储。</li><li><code>openssl</code>：支持多种密钥格式，例如PEM、DER等，可以处理不同类型的密钥和证书。</li></ul></li><li><p><strong>具体应用场景：</strong></p><ul><li><code>ssh-keygen</code>：主要用于SSH连接，生成用于身份验证的密钥对。</li><li><code>openssl</code>：更广泛地用于TLS/SSL证书、数字签名、加密和其他与通用密码学相关的应用。</li></ul></li><li><p><strong>具体命令和用法：</strong></p><ul><li><p><code>ssh-keygen</code>：用于生成SSH密钥对的常见命令包括：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -b 2048 -f myid_rsa</span><br></pre></td></tr></table></figure></li><li><p><code>openssl</code>：用于生成RSA密钥对的常见命令包括：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">openssl genpkey -algorithm RSA -out private-key.pem</span><br><span class="line">openssl rsa -pubout -<span class="keyword">in</span> private-key.pem -out public-key.pem</span><br></pre></td></tr></table></figure></li></ul></li></ol><p>以上的ChatGPT提供的内容，还是对比的挺全面的，从 <code>openssl</code> 生成密钥对的过程可以看出，确实可以从私钥中提取出公钥。</p><p><code>ssh-keygen</code> 是我接触的最多的生成密钥对的命令，不管是github还是gitlab，或者一些其他的托管平台都会提到SSH Keys，所以每次我都会用 <code>ssh-keygen</code> 来生成，它是用于生成SSH连接密钥对最直接的选择，如果是想要使用更广泛的密码学操作，包括证书生成、签名和加密等，那么 <code>openssl</code> 提供了更大的灵活性。</p><h2 id="两种证书的内容对比"><a href="#两种证书的内容对比" class="headerlink" title="两种证书的内容对比"></a>两种证书的内容对比</h2><p>前面说了两种命令生成的证书、格式、算法和用途都有区别，我们来看看利用上面的命令生成的证书内容有什么不同，先看 <code>ssh-keygen</code> 生成的私钥 <code>myid_rsa</code> 和公钥 <code>myid_rsa.pub</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># demo @ demo-ThinkPad-X390 in ~/tmp/rsa [17:58:47]</span></span><br><span class="line">$ ssh-keygen -t rsa -b 2048 -f myid_rsa</span><br><span class="line">Generating public/private rsa key pair.</span><br><span class="line">Enter passphrase (empty <span class="keyword">for</span> no passphrase):</span><br><span class="line">Enter same passphrase again:</span><br><span class="line">Your identification has been saved <span class="keyword">in</span> myid_rsa</span><br><span class="line">Your public key has been saved <span class="keyword">in</span> myid_rsa.pub</span><br><span class="line">The key fingerprint is:</span><br><span class="line">SHA256:eLzG9lryO/AOdd05cDkixvBNCPFZRLRu0wp3bxZ7Vnk demo@demo-ThinkPad-X390</span><br><span class="line">The key<span class="string">'s randomart image is:</span></span><br><span class="line"><span class="string">+---[RSA 2048]----+</span></span><br><span class="line"><span class="string">|         +o =*   |</span></span><br><span class="line"><span class="string">|          =.= . .|</span></span><br><span class="line"><span class="string">|           B = + |</span></span><br><span class="line"><span class="string">|       o  . o.=.+|</span></span><br><span class="line"><span class="string">|      . S ...=.BE|</span></span><br><span class="line"><span class="string">|       o.o .+ + B|</span></span><br><span class="line"><span class="string">|        Bo.  . .*|</span></span><br><span class="line"><span class="string">|       o *o    +.|</span></span><br><span class="line"><span class="string">|        .o=o     |</span></span><br><span class="line"><span class="string">+----[SHA256]-----+</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># demo @ demo-ThinkPad-X390 in ~/tmp/rsa [19:22:03]</span></span><br><span class="line">$ cat myid_rsa</span><br><span class="line">-----BEGIN OPENSSH PRIVATE KEY-----</span><br><span class="line">b3BlbnNzaC1rZXktdjEAAAAABG5vbmUAAAAEbm9uZQAAAAAAAAABAAABFwAAAAdzc2gtcn</span><br><span class="line">NhAAAAAwEAAQAAAQEAr7gEjCdhA4at0tx0efpLunEOEGvK3ejJCh/dBwLfsvVJelwTeJjK</span><br><span class="line">zI2nFvYGkJgndhWLuvwy6+ODnvASeNvXSvZZzXvvXjTF4JP3TRbATayFvS9mZgzOnxh/rU</span><br><span class="line">z4P7ecLBfqZZkem+VBrMlv37yaIWf7co59dtrJJuAfZJFXyW//LQhNoEaqbZ/gvZls5pOX</span><br><span class="line">r2foMnYg2HV0ayPlvz8cmVF8LIOqaGOc28nMQakVwO+nZhbSv1bGprIGcy4czc7UOp/m+o</span><br><span class="line">t6mWJflpq3NBGiImyfaT2kxp1+pIdd6ISqoZqa9C2JzH7ZXVGjevbHuqup871yjUGapxDx</span><br><span class="line">lDk9HjdSLwAAA9AlxLUDJcS1AwAAAAdzc2gtcnNhAAABAQCvuASMJ2EDhq3S3HR5+ku6cQ</span><br><span class="line">4Qa8rd6MkKH90HAt+y9Ul6XBN4mMrMjacW9gaQmCd2FYu6/DLr44Oe8BJ429dK9lnNe+9e</span><br><span class="line">NMXgk/dNFsBNrIW9L2ZmDM6fGH+tTPg/t5wsF+plmR6b5UGsyW/fvJohZ/tyjn122skm4B</span><br><span class="line">9kkVfJb/8tCE2gRqptn+C9mWzmk5evZ+gydiDYdXRrI+W/PxyZUXwsg6poY5zbycxBqRXA</span><br><span class="line">76dmFtK/VsamsgZzLhzNztQ6n+b6i3qZYl+Wmrc0EaIibJ9pPaTGnX6kh13ohKqhmpr0LY</span><br><span class="line">nMftldUaN69se6q6nzvXKNQZqnEPGUOT0eN1IvAAAAAwEAAQAAAP8nH9HjYuE258XMLUnB</span><br><span class="line">3vj9ii6XeWiyACLDHlUYOouUTQkPNXEgaOS+psuNUTok97vRjvqNp5mu6/liahGy10AYcM</span><br><span class="line">GN/wpM73MfjdKCV455vPAKL4OdNTzML6g97eVYSol7R9foxy8JhwIYdsFyD4xB4+UYnKFS</span><br><span class="line">1WP0Q/K5caMaNnazPF0X7JDSenEwBwl1bDAN5OKwZNzSzUpR/96fl1DAgnG9yp1/634WGt</span><br><span class="line">IfjXLm13OSMrSHfwazNHoqAPkD0SQVJrm38ppvqArU0tBVfh/kvBkv7CCAE9mzhxusiKju</span><br><span class="line">B0c/jrsRDu45AJX5wuqIWcZdfppATJjK10S20MgN5dkAAACBALYym7mpDVQJ2gedSjv/Pv</span><br><span class="line">a+O/5b/20jawc3RFZdJAUWSGJTe9UqyHBHPlYj3/bHJVWIQ9S7s5AxpBtAEOsjeQf0VGFa</span><br><span class="line">FALQwcUghx5r1uM5sAL06CT/5t3Ze8lcJozNW7yjbVZKjJK13GTDMrnPYTfPOc+I/6N3R+</span><br><span class="line">SV2iKOwUQPAAAAgQDp9/2WvHOX2GKXan2BvMaexj6GYIQa8xEsqhtQGY9zxQ2d+9Z7YgDf</span><br><span class="line">XnNanxv8XJ61komeP9KmhS+2TCt0trj8sXtQobDsDGjFcDx0jjBobU6zKvO4htoZP3lb8w</span><br><span class="line">ZARgQoEANxqNOo8R61CsDQW4eM0ReAitKZ0GCcXbqNYCRTGwAAAIEAwEPdhAH4iH6V7IJn</span><br><span class="line">Qs3pgf9AG9UubDe9mAwVNIircWTFO2EFaBpwP7UKgpNmmZjoD2lWEcr2Zxv6x8ILBlJqea</span><br><span class="line">vCpGfLo0hwt2XZHgLRsTx8RmsbmYI2l8qnkMWyz5Lh3XAhNMZM4s9OvSJM6JPWYcedG5KY</span><br><span class="line">G1/zbarjwkq+Gn0AAAAVc2h6QHNoei1UaGlua1BhZC1YMzkwAQIDBAUG</span><br><span class="line">-----END OPENSSH PRIVATE KEY-----</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># demo @ demo-ThinkPad-X390 in ~/tmp/rsa [19:22:10]</span></span><br><span class="line">$ cat myid_rsa.pub</span><br><span class="line">ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQCvuASMJ2EDhq3S3HR5+ku6cQ4Qa8rd6MkKH90HAt+y9Ul6XBN4mMrMjacW9gaQmCd2FYu6/DLr44Oe8BJ429dK9lnNe+9eNMXgk/dNFsBNrIW9L2ZmDM6fGH+tTPg/t5wsF+plmR6b5UGsyW/fvJohZ/tyjn122skm4B9kkVfJb/8tCE2gRqptn+C9mWzmk5evZ+gydiDYdXRrI+W/PxyZUXwsg6poY5zbycxBqRXA76dmFtK/VsamsgZzLhzNztQ6n+b6i3qZYl+Wmrc0EaIibJ9pPaTGnX6kh13ohKqhmpr0LYnMftldUaN69se6q6nzvXKNQZqnEPGUOT0eN1Iv demo@demo-ThinkPad-X390</span><br></pre></td></tr></table></figure><p>接着看看 <code>openssl</code> 生成的私钥 <code>private-key.pem</code> 和公钥 <code>public-key.pem</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># demo @ demo-ThinkPad-X390 in ~/tmp/rsa [19:23:01]</span></span><br><span class="line">$ openssl genpkey -algorithm RSA -out private-key.pem</span><br><span class="line">......................................................................+++++</span><br><span class="line">..................+++++</span><br><span class="line"></span><br><span class="line"><span class="comment"># demo @ demo-ThinkPad-X390 in ~/tmp/rsa [19:25:04]</span></span><br><span class="line">$ openssl rsa -pubout -<span class="keyword">in</span> private-key.pem -out public-key.pem</span><br><span class="line">writing RSA key</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># demo @ demo-ThinkPad-X390 in ~/tmp/rsa [19:26:18]</span></span><br><span class="line">$ cat private-key.pem</span><br><span class="line">-----BEGIN PRIVATE KEY-----</span><br><span class="line">MIIEvwIBADANBgkqhkiG9w0BAQEFAASCBKkwggSlAgEAAoIBAQDjxEM9ypyLb0fT</span><br><span class="line">xk7Ujdvj7efUjbLhzAcbfHNRZqzqif1rlTS4jz+tIDZBX9/HJkDcoz1dIolp/53S</span><br><span class="line">CJtz+qBrkHMzsi6dcqd5jXUfT3Ts/FMTVsAKIkwafnw2Gbi2DGQx8WQ8Sn5+LlUP</span><br><span class="line">FSCJa+2MTc21taiMP7CtF7iG6jFeGna3xeRTWAjMMS2xk9Zk37KMz8weU4ShdQ9q</span><br><span class="line">mX7yuKHuZzUiWHmjbW/bi6abur3dfi/1jRSnFQF+r/gJoH1UXT4st/+fW425nWqO</span><br><span class="line">ohSV+xw61a09fjECfjVDkMXtwiPCbbGNjD8WjLbilOJK3uBx5e7GIN1jZjVBqlH9</span><br><span class="line">NqEk12HVAgMBAAECggEAIlcf8DwRGDDB+psGnaN5yMbA0lo+4y5Yz/sWg+pgHciK</span><br><span class="line">TeMkHMN0TUzzAS5MVgFdfCachONFJpckm1sy3OynrTANPnkZ8CEuQPRj+UGIloaA</span><br><span class="line">nATTVXPQV5pEbf+4yrHZlXIYs8JjifDAYFLGIhIEsce1QTVPYT3lDGPsLWM36ED6</span><br><span class="line">XVnvJYsr00wpLlYy4uWikt4Q8ruKDnWSS8xeE7pj0bBaqYd8Gz4jfrJ94IgNIROQ</span><br><span class="line">xnXb8aMG/o441ImrF6YXKn8jR/gjZXT1L4ZsD7fGTvLKBxxImBXL2eIoZ8usmTtX</span><br><span class="line">eLEfYaJlzyXOcnYKKVtMQxRI+4ANJWWnMDgM8NTBTQKBgQD0hboW//hXGVcng3Pu</span><br><span class="line">NfD7hUPHQKWWUHbchjRfxvxy/4itqGaWHtUrmc4PTXUxW71YaVA6qm2gvfV+jn83</span><br><span class="line">o5k009vVbXYVvztNQq9wC0Fj2OYwQkxHMgAY9JdhZr6ghuEZ0+hNd5Jea9K3w62C</span><br><span class="line">cY0mHqlvo55szhWmhuvzFtSUXwKBgQDudTFUjf7+qPsfYEX14udsKtfowrjepFLf</span><br><span class="line">nQAbxj16PxpRBSV7S77gdlW1shKEreIPbm083bhU3ypCRs7ktR0Wki/uoQGYekHr</span><br><span class="line">b8Nljh+rM9DxY83+HfLHAC/RjP8ZFrWJFgo6Whfr3jhlb8j3a4siLvqMj0d35BRv</span><br><span class="line">M+HtsEhWSwKBgQC7M746aZG5LP9akvsofkeWaHpxi366S7QUNPLX+MHBUP1U5j5T</span><br><span class="line">5BsTnFbzxDtapH+btlTj9SKlE4llcLbY4/khRqlhBsKG97bw+YLS5usTBDWG8Nrx</span><br><span class="line">DsigUnGq8jwzLdAcM+3/kPGQNEBIzBiEa2bCrmrNu5hIeKZ+rYDqxKnPRQKBgQCh</span><br><span class="line">MZuNOwfbAkPvq9bfJuml1zho4eiyqIZVHv6Jx/KbBrk1d7Mkq8l2VsgNsTiPdDPS</span><br><span class="line">lqVFdeQ7izg34UHOnRfywBOizjgT6OFS1BRUPETwKHDgHMWNOJV7LIcmspdnUFCb</span><br><span class="line">QMjdNTXifi/FclF537sH+pXoGpsHUqj1my7ozDe6DQKBgQDY9tJvXx5DRPVH2t60</span><br><span class="line">0rl1df3PogoAhwjvK+Q/Y5vLyrL470JxMNPtW546aWXRL6INTg+OvsUqLJXEMlxl</span><br><span class="line">HdHIe16orIGBrGcqHNGfkQPfddJVOo0eQCCk4jaLL9EP7+euA83vp6cP38rqgsL7</span><br><span class="line">0+gt34iMPCP9dEKaJyjZPv+vFQ==</span><br><span class="line">-----END PRIVATE KEY-----</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># demo @ demo-ThinkPad-X390 in ~/tmp/rsa [19:26:21]</span></span><br><span class="line">$ cat public-key.pem</span><br><span class="line">-----BEGIN PUBLIC KEY-----</span><br><span class="line">MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA48RDPcqci29H08ZO1I3b</span><br><span class="line">4+3n1I2y4cwHG3xzUWas6on9a5U0uI8/rSA2QV/fxyZA3KM9XSKJaf+d0gibc/qg</span><br><span class="line">a5BzM7IunXKneY11H0907PxTE1bACiJMGn58Nhm4tgxkMfFkPEp+fi5VDxUgiWvt</span><br><span class="line">jE3NtbWojD+wrRe4huoxXhp2t8XkU1gIzDEtsZPWZN+yjM/MHlOEoXUPapl+8rih</span><br><span class="line">7mc1Ilh5o21v24umm7q93X4v9Y0UpxUBfq/4CaB9VF0+LLf/n1uNuZ1qjqIUlfsc</span><br><span class="line">OtWtPX4xAn41Q5DF7cIjwm2xjYw/Foy24pTiSt7gceXuxiDdY2Y1QapR/TahJNdh</span><br><span class="line">1QIDAQAB</span><br><span class="line">-----END PUBLIC KEY-----</span><br></pre></td></tr></table></figure><h1 id="从私钥提取公钥"><a href="#从私钥提取公钥" class="headerlink" title="从私钥提取公钥"></a>从私钥提取公钥</h1><p>使用 <code>openssl</code> 命令从私钥提取公钥，上面已经展示过程了，它的公钥就是这样生成的</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl rsa -pubout -<span class="keyword">in</span> private-key.pem -out public-key.pem</span><br></pre></td></tr></table></figure><p>使用 <code>ssh-keygen</code> 命令从私钥提取公钥可以这样做</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -y -f myid_rsa &gt; compare_myid_rsa.pub</span><br></pre></td></tr></table></figure><p>结果文件 compare_myid_rsa.pub 和 myid_rsa.pub 的内容一模一样，所以从私钥提取公钥可以作为检验密钥是否匹配的方法</p><h1 id="OPENSSH和PEM两种密钥格式相互转化"><a href="#OPENSSH和PEM两种密钥格式相互转化" class="headerlink" title="OPENSSH和PEM两种密钥格式相互转化"></a>OPENSSH和PEM两种密钥格式相互转化</h1><p>之前说了<code>ssh-keygen</code> 和 <code>openssl</code>两个命令及生成的密钥区别，现在讲讲两种密钥的联系，OpenSSH 和 OpenSSL 使用的密钥对虽然有一些格式上的差异，但可以相互转换。OpenSSH 使用自己的私钥和公钥格式, 而 OpenSSL 通常使用 PEM 格式，可以通过下列命令转化</p><h2 id="OpenSSH-格式私钥转换成-OpenSSL-PEM-格式私钥"><a href="#OpenSSH-格式私钥转换成-OpenSSL-PEM-格式私钥" class="headerlink" title="OpenSSH 格式私钥转换成 OpenSSL PEM 格式私钥"></a>OpenSSH 格式私钥转换成 OpenSSL PEM 格式私钥</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -p -N <span class="string">""</span> -f myid_rsa -m PEM</span><br></pre></td></tr></table></figure><blockquote><p>$ file myid_rsa<br>myid_rsa: PEM RSA private key</p></blockquote><h2 id="OpenSSL-PEM-格式私钥转换成-OpenSSH-格式私钥"><a href="#OpenSSL-PEM-格式私钥转换成-OpenSSH-格式私钥" class="headerlink" title="OpenSSL PEM 格式私钥转换成 OpenSSH 格式私钥"></a>OpenSSL PEM 格式私钥转换成 OpenSSH 格式私钥</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -p -N <span class="string">""</span> -f myid_rsa</span><br></pre></td></tr></table></figure><blockquote><p>$ file myid_rsa<br>myid_rsa: OpenSSH private key</p></blockquote><h2 id="OpenSSH-格式公钥生成-OpenSSL-PEM-格式公钥"><a href="#OpenSSH-格式公钥生成-OpenSSL-PEM-格式公钥" class="headerlink" title="OpenSSH 格式公钥生成 OpenSSL PEM 格式公钥"></a>OpenSSH 格式公钥生成 OpenSSL PEM 格式公钥</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -e -m PEM -f myid_rsa.pub &gt; new-public-key.pem</span><br></pre></td></tr></table></figure><blockquote><p>$ file new-public-key.pem<br>new-public-key.pem: ASCII text</p></blockquote><h2 id="OpenSSL-PEM-格式公钥生成-OpenSSH-格式公钥"><a href="#OpenSSL-PEM-格式公钥生成-OpenSSH-格式公钥" class="headerlink" title="OpenSSL PEM 格式公钥生成 OpenSSH 格式公钥"></a>OpenSSL PEM 格式公钥生成 OpenSSH 格式公钥</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -i -m PKCS8 -f new-public-key.pem &gt; compare_myid_rsa.pub</span><br></pre></td></tr></table></figure><blockquote><p>$ file compare_myid_rsa.pub<br>compare_myid_rsa.pub: OpenSSH RSA public key</p></blockquote><h1 id="公钥和私钥的匹配使用"><a href="#公钥和私钥的匹配使用" class="headerlink" title="公钥和私钥的匹配使用"></a>公钥和私钥的匹配使用</h1><p>匹配使用公钥和私钥之前先准备一个测试文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"Hello World"</span> &gt; data.txt</span><br></pre></td></tr></table></figure><h2 id="加密和解密"><a href="#加密和解密" class="headerlink" title="加密和解密"></a>加密和解密</h2><p>使用公钥加密</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl rsautl -<span class="keyword">in</span> data.txt -out data_enc.txt -inkey public-key.pem -pubin -encrypt</span><br></pre></td></tr></table></figure><p>使用私钥解密</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl rsautl -<span class="keyword">in</span> data_enc.txt -out data_dec.txt -inkey private-key.pem -decrypt</span><br></pre></td></tr></table></figure><p>两个命令执行后都没有任何控制台输出，文件 <code>data_enc.txt</code> 中是加密后的内容，文件 <code>data_dec.txt</code> 是解密后的内容，成功解密后内容与 <code>data.txt</code> 文件内容一样</p><h2 id="签名和验证"><a href="#签名和验证" class="headerlink" title="签名和验证"></a>签名和验证</h2><p>使用私钥签名</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl dgst -sha256 -sign private-key.pem -out signature.bin data.txt</span><br></pre></td></tr></table></figure><p>使用公钥验证签名</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl dgst -sha256 -verify public-key.pem -signature signature.bin data.txt</span><br></pre></td></tr></table></figure><p>验证通过后，会在命令行输出 “Verified OK” 字样，若不通过则输出 “Verification Failure” 字样</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>验证公钥私钥是否匹配的最便捷的方法是通过私钥提取公钥来和原公钥进行对比</li><li>公钥加密私钥解密，私钥签名公钥验证签名，需要把公钥发给别人，私钥自己要保留好</li><li>公钥和私钥常用的有OpenSSH和PEM两种格式，这两种格式的密钥可以相互转化</li><li><code>ssh-keygen</code> 和 <code>openssl</code> 是两个不同的工具，前者用于管理SSH密钥更具体，后者使用范围更广更灵活</li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/134724042" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>事情一件件去办就好了，『没什么大不了的』，希望你长大后还可以经常乐观的说这句话，一副俾睨天下的姿态</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;公钥和私钥都是一串字符，长得也没有什么关联性，那么当拿到一个公钥和一个私钥后怎么验证它们两个是一对呢？先说说为什么会有这个疑问，最近在对接一些SDK时经常需要做签名和验证签名的工作，双方要相互提供公钥来完成后续的身份验证，测试过程中生成了多个密钥对，当时就在想如果我用错了怎样才能发现呢？有没有什么方法可以验证公钥和私钥是一对呢？再寻找方法的过程中发现 &lt;code&gt;ssh-keygen&lt;/code&gt; 和 &lt;code&gt;openssl&lt;/code&gt; 生成的密钥对差别居然这么大，但后来又发现他们居然还有联系，所以本文将刚刚提到的问题都总结一下，方便日后查阅。&lt;/p&gt;
    
    </summary>
    
      <category term="Network" scheme="http://AlbertGithubHome.github.io/blog/categories/Network/"/>
    
    
      <category term="Network" scheme="http://AlbertGithubHome.github.io/blog/tags/Network/"/>
    
      <category term="openssl" scheme="http://AlbertGithubHome.github.io/blog/tags/openssl/"/>
    
      <category term="ssh-keygen" scheme="http://AlbertGithubHome.github.io/blog/tags/ssh-keygen/"/>
    
      <category term="pem" scheme="http://AlbertGithubHome.github.io/blog/tags/pem/"/>
    
      <category term="公钥" scheme="http://AlbertGithubHome.github.io/blog/tags/%E5%85%AC%E9%92%A5/"/>
    
      <category term="私钥" scheme="http://AlbertGithubHome.github.io/blog/tags/%E7%A7%81%E9%92%A5/"/>
    
  </entry>
  
  <entry>
    <title>自建CA并生成自签名SSL证书</title>
    <link href="http://AlbertGithubHome.github.io/blog/2023/11/30/%E8%87%AA%E5%BB%BACA%E5%B9%B6%E7%94%9F%E6%88%90%E8%87%AA%E7%AD%BE%E5%90%8DSSL%E8%AF%81%E4%B9%A6/"/>
    <id>http://AlbertGithubHome.github.io/blog/2023/11/30/自建CA并生成自签名SSL证书/</id>
    <published>2023-11-30T15:20:00.000Z</published>
    <updated>2023-12-19T16:33:51.378Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这是加密与认证系列的第五篇文章了，本来我是想把自建证书和nginx配置https访问总结到一起的，但是在实际操作的过程中我发现了很多细小的知识点，有些还是挺有意思的，这是一个不断自我提问不断寻求答案的过程，随着扩展的内容越来越多，我决定这篇只写自建CA和签名SSL证书这部分，至于nginx配置https访问放到后面再写吧。</p><a id="more"></a><p>相信点进这篇文章的人应该知道为什么要自建CA和自签名SSL证书了，因为买现成的SSL证书挺贵的，SSL证书通常有三种类型：域名级（DV）、企业级（OV）、增强级（EV），价格从每年几百元到上万元不等，再细分的话还有单域名证书、通配符证书、多域名证书等等，有些证书还可以追加域名。</p><p>这笔费用对于大厂来说可能不算什么，但是对于小产品来说，即使选择最便宜的证书也是一笔开销，比如在上一篇<a href="https://blog.csdn.net/albertsh/article/details/107147803" target="_blank" rel="noopener">《根证书的应用和信任基础》</a>提到的12306官网在2017以前使用的也是用的自签名证书，一般正式产品总会咬咬牙买个证书，但是如果是本地测试，或者局域内网的使用的产品使用自建的证书就足够了，相当于我们配了临时证书资源在开发新功能，等到真正对外发布时再替换成购买的证书也来的及，所以接下来我们就一起走一遍自建证书的流程。</p><h1 id="一键生成自签名证书"><a href="#一键生成自签名证书" class="headerlink" title="一键生成自签名证书"></a>一键生成自签名证书</h1><p>总有心急的人想吃热豆腐，所以我把用到的命令写了一个脚本，只要输入几个自定义密码就可以完成CA证书和SSL证书的创建，前提是在你的电脑安装了openssl命令，在ubuntu上系统上默认就有，没有的自己安装一下吧。</p><h2 id="命令脚本"><a href="#命令脚本" class="headerlink" title="命令脚本"></a>命令脚本</h2><p>将下列命令放到shell脚本文件<code>onekeyssl</code>中执行即可</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">read</span> -p <span class="string">"Enter your domain or ip [www.example.com/10.10.49.172]: "</span> INPUT</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"1. Create ca private key..."</span></span><br><span class="line"></span><br><span class="line">openssl genrsa -des3 -out selfca.key 2048</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"2. Create ca root certificate..."</span></span><br><span class="line"></span><br><span class="line">openssl req -new -x509 -days 3650 -key selfca.key -subj <span class="string">"/C=CN/ST=BJ/L=BJ/O=MyRootCA/OU=MyCA/CN=CA"</span> -out selfca.crt</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"3. Create server key and certificate signing request..."</span></span><br><span class="line"></span><br><span class="line">openssl req -newkey rsa:2048 -nodes -keyout server.key -subj <span class="string">"/C=CN/ST=BJ/L=BJ/O=MyRootServer/OU=MyServer/CN=<span class="variable">$INPUT</span>"</span> -out server.csr</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"4. Sign SSL certificate..."</span></span><br><span class="line"></span><br><span class="line">openssl x509 -req -extfile &lt;(<span class="built_in">printf</span> <span class="string">"subjectAltName=IP:<span class="variable">$INPUT</span>"</span>) -days 3650 -<span class="keyword">in</span> server.csr -CA selfca.crt -CAkey selfca.key -CAcreateserial -out server.crt</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"5. Create end, next work..."</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Copy server.crt and server.key to your server machine"</span></span><br></pre></td></tr></table></figure><h2 id="执行结果"><a href="#执行结果" class="headerlink" title="执行结果"></a>执行结果</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">$ ./onekeyssl.sh</span><br><span class="line">Enter your domain or ip [www.example.com/10.10.49.172]: 10.10.19.1</span><br><span class="line">1. Create ca private key...</span><br><span class="line">Generating RSA private key, 2048 bit long modulus (2 primes)</span><br><span class="line">..................................................+++++</span><br><span class="line">.....................................+++++</span><br><span class="line">e is 65537 (0x010001)</span><br><span class="line">Enter pass phrase <span class="keyword">for</span> selfca.key:【输入自定义密码】</span><br><span class="line">Verifying - Enter pass phrase <span class="keyword">for</span> selfca.key:【重复密码】</span><br><span class="line">2. Create ca root certificate...</span><br><span class="line">Enter pass phrase <span class="keyword">for</span> selfca.key:【重复密码】</span><br><span class="line">3. Create server key and certificate signing request...</span><br><span class="line">Generating a RSA private key</span><br><span class="line">.............................................................+++++</span><br><span class="line">..........+++++</span><br><span class="line">writing new private key to <span class="string">'server.key'</span></span><br><span class="line">-----</span><br><span class="line">4. Sign SSL certificate...</span><br><span class="line">Signature ok</span><br><span class="line">subject=C = CN, ST = BJ, L = BJ, O = MyRootServer, OU = MyServer, CN = 10.10.19.1</span><br><span class="line">Getting CA Private Key</span><br><span class="line">Enter pass phrase <span class="keyword">for</span> selfca.key:【重复密码】</span><br><span class="line">5. Create end, next work...</span><br><span class="line">Copy server.crt and server.key to your server machine</span><br></pre></td></tr></table></figure><h1 id="分步来看看自建证书的过程"><a href="#分步来看看自建证书的过程" class="headerlink" title="分步来看看自建证书的过程"></a>分步来看看自建证书的过程</h1><p>整个过程分为自建CA和自签名SSL证书两部分：</p><p>自建CA：并不是要你自己搭建一个CA中心，这里的CA其实指的是创建自己的CA根证书，这样可以给其他人签署证书，但是这个CA根证书是你自己创建的，没有得到互联网的承认，也不会被正规CA认可，所以不具备通用和有效性，一般可以在内部网络使用。</p><p>自签名SSL证书：一般来说，我们的证书是要发给权威机构CA进行验证签署的，但是自签证书，就是自己给自己签署生成一份CA证书，或者用自建的CA根证书来签发的SSL证书，同样不具备互联网的通用和有效性，一般只用于测试环境或内部网络。</p><h2 id="自建CA根证书"><a href="#自建CA根证书" class="headerlink" title="自建CA根证书"></a>自建CA根证书</h2><p>自建CA根证书也是分成两步</p><h3 id="生成CA私钥"><a href="#生成CA私钥" class="headerlink" title="生成CA私钥"></a>生成CA私钥</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl genrsa -des3 -out selfca.key 2048</span><br></pre></td></tr></table></figure><p>这条命令使用 OpenSSL 工具生成一个带有Triple-DES（3DES）加密的密码保护的2048位RSA私钥文件，各个参数的含义如下：</p><ul><li><p><code>openssl</code>: OpenSSL 工具的命令行执行器。</p></li><li><p><code>genrsa</code>: 生成RSA密钥的命令。</p></li><li><p><code>-des3</code>: 使用Triple-DES算法对生成的私钥进行加密，这会在生成私钥时要求你设置一个密码，以便在每次使用私钥时都需要提供密码。</p></li><li><p><code>-out selfca.key</code>: 指定生成的私钥的输出文件名为 <code>selfca.key</code>，私钥文件将被保存在当前工作目录中。</p></li><li><p><code>2048</code>: 指定生成的RSA私钥的位数为2048位，这是一种常见的安全密钥长度。</p></li></ul><p>其中密码这一项在生成CA证书时我们是想加的，运行命令后需要输入一个自定义密码两次，以后每次使用这个私钥都要输入密码，但是在很多文章中你会发现他们有一步是要删除密码，原因是在一些自动化部署场景中，去掉私钥密码可以避免手动输入密码，使整个过程更加自动化，比如配置到Apache或者Nginx中时不必每次启动时输入密码，所以我们在后面生成服务器私钥时就不使用密码了。</p><p>带有密码的私钥内容</p><blockquote><p>—–BEGIN RSA PRIVATE KEY—–<br>Proc-Type: 4,ENCRYPTED<br>DEK-Info: DES-EDE3-CBC,2D6A221FF66727E0</p><p>vEzhQnjsKVBLw6tPNo6Dx7D8CyzhZdZYgfxuZBYP30cLWOORTpsS1q0txNMCaWoy<br>S79k0+qTgENne2oirALiCnPB5Rzf3vO6gv/KSScvEnGrZ6Q57i3xObhLYzCtKOAg<br>E6wSBBfbeC6cXczAFZ2ehnM42+Cv/9BX829X7BnbylNbaV1VXQTaEsmo+uWwx9dZ<br>…<br>C2udyFqENooTB7n1Qbtm3Fsruwgk/0IM3vSRk41/EWADabWs4tR/uXQmCPyxouHI<br>xhT3U4EeabyY8dyjSRCkzKPIEFl2HwnYQHZcDVUPD52uHEvA5M7c1QNgX2VmTXzP<br>AgSijAZHDrh6QWa+R9eqUVQShY4mAN7c1sv1or4ZckV7jQTbIBjUGcjhX1TooxX0<br>/RE/GLodSqD8wCkxjgD7uxy93oOLuV/9iDDsrI7VMrs5jlKhKEuPozc+Y+hERRBm<br>UUMbAE2JBW+jD/JzkmXL8w4AGU8wHeRI/FqKQXLbP6v3h+Yb4zP/aOVZ5mdWlHWT<br>1+BykB3qgKUqcn+FmRbodvK8C1G1opDchyomCToHzCGTDqAAcRPoNiB5z3jB+yPC<br>M0m83wI4rWYPghWL4hT7aZgI8l2xwTJfJfyJ+/6MfBZgh/qa4t703A==<br>—–END RSA PRIVATE KEY—–</p></blockquote><p>不带密码的私钥内容</p><blockquote><p>—–BEGIN RSA PRIVATE KEY—–<br>MIIEpQIBAAKCAQEA6OCPgi1pUWdkS9DdR2mk6QJsE9i6rCgaDuk+xyi8Sdxp2u8r<br>f81ZrK4xUNUNTX8+lnj5WeolJ/Hk1o9I659oPkbWuw7yyuCBFbZ9m3goZCt2w+lc<br>csLw6o6XyGTUiptcgB/GmGcd/ua3REAt3l6uYn32vjeit5oX5xsmsUKbwpIH/B81<br>nMohd/t6m9c0h2mcVnUYDmUsV+hmgdASvkTSmvqHOUwV1qX/pQNgjR+auLiezoza<br>LmVkvtSI9/tX6sqtlyROn7ZFsUHJbYuyfOekqLCiY5Wo5ocSTqAd4n/JYmjA6anI<br>YGDXbLcP+075ZgkHSoR9ab4uFtghStx99QYwywIDAQABAoIBAQDWeWryE2y5wiVH<br>…<br>SdwHzniXCpBpNYB6XoV57bPpQiSCqVyT9Owd0A9csZf4905dOZg+/25K2TFmv7gG<br>fHN/4EkCgYEAz7VrytExyCm1B+7sFln7c1hjy5wzNaW2tYi08szvErJkpe3jz9HH<br>MLbTn+DrXZu76nsiXfQbTl7SpPQJptHctHx7K+9mykDaJNGDDNmJRKdwi8cfINrD<br>yYPab+aojwU1FZtF8EEXKjnzWIvmM8FO71ej+COUOmDxWCsDbpoHyhA=<br>—–END RSA PRIVATE KEY—–</p></blockquote><h3 id="生成CA自签名证书"><a href="#生成CA自签名证书" class="headerlink" title="生成CA自签名证书"></a>生成CA自签名证书</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl req -new -x509 -days 3650 -key selfca.key -subj <span class="string">"/C=CN/ST=BJ/L=BJ/O=MyRootCA/OU=MyCA/CN=CA"</span> -out selfca.crt</span><br></pre></td></tr></table></figure><p>这条命令使用 OpenSSL 工具生成自签名根证书（Root Certificate），各个参数的含义如下：</p><ul><li><p><strong><code>openssl req</code>：</strong> 这是 OpenSSL 工具中用于处理证书签署请求（CSR）的命令。</p></li><li><p><strong><code>-new</code>：</strong> 表示创建新的 CSR。</p></li><li><p><strong><code>-x509</code>：</strong> 表示生成自签名的 X.509 证书，而不是生成 CSR。</p></li><li><p><strong><code>-days 3650</code>：</strong> 设置证书的有效期为 3650 天（10 年）。</p></li><li><p><strong><code>-key selfca.key</code>：</strong> 指定用于生成证书的私钥文件为 <code>selfca.key</code>。</p></li><li><p><strong><code>-subj &quot;/C=CN/ST=BJ/L=BJ/O=MyRootCA/OU=MyCA/CN=CA&quot;</code>：</strong> 设置证书主题（Subject）的信息。这里使用了简化的 Distinguished Name (DN)，包括了国家（C=CN）、省/州（ST=BJ）、城市（L=BJ）、组织（O=MyRootCA）、组织单位（OU=MyCA）、通用名称（CN=CA）等信息。</p></li><li><p><strong><code>-out selfca.crt</code>：</strong> 指定生成的证书文件的输出路径和文件名，这里为 <code>selfca.crt</code>。</p></li></ul><p>至此我们就生成了一个自签名的CA根证书，如果把它加入到操作系统或浏览器的信任列表中，那么之后由他签发的SSL证书都可以被信任了，接下来我们开始用它来签发SSL证书。</p><h2 id="自签名SSL证书"><a href="#自签名SSL证书" class="headerlink" title="自签名SSL证书"></a>自签名SSL证书</h2><p>这个过程主要包括生成服务器密钥、构建签名请求和用CA签名证书三部分，其中前两步可以合并为一步：</p><!--### 生成服务器私钥<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl genrsa -out server.key 2048</span><br></pre></td></tr></table></figure><p>这一步与生成CA私钥的命令几乎一样，只是去掉了 <code>-des3</code> 选项，不再需要密码，这样以后配置到服务器上时免去了手动输入密码的麻烦。<br>–&gt;</p><h3 id="生成服务器私钥和证书申请文件CRS"><a href="#生成服务器私钥和证书申请文件CRS" class="headerlink" title="生成服务器私钥和证书申请文件CRS"></a>生成服务器私钥和证书申请文件CRS</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ openssl req -newkey rsa:2048 -nodes -keyout server.key -subj <span class="string">"/C=CN/ST=BJ/L=BJ/O=MyRootServer/OU=MyServer/CN=10.10.49.172"</span> -out server.csr</span><br></pre></td></tr></table></figure><p>这条命令使用 OpenSSL 工具生成证书签署请求（CSR），各个参数的含义如下：</p><ul><li><p><strong><code>openssl req</code>：</strong> 这是 OpenSSL 工具中用于处理证书签署请求（CSR）的命令。</p></li><li><p><strong><code>-newkey rsa:2048</code>：</strong> 创建一个新的 RSA 密钥对，其中包括一个 2048 位的 RSA 私钥和相应的公钥。</p></li><li><p><strong><code>-nodes</code>：</strong> 生成的私钥不使用密码进行加密。这意味着私钥文件 <code>server.key</code> 将不需要密码才能访问。</p></li><li><p><strong><code>-keyout server.key</code>：</strong> 指定生成的私钥文件的输出路径和文件名，这里为 <code>server.key</code>。</p></li><li><p><strong><code>-subj &quot;/C=CN/ST=BJ/L=BJ/O=MyRootServer/OU=MyServer/CN=10.10.49.172&quot;</code>：</strong> 设置证书主题（Subject）的信息。这里使用了简化的 Distinguished Name (DN)，包括了国家（C=CN）、省/州（ST=BJ）、城市（L=BJ）、组织（O=MyRootServer）、组织单位（OU=MyServer）、通用名称（CN=10.10.49.172）等信息。通用名称（CN）通常用于指定服务器的主机名或 IP 地址。</p></li><li><p><strong><code>-out server.csr</code>：</strong> 指定生成的证书签署请求文件的输出路径和文件名，这里为 <code>server.csr</code>。</p></li></ul><h3 id="使用CA根证书签名SSL证书"><a href="#使用CA根证书签名SSL证书" class="headerlink" title="使用CA根证书签名SSL证书"></a>使用CA根证书签名SSL证书</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ openssl x509 -req -extfile &lt;(<span class="built_in">printf</span> <span class="string">"subjectAltName=IP:10.10.49.172"</span>) -days 3650 -<span class="keyword">in</span> server.csr -CA selfca.crt -CAkey selfca.key -CAcreateserial -out server.crt</span><br></pre></td></tr></table></figure><p>这条命令使用 OpenSSL 工具签署证书签署请求（CSR）并生成证书，并且带有SAN信息，各个参数的含义如下：</p><ul><li><p><strong><code>openssl x509</code>：</strong> 这是 OpenSSL 工具中用于处理 X.509 证书的命令。</p></li><li><p><strong><code>-req</code>：</strong> 表示输入的文件是证书签署请求（CSR）。</p></li><li><p><strong><code>-extfile &lt;(printf &quot;subjectAltName=IP:10.10.49.172[,DNS:&lt;YOUR_DOMAIN&gt;,...]&quot;)</code>：</strong> 使用扩展文件，该文件包含了额外的证书扩展信息。在这里，<code>subjectAltName</code> 扩展用于指定主体的备用名称（Subject Alternative Name），这里指定了 IP 地址 <code>10.10.49.172</code>。你也可以在方括号中添加其他主机名或 IP 地址，用逗号分隔。</p></li><li><p><strong><code>-days 3650</code>：</strong> 设置生成的证书的有效期为 3650 天（10 年）。</p></li><li><p><strong><code>-in server.csr</code>：</strong> 指定输入的证书签署请求文件，这里为 <code>server.csr</code>。</p></li><li><p><strong><code>-CA selfca.crt</code>：</strong> 指定用于签署证书的 CA 证书文件，这里为 <code>selfca.crt</code>。</p></li><li><p><strong><code>-CAkey selfca.key</code>：</strong> 指定用于签署证书的 CA 私钥文件，这里为 <code>selfca.key</code>。</p></li><li><p><strong><code>-CAcreateserial</code>：</strong> 创建一个新的序列号文件，该文件用于跟踪 CA 签署的证书的唯一性。</p></li><li><p><strong><code>-out server.crt</code>：</strong> 指定生成的证书文件的输出路径和文件名，这里为 <code>server.crt</code>。</p></li></ul><p>SAN（Subject Alternative Name）是 X.509 证书的一种扩展，用于指定除主题（Subject）之外的其他标识信息。主要用于解决传统的基于主题（Subject）的身份验证方式可能存在的限制，特别是在一个证书需要覆盖多个主机名或 IP 地址的情况下。</p><p>SAN 扩展可以包含多个备用名称（Alternative Name），这些备用名称可以是：</p><ol><li><p><strong>DNS Name（域名）：</strong> 用于指定主机名，可以是域名或子域名。</p></li><li><p><strong>IP Address（IP 地址）：</strong> 用于指定 IP 地址。</p></li><li><p><strong>Email Address（电子邮件地址）：</strong> 用于指定电子邮件地址。</p></li><li><p><strong>URI（统一资源标识符）：</strong> 用于指定统一资源标识符。</p></li><li><p><strong>Directory Name（目录名称）：</strong> 用于指定目录名。</p></li></ol><p>在实际使用中，SAN 可以解决多种问题，例如：</p><ul><li><p><strong>多域 SSL 证书：</strong> 当一个 SSL 证书需要覆盖多个域名时，可以使用 SAN 扩展。</p></li><li><p><strong>IP 地址验证：</strong> 当需要确保证书可以与特定 IP 地址关联时，可以使用 SAN 扩展。</p></li><li><p><strong>多级子域名：</strong> 当证书需要覆盖主域和多级子域时，可以使用 SAN 扩展。</p></li></ul><p>SAN 扩展通常在证书签署请求（CSR）或证书颁发时指定，并在证书中进行存储。在 OpenSSl 命令中，使用 <code>-extfile</code> 选项指定一个包含 SAN 信息的文件，通过该文件可以指定多个备用名称。</p><h1 id="最终的文件列表"><a href="#最终的文件列表" class="headerlink" title="最终的文件列表"></a>最终的文件列表</h1><p>至此CA根证书和自签名SSL证书就生成好了，我们一共收获到了5个文件，作用分别如下：</p><ul><li><p><code>selfca.key</code>：CA私钥，用于后续签名SSL证书</p></li><li><p><code>selfca.crt</code>：CA根证书，用于后续签名SSL证书，需要加入到操作系统或浏览器的信任列表中</p></li><li><p><code>server.key</code>：服务器私钥，需要配置到https服务，比如Apache和Nginx配置文件中</p></li><li><p><code>server.csr</code>：证书签署请求文件，后续没用了</p></li><li><p><code>server.crt</code>：自签名SSL证书，需要配置到https服务，比如Apache和Nginx配置文件中，这就是代表服务器的身份证件</p></li></ul><p>如果想查询证书信息同样可以使用 <code>openssl</code> 命令查询</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">$  openssl x509 -text -noout -<span class="keyword">in</span> server.crt</span><br><span class="line">Certificate:</span><br><span class="line">    Data:</span><br><span class="line">        Version: 3 (0x2)</span><br><span class="line">        Serial Number:</span><br><span class="line">            56:76:35:2c:61:a5:a0:7c:8c:3b:26:93:db:c2:95:a7:18:f9:95:f0</span><br><span class="line">        Signature Algorithm: sha256WithRSAEncryption</span><br><span class="line">        Issuer: C = CN, ST = BJ, L = BJ, O = MyRootCA, OU = MyCA, CN = CA</span><br><span class="line">        Validity</span><br><span class="line">            Not Before: Nov 30 14:43:32 2023 GMT</span><br><span class="line">            Not After : Nov 27 14:43:32 2033 GMT</span><br><span class="line">        Subject: C = CN, ST = BJ, L = BJ, O = MyRootServer, OU = MyServer, CN = 10.10.17.2</span><br><span class="line">        Subject Public Key Info:</span><br><span class="line">            Public Key Algorithm: rsaEncryption</span><br><span class="line">                RSA Public-Key: (2048 bit)</span><br><span class="line">                Modulus:</span><br><span class="line">                    00:b3:41:7c:58:c7:13:c1:c9:af:5b:d6:7d:cb:9a:</span><br><span class="line">                    04:f1:73:5f:60:c4:43:df:4e:26:f5:4d:da:48:f6:</span><br><span class="line">                    4f:13:90:c0:6f:17:a8:44:00:9c:3f:a5:f1:5e:6c:</span><br><span class="line">                    28:15:74:5f:c7:c5:0c:bf:a1:7b:b3:31:ac:7c:67:</span><br><span class="line">                    59:58:f6:33:<span class="built_in">cd</span>:bb:a6:45:85:98:21:c1:79:2c:b9:</span><br><span class="line">                    d2:46:9e:9c:ef:59:ba:d4:0d:fb:4c:86:81:a1:4c:</span><br><span class="line">                    a8:47:d7:4c:cf:13:89:8b:d2:6d:68:85:8f:10:26:</span><br><span class="line">                    87:15:73:ee:e6:14:36:f2:09:d3:c9:2f:f5:bf:c6:</span><br><span class="line">                    e1:ec:ee:54:06:82:83:ee:f7:70:e1:50:2e:a0:44:</span><br><span class="line">                    ce:e1:a4:f9:68:4e:e5:b4:be:39:77:02:1b:ca:c2:</span><br><span class="line">                    c9:55:72:d1:56:ca:e4:47:67:54:1b:d8:a2:83:29:</span><br><span class="line">                    02:0a:1a:b3:81:22:a0:fb:84:cf:d7:43:1c:be:37:</span><br><span class="line">                    bf:9e:04:95:ad:2e:20:ca:2f:04:c8:ef:92:26:7f:</span><br><span class="line">                    5c:f9:1c:94:6d:e5:7b:93:2a:51:fa:d2:e1:a8:87:</span><br><span class="line">                    d4:f8:aa:6d:38:d0:6a:19:8f:48:9d:3a:c3:40:bd:</span><br><span class="line">                    e9:00:ff:cf:f6:67:08:7e:ec:f2:e6:3b:b1:f5:c9:</span><br><span class="line">                    ea:f9:52:5c:f4:68:6b:ee:15:b4:<span class="built_in">fc</span>:ce:44:6d:86:</span><br><span class="line">                    4d:ef</span><br><span class="line">                Exponent: 65537 (0x10001)</span><br><span class="line">        X509v3 extensions:</span><br><span class="line">            X509v3 Subject Alternative Name:</span><br><span class="line">                IP Address:10.10.17.2</span><br><span class="line">    Signature Algorithm: sha256WithRSAEncryption</span><br><span class="line">         26:c8:f8:bd:dc:a3:67:86:e9:a9:81:ce:1a:be:a4:be:c2:f0:</span><br><span class="line">         10:cf:9f:30:1a:a8:40:ee:1a:41:ab:87:33:7e:35:2c:f0:3b:</span><br><span class="line">         9b:62:79:82:fe:7c:63:6e:e8:65:a7:2d:2e:aa:d9:73:2d:58:</span><br><span class="line">         a1:b6:70:ae:33:5f:28:27:52:a0:06:d9:37:d4:a8:70:85:73:</span><br><span class="line">         34:a4:a0:f4:f0:da:4c:9a:61:ab:74:9d:2f:ff:56:be:e4:7a:</span><br><span class="line">         c8:af:7e:f6:8a:4c:52:dc:13:db:9a:33:63:cb:79:b0:18:78:</span><br><span class="line">         f4:9e:af:dd:02:54:0b:94:b0:94:29:77:92:ae:7a:35:ca:00:</span><br><span class="line">         28:bc:be:c1:a1:1a:47:1b:72:5d:2c:1d:0e:79:e6:45:0e:3e:</span><br><span class="line">         e1:25:dc:4c:e0:cb:a0:2a:ad:98:02:d1:e3:92:68:5a:37:89:</span><br><span class="line">         5e:36:54:ec:ed:8a:b4:8b:f7:26:a9:4e:89:15:5e:ed:b1:26:</span><br><span class="line">         45:b4:03:99:37:74:c1:4c:d4:11:eb:42:3d:a4:3f:a8:30:99:</span><br><span class="line">         a0:61:08:85:f7:9e:4e:15:21:37:c3:61:ea:7e:24:3d:73:85:</span><br><span class="line">         44:28:b1:be:b5:27:26:df:38:49:43:ce:b9:96:f9:48:d4:15:</span><br><span class="line">         4b:49:e6:6c:9e:e1:21:d1:25:af:da:76:e2:7e:ca:da:9e:30:</span><br><span class="line">         60:77:53:70</span><br></pre></td></tr></table></figure><h1 id="相关名词"><a href="#相关名词" class="headerlink" title="相关名词"></a>相关名词</h1><p>写到这里虽然说了很多，但感觉还是有点不太清楚，问题出在哪里呢？貌似很多名字直接把初学者干蒙了，所以对于一些认证的名次我再简单总结一下：</p><h2 id="SSL-TLS协议"><a href="#SSL-TLS协议" class="headerlink" title="SSL/TLS协议"></a>SSL/TLS协议</h2><p>SSL: Secure Socket Layer 是由网景公司创建的，一种在互联网上提供密钥传输机制或者叫做协议。其主要目标是保证两个应用间通信数据的保密性和可靠性，可在服务器端和用户端同时支持的一种加密算法。</p><p>TLS：Transport Lanyer Security，由于网景公司的没落，IETF将SSL进行标准化，1999年公布了TLS标准文件。常用的版本：TLS v1（与SSL v3基本相同）</p><h2 id="证书颁发机构（CA）"><a href="#证书颁发机构（CA）" class="headerlink" title="证书颁发机构（CA）"></a>证书颁发机构（CA）</h2><p>CA（Certificate Authority）是一个负责签发和管理数字证书的可信任实体。数字证书用于在计算机网络上进行身份验证和加密通信。CA 的主要职责包括验证证书请求者的身份，并签发数字证书，确认公钥和身份之间的关联。</p><p>以下是 CA 的主要特征和职责：</p><ol><li><p><strong>身份验证：</strong> CA 负责验证证书请求者的身份。这通常涉及验证请求者拥有特定域名或 IP 地址的控制权。验证可以通过多种方式进行，包括域验证、组织验证等。</p></li><li><p><strong>签发证书：</strong> 一旦验证通过，CA 将签发数字证书。数字证书包含了一对密钥中的公钥，以及相关的身份信息。私钥通常由证书的所有者保管，而公钥和证书信息则被 CA 所签署。</p></li><li><p><strong>证书吊销：</strong> CA 负责在需要时吊销证书。证书可能需要吊销的原因包括证书的所有者不再控制相关私钥、证书的私钥被泄露、证书的所有者不再合法等。</p></li><li><p><strong>维护证书撤销列表（CRL）：</strong> CA 维护一个证书撤销列表，其中包含吊销的证书的信息。这允许其他实体检查某个证书是否已被吊销。</p></li><li><p><strong>数字签名：</strong> CA 使用其私钥对签发的证书进行数字签名，以确保证书的完整性和真实性。其他实体可以使用 CA 的公钥来验证数字签名。</p></li><li><p><strong>信任链：</strong> CA 的根证书被内置到操作系统和浏览器中，形成了信任链。当服务器或服务端提供由 CA 签发的证书时，客户端可以通过信任链验证证书的真实性。</p></li></ol><h2 id="数字证书（Certificate）"><a href="#数字证书（Certificate）" class="headerlink" title="数字证书（Certificate）"></a>数字证书（Certificate）</h2><p>数字证书，是一种用于电脑的身份识别机制。由数字证书颁发机构（CA）对使用私钥创建的签名请求文件做的签名（盖章），表示CA结构对证书持有者的认可。</p><p>X.509证书包含三个文件：后缀分别为key，csr和crt，在密码学中，X.509是一个标准，规范了公开秘钥认证、证书吊销列表、授权凭证、凭证路径验证算法等</p><p>key：是服务器上的私钥文件，用于对发送给客户端数据的加密，以及对从客户端接收到数据的解密</p><p>csr：是证书签名请求文件，用于提交给证书颁发机构（CA）对证书签名</p><p>crt：是由证书颁发机构（CA）签名后的证书，或者是开发者自签名的证书，包含证书持有人的信息，持有人的公钥，以及签署者的签名等信息</p><h2 id="pem文件"><a href="#pem文件" class="headerlink" title=".pem文件"></a>.pem文件</h2><p>在生成密钥的过程中通常会涉及到.pem文件，<code>.pem</code> 是一种通用的文件扩展名，表示文件内容遵循 Privacy Enhanced Mail (PEM) 格式。PEM 格式是一种基于文本的编码格式，常用于存储和传输数据，特别是涉及加密和证书的数据。PEM 格式的文件使用 ASCII 编码，以便于阅读和传输。</p><p>PEM 文件通常包含的信息类型有：</p><ol><li><p><strong>证书（Certificate）：</strong> 通常以 <code>.pem</code> 扩展名保存，包含用于公钥加密和身份验证的数字证书。</p></li><li><p><strong>私钥（Private Key）：</strong> 也可以以 <code>.pem</code> 扩展名保存，包含用于对数据进行解密和签名的私钥。</p></li><li><p><strong>证书请求（Certificate Signing Request，CSR）：</strong> 包含有关证书请求者的信息，通常用于向证书颁发机构（CA）请求签发数字证书。</p></li><li><p><strong>密钥和证书的捆绑（Bundle）：</strong> 有时，PEM 文件还可以包含密钥和证书的捆绑，以便在一个文件中同时包含私钥和相关的证书。</p></li></ol><p>PEM 格式的文件采用 Base64 编码，同时包含用于描述文件内容的文本标记。标记通常以 <code>-----BEGIN ...-----</code> 和 <code>-----END ...-----</code> 的形式出现，标记之间的内容是经过 Base64 编码的二进制数据。</p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-----BEGIN CERTIFICATE-----</span><br><span class="line">MIID...</span><br><span class="line">...</span><br><span class="line">... (Base64-encoded data)</span><br><span class="line">...</span><br><span class="line">-----END CERTIFICATE-----</span><br></pre></td></tr></table></figure><p>不同的应用程序和系统可能会使用 <code>.pem</code> 扩展名来表示各种类型的文件，因此需要根据上下文和文件内容来确定其确切的含义。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>自建CA根证书和生成SSL签名证书都可以通过 <code>openssl</code> 命令来完成</li><li>自建CA根证书结果会得到selfca.key和selfca.crt两个文件，名字可以自定义，用于后续签名服务器SSL证书</li><li>生成SSL签名证书的结果会得到server.key、server.csr、server.csr三个文件，只要把server.key和server.csr配置到服务器就好了</li><li>生成server.key时一般为了自动化维护不会设置密码，如果为了安全确实需要密码的话，可以配置到密码文件中防止服务重启时打断流程</li><li>网络的世界里证书就是身份证，在这个环境下你总要无条件信点啥，比如你的操作系统和浏览器</li></ul><h1 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h1><p>不知道你有没有注意到，用私钥签名根证书的时候并没有使用公钥，按道理说签名的时候会把公钥放到签名证书中才对，为什么这里没有呢？那是因为对于 RSA 算法，从私钥可以提取公钥，因为私钥包含了模数（modulus）和私钥指数（private exponent）。然而，从公钥（包含模数和公钥指数）推导出私钥，则取决于大数分解问题的难解性，目前尚未找到有效的算法在合理的时间内解决大整数的分解问题。所以说公钥是可以从私钥从得到的，所以不必单独获取。</p><hr><center><a href="https://blog.csdn.net/albertsh/article/details/134607439"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>兜兜又转转，有些时候真的迈出那一步就成了，想了又想是不可能前进1cm的，就像这篇总结，真的开始了，到现在也就完成了~</p></blockquote>-->]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;这是加密与认证系列的第五篇文章了，本来我是想把自建证书和nginx配置https访问总结到一起的，但是在实际操作的过程中我发现了很多细小的知识点，有些还是挺有意思的，这是一个不断自我提问不断寻求答案的过程，随着扩展的内容越来越多，我决定这篇只写自建CA和签名SSL证书这部分，至于nginx配置https访问放到后面再写吧。&lt;/p&gt;
    
    </summary>
    
      <category term="Network" scheme="http://AlbertGithubHome.github.io/blog/categories/Network/"/>
    
    
      <category term="网络" scheme="http://AlbertGithubHome.github.io/blog/tags/%E7%BD%91%E7%BB%9C/"/>
    
      <category term="https" scheme="http://AlbertGithubHome.github.io/blog/tags/https/"/>
    
      <category term="openssl" scheme="http://AlbertGithubHome.github.io/blog/tags/openssl/"/>
    
      <category term="CA根证书" scheme="http://AlbertGithubHome.github.io/blog/tags/CA%E6%A0%B9%E8%AF%81%E4%B9%A6/"/>
    
      <category term="自签名SSL证书" scheme="http://AlbertGithubHome.github.io/blog/tags/%E8%87%AA%E7%AD%BE%E5%90%8DSSL%E8%AF%81%E4%B9%A6/"/>
    
  </entry>
  
  <entry>
    <title>究竟什么是阻塞与非阻塞、同步与异步</title>
    <link href="http://AlbertGithubHome.github.io/blog/2023/11/24/%E7%A9%B6%E7%AB%9F%E4%BB%80%E4%B9%88%E6%98%AF%E9%98%BB%E5%A1%9E%E4%B8%8E%E9%9D%9E%E9%98%BB%E5%A1%9E%E3%80%81%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%BC%82%E6%AD%A5/"/>
    <id>http://AlbertGithubHome.github.io/blog/2023/11/24/究竟什么是阻塞与非阻塞、同步与异步/</id>
    <published>2023-11-24T14:08:31.000Z</published>
    <updated>2023-12-19T16:01:17.785Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这几个名词在程序开发时经常听到，但是突然问起来各个词的含义一时间还真是说不清楚，貌似这几个词都是翻译过来的，每个人的解释都不太一样，我对这几个词的理解也不是一成不变的，随着开发经验的积累，渐渐有了自己的记忆方式，所以总结一下，不一定准确，有问题可以一起聊一聊。</p><p>先说说我的结论：<strong>阻塞与非阻塞是指等待执行结果时的状态，同步与异步是指获取执行结果的方式</strong>，读起来有点绕口，听起来也迷迷糊糊的，没关系，我们用具体的例子来说明应该就容易理解了。</p><a id="more"></a><h1 id="阻塞与非阻塞"><a href="#阻塞与非阻塞" class="headerlink" title="阻塞与非阻塞"></a>阻塞与非阻塞</h1><p>先说说『阻塞与非阻塞是指等待执行结果时的状态』这一句，是说在执行某个操作或者某个函数时，在没有拿到我们想要的结果时，我们的状态是怎样的，如果是一直等就是【阻塞】的，如果发现没有结果就去做别的事情了就是【非阻塞】的。</p><p>以常见的网络IO为例，服务器对客户端连接的socket调用<code>read</code>函数，试图获取客户端发送的请求数据，但是客户端并不总是有数据发送过来，所以想要获得数据我可以采用【阻塞】方式一直等，也可以采用【非阻塞】方式，在发现此时没有数据时就先去干别的事，一会再来看看。</p><h1 id="同步与异步"><a href="#同步与异步" class="headerlink" title="同步与异步"></a>同步与异步</h1><p>再来说说『同步与异步是指获取执行结果的方式』这一句，以游戏中的常见升级发奖为例，可以主动调用升级函数，在执行完成后返回升级的结果，然后根据结果来发奖励，也就是【同步】写法，也可以注册一个监听等级变化的回调函数，注册完我就不管了，当升级时会将升级的结果通过回调函数传回来，这就是【异步】处理方式。</p><h1 id="复杂的网络IO"><a href="#复杂的网络IO" class="headerlink" title="复杂的网络IO"></a>复杂的网络IO</h1><p>为什么同步和异步没有用网络IO来举例呢？因为网络IO这里的情况更加复杂，虽然你注册了回调函数，但它很可能是个同步IO，究竟怎么回事，一起来看看。</p><p>我们知道要想从IO读取数据，需要经历「内核数据准备好」和「数据从内核态拷贝到用户态」两个过程，还是以<code>read</code>函数为例，如果设置为阻塞模式，相当于<code>read</code>函数等待了「内核数据准备好」和「数据从内核态拷贝到用户态」两个过程，然后取到IO数据，如果设置成非阻塞模式，当内核数据没准备好会直接返回，也就是不会等待第一个过程，但是当数据准备好时，会直接等待第二个过程完成后，将结果数据返回。</p><p>所以无论是否阻塞，我们都等待了第二个阶段，等着它执行完成后获取结果，所以这两种都是同步IO。</p><p>那作为IO多路复用里的“一哥”epoll也是同步IO吗？是的！那封装了select/poll/epoll的libevent可是用了Reactor模式，支持事件回调，它也是同步IO吗？是的！</p><h1 id="真正的异步IO"><a href="#真正的异步IO" class="headerlink" title="真正的异步IO"></a>真正的异步IO</h1><p>有点惊呆了不是吗？那究竟什么是异步IO呢？还真有！Windows 里实现了一套完整的支持 socket 的异步编程接口 <code>IOCP</code>，而 Linux 是在 2019 年 5.1 版本 内核首次引入的高性能异步I/O 框架 <code>io_uring</code>，我确实都没用过，感兴趣的可以试一下</p><p>是否是异步IO就看「数据从内核态拷贝到用户态」这个过程需不需要等待，如果需要逻辑层自己等待这个过程取数据就是同步IO，如果这个过程都不用等，调用回调函数时已经把内核态的数据拷贝出来，并且通过回调将数据进行了回传，这就是异步IO。</p><h1 id="IO分类与示例"><a href="#IO分类与示例" class="headerlink" title="IO分类与示例"></a>IO分类与示例</h1><p>所以总结下来一共有这么几种：同步阻塞IO，同步非阻塞IO，异步IO，为啥不区分异步阻塞IO和异步非阻塞IO呢？你在阻塞时搞个异步试试，办不到吧，所以异步只能与非阻塞搭配，也就习惯只写异步IO了。</p><p>一顿理论讲下来可能还是比较抽象，那我们再举个日常生活中的例子，比如中午买饭的过程：</p><p>同步阻塞IO就好像，你去食堂吃面条，但是你去这一锅面条还没煮好，然后你就一直在那里等啊等，等了一段时间终于做好了（数据准备的过程），但是你还得继续等工作人员把面条（内核空间）打到你的餐盘里（用户空间），才能找个桌子开始吃饭。</p><p>同步非阻塞IO就好像，你又去食堂吃饭，问大叔饭做好了没有，告诉你没有你就离开了，过了一会，你又来饭堂问大叔饭做好了吗，人家说说做好了，于是你等着把饭打到你的餐盘里，后面这个过程你是得等待的。</p><p>异步IO就好像，你在十分焦急的写BUG，这时到饭点肚子饿了，给食堂大叔打电话，等饭做好了麻烦给我送一份，等到饭好了真的送来直接就能吃了，一直在抓紧写BUG中间没有等待（做梦中）</p><p>我想大部分同学吃午饭都是第一种同步阻塞IO吧，第二种同步非阻塞IO可能也有，但是不是要重新排队啊，如果是第三种异步IO的情况，我只能说大哥/姐，我跟你混了~~</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>IO分为同步阻塞IO，同步非阻塞IO，异步IO三类</li><li>异步IO有Windows平台的 <code>IOCP</code> 和 Linux 平台的 <code>io_uring</code></li><li>从IO读取数据，需要经历「内核数据准备好」和「数据从内核态拷贝到用户态」两个过程</li><li>分析阻塞和非阻塞看是否等待第一个过程，分析同步与异步看是否等待第二个过程</li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/134149247" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>人生的岔路口，不知是机会还是风险，边走边看吧，毕竟路还是在脚下，空想也到不了终点~</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;这几个名词在程序开发时经常听到，但是突然问起来各个词的含义一时间还真是说不清楚，貌似这几个词都是翻译过来的，每个人的解释都不太一样，我对这几个词的理解也不是一成不变的，随着开发经验的积累，渐渐有了自己的记忆方式，所以总结一下，不一定准确，有问题可以一起聊一聊。&lt;/p&gt;
&lt;p&gt;先说说我的结论：&lt;strong&gt;阻塞与非阻塞是指等待执行结果时的状态，同步与异步是指获取执行结果的方式&lt;/strong&gt;，读起来有点绕口，听起来也迷迷糊糊的，没关系，我们用具体的例子来说明应该就容易理解了。&lt;/p&gt;
    
    </summary>
    
      <category term="Network" scheme="http://AlbertGithubHome.github.io/blog/categories/Network/"/>
    
    
      <category term="服务器" scheme="http://AlbertGithubHome.github.io/blog/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
      <category term="同步与异步" scheme="http://AlbertGithubHome.github.io/blog/tags/%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%BC%82%E6%AD%A5/"/>
    
      <category term="阻塞与非阻塞" scheme="http://AlbertGithubHome.github.io/blog/tags/%E9%98%BB%E5%A1%9E%E4%B8%8E%E9%9D%9E%E9%98%BB%E5%A1%9E/"/>
    
      <category term="异步IO" scheme="http://AlbertGithubHome.github.io/blog/tags/%E5%BC%82%E6%AD%A5IO/"/>
    
      <category term="Reactor" scheme="http://AlbertGithubHome.github.io/blog/tags/Reactor/"/>
    
  </entry>
  
  <entry>
    <title>git diff对比差异时指定或排除特定的文件和目录</title>
    <link href="http://AlbertGithubHome.github.io/blog/2023/10/31/git-diff%E5%AF%B9%E6%AF%94%E5%B7%AE%E5%BC%82%E6%97%B6%E6%8C%87%E5%AE%9A%E6%88%96%E6%8E%92%E9%99%A4%E7%89%B9%E5%AE%9A%E7%9A%84%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95/"/>
    <id>http://AlbertGithubHome.github.io/blog/2023/10/31/git-diff对比差异时指定或排除特定的文件和目录/</id>
    <published>2023-10-31T13:26:41.000Z</published>
    <updated>2023-12-19T15:57:40.465Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>你一般什么时候会用GPT?</p></blockquote><p>居然会有这种话题，答案就是作为程序员的我天天在用，虽然GPT有个胡说八道的毛病，但试试总没错的，就比如今天题目中这个问题，我也是先查了GPT没好使，但给我提供了查询思路，最后在Stack Overflow上找到解决办法，记录一下</p><a id="more"></a><h1 id="git-diff指定或者排除文件"><a href="#git-diff指定或者排除文件" class="headerlink" title="git diff指定或者排除文件"></a>git diff指定或者排除文件</h1><p>我就直接列答案了，没什么可说的，工具参数记住就好</p><h2 id="指定文件和目录"><a href="#指定文件和目录" class="headerlink" title="指定文件和目录"></a>指定文件和目录</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff dev..feature --<span class="built_in">stat</span>  -- <span class="string">':*.pb.go'</span> <span class="string">':*.pb.h'</span> <span class="string">':*.pb.cc'</span></span><br></pre></td></tr></table></figure><p>以上语句表示对比dev和feature分支差异的文件，但是只选择后缀为以上三种的文件，如果是特定的目录，将冒号后的内容替换成目录即可，<code>-- &#39;:src/thirdparty&#39;</code></p><h2 id="排除文件和目录"><a href="#排除文件和目录" class="headerlink" title="排除文件和目录"></a>排除文件和目录</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff dev..feature --<span class="built_in">stat</span>  -- <span class="string">':!*.pb.go'</span> <span class="string">':!*.pb.h'</span> <span class="string">':!*.pb.cc'</span></span><br></pre></td></tr></table></figure><p>在上面的基础上加个取反的感叹号就行，如果是排除目录就在 <code>!</code>直接写目录就可以了，这种排除的写法还有另一种形式，用<code>(exclude)</code>代替感叹号，其中还可以写其他属性，感兴趣可以自己扩展查询一下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff dev..feature --<span class="built_in">stat</span> -- <span class="string">':(exclude)*.pb.go'</span> <span class="string">':(exclude)*.pb.h'</span> <span class="string">':(exclude)*.pb.cc'</span></span><br></pre></td></tr></table></figure><h1 id="番外篇"><a href="#番外篇" class="headerlink" title="番外篇"></a>番外篇</h1><p>今天在某乎上看到一个提问《C++有多难？》，看着大佬们口若悬河、引经据典的在诉说、在吐槽、在愤慨，却引起了我的回忆，我为什么选择C++？</p><blockquote><p>只因为在人群中多看了一眼吧，有先入为主的因素，也有水到渠成的必然。</p></blockquote><p>我最先接触的一门编程语言是C语言，对于刚刚接触编程的我来说，它是那么令人着迷，虽然开发环境是寒酸可怜的Turbo C，但是丝毫没有影响我的学习热情，刚开始打印出一个杨辉三角都开心的不得了，教科书上的每个例子我都敲了很多遍，虽然那古老的教材现在被大佬们批判的不行，但确实领我在代码的世界里入了门。</p><p>后来随着学习的推进，又逐步接触了Java、C#等高级语言，也接触了汇编、单片机等偏底层的领域，为什么没有选Java、C#而一直坚守C语言呢？有份程序员的孤傲，当时觉得C语言很酷，我是底层我牛X，你们这些语言不是带个虚拟机，就是拖个运行时一点都Cool，那为什么不选汇编语言呢？咳咳，确实吼不住。</p><p>就这样我带着C语言，C语言伴着我开始一步步经历大学生活，当然期间也从一些“旁门左道”里习得只言片语的C++，只是我不知道它还有这个名字，带着舍我其谁的年轻气盛，我和C语言一起去参加各种编程比赛，结果有好有坏，但实力确实很菜，虽然也拿到过一些区域或者国家级的名次，但如今已成过往云烟。</p><p>转眼间就来到了大四实习，一个专业100多人，少部分人选择了苹果应用，绝大多数投身于Java开发，而我独自一人选择了嵌入式C，为什么选择嵌入式，因为只有它带“C”，也是在这短暂的几个月里我再一次听说了C++，但仅仅局限于了解C和C++有什么不同，C++好像有个class和struct挺像的。</p><p>开始真正的找工作了，受大学和室友一起打dota的影响，我毅然决然的加入了游戏开发大军，在那个各类游戏百花齐放的年代，C/C++在游戏行业有着根深蒂固的基础，因为我的C语言还不错，所以还是顺利的入了坑。</p><p>但随着踏入这个坑，我和C++开始正面交锋了，纠缠至今已经有10多年，中间工作6年之后有一次转Golang开发的机会被我拒绝了，我给那个面试官的回答是因为情怀吧，我不能离开C++。</p><p>如今我用C++20的标准在工作，与刚开始接触的C++98真的跨了一个世纪，各种语法糖之外是另一些语法糖，每个版本中标准委员会提到的特性，恨不得要3年后的要下个版本才能开发，庞大语言体系使得一些初入社会的毛头小子才配标注“精通”二字，而像我这种使用十多年的菜鸟只敢承认用过C++，略懂皮毛而已。</p><p>C++很难吗？真的很难！可不可以简单一点，其实它也可以很简单，不要拿着各种内存问题和我C++挑战，这不是我的强项，但我同样可以写出没有内存泄漏的程序；也不要拿着各种工具、运行时库和我比开发效率，这也不是我的强项，我难道就没有库吗，开源的世界里百花齐放。</p><p>不要一提到C++就是面向对象、STL、模板元编程，它是一门编程语言，一门用于完成任务的可编写逻辑的语言，用它写一个冒泡排序也很简单，不要过分夸大他的难度，每次你都把它最难的地方亮出来，对它来说是不公平的。</p><p>如今，我不会再说C++就是牛X其他语言都是垃圾这种脑抽的话，C++只是一种语言，一种我暂时还离不开的语言，但它不再是我的唯一，写个小工具偶尔也会使用Python或者Golang，不是我不再爱C++，而是有了更合适的选择而已。</p><p>C++，一门集强大与庞大于一身的语言，学会它容易，但学透它确实很难，我们在一起共同成长。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>GPT无处不在，每天必用超过了google</li><li>git diff 指定文件类型 <code>git diff dev..feature -- &#39;:*.pb.go&#39; &#39;:*.pb.h&#39; &#39;:*.pb.cc&#39;</code></li><li>git diff 排除文件类型 <code>git diff dev..feature -- &#39;:!*.pb.go&#39; &#39;:!*.pb.h&#39; &#39;:!*.pb.cc&#39;</code></li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/134000167" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>每天提问自己一个问题，试验一段时间，看看是否有效吧，本质还是眼高手低造成了目前的焦虑</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;你一般什么时候会用GPT?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;居然会有这种话题，答案就是作为程序员的我天天在用，虽然GPT有个胡说八道的毛病，但试试总没错的，就比如今天题目中这个问题，我也是先查了GPT没好使，但给我提供了查询思路，最后在Stack Overflow上找到解决办法，记录一下&lt;/p&gt;
    
    </summary>
    
      <category term="Git" scheme="http://AlbertGithubHome.github.io/blog/categories/Git/"/>
    
    
      <category term="git" scheme="http://AlbertGithubHome.github.io/blog/tags/git/"/>
    
      <category term="diff" scheme="http://AlbertGithubHome.github.io/blog/tags/diff/"/>
    
      <category term="gpt" scheme="http://AlbertGithubHome.github.io/blog/tags/gpt/"/>
    
      <category term="c++" scheme="http://AlbertGithubHome.github.io/blog/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>linux环境下使用timeout监控命令执行超过5分钟后发送通知</title>
    <link href="http://AlbertGithubHome.github.io/blog/2023/10/23/linux%E7%8E%AF%E5%A2%83%E4%B8%8B%E4%BD%BF%E7%94%A8timeout%E7%9B%91%E6%8E%A7%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E8%B6%85%E8%BF%875%E5%88%86%E9%92%9F%E5%90%8E%E5%8F%91%E9%80%81%E9%80%9A%E7%9F%A5/"/>
    <id>http://AlbertGithubHome.github.io/blog/2023/10/23/linux环境下使用timeout监控命令执行超过5分钟后发送通知/</id>
    <published>2023-10-23T14:35:37.000Z</published>
    <updated>2023-12-19T15:56:57.530Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>有一段时间没写了，马上1024了，总得有点输出吧，想到最近用了一个挺有用的命令 <code>timeout</code>   ，所以拿出来简单展示一下它的用法，作用就是可以给指定命令设置超时时间，相当于扩展了原命令，对于一般没有超时参数的命令是个方便的扩展方式，可以增加超时处理。</p><a id="more"></a><h1 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h1><p>使用方法也非常简单，下面是一个简单的示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置超时时间（秒）</span></span><br><span class="line">TIMEOUT=300</span><br><span class="line"></span><br><span class="line"><span class="comment"># 要监控的命令</span></span><br><span class="line">./hooks/rsync.sh &amp;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取命令的进程ID</span></span><br><span class="line">command_pid=$!</span><br><span class="line"></span><br><span class="line"><span class="comment"># 等待命令执行完成，或者直到超时</span></span><br><span class="line">timeout <span class="variable">$TIMEOUT</span> tail --pid=<span class="variable">$command_pid</span> -f /dev/null</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查是否超时</span></span><br><span class="line"><span class="keyword">if</span> [ $? -eq 124 ]; <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"timeout"</span></span><br><span class="line">  iostat -d -x 2 9</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"normal"</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p><code>tail --pid=$command_pid -f /dev/null</code> 这个命令是用来等待指定进程 <code>$command_pid</code> 结束的同时保持脚本的运行，以确保后续的超时检查。</p><ul><li><p><code>tail</code> 是一个用于显示文件末尾内容的命令，通常用于查看日志文件。</p></li><li><p><code>--pid=$command_pid</code> 是 <code>tail</code> 命令的一个选项。它告诉 <code>tail</code> 命令在结束之前等待指定的进程 <code>$command_pid</code> 完成。这是通过监视 <code>/proc/$command_pid/fd/1</code> 文件（进程的标准输出）来实现的，以便在进程结束时 <code>tail</code> 命令也会退出。</p></li><li><p><code>-f /dev/null</code> 表示 <code>tail</code> 命令要查看 <code>/dev/null</code> 文件的内容，但 <code>/dev/null</code> 文件是一个空文件，所以它不会产生输出。这里的目的是让 <code>tail</code> 命令一直运行，直到 <code>$command_pid</code> 进程结束。</p></li></ul><p>这种构造的作用是等待命令执行完成，但在等待的过程中不产生输出。一旦 <code>$command_pid</code> 进程结束，<code>tail</code> 命令也会退出，允许脚本继续执行后续操作，如检查是否超时。</p><ul><li><p><code>if [ $? -eq 124 ]; then ... else ...:</code>这一段是条件语句，用于检查timeout命令的返回状态。如果返回状态是124，意味着rsync.sh脚本执行超时，那么它会打印”timeout”以指示发生了超时，并且运行iostat -d -x 2 9命令来获取磁盘I/O统计信息。</p></li><li><p>如果timeout命令的返回状态不是124，即没有发生超时，它将执行else部分打印”normal”以指示命令正常执行。</p></li></ul><h1 id="其他有趣的命令"><a href="#其他有趣的命令" class="headerlink" title="其他有趣的命令"></a>其他有趣的命令</h1><p>类似这种监控或者扩展的命令还有：</p><ul><li><code>time</code>，于测量命令执行的时间。它会运行一个命令，并报告命令执行所花费的实际时间（包括用户CPU时间和系统CPU时间），通常用于性能分析和优化。例如 <code>time my_command</code>，</li><li><code>at</code>，可以计划执行一次性任务，比如将在15:30执行命令<code>echo &quot;my_command&quot; | at 15:30</code></li><li><code>nohup</code>，用于在后台运行命令，比如 <code>nohup my_command &gt; output.log 2&gt;&amp;1 &amp;</code></li></ul><h1 id="系统资源查询命令"><a href="#系统资源查询命令" class="headerlink" title="系统资源查询命令"></a>系统资源查询命令</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">date &gt;&gt; /tmp/slow.log</span><br><span class="line">iostat -d -x 2 5 &gt;&gt; /tmp/slow.log</span><br><span class="line">vmstat -n 2 5 &gt;&gt; /tmp/slow.log</span><br><span class="line">sar -B 2 5 &gt;&gt; /tmp/slow.log</span><br><span class="line">top -b -n 3 | grep <span class="string">"md5sum"</span> &gt;&gt; /tmp/slow.log</span><br></pre></td></tr></table></figure><p>有时发现系统总是被无故拖慢，有些进程迟迟不能结束，虽然有监控grafana大盘可以查，但是有些参数不太细致，可以上面展示的这些命令来临时查一下，它们的含义如下：</p><ol><li><p><strong>iostat -d -x 2 5 &gt;&gt; /tmp/slow.log</strong>：</p><ul><li><code>iostat</code> 用于报告系统磁盘活动和性能</li><li><code>-d</code> 选项表示只显示磁盘相关的信息</li><li><code>-x</code> 选项用于显示扩展的磁盘统计信息</li><li><code>2</code> 表示每隔2秒报告一次</li><li><code>5</code> 表示报告5次</li></ul></li><li><p><strong>vmstat -n 2 5 &gt;&gt; /tmp/slow.log</strong>：</p><ul><li><code>vmstat</code> 用于显示虚拟内存统计</li><li><code>-n</code> 选项用于指定输出中不显示表头</li></ul></li><li><p><strong>sar -B 2 5 &gt;&gt; /tmp/slow.log</strong>：</p><ul><li><code>sar</code> 用于系统性能数据采集和报告</li><li><code>-B</code> 选项用于报告缓冲区和页缓存统计信息</li></ul></li><li><p><strong>top -b -n 3 | grep “md5sum” &gt;&gt; /tmp/slow.log</strong>：</p><ul><li><code>top</code> 用于实时查看系统中正在运行的进程和其性能</li><li><code>-b</code> 选项表示以批处理模式运行，适用于脚本</li><li><code>-n 3</code> 表示运行3次 <code>top</code></li><li><code>grep &quot;md5sum&quot;</code> 用于筛选包含 “md5sum” 的行，以查找与 “md5sum” 相关的进程</li></ul></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">Fri Oct 20 13:36:31 CST 2023</span><br><span class="line">Linux 3.10.0-1160.88.1.el7.x86_64 (demo-machine)        10/20/2023      &gt;_x86_64_        (8 CPU)</span><br><span class="line"></span><br><span class="line">Device:         rrqm/s   wrqm/s     r/s     w/s    rkB/s    wkB/s avgrq-sz &gt;avgqu-sz   await r_await w_await  svctm  %util</span><br><span class="line">fd0               0.00     0.00    0.00    0.00     0.00     0.00     8.00     &gt;0.00  136.50  136.50    0.00 136.50   0.00</span><br><span class="line">sdb               0.00     0.00    1.98    0.02   179.62     6.55   186.84     &gt;0.06   32.16   30.23  265.38   1.45   0.29</span><br><span class="line">sda               0.00     0.02    0.01    0.23     0.27     1.98    18.70     &gt;0.00    9.97  103.14    6.89   1.96   0.05</span><br><span class="line"></span><br><span class="line">Device:         rrqm/s   wrqm/s     r/s     w/s    rkB/s    wkB/s avgrq-sz &gt;avgqu-sz   await r_await w_await  svctm  %util</span><br><span class="line">fd0               0.00     0.00    0.00    0.00     0.00     0.00     0.00     &gt;0.00    0.00    0.00    0.00   0.00   0.00</span><br><span class="line">sdb               0.00     0.00    1.47    0.00   598.04     0.00   813.33     &gt;0.13   86.33   86.33    0.00  42.33   6.23</span><br><span class="line">sda               0.00     0.00    0.49    0.98     3.92     2.70     9.00     &gt;0.01   10.00   30.00    0.00  10.00   1.47</span><br><span class="line"></span><br><span class="line">Device:         rrqm/s   wrqm/s     r/s     w/s    rkB/s    wkB/s avgrq-sz &gt;avgqu-sz   await r_await w_await  svctm  %util</span><br><span class="line">fd0               0.00     0.00    0.00    0.00     0.00     0.00     0.00     &gt;0.00    0.00    0.00    0.00   0.00   0.00</span><br><span class="line">sdb               0.00     0.00    0.99    0.00   392.08     0.00   792.00     &gt;0.02   19.00   19.00    0.00   9.50   0.94</span><br><span class="line">sda               0.00     0.00    0.00    0.00     0.00     0.00     0.00     &gt;0.00    0.00    0.00    0.00   0.00   0.00</span><br><span class="line"></span><br><span class="line">Device:         rrqm/s   wrqm/s     r/s     w/s    rkB/s    wkB/s avgrq-sz &gt;avgqu-sz   await r_await w_await  svctm  %util</span><br><span class="line">fd0               0.00     0.00    0.00    0.00     0.00     0.00     0.00     &gt;0.00    0.00    0.00    0.00   0.00   0.00</span><br><span class="line">sdb               0.00     0.00    4.00    0.00  1776.00     0.00   888.00     &gt;0.06   15.25   15.25    0.00   2.62   1.05</span><br><span class="line">sda               0.00     0.00    0.00    1.50     0.00     6.00     8.00     &gt;0.00    2.00    0.00    2.00   0.67   0.10</span><br><span class="line"></span><br><span class="line">Device:         rrqm/s   wrqm/s     r/s     w/s    rkB/s    wkB/s avgrq-sz &gt;avgqu-sz   await r_await w_await  svctm  %util</span><br><span class="line">fd0               0.00     0.00    0.00    0.00     0.00     0.00     0.00     &gt;0.00    0.00    0.00    0.00   0.00   0.00</span><br><span class="line">sdb               0.00     0.00    4.23    0.00  2066.15     0.00   976.73     &gt;0.13   31.00   31.00    0.00   3.55   1.50</span><br><span class="line">sda               0.00     0.00    0.00    0.00     0.00     0.00     0.00     &gt;0.00    0.00    0.00    0.00   0.00   0.00</span><br><span class="line"></span><br><span class="line">procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----</span><br><span class="line"> r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st</span><br><span class="line"> 2  0      0 162364      0 12586664    0    0    23     1    0    1  0  0 100  0  0</span><br><span class="line"> 2  0      0 158892      0 12565264    0    0     0     0 3209  413  0  8 92  0  0</span><br><span class="line"> 2  0      0 165976      0 12543900    0    0     0     0 1879  332  0  5 95  0  0</span><br><span class="line"> 2  0      0 163496      0 12523372    0    0   396     0 2844  678  0  8 92  0  0</span><br><span class="line"> 3  0      0 162240      0 12502092    0    0     0     0 2038  574  0  7 93  0  0</span><br><span class="line">Linux 3.10.0-1160.88.1.el7.x86_64 (demo-machine)        10/20/2023      &gt;_x86_64_        (8 CPU)</span><br><span class="line"></span><br><span class="line">01:36:48 PM  pgpgin/s pgpgout/s   fault/s  majflt/s  pgfree/s pgscank/s pgscand/s &gt;pgsteal/s    %vmeff</span><br><span class="line">01:36:50 PM   1674.00      0.00   3098.00      0.00   3431.00   3362.00      &gt;0.00   3362.00    100.00</span><br><span class="line">01:36:52 PM      0.00      0.00   2874.50      0.00   2675.00   2650.50      &gt;0.00   2650.50    100.00</span><br><span class="line">01:36:54 PM   2822.00      0.00   2478.50      0.00   2666.50   2645.00      &gt;0.00   2645.00    100.00</span><br><span class="line">01:36:56 PM      0.00      0.50   1248.50      0.00 156173.00   2642.00      &gt;0.00   2642.00    100.00</span><br><span class="line">01:36:58 PM      0.00      0.00   1975.00      0.00    321.50      0.00      &gt;0.00      0.00      0.00</span><br><span class="line">Average:       899.20      0.10   2334.90      0.00  33053.40   2259.90      0.00   2259.90    100.00</span><br><span class="line"> 5667 root      20   0 1455484  54400   1256 R 100.0  0.3   3:54.39 md5sum</span><br><span class="line"> 5667 root      20   0 1455484  75784   1256 R 100.0  0.5   3:57.40 md5sum</span><br><span class="line"> 5667 root      20   0 1455484  98752   1256 R 100.0  0.6   4:00.41 md5sum</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li><code>timeout</code> 可以给其他命令设置超时时间</li><li><code>at</code> 可以计划执行一次性任务</li><li><code>iostat -d -x 2 5</code> 用于报告系统磁盘活动和性能</li><li><code>vmstat -n 2 5</code> 用于显示虚拟内存统计</li><li><code>sar -B 2 5</code> 用于系统性能数据采集和报告</li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/133689734" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>心态还是很难调整好，大道理学了这么久，发现都是讲给别人听的，根本治愈不了自己，该歇歇了~</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;有一段时间没写了，马上1024了，总得有点输出吧，想到最近用了一个挺有用的命令 &lt;code&gt;timeout&lt;/code&gt;   ，所以拿出来简单展示一下它的用法，作用就是可以给指定命令设置超时时间，相当于扩展了原命令，对于一般没有超时参数的命令是个方便的扩展方式，可以增加超时处理。&lt;/p&gt;
    
    </summary>
    
      <category term="linux" scheme="http://AlbertGithubHome.github.io/blog/categories/linux/"/>
    
    
      <category term="linux" scheme="http://AlbertGithubHome.github.io/blog/tags/linux/"/>
    
      <category term="运维" scheme="http://AlbertGithubHome.github.io/blog/tags/%E8%BF%90%E7%BB%B4/"/>
    
      <category term="服务器" scheme="http://AlbertGithubHome.github.io/blog/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
      <category term="timeout" scheme="http://AlbertGithubHome.github.io/blog/tags/timeout/"/>
    
      <category term="iostat" scheme="http://AlbertGithubHome.github.io/blog/tags/iostat/"/>
    
  </entry>
  
  <entry>
    <title>废了九牛二虎之力终于修改了MySQL8.0的root密码</title>
    <link href="http://AlbertGithubHome.github.io/blog/2023/10/08/%E5%BA%9F%E4%BA%86%E4%B9%9D%E7%89%9B%E4%BA%8C%E8%99%8E%E4%B9%8B%E5%8A%9B%E7%BB%88%E4%BA%8E%E4%BF%AE%E6%94%B9%E4%BA%86MySQL8-0%E7%9A%84root%E5%AF%86%E7%A0%81/"/>
    <id>http://AlbertGithubHome.github.io/blog/2023/10/08/废了九牛二虎之力终于修改了MySQL8-0的root密码/</id>
    <published>2023-10-08T12:56:28.000Z</published>
    <updated>2023-10-08T15:10:27.895Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>上次说到在Ubuntu系统上安装MySQL8.0之后默认是没有密码的，如果想设置密码需要写成<code>ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED WITH mysql_native_password BY &#39;xxx&#39;;</code> 的形式，其实在用这种方式之前，我还使用功能了mysql_secure_installation这个MySQL自带的程序来设置密码，但是没生效，为什么这个看起来很正规的方式不生效的呢？接下来一起找找原因。</p><a id="more"></a><h1 id="使用mysql-secure-installation"><a href="#使用mysql-secure-installation" class="headerlink" title="使用mysql_secure_installation"></a>使用mysql_secure_installation</h1><p>使用步骤比较简单，就按照提示来输入就可以了，这是我第二次运行，第一次运行时还要加个 ‘Would you like to setup VALIDATE PASSWORD component?’ 步骤</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">root@w-dev:~<span class="comment"># mysql_secure_installation</span></span><br><span class="line"></span><br><span class="line">Securing the MySQL server deployment.</span><br><span class="line"></span><br><span class="line">Enter password <span class="keyword">for</span> user root:</span><br><span class="line">The <span class="string">'validate_password'</span> component is installed on the server.</span><br><span class="line">The subsequent steps will run with the existing configuration</span><br><span class="line">of the component.</span><br><span class="line">Using existing password <span class="keyword">for</span> root.</span><br><span class="line"></span><br><span class="line">Estimated strength of the password: 50</span><br><span class="line">Change the password <span class="keyword">for</span> root ? ((Press y|Y <span class="keyword">for</span> Yes, any other key <span class="keyword">for</span> No) : y</span><br><span class="line"></span><br><span class="line">New password:</span><br><span class="line"></span><br><span class="line">Re-enter new password:</span><br><span class="line"></span><br><span class="line">Estimated strength of the password: 50</span><br><span class="line">Do you wish to <span class="built_in">continue</span> with the password provided?(Press y|Y <span class="keyword">for</span> Yes, any other key <span class="keyword">for</span> No) : y</span><br><span class="line">By default, a MySQL installation has an anonymous user,</span><br><span class="line">allowing anyone to <span class="built_in">log</span> into MySQL without having to have</span><br><span class="line">a user account created <span class="keyword">for</span> them. This is intended only <span class="keyword">for</span></span><br><span class="line">testing, and to make the installation go a bit smoother.</span><br><span class="line">You should remove them before moving into a production</span><br><span class="line">environment.</span><br><span class="line"></span><br><span class="line">Remove anonymous users? (Press y|Y <span class="keyword">for</span> Yes, any other key <span class="keyword">for</span> No) : y</span><br><span class="line">Success.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Normally, root should only be allowed to connect from</span><br><span class="line"><span class="string">'localhost'</span>. This ensures that someone cannot guess at</span><br><span class="line">the root password from the network.</span><br><span class="line"></span><br><span class="line">Disallow root login remotely? (Press y|Y <span class="keyword">for</span> Yes, any other key <span class="keyword">for</span> No) : y</span><br><span class="line">Success.</span><br><span class="line"></span><br><span class="line">By default, MySQL comes with a database named <span class="string">'test'</span> that</span><br><span class="line">anyone can access. This is also intended only <span class="keyword">for</span> testing,</span><br><span class="line">and should be removed before moving into a production</span><br><span class="line">environment.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Remove <span class="built_in">test</span> database and access to it? (Press y|Y <span class="keyword">for</span> Yes, any other key <span class="keyword">for</span> No) : y</span><br><span class="line"> - Dropping <span class="built_in">test</span> database...</span><br><span class="line">Success.</span><br><span class="line"></span><br><span class="line"> - Removing privileges on <span class="built_in">test</span> database...</span><br><span class="line">Success.</span><br><span class="line"></span><br><span class="line">Reloading the privilege tables will ensure that all changes</span><br><span class="line">made so far will take effect immediately.</span><br><span class="line"></span><br><span class="line">Reload privilege tables now? (Press y|Y <span class="keyword">for</span> Yes, any other key <span class="keyword">for</span> No) : y</span><br><span class="line">Success.</span><br><span class="line"></span><br><span class="line">All <span class="keyword">done</span>!</span><br></pre></td></tr></table></figure><p>那么这个程序具体干了哪些事呢，下面来解释一下。</p><p>mysql_secure_installation 是一个 MySQL 提供的命令行工具，用于帮助加强和改善 MySQL 服务器的安全性。当首次安装 MySQL 后，运行此工具可以执行一系列的操作来提高 MySQL 服务器的安全性，并确保默认设置不会导致潜在的安全漏洞。以下是 mysql_secure_installation 工具执行的主要任务：</p><p><strong>设置 root 密码：</strong> 如果您在安装 MySQL 时没有为 root 用户设置密码，mysql_secure_installation 会提示您设置 root 密码。设置 root 密码是非常重要的，因为 root 用户具有最高的权限，拥有对 MySQL 服务器的完全控制。</p><p><strong>删除匿名用户：</strong> mysql_secure_installation 会删除默认情况下存在的匿名用户。匿名用户是指没有用户名和密码就能访问 MySQL 服务器的用户。删除这些用户可以减少潜在的安全风险。</p><p><strong>禁止远程 root 登录：</strong> 默认情况下，MySQL 允许 root 用户从任何主机登录。mysql_secure_installation 会提示您是否禁止 root 用户从远程主机登录，以减少潜在的远程攻击风险。</p><p><strong>删除测试数据库：</strong> 默认情况下，MySQL 安装包含一个名为 “test” 的测试数据库，这个数据库可能会成为潜在的攻击目标。mysql_secure_installation 会提示您是否删除测试数据库。</p><p><strong>刷新权限：</strong> 完成上述任务后，mysql_secure_installation 会刷新 MySQL 权限表，以确保更改生效。</p><p>mysql_secure_installation 工具有助于在 MySQL 安装完成后采取一些基本的安全措施，以减少潜在的风险和攻击。然而，这只是开始，为了更好地保护 MySQL 服务器和数据，您还应该采取其他安全措施，如定期备份、限制用户权限、监控数据库活动等。</p><h1 id="mysql-secure-installation-为什么设置root密码无效"><a href="#mysql-secure-installation-为什么设置root密码无效" class="headerlink" title="mysql_secure_installation 为什么设置root密码无效"></a>mysql_secure_installation 为什么设置root密码无效</h1><p>看上面的描述这个程序挺靠谱的，为啥设置密码不好使呢？遵循着网络大神们的脚本，我找到了一个 <a href="https://github.com/twitter-forks/mysql/blob/master/scripts/mysql_secure_installation.sh" target="_blank" rel="noopener">mysql_secure_installation.sh</a>脚本，来自[twitter-forks/mysql]开源库，其中包含这样一段代码：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">esc_pass=`basic_single_escape "$password1"`</span><br><span class="line">do_query "UPDATE mysql.user SET Password=PASSWORD('$esc_pass') WHERE User='root';"</span><br><span class="line">if [ $? -eq 0 ]; then</span><br><span class="line">echo "Password updated successfully!"</span><br><span class="line">echo "Reloading privilege tables.."</span><br><span class="line">reload_privilege_tables</span><br><span class="line">if [ $? -eq 1 ]; then</span><br><span class="line">    clean_and_exit</span><br><span class="line">fi</span><br><span class="line">echo</span><br><span class="line">rootpass=$password1</span><br><span class="line">make_config</span><br><span class="line">else</span><br><span class="line">echo "Password update failed!"</span><br><span class="line">clean_and_exit</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p><code>&quot;UPDATE mysql.user SET Password=PASSWORD(&#39;$esc_pass&#39;) WHERE User=&#39;root&#39;;&quot;</code> 这个脚本里居然用了我们之前提到的已经失效的更新方式，但是我发现我在Ubuntu系统下安装的mysql_secure_installation是一个二进制程序，不是shell脚本，所以我又找到了<a href="https://github.com/mysql/mysql-server/blob/8.0/client/mysql_secure_installation.cc#L425" target="_blank" rel="noopener">mysql的源码</a>程序，其中包含这样一段：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">  query =</span><br><span class="line">      (<span class="keyword">char</span> *)my_malloc(PSI_NOT_INSTRUMENTED, password_len + <span class="number">50</span>, MYF(MY_WME));</span><br><span class="line">  end = my_stpmov(query, <span class="string">"SET PASSWORD="</span>);</span><br><span class="line">  *end++ = <span class="string">'\''</span>;</span><br><span class="line">  end += mysql_real_escape_string_quote(mysql, end, password,</span><br><span class="line">                                        (ulong)password_len, <span class="string">'\''</span>);</span><br><span class="line">  *end++ = <span class="string">'\''</span>;</span><br><span class="line">  <span class="keyword">if</span> (mysql_real_query(mysql, query, (ulong)(end - query))) &#123;</span><br><span class="line">    my_free(query);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>里面包含了<code>&quot;SET PASSWORD=&quot;</code>的字样，看起来不太靠谱的样子，需要注意的是，在 MySQL 5.7 版本之后，<code>SET PASSWORD</code> 命令已被弃用，推荐使用 <code>ALTER USER</code> 命令来修改密码。例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">USER</span> <span class="string">'root'</span>@<span class="string">'localhost'</span> <span class="keyword">IDENTIFIED</span> <span class="keyword">BY</span> <span class="string">'新密码'</span>;</span><br></pre></td></tr></table></figure><p>这个命令更加直观，并且与最新版本的 MySQL 兼容。同样，将 <code>&#39;新密码&#39;</code> 替换为您希望设置的新密码。</p><p>难道是MySQL 8.0没有更新工具的代码？暂时不得而知，这或许就是mysql_secure_installation设置密码不生效的原因。</p><h1 id="ALTER-USER再生事端"><a href="#ALTER-USER再生事端" class="headerlink" title="ALTER USER再生事端"></a>ALTER USER再生事端</h1><p>前文提到了一种更加直观的设置新密码的方式 <code>ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;新密码&#39;;</code>，但是在我这行不通，不仅我这行不通，网上也有很多人说设置不了，需要加上插件名称 <code>WITH mysql_native_password</code>，改为 <code>ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED WITH mysql_native_password BY &#39;新密码&#39;;</code> 才可以，这又是为什么呢？</p><p>执行 <code>select host,user,plugin,authentication_string from mysql.user;</code> 语句查看发现：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select host,user,plugin,authentication_string from mysql.user;</span><br><span class="line">+<span class="comment">-----------+------------------+-----------------------+------------------------------------------------------------------------+</span></span><br><span class="line">| host      | user             | plugin                | authentication_string                                                  |</span><br><span class="line">+<span class="comment">-----------+------------------+-----------------------+------------------------------------------------------------------------+</span></span><br><span class="line">| localhost | zone1            | mysql_native_password | *4C7684A2CD28A1C3C55CC832E6O817FCE3C5B5DB                              |</span><br><span class="line">| localhost | mysql.infoschema | caching_sha2_password | $A$005$THISISACOMBINATIONOFINVALIDSALTANDPASSWORDTHATMUSTNEVERBRBEUSED |</span><br><span class="line">| localhost | mysql.session    | caching_sha2_password | $A$005$THISISACOMBINATIONOFINVALIDSALTANDPASSWORDTHATMUSTNEVERBRBEUSED |</span><br><span class="line">| localhost | mysql.sys        | caching_sha2_password | $A$005$THISISACOMBINATIONOFINVALIDSALTANDPASSWORDTHATMUSTNEVERBRBEUSED |</span><br><span class="line">| localhost | root             | auth_socket           |                                                                        |</span><br><span class="line">| localhost | admin            | mysql_native_password | *F52COBE5FFB5FFCCD5BFD976OADEB81081AE4787                              |</span><br><span class="line">+<span class="comment">-----------+------------------+-----------------------+------------------------------------------------------------------------+</span></span><br></pre></td></tr></table></figure><p>原来每个账户还有默认的不同的密码管理插件，用于验证和管理用户密码，mysql_native_password、auth_socket和caching_sha2_password这三种插件的含义如下：</p><h2 id="mysql-native-password"><a href="#mysql-native-password" class="headerlink" title="mysql_native_password"></a>mysql_native_password</h2><ul><li>加密算法： 使用较旧的哈希算法，如SHA-1或SHA-256，取决于 MySQL 版本。</li><li>认证方式： 用户密码以哈希形式存储在系统表中，服务器在用户登录时将明文密码哈希并与数据库中存储的哈希进行比较。</li><li>支持远程登录： 支持远程密码登录，可以从远程主机登录 MySQL。</li><li>适用场景： 适用于需要与旧版 MySQL 兼容或需要与其他应用程序或系统进行集成的情况。</li></ul><h2 id="caching-sha2-password"><a href="#caching-sha2-password" class="headerlink" title="caching_sha2_password"></a>caching_sha2_password</h2><ul><li>加密算法： 使用 SHA-256 进行加密，提供更高级别的安全性。</li><li>支持版本： 从 MySQL 5.7.4 开始，caching_sha2_password 成为默认的密码插件。</li><li>认证方式： 用户密码以加密形式存储在系统表中，并且在用户登录时，服务器将明文密码哈希并与数据库中存储的哈希进行比较。</li><li>支持远程登录： 支持远程密码登录，可以从远程主机登录 MySQL。</li></ul><h2 id="auth-socket"><a href="#auth-socket" class="headerlink" title="auth_socket"></a>auth_socket</h2><ul><li>认证方式： 不存储密码哈希，而是依赖于操作系统（Linux）的用户认证机制。只有与操作系统用户账户关联的 MySQL 用户可以登录，而不需要密码。</li><li>适用场景： 通常用于本地连接，因为它要求数据库用户和操作系统用户名称一致。</li><li>安全性： 提供了一定的安全性，因为不需要存储密码哈希，但需要确保服务器的用户账户和 MySQL 用户账户的一致性。</li></ul><p>总结来说，这些密码插件之间的区别主要涉及到加密算法、认证方式以及适用场景。caching_sha2_password 提供更高级别的安全性，而 auth_socket 依赖于操作系统用户认证机制，mysql_native_password 则提供与旧版 MySQL 兼容性。使用前应根据安全性需求、用户管理和应用程序集成的要求来选择合适的密码插件。一般来说，推荐使用较新且安全性更高的密码插件，如caching_sha2_password。</p><p>测试后发现，MySQL8.0默认安装后root用户的默认插件是 <code>auth_socket</code>，这种插件没办法设置密码，所以指定插件为 <code>mysql_native_password</code> 时就可以设置密码了，但是根据建议，我们应该选择 <code>caching_sha2_password</code>插件。</p><h1 id="肯定好使的MySQL初始化方法"><a href="#肯定好使的MySQL初始化方法" class="headerlink" title="肯定好使的MySQL初始化方法"></a>肯定好使的MySQL初始化方法</h1><ul><li><code>apt install mysql-server</code></li><li><code>mysql</code></li><li><code>ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED WITH caching_sha2_password BY &#39;新密码&#39;;</code></li><li><code>flush privileges;</code></li><li><code>exit;</code></li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>安装MySQL8.0后使用<code>ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED WITH caching_sha2_password BY &#39;xxx&#39;;</code>设置密码</li><li>mysql_secure_installation工具不好使的原因目前来看是源代码没有工具的源代码没有及时更新，与MySQL版本不匹配</li><li>mysql_secure_installation另外的几项功能，比如删除匿名用户、删除测试数据库、禁止远程登录在安装完貌似都处理好了</li><li>综上来看，难道mysql_secure_installation工具已经被废弃了？</li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/132701267" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>你们的一切都是我的，只要留心你将获得无穷的助力，很多东西不必从头开始，既然做不成巨人，就从巨人的肩膀上出发吧~</p><p>证件照尺寸查询<br>一寸    295<em>413px   | 25</em>35mm<br>二寸    413<em>579px   | 35</em>49mm<br>小一寸  260<em>378px   | 22</em>32mm<br>大一寸  390<em>567px   | 33</em>48mm<br>小二寸  413<em>531px   | 35</em>45mm<br>大二寸  413<em>626px   | 35</em>53mm<br>三寸    650<em>992px   | 55</em>84mm<br>四寸    898<em>1181px  | 76</em>100mm<br>五寸    1050<em>1500px | 89</em>127mm</p><p>2023-10-8 20:56:28</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;上次说到在Ubuntu系统上安装MySQL8.0之后默认是没有密码的，如果想设置密码需要写成&lt;code&gt;ALTER USER &amp;#39;root&amp;#39;@&amp;#39;localhost&amp;#39; IDENTIFIED WITH mysql_native_password BY &amp;#39;xxx&amp;#39;;&lt;/code&gt; 的形式，其实在用这种方式之前，我还使用功能了mysql_secure_installation这个MySQL自带的程序来设置密码，但是没生效，为什么这个看起来很正规的方式不生效的呢？接下来一起找找原因。&lt;/p&gt;
    
    </summary>
    
      <category term="Mysql" scheme="http://AlbertGithubHome.github.io/blog/categories/Mysql/"/>
    
    
      <category term="Mysql" scheme="http://AlbertGithubHome.github.io/blog/tags/Mysql/"/>
    
      <category term="root" scheme="http://AlbertGithubHome.github.io/blog/tags/root/"/>
    
      <category term="mysql_secure_installation" scheme="http://AlbertGithubHome.github.io/blog/tags/mysql-secure-installation/"/>
    
      <category term="AlterUser" scheme="http://AlbertGithubHome.github.io/blog/tags/AlterUser/"/>
    
      <category term="修改密码" scheme="http://AlbertGithubHome.github.io/blog/tags/%E4%BF%AE%E6%94%B9%E5%AF%86%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>C++20中的关键字</title>
    <link href="http://AlbertGithubHome.github.io/blog/2023/10/07/C-20%E4%B8%AD%E7%9A%84%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <id>http://AlbertGithubHome.github.io/blog/2023/10/07/C-20中的关键字/</id>
    <published>2023-10-07T15:34:23.000Z</published>
    <updated>2023-10-08T15:08:12.248Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>源于上一篇中提到了 <code>decltype</code>是一个关键字，所以去查了现有的关键字列表，其实我对C/C++的关键字还停留在上世纪大概30多个的时代，虽然知道C++加了 <code>auto</code>、<code>constexpr</code> 等关键字，但查询过后才发现原来他扩充到了将近100个，而C语言的关键字也扩到了六七十个，有点震惊了。</p><a id="more"></a><h1 id="关键字列表"><a href="#关键字列表" class="headerlink" title="关键字列表"></a>关键字列表</h1><p><img src="https://img-blog.csdnimg.cn/571f2e791dfa484c82436da29a1e5b61.png" alt="keywords"><br>这份列表来源于<a href="https://en.cppreference.com/w/cpp/keyword" target="_blank" rel="noopener">cppreference</a>，感兴趣的可以去看原文，下面对这些关键字进行一个简单的介绍，有些还是很陌生的。</p><h1 id="关键字含义"><a href="#关键字含义" class="headerlink" title="关键字含义"></a>关键字含义</h1><table><thead><tr><th style="text-align:left">关键字</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td style="text-align:left">alignas</td><td style="text-align:left">指定类型或对象的对齐要求</td></tr><tr><td style="text-align:left">alignof</td><td style="text-align:left">查询类型的对齐要求</td></tr><tr><td style="text-align:left">and</td><td style="text-align:left">用作 <code>&amp;&amp;</code> 的替代写法</td></tr><tr><td style="text-align:left">and_eq</td><td style="text-align:left">用作 <code>&amp;=</code> 的替代写法</td></tr><tr><td style="text-align:left">asm</td><td style="text-align:left">汇编（asm）声明给予在 C++ 程序中嵌入汇编语言源代码的能力</td></tr><tr><td style="text-align:left">atomic_cancel (TM TS)</td><td style="text-align:left">原子块，若抛出异常，则调用 std::abort，除非该异常是用于事务取消的异常之一，这种情况下事务被取消</td></tr><tr><td style="text-align:left">atomic_commit (TM TS)</td><td style="text-align:left">原子块，若抛出异常，则正常地提交事务</td></tr><tr><td style="text-align:left">atomic_noexcept (TM TS)</td><td style="text-align:left">原子块，若抛出异常，则调用 std::abort</td></tr><tr><td style="text-align:left">auto</td><td style="text-align:left">可以在声明变量的时候根据变量初始值的类型自动为此变量选择匹配的类型（C++11）</td></tr><tr><td style="text-align:left">bitand</td><td style="text-align:left">用作 <code>&amp;</code> 的替代写法</td></tr><tr><td style="text-align:left">bitor</td><td style="text-align:left">用作  `\</td><td>`  的替代写法</td></tr><tr><td style="text-align:left">bool</td><td style="text-align:left">足以存放两个值 true 或 false 之一的类型</td></tr><tr><td style="text-align:left">break</td><td style="text-align:left">控制将被转移到紧跟其外围循环或 switch 的下一位置</td></tr><tr><td style="text-align:left">case</td><td style="text-align:left">根据条件的值，将控制流转移到若干语句之一</td></tr><tr><td style="text-align:left">catch</td><td style="text-align:left">和try联合使用，将一或多个异常处理块（catch 子句）与复合语句关联</td></tr><tr><td style="text-align:left">char</td><td style="text-align:left">能在目标系统上最有效地处理的字符表示的类型</td></tr><tr><td style="text-align:left">char8_t</td><td style="text-align:left">UTF-8 字符表示的类型，要求大到足以表示任何 UTF-8 编码单元（ 8 位）</td></tr><tr><td style="text-align:left">char16_t</td><td style="text-align:left">UTF-16 字符表示的类型，要求大到足以表示任何 UTF-16 编码单元（ 16 位）</td></tr><tr><td style="text-align:left">char32_t</td><td style="text-align:left">UTF-32 字符表示的类型，要求大到足以表示任何 UTF-32 编码单元（ 32 位）， C++ 标准还保证 1 == sizeof(char) &lt;= sizeof(short) &lt;= sizeof(int) &lt;= sizeof(long) &lt;= sizeof(long long)</td></tr><tr><td style="text-align:left">class</td><td style="text-align:left">声明类</td></tr><tr><td style="text-align:left">compl</td><td style="text-align:left">用作 <code>~</code> 的替代写法</td></tr><tr><td style="text-align:left">concept</td><td style="text-align:left">声明具名类型要求</td></tr><tr><td style="text-align:left">const</td><td style="text-align:left">类型限定符，定义类型为常量</td></tr><tr><td style="text-align:left">consteval</td><td style="text-align:left">指定函数是立即函数（immediate function），即每次调用该函数必须产生编译时常量</td></tr><tr><td style="text-align:left">constexpr</td><td style="text-align:left">指定变量或函数的值可在常量表达式中出现，在 constexpr if 语句中，条件的值必须是可按语境转换到 bool 类型的经转换常量表达式</td></tr><tr><td style="text-align:left">constinit</td><td style="text-align:left">断言变量拥有静态初始化，即零初始化与常量初始化</td></tr><tr><td style="text-align:left">const_cast</td><td style="text-align:left">用const_cast来去除const限定</td></tr><tr><td style="text-align:left">continue</td><td style="text-align:left">导致外围 for、范围 for、while 或 do-while 循环体的剩余部分被跳过</td></tr><tr><td style="text-align:left">co_await</td><td style="text-align:left">协程是能暂停执行以在之后恢复的函数</td></tr><tr><td style="text-align:left">co_return</td><td style="text-align:left">协程中的 return 语句</td></tr><tr><td style="text-align:left">co_yield</td><td style="text-align:left">协程中表达式向调用方返回一个值并暂停当前协程</td></tr><tr><td style="text-align:left">decltype</td><td style="text-align:left">检查实体的声明类型，或表达式的类型和值类别</td></tr><tr><td style="text-align:left">default</td><td style="text-align:left">1.switch 语句用于声明默认情况标号。2.显式默认化的函数定义令编译器为某个类生成特殊成员函数或比较运算符的显式指令</td></tr><tr><td style="text-align:left">delete</td><td style="text-align:left">1.销毁先前由 new 表达式分配的对象，并释放获得的内存区域。2.弃置函数(C++11 起)</td></tr><tr><td style="text-align:left">do</td><td style="text-align:left">do-while 循环，用作循环的声明</td></tr><tr><td style="text-align:left">double</td><td style="text-align:left">浮点类型</td></tr><tr><td style="text-align:left">dynamic_cast</td><td style="text-align:left">沿继承层级向上、向下及侧向，安全地转换到其他类的指针和引用</td></tr><tr><td style="text-align:left">else</td><td style="text-align:left">if 语句用作另一分支的声明</td></tr><tr><td style="text-align:left">enum</td><td style="text-align:left">声明枚举类型</td></tr><tr><td style="text-align:left">explicit</td><td style="text-align:left">1.指定构造函数或转换函数 (C++11 起)或推导指引 (C++17 起)为显式，即它不能用于隐式转换和复制初始化。2.explicit 说明符可以与常量表达式一同使用。当且仅当该常量表达式求值为 true 时函数为显式。</td></tr><tr><td style="text-align:left">export</td><td style="text-align:left">1.用于标记模板定义为被导出，这允许在其他翻译单元中声明但不定义同一模板。(C++11 前) 2.不使用并保留该关键词。(C++11 起)(C++20 前) 3.标记一个声明、一组声明或另一模块为当前模块所导出。(C++20 起)</td></tr><tr><td style="text-align:left">extern</td><td style="text-align:left">1.具有外部连接的静态存储期说明符 2.语言连接说明 3.显示模板实例化声明（或“extern 模板”）</td></tr><tr><td style="text-align:left">false</td><td style="text-align:left">布尔字面量</td></tr><tr><td style="text-align:left">float</td><td style="text-align:left">单精度浮点类型</td></tr><tr><td style="text-align:left">for</td><td style="text-align:left">用于该循环的声明</td></tr><tr><td style="text-align:left">friend</td><td style="text-align:left">友元声明出现于类体内，并向一个函数或另一个类授予对包含友元声明的类的私有及受保护成员的访问权。</td></tr><tr><td style="text-align:left">goto</td><td style="text-align:left">无条件转移控制流。当使用其他语句不可能将控制转移到所需位置时使用。</td></tr><tr><td style="text-align:left">if</td><td style="text-align:left">有条件地执行另一条语句。用于需要基于运行时或编译时条件执行的代码。</td></tr><tr><td style="text-align:left">inline</td><td style="text-align:left">1.将函数声明为一个 内联（inline）函数。完全在 class/struct/union 的定义之内定义的函数，无论它是成员函数还是非成员 friend 函数，均为隐式的内联函数。2.内联命名空间</td></tr><tr><td style="text-align:left">int</td><td style="text-align:left">基本整数类型</td></tr><tr><td style="text-align:left">long</td><td style="text-align:left">长整数类型</td></tr><tr><td style="text-align:left">mutable(1)</td><td style="text-align:left">1.容许在即便包含它的对象被声明为 const 时仍可修改声明为 mutable 的类成员。2.mutable 用于指定不影响类的外部可观察状态的成员（通常用于互斥体、记忆缓存、惰性求值和访问指令等）。3.从按复制捕获的形参中移除的 const 限定性的 lambda 声明符 (C++11 起) 4.被mutable修饰的变量，将永远处于可变的状态，即使在一个const函数中</td></tr><tr><td style="text-align:left">namespace</td><td style="text-align:left">命名空间声明</td></tr><tr><td style="text-align:left">new</td><td style="text-align:left">.创建并初始化拥有动态存储期的对象，这些对象的生存期不受它们创建时所在的作用域限制</td></tr><tr><td style="text-align:left">noexcept (C++11 起)</td><td style="text-align:left">1.noexcept 运算符进行编译时检查，若表达式声明为不抛出任何异常则返回 true 2.指定函数是否抛出异常</td></tr><tr><td style="text-align:left">not</td><td style="text-align:left">用作 <code>!</code> 的替代写法</td></tr><tr><td style="text-align:left">not_eq</td><td style="text-align:left">用作 <code>!=</code> 的替代写法</td></tr><tr><td style="text-align:left">nullptr (C++11 起)</td><td style="text-align:left">代表指针字面量，保持空指针常量的含义</td></tr><tr><td style="text-align:left">operator</td><td style="text-align:left">重载的运算符是具有特殊的函数名的函数</td></tr><tr><td style="text-align:left">or</td><td style="text-align:left">用作</td><td>的替代写法</td></tr><tr><td style="text-align:left">or_eq</td><td style="text-align:left">用作 `\</td><td>=` 的替代写法</td></tr><tr><td style="text-align:left">private</td><td style="text-align:left">该访问说明符之后的各个成员具有私有成员访问</td></tr><tr><td style="text-align:left">protected</td><td style="text-align:left">该访问说明符之后的各个成员具有受保护成员访问</td></tr><tr><td style="text-align:left">public</td><td style="text-align:left">该访问说明符之后的各个成员具有公开成员访问</td></tr><tr><td style="text-align:left">reflexpr (反射 TS)</td><td style="text-align:left">反射是指程序在运行时动态获取对象属性与方法的一种机制</td></tr><tr><td style="text-align:left">register</td><td style="text-align:left">1.动存储期，另提示编译器将此对象置于处理器的寄存器。2.不使用并保留该关键词</td></tr><tr><td style="text-align:left">reinterpret_cast</td><td style="text-align:left">通过重新解释底层位模式在类型间转换。</td></tr><tr><td style="text-align:left">requires (C++20 起)</td><td style="text-align:left">1.对模板形参指定一个求值为要求的常量表达式。 2.于模板声明中指定关联制约</td></tr><tr><td style="text-align:left">return</td><td style="text-align:left">终止当前函数并返回指定值（若存在）给调用方函数</td></tr><tr><td style="text-align:left">short</td><td style="text-align:left">至少 16 位的宽度（和long一样表示大小）</td></tr><tr><td style="text-align:left">signed</td><td style="text-align:left">目标类型将拥有有符号表示（若省略则此为默认）</td></tr><tr><td style="text-align:left">sizeof(1)</td><td style="text-align:left">1.查询对象或类型的大小。2.在需要知道对象的实际大小时使用。3.返回形参包中的元素数量</td></tr><tr><td style="text-align:left">static</td><td style="text-align:left">1.声明具有静态存储期和内部连接的命名空间成员。2.定义具有静态存储期且仅初始化一次的块作用域变量。3.声明不绑定到特定实例的类成员</td></tr><tr><td style="text-align:left">static_assert (C++11 起)</td><td style="text-align:left">进行编译时断言检查</td></tr><tr><td style="text-align:left">static_cast</td><td style="text-align:left">用隐式和用户定义转换的组合在类型间转换</td></tr><tr><td style="text-align:left">struct</td><td style="text-align:left">1.复合类型的声明。2.有作用域枚举类型的声明(C++11 起) 3.若存在于作用域中的某个函数或变量所拥有的名字，与某个非联合体类类型的名字相同，则可在其名字之前加上 struct 来消歧义，这产生一个详述类型说明符</td></tr><tr><td style="text-align:left">switch</td><td style="text-align:left">根据条件的值，将控制流转移到若干语句之一</td></tr><tr><td style="text-align:left">synchronized (TM TS)</td><td style="text-align:left">程序中的所有最外层同步块都以一个单独的全序执行</td></tr><tr><td style="text-align:left">template</td><td style="text-align:left">1.声明模板。 2.在模板定义中，template 可用于将某个待决名声明为模板</td></tr><tr><td style="text-align:left">this</td><td style="text-align:left">this 是一个纯右值表达式，其值是隐式对象形参（在其上调用非静态成员函数的对象）的地址</td></tr><tr><td style="text-align:left">thread_local (C++11 起)</td><td style="text-align:left">线程存储期</td></tr><tr><td style="text-align:left">throw</td><td style="text-align:left">1.对错误条件发信号，并执行错误处理代码 2.列出函数可能直接或间接抛出的异常</td></tr><tr><td style="text-align:left">true</td><td style="text-align:left">bool 类型的纯右值，为真</td></tr><tr><td style="text-align:left">try</td><td style="text-align:left">将一或多个异常处理块（catch 子句）与复合语句关联</td></tr><tr><td style="text-align:left">typedef</td><td style="text-align:left">创建能在任何位置替代（可能复杂的）类型名的别名</td></tr><tr><td style="text-align:left">typeid</td><td style="text-align:left">查询类型的信息。用于必须知晓多态对象的动态类型的场合以及静态类型鉴别</td></tr><tr><td style="text-align:left">typename</td><td style="text-align:left">1.在模板声明中，typename 可用作 class 的代替品，以声明类型模板形参和模板形参 (C++17 起) 2.在模板的声明或定义内，typename 可用于声明某个待决的有限定名是类型。3.在模板的声明或定义内， (C++11 前)typename 可在非待决的有限定类型名之前使用。此情况下它没有效果。4.在类型要求的要求中。(C++20 起)</td></tr><tr><td style="text-align:left">union</td><td style="text-align:left">1.联合体类型的声明。2.若存在于作用域中的某个函数或变量所拥有的名字与某个联合体类型的名字相同，则可在该名字之前加上 union 以消歧义，这产生详述类型说明符</td></tr><tr><td style="text-align:left">unsigned</td><td style="text-align:left">目标类型将拥有无符号表示</td></tr><tr><td style="text-align:left">using</td><td style="text-align:left">1.对命名空间的 using 指令及对命名空间成员的 using 声明。2.对类成员的 using 声明。3.类型别名与别名模板声明 (C++11 起)</td></tr><tr><td style="text-align:left">virtual</td><td style="text-align:left">1.虚函数说明符。2.虚基类说明符</td></tr><tr><td style="text-align:left">void</td><td style="text-align:left">1.void 类型。2.无形参函数的形参列表</td></tr><tr><td style="text-align:left">volatile</td><td style="text-align:left">定义类型为易变，确保本条指令不会因编译器的优化而省略，且要求每次直接读值</td></tr><tr><td style="text-align:left">wchar_t</td><td style="text-align:left">宽字符表示的类型</td></tr><tr><td style="text-align:left">while</td><td style="text-align:left">1.while 循环的声明。2.do-while 循环终止条件的声明</td></tr><tr><td style="text-align:left">xor</td><td style="text-align:left">作为 <code>^</code> 的替代写法</td></tr><tr><td style="text-align:left">xor_eq</td><td style="text-align:left">用作 <code>^=</code> 的替代写法</td></tr></tbody></table><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>C++关键字从C++11开始快速扩张，到C++20标准已经有100个左右了</li><li>C语言关键字发展到现在也有60多个了</li><li>像 <code>xor_eq</code>、<code>or_eq</code> 这些关键字就是对原来的运算符号换了个写法，感觉上没有什么用，只是不用敲特殊符号了</li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/133655454" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>好日子都是自己争取来的~</p><p>2023-10-7 23:34:23</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;源于上一篇中提到了 &lt;code&gt;decltype&lt;/code&gt;是一个关键字，所以去查了现有的关键字列表，其实我对C/C++的关键字还停留在上世纪大概30多个的时代，虽然知道C++加了 &lt;code&gt;auto&lt;/code&gt;、&lt;code&gt;constexpr&lt;/code&gt; 等关键字，但查询过后才发现原来他扩充到了将近100个，而C语言的关键字也扩到了六七十个，有点震惊了。&lt;/p&gt;
    
    </summary>
    
      <category term="C/C++" scheme="http://AlbertGithubHome.github.io/blog/categories/C-C/"/>
    
    
      <category term="C/C++" scheme="http://AlbertGithubHome.github.io/blog/tags/C-C/"/>
    
      <category term="keywords" scheme="http://AlbertGithubHome.github.io/blog/tags/keywords/"/>
    
      <category term="xor_eq" scheme="http://AlbertGithubHome.github.io/blog/tags/xor-eq/"/>
    
      <category term="co_await" scheme="http://AlbertGithubHome.github.io/blog/tags/co-await/"/>
    
  </entry>
  
  <entry>
    <title>linux环境下如果掌控了系统root账户就能对上面安装的MySQL数据为所欲为了吗</title>
    <link href="http://AlbertGithubHome.github.io/blog/2023/10/07/linux%E7%8E%AF%E5%A2%83%E4%B8%8B%E5%A6%82%E6%9E%9C%E6%8E%8C%E6%8E%A7%E4%BA%86%E7%B3%BB%E7%BB%9Froot%E8%B4%A6%E6%88%B7%E5%B0%B1%E8%83%BD%E5%AF%B9%E4%B8%8A%E9%9D%A2%E5%AE%89%E8%A3%85%E7%9A%84MySQL%E6%95%B0%E6%8D%AE%E4%B8%BA%E6%89%80%E6%AC%B2%E4%B8%BA%E4%BA%86%E5%90%97/"/>
    <id>http://AlbertGithubHome.github.io/blog/2023/10/07/linux环境下如果掌控了系统root账户就能对上面安装的MySQL数据为所欲为了吗/</id>
    <published>2023-10-07T12:47:41.000Z</published>
    <updated>2023-10-08T15:06:03.971Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>根据我目前测试的情况来看，这个问题的答案是【确实可以为所欲为】，事情的起因是这样的，一次偶然的机会我发现Ubuntu20.04系统上通过 <code>sudo apt install mysql-server</code> 命令安装的MySQL服务器，使用root账号登录无论输入什么密码都可以成功进入，多次尝试后才知道原来root用户默认没有密码，这可是让我惊呆了，居然还可以这样，为了服务器的安全，我必须给他设置个密码，在不断尝试的过程中引发了标题中的疑问。</p><a id="more"></a><h1 id="修改root密码"><a href="#修改root密码" class="headerlink" title="修改root密码"></a>修改root密码</h1><p>修改MySQL用户root密码在网络上充斥着各种各样的版本，最常见的这种在MySQL8.0中已经不生效了，错误示例如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">user</span> <span class="keyword">SET</span> authentication_string = <span class="keyword">PASSWORD</span>(<span class="string">'iL1jfLqUSfmTECXRi4nO'</span>) <span class="keyword">WHERE</span> <span class="keyword">User</span> = <span class="string">'root'</span>;</span><br></pre></td></tr></table></figure><p>目前测试在MySQL8.0版本中可行的设置root密码的方式为：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">USE</span> mysql;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">USER</span> <span class="string">'root'</span>@<span class="string">'localhost'</span> <span class="keyword">IDENTIFIED</span> <span class="keyword">WITH</span> mysql_native_password <span class="keyword">BY</span> <span class="string">'iL1jfLqUSfmTECXRi4nO'</span>;</span><br><span class="line"><span class="keyword">FLUSH</span> <span class="keyword">PRIVILEGES</span>;</span><br></pre></td></tr></table></figure><h1 id="产生疑问"><a href="#产生疑问" class="headerlink" title="产生疑问"></a>产生疑问</h1><p>root用户的密码是设置好了，这么长的密码估计破解个几年也破解不开，但是我发现安装完毕提示了这样一样配置文件 <code>/etc/mysql/debian.cnf</code>，打开文件内容展示如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># Automatically generated for Debian scripts. DO NOT TOUCH!</span><br><span class="line">[client]</span><br><span class="line">host     = localhost</span><br><span class="line">user     = debian-sys-maint</span><br><span class="line">password = xg9vyvjNly3vUSsm</span><br><span class="line">socket   = /var/run/mysqld/mysqld.sock</span><br><span class="line">[mysql_upgrade]</span><br><span class="line">host     = localhost</span><br><span class="line">user     = debian-sys-maint</span><br><span class="line">password = xg9vyvjNly3vUSsm</span><br><span class="line">socket   = /var/run/mysqld/mysqld.sock</span><br></pre></td></tr></table></figure><p>居然是一个包含了MySQL用户和密码的未加密的文本文件，这不是在大门口的脚垫底下放上了大门的钥匙吗？关键这个debian-sys-maint虽然设计上是用于数据库维护和管理，但权限上与root几乎相同，通常在 Debian 或基于 Debian 的 Linux 发行版比如Ununtu上安装MySQL就会自动生成这个文件，看起来有点不安全啊？</p><p>于是查了相关的处理方法，都说要控制这个文件的权限，只让系统root用户可以访问它，这时我就产生了疑问，这样做安全吗？如果系统root用户被窃取了呢？那是不是完全可以通过这个文件来操控MySQL数据了，答案是很显然的。</p><h1 id="渐渐明白"><a href="#渐渐明白" class="headerlink" title="渐渐明白"></a>渐渐明白</h1><p>虽然说掌握了root用户就可以任意修改MySQL数据让人难以接受，但是换个角度或许就可以释然了，root可是系统里的上帝啊，控制了root用户可以任意执行 <code>rm -rf /*</code>，如果你知道银行卡密码当然就可以从取款机里取钱，对于操作系统也是一样，既然你是root你就掌控了这个系统里的一切。</p><p>即便没有这个<code>/etc/mysql/debian.cnf</code>文件，root用户还可以先关闭MySQL服务，然后通过 <code>sudo mysqld_safe --skip-grant-tables &amp;</code>以跳过授权表的方式启动MySQL，此时允许你在不知道密码的情况下以 root 身份登录 MySQL，这还有什么隐私可言。再换种方式，作为root用户的我从磁盘上把MySQL存储的文件拿到其他MySQL服务器上都是可以的，所以你是防不住root上帝的。</p><p>所以刚刚那个【大门口的脚垫底下放上了大门的钥匙】的比喻不太恰当，应该是<code>/etc/mysql/debian.cnf</code>就像屋里的桌子上摆着的保险柜的钥匙，而你要保证大门的钥匙（root密码）不要轻易被人搞到手，像 <code>--skip-grant-tables</code> 这种看起来很像是后门，或者叫应急开关，实际上它的设计就是为了提供一种紧急的修复机制，用于在丧失所有密码或无法登录到 MySQL 数据库时进行数据库恢复和修复，比如紧急恢复、密码重置、修复数据库权限等等</p><p>这种设计就像是各司其职，我只负责我数据的管理与权限的分配，而用户需要保证系统很牢固，一旦你的系统被攻破我将束手就擒，做的再多也是徒劳。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>MySQL8.0修改密码的方式<code>ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED WITH mysql_native_password BY &#39;xxx&#39;;</code></li><li>文件<code>/etc/mysql/debian.cnf</code>是Debian系列系统上安装MySQL时自动生成的，其中的用户用于用于数据库维护和管理</li><li>如果忘了MySQL中root用户的密码可以通过 <code>sudo mysqld_safe --skip-grant-tables &amp;</code> 启动服务来进行免密登录</li><li>控制了系统的root用户，你就掌控了操作系统的一切</li></ul><center><a href="https://blog.csdn.net/albertsh/article/details/132641641" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>假期归来又看了很多，也不安分了许多，或许只有通过打破常规才能获得额外的收益，否则只能是一直保持饿不死的状态</p><p>2023-10-7 20:47:41</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;根据我目前测试的情况来看，这个问题的答案是【确实可以为所欲为】，事情的起因是这样的，一次偶然的机会我发现Ubuntu20.04系统上通过 &lt;code&gt;sudo apt install mysql-server&lt;/code&gt; 命令安装的MySQL服务器，使用root账号登录无论输入什么密码都可以成功进入，多次尝试后才知道原来root用户默认没有密码，这可是让我惊呆了，居然还可以这样，为了服务器的安全，我必须给他设置个密码，在不断尝试的过程中引发了标题中的疑问。&lt;/p&gt;
    
    </summary>
    
      <category term="linux" scheme="http://AlbertGithubHome.github.io/blog/categories/linux/"/>
    
    
      <category term="linux" scheme="http://AlbertGithubHome.github.io/blog/tags/linux/"/>
    
      <category term="ubuntu" scheme="http://AlbertGithubHome.github.io/blog/tags/ubuntu/"/>
    
      <category term="mysql" scheme="http://AlbertGithubHome.github.io/blog/tags/mysql/"/>
    
      <category term="root" scheme="http://AlbertGithubHome.github.io/blog/tags/root/"/>
    
      <category term="debian-sys-maint" scheme="http://AlbertGithubHome.github.io/blog/tags/debian-sys-maint/"/>
    
      <category term="skip-grant-tables" scheme="http://AlbertGithubHome.github.io/blog/tags/skip-grant-tables/"/>
    
  </entry>
  
  <entry>
    <title>C++中的decltype、std::declval 和 std::decay_t傻傻分不清楚</title>
    <link href="http://AlbertGithubHome.github.io/blog/2023/09/05/C-%E4%B8%AD%E7%9A%84decltype%E3%80%81std-declval-%E5%92%8C-std-decay-t%E5%82%BB%E5%82%BB%E5%88%86%E4%B8%8D%E6%B8%85%E6%A5%9A/"/>
    <id>http://AlbertGithubHome.github.io/blog/2023/09/05/C-中的decltype、std-declval-和-std-decay-t傻傻分不清楚/</id>
    <published>2023-09-05T13:42:25.000Z</published>
    <updated>2023-10-08T15:02:51.293Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在C++中提到推导第一个映入脑海的可能是“模板”，当然有人也可能想到 <code>auto</code>，这些都是和推导相关的语言语法，再比如“完美转发”等等，总是就是他们的类型不用明明白白的写出来，可以利用一种简单的方式来定义，比如 <code>candidates</code> 是一个字符串数组， 如果遍历它我们可以写成 <code>for (auto&amp; skillId : candidates)</code>，而不用将 <code>skillId</code> 变量定义成 <code>const std::string&amp;</code>，这在一定程度上带来了便利，今天的几个东东也是用于推导的，我们一起来看看。</p><a id="more"></a><h1 id="它们是什么"><a href="#它们是什么" class="headerlink" title="它们是什么"></a>它们是什么</h1><p><code>decltype</code>、<code>std::declval</code> 和 <code>std::decay_t</code> 都是 C++ 标准库中的类型相关工具，这些工具在 C++ 编程中提供了强大的类型推导和处理能力，使得代码更加灵活。</p><ul><li><p><code>decltype</code> 是一个关键字，用于从一个表达式中推导出其类型。它通常与表达式一起使用，以便在编译时确定表达式的类型。例如：</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">decltype</span>(x) y = <span class="number">10</span>;  <span class="comment">// y 的类型将被推导为 int</span></span><br></pre></td></tr></table></figure><p> <code>decltype</code> 还可以用于推导函数返回类型，以及在泛型编程中处理模板的类型。</p></li><li><p><code>std::declval</code> 是一个函数模板，用于在不实际调用构造函数的情况下生成一个对象引用，以便在类型推导中使用。通常在需要引用某个类型的对象但实际无法创建该对象的上下文中使用，例如在函数返回类型推导中：</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">auto createAndProcess() -&gt; decltype(std::declval&lt;T&gt;().process()) &#123;</span><br><span class="line">    <span class="comment">// 此处只是用于类型推导，并不会实际创建 T 的对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 在这个例子中，<code>std::declval&lt;T&gt;().process()</code> 用于推导函数的返回类型，但并不会实际调用 <code>process</code> 函数。</p></li><li><p><code>std::decay_t</code> 是一个类型转换工具模板，用于将给定类型的”衰变”后的类型返回。衰变指的是将类型转换为其”自然”形式，即去掉引用、添加 cv 限定符（const 和 volatile）。例如：</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> T1 = <span class="built_in">std</span>::<span class="keyword">decay_t</span>&lt;<span class="keyword">int</span>&amp;&gt;;      <span class="comment">// T1 为 int</span></span><br><span class="line"><span class="keyword">using</span> T2 = <span class="built_in">std</span>::<span class="keyword">decay_t</span>&lt;<span class="keyword">const</span> <span class="keyword">int</span>&gt;; <span class="comment">// T2 为 int</span></span><br><span class="line"><span class="keyword">using</span> T3 = <span class="built_in">std</span>::<span class="keyword">decay_t</span>&lt;<span class="keyword">int</span>[]&gt;;     <span class="comment">// T3 为 int*</span></span><br></pre></td></tr></table></figure><p> <code>std::decay_t</code> 在模板编程中很有用，因为它可以帮助去除类型的多余限定符，使得函数模板的匹配更加精确。</p></li></ul><h1 id="通俗解释"><a href="#通俗解释" class="headerlink" title="通俗解释"></a>通俗解释</h1><p>如果看了上面的例子还是有点迷糊，那我再解释的通俗一点：</p><ul><li><p><code>decltype</code>  读音为 “dee-kluh-type”，就是返回一个变量的类型，比如你有一个对象 <code>obj</code> 想要再定义一个和它相同各类型的变量就可以写成 <code>decltype(obj) newObj;</code></p></li><li><p><code>std::declval</code>  读音为 “standard dee-cl-val”，它能返回类型 T 的右值引用，其实是一个伪实例，不会产生任何临时对象，也不会因为表达式很复杂而发生真实的计算。因为不会真正的进行构造，所以可以实现在元编程时伪构造一个没有定义默认构造函数类，还可以避开纯虚基类不能实例化的问题，说白了它就是假装创建个对象用于推导类型。</p></li><li><p><code>std::decay_t</code> 读音为 “standard dee-kay tee”，有点褪去外表直击内心的意味，就是大家一起褪去花里胡哨的修饰符，获得原始的类型，用于函数模板的匹配更加精确，比如判断类型 <code>T</code>是不是int，<code>if constexpr (std::is_same_v&lt;std::decay_t&lt;T&gt;, int&gt;)</code></p></li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li><code>decltype</code> 是关键字，用于有了值或对象求类型的</li><li><code>std::declval</code> 是函数模板，用于伪造一个对象但不实际构造的</li><li><code>std::decay_t</code> 是类模板，用于去除修饰符获取原始类型的</li><li>没想到<code>decltype</code> 居然是关键字，结果一查发现C++的关键字已经膨胀了，下次总结一下</li></ul><center><a href="https://blog.csdn.net/albertsh/article/details/132549001" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>当身边出现不和谐声音的时候问问自己，是不是你把他们招来的，用实力让他们闭嘴，而不要视图通过语言让他们明白</p><p>2023-9-5 21:42:25</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;在C++中提到推导第一个映入脑海的可能是“模板”，当然有人也可能想到 &lt;code&gt;auto&lt;/code&gt;，这些都是和推导相关的语言语法，再比如“完美转发”等等，总是就是他们的类型不用明明白白的写出来，可以利用一种简单的方式来定义，比如 &lt;code&gt;candidates&lt;/code&gt; 是一个字符串数组， 如果遍历它我们可以写成 &lt;code&gt;for (auto&amp;amp; skillId : candidates)&lt;/code&gt;，而不用将 &lt;code&gt;skillId&lt;/code&gt; 变量定义成 &lt;code&gt;const std::string&amp;amp;&lt;/code&gt;，这在一定程度上带来了便利，今天的几个东东也是用于推导的，我们一起来看看。&lt;/p&gt;
    
    </summary>
    
      <category term="C/C++" scheme="http://AlbertGithubHome.github.io/blog/categories/C-C/"/>
    
    
      <category term="C/C++" scheme="http://AlbertGithubHome.github.io/blog/tags/C-C/"/>
    
      <category term="decltype" scheme="http://AlbertGithubHome.github.io/blog/tags/decltype/"/>
    
      <category term="std::declval" scheme="http://AlbertGithubHome.github.io/blog/tags/std-declval/"/>
    
      <category term="std::decay_t" scheme="http://AlbertGithubHome.github.io/blog/tags/std-decay-t/"/>
    
  </entry>
  
  <entry>
    <title>C++定义一个返回值为拥有3个元素的 char 数组引用的函数</title>
    <link href="http://AlbertGithubHome.github.io/blog/2023/08/28/C-%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA%E8%BF%94%E5%9B%9E%E5%80%BC%E4%B8%BA%E6%8B%A5%E6%9C%893%E4%B8%AA%E5%85%83%E7%B4%A0%E7%9A%84-char-%E6%95%B0%E7%BB%84%E5%BC%95%E7%94%A8%E7%9A%84%E5%87%BD%E6%95%B0/"/>
    <id>http://AlbertGithubHome.github.io/blog/2023/08/28/C-定义一个返回值为拥有3个元素的-char-数组引用的函数/</id>
    <published>2023-08-28T14:21:41.000Z</published>
    <updated>2023-09-03T12:57:59.425Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>编程语言最怕细节，怼着一个点扣能让你怀疑人生，今天就碰到这么一个问题，“C++定义一个返回值为拥有3个元素的 char 数组引用的函数”，不敢说99%的人不会，但我觉得应该有80%的人写不出来吧，要不你来试试。</p><a id="more"></a><h1 id="分解需求"><a href="#分解需求" class="headerlink" title="分解需求"></a>分解需求</h1><p>首先得能看出来这是要求定义一个函数，如果这一步就错了，那就没必要往后走了，函数有的参数没有要求，但是返回值得是一个引用，这个引用的原始类型应该为一个拥有3个元素的char类型数组，难道要这样写？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>&amp; [<span class="number">3</span>] func()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>试试吧，肯定编不过的，要是这么容易就哪能让人死去活来，直接给答案了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line">const char (&amp;getCharArray())[3] &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> charArray[<span class="number">3</span>] = &#123;<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'X'</span>&#125;;</span><br><span class="line">    <span class="keyword">return</span> charArray;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    const char (&amp;result)[3] = getCharArray();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> c : result) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; c &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="举一反三"><a href="#举一反三" class="headerlink" title="举一反三"></a>举一反三</h1><p>学习要学会举一反三，把题目中的“引用”换成“指针”，再试一下，依葫芦画瓢还是很容易的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> (*getCharArrayPointer())[<span class="number">3</span>] &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> charArray[<span class="number">3</span>] = &#123;<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'J'</span>&#125;;</span><br><span class="line">    <span class="keyword">return</span> &amp;charArray;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> (*result)[<span class="number">3</span>] = getCharArrayPointer();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; (*result)[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>仿佛这也不是我们常常见到的形式，对于指针作为返回值，我们常见到的应该是下面这种</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">getCharArrayPointer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> charArray[<span class="number">10</span>] = &#123;<span class="string">'H'</span>, <span class="string">'e'</span>, <span class="string">'l'</span>, <span class="string">'l'</span>, <span class="string">'o'</span>, <span class="string">' '</span>, <span class="string">'W'</span>, <span class="string">'o'</span>, <span class="string">'r'</span>, <span class="string">'l'</span>&#125;;</span><br><span class="line">    <span class="keyword">return</span> charArray;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span>* result = getCharArrayPointer();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; result[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>他们有什么区别呢？我们从定义层面来对比一下：</p><h1 id="进行对比"><a href="#进行对比" class="headerlink" title="进行对比"></a>进行对比</h1><ul><li><figure class="highlight plain"><figcaption><span>char (&result)[3] </span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  - `result` 是一个引用类型变量，被引用的类型为 `char[3]`</span><br><span class="line">  - `sizeof(result)` == 3</span><br><span class="line">- ```char (*result)[3] = getCharArrayPointer();</span><br></pre></td></tr></table></figure><ul><li><code>result</code> 是一个指针类型变量，指向的类型的类型为 <code>char[3]</code></li><li><code>sizeof(result)</code> == 8</li><li><code>result++</code> 先后移动24个字节=8*3</li></ul></li><li><code>char* result = getCharArrayPointer();</code><ul><li><code>result</code> 是一个指针类型变量，被引用的类型为 <code>char</code></li><li><code>sizeof(result)</code> == 8</li><li><code>result++</code> 先后移动8个字节=8*1</li></ul></li></ul><p>有了上面的对比就可以根据区别来选择定义什么样的返回值，使用引用类型能取到被引用变量的原始大小，使用指针要注意移动的步长。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>定义一个返回定长数组引用的函数 <code>const char (&amp;getCharArray())[3] { //... }</code></li><li>定义一个返回定长数组指针的函数 <code>const char (*getCharArray())[3] { //... }</code></li><li>引用不需要内存分配和释放，因为它只是目标对象的别名（存疑，在绝大多数编译器中，引用在底层是通过指针来实现的，但GPT嘴硬说不需要，表示需要继续探索）</li></ul><blockquote><p>引用在底层通过指针实现时，并不需要额外的内存分配。引用被设计为变量的别名，它并不占用额外的内存空间。引用在编译器生成的汇编代码中，会被处理为指向原始对象的指针，但是这个指针对于用户来说是透明的，不需要分配额外的内存来存储引用本身。<br>引用只是目标对象的别名，与指针不同，它没有自己的内存存储空间。因此，无论引用在底层是通过指针实现还是其他方式实现，都不会导致额外的内存分配。这也是为什么引用在使用上更接近于对变量的直接访问。<br>需要注意的是，尽管引用不需要额外的内存分配，但指针本身需要存储指向对象的地址，因此指针会占用一定的内存空间。这也是引用和指针之间的一个重要区别。</p></blockquote><center><a href="https://blog.csdn.net/albertsh/article/details/132484006" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>内练一口气，外练筋骨皮</p><p>2023-8-28 22:17:27</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;编程语言最怕细节，怼着一个点扣能让你怀疑人生，今天就碰到这么一个问题，“C++定义一个返回值为拥有3个元素的 char 数组引用的函数”，不敢说99%的人不会，但我觉得应该有80%的人写不出来吧，要不你来试试。&lt;/p&gt;
    
    </summary>
    
      <category term="C/C++" scheme="http://AlbertGithubHome.github.io/blog/categories/C-C/"/>
    
    
      <category term="C/C++" scheme="http://AlbertGithubHome.github.io/blog/tags/C-C/"/>
    
      <category term="开发语言" scheme="http://AlbertGithubHome.github.io/blog/tags/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/"/>
    
      <category term="指针" scheme="http://AlbertGithubHome.github.io/blog/tags/%E6%8C%87%E9%92%88/"/>
    
      <category term="引用" scheme="http://AlbertGithubHome.github.io/blog/tags/%E5%BC%95%E7%94%A8/"/>
    
      <category term="函数定义" scheme="http://AlbertGithubHome.github.io/blog/tags/%E5%87%BD%E6%95%B0%E5%AE%9A%E4%B9%89/"/>
    
  </entry>
  
</feed>
