<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Albert World</title>
  <icon>https://www.gravatar.com/avatar/8ccc6291d5bfd34e7aaf601c4ebec7e1</icon>
  
  <link href="/blog/atom.xml" rel="self"/>
  
  <link href="http://AlbertGithubHome.github.io/blog/"/>
  <updated>2020-05-17T03:22:00.538Z</updated>
  <id>http://AlbertGithubHome.github.io/blog/</id>
  
  <author>
    <name>Albert Shi</name>
    <email>347070901@qq.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>使用c++filt命令还原C++编译后的函数名</title>
    <link href="http://AlbertGithubHome.github.io/blog/2020/05/16/%E4%BD%BF%E7%94%A8c-filt%E5%91%BD%E4%BB%A4%E8%BF%98%E5%8E%9FC-%E7%BC%96%E8%AF%91%E5%90%8E%E7%9A%84%E5%87%BD%E6%95%B0%E5%90%8D/"/>
    <id>http://AlbertGithubHome.github.io/blog/2020/05/16/使用c-filt命令还原C-编译后的函数名/</id>
    <published>2020-05-16T13:22:43.000Z</published>
    <updated>2020-05-17T03:22:00.538Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这个命令功能单一，但是非常强大，可以用来还原C++编译后的函数名，为什么C++的函数名需要单独的命令来还原，因为他们看起来都是这样 <code>_ZNK4Json5ValueixEPKc</code>、这样 <code>_Z41__static_initialization_and_destruction_0ii</code> 或者这样的 <code>_ZN6apsara5pangu15ScopedChunkInfoINS0_12RafChunkInfoEED1Ev</code>，仅通过这一串字母很难知道原函数的名字是什么，参数类型就更难分析了，实际上C++在编译函数时有一套命名函数的规则，每种参数使用什么字母表示都是有约定的，但是通过学习这些约定来还原函数太麻烦了，还好有人编写了 <code>c++filt</code> 命令可以让我们直接得到编译前的函数名，真好……</p><h1 id="C-编译后的函数名"><a href="#C-编译后的函数名" class="headerlink" title="C++编译后的函数名"></a>C++编译后的函数名</h1><p><code>C++</code> 编译后的函数名字非常古怪，相比而言 <code>C</code> 语言编译后的函数看起来就正常许多了，<code>extern &quot;C&quot;</code>、函数重载、<code>name mangling</code> 这些知识点都与 <code>C++</code> 这个奇怪的函数名有些关系，<code>extern &quot;C&quot;</code> 的作用简而言之就是告诉编译器和链接器被“我”修饰的变量和函数需要按照 <code>C</code> 语言方式进行编译和链接，这样做是由于 <code>C++</code> 支持函数重载，而 <code>C</code> 语言不支持，结果导致函数被 <code>C++</code> 编译后在符号库中的名字和被 <code>C</code>语言编译后的名字是不一样的，程序编译和连接就会出现问题，此类问题一般出现在 <code>C++</code> 代码调用 <code>C</code> 语言写的库函数的时候。</p><p>而 <code>name mangling</code> 就是实现 <code>C++</code> 函数重载的一种技术或者叫做方式，要求同名的 <code>C++</code> 函数参数个数不同或参数类型不同，如果只有返回值类型不同，那么两个函数被认为是相同的函数，无法成功通过编译。接下来我们就来看几个例子，看看 <code>C++</code> 编译后的函数名有什么变化。</p><h2 id="C-和C语言编译后的函数名对比"><a href="#C-和C语言编译后的函数名对比" class="headerlink" title="C++和C语言编译后的函数名对比"></a>C++和C语言编译后的函数名对比</h2><p>我们来写一段相同的代码，分别使用 <code>gcc</code> 和 <code>g++</code> 进行编译，从代码到可执行文件需要经历“预处理、编译、汇编、链接”4个步骤，接下来为了看到编译后函数名的不同，我们只进行前两步，生成汇编代码，再来比较不同。</p><h3 id="gcc编译simple-c文件"><a href="#gcc编译simple-c文件" class="headerlink" title="gcc编译simple.c文件"></a>gcc编译simple.c文件</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// simple.c</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">myadd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">110</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">119</span>;</span><br><span class="line">    <span class="keyword">int</span> c = myadd(a, b);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>gcc simple.c -S</code> 生成汇编代码文件simple.s内容</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">    .file   <span class="string">"simple.c"</span></span><br><span class="line">    .text</span><br><span class="line">    .globl  myadd</span><br><span class="line">    .type   myadd, @function</span><br><span class="line">myadd:</span><br><span class="line">.LFB0:</span><br><span class="line">    .cfi_startproc</span><br><span class="line">    pushq   %rbp</span><br><span class="line">    .cfi_def_cfa_offset <span class="number">16</span></span><br><span class="line">    .cfi_offset <span class="number">6</span>, <span class="number">-16</span></span><br><span class="line">    movq    %rsp, %rbp</span><br><span class="line">    .cfi_def_cfa_register <span class="number">6</span></span><br><span class="line">    movl    %edi, <span class="number">-4</span>(%rbp)</span><br><span class="line">    movl    %esi, <span class="number">-8</span>(%rbp)</span><br><span class="line">    movl    <span class="number">-4</span>(%rbp), %edx</span><br><span class="line">    movl    <span class="number">-8</span>(%rbp), %eax</span><br><span class="line">    addl    %edx, %eax</span><br><span class="line">    popq    %rbp</span><br><span class="line">    .cfi_def_cfa <span class="number">7</span>, <span class="number">8</span></span><br><span class="line">    ret</span><br><span class="line">    .cfi_endproc</span><br><span class="line">.LFE0:</span><br><span class="line">    .size   myadd, .-myadd</span><br><span class="line">    .globl  main</span><br><span class="line">    .type   main, @function</span><br><span class="line">main:</span><br><span class="line">.LFB1:</span><br><span class="line">    .cfi_startproc</span><br><span class="line">    pushq   %rbp</span><br><span class="line">    .cfi_def_cfa_offset <span class="number">16</span></span><br><span class="line">    .cfi_offset <span class="number">6</span>, <span class="number">-16</span></span><br><span class="line">    movq    %rsp, %rbp</span><br><span class="line">    .cfi_def_cfa_register <span class="number">6</span></span><br><span class="line">    subq    $<span class="number">16</span>, %rsp</span><br><span class="line">    movl    $<span class="number">110</span>, <span class="number">-12</span>(%rbp)</span><br><span class="line">    movl    $<span class="number">119</span>, <span class="number">-8</span>(%rbp)</span><br><span class="line">    movl    <span class="number">-8</span>(%rbp), %edx</span><br><span class="line">    movl    <span class="number">-12</span>(%rbp), %eax</span><br><span class="line">    movl    %edx, %esi</span><br><span class="line">    movl    %eax, %edi</span><br><span class="line">    call    myadd</span><br><span class="line">    movl    %eax, <span class="number">-4</span>(%rbp)</span><br><span class="line">    movl    $<span class="number">0</span>, %eax</span><br><span class="line">    leave</span><br><span class="line">    .cfi_def_cfa <span class="number">7</span>, <span class="number">8</span></span><br><span class="line">    ret</span><br><span class="line">    .cfi_endproc</span><br><span class="line">.LFE1:</span><br><span class="line">    .size   main, .-main</span><br><span class="line">    .ident  <span class="string">"GCC: (Ubuntu 5.4.0-6ubuntu1~16.04.12) 5.4.0 20160609"</span></span><br><span class="line">    .section    .note.GNU-<span class="built_in">stack</span>,<span class="string">""</span>,@progbits</span><br></pre></td></tr></table></figure><h3 id="g-编译simple-cpp文件"><a href="#g-编译simple-cpp文件" class="headerlink" title="g++编译simple.cpp文件"></a>g++编译simple.cpp文件</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// simple.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">myadd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">110</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">119</span>;</span><br><span class="line">    <span class="keyword">int</span> c = myadd(a, b);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>g++ simple.cpp -S</code> 生成汇编代码文件simple.s内容</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">    .file   <span class="string">"simple.cpp"</span></span><br><span class="line">    .text</span><br><span class="line">    .globl  _Z5myaddii</span><br><span class="line">    .type   _Z5myaddii, @function</span><br><span class="line">_Z5myaddii:</span><br><span class="line">.LFB0:</span><br><span class="line">    .cfi_startproc</span><br><span class="line">    pushq   %rbp</span><br><span class="line">    .cfi_def_cfa_offset <span class="number">16</span></span><br><span class="line">    .cfi_offset <span class="number">6</span>, <span class="number">-16</span></span><br><span class="line">    movq    %rsp, %rbp</span><br><span class="line">    .cfi_def_cfa_register <span class="number">6</span></span><br><span class="line">    movl    %edi, <span class="number">-20</span>(%rbp)</span><br><span class="line">    movl    %esi, <span class="number">-24</span>(%rbp)</span><br><span class="line">    movl    $<span class="number">0</span>, <span class="number">-4</span>(%rbp)</span><br><span class="line">    movl    <span class="number">-20</span>(%rbp), %edx</span><br><span class="line">    movl    <span class="number">-24</span>(%rbp), %eax</span><br><span class="line">    addl    %edx, %eax</span><br><span class="line">    movl    %eax, <span class="number">-4</span>(%rbp)</span><br><span class="line">    movl    <span class="number">-4</span>(%rbp), %eax</span><br><span class="line">    popq    %rbp</span><br><span class="line">    .cfi_def_cfa <span class="number">7</span>, <span class="number">8</span></span><br><span class="line">    ret</span><br><span class="line">    .cfi_endproc</span><br><span class="line">.LFE0:</span><br><span class="line">    .size   _Z5myaddii, .-_Z5myaddii</span><br><span class="line">    .globl  main</span><br><span class="line">    .type   main, @function</span><br><span class="line">main:</span><br><span class="line">.LFB1:</span><br><span class="line">    .cfi_startproc</span><br><span class="line">    pushq   %rbp</span><br><span class="line">    .cfi_def_cfa_offset <span class="number">16</span></span><br><span class="line">    .cfi_offset <span class="number">6</span>, <span class="number">-16</span></span><br><span class="line">    movq    %rsp, %rbp</span><br><span class="line">    .cfi_def_cfa_register <span class="number">6</span></span><br><span class="line">    subq    $<span class="number">16</span>, %rsp</span><br><span class="line">    movl    $<span class="number">110</span>, <span class="number">-12</span>(%rbp)</span><br><span class="line">    movl    $<span class="number">119</span>, <span class="number">-8</span>(%rbp)</span><br><span class="line">    movl    $<span class="number">0</span>, <span class="number">-4</span>(%rbp)</span><br><span class="line">    movl    <span class="number">-8</span>(%rbp), %edx</span><br><span class="line">    movl    <span class="number">-12</span>(%rbp), %eax</span><br><span class="line">    movl    %edx, %esi</span><br><span class="line">    movl    %eax, %edi</span><br><span class="line">    call    _Z5myaddii</span><br><span class="line">    movl    %eax, <span class="number">-4</span>(%rbp)</span><br><span class="line">    movl    $<span class="number">0</span>, %eax</span><br><span class="line">    leave</span><br><span class="line">    .cfi_def_cfa <span class="number">7</span>, <span class="number">8</span></span><br><span class="line">    ret</span><br><span class="line">    .cfi_endproc</span><br><span class="line">.LFE1:</span><br><span class="line">    .size   main, .-main</span><br><span class="line">    .ident  <span class="string">"GCC: (Ubuntu 5.4.0-6ubuntu1~16.04.12) 5.4.0 20160609"</span></span><br><span class="line">    .section    .note.GNU-<span class="built_in">stack</span>,<span class="string">""</span>,@progbits</span><br></pre></td></tr></table></figure><p>虽然只有几行代码，可是生成汇编文件之后变成了50多行，我们只需要关注 <code>myadd()</code> 这个函数编译之后变成了什么就可以了，汇编代码虽然不好读，但是查找一个函数名应该没问题的，对照着上面的代码我们发现，<code>myadd()</code> 这个函数通过 <code>gcc</code> 编译之后的函数名还是 <code>myadd</code>，而通过 <code>g++</code> 编译之后的函数名变成了 <code>_Z5myaddii</code>，可以明显感觉到最后的两个字母 <code>i</code> 代表的是参数 <code>int</code>，使用 <code>c++filt</code> 命令还原如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ c++filt _Z5myaddii</span><br><span class="line">myadd(int, int)</span><br></pre></td></tr></table></figure><h2 id="C-函数重载编译后的函数名对比"><a href="#C-函数重载编译后的函数名对比" class="headerlink" title="C++函数重载编译后的函数名对比"></a>C++函数重载编译后的函数名对比</h2><p>我们还是在刚才的代码的基础上增加一个参数类型不同的 <code>myadd</code> 函数，修改后的代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">myadd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">myadd</span><span class="params">(<span class="keyword">float</span> a, <span class="keyword">float</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c = myadd(<span class="number">110</span>, <span class="number">119</span>);</span><br><span class="line">    <span class="keyword">float</span> d = myadd(<span class="number">52.0f</span>, <span class="number">13.14f</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>g++ simple.cpp -S</code> 生成汇编代码文件simple.s内容为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">    .file   <span class="string">"simple.cpp"</span></span><br><span class="line">    .text</span><br><span class="line">    .globl  _Z5myaddii</span><br><span class="line">    .type   _Z5myaddii, @function</span><br><span class="line">_Z5myaddii:</span><br><span class="line">.LFB0:</span><br><span class="line">    .cfi_startproc</span><br><span class="line">    pushq   %rbp</span><br><span class="line">    .cfi_def_cfa_offset <span class="number">16</span></span><br><span class="line">    .cfi_offset <span class="number">6</span>, <span class="number">-16</span></span><br><span class="line">    movq    %rsp, %rbp</span><br><span class="line">    .cfi_def_cfa_register <span class="number">6</span></span><br><span class="line">    movl    %edi, <span class="number">-4</span>(%rbp)</span><br><span class="line">    movl    %esi, <span class="number">-8</span>(%rbp)</span><br><span class="line">    movl    <span class="number">-4</span>(%rbp), %edx</span><br><span class="line">    movl    <span class="number">-8</span>(%rbp), %eax</span><br><span class="line">    addl    %edx, %eax</span><br><span class="line">    popq    %rbp</span><br><span class="line">    .cfi_def_cfa <span class="number">7</span>, <span class="number">8</span></span><br><span class="line">    ret</span><br><span class="line">    .cfi_endproc</span><br><span class="line">.LFE0:</span><br><span class="line">    .size   _Z5myaddii, .-_Z5myaddii</span><br><span class="line">    .globl  _Z5myaddff</span><br><span class="line">    .type   _Z5myaddff, @function</span><br><span class="line">_Z5myaddff:</span><br><span class="line">.LFB1:</span><br><span class="line">    .cfi_startproc</span><br><span class="line">    pushq   %rbp</span><br><span class="line">    .cfi_def_cfa_offset <span class="number">16</span></span><br><span class="line">    .cfi_offset <span class="number">6</span>, <span class="number">-16</span></span><br><span class="line">    movq    %rsp, %rbp</span><br><span class="line">    .cfi_def_cfa_register <span class="number">6</span></span><br><span class="line">    movss   %xmm0, <span class="number">-4</span>(%rbp)</span><br><span class="line">    movss   %xmm1, <span class="number">-8</span>(%rbp)</span><br><span class="line">    movss   <span class="number">-4</span>(%rbp), %xmm0</span><br><span class="line">    addss   <span class="number">-8</span>(%rbp), %xmm0</span><br><span class="line">    popq    %rbp</span><br><span class="line">    .cfi_def_cfa <span class="number">7</span>, <span class="number">8</span></span><br><span class="line">    ret</span><br><span class="line">    .cfi_endproc</span><br><span class="line">.LFE1:</span><br><span class="line">    .size   _Z5myaddff, .-_Z5myaddff</span><br><span class="line">    .globl  main</span><br><span class="line">    .type   main, @function</span><br><span class="line">main:</span><br><span class="line">.LFB2:</span><br><span class="line">    .cfi_startproc</span><br><span class="line">    pushq   %rbp</span><br><span class="line">    .cfi_def_cfa_offset <span class="number">16</span></span><br><span class="line">    .cfi_offset <span class="number">6</span>, <span class="number">-16</span></span><br><span class="line">    movq    %rsp, %rbp</span><br><span class="line">    .cfi_def_cfa_register <span class="number">6</span></span><br><span class="line">    subq    $<span class="number">16</span>, %rsp</span><br><span class="line">    movl    $<span class="number">119</span>, %esi</span><br><span class="line">    movl    $<span class="number">110</span>, %edi</span><br><span class="line">    call    _Z5myaddii</span><br><span class="line">    movl    %eax, <span class="number">-8</span>(%rbp)</span><br><span class="line">    movss   .LC0(%rip), %xmm1</span><br><span class="line">    movss   .LC1(%rip), %xmm0</span><br><span class="line">    call    _Z5myaddff</span><br><span class="line">    movd    %xmm0, %eax</span><br><span class="line">    movl    %eax, <span class="number">-4</span>(%rbp)</span><br><span class="line">    movl    $<span class="number">0</span>, %eax</span><br><span class="line">    leave</span><br><span class="line">    .cfi_def_cfa <span class="number">7</span>, <span class="number">8</span></span><br><span class="line">    ret</span><br><span class="line">    .cfi_endproc</span><br><span class="line">.LFE2:</span><br><span class="line">    .size   main, .-main</span><br><span class="line">    .section    .rodata</span><br><span class="line">    .align <span class="number">4</span></span><br><span class="line">.LC0:</span><br><span class="line">    .<span class="keyword">long</span>   <span class="number">1095908721</span></span><br><span class="line">    .align <span class="number">4</span></span><br><span class="line">.LC1:</span><br><span class="line">    .<span class="keyword">long</span>   <span class="number">1112539136</span></span><br><span class="line">    .ident  <span class="string">"GCC: (Ubuntu 5.4.0-6ubuntu1~16.04.12) 5.4.0 20160609"</span></span><br><span class="line">    .section    .note.GNU-<span class="built_in">stack</span>,<span class="string">""</span>,@progbits</span><br></pre></td></tr></table></figure><p>这次一共3个函数，生成的汇编代码更长，但是我们一眼就能看见汇编代码中包含 <code>_Z5myaddii</code> 和 <code>_Z5myaddff</code> 两个函数，这就是函数重载的产物，两个参数类型不同的同名函数编译之后生成了不同的名字，<code>_Z5myaddff</code> 函数末尾的两个 <code>f</code> 应该指的就是参数类型 <code>float</code>。</p><h1 id="使用c-filt定位问题示例"><a href="#使用c-filt定位问题示例" class="headerlink" title="使用c++filt定位问题示例"></a>使用c++filt定位问题示例</h1><p>c++filt的作用就是还原函数名字，它可以帮我们查找动态链接库中缺少的函数，还原崩溃堆栈中一大串的函数名字母等等，下面来看一个崩溃堆栈的例子，代码内容尽量简写，只为了说明问题，现实情况可能要复杂的多。</p><!-- ldd -r test.so --><p>首先定义一个打印函数堆栈的函数，参考之前的总结<a href="https://blog.csdn.net/albertsh/article/details/100594143" target="_blank" rel="noopener">《linux环境下C++代码打印函数堆栈调用情况》</a>，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;execinfo.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_stack</span><span class="params">(<span class="keyword">int</span> nSignal)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> MAX_STACK_FRAMES = <span class="number">12</span>;</span><br><span class="line">    <span class="keyword">void</span> *pStack[MAX_STACK_FRAMES];</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> szStackInfo[<span class="number">1024</span> * MAX_STACK_FRAMES];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> ** pStackList = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> frames = backtrace(pStack, MAX_STACK_FRAMES);</span><br><span class="line">    pStackList = backtrace_symbols(pStack, frames);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == pStackList)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">strcpy</span>(szStackInfo, <span class="string">"stack traceback:\n"</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; frames; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">NULL</span> == pStackList[i])</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">strncat</span>(szStackInfo, pStackList[i], <span class="number">1024</span>);</span><br><span class="line">        <span class="built_in">strcat</span>(szStackInfo, <span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; szStackInfo; <span class="comment">// 输出到控制台，也可以打印到日志文件中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再写一段隐藏着崩溃问题的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CTest</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span>&amp; <span class="title">get_string</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> s;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set_string</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; str)</span> </span>&#123;s = str;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> s;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">float</span> z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *p = <span class="literal">nullptr</span>;</span><br><span class="line">    *p = <span class="number">110</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; z;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CTest* pTest = <span class="keyword">new</span> CTest();</span><br><span class="line">    pTest-&gt;set_string(<span class="string">"20200517"</span>);</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; s = pTest-&gt;get_string();</span><br><span class="line">    <span class="keyword">delete</span> pTest;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="string">"20200517"</span>) foo(<span class="number">13.14</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> s = <span class="built_in">std</span>::to_string(a) + <span class="built_in">std</span>::to_string(b);</span><br><span class="line">    test(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    signal(SIGSEGV, show_stack);</span><br><span class="line">    func(<span class="number">250</span>, <span class="number">520</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译运行，果然崩溃了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ g++ simple.cpp --std=c++11</span><br><span class="line">$ ./a.out</span><br><span class="line">stack traceback:</span><br><span class="line">./a.out() [0x401aff]</span><br><span class="line">/lib/x86_64-linux-gnu/libc.so.6(+0x354b0) [0x7fd5f98b54b0]</span><br><span class="line">/lib/x86_64-linux-gnu/libc.so.6(+0x16eff6) [0x7fd5f99eeff6]</span><br><span class="line">/usr/lib/x86_64-linux-gnu/libstdc++.so.6(_ZNKSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE7compareEPKc+0x3a) [0x7fd5f9f9145a]</span><br><span class="line">./a.out() [0x4022b6]</span><br><span class="line">./a.out() [0x401d30]</span><br><span class="line">./a.out() [0x401e27]</span><br><span class="line">./a.out() [0x401ed8]</span><br><span class="line">/lib/x86_64-linux-gnu/libc.so.6(__libc_start_main+0xf0) [0x7fd5f98a0830]</span><br><span class="line">./a.out() [0x4019f9]</span><br></pre></td></tr></table></figure><p>这时崩溃的堆栈中发现了一个特别长的函数 <code>_ZNKSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE7compareEPKc</code>，使用 <code>c++filt</code> 命令来还原函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ c++filt _ZNKSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE7compareEPKc</span><br><span class="line"><span class="built_in">std</span>::__cxx11::basic_string&lt;<span class="keyword">char</span>, <span class="built_in">std</span>::char_traits&lt;<span class="keyword">char</span>&gt;, <span class="built_in">std</span>::allocator&lt;<span class="keyword">char</span>&gt; &gt;::compare(<span class="keyword">char</span> <span class="keyword">const</span>*) <span class="keyword">const</span></span><br></pre></td></tr></table></figure><p>从函数名来看是一个与字符串相关的 <code>compare</code> 函数，查看代码发现是 <code>s == &quot;20200517&quot;</code> 这一句的问题，所以说能确切的知道函数名对我们查找问题来说还是挺有帮助的。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li><code>c++filt</code> 命令可以还原 <code>C++</code> 为实现函数重载采用 <code>name mangling</code> 搞出来的奇奇怪怪的函数名</li><li>注册信号回调函数方式：<code>signal(SIGSEGV, show_stack);</code>，<code>SIGSEGV</code>代表无效的内存引用</li><li>注意 <code>C</code> 语言和 <code>C++</code> 在编译后函数命名方式的不同，<code>C</code> 语言不支持严格意义的重载，C++支持</li></ul><hr><blockquote><p>阳光、空气、水，这些真的是好东西，当你真的快要失去它们才意识的到的话就有些晚了…</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;这个命令功能单一，但是非常强大，可以用来还原C++编译后的函数名，为什么C++的函数名需要单独的命令来还原，因为他们看起来都是这样 &lt;cod
      
    
    </summary>
    
      <category term="C/C++" scheme="http://AlbertGithubHome.github.io/blog/categories/C-C/"/>
    
    
      <category term="C/C++" scheme="http://AlbertGithubHome.github.io/blog/tags/C-C/"/>
    
      <category term="linux" scheme="http://AlbertGithubHome.github.io/blog/tags/linux/"/>
    
      <category term="工具" scheme="http://AlbertGithubHome.github.io/blog/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="c++filt" scheme="http://AlbertGithubHome.github.io/blog/tags/c-filt/"/>
    
  </entry>
  
  <entry>
    <title>汇编指令入门级整理</title>
    <link href="http://AlbertGithubHome.github.io/blog/2020/05/09/%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4%E5%85%A5%E9%97%A8%E7%BA%A7%E6%95%B4%E7%90%86/"/>
    <id>http://AlbertGithubHome.github.io/blog/2020/05/09/汇编指令入门级整理/</id>
    <published>2020-05-08T16:00:11.000Z</published>
    <updated>2020-05-10T12:42:32.561Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我们大都是被高级语言惯坏了的一代，源源不断的新特性正在逐步添加到各类高级语言之中，汇编作为最接近机器指令的低级语言，已经很少被直接拿来写程序了，不过我还真的遇到了一个，那是之前的一个同事，因为在写代码时遇到了成员函数权限及可见性的问题，导致他无法正确调用想执行的函数，结果他就开始在 <code>C++</code> 代码里嵌入汇编了，绕过了种种限制终于如愿以偿，但是读代码的我们傻眼了…</p><a id="more"></a><p>因为项目是跨平台的，代码推送的 Linux 上编译的时候他才发现，汇编代码的语法在 Linux 和 Windows 上居然是不一样的，结果他又用一个判断平台的宏定义“完美”的解决了，最终这些代码肯定是重写了啊，因为可读性太差了，最近在学习左值、右值、左引用和右引用的时候，总是有人用程序编译生成的中间汇编代码来解释问题，看得我迷迷糊糊，所以决定熟悉一下简单的汇编指令，边学习边记录，方便今后忘记了可以直接拿来复习。</p><h1 id="什么是汇编语言"><a href="#什么是汇编语言" class="headerlink" title="什么是汇编语言"></a>什么是汇编语言</h1><p>汇编语言是最接近机器语言的编程语言，引用百科中的一段话解释为：</p><blockquote><p>汇编语言（assembly language）是一种用于电子计算机、微处理器、微控制器或其他可编程器件的低级语言，亦称为符号语言。在汇编语言中，用助记符代替机器指令的操作码，用地址符号或标号代替指令或操作数的地址。汇编语言又被称为第二代计算机语言。</p></blockquote><h2 id="汇编语言产生的原因"><a href="#汇编语言产生的原因" class="headerlink" title="汇编语言产生的原因"></a>汇编语言产生的原因</h2><p>对于绝大多数人来说，二进制程序是不可读的，当然有能人可以读，比如第一代程序员，但这类人快灭绝了，直接看二进制不容易看出来究竟做了什么事情，比如最简单的加法指令二进制表示为 <code>00000011</code>，如果它混在一大串01字符串中就很难把它找出来，所以汇编语言主要就是为了解决二进制编码的可读性问题。</p><h2 id="汇编与二进制的关系"><a href="#汇编与二进制的关系" class="headerlink" title="汇编与二进制的关系"></a>汇编与二进制的关系</h2><p>换句话来说，汇编语言就是把给机器看的二进制编码翻译成人话，汇编指令是机器指令的助记符，与机器指令是一一对应的关系，是一种便于阅读和记忆的书写格式。有效地解决了机器指令编写程序难度大的问题，并且使用编译器，可以很方便的把汇编程序转译成机器指令程序，比如之前提到的 <code>00000011</code> 加法指令，对应的汇编指令是 <code>ADD</code>，在调用汇编器时就会把 <code>ADD</code> 翻译成 <code>00000011</code>。</p><h1 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h1><p>说到汇编指令不得不提到寄存器，寄存器本身是用来存数据的，因为 <code>CPU</code> 本身只负责逻辑运算，数据需要单独储存在其他的地方，但是对于不熟悉寄存器的人来说会有疑惑，数据不是存在硬盘上吗？或者说数据不是存在内存中吗？这些想法都没错，那么寄存器是用来做什么的呢？</p><h2 id="寄存器作用"><a href="#寄存器作用" class="headerlink" title="寄存器作用"></a>寄存器作用</h2><p>其实硬盘、内存都是用来存储数据的，但是 <code>CPU</code> 的运算速度远高于内存的读写速度，更不用说从硬盘上取数据了，所以为了避免被拖慢速度影响效率，<code>CPU</code> 都自带一级缓存和二级缓存，一些 <code>CPU</code> 甚至增加了三级缓存，从这些缓存中读写数据要比内存快很多，但是还是无法使用飞速运转的 <code>CPU</code>，所以才会有寄存器的存在。</p><p>寄存器不是后来增加的，在最初的计算中就已经设计出来，相比而言，多级缓存出现的更晚一些，通常那些最频繁读写的数据都会被放在寄存器里面，<code>CPU</code> 优先读写寄存器，再通过寄存器、缓存跟内存来交换数据，达到缓冲的目的，因为可以通过名称访问寄存器，这样访问速度是最快的，因此也被称为零级缓存。</p><h2 id="存取速度比较"><a href="#存取速度比较" class="headerlink" title="存取速度比较"></a>存取速度比较</h2><p>通过上面的叙述我们可以知道存取速度从高到低分别是: <code>寄存器 &gt; 1级缓存 &gt; 2级缓存 &gt; 3级缓存 &gt; 内存 &gt; 硬盘</code>，关于它们的存取速度，举个例子很容易就能明白了，比如我们做菜（CPU工作）时，取手中（寄存器）正拿着的肉和蔬菜肯定是最快的，如果没有就需要把案板上（1级缓存）处理好的菜拿过来，如果案板上没有就在更远一点的洗菜池（2级缓存）中找一找，还没找到的话就要到冰箱（3级缓存）中看一看了，这时发现家里真没有，那去楼下的菜店（内存）去买点吧，转了一圈发现没有想要的，最后还是开车去农贸市场（硬盘）买吧。</p><p>通过上面这个例子应该能明白它们的速度关系了，既然缓存这么快，为什么不用缓存代替内存，或者将2、3级缓存都换成1级缓存呢？这里边有一个成本问题，速度越快对应着价格越高，如果你买过机械硬盘和固态硬盘应该很容易就理解了。</p><h2 id="寄存器分类"><a href="#寄存器分类" class="headerlink" title="寄存器分类"></a>寄存器分类</h2><p>常用的 <code>x86 CPU</code> 寄存器有8个：<code>EAX</code> 、<code>EBX</code>、<code>ECX</code>、<code>EDX</code>、<code>EDI</code>、<code>ESI</code>、<code>EBP</code>、<code>ESP</code>，据说现在寄存器总数已经超过100个了，等我找到相关资料再来补充，上面这几个寄存器是最常用的，这些名字也常常出现在汇编的代码中。</p><p>我们常说的32位、64位 <code>CPU</code> 是指数据总线的宽度或根数，而寄存器是暂存数据和中间结果的单元，因此寄存器的位数也就是处理数据的长度与数据总线的根数是相同的，所以32位 <code>CPU</code> 对应的寄存器也应该是32位的。</p><h2 id="常用寄存器用途"><a href="#常用寄存器用途" class="headerlink" title="常用寄存器用途"></a>常用寄存器用途</h2><p>上面提到大8个寄存器都有其特定的用途，我们以32位 <code>CPU</code> 为例简单说明下这些寄存器的作用，整理如下表：</p><table><thead><tr><th style="text-align:center">寄存器</th><th style="text-align:center">含义</th><th style="text-align:center">用途</th><th style="text-align:center">包含寄存器</th></tr></thead><tbody><tr><td style="text-align:center">EAX</td><td style="text-align:center">累加(Accumulator)寄存器</td><td style="text-align:center">常用于乘、除法和函数返回值</td><td style="text-align:center">AX(AH、AL)</td></tr><tr><td style="text-align:center">EBX</td><td style="text-align:center">基址(Base)寄存器</td><td style="text-align:center">常做内存数据的指针, 或者说常以它为基址来访问内存.</td><td style="text-align:center">BX(BH、BL)</td></tr><tr><td style="text-align:center">ECX</td><td style="text-align:center">计数器(Counter)寄存器</td><td style="text-align:center">常做字符串和循环操作中的计数器</td><td style="text-align:center">CX(CH、CL)</td></tr><tr><td style="text-align:center">EDX</td><td style="text-align:center">数据(Data)寄存器</td><td style="text-align:center">常用于乘、除法和 I/O 指针</td><td style="text-align:center">DX(DH、DL)</td></tr><tr><td style="text-align:center">ESI</td><td style="text-align:center">来源索引(Source Index)寄存器</td><td style="text-align:center">常做内存数据指针和源字符串指针</td><td style="text-align:center">SI</td></tr><tr><td style="text-align:center">EDI</td><td style="text-align:center">目的索引(Destination Index)寄存器</td><td style="text-align:center">常做内存数据指针和目的字符串指针</td><td style="text-align:center">DI</td></tr><tr><td style="text-align:center">ESP</td><td style="text-align:center">堆栈指针(Stack Point)寄存器</td><td style="text-align:center">只做堆栈的栈顶指针; 不能用于算术运算与数据传送</td><td style="text-align:center">SP</td></tr><tr><td style="text-align:center">EBP</td><td style="text-align:center">基址指针(Base Point)寄存器</td><td style="text-align:center">只做堆栈指针, 可以访问堆栈内任意地址, 经常用于中转 ESP 中的数据, 也常以它为基址来访问堆栈; 不能用于算术运算与数据传送</td><td style="text-align:center">BP</td></tr></tbody></table><h2 id="寄存器EAX、AX、AH、AL的关系"><a href="#寄存器EAX、AX、AH、AL的关系" class="headerlink" title="寄存器EAX、AX、AH、AL的关系"></a>寄存器EAX、AX、AH、AL的关系</h2><p>在上面的图标中每个常用寄存器后面还有其他的名字，它们是同一个寄存器不同用法下的不同名字，比如在32位 <code>CPU</code> 上，EAX是32位的寄存器，而AX是EAX的低16位，AH是AX的高8位，而AL是AX的低8位，它们的对照关系如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">00000000 00000000 00000000 00000000</span><br><span class="line">|===============EAX===============|---4个字节</span><br><span class="line">                  |======AX=======|---2个字节</span><br><span class="line">                  |==AH===|-----------1个字节</span><br><span class="line">                          |===AL==|---1个字节</span><br></pre></td></tr></table></figure><h1 id="汇编语言指令"><a href="#汇编语言指令" class="headerlink" title="汇编语言指令"></a>汇编语言指令</h1><p>终于说到汇编常用指令了，因为 <code>linux</code> 和 <code>windows</code> 下的汇编语法是有些不同的，所以下面我们先通过 <code>windows</code> 下的汇编指令来简单学习一下，后续再来比较两者的不同。</p><h2 id="数据传送指令"><a href="#数据传送指令" class="headerlink" title="数据传送指令"></a>数据传送指令</h2><table><thead><tr><th style="text-align:center">指令</th><th style="text-align:center">名称</th><th style="text-align:center">示例</th><th style="text-align:center">备注</th></tr></thead><tbody><tr><td style="text-align:center">MOV</td><td style="text-align:center">传送指令</td><td style="text-align:center">MOV dest, src</td><td style="text-align:center">将数据从src移动到dest</td></tr><tr><td style="text-align:center">PUSH</td><td style="text-align:center">进栈指令</td><td style="text-align:center">PUSH src</td><td style="text-align:center">把源操作数src压入堆栈</td></tr><tr><td style="text-align:center">POP</td><td style="text-align:center">出栈指令</td><td style="text-align:center">POP desc</td><td style="text-align:center">从栈顶弹出字数据到dest</td></tr></tbody></table><h2 id="算术运算指令"><a href="#算术运算指令" class="headerlink" title="算术运算指令"></a>算术运算指令</h2><table><thead><tr><th style="text-align:center">指令</th><th style="text-align:center">名称</th><th style="text-align:center">示例</th><th style="text-align:center">备注</th></tr></thead><tbody><tr><td style="text-align:center">ADD</td><td style="text-align:center">加法指令</td><td style="text-align:center">ADD dest, src</td><td style="text-align:center">在dest基础上加src</td></tr><tr><td style="text-align:center">SUB</td><td style="text-align:center">减法指令</td><td style="text-align:center">SUB dest, src</td><td style="text-align:center">在dest基础上减src</td></tr><tr><td style="text-align:center">INC</td><td style="text-align:center">加1指令</td><td style="text-align:center">INC dest</td><td style="text-align:center">在dest基础上加1</td></tr><tr><td style="text-align:center">DEC</td><td style="text-align:center">减1指令</td><td style="text-align:center">DEC dest</td><td style="text-align:center">在dest基础上减1</td></tr></tbody></table><h2 id="逻辑运算指令"><a href="#逻辑运算指令" class="headerlink" title="逻辑运算指令"></a>逻辑运算指令</h2><table><thead><tr><th style="text-align:center">指令</th><th style="text-align:center">名称</th><th style="text-align:center">示例</th><th style="text-align:center">备注</th></tr></thead><tbody><tr><td style="text-align:center">NOT</td><td style="text-align:center">取反运算指令</td><td style="text-align:center">NOT dest</td><td style="text-align:center">把操作数dest按位取反</td></tr><tr><td style="text-align:center">AND</td><td style="text-align:center">与运算指令</td><td style="text-align:center">AND dest, src</td><td style="text-align:center">把dest和src进行与运算之后送回dest</td></tr><tr><td style="text-align:center">OR</td><td style="text-align:center">或运算指令</td><td style="text-align:center">OR dest, src</td><td style="text-align:center">把dest和src进行或运算之后送回dest</td></tr><tr><td style="text-align:center">XOR</td><td style="text-align:center">异或运算</td><td style="text-align:center">XOR dest, src</td><td style="text-align:center">把dest和src进行异或运算之后送回dest</td></tr></tbody></table><h2 id="循环控制指令"><a href="#循环控制指令" class="headerlink" title="循环控制指令"></a>循环控制指令</h2><table><thead><tr><th style="text-align:center">指令</th><th style="text-align:center">名称</th><th style="text-align:center">示例</th><th style="text-align:center">备注</th></tr></thead><tbody><tr><td style="text-align:center">LOOP</td><td style="text-align:center">计数循环指令</td><td style="text-align:center">LOOP label</td><td style="text-align:center">使ECX的值减1，当ECX的值不为0的时候跳转至label，否则执行LOOP之后的语句</td></tr></tbody></table><h2 id="转移指令"><a href="#转移指令" class="headerlink" title="转移指令"></a>转移指令</h2><table><thead><tr><th style="text-align:center">指令</th><th style="text-align:center">名称</th><th style="text-align:center">示例</th><th style="text-align:center">备注</th></tr></thead><tbody><tr><td style="text-align:center">JMP</td><td style="text-align:center">无条件转移指令</td><td style="text-align:center">JMP lable</td><td style="text-align:center">无条件地转移到标号为label的位置</td></tr><tr><td style="text-align:center">CALL</td><td style="text-align:center">过程调用指令</td><td style="text-align:center">CALL labal</td><td style="text-align:center">直接调用label</td></tr><tr><td style="text-align:center">JE</td><td style="text-align:center">条件转移指令</td><td style="text-align:center">JE lable</td><td style="text-align:center">zf =1 时跳转到标号为label的位置</td></tr><tr><td style="text-align:center">JNE</td><td style="text-align:center">条件转移指令</td><td style="text-align:center">JNE lable</td><td style="text-align:center">zf=0 时跳转到标号为label的位置</td></tr></tbody></table><h1 id="linux-和-windows-下汇编的区别"><a href="#linux-和-windows-下汇编的区别" class="headerlink" title="linux 和 windows 下汇编的区别"></a>linux 和 windows 下汇编的区别</h1><p>前面说到 <code>linux</code> 和 <code>windows</code> 下的汇编语法是不同的，其实两种语法的不同和系统不同没有绝对的关系，一般在 <code>linux</code> 上会使用 <code>gcc/g++</code> 编译器，而在 <code>windows</code> 上会使用微软的 <code>cl</code> 也就是 <code>MSBUILD</code>，所以产生不同的代码是因为编译器不同，<code>gcc</code> 下采用的是AT&amp;T的汇编语法格式，<code>MSBUILD</code> 采用的是Intel汇编语法格式。</p><table><thead><tr><th style="text-align:center">差异</th><th style="text-align:center">Intel</th><th style="text-align:center">AT&amp;T</th></tr></thead><tbody><tr><td style="text-align:center">引用寄存器名字</td><td style="text-align:center">eax</td><td style="text-align:center">%eax</td></tr><tr><td style="text-align:center">赋值操作数顺序</td><td style="text-align:center">mov dest, src</td><td style="text-align:center">movl src, dest</td></tr><tr><td style="text-align:center">寄存器、立即数指令前缀</td><td style="text-align:center">mov  ebx, 0xd00d</td><td style="text-align:center">movl  $0xd00d, %ebx</td></tr><tr><td style="text-align:center">寄存器间接寻址</td><td style="text-align:center">[eax]</td><td style="text-align:center">(%eax)</td></tr><tr><td style="text-align:center">数据类型大小</td><td style="text-align:center">操作码后加后缀字母，“l” 32位，“w” 16位，“b” 8位（mov dx, word ptr [eax]）</td><td style="text-align:center">操作数前面加dword ptr， word ptr，byte ptr的格式 （movb %bl %al）</td></tr></tbody></table><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>汇编指令是机器指令的助记符，与机器指令是一一对应的</li><li>AT&amp;T的汇编语法格式和Intel汇编语法格式的是不同的</li><li>常用寄存器：<code>EAX</code> 、<code>EBX</code>、<code>ECX</code>、<code>EDX</code>、<code>EDI</code>、<code>ESI</code>、<code>EBP</code>、<code>ESP</code></li><li>存取速度从高到低分别是: <code>寄存器 &gt; 1级缓存 &gt; 2级缓存 &gt; 3级缓存 &gt; 内存 &gt; 硬盘</code></li><li>常用的汇编指令：<code>mov</code>、<code>je</code>、<code>jmp</code>、<code>call</code>、<code>add</code>、<code>sub</code>、<code>inc</code>、<code>dec</code>、<code>and</code>、<code>or</code></li></ul><hr><blockquote><p>如今的每分每秒都是人生，不要总想着将自然发生的事情拖到预定的时刻才进行~</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;我们大都是被高级语言惯坏了的一代，源源不断的新特性正在逐步添加到各类高级语言之中，汇编作为最接近机器指令的低级语言，已经很少被直接拿来写程序了，不过我还真的遇到了一个，那是之前的一个同事，因为在写代码时遇到了成员函数权限及可见性的问题，导致他无法正确调用想执行的函数，结果他就开始在 &lt;code&gt;C++&lt;/code&gt; 代码里嵌入汇编了，绕过了种种限制终于如愿以偿，但是读代码的我们傻眼了…&lt;/p&gt;
    
    </summary>
    
      <category term="ASM" scheme="http://AlbertGithubHome.github.io/blog/categories/ASM/"/>
    
    
      <category term="C/C++" scheme="http://AlbertGithubHome.github.io/blog/tags/C-C/"/>
    
      <category term="汇编" scheme="http://AlbertGithubHome.github.io/blog/tags/%E6%B1%87%E7%BC%96/"/>
    
      <category term="linux" scheme="http://AlbertGithubHome.github.io/blog/tags/linux/"/>
    
      <category term="windows" scheme="http://AlbertGithubHome.github.io/blog/tags/windows/"/>
    
      <category term="asm" scheme="http://AlbertGithubHome.github.io/blog/tags/asm/"/>
    
  </entry>
  
  <entry>
    <title>C++11在左值引用的基础上增加右值引用</title>
    <link href="http://AlbertGithubHome.github.io/blog/2020/05/05/C-11%E5%9C%A8%E5%B7%A6%E5%80%BC%E5%BC%95%E7%94%A8%E7%9A%84%E5%9F%BA%E7%A1%80%E4%B8%8A%E5%A2%9E%E5%8A%A0%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8/"/>
    <id>http://AlbertGithubHome.github.io/blog/2020/05/05/C-11在左值引用的基础上增加右值引用/</id>
    <published>2020-05-05T08:52:16.000Z</published>
    <updated>2020-05-05T15:23:10.588Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>右值引用这个词是最开始是学习 <code>easylogging++</code> 这个日志开源项目的时候遇到的，当时遇到 <code>&amp;&amp;</code> 这样的写法先是一愣，还有这种写法？难道是引用的地址？结果查询资料才明白这叫做右值引用。</p><a id="more"></a><h1 id="右值引用的出现"><a href="#右值引用的出现" class="headerlink" title="右值引用的出现"></a>右值引用的出现</h1><p>其实右值引用是在 <code>C++11</code> 时增加的新内容，在此之前，引用是没有左值和右值之分的，只存在一种引用，也就是后来 <code>C++11</code> 标准中的左值引用，而右值引用的提出主要是为了解决之前左值引用出现的一些尴尬的问题。</p><h1 id="左值和右值"><a href="#左值和右值" class="headerlink" title="左值和右值"></a>左值和右值</h1><p>说到右值引用需要先了解下左值和右值，这也是我自己学习的过程，之前在 <a href="https://blog.csdn.net/albertsh/article/details/105756674" target="_blank" rel="noopener">《简单聊聊C/C++中的左值和右值》</a> 这篇笔记中总结过，可以简单理解左值就是放在 <code>=</code> 左边，可以取到地址，可以被赋值的表达式，而右值通常是放在 <code>=</code> 右侧，不能取地址，只能被当成一个“值”的表达式。</p><h1 id="右值引用的作用"><a href="#右值引用的作用" class="headerlink" title="右值引用的作用"></a>右值引用的作用</h1><p>右值引用的出现并不是为了取代左值引用，也不是和左值引用形成对立，而是充分利用右值内容来减少对象构造和析构操作，以达到提高程序代码效率的目的。</p><p>也就是说增加右值引用这个特性是为了提高效率，之前的总结中也提到过，在 <code>C++11</code> 中还引入了 <code>std::move()</code> 函数，并用这个函数改写了 <code>std::remove_if()</code> 函数，这就是提高效率的例子。</p><p>使用 <code>std::move()</code> 函数意味着放弃所有权，对于一个左值，如果我们明确放弃对其资源的所有权，则可以通过 <code>std::move()</code> 来将其转为右值引用，放弃所有权的这个操作不一定都是方便的，比如 <code>std::auto_ptr</code> 这个第一代的智能指针，就是因为转移了所有权，使用起来不太方便，才在最新标准中被废弃的。但如果你明确要转移所有权，并且合理使用，有时可以有效的提高程序效率。</p><h1 id="引用类型的对比"><a href="#引用类型的对比" class="headerlink" title="引用类型的对比"></a>引用类型的对比</h1><p>在学习使用右值引用之前先复习一下左值引用，对比学习更有利于我们的记忆。</p><h2 id="左值引用"><a href="#左值引用" class="headerlink" title="左值引用"></a>左值引用</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">22</span>;</span><br><span class="line"><span class="keyword">int</span>&amp; j = i;</span><br><span class="line"></span><br><span class="line">j = <span class="number">11</span>;</span><br></pre></td></tr></table></figure><p>上面这几行代码就是最常见左值引用的例子，变量 <code>j</code> 引用了变量 <code>i</code> 的存储位置，修改变量 <code>j</code> 就修改了变量 <code>i</code> 的值，但是如果引用一个值会怎么样呢？比如下面这行代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>&amp; j = <span class="number">22</span>;</span><br></pre></td></tr></table></figure><p>编译这行代码会得到一个编译错误：</p><blockquote><p>error: invalid initialization of non-const reference of type ‘int&amp;’ from an rvalue of type ‘int’<br>   int&amp; j = 22;</p></blockquote><p>像上面这种问题，可以使用常量引用来解决。</p><h2 id="常量引用"><a href="#常量引用" class="headerlink" title="常量引用"></a>常量引用</h2><p>针对上面的编译错误，改成常量引用就可以通过编译了，就像这样：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>&amp; j = <span class="number">22</span>;</span><br></pre></td></tr></table></figure><p>使用常量引用来引用数字常量22，可以编译通过是因为内存上产生了临时变量保存了22这个数据，这个临时变量是可以进行取地址操作的，因此变量 <code>j</code> 引用的其实是这个临时变量，相当于下面的这两句：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> temp = <span class="number">22</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;j = temp;</span><br></pre></td></tr></table></figure><p>看到这里我们发现常量引用可以解决引用常量的问题，那么为什么非得新增一个右值引用呢？那是因为使用常引用后，我们只能通过引用来读取数据，无法去修改数据，这在很多情况下是很不方便的。</p><h2 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h2><p>常量引用可以使用右值引用来改写，改写之后可以正常编译，并且还可以进行修改：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>&amp;&amp; j = <span class="number">22</span>;</span><br></pre></td></tr></table></figure><p>这句代码有两个需要注意的点，第一是右值引用是 <code>C++11</code> 中才增加的，所以需要增加 <code>--std=c++11</code> 这个编译选项才能正常编译，第二是右值引用的两个地址符需要连着写成 <code>&amp;&amp;</code>, 如果中间有空格写成 <code>&amp; &amp;</code> 会被认为是引用的引用而导致编译错误，这是不符合语法的。</p><h1 id="右值引用的示例"><a href="#右值引用的示例" class="headerlink" title="右值引用的示例"></a>右值引用的示例</h1><p>前面对引用类型进行了对比，但是还没有发现右值引用的好处，接下来用一个例子来展示一下增加右值引用之前的写法，和使用右值引用的写法，通过对比来了解一下右值引用究竟有什么好处。</p><p>我们来实现一个自定义缓冲区，先使用最常见的方法来实现拷贝构造函数和拷贝赋值函数，简单实现如下，功能不太完整，但是可以说明右值引用的作用：</p><h2 id="常量引用实现"><a href="#常量引用实现" class="headerlink" title="常量引用实现"></a>常量引用实现</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CBuffer</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    CBuffer(<span class="keyword">int</span> size = <span class="number">1024</span>): m_size(size)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"CBuffer(int)"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        m_buffer = <span class="keyword">new</span> <span class="keyword">char</span>[size];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~CBuffer()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"~CBuffer()"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">delete</span>[] m_buffer;</span><br><span class="line">        m_buffer = <span class="literal">nullptr</span>;</span><br><span class="line">        m_size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拷贝构造</span></span><br><span class="line">    CBuffer(<span class="keyword">const</span> CBuffer &amp;origin): m_size(origin.m_size)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"CBuffer(const CBuffer&amp;)"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        m_buffer = <span class="keyword">new</span> <span class="keyword">char</span>[origin.m_size];</span><br><span class="line">        <span class="built_in">memcpy</span>(m_buffer, origin.m_buffer, m_size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 赋值重载</span></span><br><span class="line">    CBuffer&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> CBuffer &amp;origin)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"operator=(const CBuffer&amp;)"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;origin) <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">delete</span>[] m_buffer;</span><br><span class="line"></span><br><span class="line">        m_size = origin.m_size;</span><br><span class="line">        m_buffer = <span class="keyword">new</span> <span class="keyword">char</span>[origin.m_size];</span><br><span class="line">        <span class="built_in">memcpy</span>(m_buffer, origin.m_buffer, m_size);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get_size</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> CBuffer <span class="title">gen_buffer</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">CBuffer <span class="title">temp_buffer</span><span class="params">(size)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> temp_buffer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span> *m_buffer;</span><br><span class="line">    <span class="keyword">int</span> m_size;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CBuffer b1;</span><br><span class="line">    <span class="function">CBuffer <span class="title">b2</span><span class="params">(b1)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"b1.size = "</span> &lt;&lt; b1.get_size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"b2.size = "</span> &lt;&lt; b2.get_size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    b2 = CBuffer::gen_buffer(<span class="number">100</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果是：</p><blockquote><p>CBuffer(int)<br>CBuffer(const CBuffer&amp;)<br>b1.size = 1024<br>b2.size = 1024<br>CBuffer(int)<br>operator=(const CBuffer&amp;)<br>~CBuffer()<br>~CBuffer()<br>~CBuffer()</p></blockquote><p>这个例子不具有实用性，只为了说明问题，<code>CBuffer</code> 这个类定义为了拷贝构造函数并且重载了 <code>=</code> 运算符，两个函数参数均使用常量引用的类型，这就是一般的写法。</p><p>但是这样实现有一个问题，因为参数是常量引用，所以没办法修改原对象的值，我们看到拷贝构造和赋值重载两个函数中都有申请空间和拷贝的操作，这种操作在操作内存较大的对象是比较耗时，所以应该尽量避免，我们想到可以使用新对象的指针指向旧对象指针来解决，这样就不用拷贝了，可是这样修改会导致两个对象指向同一块内存，这个问题需要解决。</p><h2 id="改为左值引用实现报错"><a href="#改为左值引用实现报错" class="headerlink" title="改为左值引用实现报错"></a>改为左值引用实现报错</h2><p>如果两个对象指向同一块内存，那么对象在析构的时候就会将一块内存释放两次导致奔溃，这时考虑在拷贝构造或者赋值重载时，将原来对象的指针设置成空就可以了，但是参数是常量没有办法修改啊，那我们将 <code>const</code> 关键字去掉试试，将两个函数改成这样：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 拷贝构造</span></span><br><span class="line">CBuffer(CBuffer &amp;origin): m_size(origin.m_size)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"CBuffer(CBuffer&amp;)"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    m_buffer = origin.m_buffer;</span><br><span class="line"></span><br><span class="line">    origin.m_buffer = <span class="literal">nullptr</span>;</span><br><span class="line">    origin.m_size = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 赋值重载</span></span><br><span class="line">CBuffer&amp; <span class="keyword">operator</span>=(CBuffer &amp;origin)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"operator=(CBuffer&amp;)"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;origin) <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">    m_buffer = origin.m_buffer;</span><br><span class="line"></span><br><span class="line">    origin.m_buffer = <span class="literal">nullptr</span>;</span><br><span class="line">    origin.m_size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看起来没有什么问题，但是编译的时候会报错：</p><blockquote><p>error: invalid initialization of non-const reference of type ‘CBuffer&amp;’ from an rvalue of type ‘CBuffer’<br>    b2 = CBuffer::gen_buffer(100);<br>                            ^<br>note:   initializing argument 1 of ‘CBuffer&amp; CBuffer::operator=(CBuffer&amp;)’<br>    CBuffer&amp; operator=(CBuffer &amp;origin)</p></blockquote><p>这个错误是什么意思呢？其实说的就是在调用 <code>CBuffer::gen_buffer(100);</code> 函数时，会产生一个临时对象，这个临时对象在赋值给 <code>b2</code> 是会调用<br><code>CBuffer&amp; operator=(CBuffer &amp;origin)</code> 函数，但是这个函数的参数是一个左值引用类型，而临时对象是一个右值，无法绑定到左值引用上，所以报错了。</p><p>还有拷贝构造函数也是有相同的问题，当写出类似 <code>b2 = CBuffer(CBuffer(1000))</code> 类型会产生临时对象的语句时，同样会因为左值引用不能绑定到右值上而报错，这时候就要请出右值引用了。</p><h2 id="改为右值引用实现"><a href="#改为右值引用实现" class="headerlink" title="改为右值引用实现"></a>改为右值引用实现</h2><p>对于赋值重载函数，我们使用右值引用将其改写为:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 赋值重载</span></span><br><span class="line">CBuffer&amp; <span class="keyword">operator</span>=(CBuffer &amp;&amp;origin)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"operator=(CBuffer&amp;&amp;)"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;origin) <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">    m_buffer = origin.m_buffer;</span><br><span class="line"></span><br><span class="line">    origin.m_buffer = <span class="literal">nullptr</span>;</span><br><span class="line">    origin.m_size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时可以正常通过编译，并且只是修改了指针的指向，并没有申请和拷贝另外一份内存。</p><h2 id="std-move-函数"><a href="#std-move-函数" class="headerlink" title="std::move() 函数"></a>std::move() 函数</h2><p>如果我们将拷贝构造函数的参数也改成右值引用的形式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 拷贝构造</span></span><br><span class="line">CBuffer(CBuffer &amp;&amp;origin): m_size(origin.m_size)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"CBuffer(CBuffer&amp;)"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    m_buffer = origin.m_buffer;</span><br><span class="line"></span><br><span class="line">    origin.m_buffer = <span class="literal">nullptr</span>;</span><br><span class="line">    origin.m_size = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译时就会发现编译错误：</p><blockquote><p>error: use of deleted function ‘constexpr CBuffer::CBuffer(const CBuffer&amp;)’<br>    CBuffer b2(b1);<br>                  ^<br>note: ‘constexpr CBuffer::CBuffer(const CBuffer&amp;)’ is implicitly declared<br>   as deleted because ‘CBuffer’ declares a move constructor or move assignment operator<br>   class CBuffer</p></blockquote><p>其本质问题就是主函数中 <code>CBuffer b2(b1);</code> 这一句引起的，因为变量 <code>b1</code> 是一个左值，但是拷贝构造函数接受的是右值引用，所以类型不匹配导致了编译错误，这时可以使用 <code>std::move()</code> 函数改成这条语句为 <code>CBuffer b2(std::move(b1));</code> 就可以正常编译运行了，运行结果为：</p><blockquote><p>CBuffer(int)<br>CBuffer(CBuffer&amp;)<br>b1.size = 0<br>b2.size = 1024<br>CBuffer(int)<br>operator=(CBuffer&amp;&amp;)<br>~CBuffer()<br>~CBuffer()<br>~CBuffer()</p></blockquote><p>查看运行结果会发现 <code>b1.size = 0</code>，因为 <code>b1</code> 调用了 <code>std::move()</code> 函数，转移了资源的所有权，内部已经被“掏空”了，所以在明确所有权转移之后，不要再直接使用变量 <code>b1</code> 了。</p><h1 id="万能引用"><a href="#万能引用" class="headerlink" title="万能引用"></a>万能引用</h1><p>听到这个名字就感觉很厉害，什么是万能引用，其实就是可以同时接受左值和右值的引用类型，但是这种完能引用只能发生在推导的情况下，下面给出了一个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(T&amp;&amp; val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; val &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> year = <span class="number">2020</span>;</span><br><span class="line">    func(year);</span><br><span class="line">    func(<span class="number">2020</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码中 <code>T&amp;&amp; val</code> 就是万能引用，因为是在模板中，类型需要推导，如果是在普通函数中 <code>T&amp;&amp; val</code> 这个形式就是右值引用。</p><h1 id="左值引用和右值引用判定的函数"><a href="#左值引用和右值引用判定的函数" class="headerlink" title="左值引用和右值引用判定的函数"></a>左值引用和右值引用判定的函数</h1><p>文中多次提到左值和右值，可能刚学习这块内容的小伙伴会有些懵，其实 <code>C++</code> 中提供了判定左值引用和右值引用的函数，头文件为 <code>&lt;type_traits&gt;</code>，函数名为 <code>is_reference</code>、 <code>is_rvalue_reference</code>、 <code>is_lvalue_reference</code>，看名字就可以知道他们的用途，看下面的例子就更清楚了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;type_traits&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">22</span>;</span><br><span class="line">    <span class="keyword">int</span>&amp; j = i;</span><br><span class="line">    <span class="keyword">int</span>&amp;&amp; k = <span class="number">11</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"i is_reference: "</span> &lt;&lt; is_reference&lt;<span class="keyword">decltype</span>(i)&gt;::value &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"i is_lvalue_reference: "</span> &lt;&lt; is_lvalue_reference&lt;<span class="keyword">decltype</span>(i)&gt;::value &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"i is_rvalue_reference: "</span> &lt;&lt; is_rvalue_reference&lt;<span class="keyword">decltype</span>(i)&gt;::value &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"j is_reference: "</span> &lt;&lt; is_reference&lt;<span class="keyword">decltype</span>(j)&gt;::value &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"j is_lvalue_reference: "</span> &lt;&lt; is_lvalue_reference&lt;<span class="keyword">decltype</span>(j)&gt;::value &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"j is_rvalue_reference: "</span> &lt;&lt; is_rvalue_reference&lt;<span class="keyword">decltype</span>(j)&gt;::value &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"k is_reference: "</span> &lt;&lt; is_reference&lt;<span class="keyword">decltype</span>(k)&gt;::value &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"k is_lvalue_reference: "</span> &lt;&lt; is_lvalue_reference&lt;<span class="keyword">decltype</span>(k)&gt;::value &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"k is_rvalue_reference: "</span> &lt;&lt; is_rvalue_reference&lt;<span class="keyword">decltype</span>(k)&gt;::value &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下，满足返回1，否则返回0：</p><blockquote><p>i is_reference: 0<br>i is_lvalue_reference: 0<br>i is_rvalue_reference: 0<br>j is_reference: 1<br>j is_lvalue_reference: 1<br>j is_rvalue_reference: 0<br>k is_reference: 1<br>k is_lvalue_reference: 0<br>k is_rvalue_reference: 1</p></blockquote><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>右值引用的写法为 <code>T&amp;&amp; val</code>，两个地址符要挨在一起，在模板中被称为万能引用</li><li>注意左值引用和右值引用的使用区别，其实本质都是为了减少无效的拷贝</li><li><code>std::move()</code> 函数会转移对象的所有权，转移操作之后将左值转为右值引用，原对象不可再直接使用</li><li>可以使用 <code>is_reference</code>、 <code>is_rvalue_reference</code>、 <code>is_lvalue_reference</code> 来判断引用类型</li></ul><hr><blockquote><p>陪伴是最长情的告白，等待是最极致的思念<br>五一离家返工了，心里有些不是滋味，为了家出来奋斗却将“家”抛在了身后，珍惜眼前人吧~</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;右值引用这个词是最开始是学习 &lt;code&gt;easylogging++&lt;/code&gt; 这个日志开源项目的时候遇到的，当时遇到 &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; 这样的写法先是一愣，还有这种写法？难道是引用的地址？结果查询资料才明白这叫做右值引用。&lt;/p&gt;
    
    </summary>
    
      <category term="C/C++" scheme="http://AlbertGithubHome.github.io/blog/categories/C-C/"/>
    
    
      <category term="C/C++" scheme="http://AlbertGithubHome.github.io/blog/tags/C-C/"/>
    
      <category term="左值" scheme="http://AlbertGithubHome.github.io/blog/tags/%E5%B7%A6%E5%80%BC/"/>
    
      <category term="右值" scheme="http://AlbertGithubHome.github.io/blog/tags/%E5%8F%B3%E5%80%BC/"/>
    
      <category term="左值引用" scheme="http://AlbertGithubHome.github.io/blog/tags/%E5%B7%A6%E5%80%BC%E5%BC%95%E7%94%A8/"/>
    
      <category term="右值引用" scheme="http://AlbertGithubHome.github.io/blog/tags/%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>简单聊聊C/C++中的左值和右值</title>
    <link href="http://AlbertGithubHome.github.io/blog/2020/04/24/%E7%AE%80%E5%8D%95%E8%81%8A%E8%81%8AC-C-%E4%B8%AD%E7%9A%84%E5%B7%A6%E5%80%BC%E5%92%8C%E5%8F%B3%E5%80%BC/"/>
    <id>http://AlbertGithubHome.github.io/blog/2020/04/24/简单聊聊C-C-中的左值和右值/</id>
    <published>2020-04-24T15:26:23.000Z</published>
    <updated>2020-04-25T13:36:02.099Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>为什么标题要写成简单聊聊，而不是写成什么“C++中左值与右值详解”或者现在很流行的“惊了！看了这一篇左值与右值讲解，他吊打了面试官”，其实带有详解这个词是需要勇气的，最起码要融会贯通之后才敢这么说吧，本来是学习右值引用的，结果涉及到了左值和右值，然后去了解他们历史发现也是有些混乱，操作中又经常涉及到运算符优先级，真是越学越乱了。</p><a id="more"></a><!-- https://www.cnblogs.com/catch/p/3500678.html --><!-- https://www.cnblogs.com/catch/p/3251937.html --><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>索性也把右值引用放一边，从头来看看这个左值和右值，其实我跟这两个词一点都不熟，最多就是在编译报错的提示框中看到他们，当然有时候也会看到他们的英文名字 <code>lvalue</code> 和 <code>rvalue</code>，这时候一般就是编译器开始抱怨了，说我写了什么它不能理解的东西，其实嘛，我自己都没完全理解，从现在开始边学边总结了，先展示一个常见报错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error: lvalue required as increment operand</span><br></pre></td></tr></table></figure><p>这是什么意思，这么绕嘴，左值需要作为增长操作数，请说人话：自增操作需要一个可以赋值的变量作为操作数，需要变量就直说嘛，为什么要左值、右值的把人都绕蒙了。</p><h1 id="历史渊源"><a href="#历史渊源" class="headerlink" title="历史渊源"></a>历史渊源</h1><p>这个世界一直是在变化的，可能之前你一直引以为豪的经验大楼，转眼之间就会倾塌。关于左值和右值的历史，普遍的观点是最初来源于 <code>C</code> 语言，后来被引入到了 <code>C++</code>，但是关于左值和右值的含义和实现却在一直改变和完善，对于它的历史讲解发现一篇总结的比较好的文章 <a href="https://www.cnblogs.com/dejavu/archive/2012/09/02/2667640.html" target="_blank" rel="noopener">《C/C++ 左值和右值, L-value和R-value》</a>。</p><p>这是2012年的一篇文章，文中给出了历史说明依据，最后还举了一些例子来说明 <code>C</code> 和 <code>C++</code> 关于左值实现的不同，但是实际操作后你会发现，时间的车轮早已向前行进了一大截，文中提到的那些不同，在最新的 <code>gcc</code> 和 <code>g++</code> 编译器上早已变得相同，文中提到的反例现在看来几乎没有意义了。</p><p>简单梳理下，左值的定义最早出现在 《The C Programming Language 》一书中，指的是引用一个对象，放在赋值表达式 <code>=</code> 左边的值。</p><p>后来在新的 <code>C</code> 语言标准中提到左值是赋值表达式 <code>=</code> 左边的值或者需要被改变的值，而等号的右边的值被称为右值。左值更好的表达为可以定位的值，而右值是一种表达数据的值，基于这个表述 <code>L-value</code> 可以理解为 <code>locator value</code>，代表可寻址，而 <code>R-value</code> 可以理解为 <code>read value</code>，代表可读取。</p><p>不过以上的新解，完全是人们为了理解左值、右值赋予的新含义，从历史发展来看，一开始左值和右值完全就是通过等号的左边和右边来命名的，只不过随着标准的完善和语言的发展、更替，虽然两个名字保留了下来，但是它们的含义却在逐步发生改变，与最初诞生时的 <code>=</code> 左右两边的值这个含义相比，已经相差很多了。</p><h1 id="认识左值和右值"><a href="#认识左值和右值" class="headerlink" title="认识左值和右值"></a>认识左值和右值</h1><p>关于左值右值有几条规则和特点，先列举在这里，后面可以跟随例子慢慢体会：</p><ol><li>左值和右值都是指的表达式，比如 <code>int a = 1</code> 中的 <code>a</code> 是左值，<code>++a</code> 是左值, <code>func()</code> 也可能是左值，而 <code>a+1</code> 是右值， <code>110</code> 也是一个右值。</li><li>左值可以放在 <code>=</code> 的左边，右值只能放在 <code>=</code> 的右边，这其中隐含的意思就是左值也能放在 <code>=</code> 的右边，但是右值不能放在 <code>=</code> 的左边。</li><li>左值可以取地址，代表着内存中某个位置，可以存储数据，右值仅仅是一个值，不能取地址，或者它看起来是一个变量，但它是临时的无法取地址，例如一个函数的非引用的值返回。</li></ol><p>以上规则从定义来看一点也不严谨，比如一个常量定义是可以赋值，后面就不行了，它也可以取地址，但是不能赋值的它到底是左值还是右值，这点其实不用纠结，心里知道这个情况就可以了。</p><p>再比如一个普通变量，它原本是一个左值，当用它给其他变量赋值的时候，它又化身为一个右值，这时它也可以取地址，好像与上面的说法相违背了，但是仔细想想真的是这样吗？它只是临时化身为右值，其实是一个左值，所以才可以取地址的。</p><p>其实你如果不做学术研究、不斤斤计较，那么完全可以把能够赋值的表达式作为左值，然后把左值以外的表达式看成右值，如果你不熟悉解左值和右值可能根本不会影响你平时的工作和学习，但是了解它有助于我们深入理解一些内置运算符和程序执行过程，以及在出现编译错误的时候及时定位问题。</p><h1 id="具体的示例"><a href="#具体的示例" class="headerlink" title="具体的示例"></a>具体的示例</h1><h2 id="最简单的赋值语句"><a href="#最简单的赋值语句" class="headerlink" title="最简单的赋值语句"></a>最简单的赋值语句</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> age = <span class="number">18</span>;</span><br></pre></td></tr></table></figure><p>这个赋值语句很简单，<code>=</code> 作为分界线，左边的 <code>age</code> 是左值，可以被赋值，可以取地址，它其实就是一个表达式，代表一个可以存储整数的内存地址；右边的 <code>18</code> 也是一个表达式，明显只能作为右值，不能取地址。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">18</span> = age;</span><br></pre></td></tr></table></figure><p>这个语句在编译时会提示下面的错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error: lvalue required as left operand of assignment</span><br></pre></td></tr></table></figure><p>错误提示显示：赋值语句的左边需要一个左值，显然 <code>18</code> 不能作为左值，它不代表任何内存地址，不能被改变。</p><p>如果程序中的表达式都这么简单就不需要纠结了，接着我们往下看一些复杂点的例子。</p><h2 id="自增自减运算"><a href="#自增自减运算" class="headerlink" title="自增自减运算"></a>自增自减运算</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">++age++;</span><br></pre></td></tr></table></figure><p>第一眼看到这个表达式，你感觉它会怎样运算，编译一下，你会发现编译失败了，错误如下：</p><blockquote><p>error: lvalue required as increment operand</p></blockquote><p>加个括号试试：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">++(age++)</span><br></pre></td></tr></table></figure><p>编译之后会出现相同的错误：</p><blockquote><p>error: lvalue required as increment operand</p></blockquote><p>再换一种加括号的方式再编译一次：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(++age)++</span><br></pre></td></tr></table></figure><p>这次成功编译了，并且输出值之后发现 <code>age</code> 变量增加了两次。</p><p>先不考虑左值右值的问题，我们可以从这个例子中发现自增运算的优先级，后置自增 <code>age++</code> 的优先级要高于前置自增 <code>++age</code> 的优先级。</p><p>现在回过头来看看之前的编译错误，为什么我们加括号改变运算顺序之后就可以正常执行了呢？这其实和自增运算的实现有关。</p><h3 id="前置自增"><a href="#前置自增" class="headerlink" title="前置自增"></a>前置自增</h3><p>前置自增的一般实现，是直接修改原对象，在原对象上实现自增，然后将原对象以引用方式返回：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">UPInt&amp; UPInt::<span class="keyword">operator</span>++()</span><br><span class="line">&#123;</span><br><span class="line">　*<span class="keyword">this</span> += <span class="number">1</span>;    <span class="comment">// 原对象自增</span></span><br><span class="line">　<span class="keyword">return</span> *<span class="keyword">this</span>;  <span class="comment">// 返回原对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里一直操作的是原对象，返回的也是原对象的引用，所以前置自增表达式的结果是左值，它引用的是原对象之前所占用的内存。</p><h3 id="后置自增"><a href="#后置自增" class="headerlink" title="后置自增"></a>后置自增</h3><p>后置自增的一般实现，是先将原对象的数据存储到临时变量中，接着在原对象上实现自增，然后将临时变量以只读的方式返回：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> UPInt UPInt::<span class="keyword">operator</span>++(<span class="keyword">int</span>)</span><br><span class="line">&#123;</span><br><span class="line">　UPInt oldValue = *<span class="keyword">this</span>; <span class="comment">// 将原对象赋值给临时变量</span></span><br><span class="line">　++(*<span class="keyword">this</span>);              <span class="comment">// 原对象自增</span></span><br><span class="line">　<span class="keyword">return</span> oldValue;        <span class="comment">// 返回临时变量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里返回的是临时变量，在函数返回后就被销毁了，无法对其取地址，所以后置自增表达式的结果是右值，不能对其进行赋值。</p><p>所以表达式 <code>++age++;</code> 先进行后置自增，然后再进行前置自增就报出编译错误了，因为不能修改右值，也不能对右值进行自增操作。</p><h3 id="自增表达式赋值"><a href="#自增表达式赋值" class="headerlink" title="自增表达式赋值"></a>自增表达式赋值</h3><p>前面说到前置自增表达式是一个左值，那能不能对其赋值呢？当然可以！试试下面的语句：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">++age = <span class="number">20</span>;</span><br></pre></td></tr></table></figure><p>这条语句是可以正常通过编译的，并且执行之后 <code>age</code> 变量的值为 <code>20</code>。</p><h2 id="函数表达式"><a href="#函数表达式" class="headerlink" title="函数表达式"></a>函数表达式</h2><p>函数可以作为左值吗？带着这个疑问我们看一下这个赋值语句：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func() = <span class="number">6</span>;</span><br></pre></td></tr></table></figure><p>可能有些同学会有疑问，这是正常的语句吗？其实它是可以正常的，只要 <code>func()</code> 是一个左值就可以，怎么才能让他成为一个左值呢，想想刚才的前置自增运算可能会给你启发，要想让他成为左值，它必须代表一个内存地址，写成下面这样就可以了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> g;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>&amp; <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> g;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    func() = <span class="number">100</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数 <code>func()</code> 返回的是全局变量 <code>g</code> 的引用，变量 <code>g</code> 是一个可取地址的左值，所以 <code>func()</code> 表达式也是一个左值，对其赋值后就改变了全局变量 <code>g</code> 的值。</p><p>那么我们注意到这里 <code>func()</code> 函数返回的是全局变量的引用，如果是局部变量会怎么样呢？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>&amp; <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">101</span>;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    func() = <span class="number">100</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码编译没有错误，但是会产生一个警告，提示返回了局部变量的引用:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">warning: reference to local variable ‘i’ returned [-Wreturn-local-addr]</span><br></pre></td></tr></table></figure><p>运行之后可就惨了，直接显示段错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Segmentation fault (core dumped)</span><br></pre></td></tr></table></figure><p>改为局部变量之后，<code>func()</code> 函数虽然返回了一个值，但是这个值是一个临时值，函数返回之后该值被销毁，对应的内存空间也不属于它了，所以在最后赋值的时候才会出现段错误，就和我们访问非法内存是产生的错误时一样的。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>可以被赋值的表达式是左值，左值可以取地址。</li><li>右值应该是一个表示值的表达式，不是左值的表达式都可以看成是右值</li><li>后置自增操作符的优先级要高于前置自增操作符，它们是按照从右向左结合的</li><li>关于左值和右值的知识点还有很多，后续想到了再补充，我也是边学边总结，如果有错误也欢迎小伙伴们及时指出，我会及时改正的</li></ul><hr><blockquote><p>时刻静下来想想当初为什么出发，不要在现实的汪洋中偏离航向</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;为什么标题要写成简单聊聊，而不是写成什么“C++中左值与右值详解”或者现在很流行的“惊了！看了这一篇左值与右值讲解，他吊打了面试官”，其实带有详解这个词是需要勇气的，最起码要融会贯通之后才敢这么说吧，本来是学习右值引用的，结果涉及到了左值和右值，然后去了解他们历史发现也是有些混乱，操作中又经常涉及到运算符优先级，真是越学越乱了。&lt;/p&gt;
    
    </summary>
    
      <category term="C/C++" scheme="http://AlbertGithubHome.github.io/blog/categories/C-C/"/>
    
    
      <category term="C/C++" scheme="http://AlbertGithubHome.github.io/blog/tags/C-C/"/>
    
      <category term="左值" scheme="http://AlbertGithubHome.github.io/blog/tags/%E5%B7%A6%E5%80%BC/"/>
    
      <category term="右值" scheme="http://AlbertGithubHome.github.io/blog/tags/%E5%8F%B3%E5%80%BC/"/>
    
      <category term="lvalue" scheme="http://AlbertGithubHome.github.io/blog/tags/lvalue/"/>
    
      <category term="rvalue" scheme="http://AlbertGithubHome.github.io/blog/tags/rvalue/"/>
    
  </entry>
  
  <entry>
    <title>.bat批处理（九）：替换带有等号=的字符串的子串</title>
    <link href="http://AlbertGithubHome.github.io/blog/2020/04/18/bat%E6%89%B9%E5%A4%84%E7%90%86%EF%BC%88%E4%B9%9D%EF%BC%89%EF%BC%9A%E6%9B%BF%E6%8D%A2%E5%B8%A6%E6%9C%89%E7%AD%89%E5%8F%B7-%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%AD%90%E4%B8%B2/"/>
    <id>http://AlbertGithubHome.github.io/blog/2020/04/18/bat批处理（九）：替换带有等号-的字符串的子串/</id>
    <published>2020-04-18T10:01:16.000Z</published>
    <updated>2020-04-19T03:08:08.169Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>今天写这篇记录要解决的问题来源于最近一名读者的提问，之前写过一篇名为<a href="https://blog.csdn.net/albertsh/article/details/79919465" target="_blank" rel="noopener">《.bat批处理（六）：替换字符串中匹配的子串》</a>的总结文章，结果有读者在评论区提问说，如果想要替换的子串中包含等号 <code>=</code>，那么就无法替换了，问有没有什么办法可以解决。遇到这个问题的第一感觉应该挺好处理的吧，如果批处理程序在替换操作中认为等号 <code>=</code> 比较特殊，那就加个转义字符应该就可以了，但事实却证明这种想法有些天真了。</p><a id="more"></a><p>在尝试多次失败之后，我意识到事情远没有想象的那么简单，开始在网上寻找解决方案，结果有些让人意外，绝大多数人都说这是 <code>SET</code> 命令的执行规则决定的，无法实现这种需求。当要替换的子串中包含 <code>=</code> 时，第一个 <code>=</code> 就会被认为是替换语法中的 <code>=</code>，进而导致无法得到正确的结果，即使是使用转义字符都无法完成正确替换，加入的转义字符会影响匹配，导致替换失败。还有一些人建议用其他工具来完整这种需求，比如记事本的替换功能 <code>O(∩_∩)O</code>。</p><h1 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h1><p>看了上面的叙述，可能有些小伙伴对我所说的问题还没有太直观的认识，接下来我们举个例子来说一下这个问题究竟是怎样产生的。</p><h2 id="0x00-带有-的字符串"><a href="#0x00-带有-的字符串" class="headerlink" title="0x00 带有 = 的字符串"></a>0x00 带有 = 的字符串</h2><p>首先需要被替换的字符串中要包含等号，我们来定义一个这样的变量：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> STR=abcdo=ocar12a=ajdjko=ot</span><br></pre></td></tr></table></figure><p>变量的名字是 <code>STR</code>，变量的值是 <code>abcdo=ocar12a=ajdjko=ot</code>，其中包含了三个 <code>=</code>。</p><h2 id="0x01-带有-的想要被替换的子串"><a href="#0x01-带有-的想要被替换的子串" class="headerlink" title="0x01 带有 = 的想要被替换的子串"></a>0x01 带有 = 的想要被替换的子串</h2><p>确定一下我们想要替换的子串 <code>o=o</code>，假如我们想把它替换成字母 <code>A</code>，按照一般的替换规则<code>X:Y=Z</code>，在 <code>X</code> 串中寻找到 <code>Y</code> 串之后把它替换成 <code>Z</code> 串，实现的代码如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> STR=abcdo=ocar12a=ajdjko=ot</span><br><span class="line"><span class="built_in">set</span> RESULT=%STR:o=o=A%</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> %RESULT%</span><br><span class="line">pause &gt; nul</span><br></pre></td></tr></table></figure><p>运行之后的结果是：</p><blockquote><p>abcdo=A=o=Acar12a=ajdjko=A=o=At</p></blockquote><p>和我们想法不一样，我们本来想把 <code>o=o</code> 替换成 <code>A</code>，但是从结果来看应该是把 <code>o</code> 替换成了 <code>o=A</code>，原因就是我们选择的被替换中的子串 <code>o=o</code> 包含一个 <code>=</code>，而这个 <code>=</code> 被当成了替换语法 <code>X:Y=Z</code> 中的 <code>=</code>，所以就不对了。</p><h2 id="0x02-尝试用转义字符来处理"><a href="#0x02-尝试用转义字符来处理" class="headerlink" title="0x02 尝试用转义字符来处理"></a>0x02 尝试用转义字符来处理</h2><p>很多语言中都有转义字符，比如 Markdown 语法中的反斜杠 <code>\</code>，在 Markdown 语法中被星号 <code>*</code> 包裹的文字是倾斜的，但是如果想正常的输出一个 <code>*</code> 怎么办呢？就需要在 <code>*</code> 前面加一个反斜杠 <code>\</code>，变成 <code>\*</code>，这样 <code>*</code> 原本的倾斜文字的作用就被转义了，变成了一个普通的输出字符。</p><p>在批处理中也有转义字符的概念，它就是 <code>^</code>，我们知道在批处理中 <code>&gt;</code>、<code>|</code> 等符号都是有特殊用处的，所以不能简单的输出，比如 <code>echo &gt;</code> 是无法输出一个大于号的，要写成 <code>echo ^&gt;</code> 才能正常输出一个 <code>&gt;</code> 符号。</p><p>我们就利用这个转义字符来告诉替换命令，被替换的子串中的 <code>=</code> 是一个普通字符，不能作为替换规则的一部分，所以被替换的子串写成了 <code>o^=o</code>，我们实现下面的代码，看看能不能达到目的：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> STR=abcdo=ocar12a=ajdjko=ot</span><br><span class="line"><span class="built_in">set</span> RESULT=%STR:o^=o=A%</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> %RESULT%</span><br><span class="line">pause &gt; nul</span><br></pre></td></tr></table></figure><p>运行之后结果如下：</p><blockquote><p>abcdo=ocar12a=ajdjko=ot</p></blockquote><p>与替换前对比发现没有任何变化，看来转义字符的想法没能帮助我们解决问题，还是想想其他的办法吧。</p><h1 id="稳扎稳打的解决方案"><a href="#稳扎稳打的解决方案" class="headerlink" title="稳扎稳打的解决方案"></a>稳扎稳打的解决方案</h1><p>既然 <code>=</code> 这么特殊，我们就先想办法干掉等号，直接替换的方式不好使，我们可以一个字符一个字符的判断啊，虽然麻烦一点，但是解决问题才是最重要的。</p><p>既然要一个个的字符去判断，就需要遍历原字符串，最简单的可以使用字符串分割啊，语法为 <code>原串:~偏移,长度</code> 就可以了，如果不太清楚可以参考一下 <a href="https://blog.csdn.net/albertsh/article/details/52797519" target="_blank" rel="noopener">《.bat批处理（三）：变量声明、设置、拼接、截取》</a>，截取第一个字符的语法是 <code>原串:~0,1</code>， 截取第二个字符的语法是 <code>原串:~1,1</code>，以此类推。</p><p>具体的思路就是我们先判断第一个字符，如果是 <code>=</code> 就进行替换，如果不是 <code>=</code> 就放到结果字符串里，然后继续判断第二个字符进行操作，最后所有的字符处理一遍就完成了替换。</p><p>需要使用 <code>goto</code> 语句来写一个循环，代码逻辑比较简单，就是遍历所有字符，是 <code>=</code> 就替换，不是 <code>=</code> 就保留，假设我们先把 <code>=</code> 替换成 <code>#</code>，实现的代码如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> STR=abcdo=ocar12a=ajdjko=ot</span><br><span class="line"><span class="built_in">set</span> CURSTR=%STR%</span><br><span class="line"><span class="built_in">set</span> RESULT=</span><br><span class="line"></span><br><span class="line">:next</span><br><span class="line"><span class="keyword">if</span> <span class="string">"%CURSTR%"</span> equ <span class="string">""</span> goto end</span><br><span class="line"><span class="built_in">set</span> a=%CURSTR:~0,1%</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="string">"%a%"</span> equ <span class="string">"="</span> (<span class="built_in">set</span> RESULT=%RESULT%<span class="comment">#) else (set RESULT=%RESULT%%a%)</span></span><br><span class="line"><span class="built_in">set</span> CURSTR=%CURSTR:~1%</span><br><span class="line">goto next</span><br><span class="line"></span><br><span class="line">:end</span><br><span class="line"><span class="built_in">echo</span> <span class="built_in">source</span> string is %STR%</span><br><span class="line"><span class="built_in">echo</span> result string is %RESULT%</span><br><span class="line">pause &gt; nul</span><br></pre></td></tr></table></figure><p><code>:next</code> 是循环的入口，每次截取第一个字符，判断是 <code>=</code> 就在结果中拼接 <code>#</code> 字符，相当于完成了替换，如果字符不是 <code>=</code> ，就将字符直接拼接到结果中，操作之后将原串的第一个字符删除形成新的原串，然后再判断第一个字符，以此类推，直到原串为空，运行结果如下：</p><blockquote><p>source string is abcdo=ocar12a=ajdjko=ot<br>result string is abcdo#ocar12a#ajdjko#ot</p></blockquote><h1 id="最终方案"><a href="#最终方案" class="headerlink" title="最终方案"></a>最终方案</h1><p>事情到了这里好像还没完，在实际操作中有些情况不是替换一个 <code>=</code>，往往是替换的内容中包含 <code>=</code>，上面将 <code>=</code> 替换成 <code>#</code> 不具有通用型，如果是一开始的请求，将 <code>o=o</code>替换成 <code>A</code> 就不能这样写了，就应该是每次判断3个字符了，写起来有些麻烦，批处理中没有获得字符串长度的函数，需要自己实现一个，如果是100个字符的被替换串，那代码就很难写了。</p><p>既然 <code>=</code> 都能被我们替换掉，肯定有办法实现上面我们这种将 <code>o=o</code>替换成 <code>A</code> 的要求，下面我们就列举一种通用的处理方法。</p><h2 id="0x00-首先将-替换成一个原串中不可能出现的字符或者序列"><a href="#0x00-首先将-替换成一个原串中不可能出现的字符或者序列" class="headerlink" title="0x00 首先将 = 替换成一个原串中不可能出现的字符或者序列"></a>0x00 首先将 <code>=</code> 替换成一个原串中不可能出现的字符或者序列</h2><p>这步替换可能最后需要还原的，所以要求我们替换成的目标序列不能在原串中出现，比如我们上面把 <code>=</code> 替换成了 <code>#</code>， 如果原串中有 <code>#</code> 就会弄混了，不能确定是原来字符串中就存在的 <code>#</code>，还是由 <code>=</code> 变成的 <code>#</code>。</p><p>这个序列我们可以定义的变态一点，比如把 <code>=</code> 替换成 <code>###i#am#happy###</code>，我们把它记作 <code>α</code>。</p><h2 id="0x01-用这个不能出现序列替换我们之前要查找替换子串中的"><a href="#0x01-用这个不能出现序列替换我们之前要查找替换子串中的" class="headerlink" title="0x01 用这个不能出现序列替换我们之前要查找替换子串中的 ="></a>0x01 用这个不能出现序列替换我们之前要查找替换子串中的 <code>=</code></h2><p>我们之前要查找替换的子串是 <code>o=o</code>，那么替换之后形成 <code>o###i#am#happy###o</code>，我们把它记作 <code>β</code>。</p><h2 id="0x02-将第1步结束获得的替换结果作为原串，将其中的-β-替换成-A"><a href="#0x02-将第1步结束获得的替换结果作为原串，将其中的-β-替换成-A" class="headerlink" title="0x02 将第1步结束获得的替换结果作为原串，将其中的 β 替换成 A"></a>0x02 将第1步结束获得的替换结果作为原串，将其中的 <code>β</code> 替换成 <code>A</code></h2><p>其实就是把第1步替换完结果作为原串，把其中的 <code>o###i#am#happy###o</code> 也就是原来的 <code>o=o</code> 替换成 <code>A</code>。</p><h2 id="0x03-将第3步结果的子串作为原串，将其中的-α-替换为"><a href="#0x03-将第3步结果的子串作为原串，将其中的-α-替换为" class="headerlink" title="0x03 将第3步结果的子串作为原串，将其中的 α 替换为 ="></a>0x03 将第3步结果的子串作为原串，将其中的 <code>α</code> 替换为 <code>=</code></h2><p>这一步就是处理那些虽然是 <code>=</code>，但是这个 <code>=</code> 不是我要替换的结果子串中的，所以要还原</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><p>步骤梳理清楚了，下面来写代码，按照步骤一步步写就可以了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line"></span><br><span class="line">rem 第一步</span><br><span class="line"><span class="built_in">set</span> CORESTR=<span class="comment">###i#am#happy###</span></span><br><span class="line"><span class="built_in">set</span> STR=abcdo=ocar12a=ajdjko=ot</span><br><span class="line"><span class="built_in">set</span> CURSTR=%STR%</span><br><span class="line"><span class="built_in">set</span> RESULT1=</span><br><span class="line"></span><br><span class="line">:next1</span><br><span class="line"><span class="keyword">if</span> <span class="string">"%CURSTR%"</span> equ <span class="string">""</span> goto end1</span><br><span class="line"><span class="built_in">set</span> a=%CURSTR:~0,1%</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="string">"%a%"</span> equ <span class="string">"="</span> (<span class="built_in">set</span> RESULT1=%RESULT1%%CORESTR%) <span class="keyword">else</span> (<span class="built_in">set</span> RESULT1=%RESULT1%%a%)</span><br><span class="line"><span class="built_in">set</span> CURSTR=%CURSTR:~1%</span><br><span class="line">goto next1</span><br><span class="line"></span><br><span class="line">:end1</span><br><span class="line"><span class="built_in">echo</span> source1 string is %STR%</span><br><span class="line"><span class="built_in">echo</span> result1 string is %RESULT1%</span><br><span class="line">pause &gt; nul</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">rem 第 2 步</span><br><span class="line"><span class="built_in">set</span> CORESTR=<span class="comment">###i#am#happy###</span></span><br><span class="line"><span class="built_in">set</span> STR=o=o</span><br><span class="line"><span class="built_in">set</span> CURSTR=%STR%</span><br><span class="line"><span class="built_in">set</span> RESULT2=</span><br><span class="line"></span><br><span class="line">:next2</span><br><span class="line"><span class="keyword">if</span> <span class="string">"%CURSTR%"</span> equ <span class="string">""</span> goto end2</span><br><span class="line"><span class="built_in">set</span> a=%CURSTR:~0,1%</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="string">"%a%"</span> equ <span class="string">"="</span> (<span class="built_in">set</span> RESULT2=%RESULT2%%CORESTR%) <span class="keyword">else</span> (<span class="built_in">set</span> RESULT2=%RESULT2%%a%)</span><br><span class="line"><span class="built_in">set</span> CURSTR=%CURSTR:~1%</span><br><span class="line">goto next2</span><br><span class="line"></span><br><span class="line">:end2</span><br><span class="line"><span class="built_in">echo</span> source2 string is %STR%</span><br><span class="line"><span class="built_in">echo</span> result2 string is %RESULT2%</span><br><span class="line">pause &gt; nul</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">rem 第3步，需要开启延迟变量</span><br><span class="line">setlocal ENABLEDELAYEDEXPANSION</span><br><span class="line"><span class="built_in">set</span> RESULT3=!RESULT1:%RESULT2%=A!</span><br><span class="line"><span class="built_in">echo</span> result3 string is %RESULT3%</span><br><span class="line">pause &gt; nul</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">rem 第4步</span><br><span class="line"><span class="built_in">set</span> RESULT4=!RESULT3:%CORESTR%==!</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> finally result is %RESULT4%</span><br></pre></td></tr></table></figure><p>运行之后的结果为：</p><blockquote><p>source1 string is abcdo=ocar12a=ajdjko=ot<br>result1 string is abcdo###i#am#happy###ocar12a###i#am#happy###ajdjko###i#am#happy###ot<br>source2 string is o=o<br>result2 string is o###i#am#happy###o<br>result3 string is abcdAcar12a###i#am#happy###ajdjkAt<br>finally result is abcdAcar12a=ajdjkAt</p></blockquote><p>这次终于替换成功了，<code>o=o</code> 被成功替换成了字母 <code>A</code>，代码中用到了延迟变量，主要是为了实现被替换字符串是变量的情况，不清楚延迟变量的用法可以简单查询一下，至此文章开头提出的问题我们就成功解决了，虽然路途有些坎坷。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol><li>批处理程序中的 <code>=</code> 比较特殊，使用常规的 <code>X:Y=Z</code> 的语法不能替换包含 <code>=</code> 的子串</li><li>遇到上述情况可以将字符串切割，采用逐个字符比较的方式，将 <code>=</code> 替换成其他字符再进行后续操作</li><li>有时候也不必非得使用批处理来替换包含 <code>=</code> 的字符串，随便一个文本工具，比如记事本都可以文本进行替换</li><li>如果非得用命令解决，也可以使用从 linux 的 <code>sed</code> 命令移植到 windows 的 <code>sed.exe</code> 程序来很方便的进行替换</li><li>使用 sed 命令的语法是 <code>echo abcdo=ocar12a=ajdjko=ot | sed -e &quot;s/o=o/A/g&quot;</code>，一步就可以完成了文章开头的需求了</li><li>如果你暂时没有 <code>sed.exe</code> 程序，可以点击这个链接 <a href="https://download.csdn.net/download/shihengzhen101/12335608" target="_blank" rel="noopener">sed.exe程序</a> 下载，若不是在同一目录使用，记得将命令目录添加到环境变量中</li></ol><hr><blockquote><p>时间慢慢地磨去了年少轻狂，也渐渐地沉淀了冷暖自知。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;今天写这篇记录要解决的问题来源于最近一名读者的提问，之前写过一篇名为&lt;a href=&quot;https://blog.csdn.net/albertsh/article/details/79919465&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《.bat批处理（六）：替换字符串中匹配的子串》&lt;/a&gt;的总结文章，结果有读者在评论区提问说，如果想要替换的子串中包含等号 &lt;code&gt;=&lt;/code&gt;，那么就无法替换了，问有没有什么办法可以解决。遇到这个问题的第一感觉应该挺好处理的吧，如果批处理程序在替换操作中认为等号 &lt;code&gt;=&lt;/code&gt; 比较特殊，那就加个转义字符应该就可以了，但事实却证明这种想法有些天真了。&lt;/p&gt;
    
    </summary>
    
      <category term="bat" scheme="http://AlbertGithubHome.github.io/blog/categories/bat/"/>
    
    
      <category term="实用工具" scheme="http://AlbertGithubHome.github.io/blog/tags/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/"/>
    
      <category term="bat" scheme="http://AlbertGithubHome.github.io/blog/tags/bat/"/>
    
  </entry>
  
  <entry>
    <title>C++11中的时间库std::chrono（引发关于时间的思考）</title>
    <link href="http://AlbertGithubHome.github.io/blog/2020/04/08/C-11%E4%B8%AD%E7%9A%84%E6%97%B6%E9%97%B4%E5%BA%93std-chrono/"/>
    <id>http://AlbertGithubHome.github.io/blog/2020/04/08/C-11中的时间库std-chrono/</id>
    <published>2020-04-08T15:18:13.000Z</published>
    <updated>2020-04-12T12:54:33.281Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>时间都去哪了？还没好好感受年轻就…</p></blockquote><hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>时间是宝贵的，我们无时无刻不在和时间打交道，这个任务明天下班前截止，你点的外卖还有5分钟才能送到，那个程序已经运行了整整48个小时，既然时间和我们联系这么紧密，我们总要定义一些术语来描述它，像前面说到的明天下班前、5分钟、48个小时都是对时间的描述，程序代码构建的程序世界也需要定义一些术语来描述时间。</p><a id="more"></a><p>今天要总结学习的是 <code>std::chrono</code> 库，它是 <code>C++11</code> 标准时从 <code>boost</code> 库中引入的，其实在 C++ 中还有一种 <code>C</code> 语言风格的时间管理体系，像我们常见的函数 <code>time()</code>、<code>clock()</code>、<code>localtime()</code>、<code>mktime()</code> 和常见的类型 <code>tm</code>、<code>time_t</code>、<code>clock_t</code> 都是 <code>C</code> 语言风格的时间管理体系。</p><p><code>std::chrono</code> 这个库之前接触的不多，<code>C++20</code> 标准都出了，<code>C++11</code> 引入的这个库还没怎么用过，整天和 <code>time()</code>、 <code>localtime()</code>、 <code>tm</code> 打交道，最近工作中换了项目，代码中出现了 <code>std::chrono</code> 的使用，是时候好好学习总结一下了。</p><h1 id="chrono-的概况"><a href="#chrono-的概况" class="headerlink" title="chrono 的概况"></a>chrono 的概况</h1><ul><li>头文件 <code>#include &lt;chrono&gt;</code></li><li>命名空间 <code>std::chrono</code></li></ul><p>这个库从 <code>C++11</code> 引入标准之后，每个版本都有所修改，不过核心内容变化不是太大，他定义了三种主要类型，分别是 <code>durations</code>、<code>clocks</code> 和 <code>time points</code>，以及围绕这些类型的一些工具函数和衍生的定义。</p><h1 id="chrono-的核心内容"><a href="#chrono-的核心内容" class="headerlink" title="chrono 的核心内容"></a>chrono 的核心内容</h1><h2 id="duration"><a href="#duration" class="headerlink" title="duration"></a>duration</h2><p>这个模板类用来表示时间间隔，我们知道时间的基本单位是秒，这个类的对象所表示的时间间隔也是以秒为单位的，它的定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Rep</span>, <span class="title">class</span> <span class="title">Period</span> = <span class="title">std</span>:</span>:ratio&lt;<span class="number">1</span>&gt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">duration</span>;</span></span><br></pre></td></tr></table></figure><p><code>Rep</code> 表示一种数值类型，用来描述周期 <code>Period</code> 的数值类型，比如可以是 <code>int</code>、<code>float</code> 等，而 <code>Period</code> 的类型是 <code>std::ratio</code>，同样是一个模板类，实际表示的是一个有理数，像100、0、1/1000（千分之一）等等。</p><p>在 <code>std</code> 这个命名空间下有很多已经定义好的有理数，可以举几个常见的头文件 <code>&lt;ratio&gt;</code> 中的例子:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">nano    <span class="built_in">std</span>::ratio&lt;<span class="number">1</span>, <span class="number">1000000000</span>&gt;   <span class="comment">// 十亿分之一</span></span><br><span class="line">micro   <span class="built_in">std</span>::ratio&lt;<span class="number">1</span>, <span class="number">1000000</span>&gt;      <span class="comment">// 百万分之一</span></span><br><span class="line">milli   <span class="built_in">std</span>::ratio&lt;<span class="number">1</span>, <span class="number">1000</span>&gt;         <span class="comment">// 千分之一</span></span><br><span class="line">centi   <span class="built_in">std</span>::ratio&lt;<span class="number">1</span>, <span class="number">100</span>&gt;          <span class="comment">// 百分之一</span></span><br><span class="line">deci    <span class="built_in">std</span>::ratio&lt;<span class="number">1</span>, <span class="number">10</span>&gt;           <span class="comment">// 十分之一</span></span><br><span class="line">deca    <span class="built_in">std</span>::ratio&lt;<span class="number">10</span>, <span class="number">1</span>&gt;           <span class="comment">// 十</span></span><br><span class="line">hecto   <span class="built_in">std</span>::ratio&lt;<span class="number">100</span>, <span class="number">1</span>&gt;          <span class="comment">// 百</span></span><br><span class="line">kilo    <span class="built_in">std</span>::ratio&lt;<span class="number">1000</span>, <span class="number">1</span>&gt;         <span class="comment">// 千</span></span><br></pre></td></tr></table></figure><p>比如我们想定义一个整数类型的100秒的时间间隔类型可以使用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">std</span>::chrono::duration&lt;<span class="keyword">int</span>, <span class="built_in">std</span>::ratio&lt;<span class="number">100</span>,<span class="number">1</span>&gt;&gt; my_duration_type;</span><br></pre></td></tr></table></figure><p>当然也可以简写成：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">std</span>::chrono::duration&lt;<span class="keyword">int</span>, <span class="built_in">std</span>::hecto&gt; my_duration_type;</span><br></pre></td></tr></table></figure><p>如果我们想定义一个整数类型1分钟的时间间隔类型可以写成：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">std</span>::chrono::duration&lt;<span class="keyword">int</span>, <span class="built_in">std</span>::ratio&lt;<span class="number">60</span>,<span class="number">1</span>&gt;&gt; my_minute_type;</span><br></pre></td></tr></table></figure><p>因为这种时、分、秒的时间表示在代码逻辑中很常用，所有在 <code>std::chrono</code> 命名空间下已经定义好了一些时间间隔类型:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">std::chrono::nanoseconds    duration&lt;/*signed integer type of at least 64 bits*/, std::nano&gt;</span><br><span class="line">std::chrono::microseconds   duration&lt;/*signed integer type of at least 55 bits*/, std::micro&gt;</span><br><span class="line">std::chrono::milliseconds   duration&lt;/*signed integer type of at least 45 bits*/, std::milli&gt;</span><br><span class="line">std::chrono::seconds        duration&lt;/*signed integer type of at least 35 bits*/&gt;</span><br><span class="line">std::chrono::minutes        duration&lt;/*signed integer type of at least 29 bits*/, std::ratio&lt;60&gt;&gt;</span><br><span class="line">std::chrono::hours          duration&lt;/*signed integer type of at least 23 bits*/, std::ratio&lt;3600&gt;&gt;</span><br></pre></td></tr></table></figure><p>另外还有一个很重要的成员函数 <code>count()</code>，用来获得指定的时间间隔对象中包含多少个时间周期，接下来可以写个例子理解一下，我们用 <code>duration</code> 这个模板类来表示一下5分钟和12小时，看看他应该怎么使用，对于5分钟你可以看成是 5 个 1 分钟或者 1 个 5 分钟，或者更变态你可以看成 2.5 个 2 分钟，而 12 小时一般会看成是 12个 1 小时，你当成 0.5 个 1 天也是可以的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 以下为5分钟表达</span></span><br><span class="line">    <span class="built_in">std</span>::chrono::minutes minute1&#123;<span class="number">5</span>&#125;; <span class="comment">// 5个1分钟</span></span><br><span class="line">    <span class="built_in">std</span>::chrono::duration&lt;<span class="keyword">int</span>, <span class="built_in">std</span>::ratio&lt;<span class="number">5</span>*<span class="number">60</span>, <span class="number">1</span>&gt;&gt; minute2&#123;<span class="number">1</span>&#125;; <span class="comment">// 1个5分钟</span></span><br><span class="line">    <span class="built_in">std</span>::chrono::duration&lt;<span class="keyword">double</span>, <span class="built_in">std</span>::ratio&lt;<span class="number">2</span>*<span class="number">60</span>, <span class="number">1</span>&gt;&gt; minute3&#123;<span class="number">2.5</span>&#125;; <span class="comment">// 2.5个2分钟</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;  <span class="string">"minutes1 duration has "</span> &lt;&lt; minute1.count() &lt;&lt; <span class="string">" ticks\n"</span></span><br><span class="line">              &lt;&lt;  <span class="string">"minutes2 duration has "</span> &lt;&lt; minute2.count() &lt;&lt; <span class="string">" ticks\n"</span></span><br><span class="line">              &lt;&lt;  <span class="string">"minutes3 duration has "</span> &lt;&lt; minute3.count() &lt;&lt; <span class="string">" ticks\n"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一下为12小时表达</span></span><br><span class="line">    <span class="built_in">std</span>::chrono::hours hours1&#123;<span class="number">12</span>&#125;; <span class="comment">// 12个1小时</span></span><br><span class="line">    <span class="built_in">std</span>::chrono::duration&lt;<span class="keyword">double</span>, <span class="built_in">std</span>::ratio&lt;<span class="number">60</span>*<span class="number">60</span>*<span class="number">24</span>, <span class="number">1</span>&gt;&gt; hours2&#123;<span class="number">0.5</span>&#125;; <span class="comment">// 0.5个1天</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;  <span class="string">"hours1 duration has "</span> &lt;&lt; hours1.count() &lt;&lt; <span class="string">" ticks\n"</span></span><br><span class="line">              &lt;&lt;  <span class="string">"hours2 duration has "</span> &lt;&lt; hours2.count() &lt;&lt; <span class="string">" ticks\n"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 std::chrono::duration_cast&lt;T&gt; 将分钟间隔转化成标准秒间隔</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;  <span class="string">"minutes1 duration has "</span> &lt;&lt;</span><br><span class="line">        <span class="built_in">std</span>::chrono::duration_cast&lt;<span class="built_in">std</span>::chrono::seconds&gt;(minute1).count() &lt;&lt; <span class="string">" seconds\n"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中还使用了 <code>std::chrono::duration_cast&lt;T&gt;()</code> 函数，用于各种时间间隔的换算，运行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">minutes1 duration has 5 ticks</span><br><span class="line">minutes2 duration has 1 ticks</span><br><span class="line">minutes3 duration has 2.5 ticks</span><br><span class="line">hours1 duration has 12 ticks</span><br><span class="line">hours2 duration has 0.5 ticks</span><br><span class="line">minutes1 duration has 300 seconds</span><br></pre></td></tr></table></figure><h2 id="clock"><a href="#clock" class="headerlink" title="clock"></a>clock</h2><p>从名字可以看出这个类叫做时钟，时钟是用来看时间和计时的，常用的两个类是 <code>system_clock</code> 和 <code>steady_clock</code>，在 <code>C++20</code> 标准中又加入了多种内容，现在我们先来看看这两个常用类。</p><p>从这一部分开始类的定义让人有些迷糊，其实 clock 引用了 <code>std::chrono::duration</code> 和后面要说的 <code>std::chrono::time_point</code>， 而 <code>std::chrono::time_point</code> 又引用了 <code>std::chrono::duration</code> 和现在要讲的 <code>std::chrono::system_clock</code>、 <code>std::chrono::steady_clock</code>，如果只看定义很容易被绕晕，所以还是先做个练习实验一下。</p><h3 id="system-clock"><a href="#system-clock" class="headerlink" title="system_clock"></a>system_clock</h3><p>这个类被称为系统内时钟，当修改系统时钟时可能会改变其单调递增的性质，静态成员函数有 <code>now()</code>、<code>to_time_t()</code>、<code>from_time_t()</code> 三个，关于它的单调性被修改举个例子，一般认为时间一直是递增的，但是当你现在调用一次函数 <code>now()</code>，然后把时间往过去调1天，然后再调用 <code>now()</code> 函数，就会发现新得到的时间“变小”了。</p><p>也因为这样它会受到 NTP（Network Time Protocol，网络时间协议）的影响，但是不会受时区和夏令时的影响（其实很多国家早就废除夏令时了）。</p><p>下面写个例子练习一下，例子中使用了 <code>now()</code>、<code>to_time_t()</code>、<code>from_time_t()</code> 三个函数，不清楚的时候可以对照一下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::chrono::duration&lt;<span class="keyword">int</span>, <span class="built_in">std</span>::ratio&lt;<span class="number">60</span>*<span class="number">60</span>*<span class="number">24</span>&gt; &gt; one_day(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据时钟得到现在时间</span></span><br><span class="line">    <span class="built_in">std</span>::chrono::system_clock::time_point today = <span class="built_in">std</span>::chrono::system_clock::now();</span><br><span class="line">    <span class="built_in">std</span>::<span class="keyword">time_t</span> time_t_today = <span class="built_in">std</span>::chrono::system_clock::<span class="keyword">to_time_t</span>(today);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;  <span class="string">"now time stamp is "</span> &lt;&lt; time_t_today &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;  <span class="string">"now time is "</span> &lt;&lt; ctime(&amp;time_t_today) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 看看明天的时间</span></span><br><span class="line">    <span class="built_in">std</span>::chrono::system_clock::time_point tomorrow = today + one_day;</span><br><span class="line">    <span class="built_in">std</span>::<span class="keyword">time_t</span> time_t_tomorrow = <span class="built_in">std</span>::chrono::system_clock::<span class="keyword">to_time_t</span>(tomorrow);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;  <span class="string">"tomorrow time stamp is "</span> &lt;&lt; time_t_tomorrow &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;  <span class="string">"tomorrow time is "</span> &lt;&lt; ctime(&amp;time_t_tomorrow) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算下个小时时间</span></span><br><span class="line">    <span class="built_in">std</span>::chrono::system_clock::time_point next_hour = today + <span class="built_in">std</span>::chrono::hours(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="keyword">time_t</span> time_t_next_hour = <span class="built_in">std</span>::chrono::system_clock::<span class="keyword">to_time_t</span>(next_hour);</span><br><span class="line">    <span class="built_in">std</span>::chrono::system_clock::time_point next_hour2 = <span class="built_in">std</span>::chrono::system_clock::<span class="keyword">from_time_t</span>(time_t_next_hour);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="keyword">time_t</span> time_t_next_hour2 = <span class="built_in">std</span>::chrono::system_clock::<span class="keyword">to_time_t</span>(next_hour2);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;  <span class="string">"tomorrow time stamp is "</span> &lt;&lt; time_t_next_hour2 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;  <span class="string">"tomorrow time is "</span> &lt;&lt; ctime(&amp;time_t_next_hour2) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">now time stamp is <span class="number">1586662332</span></span><br><span class="line">now time is Sun Apr <span class="number">12</span> <span class="number">11</span>:<span class="number">32</span>:<span class="number">12</span> <span class="number">2020</span></span><br><span class="line"></span><br><span class="line">tomorrow time stamp is <span class="number">1586748732</span></span><br><span class="line">tomorrow time is Mon Apr <span class="number">13</span> <span class="number">11</span>:<span class="number">32</span>:<span class="number">12</span> <span class="number">2020</span></span><br><span class="line"></span><br><span class="line">tomorrow time stamp is <span class="number">1586665932</span></span><br><span class="line">tomorrow time is Sun Apr <span class="number">12</span> <span class="number">12</span>:<span class="number">32</span>:<span class="number">12</span> <span class="number">2020</span></span><br></pre></td></tr></table></figure><h3 id="steady-clock"><a href="#steady-clock" class="headerlink" title="steady_clock"></a>steady_clock</h3><p>这是一个单调时钟，一旦启动之后就与系统时间没有关系了，完全根据物理是时间向前移动，成员函数只有一个 <code>now()</code>，通常可以用来计时，使用方法与 <code>system_clock</code> 相比简单许多，下面写个小例子。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 先记录程序运行时间</span></span><br><span class="line">    <span class="built_in">std</span>::chrono::steady_clock::time_point start = <span class="built_in">std</span>::chrono::steady_clock::now();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> nDstVal, nSrcVal;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000000</span>; ++i)</span><br><span class="line">        nDstVal = nSrcVal;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 做差值计算耗时</span></span><br><span class="line">    <span class="built_in">std</span>::chrono::duration&lt;<span class="keyword">double</span>&gt; duration_cost = <span class="built_in">std</span>::chrono::duration_cast&lt;</span><br><span class="line">        <span class="built_in">std</span>::chrono::duration&lt;<span class="keyword">double</span>&gt; &gt;(<span class="built_in">std</span>::chrono::steady_clock::now() - start);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;  <span class="string">"total cost "</span> &lt;&lt; duration_cost.count() &lt;&lt; <span class="string">" seconds."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">total cost 1.9424 seconds.</span><br></pre></td></tr></table></figure></p><h2 id="time-point"><a href="#time-point" class="headerlink" title="time point"></a>time point</h2><p>这个类与 <code>duration</code> 类似，同样是模板类，表示具体的时间点，比如今天 18:00 开饭，明天上午 10:00 发版本，今年 5 月 1 日可能因为疫情不让出去玩了，像这些具体的时间点可以使用 <code>std::chrono::time_point</code> 来表达，它的定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Clock</span>, <span class="title">class</span> <span class="title">Duration</span> = <span class="title">typename</span> <span class="title">Clock</span>:</span>:duration&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">time_point</span>;</span></span><br></pre></td></tr></table></figure><p>首先这个类是在 <code>std::chrono</code> 这个命名空间下，但是你会经常看到以下这种写法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::chrono::system_clock::time_point today = <span class="built_in">std</span>::chrono::system_clock::now();</span><br><span class="line"><span class="built_in">std</span>::chrono::steady_clock::time_point start = <span class="built_in">std</span>::chrono::steady_clock::now();</span><br></pre></td></tr></table></figure><p>好像 <code>time_point</code> 又在 <code>std::chrono::system_clock</code> 和 <code>std::chrono::steady_clock</code> 范围内，实际上这两个范围内的 <code>time_point</code> 引用的是 <code>std::chrono::time point</code>，看看 <code>std::chrono::system_clock</code> 的定义能明白一些。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">system_clock</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">using</span> rep = <span class="comment">/*see description*/</span> ;</span><br><span class="line">  <span class="keyword">using</span> period = ratio&lt;<span class="comment">/*unspecified*/</span>, <span class="comment">/*unspecified*/</span> &gt;;</span><br><span class="line">  <span class="keyword">using</span> duration = chrono::duration&lt;rep, period&gt;;</span><br><span class="line">  <span class="keyword">using</span> time_point = chrono::time_point&lt;system_clock&gt;;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">bool</span> is_steady = <span class="comment">/*unspecified*/</span> ;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> time_point <span class="title">now</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line">  <span class="comment">// Map to C API</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> time_t <span class="title">to_time_t</span> <span class="params">(<span class="keyword">const</span> time_point&amp; t)</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> time_point <span class="title">from_time_t</span><span class="params">(<span class="keyword">time_t</span> t)</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>对照上面的定义可以知道，<code>std::chrono::system_clock::time_point</code> 实际上 <code>std::chrono::time_point&lt;system_clock&gt;</code>，这几个时间类的定义相互引用，看到这一部分的时候一定不要烦躁，一步步推导分析其中的关系。</p><p><code>time_point</code> 这个类有一个成员函数 <code>time_since_epoch()</code> 用来获得 <code>1970-01-01 00:00:00</code> 到 <code>time_point</code> 时间经过的 <code>duration</code>, 返回的 <code>duration</code> 的单位取决于 <code>timepoint</code> 定义时的 <code>duraion</code> 的单位，不过你也可以得到 <code>duration</code> 之后使用 <code>std::chrono::duration_cast&lt;T&gt;()</code> 函数来转化。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 获得epoch 和 now 的时间点</span></span><br><span class="line">    <span class="built_in">std</span>::chrono::time_point&lt;<span class="built_in">std</span>::chrono::system_clock&gt; epoch =</span><br><span class="line">        <span class="built_in">std</span>::chrono::time_point&lt;<span class="built_in">std</span>::chrono::system_clock&gt;&#123;&#125;;</span><br><span class="line">    <span class="built_in">std</span>::chrono::time_point&lt;<span class="built_in">std</span>::chrono::system_clock&gt; now =</span><br><span class="line">        <span class="built_in">std</span>::chrono::system_clock::now();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显示时间点对应的日期和时间</span></span><br><span class="line">    <span class="keyword">time_t</span> epoch_time = <span class="built_in">std</span>::chrono::system_clock::<span class="keyword">to_time_t</span>(epoch);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"epoch: "</span> &lt;&lt; <span class="built_in">std</span>::ctime(&amp;epoch_time);</span><br><span class="line">    <span class="keyword">time_t</span> today_time = <span class="built_in">std</span>::chrono::system_clock::<span class="keyword">to_time_t</span>(now);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"today: "</span> &lt;&lt; <span class="built_in">std</span>::ctime(&amp;today_time);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显示duration的值</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"seconds since epoch: "</span></span><br><span class="line">        &lt;&lt; <span class="built_in">std</span>::chrono::duration_cast&lt;<span class="built_in">std</span>::chrono::seconds&gt;(epoch.time_since_epoch()).count()</span><br><span class="line">        &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"today, ticks since epoch: "</span></span><br><span class="line">        &lt;&lt; now.time_since_epoch().count()</span><br><span class="line">        &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"today, hours since epoch: "</span></span><br><span class="line">        &lt;&lt; <span class="built_in">std</span>::chrono::duration_cast&lt;<span class="built_in">std</span>::chrono::hours&gt;(now.time_since_epoch()).count()</span><br><span class="line">        &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">epoch: Thu Jan  1 08:00:00 1970</span><br><span class="line">today: Sun Apr 12 12:30:04 2020</span><br><span class="line">seconds since epoch: 0</span><br><span class="line">today, ticks since epoch: 1586665804624992500</span><br><span class="line">today, hours since epoch: 440740</span><br></pre></td></tr></table></figure><p>从运行结果来看，epoch 的时间点是 <code>Thu Jan  1 08:00:00 1970</code>，为什么不是 <code>1970-01-01 00:00:00</code> 呢？那是因为我们在东8区，格林威治时间为<br><code>1970-01-01 00:00:00</code> 的时候，我们的时间就是 <code>Thu Jan  1 08:00:00 1970</code>，这样看来 <code>std::ctime()</code> 这个函数考虑了时区的影响，相同的代码如果在韩国同时运行得到的可能就是 <code>epoch: Thu Jan  1 09:00:00 1970</code>。</p><h1 id="关于时间的思考"><a href="#关于时间的思考" class="headerlink" title="关于时间的思考"></a>关于时间的思考</h1><p>思考一个问题，时间是不是一种不变的量，或者换一种说法，它是不是一种均匀的量。如果了解过《三体》中的部分章节，你就会发现时间总在被任意改变着。但是在现实生活中好像时间就是一个标准，我们认为它是一成不变的，总是感觉今天的1天和昨天的24小时在时间上是等同的，今年的这一年和去年的365天是等同的，但其实你了解一下闰年、闰秒、夏令时就会发现，前面提到的这些未必等同。</p><p>日常生活中对时间的描述只是为了理解和阐明一些事物，我们把太阳升到头顶叫做中午，把地球自转一圈叫做一天24小时，把地球围绕太阳公转一圈叫做1年365天，但是地球自转不是那么均匀的，也就是说每转一圈占用的绝对时间是不一样的，我们现在使用的时钟通常是滴答滴答一秒秒的走着，如果地球自转一圈的时间不是完全相同的，那么建立在这个滴答上的一切时间都是不准确的。</p><p>什么是建立在滴答滴答上的时间，我们以滴答一次作为1秒来计算，那么1分钟是60秒，也就是滴答60次，1小时是60分钟，滴答3600次，一天是24小时，滴答86400次，滴答的次数是均匀的，但是自转和公转是不均匀的，那么两个时间就对不上了，所以出现了闰秒、闰年等方法来调整时间，使得我们用来描述生活的时间和周围的环境现象可以一致，不然大约几千年以后就会出现中午12点天上出现月亮的奇观，那时的人们在史书中会发现我们这个时代中午12点挂在天上的是太阳，简直太玄幻。</p><p>有没有一种计时可以描述这种不均匀的自转呢？其实我们伟大的古人早已经发明出来了，你一定听说过日晷这种计时工具，它是观测日影记时的仪器，主要是根据日影的在日晷面上的位置，以指定当时的时辰或刻数，是我国古代较为普遍使用的计时仪器。为什么它没有时间不一致的问题？因为它本身就是不均匀的，它是根据自然现象来规定生活中每天的时间的，其实对照现在来说就是每个时辰的滴答数实际上是不一样的。</p><p>日晷这种不均匀的计时其实是为了适应天文现象，方便人们的生产生活，所以说现在地球自转一圈是一天，但不一定是86400秒，地球公转一圈是一年，但不一定是365天，后来人们使用电子设备计时，按道理来说应该非常准确，但是因为地球自转、公转的速率都不稳定，这种差距渐渐地会给生活带来困扰，于是又发明了一个折中的协调世界时，会在适当的时候闰秒、闰天，以弥补这种差距。假如你买了一个绝对精准的不联网的电子计时器，但是几年之后你就会发现你的计时器肯定和大家使用的标准时间不一致了。</p><p>其实还有一种基于特定铯原子的振荡周期来确定的国际原子时，主要是在时间精度要求较高的航天、通讯、电子等领域，为了保持系统的连续性而使用的，在日常生活中基本不会使用，但是这个时间是相对恒定的，不会去计较天文现象，每一秒都“准确”的流逝着。</p><h1 id="时间函数思考"><a href="#时间函数思考" class="headerlink" title="时间函数思考"></a>时间函数思考</h1><p>现在回过头来再来看这些时间函数，是不是感觉有点不一样了，比如 <code>time(NULL)</code> 这个函数，它返回的是从 <code>1970-01-01 00:00:00</code> 到现在时间的秒数，回忆一下上面关于时间的思考，这个秒数真的是准确的吗？其实你如果理解了上面的内容就能得出结论，它肯定和国际原子时是有出入的。</p><p>再考虑下闰秒的影响，假如你实现了一个函数，第一次执行是在0点执行，执行之后你设置了一个86400秒的倒计时，也就是1天的时间，到第二天0点的时候正好又执行，你又设置了一个86400秒的倒计时，但今天正好是闰秒的日子，也就是今天会比昨天多1秒，那么今天的时间到23:59:59的时候就经过了86400秒，也就是说在23:59:59的时候就会执行你写的函数，如果碰到秒杀就尴尬了…</p><p>一般的程序开发不用太考虑闰秒的影响，但是如果这一秒的误差出现的宇宙飞船的飞行中，可能会导致几十公里的误差，所以程序员们一定要理解闰秒的可能带来的问题，评估自己所写的代码需不需要处理这种情况。曾经的一次闰秒直接导致了芬兰航空系统的瘫痪，所以一些大型项目还是会提前很长时间就把即将到来的闰秒处理写入到自己的系统中，以应对它带来的危险。</p><p>当你认为时间不会倒流的时候，它确实就发生了。我们一般假定时间不会倒流，但是如果你过分依赖这个特性，可能就会导致一些问题，这种情况常常出现设定了自动校准时间的电脑上，电脑的时间走快了，然后到达一定的差距后会触发校准程序，这时就会出现“时间倒流”的现象，比如 <code>time(NULL)</code> 这种依赖于电脑时间的函数，在这种情况下函数返回值就会变小，出现不单调性。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>关于时间的操作真的太多了，我居然发现一种名为 <code>operator&quot;&quot;h</code> 的操作符，与数字连用表示小时，有兴趣的话可以自己扩展学习一下。</li><li><code>durations</code>、<code>clocks</code> 和 <code>time points</code> 三种有关时间操作的定义相互之间是有引用的，需要理清其中的关系。</li><li>需要了解闰秒、闰年、天文时、原子时、协调时产生的原因，这样就可以做到熟悉原理，心里不慌。</li><li>在测试的例子中出现了时区的概念，其实是人们为了生产生活主动创造出来以适应自然现象的。</li><li>这里抛出一个疑问，我之前刚接触时晕乎了很久，后来渐渐才明白，有些时间函数的说明中会提到与时区无关，比如 <code>time(NULL)</code>、还有今天学习的 <code>system_clock</code>，但是当我修改电脑时区的时候会发现，这些函数的返回值会发生突变，大家有探究过其中的原因吗？</li></ul><hr><blockquote><p>我们都是追逐时间奔跑的蝼蚁，改变世界的同时也被时间改变着。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;时间都去哪了？还没好好感受年轻就…&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;时间是宝贵的，我们无时无刻不在和时间打交道，这个任务明天下班前截止，你点的外卖还有5分钟才能送到，那个程序已经运行了整整48个小时，既然时间和我们联系这么紧密，我们总要定义一些术语来描述它，像前面说到的明天下班前、5分钟、48个小时都是对时间的描述，程序代码构建的程序世界也需要定义一些术语来描述时间。&lt;/p&gt;
    
    </summary>
    
      <category term="C/C++" scheme="http://AlbertGithubHome.github.io/blog/categories/C-C/"/>
    
    
      <category term="C++" scheme="http://AlbertGithubHome.github.io/blog/tags/C/"/>
    
      <category term="C++11" scheme="http://AlbertGithubHome.github.io/blog/tags/C-11/"/>
    
      <category term="chrono" scheme="http://AlbertGithubHome.github.io/blog/tags/chrono/"/>
    
      <category term="时间" scheme="http://AlbertGithubHome.github.io/blog/tags/%E6%97%B6%E9%97%B4/"/>
    
  </entry>
  
  <entry>
    <title>Win10通过带命令行的安全模式清除顽固的广告弹窗文件</title>
    <link href="http://AlbertGithubHome.github.io/blog/2020/04/02/Win10%E9%80%9A%E8%BF%87%E5%B8%A6%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%9A%84%E5%AE%89%E5%85%A8%E6%A8%A1%E5%BC%8F%E6%B8%85%E9%99%A4%E9%A1%BD%E5%9B%BA%E7%9A%84%E5%B9%BF%E5%91%8A%E5%BC%B9%E7%AA%97%E6%96%87%E4%BB%B6/"/>
    <id>http://AlbertGithubHome.github.io/blog/2020/04/02/Win10通过带命令行的安全模式清除顽固的广告弹窗文件/</id>
    <published>2020-04-02T14:57:53.000Z</published>
    <updated>2020-04-06T15:05:30.015Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近电脑开机后偶尔会出现一个弹窗，这种广告弹窗见的多了也就麻木了，本来也没放在心上，随手一关就准备去做其他事情了，但是点击关闭按钮后这个广告弹窗居然还弹出了二次确认框，想想也忍了，毕竟广告商做半天就是为了让你多看几眼，当我用鼠标的光标接近这个确认按钮时，确认框消失了，整个广告页面居然还在！</p><a id="more"></a><p>一开始我还以为自己手滑点错了，后来试了3、4次之后发现，这个二次确认框从出来到消失不到1秒钟，以我的手速试了这么多次就没点到，这次暴脾气上来了，再也不忍了，我必须找到你是哪个软件的广告页，然后把你干掉！</p><h1 id="战斗经历"><a href="#战斗经历" class="headerlink" title="战斗经历"></a>战斗经历</h1><p>本以为找到软件直接卸载就完事了，没想到碰上硬茬了，这个软件大有来头，真不是随随便便能搞定的。</p><h2 id="查找广告来源"><a href="#查找广告来源" class="headerlink" title="查找广告来源"></a>查找广告来源</h2><p>这一步比较简单，这个打开的广告页在任务栏上有个图标，鼠标光标放到图标上会显示缩略图，就像下面这样：</p><p><img src="https://cdn.jsdelivr.net/gh/albertgithubhome/cdn/img/cmddel1.png" alt="cmddel1"></p><p>在图标上单击右键，然后在弹出菜单中将光标移到最上面的选项继续单击右键，这时会在弹出一个菜单，如果一次不行就多试几次：</p><p><img src="https://cdn.jsdelivr.net/gh/albertgithubhome/cdn/img/cmddel2.png" alt="cmddel2"></p><p>这时点击菜单上的属性按钮会弹出这个广告页对应程序的属性页面：</p><p><img src="https://cdn.jsdelivr.net/gh/albertgithubhome/cdn/img/cmddel3.png" alt="cmddel3"></p><h2 id="开始删除程序"><a href="#开始删除程序" class="headerlink" title="开始删除程序"></a>开始删除程序</h2><p>让我找到你了吧，目录是 <code>D:\Program Files (x86)\MyDrivers\DriverGenius\ksoft</code>，看来是驱动精灵软件带来的广告页，直接进入目录删除：</p><p><img src="https://cdn.jsdelivr.net/gh/albertgithubhome/cdn/img/cmddel7.png" alt="cmddel4"></p><p>尴尬！提示“你需要提供管理员权限才能删除此文件”，点击“继续”按钮试试：</p><p><img src="https://cdn.jsdelivr.net/gh/albertgithubhome/cdn/img/cmddel8.png" alt="cmddel5"></p><p>依旧不行，提示“你需要权限执行此操作”、“你需要Administrators提供的权限才能对此文件进行更改”，真是有点诡异，一个普通软件居然还要管理员权限才能删。</p><h2 id="找管理员帮忙"><a href="#找管理员帮忙" class="headerlink" title="找管理员帮忙"></a>找管理员帮忙</h2><p>没办法了，提权吧！我把沉睡的管理员账号的都开启了，再试一次还是不行，我可是 Administrator 啊，在这个电脑中还有什么是我不能干的吗？</p><blockquote><p>微软：“你能干什么你说了不算，我说了算！”。</p></blockquote><p>右键单击软件查看属性是不是只读了呢？没有啊！这时我还没意识到它究竟有多难缠，以为简简单单设置几个属性就能把它删掉，于是一拍脑袋决定，这种情况下一般需要修改权限啊，然后在属性面板中点击了“安全”选项卡：</p><p><img src="https://cdn.jsdelivr.net/gh/albertgithubhome/cdn/img/cmddel4.png" alt="cmddel6"></p><p>然后点击“高级按钮”，弹出了很多教程中都给出的界面，长成下面这个样子：</p><p><img src="https://cdn.jsdelivr.net/gh/albertgithubhome/cdn/img/cmddel5.png" alt="cmddel7"></p><p>这时要点击“更改”开始修改权限了，接着神奇的一幕发生了，当前界面一闪没有弹出修改界面，而原来的“更改”两个字也变成灰色不能再使用了。</p><p><img src="https://cdn.jsdelivr.net/gh/albertgithubhome/cdn/img/cmddel6.png" alt="cmddel8"></p><p>有点慌了啊，试试命令行吧，一个 <code>del</code> 强制删除试试，丝毫未动，删除请求被拒绝了：</p><p><img src="https://cdn.jsdelivr.net/gh/albertgithubhome/cdn/img/cmddel9.png" alt="cmddel9"></p><p>再试试别的文件，删除一个失败，再试一个又失败，最后发现这个文件夹中，我连个日志文件都删不掉，不仅发出了灵魂拷问，我真的是管理员吗？我的 <code>Administrator</code> 不会是假的吧？打开文件夹左看看、右看看没有发现什么可疑的地方，忽然我发现文件夹外面一层有个齿轮，难道被当成系统配置了，这是什么骚操作？</p><p><img src="https://cdn.jsdelivr.net/gh/albertgithubhome/cdn/img/cmddel9_1.png" alt="cmddel9_1"></p><p>看来我的电脑已经被这个软件给控制住了，一个做驱动的，在操作系统启动时早早的被唤醒，牢牢的控制住了局面，设置了一道道钩子，将可能影响到的它生存的途径全部堵死，这可能就是我修改权限时，界面闪了一下就再也修改不了的原因吧。</p><p>之前还碰到过一个软件比较坑，也是不让删除，在任务管理器强行关闭时会提示拒绝访问，最后发现一个名称比较相似的服务一直在启动着，然后尝试关闭这个服务，结果有趣的事情发生了，只要我点禁用服务一刷新，它又会重启，不知道还有哪个匿名的进程在默默的帮助它。</p><h2 id="进入安全模式"><a href="#进入安全模式" class="headerlink" title="进入安全模式"></a>进入安全模式</h2><p>没办法了，本来想快速解决战斗，改改权限后直接删除了，哪里想到它这么顽强，既然是涉及到了驱动，谁知道你在系统启动时搞了什么鬼，我就在另一个世界把你搞掉吧，从安全模式启动，让你原来的小算盘只能在硬盘里乖乖的躺着了，说到这怎么有一种从四维空间看三维世界的感觉。</p><p>关于怎么进入安全模式的命令行，之前在XP和Win7上好像是开机就可以选，在Win10上开机没有看到，之前也没操作过，不过网络上有大量的教程，我发现其中有两个比较有意思的，一个是要我用U盘做系统盘，然后假装给电脑做系统，在配置界面打开命令行进行设置然后重启，这有点太麻烦了吧。</p><p>还有一种更好玩就是让你在电脑启动的时候直接按电源键关机，反复尝试2-3次等电脑感觉到自己异常了，就能看到安全模式的选项了，这就好比让你借梯子你借不到，就在家里放了把火，结果借来了消防队的云梯，有可能损失惨重啊。</p><p>这里说一个我感觉最简单的方法吧，使用 <code>Win+R</code> 组合键，调出 windows 运行窗口，然后输入 <code>shutdown /r /o</code>，回车等着电脑重启就可以了。</p><p><img src="https://cdn.jsdelivr.net/gh/albertgithubhome/cdn/img/cmddel10_1.png" alt="cmddel10"></p><p>接着电脑会出现下面这个画面，选择其中的“疑难解答”选项：</p><p><img src="https://cdn.jsdelivr.net/gh/albertgithubhome/cdn/img/cmddel11.png" alt="cmddel11"></p><p>然后界面变化进入下面展示的“高级选项”界面，选择其中的“启动设置”选项：</p><p><img src="https://cdn.jsdelivr.net/gh/albertgithubhome/cdn/img/cmddel12.png" alt="cmddel12"></p><p>最后在启动设置的详细界面上选择“重启”按钮，短暂运行之后，电脑上开始出现下面的选项：</p><p><img src="https://cdn.jsdelivr.net/gh/albertgithubhome/cdn/img/cmddel13.png" alt="cmddel13"></p><p>这时就可以选择进入系统的模式了，使用 <code>F1~F9</code> 来进行选择，<code>F4</code> 就是进入安全模式，不加载多余的驱动，<code>F6</code> 是带命令提示符的安全模式：</p><p><img src="https://cdn.jsdelivr.net/gh/albertgithubhome/cdn/img/cmddel14.png" alt="cmddel14"></p><p>我们可以按键盘上的 <code>F6</code> 选择带命令提示符的安全模式，然后界面上就出现了下面这个“黑框框”：</p><p><img src="https://cdn.jsdelivr.net/gh/albertgithubhome/cdn/img/cmddel15.png" alt="cmddel15"></p><h2 id="彻底删除文件"><a href="#彻底删除文件" class="headerlink" title="彻底删除文件"></a>彻底删除文件</h2><p>有了黑框框就可以删除文件，先通过 <code>cd</code> 命令进入待删除文件所在目录，然后使用 <code>del</code> 命令删除文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">C:\Windows\System32&gt;d:</span><br><span class="line"></span><br><span class="line">D:\&gt;<span class="built_in">cd</span> <span class="string">"Program Files (x86)\MyDrivers\DriverGenius\ksoft"</span></span><br><span class="line"></span><br><span class="line">D:\Program Files (x86)\MyDrivers\DriverGenius\ksoft&gt;del /f znb.exe</span><br></pre></td></tr></table></figure><p>没有任何报错，世界都安静了，输入 <code>shutdown /r /t 0</code> 重启电脑，正常进入操作系统，这时就会发现刚刚统治了我的电脑的可执行程序，已经被我干掉不存在了。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>这些顽固广告真是厉害，一般删除文件的办法还真删不掉它们。</li><li>不光普通方法删不掉，连一些“流氓卫士”的文件粉碎功能都拿它们没办法。</li><li>不过电脑毕竟在用户手中，总有一些非常规办法可以干掉这些不正常的文件。</li><li>修理电脑时没有什么是重启电脑不能解决的，如果真的有，那就请你重装系统。</li></ul><hr><blockquote><p>别放弃，坚持朝着目标一步一步的走就好了~</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;最近电脑开机后偶尔会出现一个弹窗，这种广告弹窗见的多了也就麻木了，本来也没放在心上，随手一关就准备去做其他事情了，但是点击关闭按钮后这个广告弹窗居然还弹出了二次确认框，想想也忍了，毕竟广告商做半天就是为了让你多看几眼，当我用鼠标的光标接近这个确认按钮时，确认框消失了，整个广告页面居然还在！&lt;/p&gt;
    
    </summary>
    
      <category term="windows" scheme="http://AlbertGithubHome.github.io/blog/categories/windows/"/>
    
    
      <category term="Win10" scheme="http://AlbertGithubHome.github.io/blog/tags/Win10/"/>
    
      <category term="del" scheme="http://AlbertGithubHome.github.io/blog/tags/del/"/>
    
      <category term="exe" scheme="http://AlbertGithubHome.github.io/blog/tags/exe/"/>
    
  </entry>
  
  <entry>
    <title>git stash帮你在切换分支前暂存不想提交的修改</title>
    <link href="http://AlbertGithubHome.github.io/blog/2020/03/25/git-stash%E5%B8%AE%E4%BD%A0%E5%9C%A8%E5%88%87%E6%8D%A2%E5%88%86%E6%94%AF%E5%89%8D%E6%9A%82%E5%AD%98%E4%B8%8D%E6%83%B3%E6%8F%90%E4%BA%A4%E7%9A%84%E4%BF%AE%E6%94%B9/"/>
    <id>http://AlbertGithubHome.github.io/blog/2020/03/25/git-stash帮你在切换分支前暂存不想提交的修改/</id>
    <published>2020-03-25T15:27:38.000Z</published>
    <updated>2020-03-29T06:36:50.512Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>偶然间发现这个命令，正好解决了最近遇到的问题，使用 <code>Git</code> 管理代码时有这样一种场景，你正在分支 <code>branch2</code> 上开发新功能，突然刚刚提交测试的 <code>branch1</code> 分支上报了严重的BUG，需要尽快修改，这时候就需要切换到 <code>branch1</code> 分支上去修复BUG，但是你刚刚在分支 <code>branch2</code> 修改的文件还没有提交，接下来该怎么办？</p><a id="more"></a><p>如果本地的修改正好到达一个比较完整的阶段，可以直接提交，然后切换分支改BUG，那再好不过了。可是发生这种情况的时候往往是函数写了一半，或者功能大致写完但是还没来得及测试，这样的代码你敢提交吗？我感觉最好还是不要提交吧，那么如果这时候切换分支会有什么后果呢？一般会遇到两种情况：第一种是你在 <code>branch2</code> 分支上所做的修改与 <code>branch1</code> 上做过的修改不冲突，这时切换分支会将本地修改带到 <code>branch1</code> 分支，如果冲突了就是第二种情况，<code>git checkout branch1</code> 命令会被拒绝，当然你可以添加 <code>-f</code> 参数强行切换分支是能成功切换的，代价就是你会丢掉本地的所有修改。</p><h1 id="git-stash"><a href="#git-stash" class="headerlink" title="git stash"></a>git stash</h1><p>上面提到的切换分支时遇到的两种情况一般都不是我们想要的，之前说过“在 <code>Git</code> 中没有真正的方法来做任何事情，这就是它的妙处！”，但是关于切换分支有这样一个建议，那就是在切换分支时尽量保证你的工作区和暂存区是干净的，而 <code>git stash</code> 命令就是用来做这件事的。</p><p>当我们遇到这种状况，本地的修改我不能提交，不想带到新切换的分支，更不想直接丢掉，只想把他们暂存到一个地方，等我切换完分支修改好BUG，再切换回来迎接他们。使用 <code>SVN</code> 想保存本地修改可以使用 <code>patch</code>，而使用 <code>Git</code> 想要解决这种情况更加方便，那就是利用 <code>git stash</code> 命令。</p><h1 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h1><p>这个命令的使用方法非常简单，最常用的 <code>git stash push</code> 和 <code>git stash pop</code> 就能应付大部分情况了，其中 <code>push</code> 这个单词还可以省略，使用起来可以说是相当方便了，接下来尝试一下具体用法。</p><h2 id="本地有修改时切换分支的两种情况"><a href="#本地有修改时切换分支的两种情况" class="headerlink" title="本地有修改时切换分支的两种情况"></a>本地有修改时切换分支的两种情况</h2><p>之前提到过这两种情况，一种是将当前分支修改带到要切换的分支，另一种是切换会导致冲突，本次切换操作被拒绝，下面具体操作一下。</p><h3 id="将当前分支修改带到要切换的分支"><a href="#将当前分支修改带到要切换的分支" class="headerlink" title="将当前分支修改带到要切换的分支"></a>将当前分支修改带到要切换的分支</h3><p>首先以 <code>dev</code> 分支为基础新建 <code>feature</code> 分支</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">albert@homepc MINGW64 /d/gitstart (dev)</span><br><span class="line">$ git status</span><br><span class="line">On branch dev</span><br><span class="line">Your branch is up to date with <span class="string">'origin/dev'</span>.</span><br><span class="line"></span><br><span class="line">nothing to commit, working tree clean</span><br><span class="line"></span><br><span class="line">albert@homepc MINGW64 /d/gitstart (dev)</span><br><span class="line">$ git checkout -b feature</span><br><span class="line">Switched to a new branch <span class="string">'feature'</span></span><br></pre></td></tr></table></figure><p>在 <code>feature</code> 分支上修改文件，再切换回 <code>dev</code> 分支，可以正常切换，<code>git status</code> 查看状态，发现修改的文件被带到了 <code>dev</code> 分支上</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">albert@homepc MINGW64 /d/gitstart (feature)</span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">"test checkout"</span>&gt;&gt;README.md</span><br><span class="line"></span><br><span class="line">albert@homepc MINGW64 /d/gitstart (feature)</span><br><span class="line">$ git status</span><br><span class="line">On branch feature</span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">"git restore &lt;file&gt;..."</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line">        modified:   README.md</span><br><span class="line"></span><br><span class="line">no changes added to commit (use <span class="string">"git add"</span> and/or <span class="string">"git commit -a"</span>)</span><br><span class="line"></span><br><span class="line">albert@homepc MINGW64 /d/gitstart (feature)</span><br><span class="line">$ git checkout dev</span><br><span class="line">Switched to branch <span class="string">'dev'</span></span><br><span class="line">M       README.md</span><br><span class="line">Your branch is up to date with <span class="string">'origin/dev'</span>.</span><br><span class="line"></span><br><span class="line">albert@homepc MINGW64 /d/gitstart (dev)</span><br><span class="line">$ git status</span><br><span class="line">On branch dev</span><br><span class="line">Your branch is up to date with <span class="string">'origin/dev'</span>.</span><br><span class="line"></span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">"git restore &lt;file&gt;..."</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line">        modified:   README.md</span><br><span class="line"></span><br><span class="line">no changes added to commit (use <span class="string">"git add"</span> and/or <span class="string">"git commit -a"</span>)</span><br></pre></td></tr></table></figure><p>这里要注意一点，在切换到 <code>dev</code> 分支的时候，有一行 <code>M       README.md</code>的内容，表示这个文件在切换过来的时候就是修改的。</p><p>如果你想要的效果就是这样，就可以直接提交了，比如修改了代码发现分支弄错了，可以这样带着修改的内容切换分支，假设就是这种情况，我们直接在 <code>dev</code> 分支提交修改。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">albert@homepc MINGW64 /d/gitstart (dev)</span><br><span class="line">$ git add README.md</span><br><span class="line"></span><br><span class="line">albert@homepc MINGW64 /d/gitstart (dev)</span><br><span class="line">$ git commit -m<span class="string">"add comments"</span></span><br><span class="line">[dev 5f4181e] add comments</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line">git</span><br><span class="line">albert@homepc MINGW64 /d/gitstart (dev)</span><br><span class="line">$ git status</span><br><span class="line">On branch dev</span><br><span class="line">Your branch is ahead of <span class="string">'origin/dev'</span> by 1 commit.</span><br><span class="line">  (use <span class="string">"git push"</span> to publish your <span class="built_in">local</span> commits)</span><br><span class="line"></span><br><span class="line">nothing to commit, working tree clean</span><br></pre></td></tr></table></figure><h3 id="切换分支操作被拒绝"><a href="#切换分支操作被拒绝" class="headerlink" title="切换分支操作被拒绝"></a>切换分支操作被拒绝</h3><p>上面一种情况，在 <code>feature</code> 分支的修改被带到 <code>dev</code> 分支提交，我们在此基础上切换回 <code>feature</code> 分支看一下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">albert@homepc MINGW64 /d/gitstart (dev)</span><br><span class="line">$ git checkout feature</span><br><span class="line">Switched to branch <span class="string">'feature'</span></span><br><span class="line"></span><br><span class="line">albert@homepc MINGW64 /d/gitstart (feature)</span><br><span class="line">$ git status</span><br><span class="line">On branch feature</span><br><span class="line">nothing to commit, working tree clean</span><br></pre></td></tr></table></figure><p>发现此时 <code>feature</code> 分支上没有任何修改了，我们再改一次，然后切换到 <code>dev</code> 分支上试试：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">albert@homepc MINGW64 /d/gitstart (feature)</span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">"second try"</span>&gt;&gt;README.md</span><br><span class="line"></span><br><span class="line">albert@homepc MINGW64 /d/gitstart (feature)</span><br><span class="line">$ git status</span><br><span class="line">On branch feature</span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">"git restore &lt;file&gt;..."</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line">        modified:   README.md</span><br><span class="line"></span><br><span class="line">no changes added to commit (use <span class="string">"git add"</span> and/or <span class="string">"git commit -a"</span>)</span><br><span class="line"></span><br><span class="line">albert@homepc MINGW64 /d/gitstart (feature)</span><br><span class="line">$ git checkout dev</span><br><span class="line">error: Your <span class="built_in">local</span> changes to the following files would be overwritten by checkout:</span><br><span class="line">        README.md</span><br><span class="line">Please commit your changes or stash them before you switch branches.</span><br><span class="line">Aborting</span><br></pre></td></tr></table></figure><p>看到了吧，切换分支的操作被拒绝了，原因是这次切换可能导致本地的修改被覆盖，你可以在切换分支前尝试 <code>commit</code> 你的修改或者 <code>stash</code> 你的修改，等等，这里出现了 <code>stash</code> 这个单词，其实之前我都没注意到，不是修改好提交了就是直接加 <code>-f</code> 参数放弃了所做的修改，没想到还有这样神奇 <code>stash</code> 命令帮我渡过难关。</p><h2 id="stash-一般操作"><a href="#stash-一般操作" class="headerlink" title="stash 一般操作"></a><code>stash</code> 一般操作</h2><p>接下来展示一下 <code>git stash</code> 最常用的操作，也就是标题中提到的——在切换分支前暂存不想提交的修改，继续在上面的环境下操作，现在 <code>feature</code><br> 分支上修改了 <code>README.md</code> 文件，切换到 <code>dev</code> 分支时因为可能产生冲突而被拒绝，我们先来看一下文件状态。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">albert@homepc MINGW64 /d/gitstart (feature)</span><br><span class="line">$ git status</span><br><span class="line">On branch feature</span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">"git restore &lt;file&gt;..."</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line">        modified:   README.md</span><br><span class="line"></span><br><span class="line">no changes added to commit (use <span class="string">"git add"</span> and/or <span class="string">"git commit -a"</span>)</span><br><span class="line"></span><br><span class="line">albert@homepc MINGW64 /d/gitstart (feature)</span><br><span class="line">$ git diff</span><br><span class="line">warning: LF will be replaced by CRLF <span class="keyword">in</span> README.md.</span><br><span class="line">The file will have its original line endings <span class="keyword">in</span> your working directory</span><br><span class="line">diff --git a/README.md b/README.md</span><br><span class="line">index 76a124a..4c2bfb8 100644</span><br><span class="line">--- a/README.md</span><br><span class="line">+++ b/README.md</span><br><span class="line">@@ -1,2 +1,3 @@</span><br><span class="line"> learn git branch <span class="built_in">command</span></span><br><span class="line"> m2</span><br><span class="line">+second try</span><br></pre></td></tr></table></figure><h3 id="存储临时修改"><a href="#存储临时修改" class="headerlink" title="存储临时修改"></a>存储临时修改</h3><p>对比显示我们增加了一行，然后执行 <code>git stash</code> 命令，再查看一下文件状态：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">albert@homepc MINGW64 /d/gitstart (feature)</span><br><span class="line">$ git stash</span><br><span class="line">warning: LF will be replaced by CRLF <span class="keyword">in</span> README.md.</span><br><span class="line">The file will have its original line endings <span class="keyword">in</span> your working directory</span><br><span class="line">Saved working directory and index state WIP on feature: 6ae97d0 Revert <span class="string">"modify README 1"</span></span><br><span class="line"></span><br><span class="line">albert@homepc MINGW64 /d/gitstart (feature)</span><br><span class="line">$ git status</span><br><span class="line">On branch feature</span><br><span class="line">nothing to commit, working tree clean</span><br></pre></td></tr></table></figure><p>执行完 <code>git stash</code> 之后我们发现，刚才的修改不见了，本地状态提示为 <code>nothing to commit, working tree clean</code>，这时我们再来切换分支：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">albert@homepc MINGW64 /d/gitstart (feature)</span><br><span class="line">$ git checkout dev</span><br><span class="line">Switched to branch <span class="string">'dev'</span></span><br><span class="line">Your branch is ahead of <span class="string">'origin/dev'</span> by 1 commit.</span><br><span class="line">  (use <span class="string">"git push"</span> to publish your <span class="built_in">local</span> commits)</span><br><span class="line"></span><br><span class="line">albert@homepc MINGW64 /d/gitstart (dev)</span><br><span class="line">$ git status</span><br><span class="line">On branch dev</span><br><span class="line">Your branch is ahead of <span class="string">'origin/dev'</span> by 1 commit.</span><br><span class="line">  (use <span class="string">"git push"</span> to publish your <span class="built_in">local</span> commits)</span><br><span class="line"></span><br><span class="line">nothing to commit, working tree clean</span><br></pre></td></tr></table></figure><p>这次切换就没有被拒绝，成功的切换到了 <code>dev</code> 分支，你可以在 <code>dev</code> 分支上进行想要的操作，全部操作完成后再切换回 <code>feature</code> 分支，我们这里就不操作了，直接切回 <code>feature</code> 分支查看一下状态：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">albert@homepc MINGW64 /d/gitstart (dev)</span><br><span class="line">$ git checkout feature</span><br><span class="line">Switched to branch <span class="string">'feature'</span></span><br><span class="line"></span><br><span class="line">albert@homepc MINGW64 /d/gitstart (feature)</span><br><span class="line">$ git status</span><br><span class="line">On branch feature</span><br><span class="line">nothing to commit, working tree clean</span><br></pre></td></tr></table></figure><h3 id="还原临时修改"><a href="#还原临时修改" class="headerlink" title="还原临时修改"></a>还原临时修改</h3><p>我们看到工作区很干净，这时如果想还原刚才在 <code>feature</code> 分支的修改，可以使用 <code>git stash pop</code> 命令，我们执行一下然后查看状态：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">albert@homepc MINGW64 /d/gitstart (feature)</span><br><span class="line">$ git stash pop</span><br><span class="line">On branch feature</span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">"git restore &lt;file&gt;..."</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line">        modified:   README.md</span><br><span class="line"></span><br><span class="line">no changes added to commit (use <span class="string">"git add"</span> and/or <span class="string">"git commit -a"</span>)</span><br><span class="line">Dropped refs/stash@&#123;0&#125; (bd500adb74d57a3d916a89ff2cd4536cf4eaf6ae)</span><br><span class="line"></span><br><span class="line">albert@homepc MINGW64 /d/gitstart (feature)</span><br><span class="line">$ git status</span><br><span class="line">On branch feature</span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">"git restore &lt;file&gt;..."</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line">        modified:   README.md</span><br><span class="line"></span><br><span class="line">no changes added to commit (use <span class="string">"git add"</span> and/or <span class="string">"git commit -a"</span>)</span><br></pre></td></tr></table></figure><p>刚刚被临时暂存的修改又恢复了，我们可以在 <code>feature</code> 分支上继续愉快地开发了。</p><h2 id="stash-进阶操作"><a href="#stash-进阶操作" class="headerlink" title="stash 进阶操作"></a><code>stash</code> 进阶操作</h2><p>作为这么神奇的命令，<code>stash</code> 肯定不止这么一点点用法，接下来再列举几个较为常用的参数组合：</p><h3 id="查看临时存储的所有条目-git-stash-list"><a href="#查看临时存储的所有条目-git-stash-list" class="headerlink" title="查看临时存储的所有条目 git stash list"></a>查看临时存储的所有条目 <code>git stash list</code></h3><p>当你使用几次 <code>git stash</code> 命令之后就会发现，这个命令有点像建立还原点，所以暂存命令不止可以用一次，当使用多次暂存命令之后就会形成一个暂存列表，这时可以使用 <code>git stash list</code> 命令查看所有的暂存操作，执行命令后大概就是下面的样子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">albert@homepc MINGW64 /d/gitstart (feature)</span><br><span class="line">$ git stash list</span><br><span class="line">stash@&#123;0&#125;: WIP on feature: 84dfd79 add <span class="built_in">test</span> file</span><br><span class="line">stash@&#123;1&#125;: WIP on feature: 6ae97d0 Revert <span class="string">"modify README 1"</span></span><br></pre></td></tr></table></figure><p>这个列表的构成很像一个栈，<code>stash@{0}</code> 是栈顶元素，<code>stash@{1}</code> 是栈顶下面的一个元素，当使用 <code>git stash</code> 命令时会把新的临时存储信息压入栈顶，原来的信息向栈底移动，当使用 <code>git stash pop</code> 命令的时候又会把栈顶的元素弹出，恢复到工作区和暂存区。</p><h3 id="临时存储未追踪的新文件-git-stash-u"><a href="#临时存储未追踪的新文件-git-stash-u" class="headerlink" title="临时存储未追踪的新文件 git stash -u"></a>临时存储未追踪的新文件 <code>git stash -u</code></h3><p>在开发过程中新添加的文件不属于任何一个分支，在不冲突的文件情况下也可以在切换分支的时候带到新的分支，默认在使用 <code>git stash</code> 命令的时候不会把这些文件临时存起来，如果想要存起来加上 <code>-u</code> 参数就可以了，执行之后你会发现这个新加的文件在工作区中消失了。</p><h3 id="临时存储被忽略的文件-git-stash-a"><a href="#临时存储被忽略的文件-git-stash-a" class="headerlink" title="临时存储被忽略的文件 git stash -a"></a>临时存储被忽略的文件 <code>git stash -a</code></h3><p>被忽略的文件在默认情况下也不会被 <code>git stash</code> 命令存储，想要临时存储这部分文件只要使用 <code>-a</code> 参数就可以了，这样不仅会把忽略的文件临时存储，连未追踪的文件也存储了起来。</p><h2 id="stash-操作的标号"><a href="#stash-操作的标号" class="headerlink" title="stash 操作的标号"></a><code>stash</code> 操作的标号</h2><p>前面的 <code>git stash list</code> 命令也提到了，使用 <code>git stash</code> 命令的结果会形成一个栈形式的列表，其中 <code>stash@{n}</code> 就是每次临时存储对应的标号，针对于这些标号的操作也有很多，如果不加这些标号默认使用 <code>stash@{0}</code> ，也就是栈顶元素。</p><h3 id="查看临时修改的具体内容-git-stash-show-stash-0"><a href="#查看临时修改的具体内容-git-stash-show-stash-0" class="headerlink" title="查看临时修改的具体内容 git stash show stash@{0}"></a>查看临时修改的具体内容 <code>git stash show stash@{0}</code></h3><p>这个查询过程和查询提交日志的形式有点像，主要展示了某次临时存储时改了哪些内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">albert@homepc MINGW64 /d/gitstart (feature)</span><br><span class="line">$ git stash show stash@&#123;0&#125;</span><br><span class="line"> test.txt | 1 +</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line"></span><br><span class="line">albert@homepc MINGW64 /d/gitstart (feature)</span><br><span class="line">$ git stash show stash@&#123;1&#125;</span><br><span class="line"> README.md | 1 +</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br></pre></td></tr></table></figure><h3 id="恢复指定标号的临时修改-git-stash-apply-stash-0"><a href="#恢复指定标号的临时修改-git-stash-apply-stash-0" class="headerlink" title="恢复指定标号的临时修改 git stash apply stash@{0}"></a>恢复指定标号的临时修改 <code>git stash apply stash@{0}</code></h3><p>在恢复临时存储的修改时不仅可以使用 <code>git stash pop</code> 命令来恢复栈顶那一次修改，也可以按照标号恢复指定的某次修改，测试如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">albert@homepc MINGW64 /d/gitstart (feature)</span><br><span class="line">$ git stash apply stash@&#123;1&#125;</span><br><span class="line">On branch feature</span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">"git restore &lt;file&gt;..."</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line">        modified:   README.md</span><br><span class="line"></span><br><span class="line">no changes added to commit (use <span class="string">"git add"</span> and/or <span class="string">"git commit -a"</span>)</span><br><span class="line"></span><br><span class="line">albert@homepc MINGW64 /d/gitstart (feature)</span><br><span class="line">$ git stash list</span><br><span class="line">stash@&#123;0&#125;: WIP on feature: 84dfd79 add <span class="built_in">test</span> file</span><br><span class="line">stash@&#123;1&#125;: WIP on feature: 6ae97d0 Revert <span class="string">"modify README 1"</span></span><br><span class="line"></span><br><span class="line">albert@homepc MINGW64 /d/gitstart (feature)</span><br><span class="line">$ git stash apply stash@&#123;1&#125;</span><br><span class="line">error: Your <span class="built_in">local</span> changes to the following files would be overwritten by merge:</span><br><span class="line">        README.md</span><br><span class="line">Please commit your changes or stash them before you merge.</span><br><span class="line">Aborting</span><br></pre></td></tr></table></figure><p>这个命令在执行后，指定标号的修改会被恢复到工作区和暂存区，但是临时存储的列表不会被删除，这时可以尝试再次恢复相同标号的修改到工作区，你会发现本次操作因为修改了相同的文件而被拒绝。</p><h3 id="刪除指定标号的临时存储的修改-git-stash-drop-stash-0"><a href="#刪除指定标号的临时存储的修改-git-stash-drop-stash-0" class="headerlink" title="刪除指定标号的临时存储的修改 git stash drop stash@{0}"></a>刪除指定标号的临时存储的修改 <code>git stash drop stash@{0}</code></h3><p>可以在临时存储列表中删除指定标号的一些修改，可以测试一下看看效果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">albert@homepc MINGW64 /d/gitstart (feature)</span><br><span class="line">$ git stash list</span><br><span class="line">stash@&#123;0&#125;: WIP on feature: 84dfd79 add <span class="built_in">test</span> file</span><br><span class="line">stash@&#123;1&#125;: WIP on feature: 6ae97d0 Revert <span class="string">"modify README 1"</span></span><br><span class="line"></span><br><span class="line">albert@homepc MINGW64 /d/gitstart (feature)</span><br><span class="line">$ git stash drop stash@&#123;1&#125;</span><br><span class="line">Dropped stash@&#123;1&#125; (8408e56305fabcd82c1d05db18e177c89c47c5ac)</span><br><span class="line"></span><br><span class="line">albert@homepc MINGW64 /d/gitstart (feature)</span><br><span class="line">$ git stash list</span><br><span class="line">stash@&#123;0&#125;: WIP on feature: 84dfd79 add <span class="built_in">test</span> file</span><br></pre></td></tr></table></figure><h3 id="利用临时存储的修改内容新建分支-git-stash-branch-lt-branchname-gt-lt-stash-gt"><a href="#利用临时存储的修改内容新建分支-git-stash-branch-lt-branchname-gt-lt-stash-gt" class="headerlink" title="利用临时存储的修改内容新建分支 git stash branch &lt;branchname&gt; [&lt;stash&gt;]"></a>利用临时存储的修改内容新建分支 <code>git stash branch &lt;branchname&gt; [&lt;stash&gt;]</code></h3><p>一般这种情况就是使用过多次 <code>git stash push</code> 命令，而本地分支还修改了其他内容，直接恢复之前的修改不太合适，所以利用这个命令新建一个分支，分支的内容以指定的存储标号 <code>&lt;stash&gt;</code> 对应的提交 <code>commit-id</code> 为基础，然后应用 <code>&lt;stash&gt;</code> 的修改，实际上就是新建了一个对应 <code>&lt;stash&gt;</code> 的分支，继续之前未完成的工作，<code>&lt;stash&gt;</code> 默认为 <code>stash@{0}</code>，测试如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">albert@homepc MINGW64 /d/gitstart (feature)</span><br><span class="line">$ git stash branch feature1</span><br><span class="line">Switched to a new branch <span class="string">'feature1'</span></span><br><span class="line">M       README.md</span><br><span class="line">On branch feature1</span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">"git restore &lt;file&gt;..."</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line">        modified:   README.md</span><br><span class="line">        modified:   test.txt</span><br><span class="line"></span><br><span class="line">no changes added to commit (use <span class="string">"git add"</span> and/or <span class="string">"git commit -a"</span>)</span><br><span class="line">Dropped refs/stash@&#123;0&#125; (2922b3eeeda44c98316453b93fcf07c1fcfffca4)</span><br><span class="line"></span><br><span class="line">albert@homepc MINGW64 /d/gitstart (feature1)</span><br><span class="line">$ git stash list</span><br></pre></td></tr></table></figure><p>这个操作会消耗掉对应 <code>&lt;stash&gt;</code> 标号的临时存储的内容，将这些内容从存储列表中移除。</p><h1 id="stash-的注意事项"><a href="#stash-的注意事项" class="headerlink" title="stash 的注意事项"></a><code>stash</code> 的注意事项</h1><p>这个命令不仅可以在同一分支上存储和还原，也可用于不同分支之间，这时就可以有一个应用，当我们发现在错误的分支上开发了代码，可以先 <code>git stash push</code> 将这些修改临时存储起来， 然后切换到正确的分支，再执行 <code>git stash pop</code> 命令将刚才的修改引用到现在的分支上。</p><p><code>git stash push</code> 命令默认是存储工作区和暂存区的修改内容的，但是 <code>git stash pop</code> 命令在还原是默认将所有的修改还原到工作区，如果想还原到对应的暂存区，需要加额外的参数，像这样 <code>git stash pop --index</code>。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>这个命令挺有用的，在合作开发的时候经常碰到临时问题需要处理，切换分支暂存一下很方便</li><li>感觉这个命令其实和 <code>commit</code> 也很像的，在操作过程中你会发现，它也有自己的 <code>hash-id</code>，但是不会放到 <code>commit</code> 列表中</li><li>这个命令参数也有好多个，不过记住常用的就可以面对大多数情况了，简单列举下</li><li><code>git stash push</code> 会将当前本地的修改临时保存起来，<code>push</code> 可以省略</li><li><code>git stash list</code> 查看当前<code>stash push</code>操作的记录</li><li><code>git stash pop</code> 取出最近一次修改，并应用到本地</li><li><code>git stash apply stash@{n}</code> 应用 <code>stash@{n}</code> 对应的修改，但是不删除这条记录</li><li><code>git stash show stash@{n}</code> 展示 <code>stash@{n}</code> 对应的修改的实际修改内容</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;偶然间发现这个命令，正好解决了最近遇到的问题，使用 &lt;code&gt;Git&lt;/code&gt; 管理代码时有这样一种场景，你正在分支 &lt;code&gt;branch2&lt;/code&gt; 上开发新功能，突然刚刚提交测试的 &lt;code&gt;branch1&lt;/code&gt; 分支上报了严重的BUG，需要尽快修改，这时候就需要切换到 &lt;code&gt;branch1&lt;/code&gt; 分支上去修复BUG，但是你刚刚在分支 &lt;code&gt;branch2&lt;/code&gt; 修改的文件还没有提交，接下来该怎么办？&lt;/p&gt;
    
    </summary>
    
      <category term="Git" scheme="http://AlbertGithubHome.github.io/blog/categories/Git/"/>
    
    
      <category term="git" scheme="http://AlbertGithubHome.github.io/blog/tags/git/"/>
    
      <category term="checkout" scheme="http://AlbertGithubHome.github.io/blog/tags/checkout/"/>
    
      <category term="stash" scheme="http://AlbertGithubHome.github.io/blog/tags/stash/"/>
    
      <category term="merge" scheme="http://AlbertGithubHome.github.io/blog/tags/merge/"/>
    
  </entry>
  
  <entry>
    <title>没想到C++中的std::remove_if()函数历史还挺悠久</title>
    <link href="http://AlbertGithubHome.github.io/blog/2020/03/19/%E6%B2%A1%E6%83%B3%E5%88%B0C-%E4%B8%AD%E7%9A%84std-remove-if-%E5%87%BD%E6%95%B0%E5%8E%86%E5%8F%B2%E8%BF%98%E6%8C%BA%E6%82%A0%E4%B9%85/"/>
    <id>http://AlbertGithubHome.github.io/blog/2020/03/19/没想到C-中的std-remove-if-函数历史还挺悠久/</id>
    <published>2020-03-19T15:30:46.000Z</published>
    <updated>2020-03-21T12:50:58.287Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>看到 remove 这个单词的第一反应是什么意思？我的第一感觉是删除、去掉的意思，就像一个程序员看到 string 就会说是字符串，而不会说它是线、或者细绳的意思，可是C++里居然有个函数叫 <code>std::remove()</code>，调用完这个函数什么也没删除，这我就奇怪了，打开有道词典查询一下：</p><a id="more"></a><p>不查不要紧，一查吓一跳，以下是词典给出的三个释义：</p><ul><li>vt. 移动，迁移；开除；调动</li><li>vi. 移动，迁移；搬家</li><li>n. 移动；距离；搬家</li></ul><p>及物动词、不及物动词、名词给出的含义都是移动，只有一个开除的意思和删除有点像，难道我穿越了？我之前一直以为它是删除的意思啊，很多函数还是用它命名的呢！</p><p>赶紧翻翻其他的字典，给高中的英语老师打个电话问问，最终还是在一些释义中找到了删除的意思，还有一些用作删除的例句，有趣的是在有道词典上，所有的单词解释都和移动有关，所有的例句都是和删除有关。</p><h1 id="remove-if的历史"><a href="#remove-if的历史" class="headerlink" title="remove_if的历史"></a><code>remove_if</code>的历史</h1><p>为什么要查单词的 remove 的意思，当然是被它坑过了，本来想从 <code>std::vector&lt;T&gt;</code> 中删除指定的元素，考虑到迭代器失效的问题，放弃了循环遍历的复杂处理，选择直接使用算法函数 <code>std::remove_if()</code>来进行删除，之前对于 <code>std::remove()</code> 和 <code>std::remove_if()</code> 有过简单的了解，不过记忆还是出现了偏差。</p><p>一直记得 <code>std::remove()</code> 函数调用之后需要再使用 <code>erase()</code> 函数处理下，忘记了 <code>std::remove_if()</code> 函数也要做相同的处理，于是在出现问题的时候一度怀疑这个函数的功能发生了变更，开始找这个函数历史迭代的版本，这里推荐一个网站 <a href="https://en.cppreference.com/w/cpp/algorithm/remove" target="_blank" rel="noopener">C++标准函数查询 - std::remove_if()</a>，用来查询函数的定义、所在头文件和使用方法非常方便。</p><p>文档中有这样两句：</p><blockquote><p>1) Removes all elements that are equal to value, using operator== to compare them.<br>3) Removes all elements for which predicate p returns true.</p></blockquote><p>解释函数作用时用到的单词都是 remove ，你说神不神奇，这里应该都是取的移动的意思。</p><p>这两句话对应的函数声明应该是：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt; <span class="class"><span class="keyword">class</span> <span class="title">ForwardIt</span>, <span class="title">class</span> <span class="title">T</span> &gt;</span></span><br><span class="line"><span class="class"><span class="title">ForwardIt</span> <span class="title">remove</span>( <span class="title">ForwardIt</span> <span class="title">first</span>, <span class="title">ForwardIt</span> <span class="title">last</span>, <span class="title">const</span> <span class="title">T</span>&amp; <span class="title">value</span> );</span>        <span class="comment">// (until C++20)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt; <span class="class"><span class="keyword">class</span> <span class="title">ForwardIt</span>, <span class="title">class</span> <span class="title">UnaryPredicate</span> &gt;</span></span><br><span class="line"><span class="class"><span class="title">ForwardIt</span> <span class="title">remove_if</span>( <span class="title">ForwardIt</span> <span class="title">first</span>, <span class="title">ForwardIt</span> <span class="title">last</span>, <span class="title">UnaryPredicate</span> <span class="title">p</span> );</span>   <span class="comment">// (until C++20)</span></span><br></pre></td></tr></table></figure><p>这两个函数后面都有相同的说明—— <code>(until C++20)</code> ，意思大概就是说这两个函数一直到 <code>C++20</code> 版本都存在，在我的印象中 <code>std::remove_if()</code> 函数比较新，最起码得比 <code>std::remove()</code> 函数年轻几岁，可是他们到底是哪个版本添加到c++标准的的呢？中途的功能有没有发生变更，继续回忆！</p><p>第一次看到这两个函数应该是在看《Effective STL》这本书的时候，大概是5年前了，正好这个本书就放在手边，赶紧翻目录查一下，打开对应章节发现其中确实提到了删除 <code>std::vector&lt;T&gt;</code> 中的元素时，在调用了这两个函数之后都需要再调用 <code>erase()</code> 函数对待删除的元素进行擦除。</p><p>看看书的出版时间是2013年，难道是 <code>C++11</code> 的标准加上的，不对，看一下翻译者写得序，落款时间2003年，不能是 <code>C++03</code> 的标准吧？不过这是一本翻译书籍，再看看原作者 <code>Scott Meyers</code> 写的前言，落款时间2001年，好吧，看来这两个函数肯定在 <code>C++98</code>的版本中就已经存在了，我有点惊呆了，这确实颠覆了我的记忆和认知。</p><p>造成这种认知错误主要有两方面原因，第一方面就是受到了开发环境的限制，从一开始学习的时候<code>Turob C 2.0</code>、<code>VC++ 6.0</code>、<code>VS2005</code>、<code>VS2008</code>、<code>VS2010</code>就很少接触 <code>C++11</code> 的知识，<code>Dev-C++</code> 和 <code>Code::Blocks</code> 也是在特定的情况下使用，没有过多的研究，结果在刚开始工作的时候开发工具居然是<code>VS2003</code>，这个版本我之前都没听说过，还好一步步升级到了08、13、17版本。</p><p>第二方面就是这两个函数常常与 <code>Lambda</code> 表达式，<code>auto</code> 关键字一起用，这都是 <code>C++11</code> 里才有的，让人感觉好像这个 <code>std::remove_if()</code> 函数也是 <code>C++11</code> 版本中的内容，造成了错觉。总来说还是用的少，不熟悉，以后多看多练就好了。</p><h1 id="remove-if的实现"><a href="#remove-if的实现" class="headerlink" title="remove_if的实现"></a><code>remove_if</code>的实现</h1><p>要想更深入的学习 <code>std::remove_if()</code> 函数， 那这个函数实现的细节有必要了解一下，这有助于我们理解函数的使用方法，下面给出两个版本可能的实现方式，也许下面的实现与你查到的不一样，但是思想是相通的，有些实现细节中使用了 <code>std::find_if()</code> 函数，这里没有列举这个版本，下面这两个版本的代码更容易让人明白，它究竟做了哪些事情。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++98 版本</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">ForwardIterator</span>, <span class="title">class</span> <span class="title">UnaryPredicate</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">ForwardIterator</span> <span class="title">remove_if</span> (<span class="title">ForwardIterator</span> <span class="title">first</span>, <span class="title">ForwardIterator</span> <span class="title">last</span>,</span></span><br><span class="line"><span class="class">                             <span class="title">UnaryPredicate</span> <span class="title">pred</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ForwardIterator result = first;</span><br><span class="line">    <span class="keyword">while</span> (first!=last) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!pred(*first)) &#123;</span><br><span class="line">            *result = *first;</span><br><span class="line">            ++result;</span><br><span class="line">        &#125;</span><br><span class="line">        ++first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++11     版本</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">ForwardIterator</span>, <span class="title">class</span> <span class="title">UnaryPredicate</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">ForwardIterator</span> <span class="title">remove_if</span> (<span class="title">ForwardIterator</span> <span class="title">first</span>, <span class="title">ForwardIterator</span> <span class="title">last</span>,</span></span><br><span class="line"><span class="class">                             <span class="title">UnaryPredicate</span> <span class="title">pred</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ForwardIterator result = first;</span><br><span class="line">    <span class="keyword">while</span> (first!=last) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!pred(*first)) &#123;</span><br><span class="line">            *result = <span class="built_in">std</span>::move(*first);</span><br><span class="line">            ++result;</span><br><span class="line">        &#125;</span><br><span class="line">        ++first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对比两段代码有没有发现区别——只改了半行代码，将赋值语句中的 <code>*first</code> 在 <code>C++11</code> 版本中替换成了 <code>std::move(*first)</code>，这只能发生在 <code>C++11</code> 之后，因为 <code>std::move()</code> 函数是 <code>C++11</code> 才加入的。</p><p>这代码乍一看挺唬人的，其实仔细分析一下还挺简单的，只是这些符号看起来有些生疏，其实可以把 <code>ForwardIterator</code> 看成一个指针类型，<code>UnaryPredicate</code> 是一个函数类型，我们改写一下:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">remove_if</span> <span class="params">(<span class="keyword">int</span>* first, <span class="keyword">int</span>* last, func_type func)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>* result = first;</span><br><span class="line">    <span class="keyword">for</span> (;first!=last;++first)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!func(*first))</span><br><span class="line">        &#123;</span><br><span class="line">            *result = *first;</span><br><span class="line">            ++result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这代码是不是就比较接地气了，想象一下，一个是包含10个元素的数组，让你删除其中的偶数怎么做？其实就是遍历一遍数组，从开始位置到结束位置逐个判断，如果不是偶数就不进行操作，如果是偶数就把当前的偶数向前移动到结果指针上就好了，结果指针向后移动准备接受下一个奇数，这个判断是不是偶数的函数就是上面代码中的 <code>func()</code>。</p><p>最后结果指针 <code>result</code> 停在有效元素后面一个位置上，这个位置到结尾指针 <code>last</code> 的位置上的元素都应该被删除，这就是为什么常常将 <code>std::remove_if()</code> 函数的返回值作为 <code>erase()</code> 函数的第一个参数，而将 <code>last</code> 指针作为 <code>erase()</code> 函数的第二个参数，实际作用就是将这些位置上的元素擦除，从头擦到尾，达到真正删除的目的。</p><h1 id="具体使用"><a href="#具体使用" class="headerlink" title="具体使用"></a>具体使用</h1><p>说了这么多，接下来看看具体怎么用，我们将 <code>std::remove_if()</code> 函数和 <code>erase()</code> 函数分开使用，主要看一下调用 <code>std::remove_if()</code> 函数之后的 <code>vector</code> 中元素的值是怎么变的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isEven</span><span class="params">(<span class="keyword">int</span> n)</span> <span class="comment">// 是否是偶数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n % <span class="number">2</span> == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vecTest;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">        vecTest.push_back(i);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vecTest.size(); ++i)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; vecTest[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移动元素</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator itor = <span class="built_in">std</span>::remove_if(vecTest.begin(), vecTest.end(), isEven);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查看移动后的变化</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vecTest.size(); ++i)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; vecTest[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除元素</span></span><br><span class="line">    vecTest.erase(itor, vecTest.end());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vecTest.size(); ++i)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; vecTest[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为：</p><blockquote><p>0 1 2 3 4 5 6 7 8 9<br>1 3 5 7 9 5 6 7 8 9<br>1 3 5 7 9</p></blockquote><p>从结果可以看出，第二步调用 <code>std::remove_if()</code> 函数之后，vector 中的元素个数并没有减少，只是将后面不需要删除的元素移动到了 vector 的前面，从第二行结果来看，调用 <code>std::remove_if()</code> 函数之后返回的结果 <code>itor</code> 指向5，所以擦除从5所在位置到结尾的元素就达到了我们的目的。</p><p>这段代码在 <code>C++98</code>、<code>C++11</code>、<code>C++14</code> 环境下都可以编译运行，在这里推荐一个在线编译器 <a href="http://cpp.sh/" target="_blank" rel="noopener">C++ Shell</a>，可以测试各个版本编译器下运行结果，界面简洁明了，方便测试。</p><p>上面的代码其实写得有些啰嗦，如果使用 <code>C++11</code> 语法之后，可以简写为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">，</span><br></pre></td></tr></table></figure><p>运行结果：</p><blockquote><p>0 1 2 3 4 5 6 7 8 9<br>1 3 5 7 9</p></blockquote><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol><li>对于模糊的知识要花时间复习，避免临时用到的时候手忙脚乱出问题</li><li>对于一些心存疑虑的函数可以看一下具体的实现，知道实现的细节可以让我们更加清楚程序都做了哪些事情</li><li>对于新的技术标准可以不精通，但是必须花一些时间进行了解，比如新的 <code>C++</code> 标准</li><li>对于违反常识的代码，先不要否定，即使在你的运行环境中报错，说不定人家是新语法呢？</li><li>曾经看到一段在类的定义时初始化非静态变量的代码，一度认为编译不过，但后来发现在 <code>C++11</code> 中运行的很好</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;看到 remove 这个单词的第一反应是什么意思？我的第一感觉是删除、去掉的意思，就像一个程序员看到 string 就会说是字符串，而不会说它是线、或者细绳的意思，可是C++里居然有个函数叫 &lt;code&gt;std::remove()&lt;/code&gt;，调用完这个函数什么也没删除，这我就奇怪了，打开有道词典查询一下：&lt;/p&gt;
    
    </summary>
    
      <category term="C/C++" scheme="http://AlbertGithubHome.github.io/blog/categories/C-C/"/>
    
    
      <category term="C/C++" scheme="http://AlbertGithubHome.github.io/blog/tags/C-C/"/>
    
      <category term="历史" scheme="http://AlbertGithubHome.github.io/blog/tags/%E5%8E%86%E5%8F%B2/"/>
    
      <category term="remove" scheme="http://AlbertGithubHome.github.io/blog/tags/remove/"/>
    
      <category term="remove_if" scheme="http://AlbertGithubHome.github.io/blog/tags/remove-if/"/>
    
      <category term="删除" scheme="http://AlbertGithubHome.github.io/blog/tags/%E5%88%A0%E9%99%A4/"/>
    
  </entry>
  
  <entry>
    <title>Python操作Excel工作簿(\*.xlsx)</title>
    <link href="http://AlbertGithubHome.github.io/blog/2020/03/14/Python%E6%93%8D%E4%BD%9CExcel%E5%B7%A5%E4%BD%9C%E7%B0%BF/"/>
    <id>http://AlbertGithubHome.github.io/blog/2020/03/14/Python操作Excel工作簿/</id>
    <published>2020-03-14T10:51:25.000Z</published>
    <updated>2020-03-15T09:28:33.963Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><code>Excel</code> 作为流行的个人计算机数据处理软件，混迹于各个领域，在程序员这里也是常常被处理的对象，可以处理 <code>Excel</code> 格式文件的 Python 库还是挺多的，比如 <code>xlrd</code>、<code>xlwt</code>、<code>xlutils</code>、<code>openpyxl</code>、<code>xlwings</code> 等等，但是每个库处理 <code>Excel</code> 的方式不同，有些库在处理时还会有一些局限性。</p><a id="more"></a><p>接下来对比一下几个库的不同，然后主要记录一下 <code>xlwings</code> 这个库的使用，目前这是个人感觉使用起来比较方便的一个库了，其他的几个库在使用过程中总是有这样或那样的问题，不过在特定情况下使用也是挺不错的。</p><h1 id="EXCEL文件"><a href="#EXCEL文件" class="headerlink" title="EXCEL文件"></a>EXCEL文件</h1><p><code>Excel</code> 被称为电子表格，其实际可以保存的格式分为很多种，但是“Excel 工作簿(*.xlsx)”和“Excel 97-2003 工作簿(*.xls)”是其中比较常用的两种，可以认为 <code>.xls</code> 格式的表格是 <code>03版Excel</code> 之前常用的格式，而 <code>.xlsx</code> 是 03版之后，一般指 <code>07版Excel</code> 之后常用的格式。</p><p>一般的 Excel 程序对于上述的两种格式都可以打开编辑，也可以相互转化存储，不过还是建议在没有特殊要求的情况下使用新版本的格式，一方面新的稳定版本可能会修复之前的一些BUG，同时也会带来进行一些优化。</p><p>我也是在写这篇总结之前才发现，一个空的 <code>.xlsx</code> 格式的文件大小有 7KB，而一个空的 <code>.xls</code> 格式的文件大小有 24KB，当我分别写入一个相同的汉字后，两个文件大小变成了 10KB 和 30KB，差距还是不小的，还有一个问题就是在将 <code>.xlsx</code> 格式的文件另存为 <code>.xls</code> 格式时还会有兼容性提示，提醒用户有些设置可能会丢失，所以能选新版本还是尽量用新版本吧。</p><h1 id="测试环境"><a href="#测试环境" class="headerlink" title="测试环境"></a>测试环境</h1><p>因为很多应用程序是不断迭代的，相对应的 Python 库也是不断迭代的，这里尽可能的给出版本号，不同的版本可能会有不同的问题：</p><ul><li>操作系统: Windows 10 随意版</li><li>Python: 3.75</li><li>xlrd: 1.2.0</li><li>xlwt: 1.3.0</li><li>xlutils: 2.0.0</li><li>openpyxl: 3.0.3</li><li>xlwings: 0.18.0</li></ul><p>以上各个程序库使用之前自行安装就行，安装方法就不赘述了，不过可以提供一个可以快速安装镜像源，使用 <code>pip install -i https://pypi.doubanio.com/simple 库名</code> 可以尽可能解决下载安装缓慢的问题。</p><h1 id="Excel具体操作"><a href="#Excel具体操作" class="headerlink" title="Excel具体操作"></a>Excel具体操作</h1><p>关于使用 Python 具体操作 <code>Excel</code> 的方法可以分为三组，配合使用 <code>xlrd</code>、<code>xlwt</code>、<code>xlutils</code> 操作作为第一组，使用库 <code>openpyxl</code> 作为第二组，而 <code>xlwings</code> 作为第三组，这篇总结重点总结 <code>xlwings</code> 的使用，其他两组简单了解。</p><h2 id="xlrd、xlwt、xlutils"><a href="#xlrd、xlwt、xlutils" class="headerlink" title="xlrd、xlwt、xlutils"></a><code>xlrd</code>、<code>xlwt</code>、<code>xlutils</code></h2><p>这一组操作 <code>Excel</code> 的库名字很形象，一个读、一个写、一个小工具，凑到一起就可以对 <code>Excel</code> 肆意妄为了，下面做个小练习，打开一个 <code>Excel</code> 文件然后修改第一个单元格的值，再另存为一个新文件，代码如下:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> xlrd</span><br><span class="line"><span class="keyword">import</span> xlwt</span><br><span class="line"><span class="keyword">import</span> xlutils.copy</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">save_as_new_file</span><span class="params">(file_name, new_file_name)</span>:</span></span><br><span class="line">    <span class="comment"># 打开Excel文件</span></span><br><span class="line">    rb = xlrd.open_workbook(file_name)</span><br><span class="line">    <span class="comment"># 创建一个可写入的副本</span></span><br><span class="line">    wb = xlutils.copy.copy(rb)</span><br><span class="line">    <span class="comment"># 获得第一个sheet页签</span></span><br><span class="line">    ws = wb.get_sheet(<span class="number">0</span>)</span><br><span class="line">    <span class="comment"># 第一个单元格写入测试值</span></span><br><span class="line">    ws.write(<span class="number">0</span>, <span class="number">0</span>, <span class="string">'test value'</span>)</span><br><span class="line">    <span class="comment"># 另存为一个新文件</span></span><br><span class="line">    wb.save(new_file_name)</span><br></pre></td></tr></table></figure><p>上述代码无论是操作 <code>.xlsx</code> 文件还是操作 <code>.xls</code> 文件都不会报错，但是另存为的 <code>.xlsx</code> 格式的文件会打不开，同时你会发现正常存储的 <code>.xls</code> 文件打开后格式全都没了，怎么办，改个参数试试，将打开文件的代码修改如下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rb = xlrd.open_workbook(file_name, formatting_info=<span class="keyword">True</span>)</span><br></pre></td></tr></table></figure><p>其中参数 <code>formatting_info=True</code> 就表示打开Excel时保留原有的格式，但是这是相对于 <code>.xls</code> 格式的文件，对于 <code>.xlsx</code> 格式的文件直接跑出异常 <code>raise NotImplementedError(&quot;formatting_info=True not yet implemented&quot;)</code>，就因为处理不了 <code>.xlsx</code> 格式的文件，我暂时没有使用这几个库操作 <code>Excel</code>。</p><p>还有一点，这几个库操作单元格时，行和列的索引是从0开始的。</p><h2 id="openpyxl"><a href="#openpyxl" class="headerlink" title="openpyxl"></a><code>openpyxl</code></h2><p>首先说这个库主要用来操作 <code>.xlsx</code> 格式的文件，对于 <code>.xls</code> 格式的文件无法打开，会报 <code>openpyxl does not support the old .xls file format</code> 这样的错误，但是可以存储成这样的格式，再次打开时会有格式不匹配的警告，但是基础的数据还在，所以还是优先用来操作 <code>.xls</code> 格式的文件吧。</p><p>写一个新文件的常见用法：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> openpyxl <span class="keyword">import</span> Workbook</span><br><span class="line"><span class="keyword">from</span> openpyxl <span class="keyword">import</span> load_workbook</span><br><span class="line"><span class="keyword">from</span> openpyxl.styles <span class="keyword">import</span> Font, Fill, Alignment, PatternFill</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">write_new_excel</span><span class="params">(file_name)</span>:</span></span><br><span class="line">    <span class="comment"># 创建一个excel文档</span></span><br><span class="line">    wb = Workbook()</span><br><span class="line">    <span class="comment"># 获得当前激活的sheet对象</span></span><br><span class="line">    ws = wb.active</span><br><span class="line">    <span class="comment"># 给A2单元格赋值</span></span><br><span class="line">    ws[<span class="string">'A2'</span>] = <span class="string">'This is A2 cell'</span></span><br><span class="line">    <span class="comment"># 一行添加多列数据</span></span><br><span class="line">    ws.append([<span class="number">1</span>, <span class="number">2</span>, <span class="string">'hello'</span>])</span><br><span class="line">    <span class="comment"># 添加新的sheet</span></span><br><span class="line">    ws = wb.create_sheet(title=<span class="string">'NewInfo'</span>,index=<span class="number">0</span>)</span><br><span class="line">    <span class="comment"># 设置单元格的值</span></span><br><span class="line">    ws[<span class="string">'A1'</span>] = <span class="string">'This is new sheet'</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 保存excel</span></span><br><span class="line">    wb.save(file_name)</span><br></pre></td></tr></table></figure><p>读取和改写一个原有文件的常见用法：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read_update_excel</span><span class="params">(file_name)</span>:</span></span><br><span class="line">    <span class="comment"># 加载Excel表</span></span><br><span class="line">    wb = load_workbook(file_name)</span><br><span class="line">    <span class="comment"># 打印sheet数量</span></span><br><span class="line">    print(<span class="string">'sheet count:'</span>, len(wb.sheetnames))</span><br><span class="line">    <span class="comment"># 打印所有sheet名字</span></span><br><span class="line">    print(<span class="string">'sheet name list:'</span>, wb.sheetnames)</span><br><span class="line">    <span class="comment"># 获取第一个sheet对象</span></span><br><span class="line">    ws = wb[wb.sheetnames[<span class="number">0</span>]]</span><br><span class="line">    <span class="comment"># 打印sheet表行数和列数</span></span><br><span class="line">    print(<span class="string">'rows count:'</span>, ws.max_row, <span class="string">'cols count:'</span>, ws.max_column)</span><br><span class="line">    <span class="comment"># 更新单元格A1的内容</span></span><br><span class="line">    ws[<span class="string">'A1'</span>] = <span class="string">'this is A1'</span></span><br><span class="line">    <span class="comment"># 在第二行位置插入一行</span></span><br><span class="line">    ws.insert_rows(<span class="number">2</span>)</span><br><span class="line">    <span class="comment"># 删除第五行</span></span><br><span class="line">    ws.delete_rows(<span class="number">5</span>)</span><br><span class="line">    <span class="comment"># 获取单元格对象，对应B2单元格</span></span><br><span class="line">    cell = ws.cell(<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line">    <span class="comment"># 设置单元格内容</span></span><br><span class="line">    cell.value = <span class="string">'this is B2'</span></span><br><span class="line">    <span class="comment"># 修改字体格式为粗体</span></span><br><span class="line">    cell.font = Font(bold=<span class="keyword">True</span>)</span><br><span class="line">    <span class="comment"># 修改单元格格式</span></span><br><span class="line">    cell.fill = PatternFill(<span class="string">"solid"</span>, fgColor=<span class="string">"F0CDCD"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 保存原文件或另存一个文件</span></span><br><span class="line">    wb.save(file_name)</span><br></pre></td></tr></table></figure><p>使用这个库遇到的情况，存储带有样式的数据没有发现问题，但是当加入一个计算公式后，另存为一个文件时明显文件尺寸变小了，但是数据和公式没有发现有问题。</p><p>有资料说处理速度真的很慢，因为我处理的文件比较小，但是没有发现这方面的问题，还有一个问题就是说Excel中的宏全部丢失，这个测试的时候确实是丢了，只不过这个好像和文件格式有关，要想保存宏需要存储为 <code>.xlsm</code> 格式，但是 <code>openpyxl</code> 使用来操作 <code>.xlsx</code> 文件的，存储时会导致宏丢失，强行存储为 <code>.xlsm</code> 格式会导致最终的文件打不开。</p><p>还有一点，这个库操作单元格时，行和列的索引是从1开始的。</p><h2 id="xlwings"><a href="#xlwings" class="headerlink" title="xlwings"></a><code>xlwings</code></h2><p>这个库在操作的首先要创建一个 <code>App</code>，通过这个创建出来的 <code>App</code> 对象来操作 <code>Excel</code>，非常像把 <code>Excel</code> 的各种操作 <code>api</code> 封装到一起，然后通过这个 <code>App</code> 对象来调用，如果在创建 <code>App</code> 的时候不设置隐藏参数，是会正常打开 <code>Excel</code> 程序的。</p><h3 id="使用-xlwings-的基本方式："><a href="#使用-xlwings-的基本方式：" class="headerlink" title="使用 xlwings 的基本方式："></a>使用 <code>xlwings</code> 的基本方式：</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> xlwings <span class="keyword">as</span> xw</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置Excel程序不可见</span></span><br><span class="line">app = xw.App(visible=<span class="keyword">False</span>, add_book=<span class="keyword">False</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过 app 操作 Excel文件</span></span><br><span class="line"><span class="comment"># app.bala bala bala .....</span></span><br><span class="line"><span class="comment"># app.bala bala bala .....</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 优雅的退出</span></span><br><span class="line">app.quit()</span><br></pre></td></tr></table></figure><h3 id="创建一个新的-Excel-文件并写入数据："><a href="#创建一个新的-Excel-文件并写入数据：" class="headerlink" title="创建一个新的 Excel 文件并写入数据："></a>创建一个新的 <code>Excel</code> 文件并写入数据：</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">write_new_excel</span><span class="params">(app, file_name)</span>:</span></span><br><span class="line">    <span class="comment"># 创建新的 Excel 表</span></span><br><span class="line">    wb = app.books.add()</span><br><span class="line">    <span class="comment"># 获取当前活动的sheet</span></span><br><span class="line">    ws = wb.sheets.active</span><br><span class="line">    <span class="comment"># 初始化二维区域的值</span></span><br><span class="line">    arr_data = [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>], [<span class="number">7</span>, <span class="number">8</span>, <span class="string">'end'</span>]]</span><br><span class="line">    <span class="comment"># 设置到新建的Excel中</span></span><br><span class="line">    ws.range(<span class="string">'A1:B3'</span>).value=arr_data</span><br><span class="line">    <span class="comment"># 设置单独一个单元格的值</span></span><br><span class="line">    ws.range(<span class="string">'A4'</span>).value=<span class="string">'this is A4'</span></span><br><span class="line">    <span class="comment"># 设置单独一个单元格的值</span></span><br><span class="line">    ws[<span class="number">3</span>,<span class="number">1</span>].value=<span class="string">'this is B4'</span></span><br><span class="line">    <span class="comment"># 保存Excel文件</span></span><br><span class="line">    wb.save(file_name)</span><br><span class="line">    wb.close()</span><br></pre></td></tr></table></figure><p>需要注意的是通过行索引和列索引修改单元格时，起始索引是0。</p><h3 id="读入已有-Excel-表格并修改"><a href="#读入已有-Excel-表格并修改" class="headerlink" title="读入已有 Excel 表格并修改"></a>读入已有 Excel 表格并修改</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read_update_excel</span><span class="params">(app, file_name)</span>:</span></span><br><span class="line">    <span class="comment"># 加载已有的表格</span></span><br><span class="line">    load_wb = app.books.open(file_name)</span><br><span class="line">    <span class="comment"># 获取Excel表中第一个sheet</span></span><br><span class="line">    load_ws = load_wb.sheets[<span class="number">0</span>]</span><br><span class="line">    <span class="comment"># 打印sheet的名字</span></span><br><span class="line">    print(load_ws.name)</span><br><span class="line">    <span class="comment"># 根据sheet名字获取sheet对象</span></span><br><span class="line">    load_ws = load_wb.sheets[load_ws.name]</span><br><span class="line">    <span class="comment"># 获取当前活动的sheet</span></span><br><span class="line">    load_ws = load_wb.sheets.active</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获取存在数据的行数和列数</span></span><br><span class="line">    rows = load_ws.api.UsedRange.Rows.count</span><br><span class="line">    cols = load_ws.api.UsedRange.Columns.count</span><br><span class="line">    print(<span class="string">'rows count:'</span>, rows, <span class="string">'cols count:'</span>, cols)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 修改指定单元格数据（A1单元格）</span></span><br><span class="line">    load_ws[<span class="number">0</span>,<span class="number">0</span>].value=<span class="string">'this is A1'</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 有空行或空列时获取准确的行列数量</span></span><br><span class="line">    print(load_ws.used_range.shape)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 从A1单元格开始扩展到非空行空列，最后的行数和列数</span></span><br><span class="line">    print((load_ws.range(<span class="string">'A1'</span>).expand().last_cell.row,</span><br><span class="line">        load_ws.range(<span class="string">'A1'</span>).expand().last_cell.column))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 从A1单元格开始扩展到非空行空列，最后的行数和列数</span></span><br><span class="line">    print((load_ws.range(<span class="string">'A1'</span>).expand().last_cell.row,</span><br><span class="line">        load_ws.range(<span class="string">'A1'</span>).expand().last_cell.column))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 从A1单元格开始扩展到非空行空列，最后形状</span></span><br><span class="line">    print(load_ws.range(<span class="number">1</span>,<span class="number">1</span>).expand().shape)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 从A1单元格开始扩展到非空行空列，最后的行数和列数</span></span><br><span class="line">    print((load_ws.range(<span class="string">'A1'</span>).expand(<span class="string">'table'</span>).rows.count,</span><br><span class="line">        load_ws.range(<span class="string">'A1'</span>).expand(<span class="string">'table'</span>).columns.count))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 保存修改后的Excel</span></span><br><span class="line">    load_wb.save(file_name)</span><br><span class="line">    load_wb.close()</span><br></pre></td></tr></table></figure><h3 id="Excel-增加删除行和列"><a href="#Excel-增加删除行和列" class="headerlink" title="Excel 增加删除行和列"></a>Excel 增加删除行和列</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insert_delete_rowscols</span><span class="params">(app, file_name)</span>:</span></span><br><span class="line">    <span class="comment"># 加载已有的表格</span></span><br><span class="line">    load_wb = app.books.open(file_name)</span><br><span class="line">    <span class="comment"># 获取当前活动的sheet</span></span><br><span class="line">    load_ws = load_wb.sheets.active</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 从第2行开始插入4行，也就是说2-5行变成新插入的空行</span></span><br><span class="line">    load_ws.api.rows(<span class="string">'2:5'</span>).insert</span><br><span class="line">    <span class="comment"># 删除第6行和第7行</span></span><br><span class="line">    load_ws.api.rows(<span class="string">'6:7'</span>).delete</span><br><span class="line">    <span class="comment"># 插入一个单元格，实际测试效果是B列从B2开始向下移动，B2为新添加的单元格</span></span><br><span class="line">    load_ws.range(<span class="string">'B2'</span>).api.insert</span><br><span class="line">    <span class="comment"># 插入新的一列</span></span><br><span class="line">    load_ws.api.columns(<span class="string">'B'</span>).insert</span><br><span class="line">    <span class="comment"># 删除一列</span></span><br><span class="line">    load_ws.api.columns(<span class="string">'C'</span>).delete</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 保存修改后的Excel</span></span><br><span class="line">    load_wb.save(file_name)</span><br><span class="line">    load_wb.close()</span><br></pre></td></tr></table></figure><h3 id="单元格宽高查询设置与合并"><a href="#单元格宽高查询设置与合并" class="headerlink" title="单元格宽高查询设置与合并"></a>单元格宽高查询设置与合并</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cell_operation</span><span class="params">(app, file_name)</span>:</span></span><br><span class="line">    <span class="comment"># 加载已有的表格</span></span><br><span class="line">    load_wb = app.books.open(FILE_PATH_ROOT + file_name)</span><br><span class="line">    <span class="comment"># 获取当前活动的sheet</span></span><br><span class="line">    load_ws = load_wb.sheets.active</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 合并单元格</span></span><br><span class="line">    load_ws.range(<span class="string">'A2:A3'</span>).api.merge</span><br><span class="line"></span><br><span class="line">    <span class="comment">#获取单元格</span></span><br><span class="line">    cell = xw.Range(<span class="string">'B2'</span>)</span><br><span class="line">    <span class="comment"># 打印单元格所在的行和列</span></span><br><span class="line">    print(<span class="string">"row is:"</span>, cell.row, <span class="string">"col is:"</span>, cell.column)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 打印当前格子的高度和宽度</span></span><br><span class="line">    print(<span class="string">"cell.width:"</span>, cell.width, <span class="string">"cell.height:"</span>, cell.height)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 设置当前格子的高度和宽度</span></span><br><span class="line">    cell.row_height = <span class="number">32</span></span><br><span class="line">    cell.column_width = <span class="number">64</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 指定单元格的高度和宽度自适应</span></span><br><span class="line">    cell.columns.autofit()</span><br><span class="line">    cell.rows.autofit()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 再次打印当前格子的高度和宽度</span></span><br><span class="line">    print(<span class="string">"cell.width:"</span>, cell.width, <span class="string">"cell.height:"</span>, cell.height)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 保存修改后的Excel</span></span><br><span class="line">    load_wb.save(file_name)</span><br><span class="line">    load_wb.close()</span><br></pre></td></tr></table></figure><h1 id="几个库支持情况对比"><a href="#几个库支持情况对比" class="headerlink" title="几个库支持情况对比"></a>几个库支持情况对比</h1><p>虽然前面写了这么多方法，但是遇到一个实际的问题时还是会犹豫，到底用哪种方式呢？下面做一个简单的对比，只是根据我做的实验来简单对比，如果有不准确甚至是错误的地方，欢迎大家指出来，我会尽快改正的。</p><table><thead><tr><th style="text-align:left">情景/库</th><th style="text-align:center"><code>xlrd</code>、<code>xlwt</code>、<code>xlutils</code></th><th style="text-align:center"><code>openpyxl</code></th><th style="text-align:center"><code>xlwings</code></th></tr></thead><tbody><tr><td style="text-align:left">读取<code>.xls</code></td><td style="text-align:center">可以带有样式读取</td><td style="text-align:center">不支持</td><td style="text-align:center">可以读取</td></tr><tr><td style="text-align:left">保存<code>.xls</code></td><td style="text-align:center">可以带有样式保存</td><td style="text-align:center">可以保存，但是提示文件扩展名不匹配，可以看到原始数据</td><td style="text-align:center">可以保存，但是提示文件扩展名不匹配，可以看到原始数据</td></tr><tr><td style="text-align:left">读取<code>.xlsx</code></td><td style="text-align:center">可以读取，但没有样式</td><td style="text-align:center">可以带有样式读取</td><td style="text-align:center">可以带有样式读取</td></tr><tr><td style="text-align:left">保存<code>.xlsx</code></td><td style="text-align:center">保存后打不开</td><td style="text-align:center">可以带有样式保存</td><td style="text-align:center">可以带有样式保存</td></tr><tr><td style="text-align:left">读取<code>.xlsm</code></td><td style="text-align:center">可以读取，但没有样式和宏</td><td style="text-align:center">可以读取，但没有宏</td><td style="text-align:center">可以读取包含宏的表格</td></tr><tr><td style="text-align:left">保存<code>.xlsm</code></td><td style="text-align:center">保存后打不开，存成 <code>.xls</code> 格式宏丢失</td><td style="text-align:center">保存后打不开，存成 <code>.xls想</code> 格式宏丢失</td><td style="text-align:center">存储后宏还在</td></tr><tr><td style="text-align:left">增删行和列</td><td style="text-align:center">没有直接方法</td><td style="text-align:center">支持</td><td style="text-align:center">支持</td></tr><tr><td style="text-align:left">另存后大小</td><td style="text-align:center"><code>.xls</code> 文件没有变化</td><td style="text-align:center"><code>.xlsx</code> 文件会变小</td><td style="text-align:center"><code>.xls</code>、<code>.xlsx</code> 文件没有变化</td></tr><tr><td style="text-align:left">使用建议</td><td style="text-align:center">只操作.xls文件可以考虑</td><td style="text-align:center">只操作.xlsx文件可以考虑，不能带有宏</td><td style="text-align:center">一个比较好的选择，使用时感觉速度稍微有点慢</td></tr></tbody></table><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol><li>Excel 表格程序经过版本的更替发生了很大的变化，出现了相同内容时 <code>.xls</code> 比 <code>.xlsx</code> 格式的文件大很多的情况</li><li>基于上一点考虑，如果能使用的新版的表格，那么就放弃旧的格式的吧</li><li>还有一个神奇的情况，一个带有少量数据的 <code>.xlsx</code> 格式的表格要比一个空表格还要小，这是什么情况，暂时没弄明白怎么回事，求知道的大神告知一二</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&lt;code&gt;Excel&lt;/code&gt; 作为流行的个人计算机数据处理软件，混迹于各个领域，在程序员这里也是常常被处理的对象，可以处理 &lt;code&gt;Excel&lt;/code&gt; 格式文件的 Python 库还是挺多的，比如 &lt;code&gt;xlrd&lt;/code&gt;、&lt;code&gt;xlwt&lt;/code&gt;、&lt;code&gt;xlutils&lt;/code&gt;、&lt;code&gt;openpyxl&lt;/code&gt;、&lt;code&gt;xlwings&lt;/code&gt; 等等，但是每个库处理 &lt;code&gt;Excel&lt;/code&gt; 的方式不同，有些库在处理时还会有一些局限性。&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="http://AlbertGithubHome.github.io/blog/categories/Python/"/>
    
    
      <category term="Python" scheme="http://AlbertGithubHome.github.io/blog/tags/Python/"/>
    
      <category term="Excel" scheme="http://AlbertGithubHome.github.io/blog/tags/Excel/"/>
    
      <category term="xlrd" scheme="http://AlbertGithubHome.github.io/blog/tags/xlrd/"/>
    
      <category term="xlutils" scheme="http://AlbertGithubHome.github.io/blog/tags/xlutils/"/>
    
      <category term="xlwings" scheme="http://AlbertGithubHome.github.io/blog/tags/xlwings/"/>
    
  </entry>
  
  <entry>
    <title>git checkout/git reset/git revert/git restore常用回退操作</title>
    <link href="http://AlbertGithubHome.github.io/blog/2020/03/03/git-checkout-git-reset-git-revert-git-restore%E5%B8%B8%E7%94%A8%E5%9B%9E%E9%80%80%E6%93%8D%E4%BD%9C/"/>
    <id>http://AlbertGithubHome.github.io/blog/2020/03/03/git-checkout-git-reset-git-revert-git-restore常用回退操作/</id>
    <published>2020-03-03T14:58:46.000Z</published>
    <updated>2020-03-07T10:46:24.885Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在 <code>Git</code> 中没有真正的方法来做任何事情，这就是它的妙处！</p></blockquote><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>经常会听到别人说，如果时光可以倒流，我将会如何如何，可是现阶段的科技还达不到时光倒流的目的，或许在《三体》世界的四维裂缝里可以试一下。现实的世界中找不到后悔药，但是在代码的世界里却可以轻松实现，错误的BUG修改、砍掉的做了一半的功能都可以轻松回退，不留一丝痕迹，回滚之后一切又可以重新开始了。</p><a id="more"></a><h1 id="代码回退"><a href="#代码回退" class="headerlink" title="代码回退"></a>代码回退</h1><p>大型编程项目的开发往往伴随着版本工具的使用，其实引入代码版本控制工具，有一部分原因也是为了方便回退，回退操作每天都发生的，只是有时是我们显式的操作，有时却自然而然的进行着，我们切换着分支很可能就是从开发版本回退到一个稳定版本，我们查询日志，实际上是在记忆上回退我们整个的开发过程，找寻其中的问题和修改的内容。</p><h1 id="Git管理下的各种文件状态"><a href="#Git管理下的各种文件状态" class="headerlink" title="Git管理下的各种文件状态"></a>Git管理下的各种文件状态</h1><p><code>Git</code>的使用中，由于一个文件存在好几种状态的变化，所以处理起回退要分情况进行，有些各式各样的命令最终分析起来其实作用是一样的。</p><p>说起<code>Git</code>常常会提到工作区、暂存区、版本库的概念，这是很通用的说法，其实工作区一般就是指我们能看到的文件、本地操作文件所在的目录，我们正常编写的代码文件、管理的资源文件都是在工作区里操作，这里的文件也不是全都平等的，又细分为受版本控制的文件和不受版本控制的文件。</p><p>提到暂存区就和index文件建立起了联系，工作区的新文件和已经修改的受版本控制的文件，使用 <code>git add file_name</code> 就可以加到暂存区，相当于登记报个名，以后提交到版本库的时候会把这些登记的文件都带上，实际上执行了 <code>git add</code> 命令的文件都生成了对应的 object 对象，放在.git/objects目录下，状态变成了 <code>staged</code>， 当提交到版本库时，分支会引用这些对象。</p><p>版本库就是文件修改的目的地了，最终的修改会提交到版本库，这时提交的文件状态变成 <code>committed</code>，其实也是一种 <code>unmodified</code> 状态，一路走来，版本库中记录了你的每一次提交，可以追溯你每一次修改的内容。</p><p>其实还有一个远程仓库的概念，一般确定本地仓库的修改没有问题了，或者要将本地代码远程备份时，可以将自己修改的分支推送到远程仓库，因为有时候我们也想回退已经推送到远程仓库的修改，所以这里先提一下远程仓库。</p><p>总结起来一个文件的状态通常可以分为：</p><ul><li>不受版本控制的 <code>untracked</code> 状态</li><li>受版本控制并且已修改的 <code>modified</code> 状态</li><li>受版本控制已修改并提交到暂存区的 <code>staged</code> 状态</li><li>从暂存区已经提交到本地仓库的 <code>committed</code> 状态</li><li>提交到本地仓库未修改或者从远程仓库克隆下来的 <code>unmodified</code> 状态</li></ul><h1 id="Git回退命令"><a href="#Git回退命令" class="headerlink" title="Git回退命令"></a>Git回退命令</h1><p>上面提到了在 <code>Git</code> 这个版本控制工具下文件的各种状态，其实回退操作就是通过命令实现这些文件状态的“倒退”，进而达到回退操作的目的，下面一起先来了解下这些可以实现回退的命令。</p><h2 id="git-checkout"><a href="#git-checkout" class="headerlink" title="git checkout"></a>git checkout</h2><p>这个命令又出现了，上次是总结 <code>git branch</code> 分支操作的时候，<code>git checkout</code> 可以用来新建或者切换分支，这次总结回退版本的命令，<code>git checkout</code> 也可以用来回退文件版本，很神奇吧。</p><p>其实这个命令的作用就是它单词的本义——检出，他的常用操作也取自这个意思，比如 <code>git checkout branch_name</code> 切换分支操作，实际上就是把指定分支在仓库中对应的所有文件检出来覆盖当前工作区，最终表现就是切换了分支。</p><p>而针对于文件的检出可以使用 <code>git checkout -- file_name</code>，当不指定 <code>commit id</code> 就是将暂存区的内容恢复到工作区，也就可以达到回退本地修改的作用。</p><p>不过，这个身兼数职的 <code>git checkout</code> 命令现在可以轻松一些了，从 <code>Git 2.23</code> 版本开始引入了两个新的命令： <code>git switch</code> 用来切换分支，<code>git restore</code>用来还原工作区的文件，这个后面还会提到。</p><h2 id="git-revert"><a href="#git-revert" class="headerlink" title="git revert"></a>git revert</h2><p>revert 这个词的意思是：归还，复原，回退，它和后面即将提到的 restore 在意思上简直无法区分，为了区别他们两个这里可以把 <code>git revert</code> 看成归还的意思，对某次提交执行 <code>git revert</code> 命令就是对这次修改执行一个归还操作，其实就是反向再修改一次。</p><p>要理解 <code>git revert</code> 就要从反向修改的含义来看，当我们再一个文件中添加一行内容，并提交到版本库后，产生一个提交id——<code>commit-id-a</code>，如果这时使用 <code>git revert commit-id-a</code> 命令，就相当于在工作区中的那个文件将刚在新加的一行内容删除掉，然后再进行一个提交。</p><p>注意，这个操作是会改变分支记录的，因为产生了新的提交。</p><h2 id="git-restore"><a href="#git-restore" class="headerlink" title="git restore"></a>git restore</h2><p>这个命令是 <code>Git 2.23</code> 版本之后新加的，用来分担之前 <code>git checkout</code> 命令的功能，作用就是用暂存区或者版本库中的文件覆盖本地文件的修改可以达到回退修改的目的，同时也可以使用版本库中的文件覆盖暂存区的文件，达到回退<code>git add</code> 命令的目的。</p><p>注意，这个操作是不会影响分支记录的，就是相当于之前的 <code>git checkout</code> 命令重新检出一份文件来覆盖本地的修改。</p><h2 id="git-reset"><a href="#git-reset" class="headerlink" title="git reset"></a>git reset</h2><p>reset 重新设置的意思，其实就是用来设置分支的头部指向，当进行了一系列的提交之后，忽然发现最近的几次提交有问题，想从提交记录中删除，这是就会用到 <code>git reset</code> 命令，这个命令后面跟 <code>commit id</code>，表示当前分支回退到这个 <code>commit id</code> 对应的状态，之后的日志记录被删除，工作区中的文件状态根据参数的不同会恢复到不同的状态。</p><ul><li><p><code>--soft</code>: 被回退的那些版本的修改会被放在暂存区，可以再次提交。</p></li><li><p><code>--mixed</code>: 默认选项，被回退的那些版本的修改会放在工作目录，可以先加到暂存区，然后再提交。</p></li><li><p><code>--hard</code>: 被回退的那些版本的修改会直接舍弃，好像它们没有来过一样。</p></li></ul><p>这样来看，<code>git set</code> 命令好像是用来回退版本的，但是如果使用 <code>git rest HEAD file_name</code> 命令就可以将一个文件回退到 <code>HEAD</code> 指向版本所对应的状态，其实就是当前版本库中的状态，也就相当于还原了本地的修改。</p><h2 id="git-rm"><a href="#git-rm" class="headerlink" title="git rm"></a>git rm</h2><p>临时插播的命令，本来删除不能算是回退，但是如果它和某些命令反着来就是一种回退，比如对一个新文件使用 <code>git add newfile_name</code> 命令，然后再使用 <code>git rm --cached newfile_name</code> 就可以将这个文件从暂存区移除掉，但是在工作区里没有消失，如果不加 <code>--cached</code> 参数，就会从工作区和版本库暂存区同时删除，相当于执行了 <code>rm newfile_name</code> 和 <code>git add new_file</code> 两条命令。</p><h1 id="具体回退操作"><a href="#具体回退操作" class="headerlink" title="具体回退操作"></a>具体回退操作</h1><p>说了这么多肯定有点懵，特别是一个相同的需求可以使用很多命令来实现的时候，接下来看一些具体需求，整个测试过程用上一篇总结<a href="https://blog.csdn.net/albertsh/article/details/104581541" target="_blank" rel="noopener">《git branch常用分支操作》</a>使用的 git 仓库来进行，远程地址是 <code>git@gitee.com:myname/gitstart.git</code>，下面测试开始，我们看一下这些情况怎么进行还原：</p><h2 id="初始状态"><a href="#初始状态" class="headerlink" title="初始状态"></a>初始状态</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">albert@homepc MINGW64 /d/gitstart (dev)</span><br><span class="line">$ ls</span><br><span class="line">README.md</span><br><span class="line"></span><br><span class="line">albert@homepc MINGW64 /d/gitstart (dev)</span><br><span class="line">$ git status</span><br><span class="line">On branch dev</span><br><span class="line">Your branch is up to date with <span class="string">'origin/dev'</span>.</span><br><span class="line"></span><br><span class="line">nothing to commit, working tree clean</span><br><span class="line"></span><br><span class="line">albert@homepc MINGW64 /d/gitstart (dev)</span><br><span class="line">$ git branch -a</span><br><span class="line">* dev</span><br><span class="line">  master</span><br><span class="line">  remotes/origin/dev</span><br><span class="line">  remotes/origin/master</span><br><span class="line"></span><br><span class="line">albert@homepc MINGW64 /d/gitstart (dev)</span><br><span class="line">$ git branch -vv</span><br><span class="line">* dev     3226b63 [origin/dev] add readme file</span><br><span class="line">  master  3226b63 [origin/master] add readme file</span><br></pre></td></tr></table></figure><h2 id="还原00：工作区中未加到暂存区和版本库的文件，还原今天所做的修改"><a href="#还原00：工作区中未加到暂存区和版本库的文件，还原今天所做的修改" class="headerlink" title="还原00：工作区中未加到暂存区和版本库的文件，还原今天所做的修改"></a>还原00：工作区中未加到暂存区和版本库的文件，还原今天所做的修改</h2><p>实话实说，办不到，没有加到过暂存区就没有被追踪，它的任何修改是没有办法回退的，可是使用 <code>Ctrl+Z</code> 碰碰运气，没准就退回到了你想要的状态。</p><h2 id="还原01：工作区中未加到暂存区和版本库的文件，执行了-git-add-操作"><a href="#还原01：工作区中未加到暂存区和版本库的文件，执行了-git-add-操作" class="headerlink" title="还原01：工作区中未加到暂存区和版本库的文件，执行了 git add 操作"></a>还原01：工作区中未加到暂存区和版本库的文件，执行了 <code>git add</code> 操作</h2><p>这种情况可以使用<code>git rm --cached newfile</code>、<code>git restore --staged newfile</code> 或者 <code>git reset HEAD newfile</code> 命令，使用后两个命令的时候不能是版本库的第一个文件。</p><h3 id="git-rm-1"><a href="#git-rm-1" class="headerlink" title="git rm"></a>git rm</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">albert@homepc MINGW64 /d/gitstart (dev)</span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">"test data"</span>&gt;new.txt</span><br><span class="line"></span><br><span class="line">albert@homepc MINGW64 /d/gitstart (dev)</span><br><span class="line">$ git add new.txt</span><br><span class="line">warning: LF will be replaced by CRLF <span class="keyword">in</span> new.txt.</span><br><span class="line">The file will have its original line endings <span class="keyword">in</span> your working directory</span><br><span class="line"></span><br><span class="line">albert@homepc MINGW64 /d/gitstart (dev)</span><br><span class="line">$ git status</span><br><span class="line">On branch dev</span><br><span class="line">Your branch is up to date with <span class="string">'origin/dev'</span>.</span><br><span class="line"></span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">"git restore --staged &lt;file&gt;..."</span> to unstage)</span><br><span class="line">        new file:   new.txt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">albert@homepc MINGW64 /d/gitstart (dev)</span><br><span class="line">$ git rm --cached new.txt</span><br><span class="line">rm <span class="string">'new.txt'</span></span><br><span class="line"></span><br><span class="line">albert@homepc MINGW64 /d/gitstart (dev)</span><br><span class="line">$ git status</span><br><span class="line">On branch dev</span><br><span class="line">Your branch is up to date with <span class="string">'origin/dev'</span>.</span><br><span class="line"></span><br><span class="line">Untracked files:</span><br><span class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> to include <span class="keyword">in</span> what will be committed)</span><br><span class="line">        new.txt</span><br><span class="line"></span><br><span class="line">nothing added to commit but untracked files present (use <span class="string">"git add"</span> to track)</span><br></pre></td></tr></table></figure><h3 id="git-restore-1"><a href="#git-restore-1" class="headerlink" title="git restore"></a>git restore</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">albert@homepc MINGW64 /d/gitstart (dev)</span><br><span class="line">$ git add new.txt</span><br><span class="line">warning: LF will be replaced by CRLF <span class="keyword">in</span> new.txt.</span><br><span class="line">The file will have its original line endings <span class="keyword">in</span> your working directory</span><br><span class="line"></span><br><span class="line">albert@homepc MINGW64 /d/gitstart (dev)</span><br><span class="line">$ git status</span><br><span class="line">On branch dev</span><br><span class="line">Your branch is up to date with <span class="string">'origin/dev'</span>.</span><br><span class="line"></span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">"git restore --staged &lt;file&gt;..."</span> to unstage)</span><br><span class="line">        new file:   new.txt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">albert@homepc MINGW64 /d/gitstart (dev)</span><br><span class="line">$ git restore --staged new.txt</span><br><span class="line"></span><br><span class="line">albert@homepc MINGW64 /d/gitstart (dev)</span><br><span class="line">$ git status</span><br><span class="line">On branch dev</span><br><span class="line">Your branch is up to date with <span class="string">'origin/dev'</span>.</span><br><span class="line"></span><br><span class="line">Untracked files:</span><br><span class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> to include <span class="keyword">in</span> what will be committed)</span><br><span class="line">        new.txt</span><br><span class="line"></span><br><span class="line">nothing added to commit but untracked files present (use <span class="string">"git add"</span> to track)</span><br></pre></td></tr></table></figure><h3 id="git-reset-1"><a href="#git-reset-1" class="headerlink" title="git reset"></a>git reset</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">albert@homepc MINGW64 /d/gitstart (dev)</span><br><span class="line">$ git add new.txt</span><br><span class="line">warning: LF will be replaced by CRLF <span class="keyword">in</span> new.txt.</span><br><span class="line">The file will have its original line endings <span class="keyword">in</span> your working directory</span><br><span class="line"></span><br><span class="line">albert@homepc MINGW64 /d/gitstart (dev)</span><br><span class="line">$ git status</span><br><span class="line">On branch dev</span><br><span class="line">Your branch is up to date with <span class="string">'origin/dev'</span>.</span><br><span class="line"></span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">"git restore --staged &lt;file&gt;..."</span> to unstage)</span><br><span class="line">        new file:   new.txt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">albert@homepc MINGW64 /d/gitstart (dev)</span><br><span class="line">$ git reset HEAD new.txt</span><br><span class="line"></span><br><span class="line">albert@homepc MINGW64 /d/gitstart (dev)</span><br><span class="line">$ git status</span><br><span class="line">On branch dev</span><br><span class="line">Your branch is up to date with <span class="string">'origin/dev'</span>.</span><br><span class="line"></span><br><span class="line">Untracked files:</span><br><span class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> to include <span class="keyword">in</span> what will be committed)</span><br><span class="line">        new.txt</span><br><span class="line"></span><br><span class="line">nothing added to commit but untracked files present (use <span class="string">"git add"</span> to track)</span><br></pre></td></tr></table></figure><h2 id="还原02：版本库中的文件，修改或删除后未执行-git-add-操作"><a href="#还原02：版本库中的文件，修改或删除后未执行-git-add-操作" class="headerlink" title="还原02：版本库中的文件，修改或删除后未执行 git add 操作"></a>还原02：版本库中的文件，修改或删除后未执行 <code>git add</code> 操作</h2><p>我们直接修改 README.md 文件吧，删除刚才添加的未受版本管理的 new.txt，在 README.md 文件中添加内容，然后试着还原，这种情况常常出现在修改一个功能还未提交，但是先不要求修改了，可以直接还原。</p><p>这种情况可以使用<code>git restore file_name</code>、<code>git checkout -- file_name</code> 或者 <code>git reset --hard HEAD</code> 命令，最后的<code>git reset</code> 命令带有 <code>--hard</code> 参数不能再加文件目录，只能将工作区全还原。</p><h3 id="git-restore-2"><a href="#git-restore-2" class="headerlink" title="git restore"></a>git restore</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">albert@homepc MINGW64 /d/gitstart (dev)</span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">"new line"</span>&gt;&gt;README.md</span><br><span class="line"></span><br><span class="line">albert@homepc MINGW64 /d/gitstart (dev)</span><br><span class="line">$ git status</span><br><span class="line">On branch dev</span><br><span class="line">Your branch is up to date with <span class="string">'origin/dev'</span>.</span><br><span class="line"></span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">"git restore &lt;file&gt;..."</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line">        modified:   README.md</span><br><span class="line"></span><br><span class="line">no changes added to commit (use <span class="string">"git add"</span> and/or <span class="string">"git commit -a"</span>)</span><br><span class="line"></span><br><span class="line">albert@homepc MINGW64 /d/gitstart (dev)</span><br><span class="line">$ git restore README.md</span><br><span class="line"></span><br><span class="line">albert@homepc MINGW64 /d/gitstart (dev)</span><br><span class="line">$ git status</span><br><span class="line">On branch dev</span><br><span class="line">Your branch is up to date with <span class="string">'origin/dev'</span>.</span><br><span class="line"></span><br><span class="line">nothing to commit, working tree clean</span><br></pre></td></tr></table></figure><h3 id="git-checkout-1"><a href="#git-checkout-1" class="headerlink" title="git checkout"></a>git checkout</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">albert@homepc MINGW64 /d/gitstart (dev)</span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">"new line"</span>&gt;&gt;README.md</span><br><span class="line"></span><br><span class="line">albert@homepc MINGW64 /d/gitstart (dev)</span><br><span class="line">$ git status</span><br><span class="line">On branch dev</span><br><span class="line">Your branch is up to date with <span class="string">'origin/dev'</span>.</span><br><span class="line"></span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">"git restore &lt;file&gt;..."</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line">        modified:   README.md</span><br><span class="line"></span><br><span class="line">no changes added to commit (use <span class="string">"git add"</span> and/or <span class="string">"git commit -a"</span>)</span><br><span class="line"></span><br><span class="line">albert@homepc MINGW64 /d/gitstart (dev)</span><br><span class="line">$ git checkout -- README.md</span><br><span class="line"></span><br><span class="line">albert@homepc MINGW64 /d/gitstart (dev)</span><br><span class="line">$ git status</span><br><span class="line">On branch dev</span><br><span class="line">Your branch is up to date with <span class="string">'origin/dev'</span>.</span><br><span class="line"></span><br><span class="line">nothing to commit, working tree clean</span><br></pre></td></tr></table></figure><h3 id="git-reset-2"><a href="#git-reset-2" class="headerlink" title="git reset"></a>git reset</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">albert@homepc MINGW64 /d/gitstart (dev)</span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">"new line"</span>&gt;&gt;README.md</span><br><span class="line"></span><br><span class="line">albert@homepc MINGW64 /d/gitstart (dev)</span><br><span class="line">$ git status</span><br><span class="line">On branch dev</span><br><span class="line">Your branch is up to date with <span class="string">'origin/dev'</span>.</span><br><span class="line"></span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">"git restore &lt;file&gt;..."</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line">        modified:   README.md</span><br><span class="line"></span><br><span class="line">no changes added to commit (use <span class="string">"git add"</span> and/or <span class="string">"git commit -a"</span>)</span><br><span class="line"></span><br><span class="line">albert@homepc MINGW64 /d/gitstart (dev)</span><br><span class="line">$ git reset --hard HEAD README.md</span><br><span class="line">fatal: Cannot <span class="keyword">do</span> hard reset with paths.</span><br><span class="line"></span><br><span class="line">albert@homepc MINGW64 /d/gitstart (dev)</span><br><span class="line">$ git reset --hard HEAD</span><br><span class="line">HEAD is now at 3226b63 add readme file</span><br><span class="line"></span><br><span class="line">albert@homepc MINGW64 /d/gitstart (dev)</span><br><span class="line">$ git status</span><br><span class="line">On branch dev</span><br><span class="line">Your branch is up to date with <span class="string">'origin/dev'</span>.</span><br><span class="line"></span><br><span class="line">nothing to commit, working tree clean</span><br></pre></td></tr></table></figure><h2 id="还原03：版本库中的文件，修改或删除后执行了-git-add-操作"><a href="#还原03：版本库中的文件，修改或删除后执行了-git-add-操作" class="headerlink" title="还原03：版本库中的文件，修改或删除后执行了 git add 操作"></a>还原03：版本库中的文件，修改或删除后执行了 <code>git add</code> 操作</h2><p>使用了 <code>git add</code> 命令之后，文件的改变就放到了暂存区，这种情况可以使用<code>git restore --staged file_name</code> 或者 <code>git reset HEAD file_name</code> 命令。</p><h3 id="git-restore-3"><a href="#git-restore-3" class="headerlink" title="git restore"></a>git restore</h3><p>执行 <code>git restore --staged file_name</code> 实际上是使用版本库中的文件覆盖暂存区中的数据，执行结束后文件状态变成了 <code>&lt;还原02&gt;</code> 中的情况。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">albert@homepc MINGW64 /d/gitstart (dev)</span><br><span class="line">$ git status</span><br><span class="line">On branch dev</span><br><span class="line">Your branch is up to date with <span class="string">'origin/dev'</span>.</span><br><span class="line"></span><br><span class="line">nothing to commit, working tree clean</span><br><span class="line"></span><br><span class="line">albert@homepc MINGW64 /d/gitstart (dev)</span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">"test add"</span>&gt;&gt;README.md</span><br><span class="line"></span><br><span class="line">albert@homepc MINGW64 /d/gitstart (dev)</span><br><span class="line">$ git status</span><br><span class="line">On branch dev</span><br><span class="line">Your branch is up to date with <span class="string">'origin/dev'</span>.</span><br><span class="line"></span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">"git restore &lt;file&gt;..."</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line">        modified:   README.md</span><br><span class="line"></span><br><span class="line">no changes added to commit (use <span class="string">"git add"</span> and/or <span class="string">"git commit -a"</span>)</span><br><span class="line"></span><br><span class="line">albert@homepc MINGW64 /d/gitstart (dev)</span><br><span class="line">$ git add README.md</span><br><span class="line">warning: LF will be replaced by CRLF <span class="keyword">in</span> README.md.</span><br><span class="line">The file will have its original line endings <span class="keyword">in</span> your working directory</span><br><span class="line"></span><br><span class="line">albert@homepc MINGW64 /d/gitstart (dev)</span><br><span class="line">$ git status</span><br><span class="line">On branch dev</span><br><span class="line">Your branch is up to date with <span class="string">'origin/dev'</span>.</span><br><span class="line"></span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">"git restore --staged &lt;file&gt;..."</span> to unstage)</span><br><span class="line">        modified:   README.md</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">albert@homepc MINGW64 /d/gitstart (dev)</span><br><span class="line">$ git restore --staged README.md</span><br><span class="line"></span><br><span class="line">albert@homepc MINGW64 /d/gitstart (dev)</span><br><span class="line">$ git status</span><br><span class="line">On branch dev</span><br><span class="line">Your branch is up to date with <span class="string">'origin/dev'</span>.</span><br><span class="line"></span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">"git restore &lt;file&gt;..."</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line">        modified:   README.md</span><br><span class="line"></span><br><span class="line">no changes added to commit (use <span class="string">"git add"</span> and/or <span class="string">"git commit -a"</span>)</span><br></pre></td></tr></table></figure><h3 id="git-reset-3"><a href="#git-reset-3" class="headerlink" title="git reset"></a>git reset</h3><p><code>git reset</code> 命令如果加上 <code>--hard</code> 参数不能再加文件目录，只能将工作区全还原，如果不加默认参数为 <code>--mixed</code>，执行之后修改的文件状态变成了 <code>&lt;还原02&gt;</code> 中的情况。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">albert@homepc MINGW64 /d/gitstart (dev)</span><br><span class="line">$ git status</span><br><span class="line">On branch dev</span><br><span class="line">Your branch is up to date with <span class="string">'origin/dev'</span>.</span><br><span class="line"></span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">"git restore &lt;file&gt;..."</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line">        modified:   README.md</span><br><span class="line"></span><br><span class="line">no changes added to commit (use <span class="string">"git add"</span> and/or <span class="string">"git commit -a"</span>)</span><br><span class="line"></span><br><span class="line">albert@homepc MINGW64 /d/gitstart (dev)</span><br><span class="line">$ git add README.md</span><br><span class="line">warning: LF will be replaced by CRLF <span class="keyword">in</span> README.md.</span><br><span class="line">The file will have its original line endings <span class="keyword">in</span> your working directory</span><br><span class="line"></span><br><span class="line">albert@homepc MINGW64 /d/gitstart (dev)</span><br><span class="line">$ git status</span><br><span class="line">On branch dev</span><br><span class="line">Your branch is up to date with <span class="string">'origin/dev'</span>.</span><br><span class="line"></span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">"git restore --staged &lt;file&gt;..."</span> to unstage)</span><br><span class="line">        modified:   README.md</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">albert@homepc MINGW64 /d/gitstart (dev)</span><br><span class="line">$ git reset HEAD README.md</span><br><span class="line">Unstaged changes after reset:</span><br><span class="line">M       README.md</span><br><span class="line"></span><br><span class="line">albert@homepc MINGW64 /d/gitstart (dev)</span><br><span class="line">$ git status</span><br><span class="line">On branch dev</span><br><span class="line">Your branch is up to date with <span class="string">'origin/dev'</span>.</span><br><span class="line"></span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">"git restore &lt;file&gt;..."</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line">        modified:   README.md</span><br><span class="line"></span><br><span class="line">no changes added to commit (use <span class="string">"git add"</span> and/or <span class="string">"git commit -a"</span>)</span><br></pre></td></tr></table></figure><h2 id="还原04：版本库中的文件，修改或删除后执行了-git-add、git-commit-操作"><a href="#还原04：版本库中的文件，修改或删除后执行了-git-add、git-commit-操作" class="headerlink" title="还原04：版本库中的文件，修改或删除后执行了 git add、git commit 操作"></a>还原04：版本库中的文件，修改或删除后执行了 <code>git add</code>、<code>git commit</code> 操作</h2><p><code>git commit</code> 命令一旦执行了之后就形成了“历史”，我们叫做提交日志，要想回退就得有篡改历史的能力，很幸运 <code>Git</code> 给了我们这种能力，其实提交之后我们可以把本地文件反向修改，然后再提交一次，但是我们说的还原，一般都是只倒退，既然是错误的提交，我们就像把这段“历史”抹去，这时就要用到 <code>git reset HEAD^</code> 命令。</p><p>执行这个命令之后，刚刚的提交记录就被抹掉了，文件状态就回到了 <code>&lt;还原02&gt;</code> 的情况，如果加上参数 <code>--soft</code> 就会回到 <code>&lt;还原03&gt;</code> 的情况，如果加上参数 <code>--hard</code> ，就不能添加 <code>file_name</code> 这个文件名，然后整个工作区倒退到上一次修改之前，其他两种参数 <code>--mixed</code> 和 <code>--soft</code> 就可以指定添加名字。</p><p>这里的 <code>HEAD^</code> 表示最新版本的前一版，也就是倒数第二版本，可以类推，<code>HEAD^^</code> 表示倒数第三版本，<code>HEAD^^^</code> 表示倒数第四版本。</p><p>另外还有另一种写法 <code>HEAD~1</code> 表示最新版本的前一版，也就是倒数第二版本，<code>HEAD~2</code> 表示倒数第三版本，<code>HEAD~3</code> 表示倒数第四版本。</p><p>其中 <code>^</code> 和 <code>~</code> 的含义并不相同，涉及到合并分支的概念，有兴趣的话可以多了解下，这里就不展开了，继续还原当前这种情况，我们选择 <code>git reset HEAD^</code> 命令，先提交看下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">albert@homepc MINGW64 /d/gitstart (dev)</span><br><span class="line">$ git status</span><br><span class="line">On branch dev</span><br><span class="line">Your branch is up to date with <span class="string">'origin/dev'</span>.</span><br><span class="line"></span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">"git restore &lt;file&gt;..."</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line">        modified:   README.md</span><br><span class="line"></span><br><span class="line">no changes added to commit (use <span class="string">"git add"</span> and/or <span class="string">"git commit -a"</span>)</span><br><span class="line"></span><br><span class="line">albert@homepc MINGW64 /d/gitstart (dev)</span><br><span class="line">$ git add README.md</span><br><span class="line">warning: LF will be replaced by CRLF <span class="keyword">in</span> README.md.</span><br><span class="line">The file will have its original line endings <span class="keyword">in</span> your working directory</span><br><span class="line"></span><br><span class="line">albert@homepc MINGW64 /d/gitstart (dev)</span><br><span class="line">$ git commit -m<span class="string">"modify readme 1"</span></span><br><span class="line">[dev 8a40f22] modify readme 1</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line"></span><br><span class="line">albert@homepc MINGW64 /d/gitstart (dev)</span><br><span class="line">$ git status</span><br><span class="line">On branch dev</span><br><span class="line">Your branch is ahead of <span class="string">'origin/dev'</span> by 1 commit.</span><br><span class="line">  (use <span class="string">"git push"</span> to publish your <span class="built_in">local</span> commits)</span><br><span class="line"></span><br><span class="line">nothing to commit, working tree clean</span><br><span class="line"></span><br><span class="line">albert@homepc MINGW64 /d/gitstart (dev)</span><br><span class="line">$ git <span class="built_in">log</span> -2</span><br><span class="line">commit 8a40f229881da037ff99070fa205d7819ba9f51b (HEAD -&gt; dev)</span><br><span class="line">Author: albert &lt;qianxuan101@163.com&gt;</span><br><span class="line">Date:   Sat Mar 7 15:46:32 2020 +0800</span><br><span class="line"></span><br><span class="line">    modify readme 1</span><br><span class="line"></span><br><span class="line">commit 3226b63185a16398a02d5eaea47c95309ba49588 (origin/master, origin/dev, release, master)</span><br><span class="line">Author: albert &lt;qianxuan101@163.com&gt;</span><br><span class="line">Date:   Wed Feb 26 00:36:35 2020 +0800</span><br><span class="line"></span><br><span class="line">    add readme file</span><br></pre></td></tr></table></figure><p>然后再还原试试：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">albert@homepc MINGW64 /d/gitstart (dev)</span><br><span class="line">$ git reset HEAD^</span><br><span class="line">Unstaged changes after reset:</span><br><span class="line">M       README.md</span><br><span class="line"></span><br><span class="line">albert@homepc MINGW64 /d/gitstart (dev)</span><br><span class="line">$ git status</span><br><span class="line">On branch dev</span><br><span class="line">Your branch is up to date with <span class="string">'origin/dev'</span>.</span><br><span class="line"></span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">"git restore &lt;file&gt;..."</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line">        modified:   README.md</span><br><span class="line"></span><br><span class="line">no changes added to commit (use <span class="string">"git add"</span> and/or <span class="string">"git commit -a"</span>)</span><br><span class="line"></span><br><span class="line">albert@homepc MINGW64 /d/gitstart (dev)</span><br><span class="line">$ git <span class="built_in">log</span> -2</span><br><span class="line">commit 3226b63185a16398a02d5eaea47c95309ba49588 (HEAD -&gt; dev, origin/master, origin/dev, release, master)</span><br><span class="line">Author: albert &lt;qianxuan101@163.com&gt;</span><br><span class="line">Date:   Wed Feb 26 00:36:35 2020 +0800</span><br><span class="line"></span><br><span class="line">    add readme file</span><br></pre></td></tr></table></figure><p>怎么样，历史被我们抹除了，需要注意的是，如果想还原“历史”，那么 <code>git set</code> 命令后面不能跟文件名，也就是说必须整个还原到上一版本，否则就相当于将单个文件简单反向修改添加到暂存区，而之前对文件的修改保留在本地，文件的日志并没有回退，具体的文件状态还得你自己操作感受一下。</p><h2 id="还原05：版本库中的文件，修改或删除后执行了-git-add、git-commit、git-push-操作"><a href="#还原05：版本库中的文件，修改或删除后执行了-git-add、git-commit、git-push-操作" class="headerlink" title="还原05：版本库中的文件，修改或删除后执行了 git add、git commit、git push 操作"></a>还原05：版本库中的文件，修改或删除后执行了 <code>git add</code>、<code>git commit</code>、<code>git push</code> 操作</h2><p>这种情况就是还原远程仓库的日志记录了，实际上操作步骤先按照 <code>&lt;还原04&gt;</code> 来处理，然后将本地分支情况推送到远程分支即可。</p><p>我们先把刚才的修改提交，然后推送到远程分支，使用 <code>git status</code> 可以看到本地分支已经领先远程分支了(Your branch is ahead of ‘origin/dev’ by 1 commit.)， <code>git push</code> 操作之后两个分支同步了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">albert@homepc MINGW64 /d/gitstart (dev)</span><br><span class="line">$ git status</span><br><span class="line">On branch dev</span><br><span class="line">Your branch is ahead of <span class="string">'origin/dev'</span> by 1 commit.</span><br><span class="line">  (use <span class="string">"git push"</span> to publish your <span class="built_in">local</span> commits)</span><br><span class="line"></span><br><span class="line">nothing to commit, working tree clean</span><br><span class="line"></span><br><span class="line">albert@homepc MINGW64 /d/gitstart (dev)</span><br><span class="line">$ git <span class="built_in">log</span></span><br><span class="line">commit a5b6c18db71a0487f6316f5db4304a99984f2ab3 (HEAD -&gt; dev)</span><br><span class="line">Author: albert &lt;qianxuan101@163.com&gt;</span><br><span class="line">Date:   Sat Mar 7 15:51:56 2020 +0800</span><br><span class="line"></span><br><span class="line">    modify readme 1</span><br><span class="line"></span><br><span class="line">commit 3226b63185a16398a02d5eaea47c95309ba49588 (origin/master, origin/dev, release, master)</span><br><span class="line">Author: albert &lt;qianxuan101@163.com&gt;</span><br><span class="line">Date:   Wed Feb 26 00:36:35 2020 +0800</span><br><span class="line"></span><br><span class="line">    add readme file</span><br><span class="line"></span><br><span class="line">albert@homepc MINGW64 /d/gitstart (dev)</span><br><span class="line">$ git push</span><br><span class="line">Warning: Permanently added the ECDSA host key <span class="keyword">for</span> IP address <span class="string">'180.97.125.228'</span> to the list of known hosts.</span><br><span class="line">Enumerating objects: 5, <span class="keyword">done</span>.</span><br><span class="line">Counting objects: 100% (5/5), <span class="keyword">done</span>.</span><br><span class="line">Writing objects: 100% (3/3), 286 bytes | 286.00 KiB/s, <span class="keyword">done</span>.</span><br><span class="line">Total 3 (delta 0), reused 0 (delta 0)</span><br><span class="line">remote: Powered by GITEE.COM [GNK-3.8]</span><br><span class="line">To gitee.com:myname/gitstart.git</span><br><span class="line">   3226b63..a5b6c18  dev -&gt; dev</span><br></pre></td></tr></table></figure><p>这时通过远程仓库的管理软件，你可以看到远程分支已经有了最新的提交，然后我们可以参考 <code>&lt;还原04&gt;</code> 的情况，先将本地日志还原，再推送到远程仓库。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">albert@homepc MINGW64 /d/gitstart (dev)</span><br><span class="line">$ git reset HEAD^</span><br><span class="line">Unstaged changes after reset:</span><br><span class="line">M       README.md</span><br><span class="line"></span><br><span class="line">albert@homepc MINGW64 /d/gitstart (dev)</span><br><span class="line">$ git status</span><br><span class="line">On branch dev</span><br><span class="line">Your branch is behind <span class="string">'origin/dev'</span> by 1 commit, and can be fast-forwarded.</span><br><span class="line">  (use <span class="string">"git pull"</span> to update your <span class="built_in">local</span> branch)</span><br><span class="line"></span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">"git restore &lt;file&gt;..."</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line">        modified:   README.md</span><br><span class="line"></span><br><span class="line">no changes added to commit (use <span class="string">"git add"</span> and/or <span class="string">"git commit -a"</span>)</span><br><span class="line"></span><br><span class="line">albert@homepc MINGW64 /d/gitstart (dev)</span><br><span class="line">$ git <span class="built_in">log</span></span><br><span class="line">commit 3226b63185a16398a02d5eaea47c95309ba49588 (HEAD -&gt; dev, origin/master, release, master)</span><br><span class="line">Author: albert &lt;qianxuan101@163.com&gt;</span><br><span class="line">Date:   Wed Feb 26 00:36:35 2020 +0800</span><br><span class="line"></span><br><span class="line">    add readme file</span><br><span class="line"></span><br><span class="line">albert@homepc MINGW64 /d/gitstart (dev)</span><br><span class="line">$ git push</span><br><span class="line">To gitee.com:myname/gitstart.git</span><br><span class="line"> ! [rejected]        dev -&gt; dev (non-fast-forward)</span><br><span class="line">error: failed to push some refs to <span class="string">'git@gitee.com:myname/gitstart.git'</span></span><br><span class="line">hint: Updates were rejected because the tip of your current branch is behind</span><br><span class="line">hint: its remote counterpart. Integrate the remote changes (e.g.</span><br><span class="line">hint: <span class="string">'git pull ...'</span>) before pushing again.</span><br><span class="line">hint: See the <span class="string">'Note about fast-forwards'</span> <span class="keyword">in</span> <span class="string">'git push --help'</span> <span class="keyword">for</span> details.</span><br></pre></td></tr></table></figure><p>和想象的不太一样的，这种情况是远程仓库的记录领先，无法直接推送，此时可以添加 <code>-f</code> 参数，用本地提交记录覆盖远程分支记录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">albert@homepc MINGW64 /d/gitstart (dev)</span><br><span class="line">$ git push -f</span><br><span class="line">Total 0 (delta 0), reused 0 (delta 0)</span><br><span class="line">remote: Powered by GITEE.COM [GNK-3.8]</span><br><span class="line">To gitee.com:myname/gitstart.git</span><br><span class="line"> + a5b6c18...3226b63 dev -&gt; dev (forced update)</span><br></pre></td></tr></table></figure><p>这次再查询远程分支记录，发现也被回退了，目的达成。</p><h2 id="还原06：两次git-commit-之后产生两条日志，只还原第一次提交"><a href="#还原06：两次git-commit-之后产生两条日志，只还原第一次提交" class="headerlink" title="还原06：两次git commit 之后产生两条日志，只还原第一次提交"></a>还原06：两次<code>git commit</code> 之后产生两条日志，只还原第一次提交</h2><p>这种情况其实发生了两次修改和两次提交，和 <code>&lt;还原05&gt;</code> 情况不同的是要还原的提交不是最后一次，如果使用 <code>git reset</code> 命令必然将最后一次修改也还原了，虽然不能直接完成，但是给我们提供了解决问题的思路：</p><p>第一种方法：直接使用 <code>git reset HEAD^^</code> 命令还原两次提交，然后在工作区将文件按第二次修改再改一次进行提交，这种方法适用于想要抹除第一次提交历史的情况。</p><p>第二种方法：如果你不在意提交历史，只是想还原第一次修改，那么可以使用 <code>git revert HEAD^</code> 命令来反向修改那一次变化，修改之后会自动添加到暂存区，等待提交。</p><p>先来修改提交两次，产生两次记录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">albert@homepc MINGW64 /d/gitstart (dev)</span><br><span class="line">$ git status</span><br><span class="line">On branch dev</span><br><span class="line">Your branch is up to date with <span class="string">'origin/dev'</span>.</span><br><span class="line"></span><br><span class="line">nothing to commit, working tree clean</span><br><span class="line"></span><br><span class="line">albert@homepc MINGW64 /d/gitstart (dev)</span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">"m1"</span>&gt;&gt;README.md</span><br><span class="line"></span><br><span class="line">albert@homepc MINGW64 /d/gitstart (dev)</span><br><span class="line">$ git add README.md</span><br><span class="line">warning: LF will be replaced by CRLF <span class="keyword">in</span> README.md.</span><br><span class="line">The file will have its original line endings <span class="keyword">in</span> your working directory</span><br><span class="line"></span><br><span class="line">albert@homepc MINGW64 /d/gitstart (dev)</span><br><span class="line">$ git commit -m<span class="string">"modify README 1"</span></span><br><span class="line">[dev e570df1] modify README 1</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line"></span><br><span class="line">albert@homepc MINGW64 /d/gitstart (dev)</span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">"m2"</span>&gt;&gt;README.md</span><br><span class="line"></span><br><span class="line">albert@homepc MINGW64 /d/gitstart (dev)</span><br><span class="line">$ git add README.md</span><br><span class="line">warning: LF will be replaced by CRLF <span class="keyword">in</span> README.md.</span><br><span class="line">The file will have its original line endings <span class="keyword">in</span> your working directory</span><br><span class="line"></span><br><span class="line">albert@homepc MINGW64 /d/gitstart (dev)</span><br><span class="line">$ git commit -m<span class="string">"modify README 2"</span></span><br><span class="line">[dev 140547f] modify README 2</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line">gi</span><br><span class="line">albert@homepc MINGW64 /d/gitstart (dev)</span><br><span class="line">$ git <span class="built_in">log</span></span><br><span class="line">commit 140547f8d0b10d9a388beaf2ce522c38c878a839 (HEAD -&gt; dev)</span><br><span class="line">Author: albert &lt;qianxuan101@163.com&gt;</span><br><span class="line">Date:   Sat Mar 7 16:26:17 2020 +0800</span><br><span class="line"></span><br><span class="line">    modify README 2</span><br><span class="line"></span><br><span class="line">commit e570df134b39ee7424bc8c48c1067e72c3fb9637</span><br><span class="line">Author: albert &lt;qianxuan101@163.com&gt;</span><br><span class="line">Date:   Sat Mar 7 16:26:07 2020 +0800</span><br><span class="line"></span><br><span class="line">    modify README 1</span><br><span class="line"></span><br><span class="line">commit 3226b63185a16398a02d5eaea47c95309ba49588 (origin/master, origin/dev, release, master)</span><br><span class="line">Author: albert &lt;qianxuan101@163.com&gt;</span><br><span class="line">Date:   Wed Feb 26 00:36:35 2020 +0800</span><br><span class="line"></span><br><span class="line">    add readme file</span><br><span class="line"></span><br><span class="line">albert@homepc MINGW64 /d/gitstart (dev)</span><br><span class="line">$ cat README.md</span><br><span class="line">learn git branch <span class="built_in">command</span></span><br><span class="line">m1</span><br><span class="line">m2</span><br></pre></td></tr></table></figure><p>然后使用 <code>git revert HEAD^</code> 还原第一次修改记录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">albert@homepc MINGW64 /d/gitstart (dev)</span><br><span class="line">$ git revert HEAD^</span><br><span class="line">Auto-merging README.md</span><br><span class="line">CONFLICT (content): Merge conflict <span class="keyword">in</span> README.md</span><br><span class="line">error: could not revert e570df1... modify README 1</span><br><span class="line">hint: after resolving the conflicts, mark the corrected paths</span><br><span class="line">hint: with <span class="string">'git add &lt;paths&gt;'</span> or <span class="string">'git rm &lt;paths&gt;'</span></span><br><span class="line">hint: and commit the result with <span class="string">'git commit'</span></span><br><span class="line"></span><br><span class="line">albert@homepc MINGW64 /d/gitstart (dev|REVERTING)</span><br><span class="line">$ vi README.md</span><br><span class="line"></span><br><span class="line">albert@homepc MINGW64 /d/gitstart (dev|REVERTING)</span><br><span class="line">$ git add README.md</span><br><span class="line"></span><br><span class="line">albert@homepc MINGW64 /d/gitstart (dev|REVERTING)</span><br><span class="line">$ git commit</span><br><span class="line">[dev 6ae97d0] Revert <span class="string">"modify README 1"</span></span><br><span class="line"> 1 file changed, 1 deletion(-)</span><br><span class="line"></span><br><span class="line">albert@homepc MINGW64 /d/gitstart (dev)</span><br><span class="line">$ git <span class="built_in">log</span></span><br><span class="line">commit 6ae97d0e136abc1ed241854298037ca9d1c4460c (HEAD -&gt; dev)</span><br><span class="line">Author: albert &lt;qianxuan101@163.com&gt;</span><br><span class="line">Date:   Sat Mar 7 16:31:50 2020 +0800</span><br><span class="line"></span><br><span class="line">    Revert <span class="string">"modify README 1"</span></span><br><span class="line"></span><br><span class="line">    This reverts commit e570df134b39ee7424bc8c48c1067e72c3fb9637.</span><br><span class="line"></span><br><span class="line">commit 140547f8d0b10d9a388beaf2ce522c38c878a839</span><br><span class="line">Author: albert &lt;qianxuan101@163.com&gt;</span><br><span class="line">Date:   Sat Mar 7 16:26:17 2020 +0800</span><br><span class="line"></span><br><span class="line">    modify README 2</span><br><span class="line"></span><br><span class="line">commit e570df134b39ee7424bc8c48c1067e72c3fb9637</span><br><span class="line">Author: albert &lt;qianxuan101@163.com&gt;</span><br><span class="line">Date:   Sat Mar 7 16:26:07 2020 +0800</span><br><span class="line"></span><br><span class="line">    modify README 1</span><br><span class="line"></span><br><span class="line">commit 3226b63185a16398a02d5eaea47c95309ba49588 (origin/master, origin/dev, release, master)</span><br><span class="line">Author: albert &lt;qianxuan101@163.com&gt;</span><br><span class="line">Date:   Wed Feb 26 00:36:35 2020 +0800</span><br><span class="line"></span><br><span class="line">    add readme file</span><br></pre></td></tr></table></figure><p>因为修改了同一个文件，还原的时候还产生了冲突，解决冲突之后才提交，看日志发现这是一条新的记录，在实际操作的过程中可能会发生比这还要麻烦的场景，多练就好了。</p><h1 id="常用集合"><a href="#常用集合" class="headerlink" title="常用集合"></a>常用集合</h1><p>使用 <code>Git</code> 进行版本管理时，遇到的回退情况远不止这么多，这只是我目前常见的，之后遇到还会补充，每种情况我们其实不止有一种解决方式，接下来对于每种情况给一个我个人常用的处理方式，因为 <code>git checkout</code> 的作用被逐渐拆分成更具体的 <code>git switch</code> 和 <code>git restore</code>，我们尽量选择功能明确的命令：</p><ol><li>还原00：工作区中未加到暂存区和版本库的文件，还原今天所做的修改<ul><li>尝试下Ctrl+z吧，不行就找找自动保存的缓存文件，看看能不能找到之前版本</li></ul></li><li>还原01：工作区中未加到暂存区和版本库的文件，执行了 <code>git add</code> 操作<ul><li>直接使用 <code>git restore --staged file_name</code> 命令，如果版本不支持则使用 <code>git rm --cached file_name</code></li></ul></li><li>还原02：版本库中的文件，修改或删除后未执行 <code>git add</code> 操作<ul><li>直接使用 <code>git restore file_name</code> 命令，如果版本不支持则使用 <code>git checkout -- file_name</code></li></ul></li><li>还原03：版本库中的文件，修改或删除后执行了 <code>git add</code> 操作<ul><li>直接使用 <code>git restore --staged file_name</code> 命令，按 <code>&lt;还原02&gt;</code> 情况处理</li></ul></li><li>还原04：版本库中的文件，修改或删除后执行了 <code>git add</code>、<code>git commit</code> 操作<ul><li>直接使用 <code>git reset HEAD^</code> 命令，按 <code>&lt;还原02&gt;</code> 情况处理，或者使用 <code>git reset --soft HEAD^</code> 命令，按 <code>&lt;还原03&gt;</code> 情况处理</li></ul></li><li>还原05：版本库中的文件，修改或删除后执行了 <code>git add</code>、<code>git commit</code>、<code>git push</code> 操作<ul><li>先按照 <code>&lt;还原04&gt;</code> 情况处理，然后使用 <code>git push -f</code> 命令</li></ul></li><li>还原06：两次<code>git commit</code> 之后产生两条日志，只还原第一次提交<ul><li>使用 <code>git revert HEAD^</code> 命令，解决冲突后提交，revert 后面跟具体的 <code>commit id</code> 也可以。</li></ul></li></ol><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>参考这些具体的例子你会发现，很多操作选择在使用 <code>git status</code> 之后都有列举</li><li>所以说 <code>git status</code> 是一个可以提示你做选择的强大帮手，不知所措时可以试试它</li><li>Git 2.23版本之后学会用 <code>git switch</code> 和 <code>git restore</code> 命令，因为之前 <code>git checkout</code> 背负了太多了</li><li>最后放一幅图吧，只画了主要的，没有画出全部情况，否则会很乱，可以对照着练习一下</li></ul><p><img src="https://cdn.jsdelivr.net/gh/albertgithubhome/cdn/img/gitfilestate.png" alt="gitfilestate"></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;在 &lt;code&gt;Git&lt;/code&gt; 中没有真正的方法来做任何事情，这就是它的妙处！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;经常会听到别人说，如果时光可以倒流，我将会如何如何，可是现阶段的科技还达不到时光倒流的目的，或许在《三体》世界的四维裂缝里可以试一下。现实的世界中找不到后悔药，但是在代码的世界里却可以轻松实现，错误的BUG修改、砍掉的做了一半的功能都可以轻松回退，不留一丝痕迹，回滚之后一切又可以重新开始了。&lt;/p&gt;
    
    </summary>
    
      <category term="Git" scheme="http://AlbertGithubHome.github.io/blog/categories/Git/"/>
    
    
      <category term="git" scheme="http://AlbertGithubHome.github.io/blog/tags/git/"/>
    
      <category term="checkout" scheme="http://AlbertGithubHome.github.io/blog/tags/checkout/"/>
    
      <category term="reset" scheme="http://AlbertGithubHome.github.io/blog/tags/reset/"/>
    
      <category term="revert" scheme="http://AlbertGithubHome.github.io/blog/tags/revert/"/>
    
      <category term="restore" scheme="http://AlbertGithubHome.github.io/blog/tags/restore/"/>
    
  </entry>
  
  <entry>
    <title>git branch常用分支操作</title>
    <link href="http://AlbertGithubHome.github.io/blog/2020/02/25/git-branch%E5%B8%B8%E7%94%A8%E5%88%86%E6%94%AF%E6%93%8D%E4%BD%9C/"/>
    <id>http://AlbertGithubHome.github.io/blog/2020/02/25/git-branch常用分支操作/</id>
    <published>2020-02-25T15:20:55.000Z</published>
    <updated>2020-02-29T13:37:28.478Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近代码的版本控制工具由<code>SVN</code>换成了<code>Git</code>，只用管理个人项目常用的灵魂三步<code>git add</code>、<code>git commit</code>、<code>git push</code>看来是行不通了，之前虽然也一直在用 <code>git</code>，但是用法很有限，主要集中在前面提到的三步，所以为了更好的工作，我决定还是好好总结一下。</p><p>分支在<code>Git</code>的操作里有着很重要的地位，代表了不同的开发线路，创建一个分支，也就多了一个索引文件，相比于<code>SVN</code>分支拷贝全部文件来说来方便的多，所以<code>Git</code>使得按功能分支的开发模式变得非常简单，在开发过程中常常需要对分支进行操作。</p><a id="more"></a><h1 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h1><p>本来就几个分支，操作上也没有太麻烦，但是加入了远程仓库以后，事情变得复杂起来。有了远程仓库一般意味着代码开发需要多人合作了，这时候常常会产生冲突，分支合并时也变得不那么容易了。</p><p>远程仓库其实也很好理解，就是放在远处用来保存代码资源的一个仓库，其实和本地的代码库没有什么区别，这个远程仓库主要是为了把大家修改的代码都合并到一起，给大家提供一个统一的目标点。</p><p>远程仓库究竟有多远，常见的代码托管平台：<code>github</code>、<code>gitlab</code>、码云都可以提供远程仓库，如果你在月球上放置一台可以联网的代码仓库服务器，那么距离就是38.4万千米，但是远程仓库也可以很近，你也可以把本机电脑的D盘里的代码仓库作为E盘的代码仓库的远程仓库，或许远程仓库可能只和你隔了一个文件夹。</p><p>由于网络的原因，<code>github</code> 和 <code>gitlab</code> 访问常常很慢，所以为了做练习测试推送，我在码云创建了一个仓库 <code>gitstart</code>，它的地址大概是这个样子：<code>git@gitee.com:myname/gitstart.git</code>，创建的方法一搜一大把，上面提到的几个托管平台，在哪创建都可以，一定要记住地址，因为后面还要用到。</p><h1 id="建立联系"><a href="#建立联系" class="headerlink" title="建立联系"></a>建立联系</h1><h2 id="本地创建文件夹并进入"><a href="#本地创建文件夹并进入" class="headerlink" title="本地创建文件夹并进入"></a>本地创建文件夹并进入</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">albert@homepc MINGW64 /d</span><br><span class="line">$ mkdir gitstart</span><br><span class="line"></span><br><span class="line">albert@homepc MINGW64 /d</span><br><span class="line">$ <span class="built_in">cd</span> gitstart/</span><br><span class="line"></span><br><span class="line">albert@homepc MINGW64 /d/gitstart</span><br><span class="line">$</span><br></pre></td></tr></table></figure><p>这里的文件夹名字可以和远程仓库不同，但是为了看起来方便对应，还是取相同的名字好一点。</p><h2 id="初始化仓库"><a href="#初始化仓库" class="headerlink" title="初始化仓库"></a>初始化仓库</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">albert@homepc MINGW64 /d/gitstart</span><br><span class="line">$ git init</span><br><span class="line">Initialized empty Git repository <span class="keyword">in</span> D:/gitstart/.git/</span><br><span class="line"></span><br><span class="line">albert@homepc MINGW64 /d/gitstart (master)</span><br><span class="line">$</span><br></pre></td></tr></table></figure><h3 id="临时插播好奇心（不在流程中）"><a href="#临时插播好奇心（不在流程中）" class="headerlink" title="临时插播好奇心（不在流程中）"></a>临时插播好奇心（不在流程中）</h3><p>目前这个状态有点意思，初始化完之后，<code>(master)</code> 这个字符串表示当前是在 <code>master</code>分支，查一下日志看看：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">albert@homepc MINGW64 /d/gitstart (master)</span><br><span class="line">$ git <span class="built_in">log</span></span><br><span class="line">fatal: your current branch <span class="string">'master'</span> does not have any commits yet</span><br><span class="line"></span><br><span class="line">albert@homepc MINGW64 /d/gitstart (master)</span><br><span class="line">$</span><br></pre></td></tr></table></figure><p>提示也是正确的，说 <code>master</code>分支没有任何提交，但是我们查询一下分支看看：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">albert@homepc MINGW64 /d/gitstart (master)</span><br><span class="line">$ git branch -a</span><br><span class="line"></span><br><span class="line">albert@homepc MINGW64 /d/gitstart (master)</span><br><span class="line">$</span><br></pre></td></tr></table></figure><p>居然是空的，没有分支，查询 <code>.git\HEAD</code> 文件发现里面有一行 <code>ref: refs/heads/master</code>，说明当前分支时 <code>master</code>，但是为什么查询分支没有结果呢？</p><p>打开 <code>.git\refs\heads</code> 目录，发现这个文件夹下根本没有 <code>master</code>文件，其实想想也对，<code>Git</code> 中的分支其实对应着 <code>commit id</code>，现在什么都没有提交，master 也就找不到 <code>commit id</code>，所以就是有 <code>master</code> 文件，里面也不知道写什么。</p><h2 id="查询远程仓库"><a href="#查询远程仓库" class="headerlink" title="查询远程仓库"></a>查询远程仓库</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">albert@homepc MINGW64 /d/gitstart (master)</span><br><span class="line">$ git remote -v</span><br><span class="line"></span><br><span class="line">albert@homepc MINGW64 /d/gitstart (master)</span><br><span class="line">$</span><br></pre></td></tr></table></figure><p>依旧什么内容都没有，说明还没有和远程仓库建立联系。</p><h2 id="与远程仓库建立对应关系"><a href="#与远程仓库建立对应关系" class="headerlink" title="与远程仓库建立对应关系"></a>与远程仓库建立对应关系</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">albert@homepc MINGW64 /d/gitstart (master)</span><br><span class="line">$ git remote add origin git@gitee.com:myname/gitstart.git</span><br><span class="line"></span><br><span class="line">albert@homepc MINGW64 /d/gitstart (master)</span><br><span class="line">$ git remote -v</span><br><span class="line">origin  git@gitee.com:myname/gitstart.git (fetch)</span><br><span class="line">origin  git@gitee.com:myname/gitstart.git (push)</span><br><span class="line"></span><br><span class="line">albert@homepc MINGW64 /d/gitstart (master)</span><br><span class="line">$</span><br></pre></td></tr></table></figure><p>这一步需要注意，origin看起来就是一个远程仓库的别名，代表着 <code>git@gitee.com:myname/gitstart.git</code> 这个代码仓库，刚刚提到过，这个远程仓库也可以是本地的，所以你添加<code>git remote add origin d:/test</code> 也是可以的，就表明 <code>gitstart</code> 的远程仓库是本地的 <code>test</code> 仓库。</p><h1 id="第一个分支"><a href="#第一个分支" class="headerlink" title="第一个分支"></a>第一个分支</h1><p>刚刚说过，现在本地库的状态有些特殊，实际上刚刚在码云上创建的 <code>git@gitee.com:myname/gitstart.git</code> 库也很特殊，他们都没有真正的分支，这时只要我们成功提交一次，创建一个<code>commit id</code>，就相当于初始化了<code>master</code>分支。</p><h2 id="添加README文件"><a href="#添加README文件" class="headerlink" title="添加README文件"></a>添加README文件</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">albert@homepc MINGW64 /d/gitstart (master)</span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">"learn git branch command"</span>&gt;README.md</span><br><span class="line"></span><br><span class="line">albert@homepc MINGW64 /d/gitstart (master)</span><br><span class="line">$ git add README.md</span><br><span class="line">warning: LF will be replaced by CRLF <span class="keyword">in</span> README.md.</span><br><span class="line">The file will have its original line endings <span class="keyword">in</span> your working directory</span><br><span class="line"></span><br><span class="line">albert@homepc MINGW64 /d/gitstart (master)</span><br><span class="line">$ git commit -m<span class="string">"add readme file"</span></span><br><span class="line">[master (root-commit) 3226b63] add readme file</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line"> create mode 100644 README.md</span><br></pre></td></tr></table></figure><h2 id="查询当前分支"><a href="#查询当前分支" class="headerlink" title="查询当前分支"></a>查询当前分支</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">albert@homepc MINGW64 /d/gitstart (master)</span><br><span class="line">$ git branch -a</span><br><span class="line">* master</span><br></pre></td></tr></table></figure><p>这次可以是出现了，分支为 <code>master</code>，前面的 <code>*</code> 表示为当前分支。</p><h2 id="将分支推送到远程仓库"><a href="#将分支推送到远程仓库" class="headerlink" title="将分支推送到远程仓库"></a>将分支推送到远程仓库</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">albert@homepc MINGW64 /d/gitstart (master)</span><br><span class="line">$ git push -u origin master</span><br><span class="line">Enumerating objects: 3, <span class="keyword">done</span>.</span><br><span class="line">Counting objects: 100% (3/3), <span class="keyword">done</span>.</span><br><span class="line">Writing objects: 100% (3/3), 248 bytes | 248.00 KiB/s, <span class="keyword">done</span>.</span><br><span class="line">Total 3 (delta 0), reused 0 (delta 0)</span><br><span class="line">remote: Powered by GITEE.COM [GNK-3.8]</span><br><span class="line">To gitee.com:myname/gitstart.git</span><br><span class="line"> * [new branch]      master -&gt; master</span><br><span class="line">Branch <span class="string">'master'</span> <span class="built_in">set</span> up to track remote branch <span class="string">'master'</span> from <span class="string">'origin'</span>.</span><br></pre></td></tr></table></figure><p>至此，本地仓库和远程仓库就建立了联系，下面可以开始学习 <code>Git</code> 分支命令了。</p><h1 id="分支操作"><a href="#分支操作" class="headerlink" title="分支操作"></a>分支操作</h1><h2 id="新建分支"><a href="#新建分支" class="headerlink" title="新建分支"></a>新建分支</h2><p>新建分支可以使用 <code>git branch branch_name</code> 命令，以下就是一个创建名为 <code>release</code> 分支的命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">albert@homepc MINGW64 /d/gitstart (master)</span><br><span class="line">$ git branch release</span><br></pre></td></tr></table></figure><p>也可以使用 <code>git checkout -b branch_name</code> 来创建一个新分支，创建完会自动切换到新分支：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">albert@homepc MINGW64 /d/gitstart (master)</span><br><span class="line">$ git checkout -b dev</span><br><span class="line">Switched to a new branch <span class="string">'dev'</span></span><br><span class="line"></span><br><span class="line">albert@homepc MINGW64 /d/gitstart (dev)</span><br><span class="line">$</span><br></pre></td></tr></table></figure><h2 id="切换分支"><a href="#切换分支" class="headerlink" title="切换分支"></a>切换分支</h2><p>这是一个很奇怪的命令，命令格式为 <code>git checkout branch_name</code>，总感觉 <code>checkout</code> 子命令包揽了不属于自己的工作，如果在<code>git branch</code>的基础上加一个参数会更合理的一点，但这和切换分支的实际含义可能还有关系，切换分支其实就是修改HEAD文件中的 <code>commit id</code>，而没有真正的发生切换。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">albert@homepc MINGW64 /d/gitstart (dev)</span><br><span class="line">$ git checkout release</span><br><span class="line">Switched to branch <span class="string">'release'</span></span><br><span class="line"></span><br><span class="line">albert@homepc MINGW64 /d/gitstart (release)</span><br><span class="line">$ git checkout dev</span><br><span class="line">Switched to branch <span class="string">'dev'</span></span><br><span class="line"></span><br><span class="line">albert@homepc MINGW64 /d/gitstart (dev)</span><br><span class="line">$</span><br></pre></td></tr></table></figure><h2 id="查看本地分支"><a href="#查看本地分支" class="headerlink" title="查看本地分支"></a>查看本地分支</h2><p>像刚才我们创建的 <code>release</code> 分支和 <code>dev</code> 分支都是在本地创建的，这样的分支通过 <code>git branch</code> 命令就可以查看</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">albert@homepc MINGW64 /d/gitstart (dev)</span><br><span class="line">$ git branch</span><br><span class="line">* dev</span><br><span class="line">  master</span><br><span class="line">  release</span><br></pre></td></tr></table></figure><p>这样就列举了本地的所有分支，在当前分支名字 <code>dev</code> 前面哈还有一个 <code>*</code> 作为标记</p><h2 id="查看远程分支"><a href="#查看远程分支" class="headerlink" title="查看远程分支"></a>查看远程分支</h2><p>只要在上面的命令基础上加上 <code>-r</code> 参数就行了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">albert@homepc MINGW64 /d/gitstart (dev)</span><br><span class="line">$ git branch -r</span><br><span class="line">  origin/master</span><br></pre></td></tr></table></figure><p>查询到的分支只有 <code>origin/master</code> 一个，这个分支是一开始我们进行第一次提交产生 <code>master</code> 分支之后，通过 <code>git push -u origin master</code> 推送到远程仓库的，所以现在只有一个。</p><h2 id="查看所有分支"><a href="#查看所有分支" class="headerlink" title="查看所有分支"></a>查看所有分支</h2><p>所有分支包括本地分支和远程分支，将 <code>-r</code> 参数换成 <code>-a</code> 参数就可以了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">albert@homepc MINGW64 /d/gitstart (dev)</span><br><span class="line">$ git branch -a</span><br><span class="line">* dev</span><br><span class="line">  master</span><br><span class="line">  release</span><br><span class="line">  remotes/origin/master</span><br></pre></td></tr></table></figure><h2 id="将本地分支推送到远程仓库"><a href="#将本地分支推送到远程仓库" class="headerlink" title="将本地分支推送到远程仓库"></a>将本地分支推送到远程仓库</h2><p>其实之前已经操作过了，可以试着复习一下，<code>git push -u origin branch_name</code>，其实这是一个简写，<code>-u</code> 可以写成 <code>--set-upstream</code> 表示设置上游分支，其实就是和远程仓库的分支建立联系。</p><p><code>branch_name</code> 也是 <code>local_branch_name:remote_branch_name</code>的一种简写，冒号前表示本地分支，冒号后面表示远程分支，如果只写一个就表示两个分支名相同，远程仓库中如果没有这个分支就会新建一个。</p><p>也就是说 <code>git push -u origin dev</code> 和 <code>git push--set-upstream origin dev:dev</code> 是一样的，下面来试一下，然后查看一下分支：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">albert@homepc MINGW64 /d/gitstart (dev)</span><br><span class="line">$ git push -u origin dev</span><br><span class="line">Total 0 (delta 0), reused 0 (delta 0)</span><br><span class="line">remote: Powered by GITEE.COM [GNK-3.8]</span><br><span class="line">remote: Create a pull request <span class="keyword">for</span> <span class="string">'dev'</span> on Gitee by visiting:</span><br><span class="line">remote:     https://gitee.com/myname/gitstart/pull/new/myname:dev...myname:master</span><br><span class="line">To gitee.com:myname/gitstart.git</span><br><span class="line"> * [new branch]      dev -&gt; dev</span><br><span class="line">Branch <span class="string">'dev'</span> <span class="built_in">set</span> up to track remote branch <span class="string">'dev'</span> from <span class="string">'origin'</span>.</span><br><span class="line"></span><br><span class="line">albert@homepc MINGW64 /d/gitstart (dev)</span><br><span class="line">$ git branch -a</span><br><span class="line">* dev</span><br><span class="line">  master</span><br><span class="line">  release</span><br><span class="line">  remotes/origin/dev</span><br><span class="line">  remotes/origin/master</span><br></pre></td></tr></table></figure><p>冒号前后的米名字是不是一定相同呢？完全没有必要，我们可以让本地的 <code>release</code> 分支对应远程的 <code>master</code> 分支，只不过这样怪怪的，但是操作上完全可以的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">albert@homepc MINGW64 /d/gitstart (dev)</span><br><span class="line">$ git checkout release</span><br><span class="line">Switched to branch <span class="string">'release'</span></span><br><span class="line"></span><br><span class="line">albert@homepc MINGW64 /d/gitstart (release)</span><br><span class="line">$ git push -u origin release:master</span><br><span class="line">Everything up-to-date</span><br><span class="line">Branch <span class="string">'release'</span> <span class="built_in">set</span> up to track remote branch <span class="string">'master'</span> from <span class="string">'origin'</span>.</span><br></pre></td></tr></table></figure><h2 id="查看本地分支与远程分支对应关系"><a href="#查看本地分支与远程分支对应关系" class="headerlink" title="查看本地分支与远程分支对应关系"></a>查看本地分支与远程分支对应关系</h2><p>这个也是刚刚知道的，可以使用 <code>git branch -vv</code> 命令，注意是两个 <code>v</code>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">albert@homepc MINGW64 /d/gitstart (release)</span><br><span class="line">$ git branch -vv</span><br><span class="line">  dev     3226b63 [origin/dev] add readme file</span><br><span class="line">  master  3226b63 [origin/master] add readme file</span><br><span class="line">* release 3226b63 [origin/master] add readme file</span><br></pre></td></tr></table></figure><p>执行这个命令之后可以看出，本地的 <code>master</code> 和 <code>release</code> 分支都对应着远程的 <code>master</code> 分支</p><h2 id="删除本地分支"><a href="#删除本地分支" class="headerlink" title="删除本地分支"></a>删除本地分支</h2><p>我们先复习一下新建分支，然后把它推送到远程仓库，再使用 <code>git branch -d branch_name</code> 命令进行删除</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">albert@homepc MINGW64 /d/gitstart (release)</span><br><span class="line">$ git checkout -b feature_test</span><br><span class="line">Switched to a new branch <span class="string">'feature_test'</span></span><br><span class="line"></span><br><span class="line">albert@homepc MINGW64 /d/gitstart (feature_test)</span><br><span class="line">$ git push origin feature_test</span><br><span class="line">Total 0 (delta 0), reused 0 (delta 0)</span><br><span class="line"> remote: Powered by GITEE.COM [GNK-3.8]</span><br><span class="line">remote: Create a pull request <span class="keyword">for</span> <span class="string">'feature_test'</span> on Gitee by visiting:</span><br><span class="line">remote:     https://gitee.com/myname/gitstart/pull/new/myname:feature_test...myname:master</span><br><span class="line">To gitee.com:myname/gitstart.git</span><br><span class="line"> * [new branch]      feature_test -&gt; feature_test</span><br><span class="line"></span><br><span class="line">albert@homepc MINGW64 /d/gitstart (feature_test)</span><br><span class="line">$ git branch -a</span><br><span class="line">  dev</span><br><span class="line">* feature_test</span><br><span class="line">  master</span><br><span class="line">  release</span><br><span class="line">  remotes/origin/dev</span><br><span class="line">  remotes/origin/feature_test</span><br><span class="line">  remotes/origin/master</span><br></pre></td></tr></table></figure><p>开始删除分支，删除之前记得切换到别的分支，否则删除不成功</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">albert@homepc MINGW64 /d/gitstart (feature_test)</span><br><span class="line">$ git checkout dev</span><br><span class="line">Switched to branch <span class="string">'dev'</span></span><br><span class="line">Your branch is up to date with <span class="string">'origin/dev'</span>.</span><br><span class="line"></span><br><span class="line">albert@homepc MINGW64 /d/gitstart (dev)</span><br><span class="line">$ git branch -d feature_test</span><br><span class="line">Deleted branch feature_test (was 3226b63).</span><br><span class="line"></span><br><span class="line">albert@homepc MINGW64 /d/gitstart (dev)</span><br><span class="line">$ git branch -a</span><br><span class="line">* dev</span><br><span class="line">  master</span><br><span class="line">  release</span><br><span class="line">  remotes/origin/dev</span><br><span class="line">  remotes/origin/feature_test</span><br><span class="line">  remotes/origin/master</span><br></pre></td></tr></table></figure><h2 id="删除远程分支"><a href="#删除远程分支" class="headerlink" title="删除远程分支"></a>删除远程分支</h2><p>通过上面的操作我们发现只删除了本地的分支，远程的分支还在，要想删除远程分支，需要使用 <code>git push origin --delete branch_name</code> 命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">albert@homepc MINGW64 /d/gitstart (dev)</span><br><span class="line">$ git push origin --delete feature_test</span><br><span class="line">remote: Powered by GITEE.COM [GNK-3.8]</span><br><span class="line">To gitee.com:myname/gitstart.git</span><br><span class="line"> - [deleted]         feature_test</span><br><span class="line"></span><br><span class="line">albert@homepc MINGW64 /d/gitstart (dev)</span><br><span class="line">$ git branch -a</span><br><span class="line">* dev</span><br><span class="line">  master</span><br><span class="line">  release</span><br><span class="line">  remotes/origin/dev</span><br><span class="line">  remotes/origin/master</span><br></pre></td></tr></table></figure><p>这次再查看时发现远程分支也被删掉了。</p><h2 id="获取远程主分支到本地"><a href="#获取远程主分支到本地" class="headerlink" title="获取远程主分支到本地"></a>获取远程主分支到本地</h2><p>其实 <code>Git</code> 的克隆命令默认就是把远程仓库的主分支下载到本地，我们可以使用 <code>git clone 远程地址 本地文件夹</code> 命令来克隆一个仓库，如果本地文件夹省略，则默认新建一个与仓库名相同的文件夹：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">albert@homepc MINGW64 /d</span><br><span class="line">$ git <span class="built_in">clone</span> https://gitee.com/myname/gitstart.git gitstartcopy</span><br><span class="line">Cloning into <span class="string">'gitstartcopy'</span>...</span><br><span class="line">remote: Enumerating objects: 3, <span class="keyword">done</span>.</span><br><span class="line">remote: Counting objects: 100% (3/3), <span class="keyword">done</span>.</span><br><span class="line">remote: Total 3 (delta 0), reused 0 (delta 0)</span><br><span class="line">Unpacking objects: 100% (3/3), <span class="keyword">done</span>.</span><br><span class="line"></span><br><span class="line">albert@homepc MINGW64 /d</span><br><span class="line">$ <span class="built_in">cd</span> gitstartcopy/</span><br><span class="line"></span><br><span class="line">albert@homepc MINGW64 /d/gitstartcopy (master)</span><br><span class="line">$ git branch -a</span><br><span class="line">* master</span><br><span class="line">  remotes/origin/HEAD -&gt; origin/master</span><br><span class="line">  remotes/origin/dev</span><br><span class="line">  remotes/origin/master</span><br></pre></td></tr></table></figure><h2 id="获取远程其他分支到本地"><a href="#获取远程其他分支到本地" class="headerlink" title="获取远程其他分支到本地"></a>获取远程其他分支到本地</h2><p>从上面命令执行后的结果来看，当前本地仓库中只有 <code>master</code> 分支，其他的分支都是在远程仓库上，这时可以用 <code>git checkout branch_name</code> 命令来下载远程分支：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">albert@homepc MINGW64 /d/gitstartcopy (master)</span><br><span class="line">$ git checkout dev</span><br><span class="line">Switched to a new branch <span class="string">'dev'</span></span><br><span class="line">Branch <span class="string">'dev'</span> <span class="built_in">set</span> up to track remote branch <span class="string">'dev'</span> from <span class="string">'origin'</span>.</span><br><span class="line"></span><br><span class="line">albert@homepc MINGW64 /d/gitstartcopy (dev)</span><br><span class="line">$ git branch -a</span><br><span class="line">* dev</span><br><span class="line">  master</span><br><span class="line">  remotes/origin/HEAD -&gt; origin/master</span><br><span class="line">  remotes/origin/dev</span><br><span class="line">  remotes/origin/master</span><br><span class="line"></span><br><span class="line">albert@homepc MINGW64 /d/gitstartcopy (dev)</span><br><span class="line">$ git branch -vv</span><br><span class="line">* dev    3226b63 [origin/dev] add readme file</span><br><span class="line">  master 3226b63 [origin/master] add readme file</span><br></pre></td></tr></table></figure><p>看到这里可能会疑惑了，<code>git checkout branch_name</code> 不是切换分支的命令吗？实际上当 <code>branch_name</code> 分支在本地不存在而远程仓库存在时，这个命令与 <code>git checkout -b &lt;branch&gt; --track &lt;remote&gt;/&lt;branch&gt;</code> 含义相同，会在本地新建一个分支，并与远程分支建立联系。</p><h1 id="常用集合"><a href="#常用集合" class="headerlink" title="常用集合"></a>常用集合</h1><ul><li>新建分支：<code>git checkout -b branch_name</code></li><li>切换分支：<code>git checkout branch_name</code></li><li>查看分支：<code>git branch -a</code></li><li>删除分支：<code>git branch -d branch_name</code></li><li>推送分支到远程：<code>git push origin branch_name</code></li><li>删除远程的分支：<code>git push origin --delete branch_name</code></li><li>拉取远程分支到本地：<code>git checkout branch_name</code></li><li>查询分支的对应关系：<code>git branch -vv</code></li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>以上这些命令都是在本地测试过的，可能考虑的不太全面，不过没关系，以后的分支操作还会补充到这里。</li><li>这些命令在有些特殊的情况下使用可能会遇到问题，如果大家发现了问题请及时指出，我会尽快修改的。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;最近代码的版本控制工具由&lt;code&gt;SVN&lt;/code&gt;换成了&lt;code&gt;Git&lt;/code&gt;，只用管理个人项目常用的灵魂三步&lt;code&gt;git add&lt;/code&gt;、&lt;code&gt;git commit&lt;/code&gt;、&lt;code&gt;git push&lt;/code&gt;看来是行不通了，之前虽然也一直在用 &lt;code&gt;git&lt;/code&gt;，但是用法很有限，主要集中在前面提到的三步，所以为了更好的工作，我决定还是好好总结一下。&lt;/p&gt;
&lt;p&gt;分支在&lt;code&gt;Git&lt;/code&gt;的操作里有着很重要的地位，代表了不同的开发线路，创建一个分支，也就多了一个索引文件，相比于&lt;code&gt;SVN&lt;/code&gt;分支拷贝全部文件来说来方便的多，所以&lt;code&gt;Git&lt;/code&gt;使得按功能分支的开发模式变得非常简单，在开发过程中常常需要对分支进行操作。&lt;/p&gt;
    
    </summary>
    
      <category term="Git" scheme="http://AlbertGithubHome.github.io/blog/categories/Git/"/>
    
    
      <category term="git" scheme="http://AlbertGithubHome.github.io/blog/tags/git/"/>
    
      <category term="branch" scheme="http://AlbertGithubHome.github.io/blog/tags/branch/"/>
    
      <category term="checkout" scheme="http://AlbertGithubHome.github.io/blog/tags/checkout/"/>
    
      <category term="push" scheme="http://AlbertGithubHome.github.io/blog/tags/push/"/>
    
      <category term="remote" scheme="http://AlbertGithubHome.github.io/blog/tags/remote/"/>
    
  </entry>
  
  <entry>
    <title>挥一挥衣袖，开始一段新的旅程</title>
    <link href="http://AlbertGithubHome.github.io/blog/2020/02/16/%E6%8C%A5%E4%B8%80%E6%8C%A5%E8%A1%A3%E8%A2%96%EF%BC%8C%E5%BC%80%E5%A7%8B%E4%B8%80%E6%AE%B5%E6%96%B0%E7%9A%84%E6%97%85%E7%A8%8B/"/>
    <id>http://AlbertGithubHome.github.io/blog/2020/02/16/挥一挥衣袖，开始一段新的旅程/</id>
    <published>2020-02-16T14:36:38.000Z</published>
    <updated>2020-02-26T14:38:05.093Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>悄悄的我走了，正如我悄悄的来；我挥一挥衣袖，不带走一片云彩。</p></blockquote><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>钱钟书老先生在《围城》中说道:“天下只有两种人。比如一串葡萄到手，一种人挑最好的先吃，另一种人把最好的留到最后吃。照例第一种人应该乐观，因为他每吃一颗都是吃剩的葡萄里最好的；第二种人应该悲观，因为他每吃一颗都是吃剩的葡萄里最坏的。不过事实却适得其反，缘故是第二种人还有希望，第一种人只有回忆”。</p><a id="more"></a><p>而我在反思自己时却发现，无法将自身完全归于这两种人的一类，如果非要选一种，我更像是老先生提到的第二种人，总喜欢把最好的留到最后。按理说这样的人应该总是向前充满希望的，但是我却热衷于收集回忆，记录生活中的点点滴滴，认真记下生活中的每一笔支出，写下人生中一次次感动…</p><p>其实一开始我并没有这方面的爱好，不知从何时起，儿时的记忆渐渐和梦境中的画面杂糅在了一起，有些事情已经分不清是之前确实发生的，还是曾经在梦境中悄悄的来到过，所以慢慢地我养成了这样的习惯，记录生活中一切想要被回忆的事情，期待着有一天能与对此感兴趣的人一起分享这些点点滴滴。</p><h1 id="缘由"><a href="#缘由" class="headerlink" title="缘由"></a>缘由</h1><p>技术博客中很少写自己的生活，这一次其实也和技术有关，在一个工作岗位上勤勤恳恳工作六年之后，今年终于鼓足勇气决定出来找找新的机会，确定了新的目标之后回头看看这六年收获了很多，同时在这段找工作的经历中也学会了不少东西，新的工作基本定下来了，现在总结一下工作以来的经历以及面试中遇到的问题，方便后续复盘时能有个参照。</p><h1 id="懵懵懂懂的6年前"><a href="#懵懵懂懂的6年前" class="headerlink" title="懵懵懂懂的6年前"></a>懵懵懂懂的6年前</h1><h2 id="走出校门"><a href="#走出校门" class="headerlink" title="走出校门"></a>走出校门</h2><p>从大四学期便开始走出校门，一切按照教学大纲进行着，大四这年是企业实训，我们被安排到一家机构进行学习，学习结束已经13年的深冬，我们一群小伙伴作为花朵开始走出曾经的温室。</p><p>其实从实训的后半段我们已经开始在北京各大高校“流窜”，参加了很多不请自来的校招，进行了一轮轮的笔试，但很少有人从中得到满意的工作机会，我也尝试过几次，但是感觉自己真的很渺小，经过努力得到了一个大厂的面试邀请，我怀着激动的心情前去面试，走的时候还换上了自己都觉得怪异的正装，好在面试官并不在意我的这份不自然，完全投入身心开始进行面试。</p><p>很幸运我通过了一面，但是在去参加二面的路上我才发现后背已经被汗水浸湿了，之前也参加过几次面试，但是这一次确实是让我身心俱疲，从中也渐渐体会到了不同公司之间的技术差距，我一心想加入这个团体，但是二面的结果又把我拉回了现实，二面的过程很糟糕，有一道题我至今还记得，那就是关于数据库的连接，但是回答的很模糊，由于自己的知识储备不足，我怀疑自己当时连题目都没有弄懂。</p><h2 id="走进社会"><a href="#走进社会" class="headerlink" title="走进社会"></a>走进社会</h2><p>大厂失利后，开始寻找其他的机会，毕竟工作是现在的第一要务，放弃了保研机会一心想着早点参加工作，如果连工作都找不到岂不是让人笑话了，时间不久便通过了几家面试，其中有意向可以试试的有两家，一家是做偏硬件的软件，另一家就是做游戏开发的，工资待遇差不多，相比较而言第一家要高一些，但是当时沉迷于Dota的我经过“深思熟虑”之后，委婉的谢绝了第一家的邀请，进入了这家游戏公司，也就是后来我工作了6年的公司。</p><h2 id="开始工作"><a href="#开始工作" class="headerlink" title="开始工作"></a>开始工作</h2><p>我的人生很幸运，我一直这样觉得，在这里我碰到了我工作的中的第一位导师，都说师傅领进门，修行在个人，那么他就是我进入社会环境的那个师傅，但是他比我也大不了几岁，我更愿意称呼他为兄长。</p><p>时光荏苒，岁月如梭，即便转眼已经过去了6年多，但是工作第一天他让我修改的第一个BUG我至今还记得，那是一把“罪恶坑的钥匙”，BUG具体的细节并不重要，而是他处理的方式让我记忆犹新。</p><p>开发环境配置好之后，兄长便指给我一个BUG，让我尝试修改，便是那个“罪恶坑的钥匙”，第二天他就过来询问BUG的修改情况，我告诉他我的修改思路A，他说可以这样改，但是这种修改方式可能会给后面带来一些不利于扩展的问题，然后在他的电脑上给我看了他建议的修改思路B，然后让我按照这个思路去修改，我比较之后确实思路B更好一些。问题的关键是这个BUG他已经想好了修改方案，并且尝试修改过，他指定让我修改完全是为了帮我熟悉问题的处理方式而非完成工作。</p><p>之后也和一些其他领导沟通过工作，但是能这样带我入门的兄长就只此一个，其他人大多是就是完成工作即可，很少有人再想教我的什么东西了。我是幸运的，在我懵懂的年纪碰上了这样一位领路人，之后我们在项目组之间分分合合，但始终工作在同一个屋檐下。</p><h1 id="勤勤恳恳的6年"><a href="#勤勤恳恳的6年" class="headerlink" title="勤勤恳恳的6年"></a>勤勤恳恳的6年</h1><h2 id="初入职场"><a href="#初入职场" class="headerlink" title="初入职场"></a>初入职场</h2><p>刚刚参见工作，一切都显得那么新鲜，经常会有这样的感叹：原来游戏中的这个功能是这样实现的！开始的时候对于工作的状态还是有点不适应，印象最深的就是下午的时候总是昏昏沉沉的，当时可以用“熬”这个字来形容，但是随着后面工作内容的铺开，大脑在紧张的处理这些问题时，犯困的毛病就改掉了。</p><p>工作之前写的项目很多是个人完成的，就是几个人合伙做一个项目，基本上也不太大，所有的代码也都很了解，但是刚接触这个游戏项目时感觉它太大了，所有的代码只能不断的搜索才能找到，仿照已有的功能开发了两个新功能之后，渐渐的找到了感觉。</p><p>很长一段时间之后再回过头来看自己的代码时会发出这样的感叹：这段代码是我写的吗？现在整个流程我已经清楚了，但是当时写这段代码的时候是怎么找到这里的。其实一开始写代码完全是照葫芦画瓢，很多语句不知道什么意思，但是功能类似，这样写完就可以用了。</p><p>当时还有一个情况就是开发环境是没有网络的，有问题不能上网去查，好在分配给我的没有太复杂的功能，依照原来的系统都可以完成，并且我喜欢做笔记，常用的那些代码实现都让我记在了本子里，有些还记了不止一遍，这些笔记我至今还留着，现在看起来显得过于幼稚，但却是我工作以来的痕迹。</p><h2 id="渐入佳境"><a href="#渐入佳境" class="headerlink" title="渐入佳境"></a>渐入佳境</h2><p>工作一年以后，对整个游戏已经比较熟悉了，可以独自完成很多功能，稳定下来的游戏也逐渐对接多个平台开始蓬勃发展，那时的我真的是干劲十足，每天像打了鸡血一样，作为服务器开发的我开始偶尔“插手”客户端的开发工作。</p><p>期间还养成了每天读书的习惯，其实这个习惯的养成是被动的，原因是分配给我的电脑比较卡，我提过几次但是一直没有换的机会，每天早上开机至少得10分钟左右才能正常顺畅的工作，所以后来我一般会早来一会，开机这期间我就会把旁边同事的书拿过来看看，后来同事的书看完了，我就买一些相同类型的技术书籍来看，再后来开始扩展知识面，买一些流行技术的书，这个习惯就一直保留了下来，一直到现在每年都会看几本技术书籍，有些是不朽的经典，有些是新进的技术。</p><p>其实很多书的内容我只是有大概的印象，具体的内容早就忘记了，偶有几本书感觉有意思会回过头来再次翻看，每次看都会有不同的感受，我喜欢在纸质书上做笔记，想到什么就写什么，有些章节会被我划的很乱。在我看书的时候总有同事问我，你看那么多书都记得吗？都学会了吗？这时我常常会自嘲一般的回答：“看着玩而已，早都不记得了”。</p><p>实际上记不记得重要吗？今天吃了有营养的东西，明天依旧会饿，你会因为明天还会吃饭就放弃今天的美食吗？我想不会的吧，我感觉看书也是一样，我今天看了明白了一些事情，或者读到一个故事感动了很久，明天忘了就忘了，毕竟我曾经学会过，曾经也感动过。这些东西会消失的无影无踪吗？我想也不会的吧，吃过的美食总会有一部分营养进入了我们的细胞，成为了肉体的一部分，而曾经读过的书会忘得一干二净吗？当然不会，那些使我们印象深刻的文字总会在未来的某个深刻，在我们的脑子中再次迸发出来。</p><h2 id="再入蛮荒"><a href="#再入蛮荒" class="headerlink" title="再入蛮荒"></a>再入蛮荒</h2><p>天下没有不散的筵席，参加工作时就参与开发的这个项目终于到了最后的维护阶段，这个阶段距离我刚进公司时已经过去了2年半的时间，此时原项目不再进行新的开发只进行必要的维护，原项目组的人也被分成了两部分，现在的有两个新项目，一个是相同技术栈不同玩法的端游项目，一个是紧追潮流的手游项目。我当时想去做手游，最终也确实分到了手游组，就是从这时起，我与之前的兄长分到了不同的项目。</p><p>事实证明这个公司向手游进军的项目确实是一条蛮荒的道路，整个技术链遇到了前所未有的挑战，我们一步步探索着前进的道路，试图越过一个个技术的深坑，而真实情况却是多少次我都陷在了里面。</p><p>在这个项目组我遇到了很多新的伙伴，有的乐观、有的开放、有的乐于奉献、有的精益求精，在这我看到了相同而又不同的服务器程序，之前的程序被改的面目全非，我又得重新适应，面对全新的客户端也有太多的新知识需要学习，每天必须打起十二分精神来应对工作。</p><p>一次次的否定自我，一次次的推到重建，在项目的紧要关头，升级引擎、重建UI、优化逻辑，最终还是把这款游戏送上了线，但事实却如昙花一般，一闪而过，失败了，我们没有做出成功的产品，仅仅是做了一次失败的尝试，此时距离进入这个项目组过了1年半的时间。</p><h2 id="并入源头"><a href="#并入源头" class="headerlink" title="并入源头"></a>并入源头</h2><p>手游组的失败尝试使我有了到外面大世界看看的想法，就在这时，和我们一同开始的另一个项目组已经完成了一次轮回，很明显他们成功了，作为同时开始的两个项目，一成一败的比较对于我们的打击很大，而那个成功的项目组也进入维护阶段，领导决定合并两个项目组继续完成手游的开发，这使我又打消了出门找工作的念头。</p><p>两个项目虽然一成一败，但是各有优势，因为最终做的是手游，所以原来的手游组有技术优势，而另一个成功的项目有成功的游戏内容，两者一合并应该很快就能出一个产品，更重要的是，这两拨人有很多都是曾经的好友，好友联手打造一个游戏也是很有意思的事情。</p><p>可是理想很丰满，现实很骨感，事实证明做出一款游戏是多么的不容易，虽然两部分好友合并到一起没有什么磨合的问题，但是游戏内容的一次次修改不断冲击着之前制定的开发计划，整个开发计划不断修改，时间节点在不断修改的需求面前显得那么渺小，常常被无情的践踏。</p><p>终于看到胜利的曙光了，在不断调整了2年之后，游戏迎来了上线的的一天，之后开始根据线上反馈进行调整，在我看来游戏开发到这已经基本完成，虽然达不到爆款的要求，但终究是一款中规中矩的游戏，没有大的问题，也没有太闪光的点，我在这的修行也要告一段落了。</p><p>离开这里的一个导火索是游戏内容一次大的调整，本来现阶段不可能大面积修改功能了，可是在计划中还是出现了太多看不懂的修改内容，因为之前有了完成游戏就离开的想法，看到这里仿佛又要开启一个新游戏了，我也就没有再留下的必要了，是时候到外面的世界去看看了。</p><h1 id="信心满满的6年后"><a href="#信心满满的6年后" class="headerlink" title="信心满满的6年后"></a>信心满满的6年后</h1><h2 id="外出求索"><a href="#外出求索" class="headerlink" title="外出求索"></a>外出求索</h2><p>19年底，在第一家也是唯一一家公司呆了6年之后，我开始外出面试了，从一开始的信心满满到后面的发奋图强，我逐渐认识到了，我必须出来闯闯了，我在一个安逸的地方待了太久，虽然每天都在学习，但事实上优秀的人比你还要努力，以下简单介绍下面试过程，对于需要掌握的知识进行一个梳理，便于日常复习警醒自己，大概面了几家，以下按一面时间先后排列以下T、D、Y、W、Z、H：，全部以字母代替就不列出公司名了，有兴趣的可以进一步交流下。</p><h3 id="T公司"><a href="#T公司" class="headerlink" title="T公司"></a>T公司</h3><!-- 201912191420 --><p>很抱歉一开始把公司名看错了，当时还在想一家旅游公司怎么还做游戏，但是毕竟是第一家在招聘APP上给我发面试邀请的公司，怎么也要去看看，后来了解了一下这是一家主营棋牌类的公司，面试当天早早就来到了这家公司，顺便再楼下吃个了饭，面试开始先填个表格，内容跟查户口一样，我只填了其中的必要信息，接着做笔试题，包括后面几家面试，这是我唯一做的一套笔试题，内容不难，可能就是一个简单了解。</p><p>我还没写完面试官就来了，我看他特别像我初中的化学老师，整个过程很轻松，聊聊笔试题、曾经的项目，面试官还介绍了他们公司的情况，他表示了对我的肯定，问我有没有兴趣转Golang语言，我内心是拒绝的，其实嘴上也拒绝了，因为我一直使用C++，之后又是其他一个组的负责人来面试，他们使用的Python，整个过程依旧轻松加愉悦，还向他请教了分布式服务器的知识，最终因为我不想放弃C++而结束，他问原因是什么？我开玩笑说：可能是情怀吧！</p><p>涉及到笔试面试部分内容，列举在此主要为了重温复盘，如果你想做游戏开发也可以看看这些知识：</p><ul><li>不同类型数据内存占用大小</li><li>估算PC机上1秒钟可能执行的空的for循环次数</li><li>linux下常用搜索文件命令</li><li>常用的设计模式</li><li>字符串翻转</li><li>扑克牌中挑最长顺子</li><li>回旋排列矩阵</li><li>分布式服务器设计</li><li>linux中的lvs</li><li>服务器横向扩展</li><li>从头实现一个服务期</li><li>websocket</li><li>玩家背包怎样设计</li></ul><h3 id="D公司"><a href="#D公司" class="headerlink" title="D公司"></a>D公司</h3><!-- 201912201000 --><p>这个公司完全是抱着学习的心态去的，因为公司本身很大并且不是做游戏的，来这家公司完全是因为他们的技术总监在招聘APP给我发了面试邀请，我本来觉得不合适，人家说可以来试试，抱着学习的态度我就去了，为了这次面试还看了好几个调度算法，最终也没用上。</p><p>本来10点半的面试，7点多我就出发了，期间地铁还坐反了，还好出门早，来到西二旗发现手机都没有信号，出门都骑不了自行车，走了很久才找到一辆，开锁出发一气呵成，9点多就到公司楼下了，旁边便利店买了个菜团子，对于干吃的我来说太大了，10点左右进入公司，大公司就是不一样，进门登记后还要贴一个签，这是怕我乱跑啊。</p><p>面试不久后进行，来了一个小哥哥，年纪应该不大，很沉稳的样子，带了一台笔记本电脑，这个好像是标配，提倡无纸化办公吧，我的一切反馈他都会记录在上面，整个过程对于他来说应该是轻松的，但是对于我来说有些窘迫，整个过程对我的评价就是，很多东西用的很熟，但是对于原理掌握的还不够，算是没有达到他们的要求，这也在我的意料之中，毕竟就是来学习的。涉及到的面试内容大概有如下问题：</p><ul><li>开源项目源码的阅读情况</li><li>动态库加载路径</li><li>编译的过程</li><li>线程崩溃为什么会导致进程挂掉？一定会挂掉吗？</li><li>加权最短路径</li><li>打印过程中出现中断</li><li>中断信号怎么处理</li><li>怎么理解多态</li><li>编译时多态和运行时多态</li><li>模板和基础类型的效率比较</li><li>gdb调试</li><li>为什么先构造基类</li><li>析构函数的调用顺序</li><li>非阻塞的write什么时候返回</li><li>如果连不上服务器会有那些情况</li><li>注意wireshark的使用</li><li>listen的backlog参数</li></ul><h3 id="Y公司"><a href="#Y公司" class="headerlink" title="Y公司"></a>Y公司</h3><!-- 201912211420 --><!-- 202001021930 --><p>这个公司有自己成熟的产品线，涉及到卡牌、MMORPG等等，同样是在招聘APP上收到面试邀请，但这次招人的是一个SLG游戏组，整个给人的感觉无论是公司的氛围还是项目的情况与我当前公司很像，一共来公司面了两次，第一次两个技术Leader分别进行面试，然后又和HR聊了一下，技术面主要围绕曾经的项目，后来第二次面试跟游戏制作人聊了一下，感觉和之前的公司更像了，当时就打了退堂鼓，最终婉言谢绝了这家公司的Offer，面试主要技术内容：</p><ul><li>技能设计</li><li>redis缓存</li><li>指针用法</li><li>二分法思想</li><li>项目熟练度</li></ul><h3 id="W公司"><a href="#W公司" class="headerlink" title="W公司"></a>W公司</h3><!-- 201912271930 --><!-- 202001061930 --><!-- 202001071900 --><p>这个公司是游戏开发中的大厂了，首先是在招聘APP上，HR和我沟通之后要去了简历想要看看，后来收到了面试电话确定了面试时间，面试当天也是早早的来到了公司，这天在周围没有找到吃饭的地方，要饿着肚子了，等待了一会被HR小姐姐带去二楼等了半小时，后来她跑过来告诉我位置错了，确实有点尴尬。</p><p>之后我被带去了正确的位置，然后开始了面试过程，面试官是一个小哥哥，整个面试的过程感觉表现的不是很好，有些问题回答的不太完整，但是却从中学习到了很多东西，临走时问了几个面试问题的正解，并且冒昧的问了小哥哥的工作年限，得知才比我大两岁就已经在游戏大厂当主程之后，深感我们之间的差距还很大，同时也激起了我努力学习的意志。</p><p>面试后好几天也没有消息，本来我感觉这次面试可能失败了，但是几天后我又收到了该公司的二面邀请，收到邀请时挺高兴的，当时还有另外几家面试，之前已经约好了时间，所以这次二面不得不向后推了几天，因为是第二次去，路线熟悉了很多，又是早早来到公司，本来以为还是技术面，但是交流几个问题之后发现问的都是之前的项目，和人员之间的沟通的问题，后来对方主动说明他是项目负责人，整个聊天过程比较轻松，谈过之后让回去等消息。</p><p>第二天收到HR视频面试的邀请，本来想约晚一点回家好好面试，但是因为HR小姐姐还有其他安排，我只得将面试时间提前，在公司旁边找了个安静的地方进行视频面试，主要聊了一下目前的薪资待遇以及项目情况，能够入职的时间等等，整个过程很愉快，并且得知其实是一个工作室在招聘，我问了一些相关的问题，面试结束回到家我仔细考虑了这个机会，第二天又找该项目的负责人了解了项目的详细情况，觉得这是一个很好的学习机会，与目前的工作内容有很强的互补性，可以试一试。</p><ul><li>Gitflow使用方法</li><li>gcc编译过程</li><li>extern和static的作用</li><li>多态、虚函数、多继承虚函数</li><li>大根堆创建和插入</li><li>排序找出接近当前数的较大数</li><li>迭代器的理解、迭代器都是指针吗？</li><li>字符编码、unicode、utf8</li><li>指针数组、数组指针、函数指针</li><li>引用和指针的区别</li><li>网络4次挥手、为什么要4次？</li><li>函数阻塞是否占用资源–挂起不占用</li></ul><h3 id="Z公司"><a href="#Z公司" class="headerlink" title="Z公司"></a>Z公司</h3><!-- 201912291000 --><p>这个公司不是游戏公司，近两年异常火爆，有专门的游戏部门，但是我面试的职位不是游戏岗位，而是时下非常火的中台岗位，其实是在尝试新的领域。起初是猎头在招聘APP上要了我的简历，然后接到了公司HR小姐姐的电话，约定了面试时间，相互加了微信，面试之前和HR小姐姐交流了不少，知道公司技术面大概有3面，因为心里没底，抱着学习的态度考虑能过两面就行，如果实在太难能过一面也行，作为一个求知者，知道各个公司都需要哪些知识也就有了学习的目标。</p><p>可现实总是太残酷，这个面试我算通过了半面，什么叫半面，由于我的“出色”表现，我感觉正常的一轮面试并没有结束就被礼貌的请出来了，因为几个问题之后我也感觉出来了，我之前学的技术和他们开发思想差的有点多，所以出于礼貌，面试官也没说什么，还给出了一些建议，人真的不错，大公司的涵养还是有的。</p><ul><li>你开发的最满意的系统 –道具系统</li><li>map和hashmap的区别</li><li>stl的使用</li><li>vector的扩容，是不是线程安全的？</li><li>遍历删除vector元素，迭代器失效</li><li>有没有用过redis的有序集合</li><li>redis中hash插入的时间复杂度</li><li>设计一个红包系统 –评价为原始的面向对象方式，有些过时</li><li>给出建议这个红包系统必须要考虑redis、分布式、容灾、备份</li><li>建议如果想转向互联网需要准备的很多，可以先看下现有的解决方案</li></ul><h3 id="H公司"><a href="#H公司" class="headerlink" title="H公司"></a>H公司</h3><!-- 202001091915 --><p>这个公司的面试机会是猎头推荐的，主要做战争题材的游戏比较多，现在也有卡牌和休闲，本来约的面试时间比较早，但是由于个人原因回了次老家，结果这个面试不得不向后推了，面试当天来到公司，前台居然一个人都没有，之后电话联系到面试官，首先表达了之前改约的歉意开始了面试过程。</p><p>面试主要围绕之前的项目进行，对具体的系统实现问的很详细，通过对细节的了解，对我之前的工作内容有很多不理解，感觉有很多内容不符合他的认知，整个过程倒还轻松，没有太多的技术问题，总体感觉不是一路人，很可能走不到一起。</p><p>聊了大概一小时，换HR继续聊，还是问了之前项目、期望薪资以及入职时间等等，确定了是卡牌组再招人，问了一些当前公司情况之后，按照流程回去等消息，但个人觉得可能不太合适。</p><ul><li>面向对象要求比较高，C+Class的方式不被认可</li><li>着重问了一个游戏系统的实现方式（押镖）</li><li>面相对象设计技能系统</li><li>强调游戏充值实现的重要性，以及可能出现的多种情况</li><li>认为只有DBA才有权利修改数据库结构</li></ul><h2 id="准备离开"><a href="#准备离开" class="headerlink" title="准备离开"></a>准备离开</h2><p>出去面试一圈基本确定了新的工作，是时候离开了，先跟带自己入门的兄长道个别，我们两个聊了很久，对于我离开去学习新知识，兄长表示支持，他不仅是我工作上的领路人，同时脾气特别好，平时处理问题也很妥当，一直是我学习的榜样。</p><p>紧接着便向老大提出了离职，准备年前离职后去新公司入职，而老大的意思是再等等，年前太仓促了，先看看现在公司的情况，年后回来如果还想走再办离职吧，考虑到还有一段时间的就要放假了，为了更好的完成了交接工作，我答应了老大的请求。</p><h2 id="即将离开"><a href="#即将离开" class="headerlink" title="即将离开"></a>即将离开</h2><p>过年期间考虑了好久，还是准备出去闯一闯，今年春节的新型冠状病毒疫情非常严重，很多公司都推迟了上班时间，虽然2号之后就回来上班了，但是很多同事由于封路的原因都还没回来，离职手续也一直没有办成，年后又找老大聊了一次，毕竟工作了6年，虽然不舍，但是确实该离开了，期待下周的情况能好一些，能顺利办完手续开始新的旅程。</p><h1 id="挥挥手再出发"><a href="#挥挥手再出发" class="headerlink" title="挥挥手再出发"></a>挥挥手再出发</h1><blockquote><p>更新于2020年2月15日22:45:51</p></blockquote><h2 id="挥手告别"><a href="#挥手告别" class="headerlink" title="挥手告别"></a>挥手告别</h2><p>事情办得比较顺利，经过前期的准备，周一便完成了工作交接，上传了交接文档，周二开始办理离职手续，由于新型冠状病毒疫情的原因，公司依旧没有什么人，好在办理离职的人员都在，签字、签字、再签字，成功在下午拿到离职证明，不过唯一遗憾的是，工牌和门禁卡同时上交了，不能给我留个纪念了，毕竟是在身上装了6年的工牌，6年了几乎没有离开过……</p><p>因为很多同事也没来，加之疫情的严重性，散伙饭并没有吃成，前一天下班的时候专门去旁边的簋街转了一圈，发现除了几家仅有的外卖之外，都是黑着灯的，这可是簋街啊，是让人们可以排队等到凌晨2点的簋街，现在居然这样冷冷清清的，找不到吃饭的地方，散伙饭只能作罢。</p><p>下班前跟仅有的几个来上班的好友道了别，当然其中还有我那位可敬的兄长，当所有人都在关心你飞的高不高时，只有朋友关心你累不累，兄长就是这样的朋友，临走了还关心地问我社保能不能接上，只因为我之前和他提过一次担心社保断缴的问题。因为很多人还没来上班，剩下的关系好的小伙伴，在我晚上回家后，通过微信开始了与他们的远程云分别。</p><h2 id="还看今朝"><a href="#还看今朝" class="headerlink" title="还看今朝"></a>还看今朝</h2><p>告别了过去的工作，自然要步入新的旅程，为尽量避免人员接触，新的公司在周五为我在线办理了入职手续，两位帮忙办理入职的新同事真的非常友好，整个流程遇到不懂的都会及时解答，这让我非常期待下周一正式工作后的生活，新的旅程即将开始，又要在一个地方生根发芽了~</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;悄悄的我走了，正如我悄悄的来；我挥一挥衣袖，不带走一片云彩。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;钱钟书老先生在《围城》中说道:“天下只有两种人。比如一串葡萄到手，一种人挑最好的先吃，另一种人把最好的留到最后吃。照例第一种人应该乐观，因为他每吃一颗都是吃剩的葡萄里最好的；第二种人应该悲观，因为他每吃一颗都是吃剩的葡萄里最坏的。不过事实却适得其反，缘故是第二种人还有希望，第一种人只有回忆”。&lt;/p&gt;
    
    </summary>
    
      <category term="Thinking" scheme="http://AlbertGithubHome.github.io/blog/categories/Thinking/"/>
    
    
      <category term="总结" scheme="http://AlbertGithubHome.github.io/blog/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="工作" scheme="http://AlbertGithubHome.github.io/blog/tags/%E5%B7%A5%E4%BD%9C/"/>
    
      <category term="学习" scheme="http://AlbertGithubHome.github.io/blog/tags/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="生活" scheme="http://AlbertGithubHome.github.io/blog/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>利用__declspec(dllexport)和__declspec(dllimport)在Windows平台编写和使用DLL的小例子</title>
    <link href="http://AlbertGithubHome.github.io/blog/2020/02/05/%E5%88%A9%E7%94%A8-declspec-dllexport-%E5%92%8C-declspec-dllimport-%E5%9C%A8Windows%E5%B9%B3%E5%8F%B0%E7%BC%96%E5%86%99%E5%92%8C%E4%BD%BF%E7%94%A8DLL%E7%9A%84%E5%B0%8F%E4%BE%8B%E5%AD%90/"/>
    <id>http://AlbertGithubHome.github.io/blog/2020/02/05/利用-declspec-dllexport-和-declspec-dllimport-在Windows平台编写和使用DLL的小例子/</id>
    <published>2020-02-05T07:53:19.000Z</published>
    <updated>2020-02-09T09:46:09.532Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>关于 <code>__declspec(dllexport)</code> 和 <code>__declspec(dllimport)</code> 这两个关键字在上大学期间就没见过几次面，直到毕业后在公司项目的代码中又遇到过几次，每次也是绕着走，生怕和它产生什么联系，只知道它和动态链接库 <code>DLL</code> 有关，但是当前这个项目中几乎没有用到自己写的动态链接库，所以我也就心安理得的躲了它这么久。</p><a id="more"></a><p>最近看一些开源项目的源码时又发现了这两个关键字，此时凭借自己掌握的知识和学习方法再来看这两个关键字，发现也没有什么值得害怕的地方，其实简单来说就是 <code>__declspec(dllexport)</code> 是用来说明指定类和函数需要从 <code>DLL</code> 中导出的，而 <code>__declspec(dllimport)</code> 是用来说明指定的类和函数是从DLL中导入的。</p><h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><ul><li><code>__declspec(dllexport)</code> 和 <code>__declspec(dllimport)</code> 只在 Windows 平台才有，用来说明类或函数的导出和导入。</li><li>在 Linux 平台上源文件中的所有函数都有一个的visibility属性，默认导出。如果要隐藏所有函数导出，则需要在GCC编译指令中加入 <code>-fvisibility=hidden</code> 参数。</li><li>生成 <code>dll</code> 的同时还会生成对应的 <code>lib</code> 文件，一般是一些索引信息，记录了 <code>dll</code> 中函数的入口和位置，这在之前还真的不知道，原来一直以为 <code>lib</code> 只是静态库文件呢。</li></ul><h1 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h1><ol><li>为什么要导入导出，直接把代码拿过来一起编译不好吗？</li></ol><p>想要一起编译前提是你得有源代码，如果人家就给你一个动态库或者静态库，你想把源代码放到一起编译的愿望根本实现不了。</p><ol><li>为什么要分为静态库和动态库？搞这么麻烦，还要导入导出。</li></ol><p>这具体的就要查查他们两者的优缺点了，每种事务的产生必要有其产生的原因，比如静态库，很可能就是一个程序员今天在A工程写了一个读取文件的类，过一段时间又在B工程写了一个读取文件的类，代码都差不多，不久又在C工程中直接把代码复制过来改一改又写了一份，这时想到干脆了写个“静态库”这种东西吧，相同的代码直接封装到库中，哪个工程需要就直接拿过来编译，也不需要再复制代码了。</p><p>又比如动态库，前面的静态库解决了代码重复开发和维护的问题，但是读取文件的静态库中的代码在A、B、C三个工程中都存在一份，导致每个可执行程序都很大，可不可以共用一份呢？结果又发明了动态库，在编译时只指定函数的入口地址，运行时才加载动态库，这样就使得可执行程序体积大大缩小。</p><p>以上内容纯粹我个人想像的，真正发明静态库和动态库是由于什么原因，大家可以自行去了解…</p><ol><li>动态库要比静态库好吗？</li></ol><p>个人感觉合适的才是最好的，不存在动态库要比静态库好的说法，最起码不是全都好，动态库的代码是在可执行程序运行时才载入内存的，在编译过程中仅简单的引用，因此代码体积较小，但是运行时要去加载库会花费一定的时间，执行速度相对会慢一些，总的来说静态库是牺牲了空间换时间，而动态库是牺牲了时间换空间。</p><ol><li>.h（头文件） .lib（库文件） .dll（动态链接库文件） 之间的联系和区别</li></ol><p><code>.h</code> 文件是编译时需要的， <code>.lib</code> 是链接时需要的， <code>.dll</code> 是运行时需要的。如果有 <code>.dll</code> 文件，那么 <code>.lib</code> 一般是一些索引信息，记录了 <code>.dll</code> 中函数的入口和位置，<code>.dll</code> 中是函数的具体的执行内容。如果只有 <code>.lib</code> 文件，那么这个 <code>.lib</code> 文件是静态编译出来的，索引和实现都在文件中。</p><h1 id="DLL的编写与使用"><a href="#DLL的编写与使用" class="headerlink" title="DLL的编写与使用"></a>DLL的编写与使用</h1><p>前面说了这么多，其实就是想带大家先了解一下动态链接库 <code>DLL</code> ，接下来开始编写一个DLL并在另一个工程中使用它，前提是你已经会使用开发工具VS，如果不会先查查教程。</p><h2 id="测试环境"><a href="#测试环境" class="headerlink" title="测试环境"></a>测试环境</h2><ul><li>VS2013随意版（个人感觉这个版本启动能快一点）</li><li>Win10畅想版（我也不知道啥版本）</li></ul><h2 id="编写DLL"><a href="#编写DLL" class="headerlink" title="编写DLL"></a>编写DLL</h2><p>编写 <code>DLL</code> 的方法不知一种，这里只简单介绍一种，对于直接写 <code>.def</code> 文件的方法这里不会展开，尽量依靠开发工具一步步向下执行就好，其实当你理解了开发工具的是怎样工作的，一切就没有那么神秘了，有些步骤直接修改配置文件也是可以实现的，只不过开发工具给我们提供了界面，操作起来更加方便了而已，下面我们开始编写：</p><ol><li>打开VS新建项目，选择Win32项目，项目名称GenDLL，解决方案名称DLLExample，点击确定：</li></ol><p><img src="https://cdn.jsdelivr.net/gh/albertgithubhome/cdn//img/dll_1.png" alt="dll_1"></p><ol><li>直接下一步，应用程序类型选择<code>DLL</code>，点击完成：</li></ol><p><img src="https://cdn.jsdelivr.net/gh/albertgithubhome/cdn//img/dll_2.png" alt="dll_2"></p><ol><li>项目会自动创建一个GenDLL.cpp文件，我们在手动创建一个GenDLL.h文件，两个文件中编写如下代码：</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GenDLL.h</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> GENDLL_EXPORTS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TEST_API __declspec(dllexport)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TEST_API __declspec(dllimport)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">TEST_API <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GenDLL.cpp : 定义 DLL 应用程序的导出函数。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdafx.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"GenDLL.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">TEST_API <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码中有一个 <code>TEST_API</code> 是我在头文件中自定义的，当存在<code>GENDLL_EXPORTS</code>宏时， <code>TEST_API</code> 代表 <code>__declspec(dllexport)</code> 也就是导出函数，当不存在<code>GENDLL_EXPORTS</code>宏时， <code>TEST_API</code> 代表 <code>__declspec(dllimport)</code> 表示导入函数，而 GENDLL_EXPORTS 这个宏是与项目名相关的，自动生成的宏，在 <code>DLL</code> 项目中存在格式为 “大写项目名_EXPORTS”。</p><p>也就是说同一个头文件中计算加法的函数 <code>add</code> 在 <code>GenDLL</code> 这个生成 <code>DLL</code> 的项目中表示导出函数，在其他使用这个 <code>DLL</code> 的项目中表示导入函数。</p><ol><li>编译看输出发现有GenDLL.lib和GenDLL.dll两个文件：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1&gt;------ 已启动生成:  项目: GenDLL, 配置: Debug Win32 ------</span><br><span class="line">1&gt;  stdafx.cpp</span><br><span class="line">1&gt;  dllmain.cpp</span><br><span class="line">1&gt;  GenDLL.cpp</span><br><span class="line">1&gt;     正在创建库 c:\users\administrator\documents\visual studio 2013\Projects\DLLExample\Debug\GenDLL.lib</span><br><span class="line">    和对象 c:\users\administrator\documents\visual studio 2013\Projects\DLLExample\Debug\GenDLL.exp</span><br><span class="line">1&gt;  GenDLL.vcxproj -&gt; c:\users\administrator\documents\visual studio 2013\Projects\DLLExample\Debug\GenDLL.dll</span><br><span class="line">========== 生成:  成功 1 个，失败 0 个，最新 0 个，跳过 0 个 ==========</span><br></pre></td></tr></table></figure><h2 id="使用DLL"><a href="#使用DLL" class="headerlink" title="使用DLL"></a>使用DLL</h2><ol><li>在DLLExample这个解决方案下添加一个新项目，命名为UseDLL，然后点击确定：</li></ol><p><img src="https://cdn.jsdelivr.net/gh/albertgithubhome/cdn/img/dll_3.png" alt="dll_3"></p><ol><li>直接下一步，应用程序类型选择“控制台应用程序”，点击完成：</li></ol><p><img src="https://cdn.jsdelivr.net/gh/albertgithubhome/cdn/img/dll4.png" alt="dll_4"></p><ol><li>在文件UseDLL.cpp文件中引用之前GenDLL项目的头文件，编写使用 <code>add</code> 函数的代码：</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// UseDLL.cpp : 定义控制台应用程序的入口点。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdafx.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"../GenDLL/GenDLL.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> _tmain(<span class="keyword">int</span> argc, _TCHAR* argv[])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"100+1="</span> &lt;&lt; add(<span class="number">100</span>, <span class="number">1</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>编译代码发现报错，提示有一个无法解析的外部命令：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1&gt;------ 已启动生成:  项目: UseDLL, 配置: Debug Win32 ------</span><br><span class="line">1&gt;  UseDLL.cpp</span><br><span class="line">1&gt;  stdafx.cpp</span><br><span class="line">1&gt;  正在生成代码...</span><br><span class="line">1&gt;UseDLL.obj : error LNK2019: 无法解析的外部符号 &quot;__declspec(dllimport)</span><br><span class="line">    int __cdecl add(int,int)&quot; (__imp_?add@@YAHHH@Z)，该符号在函数 _wmain 中被引用</span><br><span class="line">1&gt;c:\users\administrator\documents\visual studio 2013\Projects\DLLExample\Debug\UseDLL.exe :</span><br><span class="line">    fatal error LNK1120: 1 个无法解析的外部命令</span><br><span class="line">========== 生成:  成功 0 个，失败 1 个，最新 0 个，跳过 0 个 ==========</span><br></pre></td></tr></table></figure><p>提示这个错误本意就是说链接没有找到函数实现，链接需要什么文件，前面提到需要lib文件，那么我们设置一下，让UseDLL工程能够找到GenDLL.lib文件。</p><ol><li>打开UseDLL工程的属性，在“配置属性-&gt;链接器-&gt;输入-&gt;附加依赖项”中添加GenDLL.lib:</li></ol><p><img src="https://cdn.jsdelivr.net/gh/albertgithubhome/cdn/img/dll5.png" alt="dll_5"></p><ol><li>然后在“配置属性-&gt;链接器-&gt;常规-&gt;附加库目录”中添加GenDLL.lib所在路径“../Debug”即可成功编译：</li></ol><p><img src="https://cdn.jsdelivr.net/gh/albertgithubhome/cdn/img/dll6.png" alt="dll_6"></p><ol><li>直接运行就可以看到调用DLL的结果，因为这两个工程在同一解决方案下，所以最终UseDLL.exe和GenDLL.dll在同一目录下，这样不会报找不到DLL的错误</li></ol><p><img src="https://cdn.jsdelivr.net/gh/albertgithubhome/cdn/img/dll7.png" alt="dll_7"></p><ol><li>如果是不同的目录就会像下图那样，提示找不到GenDLL.dll，只要把GenDLL.dll复制到和UseDLL.exe相同目录即可：</li></ol><p><img src="https://cdn.jsdelivr.net/gh/albertgithubhome/cdn/img/dll8.png" alt="dll_8"></p><h2 id="加载DLL"><a href="#加载DLL" class="headerlink" title="加载DLL"></a>加载DLL</h2><p>上面提到当运行程序找不到 <code>DLL</code>时可以把 <code>DLL</code> 放到可执行程序程序的目录，有时运行大型软件找不到 <code>DLL</code> 时，我们也会下载一个放到System32目录，其实程序在加载 <code>DLL</code> 的时候是会按照一定顺序的，这些目录包括：包含exe文件的目录、进程的当前工作目录、Windows系统目录、Windows目录、Path环境变量中的一系列目录等等，这些目录的搜索顺序还会受到安全 <code>DLL</code> 搜索模式是否启用的影响。</p><p>所以说如果不是对<code>DLL</code> 放置的位置有特殊要求，那么直接放在exe文件所在的目录就好了，一般也是会优先搜索的。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>Windows上才有 <code>__declspec(dllexport)</code> 和 <code>__declspec(dllimport)</code></li><li><code>.h</code> 文件是编译时需要的， <code>.lib</code> 是链接时需要的， <code>.dll</code> 是运行时需要的</li><li>程序运行时加载 <code>DLL</code> 一般优先从exe文件的所在目录优先加载</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;关于 &lt;code&gt;__declspec(dllexport)&lt;/code&gt; 和 &lt;code&gt;__declspec(dllimport)&lt;/code&gt; 这两个关键字在上大学期间就没见过几次面，直到毕业后在公司项目的代码中又遇到过几次，每次也是绕着走，生怕和它产生什么联系，只知道它和动态链接库 &lt;code&gt;DLL&lt;/code&gt; 有关，但是当前这个项目中几乎没有用到自己写的动态链接库，所以我也就心安理得的躲了它这么久。&lt;/p&gt;
    
    </summary>
    
      <category term="C/C++" scheme="http://AlbertGithubHome.github.io/blog/categories/C-C/"/>
    
    
      <category term="C/C++" scheme="http://AlbertGithubHome.github.io/blog/tags/C-C/"/>
    
      <category term="dllexport" scheme="http://AlbertGithubHome.github.io/blog/tags/dllexport/"/>
    
      <category term="dllimport" scheme="http://AlbertGithubHome.github.io/blog/tags/dllimport/"/>
    
      <category term="DLL" scheme="http://AlbertGithubHome.github.io/blog/tags/DLL/"/>
    
      <category term="Windows" scheme="http://AlbertGithubHome.github.io/blog/tags/Windows/"/>
    
  </entry>
  
  <entry>
    <title>2020年的春节，我们一起抗击新型冠状病毒</title>
    <link href="http://AlbertGithubHome.github.io/blog/2020/01/29/2020%E5%B9%B4%E7%9A%84%E6%98%A5%E8%8A%82%EF%BC%8C%E6%88%91%E4%BB%AC%E4%B8%80%E8%B5%B7%E6%8A%97%E5%87%BB%E6%96%B0%E5%9E%8B%E5%86%A0%E7%8A%B6%E7%97%85%E6%AF%92/"/>
    <id>http://AlbertGithubHome.github.io/blog/2020/01/29/2020年的春节，我们一起抗击新型冠状病毒/</id>
    <published>2020-01-29T07:52:16.000Z</published>
    <updated>2020-02-09T09:46:09.532Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>终于到了什么都不用做，在家躺着就能为国家做贡献的时候了！</p></blockquote><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>新型冠状病毒，一个看起来陌生的词语，使得原本最热闹的春季变得异常冷清，随着疫情范围的扩大，这个本来陌生的词语一次次冲击着人们的认知。这个病毒到底是什么，为什么扩散起来这么凶猛？</p><a id="more"></a><h1 id="2019-nCoV"><a href="#2019-nCoV" class="headerlink" title="2019-nCoV"></a>2019-nCoV</h1><p>新型冠状病毒，在各种媒体上还会以“2019-nCoV”的名字出现，人感染了冠状病毒后常见体征有呼吸道症状、发热、咳嗽、气促和呼吸困难等。在较严重病例中，感染可导致肺炎、严重急性呼吸综合征、肾衰竭，甚至死亡。</p><p>引用百度百科中文字，对其描述为：</p><blockquote><p>2019新型冠状病毒，即“2019-nCoV”，因2019年武汉病毒性肺炎病例而被发现，2020年1月12日被世界卫生组织命名。冠状病毒是一个大型病毒家族，已知可引起感冒以及中东呼吸综合征（MERS）和严重急性呼吸综合征（SARS）等较严重疾病。新型冠状病毒是以前从未在人体中发现的冠状病毒新毒株。</p></blockquote><p>目前掌握的情况：</p><ul><li>传染源: 野生动物，可能为中华菊头蝠</li><li>传播途径: 经呼吸道飞沫传播，亦可通过接触传播</li><li>易感人群: 人群普遍易感。老年人及有基础疾病者感染后病情较重，儿童及婴幼儿也有发病</li><li>潜伏期: 1 ~ 14 天，平均 10 天，潜伏期内存在传染性</li></ul><h1 id="2019-nCoV与SARS"><a href="#2019-nCoV与SARS" class="headerlink" title="2019-nCoV与SARS"></a>2019-nCoV与SARS</h1><p>这个新型冠状病毒导致的肺炎传播速度如此之快，很多人拿它和03年的非典（SARS）相比，确实这两个病毒有很多相似的地方，同样都是新型冠状病毒，同样都会引起肺炎，甚至连发生的时间都非常相似，非典是02年11月出现病例，而2019-nCoV出现的时间大概是12月。</p><p>那它们两个这么像，能不能用相同的方法和药物治疗呢？目前来看是办不到的，两者虽然很相似，但是毕竟都是新型病毒，我们知道一种病毒变异后原来的药物很可能就起不到作用了，更何况这是两种不同的病毒，但是也有好的一面，毕竟在抗击非典时我们积累了宝贵的经验，对于防控类似的疾病能够提供很大的帮助。</p><p>比如当年非典时期,北京市在小汤山就建立起了一座封闭式的医院,就是小汤山医院，而武汉参照北京“小汤山模式” 神速建造了“火神山医院”，从开工到投入使用预计会花费10天左右，这个速度也是令人惊叹了，没有之前的经验积累是很难办到的。</p><h1 id="为什么传播的这么快"><a href="#为什么传播的这么快" class="headerlink" title="为什么传播的这么快"></a>为什么传播的这么快</h1><p>其实一开始我们都没有重视这场战斗，导致这个新型冠状病毒钻了空子，传播速度之快达到了让人心惊的地步，感觉主要有下面几方面的原因吧：</p><ul><li>华南海鲜市场存在大量新型冠状病毒，源头上就很广</li><li>起初没有得到足够重视，认为不存在人传人的可能，导致接触者甚至医务人员被感染</li><li>病毒在潜伏期也有可能传播，这是与非典不同的，导致一些携带病毒的人在无意识的情况下成了传染源</li><li>正好赶上春节返乡高峰，而武汉作为九省通衢的枢纽，反倒为病毒散播提供了便捷的条件，扩散范围很快就达到了全国</li></ul><h1 id="目前的形式"><a href="#目前的形式" class="headerlink" title="目前的形式"></a>目前的形式</h1><p>新型冠状病毒疫情已经开始进入初期扩散阶段，并呈上升趋势，但是应对措施也已经铺开，延长假期，控制人员流动，积极研制疫苗，组织医疗救援队赶赴武汉等等，相信不久疫情就能够控制住。</p><p>本来春节是一年中最忙碌的日子，今年却异常的冷清了，为了大家的健康，今年周围的人都取消了拜年聚会活动，村口也安排了人专门劝返探亲人员，因为这样我们反而多了一些陪伴家人的时间，而我居然有时间来码字了，往年不是在这喝酒就是在那聚会的，现在这样安安静静的待在家里感觉也不错。</p><p>引用网上一段顺口溜，写的不错与大家分享：</p><blockquote><p>国家有难，咱不添乱。<br>坐在家里，就是贡献。<br>亲戚不走，来年还有。<br>朋友不聚，回头再叙。<br>利人利己，互不传染。<br>吃好睡好，悠闲过年。<br>坚持几天，你我平安。</p></blockquote><h1 id="新型冠状病毒最新消息"><a href="#新型冠状病毒最新消息" class="headerlink" title="新型冠状病毒最新消息"></a>新型冠状病毒最新消息</h1><p>目前新型冠状病毒处于蔓延的趋势，各种消息满天飞，真真假假难以辨认，所以我单独建了一个项目用来收集最新的消息，尽可能保证消息的准确，其中包含最新的疫情地图、最新疫情新闻、以及正规的捐助渠道等等，有兴趣的小伙伴可以一起舔砖加瓦。</p><p>抗击2019-nCoV最新情报-<a href="https://github.com/AlbertGithubHome/ChineseVictory" target="_blank" rel="noopener">ChineseVictory</a></p><hr><blockquote><p>更新于2020年1月29日21:25:30</p></blockquote><p>今天看到一个同类型的记录武汉抗击新型冠状病毒的项目，已经有3000多的star了，我们两个项目创建的时间很接近，再看看我的项目情况有点惨淡啊！贴个图，大家感兴趣可以来逛逛，不过人家那个项目确实很规范，我还有很多东西可以学习。</p><p><img src="https://img-blog.csdnimg.cn/20200129213049802.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9hbGJlcnRnaXRodWJob21lLmdpdGh1Yi5pby9ibG9nL2Fib3V0,size_12,color_FFFFFF,t_70#pic_center" alt="项目简况"><br><img src="https://img-blog.csdnimg.cn/20200129213150117.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9hbGJlcnRnaXRodWJob21lLmdpdGh1Yi5pby9ibG9nL2Fib3V0,size_12,color_FFFFFF,t_70#pic_center" alt="主要内容"><br>从star数为0来看确实惨淡，再放一遍项目地址-<a href="https://github.com/AlbertGithubHome/ChineseVictory" target="_blank" rel="noopener">ChineseVictory</a>，感兴趣可以来看看;)</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;终于到了什么都不用做，在家躺着就能为国家做贡献的时候了！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;新型冠状病毒，一个看起来陌生的词语，使得原本最热闹的春季变得异常冷清，随着疫情范围的扩大，这个本来陌生的词语一次次冲击着人们的认知。这个病毒到底是什么，为什么扩散起来这么凶猛？&lt;/p&gt;
    
    </summary>
    
      <category term="Thinking" scheme="http://AlbertGithubHome.github.io/blog/categories/Thinking/"/>
    
    
      <category term="生活" scheme="http://AlbertGithubHome.github.io/blog/tags/%E7%94%9F%E6%B4%BB/"/>
    
      <category term="病毒" scheme="http://AlbertGithubHome.github.io/blog/tags/%E7%97%85%E6%AF%92/"/>
    
      <category term="武汉" scheme="http://AlbertGithubHome.github.io/blog/tags/%E6%AD%A6%E6%B1%89/"/>
    
      <category term="春节" scheme="http://AlbertGithubHome.github.io/blog/tags/%E6%98%A5%E8%8A%82/"/>
    
  </entry>
  
  <entry>
    <title>2019！一份迟到的年终总结</title>
    <link href="http://AlbertGithubHome.github.io/blog/2020/01/03/2019%EF%BC%81%E4%B8%80%E4%BB%BD%E8%BF%9F%E5%88%B0%E7%9A%84%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
    <id>http://AlbertGithubHome.github.io/blog/2020/01/03/2019！一份迟到的年终总结/</id>
    <published>2020-01-03T05:49:35.000Z</published>
    <updated>2020-02-09T09:46:09.532Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>长大了就要为小时候吹过的牛而奋斗~</p></blockquote><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>2019即将过去，瞅一眼桌面右下角的时间，距离2020年还有63分51秒，这是我第一次这么强烈地想在一年结束之际写下点什么。本身是一个喜欢收集和总结知识的性格，但对自己的人生却少有总结，一方面感觉没什么可写，一方面也确实对自己太过宽容。</p><a id="more"></a><p>每年年初总是在朋友圈和各大平台浏览着一个个新年展望，而每年年末总是在相同的位置看着他们把年初展望的日期向后推一年，这是个段子，同样也是事实，很多人的生活过得平平淡淡，我们都是人群中的大多数，平庸而碌碌无为。</p><h1 id="迟到"><a href="#迟到" class="headerlink" title="迟到"></a>迟到</h1><p>之所以在年终总结前冠以“迟到”二字，是因为我突然意识到这份总结早就应该做了，对于参加工作已经6年的我来说，刚刚意识到需要做年终总结确实有些不应该。作为普通人的我来说记忆能力有限，小时候吹过的牛早就忘了，如果能及时的做年终总结，或许我还可以为了去年吹过的牛奋斗一把，可是我没有，我连去年的想法也忘得差不多了，此时此刻才刚刚意识到曾经的失误。</p><h1 id="得与失"><a href="#得与失" class="headerlink" title="得与失"></a>得与失</h1><p>既然是总结就要回想一下在过去的一年中我得到了什么，失去了什么，而在新的一年中我想获得什么，回想即将过去的2019年发现，今年确实发生了很多往年没有发生过的事情，这可能也是我突然非常想写点东西，记录下来的原因。</p><h1 id="回顾2019"><a href="#回顾2019" class="headerlink" title="回顾2019"></a>回顾2019</h1><p>这一年发生的事情太多，相互之间纠葛不断，不过还是从最简单的分类：工作、学习、生活这三个方面来聊聊吧，虽然很多事情不能完全归为某一类，但是贴一个标签总能清楚一点。</p><h2 id="工作上"><a href="#工作上" class="headerlink" title="工作上"></a>工作上</h2><p>依旧是踏踏实实，勤勤恳恳的一年，做了整整一年的游戏开发几乎颗粒无收，这已经不是第一年没有收成了，有时候真的有点后悔为了工作侵占了陪家人的时间，特别是看不到回报的时候。</p><p>从年初就开始做收尾工作，几次上线几次调整，不知不觉我们又过了一个年，在我心中这款游戏的开发工作已经接近尾声，这样的状态不应该再持续下去了。</p><h2 id="学习上"><a href="#学习上" class="headerlink" title="学习上"></a>学习上</h2><p>作为一个好学的程序猿，深知“学如逆水行舟，不进则退”的道理，今年在CSDN上写了42篇原创博客，算是高产的一年了，也终于迈进了总排名前一万名的大关，截个图记录一下：</p><p><img src="https://cdn.jsdelivr.net/gh/albertgithubhome/cdn/img/20191231csdn.png" alt="20191231csdn"></p><p>有点小遗憾，访问量差几百才到50万，不过新年第一天应该差不多啦，不仅仅是知识的总结，由于加了CSDN的博客群，今年还认识了许多有意思的小伙伴，比如：铁柱同学（一个冒充小白的大佬）、第三女神（粉丝炸裂式增长）、TRHX（网站做的特漂亮），还有很多小伙伴就不一一列举啦。</p><p>关于读书，我只喜欢读纸质的书籍，喜欢那种在书上乱画，随便记笔记的方式，当然有一点不好，就是想查一个知识点，知道是哪一本书，不得不翻一翻才能找到，好希望纸质书能有个搜索按钮，不过这个问题找个电子版就能解决了。</p><p>今年一共读了7本关于编程技术的书籍：</p><ul><li>Redis入门指南(第2版)</li><li>图解HTTP</li><li>自动化平台测试开发 ——Python测试开发实践</li><li>图解密码技术</li><li>图解TCP/IP</li><li>漫画算法 ——小灰的算法之旅</li><li>MySQL必知必会</li></ul><p>推荐这本《小灰的算法之旅》，可以把学知识当做一种乐趣，绝对能达到事半功倍的效果。</p><p>附上 <a href="https://github.com/AlbertGithubHome/Bella/blob/master/books/booklist.md" target="_blank" rel="noopener">我的完整书单</a></p><h2 id="生活上"><a href="#生活上" class="headerlink" title="生活上"></a>生活上</h2><p>今年在生活上发生的事情好像比之前几年加起来都要多，年中得到了一个特别可爱的宝宝，为了解决宝宝上学问题，之前从没考虑买房的我到了售楼处就买了一套，几乎都没挑就定下了，当然这么冲动的行为必须要付出代价，因此背上了近百万的债务，从此变成了一个给银行打工按月还款的房奴。</p><p>说实话宝宝刚出生时并不好看，可是越长越可爱，现在已经7个月大了，开始会爬了，真想不去上班一直陪她玩，有时候确实有一种为了她放弃全世界的冲动，宝宝今天有点发烧，凌晨一点了还没有睡，陪我一起跨年总结了，好在这会儿烧退了一些，快点好起来吧！</p><p>2019年生活上发生的另外一件很重要的事情就是投资，入市有风险，投资需谨慎，这不是一句玩笑话，今年年初股市行情一片大好，正当我们陶醉其中的时候，贸易大棒直接挥下，给准备一飞冲天的行情当头一棒，还好跑得快，不然年初那波行情的盈利在贸易战初期就会飞烟灭了。</p><p><img src="https://cdn.jsdelivr.net/gh/albertgithubhome/cdn/img/20191231tonghuashun.png" alt="20191231tonghuashun"></p><p>年初的基金行情也异常火爆，在支付宝买了点指数基金，贸易战开始之后就抛掉了，并没有多少盈利：</p><p><img src="https://cdn.jsdelivr.net/gh/albertgithubhome/cdn/img/20191231zhifubao.png" alt="20191231zhifubao"></p><p>说完赚钱的接下来就是赔钱的，P2P暴雷给我炸的遍体鳞伤，从5月份出事到现在毫无音信，真应了那句话，你看上了人家的高息，而人家看上的是你的本金，P2P今年可谓损失惨重。</p><p>因为赚钱心切，今年还投资了一点数字货币，结果因爆仓而结束，每次都是到了爆仓点位迅速反弹，好像在提示我压根就不是我应该玩的，不过从这次投资来看，我才明白为什么有钱的人越来越有钱，而穷人一辈子很难翻身。</p><p>一句话，穷人没有东山再起的资本和承担风险的能力，举个例子：我和一个富有的人同时买一只数字货币，而我们都只花了500块来买相同的点位，不同的是富有的人保证金更多一些，这样当行情来到我的爆仓点位时，我和富有的人损失相同的钱，但是我爆仓了，而他没有，待到行情迅速反弹，他却赚的盆满钵满。</p><p>或者换一种情况，我们两个同时爆仓，他立马在低位投入2倍的钱，迅速赚回损失，而我只能眼睁睁的看着行情反弹却没有投资的砝码，忽然觉得T+1好像真的是帮助我们这些散户的。</p><h1 id="展望2020"><a href="#展望2020" class="headerlink" title="展望2020"></a>展望2020</h1><p>2019已经过去，面对着已经到来的2020年，我们需要踏上新的征程，我还没有适应给自己定出量化的目标，不过可以暂时写下大致的方向，也算是给自己一个时刻的提醒。</p><h2 id="对工作"><a href="#对工作" class="headerlink" title="对工作"></a>对工作</h2><p>新的一年不能再碌碌无为，真的需要去闯一闯了，最近和一些互联网公司的员工沟通过，仿佛我们不是生活在一个地球，外面的世界真的很大，外面的机会真的很多，是时候出去看看了，浏览一下世界的另一面，当然，脚踏实地的工作风格不能丢弃。</p><h2 id="对学习"><a href="#对学习" class="headerlink" title="对学习"></a>对学习</h2><p>经过一段时间的与大牛们的沟通，我渐渐的明白了自己的差距，也大致了解了需要重点学习哪些知识，所以简单列举如下：</p><ul><li>巩固基础知识，对于一些函数不仅要会用，还应该花时间探究实现的方式，往深处挖掘，比如listen函数backlog参数意义。</li><li>阅读 redis 源码，这是很多人都提到的一点，适当可以看一下 STL 源码</li><li>看两本有关分布式知识的图书</li></ul><h2 id="对生活"><a href="#对生活" class="headerlink" title="对生活"></a>对生活</h2><ul><li>尽最大可能陪陪家人</li><li>投资达到2019的水平（只看赚的，不看赔的）</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>接触了一些大牛之后备受打击，可是以往的岁月已经无法改变，只要认清了自己从现在开始就不晚，2019悄然离开，2020已经隆重登场！加油~</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;长大了就要为小时候吹过的牛而奋斗~&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;2019即将过去，瞅一眼桌面右下角的时间，距离2020年还有63分51秒，这是我第一次这么强烈地想在一年结束之际写下点什么。本身是一个喜欢收集和总结知识的性格，但对自己的人生却少有总结，一方面感觉没什么可写，一方面也确实对自己太过宽容。&lt;/p&gt;
    
    </summary>
    
      <category term="Thinking" scheme="http://AlbertGithubHome.github.io/blog/categories/Thinking/"/>
    
    
      <category term="总结" scheme="http://AlbertGithubHome.github.io/blog/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="工作" scheme="http://AlbertGithubHome.github.io/blog/tags/%E5%B7%A5%E4%BD%9C/"/>
    
      <category term="学习" scheme="http://AlbertGithubHome.github.io/blog/tags/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="生活" scheme="http://AlbertGithubHome.github.io/blog/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>单继承、多继承、菱形继承的虚函数表</title>
    <link href="http://AlbertGithubHome.github.io/blog/2020/01/03/%E5%8D%95%E7%BB%A7%E6%89%BF%E3%80%81%E5%A4%9A%E7%BB%A7%E6%89%BF%E3%80%81%E8%8F%B1%E5%BD%A2%E7%BB%A7%E6%89%BF%E7%9A%84%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8/"/>
    <id>http://AlbertGithubHome.github.io/blog/2020/01/03/单继承、多继承、菱形继承的虚函数表/</id>
    <published>2020-01-03T05:45:05.000Z</published>
    <updated>2020-02-09T09:46:09.532Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近被问到一个关于多继承虚函数表的问题，当时回答是可能存在多个虚函数表，应该是顺序排列的，但具体怎么排列还是有些疑惑的，回答的时候到有点儿心虚。之后查了资料，做了简单的实验，可以确定的是对于继承了多个含有虚函数基类的子类来说，指向虚函数表的指针应该不止一个。</p><a id="more"></a><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>虚函数表的问题是从C++多态的概念引出的，要想实现多态有3个条件：</p><ol><li>存在继承：没有继承就没有多态（运行时），在多态中必须存在有继承关系的父类和子类。</li><li>重写函数：父类中需要定义带有 <code>virtual</code> 关键字的函数，而在子类中重写一个名字和参数与父类中定义完全相同的函数。</li><li>向上转型：将父类的指针和引用指向子类的对象。</li></ol><p>满足以上三个条件，当使用父类的指针调用带有 <code>virtual</code> 关键字的函数时，就会产生多态行为。</p><p>实现这种多态表现的核心内容就是虚函数表，对于带有 <code>virtual</code> 关键字的函数地址会被放入一个表格，而在类中会有一个指向虚函数表的指针指向这个表格，表明这个表格属于类的一部分。</p><p>对于父类来说，这个表格中都是自己类的虚函数，而对于子类来说，首先这个虚函数表包含父类中所有的虚函数，当子类重写某个虚函数时就会用子类重写后的函数地址替换原来父类中定义的函数地址，同时在子类的虚函数表中还会包含子类独有的虚函数。</p><p>由此可见虚函数表的不同和复杂性还是体现在子类上，所以之后会分别测试单继承、多继承、菱形继承三种情况下虚函数表的不同，主要看一下虚函数表的个数和内存布局情况。</p><h1 id="测试环境"><a href="#测试环境" class="headerlink" title="测试环境"></a>测试环境</h1><p>首先来说明一下测试环境，测试工具是<code>VS2013</code>，对于<code>int *p; sizeof(p)</code>的结果是4，说明编译环境是32位的，这个对后面查看内存结构非常关键。</p><h1 id="开始测试"><a href="#开始测试" class="headerlink" title="开始测试"></a>开始测试</h1><p>使用VS2013查看类的内存布局非常方便，因为类的大小在编译期间就已经确定了，不用运行就可以通过添加编译选项知道类的大小和布局，而指向虚函数表的指针也会占用类的大小，如果说编译的时候确定了类的大小，那从侧面也说明了在编译期间虚函数表实际上也确定了。</p><p>使用VS2013查看类的布局时，可以在项目的属性页：“配置属性”–&gt;“C/C++”–&gt;“命令行”中输入以下任意一个命令，</p><ul><li><code>/d1reportAllClassLayout</code> ：这个选项可以在VS的输出窗口显示所有相关联的类结构，因为一些外部类也会显示，最终的内容会非常多，需要自己辨别有用的信息。</li><li><code>/d1reportSingleClassLayoutXXX</code> ：这个选项只会在输出窗口显示指定的类结构，只需要将<code>XXX</code>替换成想显示的类的名字即可，缺点就是无法同时显示多个想查看的类。</li></ul><h2 id="无虚函数简单类结构"><a href="#无虚函数简单类结构" class="headerlink" title="无虚函数简单类结构"></a>无虚函数简单类结构</h2><p>在查看虚函数表的结构之前，先使用之前的编译参数来查看一下简单的类结构，排除虚函数的干扰，能更清楚的了解类成员在类中的布局情况，有一点需要提一下，成员变量会占用类的大小，但是成员函数不会，如果有虚函数，所有的虚函数会被放入一个表格，而在类中放置一个指向虚函数表的指针，来看一下简单代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CBase</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> m_var1;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CDerived</span> :</span> <span class="keyword">public</span> CBase</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> m_var2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>编译输出的类的内存布局为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1&gt;  class CBase    size(4):</span><br><span class="line"><span class="number">1</span>&gt;      +---</span><br><span class="line"><span class="number">1</span>&gt;   <span class="number">0</span>  | m_var1</span><br><span class="line"><span class="number">1</span>&gt;      +---</span><br><span class="line"><span class="number">1</span>&gt;</span><br><span class="line">1&gt;  class CDerived  size(8):</span><br><span class="line"><span class="number">1</span>&gt;      +---</span><br><span class="line"><span class="number">1</span>&gt;      | +--- (base class CBase)</span><br><span class="line"><span class="number">1</span>&gt;   <span class="number">0</span>  | | m_var1</span><br><span class="line"><span class="number">1</span>&gt;      | +---</span><br><span class="line"><span class="number">1</span>&gt;   <span class="number">4</span>  | m_var2</span><br><span class="line"><span class="number">1</span>&gt;      +---</span><br></pre></td></tr></table></figure><p>从上面的输出内容来看，很清楚的可以看到基类 <code>CBase</code> 的大小 <code>size(4)</code> 占用4个字节，只有一个成员变量 <code>m_var1</code>，在类中偏移量为0的位置，而派生类 <code>CDerived</code> 占用8个字节大小，第一个成员继承自基类 <code>CBase</code> 的 <code>m_var1</code>，在类中偏移量为0的位置，还有一个子类独有的成员变量 <code>m_var2</code>，在类中偏移量为4的位置。</p><p>掌握着这种简单类的查看类结构的方法，接下来开始看一下包含虚函数的类的内存布局。</p><h2 id="包含虚函数的类结构"><a href="#包含虚函数的类结构" class="headerlink" title="包含虚函数的类结构"></a>包含虚函数的类结构</h2><p>查看包含虚函数的类结构相对来说麻烦一点，先来说两个符号，免得一会看见结构发懵，<code>vfptr</code> 表示类中指向虚函数表的指针，通常放在类的起始位置，比成员变量的位置都要靠前， <code>vftable</code> 表示类中引用的虚函数表，在具体分析是还有有一些修饰符，用来表明是谁的虚函数表。</p><h3 id="单继承"><a href="#单继承" class="headerlink" title="单继承"></a>单继承</h3><p>这种情况的下的子类的虚函数表很简单，在该子类的内存布局上，最开始的位置保存了一个指向虚函数表的指针，虚函数表中包含了从父类继承的虚函数，当子类中重写父类虚函数时会将虚函数表中对应的函数地址替换，最后添加上自己独有的虚函数地址，下面上代码分析一下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CBase</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func0</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> m_var1;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CDerived</span> :</span> <span class="keyword">public</span> CBase</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func3</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func4</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> m_var2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面这两个类的内存布局情况如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">1&gt;  class CBase size(8):</span><br><span class="line"><span class="number">1</span>&gt;      +---</span><br><span class="line"><span class="number">1</span>&gt;   <span class="number">0</span>  | &#123;vfptr&#125;</span><br><span class="line"><span class="number">1</span>&gt;   <span class="number">4</span>  | m_var1</span><br><span class="line"><span class="number">1</span>&gt;      +---</span><br><span class="line"><span class="number">1</span>&gt;</span><br><span class="line"><span class="number">1</span>&gt;  CBase::$vftable@:</span><br><span class="line"><span class="number">1</span>&gt;      | &amp;CBase_meta</span><br><span class="line"><span class="number">1</span>&gt;      |  <span class="number">0</span></span><br><span class="line"><span class="number">1</span>&gt;   <span class="number">0</span>  | &amp;CBase::func1</span><br><span class="line"><span class="number">1</span>&gt;   <span class="number">1</span>  | &amp;CBase::func2</span><br><span class="line"><span class="number">1</span>&gt;</span><br><span class="line"><span class="number">1</span>&gt;  CBase::func1 <span class="keyword">this</span> adjustor: <span class="number">0</span></span><br><span class="line"><span class="number">1</span>&gt;  CBase::func2 <span class="keyword">this</span> adjustor: <span class="number">0</span></span><br><span class="line"><span class="number">1</span>&gt;</span><br><span class="line"><span class="number">1</span>&gt;</span><br><span class="line">1&gt;  class CDerived  size(12):</span><br><span class="line"><span class="number">1</span>&gt;      +---</span><br><span class="line"><span class="number">1</span>&gt;      | +--- (base class CBase)</span><br><span class="line"><span class="number">1</span>&gt;   <span class="number">0</span>  | | &#123;vfptr&#125;</span><br><span class="line"><span class="number">1</span>&gt;   <span class="number">4</span>  | | m_var1</span><br><span class="line"><span class="number">1</span>&gt;      | +---</span><br><span class="line"><span class="number">1</span>&gt;   <span class="number">8</span>  | m_var2</span><br><span class="line"><span class="number">1</span>&gt;      +---</span><br><span class="line"><span class="number">1</span>&gt;</span><br><span class="line"><span class="number">1</span>&gt;  CDerived::$vftable@:</span><br><span class="line"><span class="number">1</span>&gt;      | &amp;CDerived_meta</span><br><span class="line"><span class="number">1</span>&gt;      |  <span class="number">0</span></span><br><span class="line"><span class="number">1</span>&gt;   <span class="number">0</span>  | &amp;CBase::func1</span><br><span class="line"><span class="number">1</span>&gt;   <span class="number">1</span>  | &amp;CDerived::func2</span><br><span class="line"><span class="number">1</span>&gt;   <span class="number">2</span>  | &amp;CDerived::func3</span><br><span class="line"><span class="number">1</span>&gt;</span><br><span class="line"><span class="number">1</span>&gt;  CDerived::func2 <span class="keyword">this</span> adjustor: <span class="number">0</span></span><br><span class="line"><span class="number">1</span>&gt;  CDerived::func3 <span class="keyword">this</span> adjustor: <span class="number">0</span></span><br></pre></td></tr></table></figure><p>看起来是不是比没有虚函数时复杂多了，不过不要着急，从上到下慢慢分析就好了，这次的基类 <code>CBase</code> 大小是8个字节，首先是<code>{vfptr}</code>这个指向虚函数表的指针，在类中的偏移量是0，接下来是成员变量 <code>m_var1</code>，在类中偏移量是4。</p><p>然后是 <code>CBase::$vftable@</code> 表示基类 <code>CBase</code> 的虚函数表，其中第一行 <code>&amp;CBase_meta</code> 看起来怪怪的，这里我们不展开（因为我也没弄太懂），应该是和虚函数表相关的元数据，第二行是一个0，看起来是一个偏移量，这里没有偏移，当出现偏移时我们再试着分析（相信我，马上就会出现），第三行内容 <code>&amp;CBase::func1</code> 是自己类的虚函数，前面有一个0，应该是指该虚函数在虚函数表中索引，第四行也是相同的情况。</p><p>接下来出现了两行非常相似的内容，看一下<code>CBase::func1 this adjustor: 0</code>，这句代码中的关键是 <code>adjustor</code>，其实有是一个偏移量，据说涉及到thunk技术，据说“thunk其实就是一条汇编指令，操作码是0xe9，就是jmp，后面紧跟操作数”，这里我们就不展开了，如果后面弄明白了可以单独写一篇总结，到此为止基类的内存结构就分析完了。</p><p>继续看派生类 <code>CDerived</code>，它的大小是12个字节，内部结构首先是 <code>{vfptr}</code> 一个指向虚函数表的指针，偏移量为0，<code>m_var1</code> 是从父类继承的成员变量，偏移量为4，而 <code>m_var2</code> 是自己类独有的成员变量，偏移量是8。</p><p>然后看派生类对应的虚函数表 <code>CDerived::$vftable@</code>，跳过前两行直接看一下后面几个函数，发现只有 <code>func1</code> 是基类的，而函数 <code>func2</code> 和 <code>func3</code> 都是派生类的，出现这种情况的原因是子类重写了函数 <code>func2</code> 和 <code>func3</code> ，所以用重写后的函数地址替换了从基类继承的虚函数，造成了目前看到的状况。</p><p>最后又出现了两行 <code>adjustor</code>，很奇怪为什么 <code>func1</code> 函数没有 <code>adjustor</code>，貌似这个 <code>adjustor</code> 只对当前类有效，先留个疑问，接下来看一下多继承。</p><h3 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h3><p>当多个父类中都包含虚函数的时候，和子类关联的虚函数表就不止一个了，这个情况是可以通过使用sizeof(子类)来简单验证的：</p><p>这一部分是在没有VS的情况下预先写下的，本来考虑使用VS展开布局后，这一段就没有什么必要了，但是后来想想还是留着吧，因为这一段使用的g++编译器，64位环境，每个指针占用8个字节，通过不同的环境调试，更加可以证明，多继承下的多个虚函数表的存在性：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">W</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">long</span> n;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>对于这样的一个简单类，sizeof(W) = 8，类的大小等于成员变量的大小。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">W1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">long</span> n1;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">W2</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">long</span> n2;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>对于上面这两个简单的包含虚函数的类，sizeof(W1) = 16，sizeof(W2) = 16，因为每个类都除了一个 <code>long</code> 类型的成员变量以外，还包含了指向虚函数的一个指针，所以类的大小是16个字节。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WW</span> :</span> <span class="keyword">public</span> W1, <span class="keyword">public</span> W2</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">long</span> nn;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>而继承了 <code>W1</code> 和 <code>W2</code> 这两个父类的子类 <code>WW</code> 在继承了两个成员变量 <code>n1</code> 和 <code>n2</code> 之外，还有自己的成员变量 <code>nn</code>，三个变量占用字节24个，而计算类 <code>WW</code> 的的大小 sizeof(W1) = 40，也就是说除了成员变量24个字节，还剩余了16个字节的空间没有着落，我们知道它至少包含一个指向虚函数表的指针，占用8个字节的大小，还剩8个字节没有找到用处，从此处分析应该还有一个指向虚函数表的指针，具体的情况可以看一下内存分布。</p><p>接下来和单继承的分析方法一样，写代码编译查看布局：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CBase0</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func0</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func3</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> m_var0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CBase1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func0</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func3</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func4</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> m_var1;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CDerived</span> :</span> <span class="keyword">public</span> CBase0, <span class="keyword">public</span> CBase1</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func4</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func5</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func6</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> m_var2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面3个类描述了一个简单的多继承的情况，之所以写这么多函数就是构建一种，既有虚函数覆盖，又有单独不被覆盖的情况，下面展示了这段代码的内存布局。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">1&gt;  class CBase0    size(8):</span><br><span class="line"><span class="number">1</span>&gt;      +---</span><br><span class="line"><span class="number">1</span>&gt;   <span class="number">0</span>  | &#123;vfptr&#125;</span><br><span class="line"><span class="number">1</span>&gt;   <span class="number">4</span>  | m_var0</span><br><span class="line"><span class="number">1</span>&gt;      +---</span><br><span class="line"><span class="number">1</span>&gt;</span><br><span class="line"><span class="number">1</span>&gt;  CBase0::$vftable@:</span><br><span class="line"><span class="number">1</span>&gt;      | &amp;CBase0_meta</span><br><span class="line"><span class="number">1</span>&gt;      |  <span class="number">0</span></span><br><span class="line"><span class="number">1</span>&gt;   <span class="number">0</span>  | &amp;CBase0::func1</span><br><span class="line"><span class="number">1</span>&gt;   <span class="number">1</span>  | &amp;CBase0::func2</span><br><span class="line"><span class="number">1</span>&gt;   <span class="number">2</span>  | &amp;CBase0::func3</span><br><span class="line"><span class="number">1</span>&gt;</span><br><span class="line"><span class="number">1</span>&gt;  CBase0::func1 <span class="keyword">this</span> adjustor: <span class="number">0</span></span><br><span class="line"><span class="number">1</span>&gt;  CBase0::func2 <span class="keyword">this</span> adjustor: <span class="number">0</span></span><br><span class="line"><span class="number">1</span>&gt;  CBase0::func3 <span class="keyword">this</span> adjustor: <span class="number">0</span></span><br><span class="line"><span class="number">1</span>&gt;</span><br><span class="line"><span class="number">1</span>&gt;</span><br><span class="line">1&gt;  class CBase1    size(8):</span><br><span class="line"><span class="number">1</span>&gt;      +---</span><br><span class="line"><span class="number">1</span>&gt;   <span class="number">0</span>  | &#123;vfptr&#125;</span><br><span class="line"><span class="number">1</span>&gt;   <span class="number">4</span>  | m_var1</span><br><span class="line"><span class="number">1</span>&gt;      +---</span><br><span class="line"><span class="number">1</span>&gt;</span><br><span class="line"><span class="number">1</span>&gt;  CBase1::$vftable@:</span><br><span class="line"><span class="number">1</span>&gt;      | &amp;CBase1_meta</span><br><span class="line"><span class="number">1</span>&gt;      |  <span class="number">0</span></span><br><span class="line"><span class="number">1</span>&gt;   <span class="number">0</span>  | &amp;CBase1::func2</span><br><span class="line"><span class="number">1</span>&gt;   <span class="number">1</span>  | &amp;CBase1::func3</span><br><span class="line"><span class="number">1</span>&gt;   <span class="number">2</span>  | &amp;CBase1::func4</span><br><span class="line"><span class="number">1</span>&gt;</span><br><span class="line"><span class="number">1</span>&gt;  CBase1::func2 <span class="keyword">this</span> adjustor: <span class="number">0</span></span><br><span class="line"><span class="number">1</span>&gt;  CBase1::func3 <span class="keyword">this</span> adjustor: <span class="number">0</span></span><br><span class="line"><span class="number">1</span>&gt;  CBase1::func4 <span class="keyword">this</span> adjustor: <span class="number">0</span></span><br><span class="line"><span class="number">1</span>&gt;</span><br><span class="line"><span class="number">1</span>&gt;</span><br><span class="line">1&gt;  class CDerived  size(20):</span><br><span class="line"><span class="number">1</span>&gt;      +---</span><br><span class="line"><span class="number">1</span>&gt;      | +--- (base class CBase0)</span><br><span class="line"><span class="number">1</span>&gt;   <span class="number">0</span>  | | &#123;vfptr&#125;</span><br><span class="line"><span class="number">1</span>&gt;   <span class="number">4</span>  | | m_var0</span><br><span class="line"><span class="number">1</span>&gt;      | +---</span><br><span class="line"><span class="number">1</span>&gt;      | +--- (base class CBase1)</span><br><span class="line"><span class="number">1</span>&gt;   <span class="number">8</span>  | | &#123;vfptr&#125;</span><br><span class="line"><span class="number">1</span>&gt;  <span class="number">12</span>  | | m_var1</span><br><span class="line"><span class="number">1</span>&gt;      | +---</span><br><span class="line"><span class="number">1</span>&gt;  <span class="number">16</span>  | m_var2</span><br><span class="line"><span class="number">1</span>&gt;      +---</span><br><span class="line"><span class="number">1</span>&gt;</span><br><span class="line"><span class="number">1</span>&gt;  CDerived::$vftable@CBase0@:</span><br><span class="line"><span class="number">1</span>&gt;      | &amp;CDerived_meta</span><br><span class="line"><span class="number">1</span>&gt;      |  <span class="number">0</span></span><br><span class="line"><span class="number">1</span>&gt;   <span class="number">0</span>  | &amp;CDerived::func1</span><br><span class="line"><span class="number">1</span>&gt;   <span class="number">1</span>  | &amp;CDerived::func2</span><br><span class="line"><span class="number">1</span>&gt;   <span class="number">2</span>  | &amp;CBase0::func3</span><br><span class="line"><span class="number">1</span>&gt;   <span class="number">3</span>  | &amp;CDerived::func5</span><br><span class="line"><span class="number">1</span>&gt;</span><br><span class="line"><span class="number">1</span>&gt;  CDerived::$vftable@CBase1@:</span><br><span class="line"><span class="number">1</span>&gt;      | <span class="number">-8</span></span><br><span class="line"><span class="number">1</span>&gt;   <span class="number">0</span>  | &amp;thunk: <span class="keyword">this</span>-=<span class="number">8</span>; <span class="keyword">goto</span> CDerived::func2</span><br><span class="line"><span class="number">1</span>&gt;   <span class="number">1</span>  | &amp;CBase1::func3</span><br><span class="line"><span class="number">1</span>&gt;   <span class="number">2</span>  | &amp;CDerived::func4</span><br><span class="line"><span class="number">1</span>&gt;</span><br><span class="line"><span class="number">1</span>&gt;  CDerived::func1 <span class="keyword">this</span> adjustor: <span class="number">0</span></span><br><span class="line"><span class="number">1</span>&gt;  CDerived::func2 <span class="keyword">this</span> adjustor: <span class="number">0</span></span><br><span class="line"><span class="number">1</span>&gt;  CDerived::func4 <span class="keyword">this</span> adjustor: <span class="number">8</span></span><br><span class="line"><span class="number">1</span>&gt;  CDerived::func5 <span class="keyword">this</span> adjustor: <span class="number">0</span></span><br></pre></td></tr></table></figure><p>内容很多，前面两个基类 <code>CBase0</code> 和 <code>CBase1</code> 的布局很简单，参照之前的分析很容易看懂，直接从派生类看起吧。</p><p>我们发现派生类 <code>CDerived</code> 中确实有两个指向虚函数表的指针，接下来看一下这两个虚函数表，这个虚函数表和前面遇到的格式一样，除了第一行的元数据，第二行的诡异偏移量0，剩下的虚函数指针有的是从基类继承来的，有的是被当前派生类覆盖的，还有派生类自己独有的。</p><p>而第二个虚函数表就有点意思了，首先是少了 <code>&amp;CDerived_meta</code> 这一行，然后偏移量终于不是0了，而是-8，从派生类 <code>CDerived</code> 的内存布局上来看，以下开始大胆假设，至于小心求证的部分放到以后来做（看自己的进步状态了）。</p><p>第二个指向虚函数表的指针是不是距离类的起始偏移量是8，我猜这个-8的意思就是指的这个偏移量，这个值有可能被后面使用，第二行出现了 <code>&amp;thunk: this-=8; goto CDerived::func2</code>，其中包含 <code>thunk</code> 字样，表示这个 <code>func2</code> 不归我管，你去-8偏移量的那个虚函数表里找一找。</p><p>还有一点你有没有发现 <code>func5</code> 这个函数只在第一个虚函数表中出现，而没有出现在第二个虚函数表中，这也是一个规则，自己独有的虚函数放到第一个虚函数表中，这可能也是为什么只有第一个虚函数表包含元数据行。</p><p>最后一点，我们发现对于函数 <code>func4</code> 来说 <code>adjustor</code> 终于不是0了，而值变成了8，仿佛在说这个虚函数只在偏移量的为8的位置。</p><h3 id="菱形继承"><a href="#菱形继承" class="headerlink" title="菱形继承"></a>菱形继承</h3><p>对于这一部分，并没有太多新的内容，只是简单的菱形继承中，最初的基类在最终的子类中会包含两份，而虚函数的样子并没有太大的不同，接下来简单看一下代码和对应的内存布局即可，因为菱形继承并不被提倡，所以也不用花太多时间来分析这个问题。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CSuper</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func0</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> m_var;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CBase0</span> :</span> <span class="keyword">public</span> CSuper</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> m_var0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CBase1</span> :</span> <span class="keyword">public</span> CSuper</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func3</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> m_var1;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CDerived</span> :</span> <span class="keyword">public</span> CBase0, <span class="keyword">public</span> CBase1</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func3</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func4</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> m_var2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line">1&gt;  class CSuper    size(8):</span><br><span class="line"><span class="number">1</span>&gt;      +---</span><br><span class="line"><span class="number">1</span>&gt;   <span class="number">0</span>  | &#123;vfptr&#125;</span><br><span class="line"><span class="number">1</span>&gt;   <span class="number">4</span>  | m_var</span><br><span class="line"><span class="number">1</span>&gt;      +---</span><br><span class="line"><span class="number">1</span>&gt;</span><br><span class="line"><span class="number">1</span>&gt;  CSuper::$vftable@:</span><br><span class="line"><span class="number">1</span>&gt;      | &amp;CSuper_meta</span><br><span class="line"><span class="number">1</span>&gt;      |  <span class="number">0</span></span><br><span class="line"><span class="number">1</span>&gt;   <span class="number">0</span>  | &amp;CSuper::func0</span><br><span class="line"><span class="number">1</span>&gt;   <span class="number">1</span>  | &amp;CSuper::func1</span><br><span class="line"><span class="number">1</span>&gt;</span><br><span class="line"><span class="number">1</span>&gt;  CSuper::func0 <span class="keyword">this</span> adjustor: <span class="number">0</span></span><br><span class="line"><span class="number">1</span>&gt;  CSuper::func1 <span class="keyword">this</span> adjustor: <span class="number">0</span></span><br><span class="line"><span class="number">1</span>&gt;</span><br><span class="line"><span class="number">1</span>&gt;</span><br><span class="line">1&gt;  class CBase0    size(12):</span><br><span class="line"><span class="number">1</span>&gt;      +---</span><br><span class="line"><span class="number">1</span>&gt;      | +--- (base class CSuper)</span><br><span class="line"><span class="number">1</span>&gt;   <span class="number">0</span>  | | &#123;vfptr&#125;</span><br><span class="line"><span class="number">1</span>&gt;   <span class="number">4</span>  | | m_var</span><br><span class="line"><span class="number">1</span>&gt;      | +---</span><br><span class="line"><span class="number">1</span>&gt;   <span class="number">8</span>  | m_var0</span><br><span class="line"><span class="number">1</span>&gt;      +---</span><br><span class="line"><span class="number">1</span>&gt;</span><br><span class="line"><span class="number">1</span>&gt;  CBase0::$vftable@:</span><br><span class="line"><span class="number">1</span>&gt;      | &amp;CBase0_meta</span><br><span class="line"><span class="number">1</span>&gt;      |  <span class="number">0</span></span><br><span class="line"><span class="number">1</span>&gt;   <span class="number">0</span>  | &amp;CSuper::func0</span><br><span class="line"><span class="number">1</span>&gt;   <span class="number">1</span>  | &amp;CBase0::func1</span><br><span class="line"><span class="number">1</span>&gt;   <span class="number">2</span>  | &amp;CBase0::func2</span><br><span class="line"><span class="number">1</span>&gt;</span><br><span class="line"><span class="number">1</span>&gt;  CBase0::func1 <span class="keyword">this</span> adjustor: <span class="number">0</span></span><br><span class="line"><span class="number">1</span>&gt;  CBase0::func2 <span class="keyword">this</span> adjustor: <span class="number">0</span></span><br><span class="line"><span class="number">1</span>&gt;</span><br><span class="line"><span class="number">1</span>&gt;</span><br><span class="line">1&gt;  class CBase1    size(12):</span><br><span class="line"><span class="number">1</span>&gt;      +---</span><br><span class="line"><span class="number">1</span>&gt;      | +--- (base class CSuper)</span><br><span class="line"><span class="number">1</span>&gt;   <span class="number">0</span>  | | &#123;vfptr&#125;</span><br><span class="line"><span class="number">1</span>&gt;   <span class="number">4</span>  | | m_var</span><br><span class="line"><span class="number">1</span>&gt;      | +---</span><br><span class="line"><span class="number">1</span>&gt;   <span class="number">8</span>  | m_var1</span><br><span class="line"><span class="number">1</span>&gt;      +---</span><br><span class="line"><span class="number">1</span>&gt;</span><br><span class="line"><span class="number">1</span>&gt;  CBase1::$vftable@:</span><br><span class="line"><span class="number">1</span>&gt;      | &amp;CBase1_meta</span><br><span class="line"><span class="number">1</span>&gt;      |  <span class="number">0</span></span><br><span class="line"><span class="number">1</span>&gt;   <span class="number">0</span>  | &amp;CSuper::func0</span><br><span class="line"><span class="number">1</span>&gt;   <span class="number">1</span>  | &amp;CBase1::func1</span><br><span class="line"><span class="number">1</span>&gt;   <span class="number">2</span>  | &amp;CBase1::func3</span><br><span class="line"><span class="number">1</span>&gt;</span><br><span class="line"><span class="number">1</span>&gt;  CBase1::func1 <span class="keyword">this</span> adjustor: <span class="number">0</span></span><br><span class="line"><span class="number">1</span>&gt;  CBase1::func3 <span class="keyword">this</span> adjustor: <span class="number">0</span></span><br><span class="line"><span class="number">1</span>&gt;</span><br><span class="line"><span class="number">1</span>&gt;</span><br><span class="line">1&gt;  class CDerived  size(28):</span><br><span class="line"><span class="number">1</span>&gt;      +---</span><br><span class="line"><span class="number">1</span>&gt;      | +--- (base class CBase0)</span><br><span class="line"><span class="number">1</span>&gt;      | | +--- (base class CSuper)</span><br><span class="line"><span class="number">1</span>&gt;   <span class="number">0</span>  | | | &#123;vfptr&#125;</span><br><span class="line"><span class="number">1</span>&gt;   <span class="number">4</span>  | | | m_var</span><br><span class="line"><span class="number">1</span>&gt;      | | +---</span><br><span class="line"><span class="number">1</span>&gt;   <span class="number">8</span>  | | m_var0</span><br><span class="line"><span class="number">1</span>&gt;      | +---</span><br><span class="line"><span class="number">1</span>&gt;      | +--- (base class CBase1)</span><br><span class="line"><span class="number">1</span>&gt;      | | +--- (base class CSuper)</span><br><span class="line"><span class="number">1</span>&gt;  <span class="number">12</span>  | | | &#123;vfptr&#125;</span><br><span class="line"><span class="number">1</span>&gt;  <span class="number">16</span>  | | | m_var</span><br><span class="line"><span class="number">1</span>&gt;      | | +---</span><br><span class="line"><span class="number">1</span>&gt;  <span class="number">20</span>  | | m_var1</span><br><span class="line"><span class="number">1</span>&gt;      | +---</span><br><span class="line"><span class="number">1</span>&gt;  <span class="number">24</span>  | m_var2</span><br><span class="line"><span class="number">1</span>&gt;      +---</span><br><span class="line"><span class="number">1</span>&gt;</span><br><span class="line"><span class="number">1</span>&gt;  CDerived::$vftable@CBase0@:</span><br><span class="line"><span class="number">1</span>&gt;      | &amp;CDerived_meta</span><br><span class="line"><span class="number">1</span>&gt;      |  <span class="number">0</span></span><br><span class="line"><span class="number">1</span>&gt;   <span class="number">0</span>  | &amp;CSuper::func0</span><br><span class="line"><span class="number">1</span>&gt;   <span class="number">1</span>  | &amp;CDerived::func1</span><br><span class="line"><span class="number">1</span>&gt;   <span class="number">2</span>  | &amp;CBase0::func2</span><br><span class="line"><span class="number">1</span>&gt;   <span class="number">3</span>  | &amp;CDerived::func4</span><br><span class="line"><span class="number">1</span>&gt;</span><br><span class="line"><span class="number">1</span>&gt;  CDerived::$vftable@CBase1@:</span><br><span class="line"><span class="number">1</span>&gt;      | <span class="number">-12</span></span><br><span class="line"><span class="number">1</span>&gt;   <span class="number">0</span>  | &amp;CSuper::func0</span><br><span class="line"><span class="number">1</span>&gt;   <span class="number">1</span>  | &amp;thunk: <span class="keyword">this</span>-=<span class="number">12</span>; <span class="keyword">goto</span> CDerived::func1</span><br><span class="line"><span class="number">1</span>&gt;   <span class="number">2</span>  | &amp;CDerived::func3</span><br><span class="line"><span class="number">1</span>&gt;</span><br><span class="line"><span class="number">1</span>&gt;  CDerived::func1 <span class="keyword">this</span> adjustor: <span class="number">0</span></span><br><span class="line"><span class="number">1</span>&gt;  CDerived::func3 <span class="keyword">this</span> adjustor: <span class="number">12</span></span><br><span class="line"><span class="number">1</span>&gt;  CDerived::func4 <span class="keyword">this</span> adjustor: <span class="number">0</span></span><br></pre></td></tr></table></figure><h3 id="虚继承"><a href="#虚继承" class="headerlink" title="虚继承"></a>虚继承</h3><p>解决菱形继承的一个常用的办法就是改为虚继承，实际上虚继承中就是将从最基类中继承的公共部分提取出来放在最子类的末尾，然后在提取之前的位置用一个叫做<code>vbptr</code>的指针指向这里。</p><p>之前看到过一种说法：</p><blockquote><p>虚继承内部实现也相当复杂，似乎破坏了OO的纯洁性</p></blockquote><p>至于复杂不复杂，看看后面的内存布局就很清楚了，那是相当复杂，其中出现了各种偏移，简单了解下就行了，如果不是维护老代码，谁现在还写这样的结构。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CSuper</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func0</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> m_var;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CBase0</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> CSuper</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> m_var0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CBase1</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> CSuper</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func3</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> m_var1;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CDerived</span> :</span> <span class="keyword">public</span> CBase0, <span class="keyword">public</span> CBase1</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func3</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func4</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> m_var2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line">1&gt;  class CSuper    size(8):</span><br><span class="line"><span class="number">1</span>&gt;      +---</span><br><span class="line"><span class="number">1</span>&gt;   <span class="number">0</span>  | &#123;vfptr&#125;</span><br><span class="line"><span class="number">1</span>&gt;   <span class="number">4</span>  | m_var</span><br><span class="line"><span class="number">1</span>&gt;      +---</span><br><span class="line"><span class="number">1</span>&gt;</span><br><span class="line"><span class="number">1</span>&gt;  CSuper::$vftable@:</span><br><span class="line"><span class="number">1</span>&gt;      | &amp;CSuper_meta</span><br><span class="line"><span class="number">1</span>&gt;      |  <span class="number">0</span></span><br><span class="line"><span class="number">1</span>&gt;   <span class="number">0</span>  | &amp;CSuper::func0</span><br><span class="line"><span class="number">1</span>&gt;   <span class="number">1</span>  | &amp;CSuper::func1</span><br><span class="line"><span class="number">1</span>&gt;</span><br><span class="line"><span class="number">1</span>&gt;  CSuper::func0 <span class="keyword">this</span> adjustor: <span class="number">0</span></span><br><span class="line"><span class="number">1</span>&gt;  CSuper::func1 <span class="keyword">this</span> adjustor: <span class="number">0</span></span><br><span class="line"><span class="number">1</span>&gt;</span><br><span class="line"><span class="number">1</span>&gt;</span><br><span class="line">1&gt;  class CBase0    size(20):</span><br><span class="line"><span class="number">1</span>&gt;      +---</span><br><span class="line"><span class="number">1</span>&gt;   <span class="number">0</span>  | &#123;vfptr&#125;</span><br><span class="line"><span class="number">1</span>&gt;   <span class="number">4</span>  | &#123;vbptr&#125;</span><br><span class="line"><span class="number">1</span>&gt;   <span class="number">8</span>  | m_var0</span><br><span class="line"><span class="number">1</span>&gt;      +---</span><br><span class="line"><span class="number">1</span>&gt;      +--- (<span class="keyword">virtual</span> base CSuper)</span><br><span class="line"><span class="number">1</span>&gt;  <span class="number">12</span>  | &#123;vfptr&#125;</span><br><span class="line"><span class="number">1</span>&gt;  <span class="number">16</span>  | m_var</span><br><span class="line"><span class="number">1</span>&gt;      +---</span><br><span class="line"><span class="number">1</span>&gt;</span><br><span class="line"><span class="number">1</span>&gt;  CBase0::$vftable@CBase0@:</span><br><span class="line"><span class="number">1</span>&gt;      | &amp;CBase0_meta</span><br><span class="line"><span class="number">1</span>&gt;      |  <span class="number">0</span></span><br><span class="line"><span class="number">1</span>&gt;   <span class="number">0</span>  | &amp;CBase0::func2</span><br><span class="line"><span class="number">1</span>&gt;</span><br><span class="line"><span class="number">1</span>&gt;  CBase0::$vbtable@:</span><br><span class="line"><span class="number">1</span>&gt;   <span class="number">0</span>  | <span class="number">-4</span></span><br><span class="line"><span class="number">1</span>&gt;   <span class="number">1</span>  | <span class="number">8</span> (CBase0d(CBase0+<span class="number">4</span>)CSuper)</span><br><span class="line"><span class="number">1</span>&gt;</span><br><span class="line"><span class="number">1</span>&gt;  CBase0::$vftable@CSuper@:</span><br><span class="line"><span class="number">1</span>&gt;      | <span class="number">-12</span></span><br><span class="line"><span class="number">1</span>&gt;   <span class="number">0</span>  | &amp;CSuper::func0</span><br><span class="line"><span class="number">1</span>&gt;   <span class="number">1</span>  | &amp;CBase0::func1</span><br><span class="line"><span class="number">1</span>&gt;</span><br><span class="line"><span class="number">1</span>&gt;  CBase0::func1 <span class="keyword">this</span> adjustor: <span class="number">12</span></span><br><span class="line"><span class="number">1</span>&gt;  CBase0::func2 <span class="keyword">this</span> adjustor: <span class="number">0</span></span><br><span class="line"><span class="number">1</span>&gt;</span><br><span class="line"><span class="number">1</span>&gt;  vbi:       <span class="class"><span class="keyword">class</span>  <span class="title">offset</span> <span class="title">o</span>.<span class="title">vbptr</span>  <span class="title">o</span>.<span class="title">vbte</span> <span class="title">fVtorDisp</span></span></span><br><span class="line"><span class="class">1&gt;            <span class="title">CSuper</span>      12       4       4 0</span></span><br><span class="line"><span class="class">1&gt;</span></span><br><span class="line"><span class="class">1&gt;</span></span><br><span class="line"><span class="class">1&gt;  <span class="title">class</span> <span class="title">CBase1</span>    <span class="title">size</span>(20):</span></span><br><span class="line"><span class="number">1</span>&gt;      +---</span><br><span class="line"><span class="number">1</span>&gt;   <span class="number">0</span>  | &#123;vfptr&#125;</span><br><span class="line"><span class="number">1</span>&gt;   <span class="number">4</span>  | &#123;vbptr&#125;</span><br><span class="line"><span class="number">1</span>&gt;   <span class="number">8</span>  | m_var1</span><br><span class="line"><span class="number">1</span>&gt;      +---</span><br><span class="line"><span class="number">1</span>&gt;      +--- (<span class="keyword">virtual</span> base CSuper)</span><br><span class="line"><span class="number">1</span>&gt;  <span class="number">12</span>  | &#123;vfptr&#125;</span><br><span class="line"><span class="number">1</span>&gt;  <span class="number">16</span>  | m_var</span><br><span class="line"><span class="number">1</span>&gt;      +---</span><br><span class="line"><span class="number">1</span>&gt;</span><br><span class="line"><span class="number">1</span>&gt;  CBase1::$vftable@CBase1@:</span><br><span class="line"><span class="number">1</span>&gt;      | &amp;CBase1_meta</span><br><span class="line"><span class="number">1</span>&gt;      |  <span class="number">0</span></span><br><span class="line"><span class="number">1</span>&gt;   <span class="number">0</span>  | &amp;CBase1::func3</span><br><span class="line"><span class="number">1</span>&gt;</span><br><span class="line"><span class="number">1</span>&gt;  CBase1::$vbtable@:</span><br><span class="line"><span class="number">1</span>&gt;   <span class="number">0</span>  | <span class="number">-4</span></span><br><span class="line"><span class="number">1</span>&gt;   <span class="number">1</span>  | <span class="number">8</span> (CBase1d(CBase1+<span class="number">4</span>)CSuper)</span><br><span class="line"><span class="number">1</span>&gt;</span><br><span class="line"><span class="number">1</span>&gt;  CBase1::$vftable@CSuper@:</span><br><span class="line"><span class="number">1</span>&gt;      | <span class="number">-12</span></span><br><span class="line"><span class="number">1</span>&gt;   <span class="number">0</span>  | &amp;CSuper::func0</span><br><span class="line"><span class="number">1</span>&gt;   <span class="number">1</span>  | &amp;CBase1::func1</span><br><span class="line"><span class="number">1</span>&gt;</span><br><span class="line"><span class="number">1</span>&gt;  CBase1::func1 <span class="keyword">this</span> adjustor: <span class="number">12</span></span><br><span class="line"><span class="number">1</span>&gt;  CBase1::func3 <span class="keyword">this</span> adjustor: <span class="number">0</span></span><br><span class="line"><span class="number">1</span>&gt;</span><br><span class="line"><span class="number">1</span>&gt;  vbi:       <span class="class"><span class="keyword">class</span>  <span class="title">offset</span> <span class="title">o</span>.<span class="title">vbptr</span>  <span class="title">o</span>.<span class="title">vbte</span> <span class="title">fVtorDisp</span></span></span><br><span class="line"><span class="class">1&gt;            <span class="title">CSuper</span>      12       4       4 0</span></span><br><span class="line"><span class="class">1&gt;</span></span><br><span class="line"><span class="class">1&gt;</span></span><br><span class="line"><span class="class">1&gt;  <span class="title">class</span> <span class="title">CDerived</span>  <span class="title">size</span>(36):</span></span><br><span class="line"><span class="number">1</span>&gt;      +---</span><br><span class="line"><span class="number">1</span>&gt;      | +--- (base class CBase0)</span><br><span class="line"><span class="number">1</span>&gt;   <span class="number">0</span>  | | &#123;vfptr&#125;</span><br><span class="line"><span class="number">1</span>&gt;   <span class="number">4</span>  | | &#123;vbptr&#125;</span><br><span class="line"><span class="number">1</span>&gt;   <span class="number">8</span>  | | m_var0</span><br><span class="line"><span class="number">1</span>&gt;      | +---</span><br><span class="line"><span class="number">1</span>&gt;      | +--- (base class CBase1)</span><br><span class="line"><span class="number">1</span>&gt;  <span class="number">12</span>  | | &#123;vfptr&#125;</span><br><span class="line"><span class="number">1</span>&gt;  <span class="number">16</span>  | | &#123;vbptr&#125;</span><br><span class="line"><span class="number">1</span>&gt;  <span class="number">20</span>  | | m_var1</span><br><span class="line"><span class="number">1</span>&gt;      | +---</span><br><span class="line"><span class="number">1</span>&gt;  <span class="number">24</span>  | m_var2</span><br><span class="line"><span class="number">1</span>&gt;      +---</span><br><span class="line"><span class="number">1</span>&gt;      +--- (<span class="keyword">virtual</span> base CSuper)</span><br><span class="line"><span class="number">1</span>&gt;  <span class="number">28</span>  | &#123;vfptr&#125;</span><br><span class="line"><span class="number">1</span>&gt;  <span class="number">32</span>  | m_var</span><br><span class="line"><span class="number">1</span>&gt;      +---</span><br><span class="line"><span class="number">1</span>&gt;</span><br><span class="line"><span class="number">1</span>&gt;  CDerived::$vftable@CBase0@:</span><br><span class="line"><span class="number">1</span>&gt;      | &amp;CDerived_meta</span><br><span class="line"><span class="number">1</span>&gt;      |  <span class="number">0</span></span><br><span class="line"><span class="number">1</span>&gt;   <span class="number">0</span>  | &amp;CBase0::func2</span><br><span class="line"><span class="number">1</span>&gt;   <span class="number">1</span>  | &amp;CDerived::func4</span><br><span class="line"><span class="number">1</span>&gt;</span><br><span class="line"><span class="number">1</span>&gt;  CDerived::$vftable@CBase1@:</span><br><span class="line"><span class="number">1</span>&gt;      | <span class="number">-12</span></span><br><span class="line"><span class="number">1</span>&gt;   <span class="number">0</span>  | &amp;CDerived::func3</span><br><span class="line"><span class="number">1</span>&gt;</span><br><span class="line"><span class="number">1</span>&gt;  CDerived::$vbtable@CBase0@:</span><br><span class="line"><span class="number">1</span>&gt;   <span class="number">0</span>  | <span class="number">-4</span></span><br><span class="line"><span class="number">1</span>&gt;   <span class="number">1</span>  | <span class="number">24</span> (CDerivedd(CBase0+<span class="number">4</span>)CSuper)</span><br><span class="line"><span class="number">1</span>&gt;</span><br><span class="line"><span class="number">1</span>&gt;  CDerived::$vbtable@CBase1@:</span><br><span class="line"><span class="number">1</span>&gt;   <span class="number">0</span>  | <span class="number">-4</span></span><br><span class="line"><span class="number">1</span>&gt;   <span class="number">1</span>  | <span class="number">12</span> (CDerivedd(CBase1+<span class="number">4</span>)CSuper)</span><br><span class="line"><span class="number">1</span>&gt;</span><br><span class="line"><span class="number">1</span>&gt;  CDerived::$vftable@CSuper@:</span><br><span class="line"><span class="number">1</span>&gt;      | <span class="number">-28</span></span><br><span class="line"><span class="number">1</span>&gt;   <span class="number">0</span>  | &amp;CSuper::func0</span><br><span class="line"><span class="number">1</span>&gt;   <span class="number">1</span>  | &amp;CDerived::func1</span><br><span class="line"><span class="number">1</span>&gt;</span><br><span class="line"><span class="number">1</span>&gt;  CDerived::func1 <span class="keyword">this</span> adjustor: <span class="number">28</span></span><br><span class="line"><span class="number">1</span>&gt;  CDerived::func3 <span class="keyword">this</span> adjustor: <span class="number">12</span></span><br><span class="line"><span class="number">1</span>&gt;  CDerived::func4 <span class="keyword">this</span> adjustor: <span class="number">0</span></span><br><span class="line"><span class="number">1</span>&gt;</span><br><span class="line"><span class="number">1</span>&gt;  vbi:       <span class="class"><span class="keyword">class</span>  <span class="title">offset</span> <span class="title">o</span>.<span class="title">vbptr</span>  <span class="title">o</span>.<span class="title">vbte</span> <span class="title">fVtorDisp</span></span></span><br><span class="line"><span class="class">1&gt;            <span class="title">CSuper</span>      28       4       4 0</span></span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol><li>虚函数表是用来实现多态的核心内容。</li><li>多继承很强大但是不要滥用，当多个基类都含有虚函数时，派生类会有多个指向虚函数表的指针。</li><li>忘记菱形继承吧，为了取消二义性引入虚继承，结果造成内存分布复杂而又难以理解，大道至简，回归本质吧！</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;最近被问到一个关于多继承虚函数表的问题，当时回答是可能存在多个虚函数表，应该是顺序排列的，但具体怎么排列还是有些疑惑的，回答的时候到有点儿心虚。之后查了资料，做了简单的实验，可以确定的是对于继承了多个含有虚函数基类的子类来说，指向虚函数表的指针应该不止一个。&lt;/p&gt;
    
    </summary>
    
      <category term="C/C++" scheme="http://AlbertGithubHome.github.io/blog/categories/C-C/"/>
    
    
      <category term="C/C++" scheme="http://AlbertGithubHome.github.io/blog/tags/C-C/"/>
    
      <category term="继承" scheme="http://AlbertGithubHome.github.io/blog/tags/%E7%BB%A7%E6%89%BF/"/>
    
      <category term="多态" scheme="http://AlbertGithubHome.github.io/blog/tags/%E5%A4%9A%E6%80%81/"/>
    
      <category term="虚函数表" scheme="http://AlbertGithubHome.github.io/blog/tags/%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>C++ STL中map的[]操作符使用时的一个坑</title>
    <link href="http://AlbertGithubHome.github.io/blog/2019/12/14/C-STL%E4%B8%ADmap%E7%9A%84-%E6%93%8D%E4%BD%9C%E7%AC%A6%E4%BD%BF%E7%94%A8%E6%97%B6%E7%9A%84%E4%B8%80%E4%B8%AA%E5%9D%91/"/>
    <id>http://AlbertGithubHome.github.io/blog/2019/12/14/C-STL中map的-操作符使用时的一个坑/</id>
    <published>2019-12-14T02:39:58.000Z</published>
    <updated>2020-02-26T15:02:09.515Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>学习C++，自从发现了map这个结构以后，就深深的被这种键值对的方式吸引了，写代码时也渐渐离不开这种结构了，一次偶然的机会发现这个map还有个 <code>[]</code> 运算符，仿佛又发现了新大陆一样，写代码更加方便了，殊不知一个深深的大坑正在前面等着我。</p><a id="more"></a><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>一开始学到map的时候还是中规中矩的使用函数插入删除，比如定义一个map，先引入头文件和命名空间：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mapTest;</span><br></pre></td></tr></table></figure><p>上面就轻松定义了一个map结构对象，是一个整数到另一个整数的映射，这种映射有什么用呢？举个简单的例子，这个映射可以作为学生的学号和成绩的对应关系，这样只要知道学号，就可以从map中直接获得对应的成绩很方便。</p><p>最开始学习插入时通常有以下两种方式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mapTest.insert(<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::value_type(<span class="number">1001</span>, <span class="number">100</span>));</span><br><span class="line">mapTest.insert(make_pair(<span class="number">1002</span>, <span class="number">98</span>));</span><br></pre></td></tr></table></figure><p>但是学了 <code>map</code> 的 <code>[]</code> 操作符以后，上述代码可以写成：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mapTest[<span class="number">1001</span>] = <span class="number">100</span>;</span><br><span class="line">mapTest[<span class="number">1002</span>] = <span class="number">98</span>;</span><br></pre></td></tr></table></figure><p>查找一个元素的时候需要用到<code>find()</code>函数，一般写成</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::const_iterator itor = mapTest.find(<span class="number">1001</span>);</span><br><span class="line"><span class="keyword">if</span> (itor != mapTest.end())</span><br><span class="line">    <span class="keyword">return</span> itor-&gt;second;</span><br></pre></td></tr></table></figure><p>但是学了 <code>map</code> 的 <code>[]</code> 操作符以后，上述代码就可以简写成：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> mapTest[<span class="number">1001</span>];</span><br></pre></td></tr></table></figure><p>特别的在插入一个元素的时候，比如用来计数，每次给一个键对应的值加1时，可以直接写成：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mapTest[<span class="number">1001</span>] += <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>根本不用检查 <code>1001</code> 这个键是否存在，使用 <code>[]</code> 操作符，在使用前会先默认成0，然后执行<code>+1</code>操作，这个比先使用<code>find()</code>查找，然后<code>+1</code>操作后再插入方便多了。</p><p>其实这只是使用<code>map</code>结构的一种语法糖，但是这语法糖简直太好使了，太甜了，让人欲罢不能，所以我就含着这块糖掉进了坑里，因为调用 <code>map</code> 的有时会产生副作用，如果查找一个键不在 <code>map</code> 中，则会在<code>map</code>中对应的这个键的位置插入默认值，接下来看一下例子就明白了。</p><h1 id="测试过程"><a href="#测试过程" class="headerlink" title="测试过程"></a>测试过程</h1><p>测试代码在VS2015中编译运行，C++11标准，如果编译不正确可以看一下环境是否不同，尝试修改代码实现即可，测试的例子也是上面提到的，使用 <code>map</code> 来存储学生学号和成绩的对应关系，下面来简单实现一个类，描述这种关系：</p><h2 id="编写测试类"><a href="#编写测试类" class="headerlink" title="编写测试类"></a>编写测试类</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CReportCard</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    CReportCard() &#123; m_mapStuNo2Score.clear(); &#125;</span><br><span class="line">    ~CReportCard() &#123; m_mapStuNo2Score.clear(); &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">LoadScores</span><span class="params">()</span></span>; <span class="comment">// 模拟录入成绩</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span>  <span class="title">GetScoreByStudentNo</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> nStudentNo)</span></span>; <span class="comment">// 根据学号查询成绩</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">PrintReportCard</span><span class="params">()</span></span>; <span class="comment">// 打印成绩单</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m_mapStuNo2Score;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> CReportCard::LoadScores()</span><br><span class="line">&#123;</span><br><span class="line">    m_mapStuNo2Score[<span class="number">1001</span>] = <span class="number">99</span>;</span><br><span class="line">    m_mapStuNo2Score[<span class="number">1002</span>] = <span class="number">94</span>;</span><br><span class="line">    m_mapStuNo2Score[<span class="number">1004</span>] = <span class="number">89</span>;</span><br><span class="line">    m_mapStuNo2Score[<span class="number">1005</span>] = <span class="number">92</span>;</span><br><span class="line">    m_mapStuNo2Score[<span class="number">1007</span>] = <span class="number">80</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> CReportCard::GetScoreByStudentNo(<span class="keyword">const</span> <span class="keyword">int</span> nStudentNo)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> m_mapStuNo2Score[nStudentNo];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> CReportCard::PrintReportCard()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"show report card start-----&gt;"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::for_each(m_mapStuNo2Score.begin(), m_mapStuNo2Score.end(), [](<span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::reference socrepair)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; socrepair.first &lt;&lt; <span class="string">"'s score = "</span> &lt;&lt; socrepair.second &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"show report card end&lt;------"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个类的内容很简单，使用 <code>map</code> 类型的对象 <code>m_mapStuNo2Score</code> 来存储学号和成绩的对应关系，<code>LoadScores()</code>函数中使用 <code>[]</code> 操作符向 <code>map</code> 中插入元素，模拟成绩录入过程；<code>GetScoreByStudentNo()</code>函数同样使用了 <code>[]</code> 操作符模拟成绩查询过程；<code>PrintReportCard()</code>函数遍历 <code>map</code> 打印成绩单信息。</p><h2 id="看似正常的调用"><a href="#看似正常的调用" class="headerlink" title="看似正常的调用"></a>看似正常的调用</h2><p>接下来编写一个函数来使用这个类，测试如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CReportCard obj;</span><br><span class="line">    obj.LoadScores();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"student no = 1001, score = "</span> &lt;&lt; obj.GetScoreByStudentNo(<span class="number">1001</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"student no = 1004, score = "</span> &lt;&lt; obj.GetScoreByStudentNo(<span class="number">1004</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    obj.PrintReportCard();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先调用 <code>LoadScores()</code>函数来加载数据，然后通过 <code>GetScoreByStudentNo()</code> 函数来查找学号为 <code>1001</code> 和 <code>1004</code> 的两个学生的成绩，最后打印一下成绩单，接下来看一下运行结果：</p><blockquote><p>student no = 1001, score = 99<br>student no = 1004, score = 89<br>show report card start—–&gt;<br>1001’s score = 99<br>1002’s score = 94<br>1004’s score = 89<br>1005’s score = 92<br>1007’s score = 80<br>show report card end&lt;——</p></blockquote><p>以上结果正常的打印出了查询的分数和成绩单，一切看起来毫无问题，如果查询的学号不存在又会怎么样呢？</p><h2 id="出现问题的调用"><a href="#出现问题的调用" class="headerlink" title="出现问题的调用"></a>出现问题的调用</h2><p>修改上面的测试函数，将学生学号改成不存在的数值，修改如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CReportCard obj;</span><br><span class="line">    obj.LoadScores();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"student no = 1011, score = "</span> &lt;&lt; obj.GetScoreByStudentNo(<span class="number">1011</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"student no = 1014, score = "</span> &lt;&lt; obj.GetScoreByStudentNo(<span class="number">1014</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    obj.PrintReportCard();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大部分的内容并没有发生变化，只将学号改成了不存在的情况，测试结果如下：</p><blockquote><p>student no = 1011, score = 0<br>student no = 1014, score = 0<br>show report card start—–&gt;<br>1001’s score = 99<br>1002’s score = 94<br>1004’s score = 89<br>1005’s score = 92<br>1007’s score = 80<br>1011’s score = 0<br>1014’s score = 0<br>show report card end&lt;——</p></blockquote><p>不存在的学号对应的分数是0，这应该也说的过去，因为键不存在，所以对 <code>map</code> 使用 <code>[]</code> 操作符查找时，寻找的键不存在则返回了整型的默认值0，但是在打印成绩单的时候居然多了两项，这充分暴露了 <code>[]</code> 操作符可能产生的副作用。</p><p>在查找返回时，<code>[]</code> 操作符并不是找不到返回对应类型默认值就完了，还会把查找的键和默认值作为一对，插入到待查的 <code>map</code>，这种操作一般是我们不需要的，所以在你明确不需要这个副作用时，查找 <code>map</code> 元素不要使用 <code>[]</code> 操作符。</p><h2 id="亡羊补牢"><a href="#亡羊补牢" class="headerlink" title="亡羊补牢"></a>亡羊补牢</h2><p>上面说到，<code>[]</code> 操作符查找不到就插入的副作用一般我们不使用，所以在查找时还是使用 <code>find()</code> 函数更规范一些，修改 <code>GetScoreByStudentNo()</code> 函数如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> CReportCard::GetScoreByStudentNo(<span class="keyword">const</span> <span class="keyword">int</span> nStudentNo)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//return m_mapStuNo2Score[nStudentNo];</span></span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::const_iterator itor = m_mapStuNo2Score.find(nStudentNo);</span><br><span class="line">    <span class="keyword">return</span> itor != m_mapStuNo2Score.end() ? itor-&gt;second : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时再运行上面的例子就正常了，成绩单中也不会插入无效值了。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol><li><code>map</code> 的 <code>[]</code> 操作符会有副作用，当查找的键不存在时，会在对应键位置插入默认值</li><li>时刻保持清醒的头脑，过分的方便或许会给你自己埋下深深的坑</li><li>敬畏自然、敬畏生命、敬畏你写下的每一行代码</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;学习C++，自从发现了map这个结构以后，就深深的被这种键值对的方式吸引了，写代码时也渐渐离不开这种结构了，一次偶然的机会发现这个map还有个 &lt;code&gt;[]&lt;/code&gt; 运算符，仿佛又发现了新大陆一样，写代码更加方便了，殊不知一个深深的大坑正在前面等着我。&lt;/p&gt;
    
    </summary>
    
      <category term="C/C++" scheme="http://AlbertGithubHome.github.io/blog/categories/C-C/"/>
    
    
      <category term="C/C++" scheme="http://AlbertGithubHome.github.io/blog/tags/C-C/"/>
    
      <category term="find" scheme="http://AlbertGithubHome.github.io/blog/tags/find/"/>
    
      <category term="中括号" scheme="http://AlbertGithubHome.github.io/blog/tags/%E4%B8%AD%E6%8B%AC%E5%8F%B7/"/>
    
      <category term="insert" scheme="http://AlbertGithubHome.github.io/blog/tags/insert/"/>
    
  </entry>
  
  <entry>
    <title>MySQL中全局变量、会话变量、用户变量和局部变量的区别</title>
    <link href="http://AlbertGithubHome.github.io/blog/2019/12/03/MySQL%E4%B8%AD%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E3%80%81%E4%BC%9A%E8%AF%9D%E5%8F%98%E9%87%8F%E3%80%81%E7%94%A8%E6%88%B7%E5%8F%98%E9%87%8F%E5%92%8C%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://AlbertGithubHome.github.io/blog/2019/12/03/MySQL中全局变量、会话变量、用户变量和局部变量的区别/</id>
    <published>2019-12-03T09:05:32.000Z</published>
    <updated>2019-12-08T04:36:30.096Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>之前在项目的存储过程中发现有通过 <code>DECLARE</code> 关键字定义的变量如<code>DECLARE cnt INT DEFAULT 0;</code>，还有形如 <code>@count</code> 这样的变量，存储过程中拿过来直接就进行设置，像这样<code>set @count=1;</code>，这两种类型的变量究竟有什么区别却弄不清楚，赶紧上网查询资料，发现还有<code>@@sql_mode</code>这样的变量，这一个圈俩圈的到底是什么啊？会不会出现三个圈的情况？</p><a id="more"></a><h1 id="变量分类与关系"><a href="#变量分类与关系" class="headerlink" title="变量分类与关系"></a>变量分类与关系</h1><p>经过一段时间学习和测试，再配合官方的文档，现在大致弄清楚了这些变量的区别，一般可以将MySQL中的变量分为全局变量、会话变量、用户变量和局部变量，这是很常见的分类方法，这些变量的作用是什么呢？可以从前往后依次看一下。</p><p>首先我们知道MySQL服务器维护了许多系统变量来控制其运行的行为，这些变量有些是默认编译到软件中的，有些是可以通过外部配置文件来配置覆盖的，如果想查询自编译的内置变量和从文件中可以读取覆盖的变量可以通过以下命令来查询:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqld --verbose --<span class="built_in">help</span></span><br></pre></td></tr></table></figure><p>如果想只看自编译的内置变量可以使用命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqld --no-defaults --verbose --<span class="built_in">help</span></span><br></pre></td></tr></table></figure><p>接下来简单了解一下这几类变量的应用范围，首先MySQL服务器启动时会使用其软件内置的变量（俗称写死在代码中的）和配置文件中的变量（如果允许，是可以覆盖源代码中的默认值的）来初始化整个MySQL服务器的运行环境，这些变量通常就是我们所说的全局变量，这些在内存中的全局变量有些是可以修改的。</p><p>当有客户端连接到MySQL服务器的时候，MySQL服务器会将这些全局变量的大部分复制一份作为这个连接客户端的会话变量，这些会话变量与客户端连接绑定，连接的客户端可以修改其中允许修改的变量，但是当连接断开时这些会话变量全部消失，重新连接时会从全局变量中重新复制一份。</p><p>其实与连接相关的变量不只有会话变量一种，用户变量也是这样的，用户变量其实就是用户自定义变量，当客户端连接上MySQL服务器之后就可以自己定义一些变量，这些变量在整个连接过程中有效，当连接断开时，这些用户变量消失。</p><p>局部变量实际上最好理解，通常由<code>DECLARE</code> 关键字来定义，经常出现在存储过程中，非常类似于C和C++函数中的局部变量，而存储过程的参数也和这种变量非常相似，基本上可以作为同一种变量来对待。</p><h1 id="变量的修改"><a href="#变量的修改" class="headerlink" title="变量的修改"></a>变量的修改</h1><p>先说全局变量有很多是可以动态调整的，也就是说可以在MySQL服务器运行期间通过 <code>SET</code> 命令修改全局变量，而不需要重新启动 MySQL 服务，但是这种方法在修改大部分变量的时候都需要超级权限，比如root账户。</p><p>相比之下会话对变量修改的要求要低的多，因为修改会话变量通常只会影响当前连接，但是有个别一些变量是例外的，修改它们也需要较高的权限，比如 <code>binlog_format</code> 和 <code>sql_log_bin</code>，因为设置这些变量的值将影响当前会话的二进制日志记录，也有可能对服务器复制和备份的完整性产生更广泛的影响。</p><p>至于用户变量和局部变量，听名字就知道，这些变量的生杀大权完全掌握在自己手中，想改就改，完全不需要理会什么权限，它的定义和使用全都由用户自己掌握。</p><h1 id="测试环境"><a href="#测试环境" class="headerlink" title="测试环境"></a>测试环境</h1><p>以下给出MySQL的版本，同时使用root用户测试，这样可以避免一些权限问题。</p><blockquote><p>Welcome to the MySQL monitor.  Commands end with ; or \g.<br>Your MySQL connection id is 7<br>Server version: 5.7.21-log MySQL Community Server (GPL)<br>Copyright (c) 2000, 2018, Oracle and/or its affiliates. All rights reserved.<br>Oracle is a registered trademark of Oracle Corporation and/or its<br>affiliates. Other names may be trademarks of their respective owners.<br>Type ‘help;’ or ‘\h’ for help. Type ‘\c’ to clear the current input statement.</p></blockquote><h1 id="变量查询与设置"><a href="#变量查询与设置" class="headerlink" title="变量查询与设置"></a>变量查询与设置</h1><h2 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h2><p>这些变量来源于软件自编译、配置文件中、以及启动参数中指定的变量，其中大部分是可以由root用户通过 <code>SET</code> 命令直接在运行时来修改的，一旦 MySQL 服务器重新启动，所有修改都被还原。如果修改了配置文件，想恢复最初的设置，只需要将配置文件还原，重新启动 MySQL 服务器，一切都可以恢复原来的样子。</p><h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><p>查询所有的全局变量：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">global</span> <span class="keyword">variables</span>;</span><br></pre></td></tr></table></figure><p>一般不会这么用，这样查简直太多了，大概有500多个，通常会加个like控制过滤条件：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show global variables like 'sql%';</span><br><span class="line">+<span class="comment">------------------------+----------------------------------------------------------------+</span></span><br><span class="line">| Variable_name          | Value                                                          |</span><br><span class="line">+<span class="comment">------------------------+----------------------------------------------------------------+</span></span><br><span class="line">| sql_auto_is_null       | OFF                                                            |</span><br><span class="line">| sql_big_selects        | ON                                                             |</span><br><span class="line">| sql_buffer_result      | OFF                                                            |</span><br><span class="line">| sql_log_off            | OFF                                                            |</span><br><span class="line">| sql_mode               | STRICT_TRANS_TABLES,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION |</span><br><span class="line">| sql_notes              | ON                                                             |</span><br><span class="line">| sql_quote_show_create  | ON                                                             |</span><br><span class="line">| sql_safe_updates       | OFF                                                            |</span><br><span class="line">| sql_select_limit       | 18446744073709551615                                           |</span><br><span class="line">| sql_slave_skip_counter | 0                                                              |</span><br><span class="line">| sql_warnings           | OFF                                                            |</span><br><span class="line">+<span class="comment">------------------------+----------------------------------------------------------------+</span></span><br><span class="line">11 rows in <span class="keyword">set</span>, <span class="number">1</span> <span class="keyword">warning</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt;</span><br></pre></td></tr></table></figure><p>还有一种查询方法就是通过select语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> @@global.sql_mode;</span><br></pre></td></tr></table></figure><p>当一个全局变量不存在会话变量副本时也可以这样</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> @@max_connections;</span><br></pre></td></tr></table></figure><h3 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h3><p>设置全局变量也有两种方式：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> sql_mode=<span class="string">''</span>;</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> @@global.sql_mode=<span class="string">''</span>;</span><br></pre></td></tr></table></figure><h2 id="会话变量"><a href="#会话变量" class="headerlink" title="会话变量"></a>会话变量</h2><p>这些变量基本来自于全局变量的复制，与客户端连接有关，无论怎样修改，当连接断开后，一切都会还原，下次连接时又是一次新的开始。</p><h3 id="查询-1"><a href="#查询-1" class="headerlink" title="查询"></a>查询</h3><p>类比全局变量，会话变量也有类似的查询方式，查询所有会话变量</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">session</span> <span class="keyword">variables</span>;</span><br></pre></td></tr></table></figure><p>添加查询匹配，只查一部分会话变量：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">session</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'sql%'</span>;</span><br></pre></td></tr></table></figure><p>查询特定的会话变量，以下三种都可以：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> @@session.sql_mode;</span><br><span class="line"><span class="keyword">select</span> @@local.sql_mode;</span><br><span class="line"><span class="keyword">select</span> @@sql_mode;</span><br></pre></td></tr></table></figure><h3 id="设置-1"><a href="#设置-1" class="headerlink" title="设置"></a>设置</h3><p>会话变量的设置方法是最多的，以下的方式都可以：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">session</span> sql_mode = <span class="string">''</span>;</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">local</span> sql_mode = <span class="string">''</span>;</span><br><span class="line"><span class="keyword">set</span> @@session.sql_mode = <span class="string">''</span>;</span><br><span class="line"><span class="keyword">set</span> @@local.sql_mode = <span class="string">''</span>;</span><br><span class="line"><span class="keyword">set</span> @@sql_mode = <span class="string">''</span>;</span><br><span class="line"><span class="keyword">set</span> sql_mode = <span class="string">''</span>;</span><br></pre></td></tr></table></figure><h2 id="用户变量"><a href="#用户变量" class="headerlink" title="用户变量"></a>用户变量</h2><p>用户变量就是用户自己定义的变量，也是在连接断开时失效，定义和使用相比会话变量来说简单许多。</p><h3 id="查询-2"><a href="#查询-2" class="headerlink" title="查询"></a>查询</h3><p>直接一个<code>select</code>语句就可以了：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> @<span class="keyword">count</span>;</span><br></pre></td></tr></table></figure><h3 id="设置-2"><a href="#设置-2" class="headerlink" title="设置"></a>设置</h3><p>设置也相对简单，可以直接使用<code>set</code>命令：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> @<span class="keyword">count</span>=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">set</span> @<span class="keyword">sum</span>:=<span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>也可以使用<code>select into</code>语句来设置值，比如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(<span class="keyword">id</span>) <span class="keyword">into</span> @<span class="keyword">count</span> <span class="keyword">from</span> items <span class="keyword">where</span> price &lt; <span class="number">99</span>;</span><br></pre></td></tr></table></figure><h2 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h2><p>局部变量通常出现在存储过程中，用于中间计算结果，交换数据等等，当存储过程执行完，变量的生命周期也就结束了。</p><h3 id="查询-3"><a href="#查询-3" class="headerlink" title="查询"></a>查询</h3><p>也是使用<code>select</code>语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">count</span> <span class="built_in">int</span>(<span class="number">4</span>);</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>;</span><br></pre></td></tr></table></figure><h3 id="设置-3"><a href="#设置-3" class="headerlink" title="设置"></a>设置</h3><p>与用户变量非常类似：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">count</span> <span class="built_in">int</span>(<span class="number">4</span>);</span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">sum</span> <span class="built_in">int</span>(<span class="number">4</span>);</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">count</span>=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">sum</span>:=<span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>也可以使用<code>select into</code>语句来设置值，比如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">count</span> <span class="built_in">int</span>(<span class="number">4</span>);</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(<span class="keyword">id</span>) <span class="keyword">into</span> <span class="keyword">count</span> <span class="keyword">from</span> items <span class="keyword">where</span> price &lt; <span class="number">99</span>;</span><br></pre></td></tr></table></figure><p>其实还有一种存储过程参数，也就是C/C++中常说的形参，使用方法与局部变量基本一致，就当成局部变量来用就可以了</p><h1 id="几种变量的对比使用"><a href="#几种变量的对比使用" class="headerlink" title="几种变量的对比使用"></a>几种变量的对比使用</h1><table><thead><tr><th style="text-align:left">操作类型</th><th style="text-align:center">全局变量</th><th style="text-align:center">会话变量</th><th style="text-align:center">用户变量</th><th style="text-align:center">局部变量（参数）</th></tr></thead><tbody><tr><td style="text-align:left">文档常用名</td><td style="text-align:center">global variables</td><td style="text-align:center">session variables</td><td style="text-align:center">user-defined variables</td><td style="text-align:center">local variables</td></tr><tr><td style="text-align:left">出现的位置</td><td style="text-align:center">命令行、函数、存储过程</td><td style="text-align:center">命令行、函数、存储过程</td><td style="text-align:center">命令行、函数、存储过程</td><td style="text-align:center">函数、存储过程</td></tr><tr><td style="text-align:left">定义的方式</td><td style="text-align:center">只能查看修改，不能定义</td><td style="text-align:center">只能查看修改，不能定义</td><td style="text-align:center">直接使用，<code>@var</code>形式</td><td style="text-align:center"><code>declare count int(4);</code></td></tr><tr><td style="text-align:left">有效生命周期</td><td style="text-align:center">服务器重启时恢复默认值</td><td style="text-align:center">断开连接时，变量消失</td><td style="text-align:center">断开连接时，变量消失</td><td style="text-align:center">出了函数或存储过程的作用域，变量无效</td></tr><tr><td style="text-align:left">查看所有变量</td><td style="text-align:center"><code>show global variables;</code></td><td style="text-align:center"><code>show session variables;</code></td><td style="text-align:center">-</td><td style="text-align:center">-</td></tr><tr><td style="text-align:left">查看部分变量</td><td style="text-align:center"><code>show global variables like &#39;sql%&#39;;</code></td><td style="text-align:center"><code>show session variables like &#39;sql%&#39;;</code></td><td style="text-align:center">-</td><td style="text-align:center">-</td></tr><tr><td style="text-align:left">查看指定变量</td><td style="text-align:center"><code>select @@global.sql_mode</code>、<br><code>select @@max_connections;</code></td><td style="text-align:center"><code>select @@session.sql_mode;</code>、 <br> <code>select @@local.sql_mode;</code>、 <br> <code>select @@sql_mode;</code></td><td style="text-align:center"><code>select @var;</code></td><td style="text-align:center"><code>select count;</code></td></tr><tr><td style="text-align:left">设置指定变量</td><td style="text-align:center"><code>set global sql_mode=&#39;&#39;;</code>、 <br> <code>set @@global.sql_mode=&#39;&#39;;</code></td><td style="text-align:center"><code>set session sql_mode = &#39;&#39;;</code>、 <br> <code>set local sql_mode = &#39;&#39;;</code>、 <br> <code>set @@session.sql_mode = &#39;&#39;;</code>、 <br> <code>set @@local.sql_mode = &#39;&#39;;</code>、 <br> <code>set @@sql_mode = &#39;&#39;;</code>、 <br> <code>set sql_mode = &#39;&#39;;</code></td><td style="text-align:center"><code>set @var=1;</code>、 <br> <code>set @var:=101;</code>、 <br> <code>select 100 into @var;</code></td><td style="text-align:center"><code>set count=1;</code>、 <br> <code>set count:=101;</code>、 <br> <code>select 100 into count;</code></td></tr></tbody></table><p>相信看了这个对比的表格，之前的很多疑惑就应该清楚了，如果发现其中有什么疑惑的地方可以给我留言，或者发现有什么错误也可以一针见血的指出来，我会尽快改正的。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol><li>MySQL 中的变量通常分为：全局变量、 会话变量、 用户变量、 局部变量</li><li>其实还有一个存储过程和函数的参数，这种类型和局部变量基本一致，当成局部变量来使用就行了</li><li>在表格中有一个容易疑惑的点就是无论是全局变量还是会话变量都有<code>select@@变量名</code>的形式。</li><li><code>select@@变量名</code>这种形式默认取的是会话变量，如果查询的会话变量不存在就会获取全局变量，比如<code>@@max_connections</code></li><li>但是<code>SET</code>操作的时候，<code>set @@变量名=xxx</code> 总是操作的会话变量，如果会话变量不存在就会报错</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;之前在项目的存储过程中发现有通过 &lt;code&gt;DECLARE&lt;/code&gt; 关键字定义的变量如&lt;code&gt;DECLARE cnt INT DEFAULT 0;&lt;/code&gt;，还有形如 &lt;code&gt;@count&lt;/code&gt; 这样的变量，存储过程中拿过来直接就进行设置，像这样&lt;code&gt;set @count=1;&lt;/code&gt;，这两种类型的变量究竟有什么区别却弄不清楚，赶紧上网查询资料，发现还有&lt;code&gt;@@sql_mode&lt;/code&gt;这样的变量，这一个圈俩圈的到底是什么啊？会不会出现三个圈的情况？&lt;/p&gt;
    
    </summary>
    
      <category term="Mysql" scheme="http://AlbertGithubHome.github.io/blog/categories/Mysql/"/>
    
    
      <category term="Mysql" scheme="http://AlbertGithubHome.github.io/blog/tags/Mysql/"/>
    
      <category term="全局变量" scheme="http://AlbertGithubHome.github.io/blog/tags/%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F/"/>
    
      <category term="会话变量" scheme="http://AlbertGithubHome.github.io/blog/tags/%E4%BC%9A%E8%AF%9D%E5%8F%98%E9%87%8F/"/>
    
      <category term="用户变量" scheme="http://AlbertGithubHome.github.io/blog/tags/%E7%94%A8%E6%88%B7%E5%8F%98%E9%87%8F/"/>
    
      <category term="局部变量" scheme="http://AlbertGithubHome.github.io/blog/tags/%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F/"/>
    
  </entry>
  
  <entry>
    <title>MySQL数据库导入、导出、复制表、重命名表</title>
    <link href="http://AlbertGithubHome.github.io/blog/2019/11/30/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AF%BC%E5%85%A5%E3%80%81%E5%AF%BC%E5%87%BA%E3%80%81%E5%A4%8D%E5%88%B6%E8%A1%A8%E3%80%81%E9%87%8D%E5%91%BD%E5%90%8D%E8%A1%A8/"/>
    <id>http://AlbertGithubHome.github.io/blog/2019/11/30/MySQL数据库导入、导出、复制表、重命名表/</id>
    <published>2019-11-30T02:28:25.000Z</published>
    <updated>2019-12-01T14:40:38.858Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>提前说明这是一篇小白总结，高手勿喷请绕行，写这篇总结的原因是发觉自己有时候确实眼高手低了，大道至简，花了很多时间去看索引、缓存、主从等等，等到出现实际问题的时候却发现自己磨磨蹭蹭写出的SQL语句居然有语法错误，看来还得稳扎稳打从基础入手，因为实际工作的用到的SQL并不多，现在把常用的几条总结一下，即使下次不能立马写出来，也能在这篇文章中的快速找到想要的。</p><a id="more"></a><p>正如标题中的提到的这些，数据库的导入和导出在紧急处理线上数据时很常用，而复制表基本上也是为了不影响原数据的情况下进行问题排查，重命名表是为了导入多份备份数据时原数据不被覆盖，比如想对比两天的A表数据，可以先把第一天的数据导入，然后将A表名修改成Aold，接着直接再导入第二天的数据库数据，这样就可以将数据库中表Aold和A进行对比了，可以避免两个数据库中的同一个表进行对比时写很长的SQL。</p><h1 id="测试环境"><a href="#测试环境" class="headerlink" title="测试环境"></a>测试环境</h1><blockquote><p>Welcome to the MySQL monitor.  Commands end with ; or \g.<br>Your MySQL connection id is 11<br>Server version: 5.7.28-log MySQL Community Server (GPL)<br>Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.<br>Oracle is a registered trademark of Oracle Corporation and/or its<br>affiliates. Other names may be trademarks of their respective owners.<br>Type ‘help;’ or ‘\h’ for help. Type ‘\c’ to clear the current input statement.</p></blockquote><h1 id="测试过程"><a href="#测试过程" class="headerlink" title="测试过程"></a>测试过程</h1><p>为了说明实现这些要求的具体SQL，我们先建立一个测试数据库，然后创建测试表格，插入测试数据，最后在这个数据库上依次实现这些要求。</p><h2 id="创建测试数据"><a href="#创建测试数据" class="headerlink" title="创建测试数据"></a>创建测试数据</h2><h3 id="创建测试数据库和表格"><a href="#创建测试数据库和表格" class="headerlink" title="创建测试数据库和表格"></a>创建测试数据库和表格</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create database dbtest;</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; use dbtest</span><br><span class="line">Database changed</span><br><span class="line"></span><br><span class="line">mysql&gt; create table a(id int, num int);</span><br><span class="line">Query OK, 0 rows affected (0.02 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; create table b(id int, name varchar(32));</span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; show tables;</span><br><span class="line">+<span class="comment">--------------+</span></span><br><span class="line">| Tables_in_zz |</span><br><span class="line">+<span class="comment">--------------+</span></span><br><span class="line">| a            |</span><br><span class="line">| b            |</span><br><span class="line">+<span class="comment">--------------+</span></span><br><span class="line">2 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><h3 id="插入测试数据"><a href="#插入测试数据" class="headerlink" title="插入测试数据"></a>插入测试数据</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; insert into a values(1, 100);</span><br><span class="line">Query OK, 1 row affected (0.02 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into a values(2, 200);</span><br><span class="line">Query OK, 1 row affected (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from a;</span><br><span class="line">+<span class="comment">------+------+</span></span><br><span class="line">| id   | num  |</span><br><span class="line">+<span class="comment">------+------+</span></span><br><span class="line">|    1 |  100 |</span><br><span class="line">|    2 |  200 |</span><br><span class="line">+<span class="comment">------+------+</span></span><br><span class="line">2 rows in <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; <span class="keyword">insert</span> <span class="keyword">into</span> b <span class="keyword">values</span>(<span class="number">1</span>, <span class="string">'albert'</span>);</span><br><span class="line">Query OK, 1 row affected (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into b values(2, 'tom');</span><br><span class="line">Query OK, 1 row affected (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from b;</span><br><span class="line">+<span class="comment">------+--------+</span></span><br><span class="line">| id   | name   |</span><br><span class="line">+<span class="comment">------+--------+</span></span><br><span class="line">|    1 | albert |</span><br><span class="line">|    2 | tom    |</span><br><span class="line">+<span class="comment">------+--------+</span></span><br><span class="line">2 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><h2 id="数据库导出"><a href="#数据库导出" class="headerlink" title="数据库导出"></a>数据库导出</h2><p>数据库导出时使用的最基础的工具叫mysqldump，这是单独的工具不是mysql命令，刚学MySQL的时候居然在MySQL的命令行中使用<code>mysqldump</code>，现在只能当笑话看了。</p><h3 id="导出指定数据库中所有表结构和数据"><a href="#导出指定数据库中所有表结构和数据" class="headerlink" title="导出指定数据库中所有表结构和数据"></a>导出指定数据库中所有表结构和数据</h3><p>在系统的命令行工具下输入以下命令，敲入回车输入密码，再回车就可以将数据库dbtest的结构和数据导出到dbtest.sql文件中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;mysqldump -uroot -h192.168.1.101 -p dbtest &gt; dbtest.sql</span><br></pre></td></tr></table></figure><p>打开dbtest.sql文件，显示如下：文件内容比较长，里面包含了数据库的表结构和其中的数据信息：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- MySQL dump 10.13  Distrib 5.7.21, for Win64 (x86_64)</span></span><br><span class="line"><span class="comment">--</span></span><br><span class="line"><span class="comment">-- Host: localhost    Database: dbtest</span></span><br><span class="line"><span class="comment">-- ------------------------------------------------------</span></span><br><span class="line"><span class="comment">-- Server version   5.7.21-log</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */</span>;</span><br><span class="line"><span class="comment">/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */</span>;</span><br><span class="line"><span class="comment">/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */</span>;</span><br><span class="line"><span class="comment">/*!40101 SET NAMES utf8 */</span>;</span><br><span class="line"><span class="comment">/*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */</span>;</span><br><span class="line"><span class="comment">/*!40103 SET TIME_ZONE='+00:00' */</span>;</span><br><span class="line"><span class="comment">/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */</span>;</span><br><span class="line"><span class="comment">/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */</span>;</span><br><span class="line"><span class="comment">/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */</span>;</span><br><span class="line"><span class="comment">/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--</span></span><br><span class="line"><span class="comment">-- Table structure for table `a`</span></span><br><span class="line"><span class="comment">--</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> <span class="string">`a`</span>;</span><br><span class="line"><span class="comment">/*!40101 SET @saved_cs_client     = @@character_set_client */</span>;</span><br><span class="line"><span class="comment">/*!40101 SET character_set_client = utf8 */</span>;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`a`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`num`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span></span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br><span class="line"><span class="comment">/*!40101 SET character_set_client = @saved_cs_client */</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--</span></span><br><span class="line"><span class="comment">-- Dumping data for table `a`</span></span><br><span class="line"><span class="comment">--</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">LOCK</span> <span class="keyword">TABLES</span> <span class="string">`a`</span> WRITE;</span><br><span class="line"><span class="comment">/*!40000 ALTER TABLE `a` DISABLE KEYS */</span>;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`a`</span> <span class="keyword">VALUES</span> (<span class="number">1</span>,<span class="number">100</span>),(<span class="number">2</span>,<span class="number">200</span>);</span><br><span class="line"><span class="comment">/*!40000 ALTER TABLE `a` ENABLE KEYS */</span>;</span><br><span class="line"><span class="keyword">UNLOCK</span> <span class="keyword">TABLES</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--</span></span><br><span class="line"><span class="comment">-- Table structure for table `b`</span></span><br><span class="line"><span class="comment">--</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> <span class="string">`b`</span>;</span><br><span class="line"><span class="comment">/*!40101 SET @saved_cs_client     = @@character_set_client */</span>;</span><br><span class="line"><span class="comment">/*!40101 SET character_set_client = utf8 */</span>;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`b`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`name`</span> <span class="built_in">varchar</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span></span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br><span class="line"><span class="comment">/*!40101 SET character_set_client = @saved_cs_client */</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--</span></span><br><span class="line"><span class="comment">-- Dumping data for table `b`</span></span><br><span class="line"><span class="comment">--</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">LOCK</span> <span class="keyword">TABLES</span> <span class="string">`b`</span> WRITE;</span><br><span class="line"><span class="comment">/*!40000 ALTER TABLE `b` DISABLE KEYS */</span>;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`b`</span> <span class="keyword">VALUES</span> (<span class="number">1</span>,<span class="string">'albert'</span>),(<span class="number">2</span>,<span class="string">'tom'</span>);</span><br><span class="line"><span class="comment">/*!40000 ALTER TABLE `b` ENABLE KEYS */</span>;</span><br><span class="line"><span class="keyword">UNLOCK</span> <span class="keyword">TABLES</span>;</span><br><span class="line"><span class="comment">/*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*!40101 SET SQL_MODE=@OLD_SQL_MODE */</span>;</span><br><span class="line"><span class="comment">/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */</span>;</span><br><span class="line"><span class="comment">/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */</span>;</span><br><span class="line"><span class="comment">/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */</span>;</span><br><span class="line"><span class="comment">/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */</span>;</span><br><span class="line"><span class="comment">/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */</span>;</span><br><span class="line"><span class="comment">/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Dump completed on 2019-11-30 11:32:23</span></span><br></pre></td></tr></table></figure><h3 id="只导出指定数据库中所有表的结构"><a href="#只导出指定数据库中所有表的结构" class="headerlink" title="只导出指定数据库中所有表的结构"></a>只导出指定数据库中所有表的结构</h3><p>只导出表结构的方法和上面是一样的，只是加上 <code>-d</code> 选项就可以了，运行下面命令就可以将dbtest数据库中的所有表结构导出到 dbteststructure.sql 中，因为和上面类似，文件中的内容就不贴了，只比 dbtest.sql 文件少了插入数据的内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;mysqldump -uroot -h192.168.1.101 -p -d dbtest &gt; dbteststructure.sql</span><br></pre></td></tr></table></figure><h3 id="只导出指定数据库中的一个表"><a href="#只导出指定数据库中的一个表" class="headerlink" title="只导出指定数据库中的一个表"></a>只导出指定数据库中的一个表</h3><p>只导出数据库中指定表，可以是一个也可以是多个，在数据库名字后面跟表的名字就可以了，比如导出表a：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;mysqldump -uroot -h192.168.1.101 -p dbtest a &gt; dbtest_a.sql</span><br></pre></td></tr></table></figure><h3 id="导出多个数据库数据"><a href="#导出多个数据库数据" class="headerlink" title="导出多个数据库数据"></a>导出多个数据库数据</h3><p>出多个数据库数据需要加上 <code>--databases</code> 选项，然后在后面依次跟上数据库名字就行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;mysqldump -uroot -h192.168.1.101 -p --databases dbtest dbtest2 &gt; db_more.sql</span><br></pre></td></tr></table></figure><h3 id="导出所有数据库数据"><a href="#导出所有数据库数据" class="headerlink" title="导出所有数据库数据"></a>导出所有数据库数据</h3><p>导出所有的数据库时不需要加数据库的名字，加上 <code>--all-databases</code> 选项就可以了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;mysqldump -uroot -h192.168.1.101 -p --all-databases &gt; db_all.sql</span><br></pre></td></tr></table></figure><h2 id="数据库导入"><a href="#数据库导入" class="headerlink" title="数据库导入"></a>数据库导入</h2><p>数据库的导入比较简单，实际上就是把sql文件在MySQL中执行一下，可以使用以下两种方式：</p><h3 id="系统命令行导入"><a href="#系统命令行导入" class="headerlink" title="系统命令行导入"></a>系统命令行导入</h3><p>一般需要指定导入的数据库dbtest和sql文件的路径，在Linux上举例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;mysql -uroot -h192.168.1.101 -p dbtest &lt; /home/albert/dbtest.sql --default-character-set=utf8</span><br></pre></td></tr></table></figure><p>在Windows上举例，主要是路径需要注意，Windows上使用正斜杠<code>/</code>和反斜杠<code>\</code>都可以，默认是反斜杠，如果路径中包含空格可以用双引号将整个路径包起来：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;mysql -uroot -h192.168.1.101 -p dbtest &lt; D:\albert\dbtest.sql --default-character-set=utf8</span><br></pre></td></tr></table></figure><p>注意<code>--default-character-set=utf8</code>是指定默认的字符集，主要是防止导入时出现编码错误，之前总结过，在此复习一下。</p><h3 id="MySQL命令行导入"><a href="#MySQL命令行导入" class="headerlink" title="MySQL命令行导入"></a>MySQL命令行导入</h3><p>首先连接MySQL服务器进行登陆：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;mysql -uroot -h192.168.1.101 -p --default-character-set=utf8</span><br></pre></td></tr></table></figure><p>输入密码登陆后再使用<code>source</code>命令直接导入sql文件就可以：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; source D:\albert\dbtest.sql</span><br></pre></td></tr></table></figure><h2 id="数据表复制"><a href="#数据表复制" class="headerlink" title="数据表复制"></a>数据表复制</h2><p>数据表的复制可以分为结构复制和完全复制，其中完全复制时可以先复制结构，再将数据复制到新表中：</p><h3 id="只复制表结构"><a href="#只复制表结构" class="headerlink" title="只复制表结构"></a>只复制表结构</h3><ul><li>使用<code>LIKE</code>语句，只不过5.0版本之后才支持，之前的版本无法使用</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> new_table <span class="keyword">LIKE</span> old_table;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from a;</span><br><span class="line">+<span class="comment">------+------+</span></span><br><span class="line">| id   | num  |</span><br><span class="line">+<span class="comment">------+------+</span></span><br><span class="line">|    1 |  100 |</span><br><span class="line">|    2 |  200 |</span><br><span class="line">+<span class="comment">------+------+</span></span><br><span class="line">2 rows in <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; <span class="keyword">create</span> <span class="keyword">table</span> a2 <span class="keyword">like</span> a;</span><br><span class="line">Query OK, 0 rows affected (0.04 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; desc a2;</span><br><span class="line">+<span class="comment">-------+---------+------+-----+---------+-------+</span></span><br><span class="line">| Field | Type    | Null | Key | Default | Extra |</span><br><span class="line">+<span class="comment">-------+---------+------+-----+---------+-------+</span></span><br><span class="line">| id    | int(11) | YES  |     | NULL    |       |</span><br><span class="line">| num   | int(11) | YES  |     | NULL    |       |</span><br><span class="line">+<span class="comment">-------+---------+------+-----+---------+-------+</span></span><br><span class="line">2 rows in <span class="keyword">set</span> (<span class="number">0.02</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; <span class="keyword">select</span> * <span class="keyword">from</span> a2;</span><br><span class="line">Empty <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><ul><li>使用 <code>SELECT</code> 语句加不成立的条件实现</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> new_table <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> old_table <span class="keyword">WHERE</span> <span class="literal">FALSE</span>;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create table a3 select * from a where false;</span><br><span class="line">Query OK, 0 rows affected (0.07 sec)</span><br><span class="line">Records: 0  Duplicates: 0  Warnings: 0</span><br><span class="line"></span><br><span class="line">mysql&gt; desc a3;</span><br><span class="line">+<span class="comment">-------+---------+------+-----+---------+-------+</span></span><br><span class="line">| Field | Type    | Null | Key | Default | Extra |</span><br><span class="line">+<span class="comment">-------+---------+------+-----+---------+-------+</span></span><br><span class="line">| id    | int(11) | YES  |     | NULL    |       |</span><br><span class="line">| num   | int(11) | YES  |     | NULL    |       |</span><br><span class="line">+<span class="comment">-------+---------+------+-----+---------+-------+</span></span><br><span class="line">2 rows in <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; <span class="keyword">select</span> * <span class="keyword">from</span> a3;</span><br><span class="line">Empty <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure><h3 id="复制表结构和数据"><a href="#复制表结构和数据" class="headerlink" title="复制表结构和数据"></a>复制表结构和数据</h3><ul><li>可以先按照上面的语句复制结构，然后再讲数据复制过去：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> new_table <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> old_table <span class="keyword">WHERE</span> <span class="literal">FALSE</span>;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> new_table <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> old_table;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; insert into a2 select * from a;</span><br><span class="line">Query OK, 2 rows affected (0.07 sec)</span><br><span class="line">Records: 2  Duplicates: 0  Warnings: 0</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from a2;</span><br><span class="line">+<span class="comment">------+------+</span></span><br><span class="line">| id   | num  |</span><br><span class="line">+<span class="comment">------+------+</span></span><br><span class="line">|    1 |  100 |</span><br><span class="line">|    2 |  200 |</span><br><span class="line">+<span class="comment">------+------+</span></span><br><span class="line">2 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><ul><li>直接将结构和数据全部复制</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> new_table <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> old_table;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create table a4 select * from a;</span><br><span class="line">Query OK, 2 rows affected (0.06 sec)</span><br><span class="line">Records: 2  Duplicates: 0  Warnings: 0</span><br><span class="line"></span><br><span class="line">mysql&gt; desc a4;</span><br><span class="line">+<span class="comment">-------+---------+------+-----+---------+-------+</span></span><br><span class="line">| Field | Type    | Null | Key | Default | Extra |</span><br><span class="line">+<span class="comment">-------+---------+------+-----+---------+-------+</span></span><br><span class="line">| id    | int(11) | YES  |     | NULL    |       |</span><br><span class="line">| num   | int(11) | YES  |     | NULL    |       |</span><br><span class="line">+<span class="comment">-------+---------+------+-----+---------+-------+</span></span><br><span class="line">2 rows in <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; <span class="keyword">select</span> * <span class="keyword">from</span> a4;</span><br><span class="line">+<span class="comment">------+------+</span></span><br><span class="line">| id   | num  |</span><br><span class="line">+<span class="comment">------+------+</span></span><br><span class="line">|    1 |  100 |</span><br><span class="line">|    2 |  200 |</span><br><span class="line">+<span class="comment">------+------+</span></span><br><span class="line">2 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><h2 id="数据表重命名"><a href="#数据表重命名" class="headerlink" title="数据表重命名"></a>数据表重命名</h2><h3 id="使用-ALTER-命令实现"><a href="#使用-ALTER-命令实现" class="headerlink" title="使用 ALTER 命令实现"></a>使用 <code>ALTER</code> 命令实现</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> old_table <span class="keyword">RENAME</span> [<span class="keyword">TO</span>|<span class="keyword">AS</span>] new_table;</span><br></pre></td></tr></table></figure><p>这个语句中的<code>TO</code>和<code>AS</code>是可选的，加不加都行，也可以选择其中一个，效果是一样的，测试如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show tables;</span><br><span class="line">+<span class="comment">------------------+</span></span><br><span class="line">| Tables_in_dbtest |</span><br><span class="line">+<span class="comment">------------------+</span></span><br><span class="line">| a                |</span><br><span class="line">| b                |</span><br><span class="line">+<span class="comment">------------------+</span></span><br><span class="line">5 rows in <span class="keyword">set</span> (<span class="number">0.02</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; <span class="keyword">alter</span> <span class="keyword">table</span> b <span class="keyword">rename</span> c;</span><br><span class="line">Query OK, 0 rows affected (0.04 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; show tables;</span><br><span class="line">+<span class="comment">------------------+</span></span><br><span class="line">| Tables_in_dbtest |</span><br><span class="line">+<span class="comment">------------------+</span></span><br><span class="line">| a                |</span><br><span class="line">| c                |</span><br><span class="line">+<span class="comment">------------------+</span></span><br><span class="line">5 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; <span class="keyword">alter</span> <span class="keyword">table</span> c <span class="keyword">rename</span> <span class="keyword">to</span> d;</span><br><span class="line">Query OK, 0 rows affected (0.02 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; show tables;</span><br><span class="line">+<span class="comment">------------------+</span></span><br><span class="line">| Tables_in_dbtest |</span><br><span class="line">+<span class="comment">------------------+</span></span><br><span class="line">| a                |</span><br><span class="line">| d                |</span><br><span class="line">+<span class="comment">------------------+</span></span><br><span class="line">5 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; <span class="keyword">alter</span> <span class="keyword">table</span> d <span class="keyword">rename</span> <span class="keyword">as</span> e;</span><br><span class="line">Query OK, 0 rows affected (0.02 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; show tables;</span><br><span class="line">+<span class="comment">------------------+</span></span><br><span class="line">| Tables_in_dbtest |</span><br><span class="line">+<span class="comment">------------------+</span></span><br><span class="line">| a                |</span><br><span class="line">| e                |</span><br><span class="line">+<span class="comment">------------------+</span></span><br><span class="line">5 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><h3 id="使用RENAME命令"><a href="#使用RENAME命令" class="headerlink" title="使用RENAME命令"></a>使用<code>RENAME</code>命令</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">RENAME</span> <span class="keyword">TABLE</span> old_table <span class="keyword">TO</span> new_table;</span><br></pre></td></tr></table></figure><p>这个语句中TO就不能省略了，否则会报语法错误，测试如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show tables</span><br><span class="line">    -&gt; ;</span><br><span class="line">+<span class="comment">------------------+</span></span><br><span class="line">| Tables_in_dbtest |</span><br><span class="line">+<span class="comment">------------------+</span></span><br><span class="line">| a                |</span><br><span class="line">| e                |</span><br><span class="line">+<span class="comment">------------------+</span></span><br><span class="line">5 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; <span class="keyword">rename</span> <span class="keyword">table</span> e <span class="keyword">to</span> f;</span><br><span class="line">Query OK, 0 rows affected (0.11 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; show tables;</span><br><span class="line">+<span class="comment">------------------+</span></span><br><span class="line">| Tables_in_dbtest |</span><br><span class="line">+<span class="comment">------------------+</span></span><br><span class="line">| a                |</span><br><span class="line">| f                |</span><br><span class="line">+<span class="comment">------------------+</span></span><br><span class="line">5 rows in <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol><li>数据库的导出、导入、数据表的复制、重命名都是MySQL操作的基础，需要熟练掌握</li><li>数据库导出：<code>mysqldump -uroot -h192.168.1.101 -p dbtest &gt; dbtest.sql</code></li><li>数据库导入：<code>mysql -uroot -h192.168.1.101 -p dbtest &lt; /tmp/dbtest.sql --default-character-set=utf8</code></li><li>数据表复制：<code>CREATE TABLE new_table SELECT * FROM old_table;</code></li><li>表格重命名：<code>RENAME TABLE old_table TO new_table;</code></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;提前说明这是一篇小白总结，高手勿喷请绕行，写这篇总结的原因是发觉自己有时候确实眼高手低了，大道至简，花了很多时间去看索引、缓存、主从等等，等到出现实际问题的时候却发现自己磨磨蹭蹭写出的SQL语句居然有语法错误，看来还得稳扎稳打从基础入手，因为实际工作的用到的SQL并不多，现在把常用的几条总结一下，即使下次不能立马写出来，也能在这篇文章中的快速找到想要的。&lt;/p&gt;
    
    </summary>
    
      <category term="Mysql" scheme="http://AlbertGithubHome.github.io/blog/categories/Mysql/"/>
    
    
      <category term="Mysql" scheme="http://AlbertGithubHome.github.io/blog/tags/Mysql/"/>
    
      <category term="导入" scheme="http://AlbertGithubHome.github.io/blog/tags/%E5%AF%BC%E5%85%A5/"/>
    
      <category term="导出" scheme="http://AlbertGithubHome.github.io/blog/tags/%E5%AF%BC%E5%87%BA/"/>
    
      <category term="复制表" scheme="http://AlbertGithubHome.github.io/blog/tags/%E5%A4%8D%E5%88%B6%E8%A1%A8/"/>
    
      <category term="重命名" scheme="http://AlbertGithubHome.github.io/blog/tags/%E9%87%8D%E5%91%BD%E5%90%8D/"/>
    
  </entry>
  
</feed>
