<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Albert World</title>
  <icon>https://www.gravatar.com/avatar/8ccc6291d5bfd34e7aaf601c4ebec7e1</icon>
  
  <link href="/blog/atom.xml" rel="self"/>
  
  <link href="http://AlbertGithubHome.github.io/blog/"/>
  <updated>2020-08-30T14:14:08.457Z</updated>
  <id>http://AlbertGithubHome.github.io/blog/</id>
  
  <author>
    <name>Albert Shi</name>
    <email>347070901@qq.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Python中时间戳、时间字符串、时间结构对象之间的相互转化</title>
    <link href="http://AlbertGithubHome.github.io/blog/2020/08/27/Python%E4%B8%AD%E6%97%B6%E9%97%B4%E6%88%B3%E3%80%81%E6%97%B6%E9%97%B4%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%81%E6%97%B6%E9%97%B4%E7%BB%93%E6%9E%84%E5%AF%B9%E8%B1%A1%E4%B9%8B%E9%97%B4%E7%9A%84%E7%9B%B8%E4%BA%92%E8%BD%AC%E5%8C%96/"/>
    <id>http://AlbertGithubHome.github.io/blog/2020/08/27/Python中时间戳、时间字符串、时间结构对象之间的相互转化/</id>
    <published>2020-08-27T15:32:21.000Z</published>
    <updated>2020-08-30T14:14:08.457Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>使用 Python 写程序的时候常常要查看中间结果，需要把一些内容记录到日志中，为了不让新产生的日志覆盖之前的日志文件，所以通常使用时间字符串来作为文件名，类似于 <code>2020827_233842.log</code> 这种格式，就是表示程序在 2020-8-27 23:38:42 启动时产生的日志文件。</p><a id="more"></a><p>日志文件名需要一个字符串，但是这个时间字符串不能直接得到，需要将时间戳经过转化才可以，每次用到都要查一次有些浪费时间，总结到一起方便自己今后快速查找。</p><p>通过学习总结发现，操作时间和日期常用的模块有 <code>time</code> 和 <code>datetime</code> 这两个，并且 <code>time</code> 模块与 C 语言中的时间处理函数颇为相似，下面来一起看一下吧。</p><h1 id="时间的表示形式"><a href="#时间的表示形式" class="headerlink" title="时间的表示形式"></a>时间的表示形式</h1><p>显示生活中的时间表示形式多种多样，比如15分钟可以说成是1刻钟，半夜12点可以叫做子时，在程序中也有几种常用的表示形式，比如 python 中的时间戳、时间结构对象和时间字符串，分别对应 <code>C</code> 语言中的<code>time_t</code>、<code>struct tm</code> 和 <code>char[]</code>，处理函数的名字也很相近，自己可以扩展学习下，本文只列举 <code>Python</code> 的用法了</p><h2 id="时间戳"><a href="#时间戳" class="headerlink" title="时间戳"></a>时间戳</h2><p>在Python中被实现成一个浮点数，表示从1970年1月1日00:00:00到当前时间所经历的秒数，因为是浮点数所以可以表示不足1秒的时间，而在有些语言中，比如<code>C</code> 语言中使用整数来表示这个值，在 python 中使用 <code>time.time()</code> 函数来获取时间戳：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">val = time.time()</span><br><span class="line">print(val, type(val))</span><br><span class="line"></span><br><span class="line"><span class="string">'''输出结果</span></span><br><span class="line"><span class="string">1598769108.8337526 &lt;class 'float'&gt;</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><h2 id="时间结构对象"><a href="#时间结构对象" class="headerlink" title="时间结构对象"></a>时间结构对象</h2><p>在 python 中使用 <code>time.struct_time</code> 这个类用来表示时间结构，其实是一个九元组，可以参考C语言中的 <code>struct tm</code>结构，表现形式相同，在 python 中这个九元组中元素依次表达的含义是：4位数年份、1-12月、1-31日、0-23小时、0-59分钟，0-59秒，0-6一周第几日，1-366一年第几日，{-1, 0, 1}夏令时标志。</p><p>通过代码我们可以尝试构造如下，不够时间使用时通常是通过函数转化，很少直接构造 <code>time.struct_time</code> 对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">val = time.struct_time([<span class="number">2020</span>, <span class="number">8</span>, <span class="number">30</span>, <span class="number">14</span>, <span class="number">45</span>, <span class="number">30</span>, <span class="number">6</span>, <span class="number">243</span>, <span class="number">0</span>])</span><br><span class="line">print(val, type(val))</span><br><span class="line"></span><br><span class="line"><span class="string">'''输出结果</span></span><br><span class="line"><span class="string">time.struct_time(tm_year=2020, tm_mon=8, tm_mday=30, tm_hour=14,</span></span><br><span class="line"><span class="string">    tm_min=45, tm_sec=30, tm_wday=6, tm_yday=243, tm_isdst=0) &lt;class 'time.struct_time'&gt;</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><h2 id="时间字符串"><a href="#时间字符串" class="headerlink" title="时间字符串"></a>时间字符串</h2><p>时间字符串是本质上是一种普通的字符串，因为用来表示时间所以感觉上有些不同，实际使用过程时会通过转化函数来生成时间字符串，然后就可以当场普通字符串来使用了，比如记录日志时间，作为文件名等都是常见用法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">val = <span class="string">'2019-08-30 15:04:00'</span></span><br><span class="line">print(val, type(val))</span><br><span class="line"></span><br><span class="line"><span class="string">'''输出结果</span></span><br><span class="line"><span class="string">2019-08-30 15:04:00 &lt;class 'str'&gt;</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><h1 id="举例说明"><a href="#举例说明" class="headerlink" title="举例说明"></a>举例说明</h1><p>仅仅认识了这三种类型还是不够的，还要学习经常使用的转化函数才可以，上面提到的这三种类型一般不会从时间戳到字符串或者从字符戳到时间戳，都是通过时间结构对象来转化的，所以常见的转化是时间戳和时间结构对象的转化、时间结构对象和时间字符串的转化，需要用到的函数展示如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/albertgithubhome/cdn/img/python_time.png" alt="python_time"></p><h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成时间戳</span></span><br><span class="line">t = time.time()</span><br><span class="line">print(t, type(t))</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">1598775821.840567 &lt;class 'float'&gt;</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成时间结构对象(本地时间)</span></span><br><span class="line">l = time.localtime()</span><br><span class="line">print(l, type(l))</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">time.struct_time(tm_year=2020, tm_mon=8, tm_mday=30, tm_hour=16, tm_min=23,</span></span><br><span class="line"><span class="string"> tm_sec=41, tm_wday=6, tm_yday=243, tm_isdst=0) &lt;class 'time.struct_time'&gt;</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 时间戳 -&gt; 时间结构对象(本地时间)</span></span><br><span class="line">l = time.localtime(t)</span><br><span class="line">print(l, type(l))</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">time.struct_time(tm_year=2020, tm_mon=8, tm_mday=30, tm_hour=16, tm_min=23,</span></span><br><span class="line"><span class="string"> tm_sec=41, tm_wday=6, tm_yday=243, tm_isdst=0) &lt;class 'time.struct_time'&gt;</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成时间结构对象(格林威治时间)</span></span><br><span class="line">g = time.gmtime()</span><br><span class="line">print(g, type(g))</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">time.struct_time(tm_year=2020, tm_mon=8, tm_mday=30, tm_hour=8, tm_min=23,</span></span><br><span class="line"><span class="string"> tm_sec=41, tm_wday=6, tm_yday=243, tm_isdst=0) &lt;class 'time.struct_time'&gt;</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 时间戳 -&gt; 时间结构对象(格林威治时间)</span></span><br><span class="line">g = time.gmtime(t)</span><br><span class="line">print(g, type(g))</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">time.struct_time(tm_year=2020, tm_mon=8, tm_mday=30, tm_hour=8, tm_min=23,</span></span><br><span class="line"><span class="string"> tm_sec=41, tm_wday=6, tm_yday=243, tm_isdst=0) &lt;class 'time.struct_time'&gt;</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成时间字符串</span></span><br><span class="line">s = time.strftime(<span class="string">"%Y-%m-%d %X"</span>)</span><br><span class="line">print(s, type(s))</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">2020-08-30 16:23:41 &lt;class 'str'&gt;</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 时间结构对象 -&gt; 时间字符串</span></span><br><span class="line">s = time.strftime(<span class="string">"%Y-%m-%d %X"</span>,time.localtime())</span><br><span class="line">print(s, type(s))</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">2020-08-30 16:23:41 &lt;class 'str'&gt;</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"><span class="string">'================================================================='</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义时间字符串</span></span><br><span class="line">s = <span class="string">'2022-02-18 09:30:00'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 时间字符串 -&gt; 时间结构对象</span></span><br><span class="line">l = time.strptime(s, <span class="string">'%Y-%m-%d %X'</span>)</span><br><span class="line">print(l, type(l))</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">time.struct_time(tm_year=2022, tm_mon=2, tm_mday=18, tm_hour=9, tm_min=30,</span></span><br><span class="line"><span class="string"> tm_sec=0, tm_wday=4, tm_yday=49, tm_isdst=-1) &lt;class 'time.struct_time'&gt;</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 时间结构对象 -&gt; 时间戳</span></span><br><span class="line">t = time.mktime(l)</span><br><span class="line">print(t, type(t))</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">1645147800.0 &lt;class 'float'&gt;</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"><span class="string">'================================================================='</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成固定格式(%a %b %d %H:%M:%S %Y)时间字符串</span></span><br><span class="line">s = time.asctime(time.localtime())</span><br><span class="line">print(s, type(s))</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">Sun Aug 30 16:23:41 2020 &lt;class 'str'&gt;</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line">s = time.ctime(time.time())</span><br><span class="line">print(s, type(s))</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">Sun Aug 30 16:23:41 2020 &lt;class 'str'&gt;</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><h2 id="格式化符号"><a href="#格式化符号" class="headerlink" title="格式化符号"></a>格式化符号</h2><p>将时间转化成字符串表示形式的时候，需要使用格式化符号，为了查找方便整理如下：</p><table><thead><tr><th><strong>格式</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>%a</td><td>本地（locale）简化星期名称</td></tr><tr><td>%A</td><td>本地完整星期名称</td></tr><tr><td>%b</td><td>本地简化月份名称</td></tr><tr><td>%B</td><td>本地完整月份名称</td></tr><tr><td>%c</td><td>本地相应的日期和时间表示</td></tr><tr><td>%d</td><td>一个月中的第几天（01 - 31）</td></tr><tr><td>%H</td><td>一天中的第几个小时（24小时制，00 - 23）</td></tr><tr><td>%I</td><td>第几个小时（12小时制，01 - 12）</td></tr><tr><td>%j</td><td>一年中的第几天（001 - 366）</td></tr><tr><td>%m</td><td>月份（01 - 12）</td></tr><tr><td>%M</td><td>分钟数（00 - 59）</td></tr><tr><td>%p</td><td>本地am或者pm的相应符</td></tr><tr><td>%S</td><td>秒（01 - 59）</td></tr><tr><td>%U</td><td>一年中的星期数。（00 - 53星期天是一个星期的开始。）</td></tr><tr><td>%w</td><td>一个星期中的第几天（0 - 6，0是星期天）</td></tr><tr><td>%W</td><td>和%U基本相同，不同的是%W以星期一为一个星期的开始。</td></tr><tr><td>%x</td><td>本地相应日期</td></tr><tr><td>%X</td><td>本地相应时间</td></tr><tr><td>%y</td><td>去掉世纪的年份（00 - 99）</td></tr><tr><td>%Y</td><td>完整的年份</td></tr><tr><td>%Z</td><td>时区的名字（如果不存在为空字符）</td></tr></tbody></table><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>时间戳和时间字符串的转化，通常要经过时间结构对象作为中间结果。</li><li>时间戳也可以通过 <code>time.ctime()</code> 函数直接转化为时间字符串，但格式固定。</li><li>常用来表示文件名的时间字符串写法：<code>time.strftime(&quot;%Y%m%d_%H%M%S&quot;, time.localtime())</code></li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/108212001" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>有时选择的意义确实高于努力的结果，认清这一点，学会适当的放下，会让焦躁的生活更美好一点，毕竟全部都坚持真的太累了，有时收益真的不高~</p><p>2020-8-30 21:50:19</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;使用 Python 写程序的时候常常要查看中间结果，需要把一些内容记录到日志中，为了不让新产生的日志覆盖之前的日志文件，所以通常使用时间字符串来作为文件名，类似于 &lt;code&gt;2020827_233842.log&lt;/code&gt; 这种格式，就是表示程序在 2020-8-27 23:38:42 启动时产生的日志文件。&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="http://AlbertGithubHome.github.io/blog/categories/Python/"/>
    
    
      <category term="Python" scheme="http://AlbertGithubHome.github.io/blog/tags/Python/"/>
    
      <category term="time" scheme="http://AlbertGithubHome.github.io/blog/tags/time/"/>
    
      <category term="datetime" scheme="http://AlbertGithubHome.github.io/blog/tags/datetime/"/>
    
      <category term="转化" scheme="http://AlbertGithubHome.github.io/blog/tags/%E8%BD%AC%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>GDB调试指北-启动调试或者附加到进程</title>
    <link href="http://AlbertGithubHome.github.io/blog/2020/08/17/GDB%E8%B0%83%E8%AF%95%E6%8C%87%E5%8C%97-%E5%90%AF%E5%8A%A8%E8%B0%83%E8%AF%95%E6%88%96%E8%80%85%E9%99%84%E5%8A%A0%E5%88%B0%E8%BF%9B%E7%A8%8B/"/>
    <id>http://AlbertGithubHome.github.io/blog/2020/08/17/GDB调试指北-启动调试或者附加到进程/</id>
    <published>2020-08-17T15:45:15.000Z</published>
    <updated>2020-08-24T16:25:47.391Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>要想使用 <code>gdb</code> 调试程序，必须让 <code>gdb</code> 程序和被调试程序建立联系，这种联系可以通过程序的可执行文件、core文件或者正在运行的进程来建立，具体调试的时候使用的选项不同，涉及到参数的传递，选项的顺序，多进程启动前的设置等等，接下来可以看一些常见用法。</p><a id="more"></a><h1 id="测试样例"><a href="#测试样例" class="headerlink" title="测试样例"></a>测试样例</h1><p>首先来写一段简单的但是会自动崩溃的代码，主要是为了展示core文件的调试方法，通过调试崩溃产生的core文件是一种很直接的查找问题的方法，可以帮助我们快速定位到问题的栈帧，进而找到具体的逻辑代码。</p><h2 id="代码内容"><a href="#代码内容" class="headerlink" title="代码内容"></a>代码内容</h2><p>新建文件 examplepro.cpp，编写代码内容如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc &gt; <span class="number">1</span>)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"argv[1] = "</span> &lt;&lt; argv[<span class="number">1</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">3</span>, b = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">int</span> c = a + b;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"c = "</span> &lt;&lt; c &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> *p = <span class="literal">NULL</span>;</span><br><span class="line">    *p = c;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="代码编译"><a href="#代码编译" class="headerlink" title="代码编译"></a>代码编译</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ examplepro.cpp -o examplepro -g</span><br></pre></td></tr></table></figure><h2 id="运行程序"><a href="#运行程序" class="headerlink" title="运行程序"></a>运行程序</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">albert@albert-virtual-machine:~/WorkSpace/cpp$ ./examplepro</span><br><span class="line">c = 7</span><br><span class="line">Segmentation fault (core dumped)</span><br></pre></td></tr></table></figure><p>我们发现程序在运行之后发生了段错误，这是一种比较常见的BUG，通常由访问无效内存导致，查看程序目录下内容，多了一个叫 <code>core</code> 的文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">albert@albert-virtual-machine:~/WorkSpace/cpp$ ls</span><br><span class="line">core  examplepro  examplepro.cpp</span><br></pre></td></tr></table></figure><p>通过这一步你可能看不到这个 <code>core</code> 文件，需要检查两点，第一是编译的时候需要加 <code>-g</code> 选项，第二是使用 <code>ulimit -c unlimited</code> 命令设置core文件占用空间的最小限制，默认大小为0，也就是不产生 <code>core</code> 文件，需要改为 <code>unlimited</code> 才可以，如果你确定产生的 <code>core</code> 文件不会太大，也可以设置一个具体的数值。</p><h1 id="使用gdb调试"><a href="#使用gdb调试" class="headerlink" title="使用gdb调试"></a>使用gdb调试</h1><p>有了上面的程序我们就可以进行调试了，因为已经产生了 core 文件，所以先来调试一下 core 文件，看下程序崩溃的原因。</p><h2 id="使用gdb调试core文件"><a href="#使用gdb调试core文件" class="headerlink" title="使用gdb调试core文件"></a>使用gdb调试core文件</h2><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gdb examplepro core</span><br></pre></td></tr></table></figure><p>具体调试的时候需要换成自己的崩溃的程序名，而core文件大多数是 <code>core.进程id</code> 的形式。</p><h3 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">albert@albert-virtual-machine:~/WorkSpace/cpp$ gdb examplepro core</span><br><span class="line">GNU gdb (Ubuntu 7.11.1-0ubuntu1~16.5) 7.11.1</span><br><span class="line">Copyright (C) 2016 Free Software Foundation, Inc.</span><br><span class="line">License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;</span><br><span class="line">This is free software: you are free to change and redistribute it.</span><br><span class="line">There is NO WARRANTY, to the extent permitted by law.  Type <span class="string">"show copying"</span></span><br><span class="line">and <span class="string">"show warranty"</span> <span class="keyword">for</span> details.</span><br><span class="line">This GDB was configured as <span class="string">"x86_64-linux-gnu"</span>.</span><br><span class="line">Type <span class="string">"show configuration"</span> <span class="keyword">for</span> configuration details.</span><br><span class="line">For bug reporting instructions, please see:</span><br><span class="line">&lt;http://www.gnu.org/software/gdb/bugs/&gt;.</span><br><span class="line">Find the GDB manual and other documentation resources online at:</span><br><span class="line">&lt;http://www.gnu.org/software/gdb/documentation/&gt;.</span><br><span class="line">For <span class="built_in">help</span>, <span class="built_in">type</span> <span class="string">"help"</span>.</span><br><span class="line">Type <span class="string">"apropos word"</span> to search <span class="keyword">for</span> commands related to <span class="string">"word"</span>...</span><br><span class="line">Reading symbols from examplepro...done.</span><br><span class="line">[New LWP 19786]</span><br><span class="line">Core was generated by `./examplepro<span class="string">'.</span></span><br><span class="line"><span class="string">Program terminated with signal SIGSEGV, Segmentation fault.</span></span><br><span class="line"><span class="string">#0  0x0000000000400932 in main (argc=1, argv=0x7ffd23cc3a18) at examplepro.cpp:15</span></span><br><span class="line"><span class="string">15      *p = c;</span></span><br><span class="line"><span class="string">(gdb)</span></span><br></pre></td></tr></table></figure><p>从调试信息来看一下就定位到了问题，在代码的第15行发生了段错误，也就是我们刚刚给野指针赋值的代码。</p><h2 id="使用gdb直接启动程序"><a href="#使用gdb直接启动程序" class="headerlink" title="使用gdb直接启动程序"></a>使用gdb直接启动程序</h2><h3 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gdb examplepro</span><br></pre></td></tr></table></figure><h3 id="调试-1"><a href="#调试-1" class="headerlink" title="调试"></a>调试</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">albert@albert-virtual-machine:~/WorkSpace/cpp$ gdb examplepro</span><br><span class="line">GNU gdb (Ubuntu 7.11.1-0ubuntu1~16.5) 7.11.1</span><br><span class="line">Copyright (C) 2016 Free Software Foundation, Inc.</span><br><span class="line">License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;</span><br><span class="line">This is free software: you are free to change and redistribute it.</span><br><span class="line">There is NO WARRANTY, to the extent permitted by law.  Type <span class="string">"show copying"</span></span><br><span class="line">and <span class="string">"show warranty"</span> <span class="keyword">for</span> details.</span><br><span class="line">This GDB was configured as <span class="string">"x86_64-linux-gnu"</span>.</span><br><span class="line">Type <span class="string">"show configuration"</span> <span class="keyword">for</span> configuration details.</span><br><span class="line">For bug reporting instructions, please see:</span><br><span class="line">&lt;http://www.gnu.org/software/gdb/bugs/&gt;.</span><br><span class="line">Find the GDB manual and other documentation resources online at:</span><br><span class="line">&lt;http://www.gnu.org/software/gdb/documentation/&gt;.</span><br><span class="line">For <span class="built_in">help</span>, <span class="built_in">type</span> <span class="string">"help"</span>.</span><br><span class="line">Type <span class="string">"apropos word"</span> to search <span class="keyword">for</span> commands related to <span class="string">"word"</span>...</span><br><span class="line">Reading symbols from examplepro...done.</span><br><span class="line">(gdb) run</span><br><span class="line">Starting program: /home/albert/WorkSpace/cpp/examplepro</span><br><span class="line">c = 7</span><br><span class="line"></span><br><span class="line">Program received signal SIGSEGV, Segmentation fault.</span><br><span class="line">0x0000000000400932 <span class="keyword">in</span> main (argc=1, argv=0x7fffffffdd18) at examplepro.cpp:15</span><br><span class="line">15      *p = c;</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure><p>这种情况下直接启动就可以了，启动之后输入 <code>run</code> 命令就可以运行程序，这时发现程序又崩溃了。</p><p>如果被调试的程序有参数的话，修改将启动的命令进行修改，写成 <code>gdb --args examplepro testparam1</code>，加上 <code>--args</code> 选项，然后将参数罗列在后面就好了，因为看这些声明很麻烦，我们利用之前学过的 <code>-q</code> 选项来屏蔽启动说明，测试如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">albert@albert-virtual-machine:~/WorkSpace/cpp$ gdb -q --args examplepro NB</span><br><span class="line">Reading symbols from examplepro...done.</span><br><span class="line">(gdb) run</span><br><span class="line">Starting program: /home/albert/WorkSpace/cpp/examplepro NB</span><br><span class="line">argv[1] = NB</span><br><span class="line">c = 7</span><br><span class="line"></span><br><span class="line">Program received signal SIGSEGV, Segmentation fault.</span><br><span class="line">0x0000000000400932 <span class="keyword">in</span> main (argc=2, argv=0x7fffffffdd08) at examplepro.cpp:15</span><br><span class="line">15      *p = c;</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure><p>还有一种写法就是启动 gdb 之后再传参数，具体操作方法如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">albert@albert-virtual-machine:~/WorkSpace/cpp$ gdb -q examplepro</span><br><span class="line">Reading symbols from examplepro...done.</span><br><span class="line">(gdb) run NB</span><br><span class="line">Starting program: /home/albert/WorkSpace/cpp/examplepro NB</span><br><span class="line">argv[1] = NB</span><br><span class="line">c = 7</span><br><span class="line"></span><br><span class="line">Program received signal SIGSEGV, Segmentation fault.</span><br><span class="line">0x0000000000400932 <span class="keyword">in</span> main (argc=2, argv=0x7fffffffdd08) at examplepro.cpp:15</span><br><span class="line">15      *p = c;</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure><p>这种情况是先启动 gdb，然后在执行 <code>run</code> 命令的时候传递参数。</p><h2 id="使用gdb调试正在运行的文件"><a href="#使用gdb调试正在运行的文件" class="headerlink" title="使用gdb调试正在运行的文件"></a>使用gdb调试正在运行的文件</h2><p>这时需要获得被套是程序的进程id，可以使用 <code>ps</code>、<code>top</code> 或者 <code>pidof</code> 命令来获取进程id，然后通过 <code>attch</code> 的方式附加到进程。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>gdb 不但可以调试 core 文件，还可以调试正在运行的程序，这对于难重现的Bug来说非常有帮助</li><li>在调试正在运行的程序时可以使用 <code>pidof</code> 命令来直接获取被调试程序的进程。</li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/108030540" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>兜兜转转又换了一个住所，匆匆忙忙如蝼蚁般迁徙，一个窝、一段事、一群人而已~</p><p>2020-8-25 00:24:01</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;要想使用 &lt;code&gt;gdb&lt;/code&gt; 调试程序，必须让 &lt;code&gt;gdb&lt;/code&gt; 程序和被调试程序建立联系，这种联系可以通过程序的可执行文件、core文件或者正在运行的进程来建立，具体调试的时候使用的选项不同，涉及到参数的传递，选项的顺序，多进程启动前的设置等等，接下来可以看一些常见用法。&lt;/p&gt;
    
    </summary>
    
      <category term="GDB" scheme="http://AlbertGithubHome.github.io/blog/categories/GDB/"/>
    
    
      <category term="GDB" scheme="http://AlbertGithubHome.github.io/blog/tags/GDB/"/>
    
      <category term="manual" scheme="http://AlbertGithubHome.github.io/blog/tags/manual/"/>
    
      <category term="调试" scheme="http://AlbertGithubHome.github.io/blog/tags/%E8%B0%83%E8%AF%95/"/>
    
      <category term="启动" scheme="http://AlbertGithubHome.github.io/blog/tags/%E5%90%AF%E5%8A%A8/"/>
    
  </entry>
  
  <entry>
    <title>Redis源码-BFS方式浏览main函数</title>
    <link href="http://AlbertGithubHome.github.io/blog/2020/08/05/Redis%E6%BA%90%E7%A0%81-BFS%E6%96%B9%E5%BC%8F%E6%B5%8F%E8%A7%88main%E5%87%BD%E6%95%B0/"/>
    <id>http://AlbertGithubHome.github.io/blog/2020/08/05/Redis源码-BFS方式浏览main函数/</id>
    <published>2020-08-05T15:35:19.000Z</published>
    <updated>2020-08-15T16:06:34.730Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>欠下的技术债慢慢还，继续为去年吹过的牛而努力。去年年末的时候意识到自己掌握的知识还不够深入，决定开始看一些开源项目的源码，因为当时 <code>Redis</code> 的兴起，所以瞄准了准备从它下手，之后确实看了一部分内容，比如跳表、网络事件库等等，后来过年就鸽了。今年开始一直熟悉新的业务，比较懒没跟进，最近间歇性踌躇满志又发作了，准备抽时间再捋顺一遍，老规矩，还是从 <code>main()</code> 函数下手。</p><a id="more"></a><p>对于 <code>C/C++</code> 程序一定是从 <code>main()</code> 函数开头的，这是我们切入的一个点，至于怎么找到 <code>main</code> 函数，每个人有不同的方法，最暴力的方法当然就是全文搜索了，不过较为成熟的项目一般搜索出来都不止一个 <code>main</code> 函数，因为整个项目完整构建下来不止一个程序。</p><p>像 <code>redis</code> 这个项目最起码有服务器和客户端两个程序，源码中至少包含了两个 <code>main</code> 函数，再加上一些测试程序，<code>main</code> 函数在源码中会有很多。再比如 <code>Lua</code> 的源代码中包含和解释器和编译器，如果直接搜索至少会找到两个 <code>main</code> 函数。</p><p><code>redis</code> 服务器程序的 <code>main</code> 函数在文件 <code>src/server.c</code> 中，之前好像是在 <code>redis.c</code> 文件中后来改名了，这都不重要，反正你需要从搜索出来的 <code>main</code> 函数中找到一个开始的地方，这个花不了多少时间。</p><h1 id="看代码的方式"><a href="#看代码的方式" class="headerlink" title="看代码的方式"></a>看代码的方式</h1><p>标题中提到了 <code>BFS</code> 方式看代码，而 <code>BFS</code> 指的是广度优先搜索，与之相对应的是 <code>DFS</code> 深度优先搜索，对于不含异步调用的单线程程序来说，执行代码是以深度优先搜索的方式，遇到一个函数就调用进去，在函数中又遇到另一个函数再调用进去，当函数执行完成返回到上一层。</p><p>为什么选择 <code>BFS</code> 方式看代码呢？因为这样可以在短时间内更全面的了解代码结构，我们先看第一层，当第一层浏览完成之后再进入到第二层，比如我们先看 <code>main</code> 函数，即使 <code>main</code> 函数调用了很多不认识的函数也不要去管，从名字大概判断一些作用就可以了，不用纠结具体的实现内容，当 <code>main</code> 函数全部看完了再进入到第二层去了解它调用的那些函数。</p><p>总之使用 <code>BFS</code> 方式看代码就要有一种“不懂装懂”的态度，不然容易陷入细节，无法整体把握。</p><h1 id="Redis-服务器的-main-函数"><a href="#Redis-服务器的-main-函数" class="headerlink" title="Redis 服务器的 main 函数"></a>Redis 服务器的 main 函数</h1><p><code>redis</code> 服务器的 <code>main</code> 函数代码量不是很大，总共 200 行左右，我选择了 <code>6.0.6</code> 这个版本 <code>7bf665f125a4771db095c83a7ad6ed46692cd314</code>，因为只是学习源码，没有特殊情况就不更新版本了，保证环境的统一，我先把代码贴一份在这，后面再来慢慢看。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>;</span></span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> REDIS_TEST</span></span><br><span class="line">    <span class="keyword">if</span> (argc == <span class="number">3</span> &amp;&amp; !strcasecmp(argv[<span class="number">1</span>], <span class="string">"test"</span>)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!strcasecmp(argv[<span class="number">2</span>], <span class="string">"ziplist"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> ziplistTest(argc, argv);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(argv[<span class="number">2</span>], <span class="string">"quicklist"</span>)) &#123;</span><br><span class="line">            quicklistTest(argc, argv);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(argv[<span class="number">2</span>], <span class="string">"intset"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> intsetTest(argc, argv);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(argv[<span class="number">2</span>], <span class="string">"zipmap"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> zipmapTest(argc, argv);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(argv[<span class="number">2</span>], <span class="string">"sha1test"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> sha1Test(argc, argv);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(argv[<span class="number">2</span>], <span class="string">"util"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> utilTest(argc, argv);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(argv[<span class="number">2</span>], <span class="string">"endianconv"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> endianconvTest(argc, argv);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(argv[<span class="number">2</span>], <span class="string">"crc64"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> crc64Test(argc, argv);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(argv[<span class="number">2</span>], <span class="string">"zmalloc"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> zmalloc_test(argc, argv);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">/* test not found */</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* We need to initialize our libraries, and the server configuration. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> INIT_SETPROCTITLE_REPLACEMENT</span></span><br><span class="line">    spt_init(argc, argv);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    setlocale(LC_COLLATE,<span class="string">""</span>);</span><br><span class="line">    tzset(); <span class="comment">/* Populates 'timezone' global. */</span></span><br><span class="line">    zmalloc_set_oom_handler(redisOutOfMemoryHandler);</span><br><span class="line">    srand(time(<span class="literal">NULL</span>)^getpid());</span><br><span class="line">    gettimeofday(&amp;tv,<span class="literal">NULL</span>);</span><br><span class="line">    crc64_init();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint8_t</span> hashseed[<span class="number">16</span>];</span><br><span class="line">    getRandomBytes(hashseed,<span class="keyword">sizeof</span>(hashseed));</span><br><span class="line">    dictSetHashFunctionSeed(hashseed);</span><br><span class="line">    server.sentinel_mode = checkForSentinelMode(argc,argv);</span><br><span class="line">    initServerConfig();</span><br><span class="line">    ACLInit(); <span class="comment">/* The ACL subsystem must be initialized ASAP because the</span></span><br><span class="line"><span class="comment">                  basic networking code and client creation depends on it. */</span></span><br><span class="line">    moduleInitModulesSystem();</span><br><span class="line">    tlsInit();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Store the executable path and arguments in a safe place in order</span></span><br><span class="line"><span class="comment">     * to be able to restart the server later. */</span></span><br><span class="line">    server.executable = getAbsolutePath(argv[<span class="number">0</span>]);</span><br><span class="line">    server.exec_argv = zmalloc(<span class="keyword">sizeof</span>(<span class="keyword">char</span>*)*(argc+<span class="number">1</span>));</span><br><span class="line">    server.exec_argv[argc] = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; argc; j++) server.exec_argv[j] = zstrdup(argv[j]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* We need to init sentinel right now as parsing the configuration file</span></span><br><span class="line"><span class="comment">     * in sentinel mode will have the effect of populating the sentinel</span></span><br><span class="line"><span class="comment">     * data structures with master nodes to monitor. */</span></span><br><span class="line">    <span class="keyword">if</span> (server.sentinel_mode) &#123;</span><br><span class="line">        initSentinelConfig();</span><br><span class="line">        initSentinel();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check if we need to start in redis-check-rdb/aof mode. We just execute</span></span><br><span class="line"><span class="comment">     * the program main. However the program is part of the Redis executable</span></span><br><span class="line"><span class="comment">     * so that we can easily execute an RDB check on loading errors. */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strstr</span>(argv[<span class="number">0</span>],<span class="string">"redis-check-rdb"</span>) != <span class="literal">NULL</span>)</span><br><span class="line">        redis_check_rdb_main(argc,argv,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strstr</span>(argv[<span class="number">0</span>],<span class="string">"redis-check-aof"</span>) != <span class="literal">NULL</span>)</span><br><span class="line">        redis_check_aof_main(argc,argv);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">        j = <span class="number">1</span>; <span class="comment">/* First option to parse in argv[] */</span></span><br><span class="line">        sds options = sdsempty();</span><br><span class="line">        <span class="keyword">char</span> *configfile = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Handle special options --help and --version */</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">"-v"</span>) == <span class="number">0</span> ||</span><br><span class="line">            <span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">"--version"</span>) == <span class="number">0</span>) version();</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">"--help"</span>) == <span class="number">0</span> ||</span><br><span class="line">            <span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">"-h"</span>) == <span class="number">0</span>) usage();</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">"--test-memory"</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (argc == <span class="number">3</span>) &#123;</span><br><span class="line">                memtest(atoi(argv[<span class="number">2</span>]),<span class="number">50</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"Please specify the amount of memory to test in megabytes.\n"</span>);</span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"Example: ./redis-server --test-memory 4096\n\n"</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* First argument is the config file name? */</span></span><br><span class="line">        <span class="keyword">if</span> (argv[j][<span class="number">0</span>] != <span class="string">'-'</span> || argv[j][<span class="number">1</span>] != <span class="string">'-'</span>) &#123;</span><br><span class="line">            configfile = argv[j];</span><br><span class="line">            server.configfile = getAbsolutePath(configfile);</span><br><span class="line">            <span class="comment">/* Replace the config file in server.exec_argv with</span></span><br><span class="line"><span class="comment">             * its absolute path. */</span></span><br><span class="line">            zfree(server.exec_argv[j]);</span><br><span class="line">            server.exec_argv[j] = zstrdup(server.configfile);</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* All the other options are parsed and conceptually appended to the</span></span><br><span class="line"><span class="comment">         * configuration file. For instance --port 6380 will generate the</span></span><br><span class="line"><span class="comment">         * string "port 6380\n" to be parsed after the actual file name</span></span><br><span class="line"><span class="comment">         * is parsed, if any. */</span></span><br><span class="line">        <span class="keyword">while</span>(j != argc) &#123;</span><br><span class="line">            <span class="keyword">if</span> (argv[j][<span class="number">0</span>] == <span class="string">'-'</span> &amp;&amp; argv[j][<span class="number">1</span>] == <span class="string">'-'</span>) &#123;</span><br><span class="line">                <span class="comment">/* Option name */</span></span><br><span class="line">                <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[j], <span class="string">"--check-rdb"</span>)) &#123;</span><br><span class="line">                    <span class="comment">/* Argument has no options, need to skip for parsing. */</span></span><br><span class="line">                    j++;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (sdslen(options)) options = sdscat(options,<span class="string">"\n"</span>);</span><br><span class="line">                options = sdscat(options,argv[j]+<span class="number">2</span>);</span><br><span class="line">                options = sdscat(options,<span class="string">" "</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">/* Option argument */</span></span><br><span class="line">                options = sdscatrepr(options,argv[j],<span class="built_in">strlen</span>(argv[j]));</span><br><span class="line">                options = sdscat(options,<span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (server.sentinel_mode &amp;&amp; configfile &amp;&amp; *configfile == <span class="string">'-'</span>) &#123;</span><br><span class="line">            serverLog(LL_WARNING,</span><br><span class="line">                <span class="string">"Sentinel config from STDIN not allowed."</span>);</span><br><span class="line">            serverLog(LL_WARNING,</span><br><span class="line">                <span class="string">"Sentinel needs config file on disk to save state.  Exiting..."</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        resetServerSaveParams();</span><br><span class="line">        loadServerConfig(configfile,options);</span><br><span class="line">        sdsfree(options);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    serverLog(LL_WARNING, <span class="string">"oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo"</span>);</span><br><span class="line">    serverLog(LL_WARNING,</span><br><span class="line">        <span class="string">"Redis version=%s, bits=%d, commit=%s, modified=%d, pid=%d, just started"</span>,</span><br><span class="line">            REDIS_VERSION,</span><br><span class="line">            (<span class="keyword">sizeof</span>(<span class="keyword">long</span>) == <span class="number">8</span>) ? <span class="number">64</span> : <span class="number">32</span>,</span><br><span class="line">            redisGitSHA1(),</span><br><span class="line">            strtol(redisGitDirty(),<span class="literal">NULL</span>,<span class="number">10</span>) &gt; <span class="number">0</span>,</span><br><span class="line">            (<span class="keyword">int</span>)getpid());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc == <span class="number">1</span>) &#123;</span><br><span class="line">        serverLog(LL_WARNING, <span class="string">"Warning: no config file specified, using the default config. In order to specify a config file use %s /path/to/%s.conf"</span>, argv[<span class="number">0</span>], server.sentinel_mode ? <span class="string">"sentinel"</span> : <span class="string">"redis"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        serverLog(LL_WARNING, <span class="string">"Configuration loaded"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    server.supervised = redisIsSupervised(server.supervised_mode);</span><br><span class="line">    <span class="keyword">int</span> background = server.daemonize &amp;&amp; !server.supervised;</span><br><span class="line">    <span class="keyword">if</span> (background) daemonize();</span><br><span class="line"></span><br><span class="line">    initServer();</span><br><span class="line">    <span class="keyword">if</span> (background || server.pidfile) createPidFile();</span><br><span class="line">    redisSetProcTitle(argv[<span class="number">0</span>]);</span><br><span class="line">    redisAsciiArt();</span><br><span class="line">    checkTcpBacklogSettings();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!server.sentinel_mode) &#123;</span><br><span class="line">        <span class="comment">/* Things not needed when running in Sentinel mode. */</span></span><br><span class="line">        serverLog(LL_WARNING,<span class="string">"Server initialized"</span>);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> __linux__</span></span><br><span class="line">        linuxMemoryWarnings();</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        moduleLoadFromQueue();</span><br><span class="line">        ACLLoadUsersAtStartup();</span><br><span class="line">        InitServerLast();</span><br><span class="line">        loadDataFromDisk();</span><br><span class="line">        <span class="keyword">if</span> (server.cluster_enabled) &#123;</span><br><span class="line">            <span class="keyword">if</span> (verifyClusterConfigWithData() == C_ERR) &#123;</span><br><span class="line">                serverLog(LL_WARNING,</span><br><span class="line">                    <span class="string">"You can't have keys in a DB different than DB 0 when in "</span></span><br><span class="line">                    <span class="string">"Cluster mode. Exiting."</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (server.ipfd_count &gt; <span class="number">0</span> || server.tlsfd_count &gt; <span class="number">0</span>)</span><br><span class="line">            serverLog(LL_NOTICE,<span class="string">"Ready to accept connections"</span>);</span><br><span class="line">        <span class="keyword">if</span> (server.sofd &gt; <span class="number">0</span>)</span><br><span class="line">            serverLog(LL_NOTICE,<span class="string">"The server is now ready to accept connections at %s"</span>, server.unixsocket);</span><br><span class="line">        <span class="keyword">if</span> (server.supervised_mode == SUPERVISED_SYSTEMD) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!server.masterhost) &#123;</span><br><span class="line">                redisCommunicateSystemd(<span class="string">"STATUS=Ready to accept connections\n"</span>);</span><br><span class="line">                redisCommunicateSystemd(<span class="string">"READY=1\n"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                redisCommunicateSystemd(<span class="string">"STATUS=Waiting for MASTER &lt;-&gt; REPLICA sync\n"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        InitServerLast();</span><br><span class="line">        sentinelIsRunning();</span><br><span class="line">        <span class="keyword">if</span> (server.supervised_mode == SUPERVISED_SYSTEMD) &#123;</span><br><span class="line">            redisCommunicateSystemd(<span class="string">"STATUS=Ready to accept connections\n"</span>);</span><br><span class="line">            redisCommunicateSystemd(<span class="string">"READY=1\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Warning the user about suspicious maxmemory setting. */</span></span><br><span class="line">    <span class="keyword">if</span> (server.maxmemory &gt; <span class="number">0</span> &amp;&amp; server.maxmemory &lt; <span class="number">1024</span>*<span class="number">1024</span>) &#123;</span><br><span class="line">        serverLog(LL_WARNING,<span class="string">"WARNING: You specified a maxmemory value that is less than 1MB (current value is %llu bytes). Are you sure this is what you really want?"</span>, server.maxmemory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    redisSetCpuAffinity(server.server_cpulist);</span><br><span class="line">    aeMain(server.el);</span><br><span class="line">    aeDeleteEventLoop(server.el);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="main-函数分段解释"><a href="#main-函数分段解释" class="headerlink" title="main 函数分段解释"></a>main 函数分段解释</h1><h2 id="函数名及参数"><a href="#函数名及参数" class="headerlink" title="函数名及参数"></a>函数名及参数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>;</span></span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就是一个标准的 <code>main</code> 函数，参数 <code>argc</code> 和 <code>argv</code> 对于一个命令行程序来说可以是重头戏，肯定会拿来做重度解析的，函数开头还定义了 <code>tv</code> 和 <code>j</code> 两个变量，不知道干嘛的，接着往下看吧。</p><h2 id="启动测试程序"><a href="#启动测试程序" class="headerlink" title="启动测试程序"></a>启动测试程序</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> REDIS_TEST</span></span><br><span class="line">    <span class="keyword">if</span> (argc == <span class="number">3</span> &amp;&amp; !strcasecmp(argv[<span class="number">1</span>], <span class="string">"test"</span>)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!strcasecmp(argv[<span class="number">2</span>], <span class="string">"ziplist"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> ziplistTest(argc, argv);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(argv[<span class="number">2</span>], <span class="string">"quicklist"</span>)) &#123;</span><br><span class="line">            quicklistTest(argc, argv);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(argv[<span class="number">2</span>], <span class="string">"intset"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> intsetTest(argc, argv);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(argv[<span class="number">2</span>], <span class="string">"zipmap"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> zipmapTest(argc, argv);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(argv[<span class="number">2</span>], <span class="string">"sha1test"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> sha1Test(argc, argv);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(argv[<span class="number">2</span>], <span class="string">"util"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> utilTest(argc, argv);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(argv[<span class="number">2</span>], <span class="string">"endianconv"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> endianconvTest(argc, argv);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(argv[<span class="number">2</span>], <span class="string">"crc64"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> crc64Test(argc, argv);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(argv[<span class="number">2</span>], <span class="string">"zmalloc"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> zmalloc_test(argc, argv);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">/* test not found */</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>当宏定义 <code>REDIS_TEST</code> 存在，并且参数合适的情况下启动测试程序，<code>argv[0]</code> 肯定是指 <code>redis</code> 服务器喽，那 <code>argv[1]</code> 的值如果是 <code>test</code>，而 <code>argv[2]</code> 的值是 <code>ziplist</code>，那么会调用 <code>ziplist</code> 的测试函数 <code>ziplistTest</code>，如果 <code>argv[2]</code> 的值是 <code>zmalloc</code>，那么会调用测试函数 <code>zmalloc_test</code>，为啥这里函数名命名规范不统一呢？挠头。</p><h2 id="程序环境初始化"><a href="#程序环境初始化" class="headerlink" title="程序环境初始化"></a>程序环境初始化</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/* We need to initialize our libraries, and the server configuration. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> INIT_SETPROCTITLE_REPLACEMENT</span></span><br><span class="line">    spt_init(argc, argv);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    setlocale(LC_COLLATE,<span class="string">""</span>);</span><br><span class="line">    tzset(); <span class="comment">/* Populates 'timezone' global. */</span></span><br><span class="line">    zmalloc_set_oom_handler(redisOutOfMemoryHandler);</span><br><span class="line">    srand(time(<span class="literal">NULL</span>)^getpid());</span><br><span class="line">    gettimeofday(&amp;tv,<span class="literal">NULL</span>);</span><br><span class="line">    crc64_init();</span><br></pre></td></tr></table></figure><ol><li>当 <code>INIT_SETPROCTITLE_REPLACEMENT</code> 这个宏存在的时候，调用 <code>spt_init</code> 函数来为设置程序标题做准备</li><li><code>setlocale()</code> 用来设置地点信息，这一句应该是设置成依赖操作系统的地点信息，比如中国，韩国等等</li><li><code>tzset()</code> 设置时区，这里可能影响到程序运行后，调整时区是否对程序产生影响</li><li><code>srand(time(NULL)^getpid());</code> 初始化随机种子</li><li><code>gettimeofday(&amp;tv,NULL);</code> 这里用到了函数开头定义的一个变量 <code>tv</code>，用来获取当前时间</li><li><code>crc64_init();</code> 循环冗余校验初始化，<code>crc</code> 神奇的存在</li></ol><h2 id="初始化配置信息"><a href="#初始化配置信息" class="headerlink" title="初始化配置信息"></a>初始化配置信息</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uint8_t</span> hashseed[<span class="number">16</span>];</span><br><span class="line">getRandomBytes(hashseed,<span class="keyword">sizeof</span>(hashseed));</span><br><span class="line">dictSetHashFunctionSeed(hashseed);</span><br><span class="line">server.sentinel_mode = checkForSentinelMode(argc,argv);</span><br><span class="line">initServerConfig();</span><br><span class="line">ACLInit(); <span class="comment">/* The ACL subsystem must be initialized ASAP because the</span></span><br><span class="line"><span class="comment">              basic networking code and client creation depends on it. */</span></span><br><span class="line">moduleInitModulesSystem();</span><br><span class="line">tlsInit();</span><br></pre></td></tr></table></figure><ol><li>定一个16字节的空间用来存放哈希种子</li><li>随机获取一段16字节数据作为种子</li><li>将刚刚获取的种子数据设置到hash函数中</li><li>分析命令行参数，判断是否是哨兵模式</li><li>初始化服务器配置</li><li><code>ACL</code> 初始化，不用管它具体是什么，进入下一层时自然会看到</li><li>初始化模块系统</li><li><code>tls</code> 初始化，存疑，好奇的话进去看看也可以，好吧，原来是 <code>ssl</code> 那一套，够喝一壶的</li></ol><h2 id="存储参数信息"><a href="#存储参数信息" class="headerlink" title="存储参数信息"></a>存储参数信息</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Store the executable path and arguments in a safe place in order</span></span><br><span class="line"><span class="comment"> * to be able to restart the server later. */</span></span><br><span class="line">server.executable = getAbsolutePath(argv[<span class="number">0</span>]);</span><br><span class="line">server.exec_argv = zmalloc(<span class="keyword">sizeof</span>(<span class="keyword">char</span>*)*(argc+<span class="number">1</span>));</span><br><span class="line">server.exec_argv[argc] = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; argc; j++) server.exec_argv[j] = zstrdup(argv[j]);</span><br></pre></td></tr></table></figure><p>这一小节比较简单，注释写的也很清楚，就是将命令行参数存储起来，方便重启 <code>redis</code> 服务</p><h2 id="根据参数确定启动方式"><a href="#根据参数确定启动方式" class="headerlink" title="根据参数确定启动方式"></a>根据参数确定启动方式</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* We need to init sentinel right now as parsing the configuration file</span></span><br><span class="line"><span class="comment"> * in sentinel mode will have the effect of populating the sentinel</span></span><br><span class="line"><span class="comment"> * data structures with master nodes to monitor. */</span></span><br><span class="line"><span class="keyword">if</span> (server.sentinel_mode) &#123;</span><br><span class="line">    initSentinelConfig();</span><br><span class="line">    initSentinel();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Check if we need to start in redis-check-rdb/aof mode. We just execute</span></span><br><span class="line"><span class="comment"> * the program main. However the program is part of the Redis executable</span></span><br><span class="line"><span class="comment"> * so that we can easily execute an RDB check on loading errors. */</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strstr</span>(argv[<span class="number">0</span>],<span class="string">"redis-check-rdb"</span>) != <span class="literal">NULL</span>)</span><br><span class="line">    redis_check_rdb_main(argc,argv,<span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strstr</span>(argv[<span class="number">0</span>],<span class="string">"redis-check-aof"</span>) != <span class="literal">NULL</span>)</span><br><span class="line">    redis_check_aof_main(argc,argv);</span><br></pre></td></tr></table></figure><p>当启用哨兵模式的时候初始化额外的配置，啥是哨兵，现在还不用知道啊，从字面上来看就好了，反正知道命令行里如果指定了哨兵模式就要额外初始化一点东西。</p><p>下面这两个参数有点意思，简单扩展下，<code>rdb</code> 和 <code>aof</code> 是 <code>redis</code> 的两种数据落地的持久化方式，这里有意思的地方是判断了 <code>argv[0]</code> 这个参数，一般 <code>argv[0]</code> 是程序的名字，这个是固定不变的，而 <code>redis</code> 这里将程序名字作为参数来判断，也就是说你把可执行程序换个名字运行，它的行为就会发生变化。</p><h2 id="处理并加载命令行参数"><a href="#处理并加载命令行参数" class="headerlink" title="处理并加载命令行参数"></a>处理并加载命令行参数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (argc &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">    j = <span class="number">1</span>; <span class="comment">/* First option to parse in argv[] */</span></span><br><span class="line">    sds options = sdsempty();</span><br><span class="line">    <span class="keyword">char</span> *configfile = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Handle special options --help and --version */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">"-v"</span>) == <span class="number">0</span> ||</span><br><span class="line">        <span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">"--version"</span>) == <span class="number">0</span>) version();</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">"--help"</span>) == <span class="number">0</span> ||</span><br><span class="line">        <span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">"-h"</span>) == <span class="number">0</span>) usage();</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">"--test-memory"</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (argc == <span class="number">3</span>) &#123;</span><br><span class="line">            memtest(atoi(argv[<span class="number">2</span>]),<span class="number">50</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"Please specify the amount of memory to test in megabytes.\n"</span>);</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"Example: ./redis-server --test-memory 4096\n\n"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* First argument is the config file name? */</span></span><br><span class="line">    <span class="keyword">if</span> (argv[j][<span class="number">0</span>] != <span class="string">'-'</span> || argv[j][<span class="number">1</span>] != <span class="string">'-'</span>) &#123;</span><br><span class="line">        configfile = argv[j];</span><br><span class="line">        server.configfile = getAbsolutePath(configfile);</span><br><span class="line">        <span class="comment">/* Replace the config file in server.exec_argv with</span></span><br><span class="line"><span class="comment">         * its absolute path. */</span></span><br><span class="line">        zfree(server.exec_argv[j]);</span><br><span class="line">        server.exec_argv[j] = zstrdup(server.configfile);</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* All the other options are parsed and conceptually appended to the</span></span><br><span class="line"><span class="comment">     * configuration file. For instance --port 6380 will generate the</span></span><br><span class="line"><span class="comment">     * string "port 6380\n" to be parsed after the actual file name</span></span><br><span class="line"><span class="comment">     * is parsed, if any. */</span></span><br><span class="line">    <span class="keyword">while</span>(j != argc) &#123;</span><br><span class="line">        <span class="keyword">if</span> (argv[j][<span class="number">0</span>] == <span class="string">'-'</span> &amp;&amp; argv[j][<span class="number">1</span>] == <span class="string">'-'</span>) &#123;</span><br><span class="line">            <span class="comment">/* Option name */</span></span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[j], <span class="string">"--check-rdb"</span>)) &#123;</span><br><span class="line">                <span class="comment">/* Argument has no options, need to skip for parsing. */</span></span><br><span class="line">                j++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (sdslen(options)) options = sdscat(options,<span class="string">"\n"</span>);</span><br><span class="line">            options = sdscat(options,argv[j]+<span class="number">2</span>);</span><br><span class="line">            options = sdscat(options,<span class="string">" "</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* Option argument */</span></span><br><span class="line">            options = sdscatrepr(options,argv[j],<span class="built_in">strlen</span>(argv[j]));</span><br><span class="line">            options = sdscat(options,<span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (server.sentinel_mode &amp;&amp; configfile &amp;&amp; *configfile == <span class="string">'-'</span>) &#123;</span><br><span class="line">        serverLog(LL_WARNING,</span><br><span class="line">            <span class="string">"Sentinel config from STDIN not allowed."</span>);</span><br><span class="line">        serverLog(LL_WARNING,</span><br><span class="line">            <span class="string">"Sentinel needs config file on disk to save state.  Exiting..."</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    resetServerSaveParams();</span><br><span class="line">    loadServerConfig(configfile,options);</span><br><span class="line">    sdsfree(options);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段内容很长，但是核心的内容不多，前一部分是判断特殊参数，用来显示程序使用方法，启动内存测试等等，中间部分是分析命令行参数保存到字符串中，最后几行是读取服务器配置文件，并使用字符串中的参数选项覆盖文件中的部分配置。</p><h2 id="打印启动和警告信息"><a href="#打印启动和警告信息" class="headerlink" title="打印启动和警告信息"></a>打印启动和警告信息</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">serverLog(LL_WARNING, <span class="string">"oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo"</span>);</span><br><span class="line">serverLog(LL_WARNING,</span><br><span class="line">    <span class="string">"Redis version=%s, bits=%d, commit=%s, modified=%d, pid=%d, just started"</span>,</span><br><span class="line">        REDIS_VERSION,</span><br><span class="line">        (<span class="keyword">sizeof</span>(<span class="keyword">long</span>) == <span class="number">8</span>) ? <span class="number">64</span> : <span class="number">32</span>,</span><br><span class="line">        redisGitSHA1(),</span><br><span class="line">        strtol(redisGitDirty(),<span class="literal">NULL</span>,<span class="number">10</span>) &gt; <span class="number">0</span>,</span><br><span class="line">        (<span class="keyword">int</span>)getpid());</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (argc == <span class="number">1</span>) &#123;</span><br><span class="line">    serverLog(LL_WARNING, <span class="string">"Warning: no config file specified, using the default config. In order to specify a config file use %s /path/to/%s.conf"</span>, argv[<span class="number">0</span>], server.sentinel_mode ? <span class="string">"sentinel"</span> : <span class="string">"redis"</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    serverLog(LL_WARNING, <span class="string">"Configuration loaded"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印 <code>redis</code> 服务器启动信息，比如版本号，pid，警告信息等等，没有实际修改数据。</p><h2 id="守护模式和初始化"><a href="#守护模式和初始化" class="headerlink" title="守护模式和初始化"></a>守护模式和初始化</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">server.supervised = redisIsSupervised(server.supervised_mode);</span><br><span class="line"><span class="keyword">int</span> background = server.daemonize &amp;&amp; !server.supervised;</span><br><span class="line"><span class="keyword">if</span> (background) daemonize();</span><br><span class="line"></span><br><span class="line">initServer();</span><br><span class="line"><span class="keyword">if</span> (background || server.pidfile) createPidFile();</span><br><span class="line">redisSetProcTitle(argv[<span class="number">0</span>]);</span><br><span class="line">redisAsciiArt();</span><br><span class="line">checkTcpBacklogSettings();</span><br></pre></td></tr></table></figure><p>根据守护进程配置和是否受监督来决定是否作为守护进程，什么是受监督，到现在还不知道，但是本着不懂装懂的方式看代码，可以认为我们懂了，后面自然还会有解释的地方。</p><p>接着就调用了 <code>initServer();</code> 函数，这个初始化函数内容是比较长的，之前版本中很多 <code>mian</code> 函数中的内容都移到了这里面，初始化完成后创建 <code>Pid</code> 文件，设置进程名字，显示 <code>redis</code> 的Logo，检查一些配置，这个 <code>backlog</code> 参数之前面试的时候还被问到过，好奇的话可以提前了解一下。</p><h2 id="哨兵模式判断启动并加载持久化数据"><a href="#哨兵模式判断启动并加载持久化数据" class="headerlink" title="哨兵模式判断启动并加载持久化数据"></a>哨兵模式判断启动并加载持久化数据</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">if</span> (!server.sentinel_mode) &#123;</span><br><span class="line">    <span class="comment">/* Things not needed when running in Sentinel mode. */</span></span><br><span class="line">    serverLog(LL_WARNING,<span class="string">"Server initialized"</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __linux__</span></span><br><span class="line">    linuxMemoryWarnings();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    moduleLoadFromQueue();</span><br><span class="line">    ACLLoadUsersAtStartup();</span><br><span class="line">    InitServerLast();</span><br><span class="line">    loadDataFromDisk();</span><br><span class="line">    <span class="keyword">if</span> (server.cluster_enabled) &#123;</span><br><span class="line">        <span class="keyword">if</span> (verifyClusterConfigWithData() == C_ERR) &#123;</span><br><span class="line">            serverLog(LL_WARNING,</span><br><span class="line">                <span class="string">"You can't have keys in a DB different than DB 0 when in "</span></span><br><span class="line">                <span class="string">"Cluster mode. Exiting."</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (server.ipfd_count &gt; <span class="number">0</span> || server.tlsfd_count &gt; <span class="number">0</span>)</span><br><span class="line">        serverLog(LL_NOTICE,<span class="string">"Ready to accept connections"</span>);</span><br><span class="line">    <span class="keyword">if</span> (server.sofd &gt; <span class="number">0</span>)</span><br><span class="line">        serverLog(LL_NOTICE,<span class="string">"The server is now ready to accept connections at %s"</span>, server.unixsocket);</span><br><span class="line">    <span class="keyword">if</span> (server.supervised_mode == SUPERVISED_SYSTEMD) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!server.masterhost) &#123;</span><br><span class="line">            redisCommunicateSystemd(<span class="string">"STATUS=Ready to accept connections\n"</span>);</span><br><span class="line">            redisCommunicateSystemd(<span class="string">"READY=1\n"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            redisCommunicateSystemd(<span class="string">"STATUS=Waiting for MASTER &lt;-&gt; REPLICA sync\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    InitServerLast();</span><br><span class="line">    sentinelIsRunning();</span><br><span class="line">    <span class="keyword">if</span> (server.supervised_mode == SUPERVISED_SYSTEMD) &#123;</span><br><span class="line">        redisCommunicateSystemd(<span class="string">"STATUS=Ready to accept connections\n"</span>);</span><br><span class="line">        redisCommunicateSystemd(<span class="string">"READY=1\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码看起来像是再做一些通知提醒，其中比较重要的几个函数是<code>moduleLoadFromQueue()</code>、 <code>InitServerLast()</code> 和 <code>loadDataFromDisk()</code> ，第一个函数是加载模块的，第二个函数是在模块加载完成之后才能初始化的部分内容，最后一个是从磁盘加载数据到内存，这也是 <code>redis</code> 支持持久化的必要保证。</p><h2 id="打印内存警告并启动事件监听"><a href="#打印内存警告并启动事件监听" class="headerlink" title="打印内存警告并启动事件监听"></a>打印内存警告并启动事件监听</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Warning the user about suspicious maxmemory setting. */</span></span><br><span class="line"><span class="keyword">if</span> (server.maxmemory &gt; <span class="number">0</span> &amp;&amp; server.maxmemory &lt; <span class="number">1024</span>*<span class="number">1024</span>) &#123;</span><br><span class="line">    serverLog(LL_WARNING,<span class="string">"WARNING: You specified a maxmemory value that is less than 1MB (current value is %llu bytes). Are you sure this is what you really want?"</span>, server.maxmemory);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">redisSetCpuAffinity(server.server_cpulist);</span><br><span class="line">aeMain(server.el);</span><br><span class="line">aeDeleteEventLoop(server.el);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>看到这段代码我们就来到了 <code>main</code> 函数结尾的部分，<code>redisSetCpuAffinity()</code> 是要做些和 <code>CPU</code> 相关的设置或配置，<code>aeMain()</code> 是主逻辑，对于提供服务的程序来说里面大概率是一个死循环，再满足指定的条件下才会打断退出，而 <code>aeDeleteEventLoop()</code> 就是循环结束时清理事件的操作，到此为止 <code>main</code> 函数就执行完啦。</p><h1 id="彩蛋"><a href="#彩蛋" class="headerlink" title="彩蛋"></a>彩蛋</h1><p>这个 <code>main</code> 函数的代码中有一个神奇的用法不知道大家有没有发现，就是下面这句话：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">serverLog(LL_WARNING,</span><br><span class="line">    <span class="string">"You can't have keys in a DB different than DB 0 when in "</span></span><br><span class="line">    <span class="string">"Cluster mode. Exiting."</span>);</span><br></pre></td></tr></table></figure><p>是不是看起来有些奇怪，不用管这个函数的定义是怎样的，可以告诉大家这个函数的定义类似于 <code>printf</code> 函数，只不过在最前面加了一个整型参数，那么调用这个函数时传了几个参数呢？3个？2个？，这个地方很神奇的会把两个字符串拼接到一起，类似于下面的写法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">serverLog(LL_WARNING,</span><br><span class="line">        <span class="string">"You can't have keys in a DB different than DB 0 when in Cluster mode. Exiting."</span>);</span><br></pre></td></tr></table></figure><p>这样的字符串不仅可以分成两行，实际上可以分成任意行，最后都会拼接在一起，是不是很神奇。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li><code>j</code> 这个变量在 <code>redis</code> 的源码中经常出现，应该是作者的行为习惯吧，有些人爱用 <code>i</code>，而这个作者 <code>antirez</code> 爱用 <code>j</code>。</li><li>不能一口吃个胖子，看代码也是一样，不能期望一次性把所有的内容都看懂，一段时间后自己的代码都看不懂了，跟别说别人写的了。</li><li><code>redis</code> 代码中频繁使用 <code>server</code> 这个变量，从 <code>main</code> 函数分析中也能看到，这个是个全局变量，代表了整个 <code>redis</code> 服务器程序数据。</li><li>不懂装懂或者说不求甚解是熟悉代码整体结构的一项优秀品质，这时候只要看个大概就可以了，真到熟悉细节的时候才是需要钻研的时候。</li><li>代码风格完全统一还是比较难实现的，从一个 <code>main</code> 函数中也可以看到，大部分函数是驼峰命名法，还要少量的下划线命名和帕斯卡命名。</li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/107873029" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>你微笑的模样，提醒着我不要躲藏，坚持原来的方向，哪怕最后遍体鳞伤，困难只会让坚持的人越来越强，共勉~</p><p>2020-8-15 23:48:53</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;欠下的技术债慢慢还，继续为去年吹过的牛而努力。去年年末的时候意识到自己掌握的知识还不够深入，决定开始看一些开源项目的源码，因为当时 &lt;code&gt;Redis&lt;/code&gt; 的兴起，所以瞄准了准备从它下手，之后确实看了一部分内容，比如跳表、网络事件库等等，后来过年就鸽了。今年开始一直熟悉新的业务，比较懒没跟进，最近间歇性踌躇满志又发作了，准备抽时间再捋顺一遍，老规矩，还是从 &lt;code&gt;main()&lt;/code&gt; 函数下手。&lt;/p&gt;
    
    </summary>
    
      <category term="Redis" scheme="http://AlbertGithubHome.github.io/blog/categories/Redis/"/>
    
    
      <category term="Redis" scheme="http://AlbertGithubHome.github.io/blog/tags/Redis/"/>
    
      <category term="源码" scheme="http://AlbertGithubHome.github.io/blog/tags/%E6%BA%90%E7%A0%81/"/>
    
      <category term="C" scheme="http://AlbertGithubHome.github.io/blog/tags/C/"/>
    
      <category term="BFS" scheme="http://AlbertGithubHome.github.io/blog/tags/BFS/"/>
    
  </entry>
  
  <entry>
    <title>GDB调试指北-启动GDB并查看说明信息</title>
    <link href="http://AlbertGithubHome.github.io/blog/2020/08/01/GDB%E8%B0%83%E8%AF%95%E6%8C%87%E5%8C%97-%E5%90%AF%E5%8A%A8GDB%E5%B9%B6%E6%9F%A5%E7%9C%8B%E8%AF%B4%E6%98%8E%E4%BF%A1%E6%81%AF/"/>
    <id>http://AlbertGithubHome.github.io/blog/2020/08/01/GDB调试指北-启动GDB并查看说明信息/</id>
    <published>2020-08-01T15:08:16.000Z</published>
    <updated>2020-08-07T16:16:09.954Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>学习 <code>gdb</code> 使用是一个漫长的过程，先了解一下 <code>gdb</code> 的启动方式和基础信息的查看方法，能够帮助我们更全面的认知这个工具。<code>gdb</code> 是一个交互式命令行程序，在使用 <code>gdb</code> 调试的时候不断的在命令行内输入命令，然后 <code>gdb</code> 程序就会给出反馈信息，这在很大程序上可以帮助我们调试程序问题。</p><a id="more"></a><h1 id="gdb-版本查看"><a href="#gdb-版本查看" class="headerlink" title="gdb 版本查看"></a>gdb 版本查看</h1><p><code>gdb</code> 的安装教程网络上有很多，这里就不提供安装步骤了，可以直接通过命令行，也可以从源码安装，找个教程一步步操作就行了，安装完之后使用 <code>which</code> 命令查看一下程序安装的位置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:~$ <span class="built_in">which</span> gdb</span><br><span class="line">/usr/bin/gdb</span><br></pre></td></tr></table></figure><p>确认 <code>gdb</code> 已经安装后我们再看一下程序版本，我用的是 <code>Ubuntu 16.04</code> 版本中匹配的 <code>gdb</code> 程序，版本稍微有些低，据说 <code>9.x</code> 版本中对 <code>Python</code> 支持的非常好，调试的时候查看变量更加方便了，这些神奇的特性我们暂时还用不到，先简单了解下就好：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:~$ gdb --version</span><br><span class="line">GNU gdb (Ubuntu 7.11.1-0ubuntu1~16.5) 7.11.1</span><br><span class="line">Copyright (C) 2016 Free Software Foundation, Inc.</span><br><span class="line">License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;</span><br><span class="line">This is free software: you are free to change and redistribute it.</span><br><span class="line">There is NO WARRANTY, to the extent permitted by law.  Type <span class="string">"show copying"</span></span><br><span class="line">and <span class="string">"show warranty"</span> <span class="keyword">for</span> details.</span><br><span class="line">This GDB was configured as <span class="string">"x86_64-linux-gnu"</span>.</span><br><span class="line">Type <span class="string">"show configuration"</span> <span class="keyword">for</span> configuration details.</span><br><span class="line">For bug reporting instructions, please see:</span><br><span class="line">&lt;http://www.gnu.org/software/gdb/bugs/&gt;.</span><br><span class="line">Find the GDB manual and other documentation resources online at:</span><br><span class="line">&lt;http://www.gnu.org/software/gdb/documentation/&gt;.</span><br><span class="line">For <span class="built_in">help</span>, <span class="built_in">type</span> <span class="string">"help"</span>.</span><br><span class="line">Type <span class="string">"apropos word"</span> to search <span class="keyword">for</span> commands related to <span class="string">"word"</span>.</span><br><span class="line">albert@home-pc:~$</span><br></pre></td></tr></table></figure><h1 id="gdb-启动"><a href="#gdb-启动" class="headerlink" title="gdb 启动"></a>gdb 启动</h1><h2 id="直接启动"><a href="#直接启动" class="headerlink" title="直接启动"></a>直接启动</h2><p><code>gdb</code> 作为一个程序和其他的程序启动方式是一样的，直接敲入 <code>gdb</code> 命令回车就可以了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:~$ gdb</span><br><span class="line">GNU gdb (Ubuntu 7.11.1-0ubuntu1~16.5) 7.11.1</span><br><span class="line">Copyright (C) 2016 Free Software Foundation, Inc.</span><br><span class="line">License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;</span><br><span class="line">This is free software: you are free to change and redistribute it.</span><br><span class="line">There is NO WARRANTY, to the extent permitted by law.  Type <span class="string">"show copying"</span></span><br><span class="line">and <span class="string">"show warranty"</span> <span class="keyword">for</span> details.</span><br><span class="line">This GDB was configured as <span class="string">"x86_64-linux-gnu"</span>.</span><br><span class="line">Type <span class="string">"show configuration"</span> <span class="keyword">for</span> configuration details.</span><br><span class="line">For bug reporting instructions, please see:</span><br><span class="line">&lt;http://www.gnu.org/software/gdb/bugs/&gt;.</span><br><span class="line">Find the GDB manual and other documentation resources online at:</span><br><span class="line">&lt;http://www.gnu.org/software/gdb/documentation/&gt;.</span><br><span class="line">For <span class="built_in">help</span>, <span class="built_in">type</span> <span class="string">"help"</span>.</span><br><span class="line">Type <span class="string">"apropos word"</span> to search <span class="keyword">for</span> commands related to <span class="string">"word"</span>.</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure><p>看着是不是有些眼熟，这就是刚刚查 <code>gdb</code> 版本时看到的那段文字，只不过这段文字结束时不是返回到命令行，而是显现出了 <code>(gdb)</code> 的字样，我们暂时把它叫做 <code>gdb 命令行</code>，这就是我们与 <code>gdb</code> 程序进行交互的主要途径了。</p><h2 id="去掉版本信息启动"><a href="#去掉版本信息启动" class="headerlink" title="去掉版本信息启动"></a>去掉版本信息启动</h2><p>上面启动 <code>gdb</code> 时出现的这段文字很长，有时候反复调试程序时看到这段文字有点烦，想把它去掉怎么办？非常简单，在启动时加上 <code>-q</code> 参数就可以了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:~$ gdb -q</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure><p>怎么样，这次上面那段文字不见了，直接就进入 <code>gdb</code> 命令行了吧。</p><h1 id="gdb-信息查看"><a href="#gdb-信息查看" class="headerlink" title="gdb 信息查看"></a>gdb 信息查看</h1><p>其实刚刚被我们嫌弃的那段文字，里面记录了不少信息，其中还展示了 <code>show copying</code>、<code>show warranty</code>、<code>show configuration</code> 等多个命令，我们可以简单尝试下这些命令有什么作用。</p><h2 id="show-copying"><a href="#show-copying" class="headerlink" title="show copying"></a>show copying</h2><p>输入 <code>show copying</code> 命令展示的是一份比较长的版本许可证说明，我省略了中间的部分，如果想看的话可以自己输入命令试一下，<code>GPL v3</code> 的许可证看起来很熟悉吧。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:~$ gdb -q</span><br><span class="line">(gdb) show copying</span><br><span class="line">                    GNU GENERAL PUBLIC LICENSE</span><br><span class="line">                       Version 3, 29 June 2007</span><br><span class="line"></span><br><span class="line"> Copyright (C) 2007 Free Software Foundation, Inc. &lt;http://fsf.org/&gt;</span><br><span class="line"> Everyone is permitted to copy and distribute verbatim copies</span><br><span class="line"> of this license document, but changing it is not allowed.</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">  Later license versions may give you additional or different</span><br><span class="line">permissions.  However, no additional obligations are imposed on any</span><br><span class="line">author or copyright holder as a result of your choosing to follow a</span><br><span class="line">later version.</span><br></pre></td></tr></table></figure><h2 id="show-warranty"><a href="#show-warranty" class="headerlink" title="show warranty"></a>show warranty</h2><p>命令 <code>show warranty</code> 输出的内容相比之前的命令就短很多了，是一份免责声明，序号从15开始，接着版本许可证的序号往下写的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">(gdb) show warranty</span><br><span class="line">  15. Disclaimer of Warranty.</span><br><span class="line"></span><br><span class="line">  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY</span><br><span class="line">APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT</span><br><span class="line">HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM <span class="string">"AS IS"</span> WITHOUT WARRANTY</span><br><span class="line">OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,</span><br><span class="line">THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR</span><br><span class="line">PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM</span><br><span class="line">IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF</span><br><span class="line">ALL NECESSARY SERVICING, REPAIR OR CORRECTION.</span><br><span class="line"></span><br><span class="line">  16. Limitation of Liability.</span><br><span class="line"></span><br><span class="line">  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING</span><br><span class="line">WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS</span><br><span class="line">THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY</span><br><span class="line">GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE</span><br><span class="line">USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF</span><br><span class="line">DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD</span><br><span class="line">PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),</span><br><span class="line">EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF</span><br><span class="line">SUCH DAMAGES.</span><br><span class="line"></span><br><span class="line">  17. Interpretation of Sections 15 and 16.</span><br><span class="line"></span><br><span class="line">  If the disclaimer of warranty and limitation of liability provided</span><br><span class="line">above cannot be given <span class="built_in">local</span> legal effect according to their terms,</span><br><span class="line">reviewing courts shall apply <span class="built_in">local</span> law that most closely approximates</span><br><span class="line">an absolute waiver of all civil liability <span class="keyword">in</span> connection with the</span><br><span class="line">Program, unless a warranty or assumption of liability accompanies a</span><br><span class="line">copy of the Program <span class="keyword">in</span> <span class="built_in">return</span> <span class="keyword">for</span> a fee.</span><br></pre></td></tr></table></figure><h2 id="show-configuration"><a href="#show-configuration" class="headerlink" title="show configuration"></a>show configuration</h2><p>最后一个 <code>show configuration</code> 展示的 <code>gdb</code> 的一下配置信息，比如 <code>--with-system-gdbinit=/etc/gdb/gdbinit</code> 在进阶版的 <code>gdb</code> 调试技巧中应该经常用到，先有个印象就行。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">(gdb) show configuration</span><br><span class="line">This GDB was configured as follows:</span><br><span class="line">   configure --host=x86_64-linux-gnu --target=x86_64-linux-gnu</span><br><span class="line">             --with-auto-load-dir=<span class="variable">$debugdir</span>:<span class="variable">$datadir</span>/auto-load</span><br><span class="line">             --with-auto-load-safe-path=<span class="variable">$debugdir</span>:<span class="variable">$datadir</span>/auto-load</span><br><span class="line">             --with-expat</span><br><span class="line">             --with-gdb-datadir=/usr/share/gdb (relocatable)</span><br><span class="line">             --with-jit-reader-dir=/usr/lib/gdb (relocatable)</span><br><span class="line">             --without-libunwind-ia64</span><br><span class="line">             --with-lzma</span><br><span class="line">             --with-python=/usr (relocatable)</span><br><span class="line">             --without-guile</span><br><span class="line">             --with-separate-debug-dir=/usr/lib/debug (relocatable)</span><br><span class="line">             --with-system-gdbinit=/etc/gdb/gdbinit</span><br><span class="line">             --with-babeltrace</span><br><span class="line"></span><br><span class="line">(<span class="string">"Relocatable"</span> means the directory can be moved with the GDB installation</span><br><span class="line">tree, and GDB will still find it.)</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure><h2 id="apropos"><a href="#apropos" class="headerlink" title="apropos"></a>apropos</h2><p>其实在 <code>gdb</code> 启动说明中还展示了 <code>apropos</code> 这个命令，可以用这个命令来显示与指定词语相关的命令，比如 <code>apropos print</code> 就是查询所有描述中带有 <code>print</code> 的命令，可以执行测试一下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">(gdb) apropos <span class="built_in">print</span></span><br><span class="line">agent-printf -- Agent-printf <span class="string">"printf format string"</span></span><br><span class="line"><span class="built_in">alias</span> -- Define a new <span class="built_in">command</span> that is an <span class="built_in">alias</span> of an existing <span class="built_in">command</span></span><br><span class="line">backtrace -- Print backtrace of all stack frames</span><br><span class="line">bt -- Print backtrace of all stack frames</span><br><span class="line">call -- Call a <span class="keyword">function</span> <span class="keyword">in</span> the program</span><br><span class="line">commands -- Set commands to be executed when a breakpoint is hit</span><br><span class="line">compile code -- Compile</span><br><span class="line">compile <span class="built_in">print</span> -- Evaluate EXPR by using the compiler and <span class="built_in">print</span> result</span><br><span class="line"><span class="built_in">disable</span> pretty-printer -- GDB <span class="built_in">command</span> to <span class="built_in">disable</span> the specified pretty-printer</span><br><span class="line">...</span><br><span class="line">info <span class="built_in">type</span>-printers -- GDB <span class="built_in">command</span> to list all registered <span class="built_in">type</span>-printers</span><br><span class="line">info vector -- Print the status of the vector unit</span><br><span class="line">inspect -- Print value of expression EXP</span><br><span class="line">maintenance agent-printf -- Translate an expression into remote agent bytecode <span class="keyword">for</span> evaluation and display the bytecodes</span><br><span class="line">maintenance btrace packet-history -- Print the raw branch tracing data</span><br><span class="line">---Type &lt;<span class="built_in">return</span>&gt; to <span class="built_in">continue</span>, or q &lt;<span class="built_in">return</span>&gt; to quit---</span><br></pre></td></tr></table></figure><h2 id="help"><a href="#help" class="headerlink" title="help"></a>help</h2><p>查询具体的命令可以使用 <code>help</code> 子命令，比如查看 <code>bt</code> 这个查看调用栈帧的命令就可以使用 <code>help bt</code>，输入后回车可以得到这个命令的描述信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(gdb) <span class="built_in">help</span> bt</span><br><span class="line">Print backtrace of all stack frames, or innermost COUNT frames.</span><br><span class="line">With a negative argument, <span class="built_in">print</span> outermost -COUNT frames.</span><br><span class="line">Use of the <span class="string">'full'</span> qualifier also prints the values of the <span class="built_in">local</span> variables.</span><br><span class="line">Use of the <span class="string">'no-filters'</span> qualifier prohibits frame filters from executing</span><br><span class="line">on this backtrace.</span><br></pre></td></tr></table></figure><p><code>gdb</code>工作作为一款调试利器，可以使用的命令是在是太多了，除了这些还有很多命令等着我们去发现，今天的内容仅仅作为入门必备先简单了解一下。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li><code>gdb</code> 是一个交互式的命令行调试工具，通过不断执行命令，展示调试信息帮助我们调试程序</li><li>当启动 <code>gdb</code> 这个工具后，命令行会变成 <code>(gdb)</code>的形式，等着我们输入命令开始调试使用</li><li><code>gdb</code> 作为一个强大的 <code>GNU</code> 工具，文档比较全，如果觉的文档枯燥，也可以跟着我的总结来熟悉一下基础用法。</li><li>开源环境下软件的版权信息和免责声明写的都比较完整，其中有很多描述值得我们学习。</li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/107724714" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>而世之奇伟、瑰怪，非常之观，常在于险远，而人之所罕至焉，故非有志者不能至也~</p><p>2020-8-5 23:17:04</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;学习 &lt;code&gt;gdb&lt;/code&gt; 使用是一个漫长的过程，先了解一下 &lt;code&gt;gdb&lt;/code&gt; 的启动方式和基础信息的查看方法，能够帮助我们更全面的认知这个工具。&lt;code&gt;gdb&lt;/code&gt; 是一个交互式命令行程序，在使用 &lt;code&gt;gdb&lt;/code&gt; 调试的时候不断的在命令行内输入命令，然后 &lt;code&gt;gdb&lt;/code&gt; 程序就会给出反馈信息，这在很大程序上可以帮助我们调试程序问题。&lt;/p&gt;
    
    </summary>
    
      <category term="GDB" scheme="http://AlbertGithubHome.github.io/blog/categories/GDB/"/>
    
    
      <category term="GDB" scheme="http://AlbertGithubHome.github.io/blog/tags/GDB/"/>
    
      <category term="manual" scheme="http://AlbertGithubHome.github.io/blog/tags/manual/"/>
    
      <category term="调试" scheme="http://AlbertGithubHome.github.io/blog/tags/%E8%B0%83%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>小白眼中的docker究竟是个什么东西</title>
    <link href="http://AlbertGithubHome.github.io/blog/2020/07/28/%E5%B0%8F%E7%99%BD%E7%9C%BC%E4%B8%AD%E7%9A%84docker%E7%A9%B6%E7%AB%9F%E6%98%AF%E4%B8%AA%E4%BB%80%E4%B9%88%E4%B8%9C%E8%A5%BF/"/>
    <id>http://AlbertGithubHome.github.io/blog/2020/07/28/小白眼中的docker究竟是个什么东西/</id>
    <published>2020-07-28T15:44:10.000Z</published>
    <updated>2020-08-01T05:43:13.785Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><code>Docker</code>，中文名：容器引擎，别名：小鲸鱼，生于2013年3月20日，有一个法裔美籍的母亲 <code>Solumon Hykes</code>，父亲是谁，不得而知。虽然只有7岁，但是在 <code>Hello World</code> 平行宇宙中也算进入了青壮年吧，正在飞速的发展着。</p><a id="more"></a><p><code>Docker</code> 这个动物选的比较有意思，是一只蓝色的鲸鱼，作为地球上最大的动物，用它来代表容器再合适不过了。不过有谁知道为什么编程技术总是和动物挂钩啊？比如 <code>Linux</code> 的企鹅，<code>Python</code> 的大蛇，<code>Hadoop</code> 的大象等等，有知道的小伙伴还请告知一下。</p><p>俗话说的好，“程序不逛动物园，肯定技术有点悬”，经常看到网上有人推荐编程学习方法，先学学基础，然后再看几本儿动物书就可以了，看来这些封面上的动物已经深入人心了。</p><p>先把这些动物放到一边，来看看这个 <code>docker</code> 究竟是什么，之前我也不知道它是什么，甚至到了现在我也不能准确的说出它是什么，我只是以一个小白的身份来学习和使用，并且把一些弄懂的知识点总结起来，方便日后查找。</p><h1 id="关于docker的疑问"><a href="#关于docker的疑问" class="headerlink" title="关于docker的疑问"></a>关于docker的疑问</h1><p>如果你之前看到 <code>docker</code> 时会有下面这些疑问，可以跟着文章梳理了解一下，如果你对这些问题的答案早已烂熟于胸，那么可以简单浏览下，帮我挑挑毛病，也是帮助想学习的同学们：</p><ol><li><code>docker</code> 最近很火啊，它到底能用来做什么？</li><li><code>docker</code> 和虚拟机好像啊，难道就是轻量虚拟机吗？它们两者还有其他的区别吗？</li><li><code>docker</code> 教程里有 <code>ubuntu</code> 上安装 <code>docker</code>，还有 <code>docker</code> 上安装 <code>linux</code>，什么鬼，到底谁装谁啊？</li><li><code>docker</code> 真的这么牛吗？那开发项目必须得用上它啊，显得高端大气上档次！</li><li><code>docker</code> 宣称构建一次，处处运行，那它应该能跨平台吧？</li></ol><p>作为小白我也是带着这些疑问开始慢慢了解 <code>docker</code> 的，特别是那个 <code>ubuntu</code> 上装 <code>docker</code>，<code>docker</code> 上还能装 <code>ubuntu</code>，都给我整蒙圈了，通过不断学习才渐渐弄清了其中的原因。</p><h1 id="疑问探索解答"><a href="#疑问探索解答" class="headerlink" title="疑问探索解答"></a>疑问探索解答</h1><h2 id="docker-是什么"><a href="#docker-是什么" class="headerlink" title="docker 是什么"></a>docker 是什么</h2><p>关于 <code>docker</code> 我们来看下常见的介绍：</p><blockquote><p><code>Docker</code> 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的 <code>Linux</code> 机器或 <code>Windows</code> 机器上，也可以实现虚拟化，容器是完全使用沙箱机制，相互之间不会有任何接口。</p></blockquote><p>从这一段话中我们可以得到以下几个知识点：</p><ol><li>它是一个容器引擎</li><li>可以用来打包应用</li><li>可以发布到 <code>linux</code> 或者 <code>windows</code> 上</li><li>可以实现虚拟化</li><li>采用沙箱机制，相互隔离</li></ol><p>结合查到的资料来了解一下 <code>docker</code>，首先它是一个容器引擎，引擎这个词经常出现，什么游戏引擎，物理引擎，发动机引擎等等，每种引擎其实就是负责一种核心工作的模块或事物，通过封装来简化工作流程，降低工作难度，而 <code>docker</code> 作为容器引擎的作用当然就是生产容器了。</p><p>它的目的就是隔离应用，在隔离空间内部署自己独特的环境，需要了解的是它并不是一项新的技术，而是利用了 <code>Linux</code> 核心中的 <code>cgroups</code> 和 <code>namespace</code> 等资源分脱机制来进行隔离，这种被称为容器的进程独立于宿主和其它的隔离的进程，是很早就存在的技术，只不过经过 <code>docker</code> 封装之后使用起来更加方便了。</p><p>再说打包应用，这也是 <code>docker</code> 迅速火起来的一个原因，因为环境部署是在太费时费力了，之前在服务器配置一个应用的运行环境，要安装各种软件，<code>Java/Tomcat/MySQL</code>等等。安装和配置这些东西非常麻烦，并且还存在各种版本，而当我们换另一台同样操作系统的服务器还要再配置一遍，有没有办法这些配置直接拷贝过来呢？其实这就是 <code>docker</code> 要做的事情，将应用与运行环境打包到一起，直接在 <code>docker</code> 中运行一个容器就好了，你所依赖的环境直接就装好了。</p><p>前面提到 <code>docker</code> 是利用了 <code>linux</code> 内核的一些特性，那么 <code>windows</code> 可以运行吗？如果你查询早期一点的资料会得到不可以的答案，或者说即使在 <code>windows</code> 上运行 <code>docker</code>，也是在中间加了一层 <code>linux</code> 虚拟机。而如今已经 2020 年了，<code>windows</code> 上可以直接安装 <code>docker for windows</code> 来启动提供 <code>docker</code> 服务，而 <code>docker for mac</code> 也使得 <code>docker</code> 运行在 <code>mac</code> 上不再困难，<code>windows</code> 很早就和 <code>docker</code> 进行了合作，最新的 <code>win10</code> 上启动 <code>docker</code> 甚至可以切换内核为 <code>linux</code> 或者 <code>windows</code>，很神奇吧。</p><p>说到这里你应该对 <code>docker</code> 有了一个简单的了解，其中有一点很重要，它和宿主机是共享内核的，这是解答上面很多疑惑的钥匙，至于虚拟化，隔离这些都很容易理解了，而这些概念在虚拟机上常常出现，所以很容易把它俩弄混。</p><h2 id="容器与虚拟机"><a href="#容器与虚拟机" class="headerlink" title="容器与虚拟机"></a>容器与虚拟机</h2><p>自从 <code>docker</code> 出现，容器和虚拟机的对比就没有停过，这些对比常常从启动时间、资源占用、隔离性，操作便利性等方面来进行比较，可以用搜索引擎搜一下，大概就是下面这个样子：</p><table><thead><tr><th>特性</th><th>Docker容器</th><th>VM虚拟机</th></tr></thead><tbody><tr><td>启动速速</td><td>秒级</td><td>分钟级</td></tr><tr><td>性能</td><td>接近原生</td><td>明显弱于原生</td></tr><tr><td>硬盘使用</td><td>相对较小，可以自由分配</td><td>创建时分配，易造成浪费</td></tr><tr><td>系统支持量</td><td>支持上千个</td><td>一般几十个</td></tr></tbody></table><p>造成这种差异的原因是什么？还是前面说的 <code>docker</code> 和宿主机是共享内核，而虚拟机是自己创建了一整套系统，虽然隔离性更强，但是也造成了资源的浪费和效率的降低。</p><p>一直想找一个例子来形象地对比一下虚拟机和容器，我强行编一个吧，比如你是一个财富自由的人，准备回老家养养牛种种菜，包个鱼塘钓钓鱼，顺便再养一窝小白兔，但是小白兔会吃你种的蔬菜，牛偶尔也会踩到小白兔，这时怎么办，把它们隔开呗。</p><p>作为一个钱花不完的人，你准备造几个“小地球”，然后把饲养的动物和种植的植物都放到各自的“地球”中放养，每个小地球都是一个密封的环境，里面有自己的太阳、月亮、空气、河流、山川等等，这种方法当然可以，只是成本有些高，一旦建立了这个小地球，它所占有的资源就定下来了，基本上与大地球隔离，但是它还要依赖大地球，还要建立在地球上，可以类比下<strong>虚拟机</strong>。</p><p>因为建造小地球太费时费力了，所以你改了策略，这次不创建完全密闭的环境了，我直接造个篱笆就可以了，阳光、空气、河流我还是使用大地球的，只是在篱笆里我进行定制，做一些鱼塘、蔬菜大棚等等。由于建造篱笆非常省事，我可以批量生产，有需要了我可以直接拿来几个，放在地上就可以使用了，并且不同动物以及植物之间都有篱笆挡着，不会出现相互影响的问题了，这就有点像<strong>容器</strong>了。</p><p>虽然有些牵强，但是这个例子还是可以帮助我们了解容器和虚拟机的区别，实际上容器与虚拟机并不是对立的关系，有时为了防止容器无限制的占用物理机资源，还会现在物理机上运行虚拟机，然后在虚拟机里运行 <code>docker</code>，他们两者只是不同需求下的不同选择而已。</p><h2 id="操作系统和容器到底谁安装谁"><a href="#操作系统和容器到底谁安装谁" class="headerlink" title="操作系统和容器到底谁安装谁"></a>操作系统和容器到底谁安装谁</h2><p>前面说过 <code>ubuntu</code> 上装 <code>docker</code>，<code>docker</code> 上还能装 <code>ubuntu</code> 这个问题困扰了我好久，实际上 <code>windows</code> 可以装虚拟机，而虚拟机中有可以装 <code>windows</code> 这没什么好奇怪的，这里的 <code>dokcker</code> 指的就是 <code>docker</code> 引擎，或者认为是 <code>docker</code> 服务器。</p><p>它们确实可以相互安装，但情况是不同的，首先说 <code>ubuntu</code> 上装 <code>docker</code>，<code>docker</code> 说白了还是一种软件，本质上和你在电脑上装个QQ也没有多大差别，只不过这个软件有点特殊，通过它还能下载、安装别的环境，这么说它看起来有点像应用商店了，不过他虽然提供仓库，但是不仅仅是仓库，本质上它就是一种帮助你搭建环境的软件。</p><p>再来看看 <code>docker</code> 上装 <code>ubuntu</code>，还记得之前说过的一个重点吗？ <code>docker</code> 上安装的环境与宿主机共享内核，这就决定了他不能安装完整的系统，不管是 <code>ubuntu</code>、<code>CentOS</code> 还是 <code>RedHat</code>，它所安装的系统仅仅包含运行库和工具链，内核还是用宿主机的，相当于在 <code>docker</code> 中给内核套了一个新的壳子而已。</p><p>这下应该清楚了，<code>ubuntu</code> 上装 <code>docker</code> 就是在 <code>ubuntu</code> 上装了一个容器软件， <code>docker</code> 上装 <code>ubuntu</code> 就是在 <code>docker</code> 容器中给宿主内核套上了一个新系统的壳子，使其满足应用软件的环境，配备应用软件可使用的工具链。</p><h2 id="这么厉害的容器项目中一定要用吗"><a href="#这么厉害的容器项目中一定要用吗" class="headerlink" title="这么厉害的容器项目中一定要用吗"></a>这么厉害的容器项目中一定要用吗</h2><p>相信这种问题就是不了解容器也可以回答，肯定不是都要用啊，没有什么技术是只有优点没有缺点吧，凡是技术总有其适合的领域和场景，一味的追求最新的技术不一定符合所要开发的项目。</p><p><code>docker</code> 也没有传说的那么神，它也有着这样那样的问题，比如一直津津乐道的资源伸缩机制，不像虚拟机那样创建时便规定了资源大小，即使不使用也占用着，而 <code>docker</code> 可以直接使用宿主资源，避免了很多浪费。但是反过来想，虚拟机规定了资源的多少，如果不够用了只影响它自己，而 <code>docker</code> 如果一个环境出了问题，它可以把整个物理机的资源耗完，影响机器上的所有服务。</p><p>另外，<code>docker</code> 建议只部署无状态的服务，它们不应该承载任何交易数据，所有数据应该保存在数据库服务器中，器随时可以停止、或者删除。当容器被删除掉，容器里的数据将会丢失，即使你要把 <code>docker</code> 数据放在主机来存储，它依然不能保证不丢数据，具体的细节我也在学习，有这方面经验的朋友可以发表一下见解。</p><h2 id="docker的跨平台"><a href="#docker的跨平台" class="headerlink" title="docker的跨平台"></a>docker的跨平台</h2><p>先来看看跨平台的概念：</p><blockquote><p>跨平台概念是软件开发中一个重要的概念，即不依赖于操作系统，也不依赖硬件环境。一个操作系统下开发的应用，放到另一个操作系统下依然可以运行。</p></blockquote><p>首先要弄明白你说的跨平台指的是 <code>docker</code> 跨平台，还是它里边的应用使用 <code>docker</code> 就能跨平台了，从定义来说 <code>docker</code> 这个容器软件应该算是跨平台的，毕竟 <code>Linux</code>、 <code>Windows</code>、 <code>Mac</code> 都有了 <code>docker</code> 的安装包，那么他里面的镜像运行之后的容器能跨平台吗？这还要看具体的应用，<code>docker</code> 没有让一个非跨平台软件变成跨平台软件的能力。</p><p>关于这一点你还要牢记前面说的，<code>docker</code> 中的环境与宿主机共享内核，你创建了一个自己编写的exe程序的镜像，拿到安装了 <code>docker</code> 的 <code>ubuntu</code> 机器上显然是无法成功运行的。</p><h1 id="基础知识点"><a href="#基础知识点" class="headerlink" title="基础知识点"></a>基础知识点</h1><h2 id="docker的缺点"><a href="#docker的缺点" class="headerlink" title="docker的缺点"></a>docker的缺点</h2><p><code>docker</code> 的卖点是让你摆脱配置环境的困扰，但真实情况是你打包镜像的机器和系统版本，最好和你要运行的目标机器和系统版本一致，另外 <code>docker</code> 环境最好也一样，忽然感觉它没有那么神奇了，这不还是要求版本吗？</p><p>试想一下，你用一个高版本的 <code>docker</code> 服务打包，其中使用了一些新特性，然后放到低版本的 <code>docker</code> 服务下怎么能保证成功运行，机器配置也是一样，之前看到过一个问题 “尝试在具有 <code>4.19</code> 或更高内核的 <code>Linux</code> 系统上运行 <code>docker official centos:6</code> 或 <code>centos:5</code> 容器，当尝试启动它时，你会发现内核和程序不兼容”。</p><p>这样看来，<code>docker</code> 只适合在相同环境下批量复制，使得实现自动化测试和持续的集成很方便，但还是有些问题需要注意的：</p><ol><li><code>docker</code> 是基于64位系统环境的，32位环境下无法使用</li><li>隔离性相比 <code>KVM</code> 之类的虚拟化方案还是有些欠缺</li><li>容器随着用户进程的停止而销毁，其中的日志、打点等用户数据不便收集</li><li>网络管理相对简单，主要是基于 <code>namespace</code> 隔离</li><li>容器的 <code>root</code> 和宿主机 <code>root</code> 等同，这使得容器容易受到攻击</li><li>…</li></ol><h2 id="docker-的组成"><a href="#docker-的组成" class="headerlink" title="docker 的组成"></a>docker 的组成</h2><p>前面一直在说初学 <code>docker</code> 时的疑问，接下来看看 <code>docker</code> 究竟都包括哪些内容，<code>docker</code> 这个容器引擎实际上是一个客户端/服务器应用程序，客户端负责与守护的服务进程进行对话，而服务进程负责构建、运行和分发 <code>docker</code> 容器。<br><code>docker</code> 客户端和服务进程可以在同一系统上运行，也可以进行远程访问，通过网络接口使用 <code>RESTful API</code> 进行通信。</p><p>使用 <code>docker</code> 时常常要接触三个概念：镜像（Image）、容器（Container）和仓库（Repository）。简单来说镜像就是我们的想要打包的程序机加上程序运行环境，打包出来的一个文件，相当于程序安装包。当镜像运行起来我们就得到了容器，镜像与容器的关系就类似于类和对象的关系。仓库就是存放镜像的地方，与代码的仓库 <code>Github</code> 很像，<code>docker</code> 镜像也有一个常用的仓库叫 <code>Docker Hub</code>，方便人们直接下载镜像来运行。</p><h2 id="运行一个镜像"><a href="#运行一个镜像" class="headerlink" title="运行一个镜像"></a>运行一个镜像</h2><p><code>Hello world</code> 常常被拿来新知识的入门和开头，今天我们用这个例子来做一下收尾吧，首先你得有 <code>docker</code> 环境，说人话就是你得装了 <code>docker</code> 软件，之前不是一直说 <code>docker</code> 就是一个软件吗，你想用它当然得安装了，这类教程很多，假设你已经安装完了，</p><p>我们在一台 <code>CentOS</code> 上操作使用一下 <code>docker</code>，查询下系统版本和 <code>docker</code> 版本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@remote-os ~]<span class="comment"># lsb_release -a</span></span><br><span class="line">LSB Version:    :core-4.1-amd64:core-4.1-noarch</span><br><span class="line">Distributor ID: CentOS</span><br><span class="line">Description:    CentOS Linux release 7.7.1908 (Core)</span><br><span class="line">Release:    7.7.1908</span><br><span class="line">Codename:   Core</span><br><span class="line">[root@remote-os ~]<span class="comment"># docker --version</span></span><br><span class="line">Docker version 19.03.7, build 7141c199a2</span><br><span class="line">[root@remote-os ~]<span class="comment">#</span></span><br></pre></td></tr></table></figure><p>首先下载 <code>hello world</code> 镜像，使用 <code>docker image pull hello-world</code> 命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@remote-os ~]<span class="comment"># docker image pull hello-world</span></span><br><span class="line">Using default tag: latest</span><br><span class="line">latest: Pulling from library/hello-world</span><br><span class="line">Digest: sha256:49a1c8800c94df04e9658809b006fd8a686cab8028d33cfba2cc049724254202</span><br><span class="line">Status: Image is up to date <span class="keyword">for</span> hello-world:latest</span><br><span class="line">docker.io/library/hello-world:latest</span><br></pre></td></tr></table></figure><p>查看本地镜，使用 <code>docker image ls</code> 命令，发现 <code>hell-world</code> 镜像已经在本地了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@remote-os ~]<span class="comment"># docker image ls</span></span><br><span class="line">REPOSITORY                  TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">ubuntu                      latest              adafef2e596e        3 weeks ago         73.9MB</span><br><span class="line">registry                    latest              708bc6af7e5e        6 months ago        25.8MB</span><br><span class="line">hello-world                 latest              bf756fb1ae65        7 months ago        13.3kB</span><br><span class="line">wurstmeister/zookeeper      latest              3f43f72cb283        18 months ago       510MB</span><br><span class="line">hyper/docker-registry-web   latest              0db5683824d8        3 years ago         599MB</span><br><span class="line">[root@remote-os ~]<span class="comment">#</span></span><br></pre></td></tr></table></figure><p>下载完成之后直接使用 <code>docker container run hello-world</code> 命令运行就可以了，这个镜像运行打印完直接就退出了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[root@remote-os ~]<span class="comment"># docker container run hello-world</span></span><br><span class="line"></span><br><span class="line">Hello from Docker!</span><br><span class="line">This message shows that your installation appears to be working correctly.</span><br><span class="line"></span><br><span class="line">To generate this message, Docker took the following steps:</span><br><span class="line"> 1. The Docker client contacted the Docker daemon.</span><br><span class="line"> 2. The Docker daemon pulled the <span class="string">"hello-world"</span> image from the Docker Hub.</span><br><span class="line">    (amd64)</span><br><span class="line"> 3. The Docker daemon created a new container from that image <span class="built_in">which</span> runs the</span><br><span class="line">    executable that produces the output you are currently reading.</span><br><span class="line"> 4. The Docker daemon streamed that output to the Docker client, <span class="built_in">which</span> sent it</span><br><span class="line">    to your terminal.</span><br><span class="line"></span><br><span class="line">To try something more ambitious, you can run an Ubuntu container with:</span><br><span class="line"> $ docker run -it ubuntu bash</span><br><span class="line"></span><br><span class="line">Share images, automate workflows, and more with a free Docker ID:</span><br><span class="line"> https://hub.docker.com/</span><br><span class="line"></span><br><span class="line">For more examples and ideas, visit:</span><br><span class="line"> https://docs.docker.com/get-started/</span><br></pre></td></tr></table></figure><p>如果不想退出，运行的镜像应该是能提供某种服务的，比如前面一直说的 <code>ubuntu</code>，它可以在 <code>docker</code> 中运行起来，直接使用 <code>docker container run -it ubuntu bash</code> 命令就行，这里为什么我们不先下载呢？实际上如果你指定的镜像在本地没有的话会自动下载，不需要手动下载完再运行。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@remote-os ~]<span class="comment"># docker container run -it ubuntu bash</span></span><br><span class="line">root@0577050677ac:/<span class="comment"># cat /etc/issue</span></span><br><span class="line">Ubuntu 20.04 LTS \n \l</span><br><span class="line"></span><br><span class="line">root@0ecfed0920aa:/<span class="comment"># ls</span></span><br><span class="line">bin  boot  dev  etc  home  lib  lib32  lib64  libx32  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var</span><br><span class="line">root@0ecfed0920aa:/<span class="comment"># ll home/</span></span><br><span class="line">total 8</span><br><span class="line">drwxr-xr-x 2 root root 4096 Apr 15 11:09 ./</span><br><span class="line">drwxr-xr-x 1 root root 4096 Jul 31 16:23 ../</span><br><span class="line">root@0ecfed0920aa:/<span class="comment">#</span></span><br></pre></td></tr></table></figure><p>可以看到上面的操作，我们又进入了 <code>ubuntu</code> 系统，成功运行了镜像，现在得到了一个容器，可以通过 <code>docker container ls</code> 命令查看，还可以通过 <code>docker container rm [containerID]</code> 命令来删除容器。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li><code>docker</code> 软件可以运行在<code>windows</code>、<code>linux</code> 和 <code>mac</code> 上</li><li><code>docker</code> 容器与宿主机共享一个系统内核，如果依赖内核版本的应用最好保证物理机系统版本一致</li><li><code>docker</code> 容器与虚拟机并不是对立的，有时候会放在一起配合使用</li><li><code>docker</code> 有自己的镜像仓库，可以直接下载安装，使用起来相当方便，因为网络原因，如果想快速搭建最好提前准备好镜像文件</li></ul><hr><h2 id="gt-gt-反爬链接，请勿点击，原地爆炸，概不负责！-lt-lt"><a href="#gt-gt-反爬链接，请勿点击，原地爆炸，概不负责！-lt-lt" class="headerlink" title=" ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== "></a><center><a href="https://blog.csdn.net/albertsh/article/details/107587859" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center></h2><blockquote><p>海纳百川有容乃大，壁立千仞无欲则刚~</p><p>2020-8-1 00:31:35</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&lt;code&gt;Docker&lt;/code&gt;，中文名：容器引擎，别名：小鲸鱼，生于2013年3月20日，有一个法裔美籍的母亲 &lt;code&gt;Solumon Hykes&lt;/code&gt;，父亲是谁，不得而知。虽然只有7岁，但是在 &lt;code&gt;Hello World&lt;/code&gt; 平行宇宙中也算进入了青壮年吧，正在飞速的发展着。&lt;/p&gt;
    
    </summary>
    
      <category term="docker" scheme="http://AlbertGithubHome.github.io/blog/categories/docker/"/>
    
    
      <category term="docker" scheme="http://AlbertGithubHome.github.io/blog/tags/docker/"/>
    
      <category term="容器" scheme="http://AlbertGithubHome.github.io/blog/tags/%E5%AE%B9%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>GDB调试指北大全</title>
    <link href="http://AlbertGithubHome.github.io/blog/2020/07/18/GDB%E8%B0%83%E8%AF%95%E6%8C%87%E5%8C%97%E5%A4%A7%E5%85%A8/"/>
    <id>http://AlbertGithubHome.github.io/blog/2020/07/18/GDB调试指北大全/</id>
    <published>2020-07-18T08:34:29.000Z</published>
    <updated>2020-07-25T13:12:28.509Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><code>GDB</code> 作为程序调试利器，是一个受通用公共许可证（GPL）保护的自由软件，全称是 <code>GNU Debugger</code>，又常常被称为 <code>GNU symbolic debugger</code> 或者 <code>GNU project debugger</code>，能够帮助开发者调试程序，分析应用程序运行过程。目前支持调试 <code>C</code>、 <code>C++</code>、 <code>D</code>、 <code>Go</code>、 <code>Objective-C</code>、 <code>Fortran</code>、 <code>Java</code>、 <code>OpenCL C</code>、 <code>Pascal</code>、 <code>assembly</code>、 <code>Modula-2</code>、 <code>Ada</code> 等多种编程语言。</p><a id="more"></a><h1 id="GDB能做什么"><a href="#GDB能做什么" class="headerlink" title="GDB能做什么"></a>GDB能做什么</h1><p><code>GDB</code> 是调试程序的强大武器，能够帮助开发者找出程序出现BUG的原因，但是不要指望它能自己查问题，它仅仅是一个工具，可以帮助我们查找问题原因，常常被用来做以下事情：</p><ul><li>分析程序崩溃的原因</li><li>查找程序表现出错误行为的原因</li><li>找到一些从源码上难以发现的逻辑错误</li></ul><h1 id="GDB调试步骤"><a href="#GDB调试步骤" class="headerlink" title="GDB调试步骤"></a>GDB调试步骤</h1><ol><li>使用 <code>g++</code> 附加 <code>-g</code> 参数编译程序，<code>g++ -g mainpro.cpp -o mainpro</code></li><li>使用 <code>gdb</code> 程序来启动调试我们自己构建的程序，<code>gdb mainpro</code></li><li>使用 <code>run</code>、<code>break</code>、<code>print</code> 等命令调试程序</li><li>使用 <code>quit</code> 命令退出程序</li></ol><h1 id="GDB调试示例"><a href="#GDB调试示例" class="headerlink" title="GDB调试示例"></a>GDB调试示例</h1><ol><li>编写示例程序代码，保存到文件 <code>mainpro.cpp</code> 中</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">110</span>, b = <span class="number">119</span>, c;</span><br><span class="line"></span><br><span class="line">    c = a + b;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"c = "</span> &lt;&lt; c &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>使用 <code>g++</code> 附加 <code>-g</code> 参数编译程序</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:~$ g++ -g mainpro.cpp -o mainpro</span><br><span class="line">albert@home-pc:~$ ls</span><br><span class="line">mainpro  mainpro.cpp</span><br></pre></td></tr></table></figure><ol><li>使用 <code>gdb</code> 命令来启动调试</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:~$ gdb mainpro</span><br><span class="line">GNU gdb (Ubuntu 7.11.1-0ubuntu1~16.5) 7.11.1</span><br><span class="line">Copyright (C) 2016 Free Software Foundation, Inc.</span><br><span class="line">License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;</span><br><span class="line">This is free software: you are free to change and redistribute it.</span><br><span class="line">There is NO WARRANTY, to the extent permitted by law.  Type <span class="string">"show copying"</span></span><br><span class="line">and <span class="string">"show warranty"</span> <span class="keyword">for</span> details.</span><br><span class="line">This GDB was configured as <span class="string">"x86_64-linux-gnu"</span>.</span><br><span class="line">Type <span class="string">"show configuration"</span> <span class="keyword">for</span> configuration details.</span><br><span class="line">For bug reporting instructions, please see:</span><br><span class="line">&lt;http://www.gnu.org/software/gdb/bugs/&gt;.</span><br><span class="line">Find the GDB manual and other documentation resources online at:</span><br><span class="line">&lt;http://www.gnu.org/software/gdb/documentation/&gt;.</span><br><span class="line">For <span class="built_in">help</span>, <span class="built_in">type</span> <span class="string">"help"</span>.</span><br><span class="line">Type <span class="string">"apropos word"</span> to search <span class="keyword">for</span> commands related to <span class="string">"word"</span>...</span><br><span class="line">Reading symbols from mainpro...done.</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure><ol><li>使用 <code>break 8</code> 在第8行打断点，使用 <code>run</code> 命令启动程序，使用 <code>print c</code> 打印程序变量</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(gdb) <span class="built_in">break</span> 8</span><br><span class="line">Breakpoint 1 at 0x4008b7: file mainpro.cpp, line 8.</span><br><span class="line">(gdb) run</span><br><span class="line">Starting program: /home/albert/mainpro</span><br><span class="line"></span><br><span class="line">Breakpoint 1, main () at mainpro.cpp:8</span><br><span class="line">8       std::cout &lt;&lt; <span class="string">"c = "</span> &lt;&lt; c &lt;&lt; std::endl;</span><br><span class="line">(gdb) <span class="built_in">print</span> c</span><br><span class="line"><span class="variable">$1</span> = 239</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure><ol><li>使用 <code>quit</code> 命令退出程序</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(gdb) quit</span><br><span class="line">A debugging session is active.</span><br><span class="line"></span><br><span class="line">    Inferior 1 [process 227] will be killed.</span><br><span class="line"></span><br><span class="line">Quit anyway? (y or n) y</span><br><span class="line">albert@home-pc:~$</span><br></pre></td></tr></table></figure><h1 id="GDB启动参数与命令列表（持续更新）"><a href="#GDB启动参数与命令列表（持续更新）" class="headerlink" title="GDB启动参数与命令列表（持续更新）"></a>GDB启动参数与命令列表（持续更新）</h1><p><code>GDB</code> 众多的启动参数和命令提供了强大的调试功能，每一条都可以展开得到很多知识，这些知识的学习是一个持续的过程，短时间无法消化和吸收，所以准备总结一个系列，从最简单的命令开始总结，持续更新学习下去，文章链接不定期更新。</p><table><thead><tr><th style="text-align:center">GDB命令</th><th style="text-align:center">备注</th><th style="text-align:center">参考文章</th></tr></thead><tbody><tr><td style="text-align:center"><code>gdb</code>、<code>gdb -q</code></td><td style="text-align:center">GDB启动、查看说明</td><td style="text-align:center">[GDB调试指北-启动GDB与查看说明]</td></tr><tr><td style="text-align:center"><code>gdb pro</code>、<code>gdb pro 123</code></td><td style="text-align:center">启动调试程序、调试正在运行的程序</td><td style="text-align:center">[GDB调试指北-使用GDB启动调试]</td></tr><tr><td style="text-align:center"><code>directory new-path</code></td><td style="text-align:center">查看调试源码</td><td style="text-align:center"><a href="https://blog.csdn.net/shihengzhen101/article/details/107274490" target="_blank" rel="noopener">GDB调试指北-查找丢失源码文件</a></td></tr><tr><td style="text-align:center"><code>set substitute from-path to-path</code></td><td style="text-align:center">查看调试源码</td><td style="text-align:center"><a href="https://blog.csdn.net/shihengzhen101/article/details/107274490" target="_blank" rel="noopener">GDB调试指北-查找丢失源码文件</a></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td></tr></tbody></table><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li><code>GDB</code> 调试技巧更多的是工具本身的功能，所谓“重剑无锋，大巧不工”，熟练利用这个工具才能发挥最大的威力</li><li>知识的学习时一个持续的过程，只有不断的学习和总结才能不断进步，而不要被那些花里胡哨的外表所迷惑</li><li>有些知识学着学着就通了，前几天看到 <code>printf</code> 这个函数，很疑惑为什么末尾要加个 <code>f</code>，猜想它是格式化 <code>format</code> 的意思</li><li>经过查证果然如此，此时距离第一次在 C 语言中学习 <code>printf</code> 函数已经过去了10年</li></ul><hr><h2 id="gt-gt-反爬链接，请勿点击，原地爆炸，概不负责！-lt-lt"><a href="#gt-gt-反爬链接，请勿点击，原地爆炸，概不负责！-lt-lt" class="headerlink" title=" ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== "></a><center><a href="https://blog.csdn.net/albertsh/article/details/107274490" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center></h2><blockquote><p>大漠孤烟直，长河落日圆~</p><p>2020-7-18 20:09:58</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&lt;code&gt;GDB&lt;/code&gt; 作为程序调试利器，是一个受通用公共许可证（GPL）保护的自由软件，全称是 &lt;code&gt;GNU Debugger&lt;/code&gt;，又常常被称为 &lt;code&gt;GNU symbolic debugger&lt;/code&gt; 或者 &lt;code&gt;GNU project debugger&lt;/code&gt;，能够帮助开发者调试程序，分析应用程序运行过程。目前支持调试 &lt;code&gt;C&lt;/code&gt;、 &lt;code&gt;C++&lt;/code&gt;、 &lt;code&gt;D&lt;/code&gt;、 &lt;code&gt;Go&lt;/code&gt;、 &lt;code&gt;Objective-C&lt;/code&gt;、 &lt;code&gt;Fortran&lt;/code&gt;、 &lt;code&gt;Java&lt;/code&gt;、 &lt;code&gt;OpenCL C&lt;/code&gt;、 &lt;code&gt;Pascal&lt;/code&gt;、 &lt;code&gt;assembly&lt;/code&gt;、 &lt;code&gt;Modula-2&lt;/code&gt;、 &lt;code&gt;Ada&lt;/code&gt; 等多种编程语言。&lt;/p&gt;
    
    </summary>
    
      <category term="GDB" scheme="http://AlbertGithubHome.github.io/blog/categories/GDB/"/>
    
    
      <category term="GDB" scheme="http://AlbertGithubHome.github.io/blog/tags/GDB/"/>
    
      <category term="manual" scheme="http://AlbertGithubHome.github.io/blog/tags/manual/"/>
    
  </entry>
  
  <entry>
    <title>gdb调试解决找不到源代码的问题</title>
    <link href="http://AlbertGithubHome.github.io/blog/2020/07/13/gdb%E8%B0%83%E8%AF%95%E8%A7%A3%E5%86%B3%E6%89%BE%E4%B8%8D%E5%88%B0%E6%BA%90%E4%BB%A3%E7%A0%81%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://AlbertGithubHome.github.io/blog/2020/07/13/gdb调试解决找不到源代码的问题/</id>
    <published>2020-07-13T15:54:14.000Z</published>
    <updated>2020-07-18T15:14:52.795Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>通过 <code>gdb</code> 启动程序，打好断点运行，开始调试输入 <code>list</code> 命令，结果发现找不到源代码，是不是很糟心，让我们来看看怎么解决这种情况。</p><a id="more"></a><p>先來说明我们要处理的情况，调试程序找不到源代码首先你得有源代码，如果编译完程序你把源代码删了，或者单独把执行程序拷贝到一个没有源代码的机器上，那么拜拜吧您嘞，这种情况不是本文能解决的。</p><p>如果你确实有源代码，正常编译源代码并且加入了 <code>-g</code> 选项，编译完之后没有改变源代码位置，那么调试的时候基本都会找到源代码，所以这种情况也不在我们的讨论范围之内。</p><p>分析到现在就剩下一种情况，程序编译完成之后我移动了代码的位置。实际工作中可能不会这么无聊，故意改变目录位置让调试程序找不到，但是工作中常常会出现发布机编译完代码要在开发机调试的情况，两台机器上的代码时一样的，但是源代码的位置可能放置的不同，那么在个人开发机上调试这样的程序就会找不到源代码，这也就是我们要解决的问题。</p><h1 id="找到源代码的必要性"><a href="#找到源代码的必要性" class="headerlink" title="找到源代码的必要性"></a>找到源代码的必要性</h1><p>其实在我看来找不到源代码的问题没有那么严重，编译程序里记录了文件名，行号等信息，可以在调试的时候对照着本地的源代码进行“盲调”，这种“盲调”的操作之前可没少干，因为线上环境中没有源代码，我只能一边对照着 <code>gdb</code> 调试输出的行号，一边对照本地的源代码进行程序分析，通过这种方法也解决了不少问题。</p><p>虽然看着源代码调试没有那么必要，但是如果可以看见那肯定是更好了，所以本文还是列举出最常见的处理方法，解决一下本来有代码，但因为目录不匹配无法正常调试的问题。</p><h1 id="涉及到的命令"><a href="#涉及到的命令" class="headerlink" title="涉及到的命令"></a>涉及到的命令</h1><p>下面几个命令是 <code>gdb</code> 命令，注意要放到和 <code>gdb</code> 交互命令行输入才可以，别管会不会，先混个脸熟，以后要经常用的：</p><ul><li><code>show dir</code></li><li><code>dir 目录</code></li><li><code>set dir 目录1:目录2:目录3</code></li><li><code>dir</code></li><li><code>pwd</code></li><li><code>cd 目录</code></li><li><code>set substitute-path from-path to-path</code></li></ul><h1 id="gdb怎样找源代码"><a href="#gdb怎样找源代码" class="headerlink" title="gdb怎样找源代码"></a>gdb怎样找源代码</h1><p>有时候很奇怪，代码明明就在那里，<code>gdb</code> 你睁开眼睛行不行，为什么你就是找不到呢？其实 <code>gdb</code> 也很苦的好不好，一直帮你查问题还要忍受着你每天的埋怨，到底是什么原因导致 <code>gdb</code> 对眼前的代码视而不见呢？</p><p>其实 <code>gdb</code> 查找代码也要遵循一定的规则，不能每次都全盘扫描吧，那不是得给它累死。举个例子吧，我们在安装一些软件，特别是一些命令行工具的时候，总是有一步要求你把工具或软件所在目录添加到环境变量中，这个变量的名字叫做 <code>Path</code>。</p><p>这个 <code>Path</code> 其实就是电脑上众多软件所在目录的集合，当你直接使用软件的程序时，会优先从 <code>Path</code> 这个集合中的目录下去找，成功找到就会直接调用，否则提醒你软件不存在。</p><h2 id="源代码目录集合"><a href="#源代码目录集合" class="headerlink" title="源代码目录集合"></a>源代码目录集合</h2><p>而在 <code>gdb</code> 的调试过程中也有这样一个目录集合，我暂且称它为 <code>SourcePathSet</code>，后面就用这个名字了，因为还要涉及到多种查找目录，请注意区分。</p><p><code>gdb</code> 在查找源码的时候首先在 <code>SourcePathSet</code> 中所包含的目录下找，如果找不到就会提示查找失败了，也就是这篇文章所提到的问题。</p><h2 id="源代码文件"><a href="#源代码文件" class="headerlink" title="源代码文件"></a>源代码文件</h2><p>程序在编译的过程中会记录源文件的名字和路径，这个路径可能是绝对路径，比如 <code>/mnt/d/main.cpp</code>，也可能是相对路径 <code>../main.cpp</code> ，究竟是哪一种取决于编译时使用的参数。</p><p>我们以绝对路径为例，比如文件名为 <code>/mnt/d/main.cpp</code>，我们可以把它拆分成包含路径和不包含路径两种形式：<code>/mnt/d/main.cpp</code> 和 <code>main.cpp</code>，当 <code>SourcePathSet</code> 中包含一个路径叫 <code>/mnt/e</code>时， <code>gdb</code> 搜索的路径包括以下几种：</p><ul><li><code>/mnt/d/main.cpp</code></li><li><code>/mnt/e/mnt/d/main.cpp</code></li><li><code>/mnt/e/main.cpp</code></li></ul><p>当源文件是相对路径 <code>../main.cpp</code> 的时候，那么搜索的路径就变成了下面两个：</p><ul><li><code>/mnt/e/../main.cpp</code></li><li><code>/mnt/e/main.cpp</code></li></ul><p>说到这里你可能就明白了，当 <code>gdb</code> 找不到源文件的时候，修改 <code>SourcePathSet</code> 就可以了，把想让它搜索的路径添加到 <code>SourcePathSet</code>，如果符合它的搜索规则，那么就可以找到了。</p><h2 id="目录集合的默认值"><a href="#目录集合的默认值" class="headerlink" title="目录集合的默认值"></a>目录集合的默认值</h2><p><code>SourcePathSet</code> 在 <code>gdb</code> 启动后开始生效，默认值并不是空，而是 <code>$cdir:$cwd</code>，这又是什么鬼？其中的 <code>$cdir</code> 叫做编译目录，是代码在编译时记录到程序中的，<code>$cwd</code> 表示当前的调试目录，可以通过 <code>cd</code> 命令来修改，要注意这个 <code>cd</code> 修改的是 <code>gdb</code> 会话中的当前目录，不会影响启动 <code>gdb</code> 前文件系统中的目录位置。</p><p>假设 <code>$cdir</code> 的值是 <code>/usr</code>，<code>cwd</code> 的值是 <code>/home/albert</code>，我们又添加了 <code>/mnt/e</code> 到 <code>SourcePathSet</code> 中，那么此时 <code>SourcePathSet</code> 的值为 <code>/mnt/e:$cdir:$cwd</code>，如果源文件的是 <code>/mnt/d/main.cpp</code>，查找的目录就会出现以下几种：</p><ul><li><code>/mnt/d/main.cpp</code></li><li><code>/mnt/e/mnt/d/main.cpp</code></li><li><code>/usr/mnt/d/main.cpp</code></li><li><code>/home/albert/mnt/d/main.cpp</code></li><li><code>/mnt/e/main.cpp</code></li><li><code>/usr/main.cpp</code></li><li><code>/home/albert/main.cpp</code></li></ul><h2 id="查看各种目录"><a href="#查看各种目录" class="headerlink" title="查看各种目录"></a>查看各种目录</h2><p>先做一下准备工作，编写一段简单代码，另存文件名为 <code>main.cpp</code>，保存在目录 <code>/mnt/d/cpp</code> 下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> c = a + b;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"c = "</span> &lt;&lt; c &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>切换到目录 <code>/mnt/d</code>下， 查看 <code>cpp</code> 目录下文件并使用 <code>g++</code> 编译，编译完成后将文件 <code>mian.cpp</code> 移动到 <code>/mnt</code> 目录下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:/mnt/d$ ls cpp/</span><br><span class="line">main.cpp</span><br><span class="line">albert@home-pc:/mnt/d$ g++ /mnt/d/cpp/main.cpp -g -o main</span><br><span class="line">albert@home-pc:/mnt/d$ ls main</span><br><span class="line">main</span><br><span class="line">albert@home-pc:/mnt/d$ sudo mv cpp/main.cpp ../</span><br><span class="line">[sudo] password <span class="keyword">for</span> albert:</span><br><span class="line">albert@home-pc:/mnt/d$ ls ../</span><br><span class="line">c  d  e  f  main.cpp</span><br></pre></td></tr></table></figure><p>启动 <code>gdb</code> 调试程序并打好断点，输入 <code>run</code> 运行发现，断点被触发，但是显示出 <code>No such file or directory.</code>，说明没有找到源代码文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:/mnt/d$ gdb -q main</span><br><span class="line">Reading symbols from main...done.</span><br><span class="line">(gdb) b 8</span><br><span class="line">Breakpoint 1 at 0x4008ac: file /mnt/d/cpp/main.cpp, line 8.</span><br><span class="line">(gdb) run</span><br><span class="line">Starting program: /mnt/d/main</span><br><span class="line"></span><br><span class="line">Breakpoint 1, main () at /mnt/d/cpp/main.cpp:8</span><br><span class="line">8   /mnt/d/cpp/main.cpp: No such file or directory.</span><br></pre></td></tr></table></figure><h3 id="查看源代码文件名和编译目录"><a href="#查看源代码文件名和编译目录" class="headerlink" title="查看源代码文件名和编译目录"></a>查看源代码文件名和编译目录</h3><p>直接在 <code>gdb</code> 命令行中输入 <code>info source</code> 回车就可以了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(gdb) info <span class="built_in">source</span></span><br><span class="line">Current <span class="built_in">source</span> file is /mnt/d/cpp/main.cpp</span><br><span class="line">Compilation directory is /mnt/d</span><br><span class="line">Source language is c++.</span><br><span class="line">Producer is GNU C++ 5.4.0 20160609 -mtune=generic -march=x86-64 -g -fstack-protector-strong.</span><br><span class="line">Compiled with DWARF 2 debugging format.</span><br><span class="line">Does not include preprocessor macro info.</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure><p>通过这个命令发现，源代码文件是 <code>/mnt/d/cpp/main.cpp</code>，编译目录是 <code>/mnt/d</code></p><h3 id="查看源代码搜索目录"><a href="#查看源代码搜索目录" class="headerlink" title="查看源代码搜索目录"></a>查看源代码搜索目录</h3><p>在 <code>gdb</code> 环境下输入 <code>show dir</code> 命令就可以显示 <code>SourcePathSet</code> 这个集合中都有哪些目录，由于还没有设置过现在还是默认值 <code>$cdir:$cwd</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(gdb) show dir</span><br><span class="line">Source directories searched: <span class="variable">$cdir</span>:<span class="variable">$cwd</span></span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure><h3 id="查看当前目录"><a href="#查看当前目录" class="headerlink" title="查看当前目录"></a>查看当前目录</h3><p>查看当前目录就比较简单了，直接 <code>pwd</code> 就搞定了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(gdb) <span class="built_in">pwd</span></span><br><span class="line">Working directory /mnt/d.</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure><p>我们“如愿以偿”的让 <code>gdb</code> 找不到代码了，从现在的环境来看，<code>$cdir</code> 和 <code>$cwd</code> 相同都是 <code>/mnt/d</code>，所以此时搜索的目录只有：</p><ul><li><code>/mnt/d/cpp/main.cpp</code></li><li><code>/mnt/d/mnt/d/cpp/main.cpp</code></li><li><code>/mnt/d/main.cpp</code></li></ul><p>而代码被我们移动到了<code>/mnt/main.cpp</code>，<code>gdb</code> 自然就找不到了，后面来看看具体怎么处理这种情况。</p><h1 id="具体示例"><a href="#具体示例" class="headerlink" title="具体示例"></a>具体示例</h1><p>说了这么多原理的东西，如果弄明白了这些很容易找到解决问题的办法，下面写一个完整点的例子，来感受一些具体怎么修复这个问题，新建三个文件 <code>mainpro.cpp</code>、<code>mymath.h</code>、<code>mymath.cpp</code>，目录结构和内容如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:/mnt/d$ tree /mnt/d/mainpro/</span><br><span class="line">/mnt/d/mainpro/</span><br><span class="line">|-- core</span><br><span class="line">|   `-- mainpro.cpp</span><br><span class="line">`-- kit</span><br><span class="line">    |-- mymath.cpp</span><br><span class="line">    `-- mymath.h</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//mainpro.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"../kit/mymath.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">2</span>;</span><br><span class="line">    mymath* m = <span class="keyword">new</span> mymath();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> c = m-&gt;add(a, b);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"c = "</span> &lt;&lt; c &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//mymath.h</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">mymath</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//mymath.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mymath.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> mymath::add(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> c = a + b;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>/mnt/d/mainpro</code> 目录下编译代码，然后将代码文件所在目录 <code>core</code> 和 <code>kit</code> 拷贝到 <code>/mnt/e/newpro</code> 目录下，将可执行文件拷贝到 <code>/home/albert</code> 目录下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:/mnt/d/mainpro$ g++ /mnt/d/mainpro/core/mainpro.cpp /mnt/d/mainpro/kit/mymath.cpp -g -o mainpro</span><br><span class="line">albert@home-pc:/mnt/d/mainpro$ tree</span><br><span class="line">.</span><br><span class="line">|-- core</span><br><span class="line">|   `-- mainpro.cpp</span><br><span class="line">|-- kit</span><br><span class="line">|   |-- mymath.cpp</span><br><span class="line">|   `-- mymath.h</span><br><span class="line">`-- mainpro</span><br><span class="line"></span><br><span class="line">2 directories, 4 files</span><br><span class="line">albert@home-pc:/mnt/d/mainpro$ mkdir /mnt/e/newpro</span><br><span class="line">albert@home-pc:/mnt/d/mainpro$ sudo mv core/ /mnt/e/newpro/</span><br><span class="line">albert@home-pc:/mnt/d/mainpro$ sudo mv kit/ /mnt/e/newpro/</span><br><span class="line">albert@home-pc:/mnt/d/mainpro$ mv mainpro /home/albert/</span><br></pre></td></tr></table></figure><p>在 <code>/home/albert</code> 目录下启动 <code>gdb</code> 开始调试，先在 <code>main</code> 函数打断点，查询源文件路径和编译目录等信息；</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:~$ gdb -q mainpro</span><br><span class="line">Reading symbols from mainpro...done.</span><br><span class="line">(gdb) b main</span><br><span class="line">Breakpoint 1 at 0x4008de: file /mnt/d/mainpro/core/mainpro.cpp, line 7.</span><br><span class="line">(gdb) run</span><br><span class="line">Starting program: /home/albert/mainpro</span><br><span class="line"></span><br><span class="line">Breakpoint 1, main () at /mnt/d/mainpro/core/mainpro.cpp:7</span><br><span class="line">7   /mnt/d/mainpro/core/mainpro.cpp: No such file or directory.</span><br><span class="line">(gdb) info <span class="built_in">source</span></span><br><span class="line">Current <span class="built_in">source</span> file is /mnt/d/mainpro/core/mainpro.cpp</span><br><span class="line">Compilation directory is /mnt/d/mainpro</span><br><span class="line">Source language is c++.</span><br><span class="line">Producer is GNU C++ 5.4.0 20160609 -mtune=generic -march=x86-64 -g -fstack-protector-strong.</span><br><span class="line">Compiled with DWARF 2 debugging format.</span><br><span class="line">Does not include preprocessor macro info.</span><br><span class="line">(gdb) list</span><br><span class="line">2   <span class="keyword">in</span> /mnt/d/mainpro/core/mainpro.cpp</span><br><span class="line">(gdb) <span class="built_in">pwd</span></span><br><span class="line">Working directory /home/albert.</span><br><span class="line">(gdb) show dir</span><br><span class="line">Source directories searched: <span class="variable">$cdir</span>:<span class="variable">$cwd</span></span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure><p>果然找不到源代码了，从上面的调试信息来看，可以得到以下信息：</p><ul><li>源代码文件为 <code>/mnt/d/mainpro/core/mainpro.cpp</code></li><li>程序编译目录为 <code>/mnt/d/mainpro</code></li><li>当前目录为 <code>/home/albert</code></li></ul><p>而源代码查找列表中只有 <code>$cdir:$cwd</code>，说明只包含 <code>/mnt/d/mainpro</code> 和 <code>/home/albert</code>，那么查找的目录有：</p><ul><li><code>/mnt/d/mainpro/core/mainpro.cpp</code></li><li><code>/mnt/d/mainpro/mnt/d/mainpro/core/mainpro.cpp</code></li><li><code>/home/albert/mnt/d/mainpro/core/mainpro.cpp</code></li><li><code>/mnt/d/mainpro/mainpro.cpp</code></li><li><code>/home/albert/mainpro.cpp</code></li></ul><p>这些目录显然找不到源代码文件了，因为文件已经被我移动到 <code>/mnt/e/newpro/</code> 目录下了，也就是 <code>/mnt/e/newpro/core/mainpro.cpp</code>，下面来尝试一些解决方法。</p><h2 id="使用-dir-命令解决"><a href="#使用-dir-命令解决" class="headerlink" title="使用 dir 命令解决"></a>使用 dir 命令解决</h2><p>刚才说了源代码查找集合 <code>SourcePathSet</code> 中只有 <code>$cdir:$cwd</code>，我们可以自己加一个嘛，比如像下面这样：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">(gdb) dir /mnt/e/newpro/core/</span><br><span class="line">Source directories searched: /mnt/e/newpro/core:<span class="variable">$cdir</span>:<span class="variable">$cwd</span></span><br><span class="line">(gdb) list</span><br><span class="line">2   <span class="comment">#include &lt;iostream&gt;</span></span><br><span class="line">3   using namespace std;</span><br><span class="line">4</span><br><span class="line">5   int main()</span><br><span class="line">6   &#123;</span><br><span class="line">7       int a = 1, b = 2;</span><br><span class="line">8       mymath* m = new mymath();</span><br><span class="line">9</span><br><span class="line">10      int c = m-&gt;add(a, b);</span><br><span class="line">11      cout &lt;&lt; <span class="string">"c = "</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure><p>这样就可以找到了，我们接着在 <code>add</code> 函数上下个断点，继续执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">(gdb) b mymath::add</span><br><span class="line">Breakpoint 2 at 0x4009a6: file /mnt/d/mainpro/kit/mymath.cpp, line 6.</span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line"></span><br><span class="line">Breakpoint 2, mymath::add (this=0x613c20, a=1, b=2) at /mnt/d/mainpro/kit/mymath.cpp:6</span><br><span class="line">6   /mnt/d/mainpro/kit/mymath.cpp: No such file or directory.</span><br><span class="line">(gdb) list</span><br><span class="line">1   <span class="keyword">in</span> /mnt/d/mainpro/kit/mymath.cpp</span><br><span class="line">(gdb) info <span class="built_in">source</span></span><br><span class="line">Current <span class="built_in">source</span> file is /mnt/d/mainpro/kit/mymath.cpp</span><br><span class="line">Source language is c++.</span><br><span class="line">Producer is GNU C++ 5.4.0 20160609 -mtune=generic -march=x86-64 -g -fstack-protector-strong.</span><br><span class="line">Compiled with DWARF 2 debugging format.</span><br><span class="line">Does not include preprocessor macro info.</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure><p>结果发现又找不到文件 <code>/mnt/d/mainpro/kit/mymath.cpp</code> 了，因为和之前不是一个文件，这个文件在其他的目录下，所以还要使用 <code>dir</code> 命令，把新的目录加到源代码查找集合 <code>SourcePathSet</code> 中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">(gdb) dir /mnt/e/newpro/kit/</span><br><span class="line">Source directories searched: /mnt/e/newpro/kit:/mnt/e/newpro/core:<span class="variable">$cdir</span>:<span class="variable">$cwd</span></span><br><span class="line">(gdb) list</span><br><span class="line">1   <span class="comment">#include "../kit/mymath.h"</span></span><br><span class="line">2   <span class="comment">#include &lt;iostream&gt;</span></span><br><span class="line">3   using namespace std;</span><br><span class="line">4</span><br><span class="line">5   int main()</span><br><span class="line">6   &#123;</span><br><span class="line">7       int a = 1, b = 2;</span><br><span class="line">8       mymath* m = new mymath();</span><br><span class="line">9</span><br><span class="line">10      int c = m-&gt;add(a, b);</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure><p>这次又能成功找到了，可是如果有好多个文件要调试，难道要把所有的目录都加进去吗？其实可以有简便方法的，在启动 <code>gdb</code>的时候可以指定搜索的源代码路径，这些路径都会被加到到源代码查找集合 <code>SourcePathSet</code> 中，具体操作如下，先退出<code>gdb</code>，然后重新加参数启动如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:~$ gdb -q mainpro `find /mnt/e/newpro/ -<span class="built_in">type</span> d -<span class="built_in">printf</span> <span class="string">'-d %p '</span>`</span><br><span class="line">Reading symbols from mainpro...done.</span><br><span class="line">(gdb) show dir</span><br><span class="line">Source directories searched: /mnt/e/newpro/kit:/mnt/e/newpro/core:/mnt/e/newpro:<span class="variable">$cdir</span>:<span class="variable">$cwd</span></span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure><p>其实这条命令的本来面目是 <code>gdb -q mainpro -d xxxxx</code>，只不过这组合了 <code>find</code> 命令以后使用起来更加方便了，可以把指定目录下的子目录全都添加到参数中</p><h2 id="使用-cd-命令解决"><a href="#使用-cd-命令解决" class="headerlink" title="使用 cd 命令解决"></a>使用 cd 命令解决</h2><p>如果是临时调试倒是用不到上面设置启动参数那么麻烦，因为变量 <code>$cwd</code> 也在搜索集合中，既然在编译时记录的源文件被改变了位置，那么我们调整我们的当前位置，让代码出现搜索路径中，还是上面的这个例子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:~$ <span class="built_in">pwd</span></span><br><span class="line">/home/albert</span><br><span class="line">albert@home-pc:~$ gdb -q mainpro</span><br><span class="line">Reading symbols from mainpro...done.</span><br><span class="line">(gdb) b main</span><br><span class="line">Breakpoint 1 at 0x4008de: file /mnt/d/mainpro/core/mainpro.cpp, line 7.</span><br><span class="line">(gdb) r</span><br><span class="line">Starting program: /home/albert/mainpro</span><br><span class="line"></span><br><span class="line">Breakpoint 1, main () at /mnt/d/mainpro/core/mainpro.cpp:7</span><br><span class="line">7   /mnt/d/mainpro/core/mainpro.cpp: No such file or directory.</span><br><span class="line">(gdb) list</span><br><span class="line">2   <span class="keyword">in</span> /mnt/d/mainpro/core/mainpro.cpp</span><br><span class="line">(gdb) <span class="built_in">cd</span> /mnt/e/newpro/core/</span><br><span class="line">Working directory /mnt/e/newpro/core.</span><br><span class="line">(gdb) list</span><br><span class="line">2   <span class="comment">#include &lt;iostream&gt;</span></span><br><span class="line">3   using namespace std;</span><br><span class="line">4</span><br><span class="line">5   int main()</span><br><span class="line">6   &#123;</span><br><span class="line">7       int a = 1, b = 2;</span><br><span class="line">8       mymath* m = new mymath();</span><br><span class="line">9</span><br><span class="line">10      int c = m-&gt;add(a, b);</span><br><span class="line">11      cout &lt;&lt; <span class="string">"c = "</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure><p>上面的操作通过 <code>cd /mnt/e/newpro/core/</code> 命令直接进入了源代码目录，当然就找到了，但是这还是会有点问题，当碰到需要调试好几个文件的时候就需要使用 <code>cd</code> 命令跳来跳去，要想一劳永逸，请看下面这个方法。</p><h2 id="使用-set-substitute-path-命令解决"><a href="#使用-set-substitute-path-命令解决" class="headerlink" title="使用 set substitute-path 命令解决"></a>使用 set substitute-path 命令解决</h2><p>我们移动源代码的时候往往会整个目录移动，或者说开发机和发布机上面的代码文件组织结构是一样，只是所在的磁盘位置是不一样的，所以如果可以设置用一个路径替换原代码文件的路径就好了， <code>set substitute-path from-path to-path</code> 这个命令就可以达到想要的目的，这个命令还可以简写成 <code>set substitute from-path to-path</code>，比如还是前面的例子，源代码从 <code>/mnt/d/mainrpo</code> 目录整体移动到了 <code>/mnt/e/newpro</code> 目录，调试时找不到源代码可以使用 <code>set substitute /mnt/d/mainrpo /mnt/e/newpro</code> 命令来指定替换目录，这样就可以找到源代码啦，下面来测试一下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc:~$ gdb -q mainpro</span><br><span class="line">Reading symbols from mainpro...done.</span><br><span class="line">(gdb) <span class="built_in">set</span> substitute-path /mnt/d/mainrpo /mnt/e/newpro</span><br><span class="line">(gdb) b main</span><br><span class="line">Breakpoint 1 at 0x4008de: file /mnt/d/mainpro/core/mainpro.cpp, line 7.</span><br><span class="line">(gdb) run</span><br><span class="line">Starting program: /home/albert/mainpro</span><br><span class="line"></span><br><span class="line">Breakpoint 1, main () at /mnt/d/mainpro/core/mainpro.cpp:7</span><br><span class="line">7   /mnt/d/mainpro/core/mainpro.cpp: No such file or directory.</span><br><span class="line">(gdb) <span class="built_in">cd</span> /mnt/e/newpro/</span><br><span class="line">Working directory /mnt/e/newpro.</span><br><span class="line">(gdb) list</span><br><span class="line">2   /mnt/d/mainpro/core/mainpro.cpp: No such file or directory.</span><br><span class="line">(gdb) <span class="built_in">set</span> substitute-path /mnt/d/mainpro /mnt/e/newpro</span><br><span class="line">(gdb) list 0</span><br><span class="line">1   <span class="comment">#include "../kit/mymath.h"</span></span><br><span class="line">2   <span class="comment">#include &lt;iostream&gt;</span></span><br><span class="line">3   using namespace std;</span><br><span class="line">4</span><br><span class="line">5   int main()</span><br><span class="line">6   &#123;</span><br><span class="line">7       int a = 1, b = 2;</span><br><span class="line">8       mymath* m = new mymath();</span><br><span class="line">9</span><br><span class="line">10      int c = m-&gt;add(a, b);</span><br><span class="line">(gdb) info <span class="built_in">source</span></span><br><span class="line">Current <span class="built_in">source</span> file is /mnt/d/mainpro/core/mainpro.cpp</span><br><span class="line">Compilation directory is /mnt/d/mainpro</span><br><span class="line">Located <span class="keyword">in</span> /mnt/e/newpro/core/mainpro.cpp</span><br><span class="line">Contains 14 lines.</span><br><span class="line">Source language is c++.</span><br><span class="line">Producer is GNU C++ 5.4.0 20160609 -mtune=generic -march=x86-64 -g -fstack-protector-strong.</span><br><span class="line">Compiled with DWARF 2 debugging format.</span><br><span class="line">Does not include preprocessor macro info.</span><br><span class="line">(gdb) <span class="built_in">pwd</span></span><br><span class="line">Working directory /home/albert.</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure><p>通过调试信息 <code>Located in /mnt/e/newpro/core/mainpro.cpp</code> 可以看到，果然在新的位置找到了源代码。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>调试的时候找不到源码有多种解决方法，需要根据实际情况选择最合适的解决方案。</li><li>编译时使用绝对路径时，推荐使用 <code>set substitute-path from-path to-path</code> 的方式。</li><li>编译时使用相对路径时，使用 <code>set substitute from-path to-path</code> 或者 <code>dir new-path</code> 都可以。</li><li>对于临时查找一个问题，单独调试某一个文件时使用 <code>cd</code> 命令就可以搞定了。</li><li>直接在 <code>gdb</code> 环境输入 <code>dir</code> 命令回车确认，可以重置 <code>dir 目录</code> 或者 <code>set dir 目录</code> 命令修改过的源代码搜索目录集合。</li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/107274490" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>当人的才华不足以撑起个人的欲望时就会感到焦虑，当面对不利的情况和事件却又无力改变时就会感到愤怒，而弱肉强食一直都是生活的本质，惟有强大才是解决这一切负面情绪的良药~</p><p>2020-7-18 15:36:53</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;通过 &lt;code&gt;gdb&lt;/code&gt; 启动程序，打好断点运行，开始调试输入 &lt;code&gt;list&lt;/code&gt; 命令，结果发现找不到源代码，是不是很糟心，让我们来看看怎么解决这种情况。&lt;/p&gt;
    
    </summary>
    
      <category term="linux" scheme="http://AlbertGithubHome.github.io/blog/categories/linux/"/>
    
    
      <category term="C/C++" scheme="http://AlbertGithubHome.github.io/blog/tags/C-C/"/>
    
      <category term="source" scheme="http://AlbertGithubHome.github.io/blog/tags/source/"/>
    
      <category term="linux" scheme="http://AlbertGithubHome.github.io/blog/tags/linux/"/>
    
      <category term="gdb" scheme="http://AlbertGithubHome.github.io/blog/tags/gdb/"/>
    
      <category term="dir" scheme="http://AlbertGithubHome.github.io/blog/tags/dir/"/>
    
      <category term="path" scheme="http://AlbertGithubHome.github.io/blog/tags/path/"/>
    
  </entry>
  
  <entry>
    <title>Shell脚本中获取命令运行结果、特殊变量使用、条件判断等常用操作</title>
    <link href="http://AlbertGithubHome.github.io/blog/2020/07/07/Shell%E8%84%9A%E6%9C%AC%E4%B8%AD%E8%8E%B7%E5%8F%96%E5%91%BD%E4%BB%A4%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C%E3%80%81%E6%9D%A1%E4%BB%B6%E5%88%A4%E6%96%AD%E7%AD%89%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/"/>
    <id>http://AlbertGithubHome.github.io/blog/2020/07/07/Shell脚本中获取命令运行结果、条件判断等常用操作/</id>
    <published>2020-07-07T15:27:09.000Z</published>
    <updated>2020-07-11T07:54:07.068Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近在处理一个 <code>Python</code> 局部变量的作用域问题时发现有些奇怪，想起了之前常写的 <code>Lua</code> 脚本，于是想写个函数测试一下，结果发现短短的十几行代码出现了多个错误，这可是我写了近三年的代码啊，才放下半年就记不清了，所以知识这个东西还是要不断“温故”，今天要总结的 <code>Shell</code> 脚本命令也是，基本属于一看就会，一写不对的状态，所以还是要把常用的操作总结到一起，方便查找和复习。</p><a id="more"></a><h1 id="获取命令执行结果"><a href="#获取命令执行结果" class="headerlink" title="获取命令执行结果"></a>获取命令执行结果</h1><p>脚本中常常要获取一些命令的执行结果，比如当前目录 <code>pwd</code>、当前时间 <code>date</code> 等等，如果在控制台时直接输入后回车就能看到结果，但是在 <code>Shell</code> 脚本中却不能这样做，常见的有以下两种方式。</p><h2 id="使用反引号-command-来执行命令"><a href="#使用反引号-command-来执行命令" class="headerlink" title="使用反引号 `command `来执行命令"></a>使用反引号 <code>`</code>command <code>`</code>来执行命令</h2><p>反引号就是键盘上 <code>Tab</code> 键上方的那个按键对应的符号，常写 Markdown 的小伙伴知道这个符号就是包裹代码块的那个符号，在 <code>Shell</code> 脚本中被用来执行命令得到结果，举个简单的例子</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">result=date</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$result</span></span><br><span class="line"></span><br><span class="line">result=`date`</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$result</span></span><br></pre></td></tr></table></figure><p>将上述命令保存到文件 <code>cmd.sh</code> 中运行 <code>./cmd.sh</code> 得到结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ./cmd.sh</span><br><span class="line">date</span><br><span class="line">Tue Jul 7 23:48:03 CST 2020</span><br></pre></td></tr></table></figure><p>从运行结果可以看出，如果不加反引号，我们常用的这些命令会被当成普通的字符串处理。</p><h2 id="使用括号组合-command-来执行命令"><a href="#使用括号组合-command-来执行命令" class="headerlink" title="使用括号组合 $(command) 来执行命令"></a>使用括号组合 $(command) 来执行命令</h2><p>除了上面的反引号，使用美元符和小括号组合也可以在 Shell 脚本中运行命令，使用同样的例子测试</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">result=`date`</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$result</span></span><br><span class="line"></span><br><span class="line">result=$(date)</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$result</span></span><br></pre></td></tr></table></figure><p>保存到文件 <code>cmd.sh</code> 中运行 <code>./cmd.sh</code> 得到结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ./cmd.sh</span><br><span class="line">Tue Jul 7 23:53:27 CST 2020</span><br><span class="line">Tue Jul 7 23:53:27 CST 2020</span><br></pre></td></tr></table></figure><p>对比可以看出两种方式在这个命令下运行结果是一样的。</p><h2 id="两种方式的区别"><a href="#两种方式的区别" class="headerlink" title="两种方式的区别"></a>两种方式的区别</h2><p>虽然上述两种方式都可以在 <code>Shell</code> 脚本中得到命令运行的结果，但是有一点是不一样的，那就是反引号执行命令不支持嵌套，不能实现反引号中再出现反引号，而 <code>$(command)</code>的方式是支持嵌套的，关于这一点可以看下面这个例子。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> $(ls $(<span class="built_in">pwd</span>))</span><br><span class="line">cmd.sh</span><br></pre></td></tr></table></figure><p>分析一下这个命令 <code>echo $(ls $(pwd))</code>，最里面的命令是 <code>$(pwd)</code>先执行得到当前目录，然后执行命令 <code>$(ls 当前目录)</code>得到目录下的文件，再通过 <code>echo</code> 命令把这个结果输出，就得到了 <code>cmd.sh</code> 这个文件名，因为我这个目录下只有这一个文件。</p><p>系统的命令使用反引号的方式改写就不生效了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> `ls `<span class="built_in">pwd</span>``</span><br><span class="line">cmd.shpwd</span><br></pre></td></tr></table></figure><p>我们还是仿照上面嵌套来写，但是 <code>echo</code> 后面的内容其实被分成了3部分，一个<code>ls</code>命令，一个<code>pwd</code>字符串、一个空命令，这样就能解释运行结果 <code>cmd.shpwd</code>了。</p><p>对照着结果我们就可以知道了， <code>$(command)</code>的方式更加强大，可以支持命令的嵌套，应用更广泛一点，而反引号的方式跟多出现在之前的脚本中。</p><h1 id="特殊变量使用"><a href="#特殊变量使用" class="headerlink" title="特殊变量使用"></a>特殊变量使用</h1><p>从学习语言的第一天起就记住了变量名中只能有数字、字母、下划线，并且数字不能打头（Shell中只能字母开头），但是在 <code>Shell</code> 脚本中有一些特殊的变量，包含各种奇奇怪怪的符号。</p><h2 id="0-1-2-…"><a href="#0-1-2-…" class="headerlink" title="$0 $1 $2 …"></a>$0 $1 $2 …</h2><p>这些是运行 <code>Shell</code> 脚本时传递给脚本的命令行参数。命令行参数用 $n 表示，$0表示当前脚本的文件名，$1 表示第一个参数，$2 表示第二个参数，依次类推，可以类比 Windows 下的 <code>%0</code>、<code>%1</code>、<code>%2</code>…</p><h2 id=""><a href="#" class="headerlink" title="$$"></a>$$</h2><p>当前 <code>Shell</code> 脚本的进程ID。如果在命令行执行得到的是当前 <code>bash</code> 的进程ID，如果放到脚本中，得到的是脚本的进程ID。</p><h2 id="-1"><a href="#-1" class="headerlink" title="$?"></a>$?</h2><p>可以获取上一个命令执行后的返回结果。</p><h2 id="-2"><a href="#-2" class="headerlink" title="$"></a>$</h2><p>传递给脚本的命令行参数的个数。</p><h2 id="-3"><a href="#-3" class="headerlink" title="$*"></a>$*</h2><p>传递给脚本的命令行参数的所有参数。</p><h2 id="-4"><a href="#-4" class="headerlink" title="$@"></a>$@</h2><p>传递给脚本的命令行参数的所有参数，与 <code>$*</code> 稍有不同。</p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>写个脚本测试一下，新建 <code>cmdargs.sh</code> 文件，编写下面代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> \<span class="variable">$0</span> is <span class="variable">$0</span></span><br><span class="line"><span class="built_in">echo</span> \<span class="variable">$1</span> is <span class="variable">$1</span></span><br><span class="line"><span class="built_in">echo</span> \<span class="variable">$2</span> is <span class="variable">$2</span></span><br><span class="line"><span class="built_in">echo</span> \$$ is $$</span><br><span class="line"><span class="built_in">echo</span> \<span class="variable">$#</span> is <span class="variable">$#</span></span><br><span class="line"><span class="built_in">echo</span> \$* is $*</span><br><span class="line"><span class="built_in">echo</span> \<span class="variable">$@</span> is <span class="variable">$@</span></span><br></pre></td></tr></table></figure><p>先执行 <code>./cmdargs.sh</code> 脚本， 然后输出 <code>$?</code> 脚本的退出状态，运行结果如下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ ./cmdargs.sh I love my daughter</span><br><span class="line"><span class="variable">$0</span> is ./cmdargs.sh</span><br><span class="line"><span class="variable">$1</span> is I</span><br><span class="line"><span class="variable">$2</span> is love</span><br><span class="line">$$ is 197</span><br><span class="line"><span class="variable">$#</span> is 4</span><br><span class="line">$* is I love my daughter</span><br><span class="line"><span class="variable">$@</span> is I love my daughter</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">echo</span> $?</span><br><span class="line">0</span><br></pre></td></tr></table></figure><h2 id="和-的区别"><a href="#和-的区别" class="headerlink" title="$* 和 $@ 的区别"></a><code>$*</code> 和 <code>$@</code> 的区别</h2><p>对照这个源码和输出结果，这些特殊变量应该可以分清楚了，其中 <code>$*</code> 和 <code>$@</code> 都是把所有内容都列出来了，但它俩还是有点区别的，当这两个变量都被双引号包裹时，通过 <code>for</code> 循环会得到不同结果，写个脚本 <code>cmdargs2.sh</code> 试一下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"test for \"\$*\""</span></span><br><span class="line"><span class="keyword">for</span> var <span class="keyword">in</span> <span class="string">"$*"</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"<span class="variable">$var</span>"</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"test for \"\$@\""</span></span><br><span class="line"><span class="keyword">for</span> var <span class="keyword">in</span> <span class="string">"<span class="variable">$@</span>"</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"<span class="variable">$var</span>"</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>运行结果如下, <code>&quot;$*&quot;</code>把所有的参数当成了一个整体，而 <code>&quot;$@&quot;</code> 把各个参数都拆分开了，可以通过循环依次打印出来。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ ./cmdargs2.sh I love my daughter</span><br><span class="line"><span class="built_in">test</span> <span class="keyword">for</span> <span class="string">"$*"</span></span><br><span class="line">I love my daughter</span><br><span class="line"><span class="built_in">test</span> <span class="keyword">for</span> <span class="string">"<span class="variable">$@</span>"</span></span><br><span class="line">I</span><br><span class="line">love</span><br><span class="line">my</span><br><span class="line">daughter</span><br></pre></td></tr></table></figure><h1 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h1><p>说起条件判断第一反应就是 <code>if</code> 了，在 <code>Shell</code> 脚本中也有 <code>if</code> 语句，同样是条件判断的中坚力量，先来看看 <code>if</code> 语句的写法：</p><h2 id="if-语句格式"><a href="#if-语句格式" class="headerlink" title="if 语句格式"></a><code>if</code> 语句格式</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ -d <span class="variable">$filename</span> ]; <span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"this is a directory."</span></span><br><span class="line"><span class="keyword">elif</span> [ -a <span class="variable">$filename</span> ]; <span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"the file is exist."</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"the file is not exist."</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p>直接提供一个最复杂的情况，如果不需要 <code>elif</code> 或者 <code>else</code> 分支，直接删掉就可以，但是 <code>if</code>、<code>then</code>、<code>fi</code> 这些都是必须的，并且中括号里面的表达式与中括号之间都要有空格，如果挨着写会报错的。</p><h2 id="中括号-的作用"><a href="#中括号-的作用" class="headerlink" title="中括号 [] 的作用"></a>中括号 <code>[]</code> 的作用</h2><p>一度认为 <code>if</code> 条件语句就是这样写，中括号 <code>[]</code> 应该是语法的一部分，但是查询后发现这居然是一个命令，和 <code>ls</code>，<code>pwd</code> 一样是一个可以执行命令，放在 <code>if</code> 条件判断时基本等同于 <code>test</code> 命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">which</span> [</span><br><span class="line">/usr/bin/[</span><br><span class="line">$ <span class="built_in">which</span> <span class="built_in">test</span></span><br><span class="line">/usr/bin/<span class="built_in">test</span></span><br></pre></td></tr></table></figure><p>看着这个查询结果感觉神奇吧，此外还有一个 <code>[[]]</code> 双中括号的操作，这个就不是命令了，而是 <code>Shell</code> 的一个关键字，比 <code>[]</code> 要强大的多。</p><h2 id="具体条件"><a href="#具体条件" class="headerlink" title="具体条件"></a>具体条件</h2><p><code>Shell</code> 脚本最常见的条件就是文件判断，数字判断和字符串判断了，接下来列举一下这些判断的常见写法。</p><h3 id="文件判断"><a href="#文件判断" class="headerlink" title="文件判断"></a>文件判断</h3><table><thead><tr><th style="text-align:center">命令</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">-a $filename</td><td style="text-align:center">文件存在时为真</td></tr><tr><td style="text-align:center">-d $filename</td><td style="text-align:center">文件名对应的是目录时为真</td></tr><tr><td style="text-align:center">-s $filename</td><td style="text-align:center">文件非空时为真</td></tr><tr><td style="text-align:center">-r $filename</td><td style="text-align:center">文件可读时为真</td></tr><tr><td style="text-align:center">-w $filename</td><td style="text-align:center">文件可写时为真</td></tr><tr><td style="text-align:center">-x $filename</td><td style="text-align:center">文件可执行时为真</td></tr></tbody></table><h3 id="数字判断"><a href="#数字判断" class="headerlink" title="数字判断"></a>数字判断</h3><table><thead><tr><th style="text-align:center">命令</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">n1 -eq n2</td><td style="text-align:center">n1等于n2时为真</td></tr><tr><td style="text-align:center">n1 -ne n2</td><td style="text-align:center">n1不等n2时为真</td></tr><tr><td style="text-align:center">n1 -gt n2</td><td style="text-align:center">n1大于n2时为真</td></tr><tr><td style="text-align:center">n1 -lt n2</td><td style="text-align:center">n1小于n2时为真</td></tr><tr><td style="text-align:center">n1 -ge n2</td><td style="text-align:center">n1大于等于n2时为真</td></tr><tr><td style="text-align:center">n1 -le n2</td><td style="text-align:center">n1小于等于n2时为真</td></tr></tbody></table><h3 id="字符串判断"><a href="#字符串判断" class="headerlink" title="字符串判断"></a>字符串判断</h3><table><thead><tr><th style="text-align:center">命令</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">-n str1</td><td style="text-align:center">str1字符串不为空串时值为真</td></tr><tr><td style="text-align:center">-z str1</td><td style="text-align:center">str1字符串为空串时值为真</td></tr><tr><td style="text-align:center">str1 == str2</td><td style="text-align:center">str1与str2相等时为真</td></tr><tr><td style="text-align:center">str1 != str2</td><td style="text-align:center">str1与str2不等时为真</td></tr><tr><td style="text-align:center">str1 &gt; str2</td><td style="text-align:center">按字典序str1排在str2后面时为真</td></tr><tr><td style="text-align:center">str1 &lt; str2</td><td style="text-align:center">按字典序str1排在str2前面时为真</td></tr></tbody></table><h3 id="数字判断特殊写法"><a href="#数字判断特殊写法" class="headerlink" title="数字判断特殊写法"></a>数字判断特殊写法</h3><table><thead><tr><th style="text-align:center">命令</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center"><code>((&quot;$n1&quot; == &quot;$n2&quot;))</code></td><td style="text-align:center">n1等于n2时为真</td></tr><tr><td style="text-align:center"><code>((&quot;$n1&quot; != &quot;$n2&quot;))</code></td><td style="text-align:center">n1不等n2时为真</td></tr><tr><td style="text-align:center"><code>((&quot;$n1&quot; &gt; &quot;$n2&quot;))</code></td><td style="text-align:center">n1大于n2时为真</td></tr><tr><td style="text-align:center"><code>((&quot;$n1&quot; &lt; &quot;$n2&quot;))</code></td><td style="text-align:center">n1小于n2时为真</td></tr><tr><td style="text-align:center"><code>((&quot;$n1&quot; &gt;= &quot;$n2&quot;))</code></td><td style="text-align:center">n1大于等于n2时为真</td></tr><tr><td style="text-align:center"><code>((&quot;$n1&quot; &lt;= &quot;$n2&quot;))</code></td><td style="text-align:center">n1小于等于n2时为真</td></tr></tbody></table><h3 id="逻辑关系运算符"><a href="#逻辑关系运算符" class="headerlink" title="逻辑关系运算符"></a>逻辑关系运算符</h3><table><thead><tr><th style="text-align:center">命令</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">-a</td><td style="text-align:center">与操作，用于<code>[]</code> 和 <code>test</code> 操作符</td></tr><tr><td style="text-align:center">-o</td><td style="text-align:center">或操作，用于<code>[]</code> 和 <code>test</code> 操作符</td></tr><tr><td style="text-align:center">！</td><td style="text-align:center">取反操作，用于<code>[]</code> 、 <code>test</code> 操作符 和 <code>[[]]</code> 关键字</td></tr><tr><td style="text-align:center">&amp;&amp;</td><td style="text-align:center">与操作，用于<code>[[]]</code> 关键字</td></tr><tr><td style="text-align:center">\</td><td style="text-align:center">\</td><td></td><td>或操作，用于<code>[[]]</code> 关键字</td></tr></tbody></table><p>这些逻辑写法千奇百怪的，写两个例子就慢慢就慢慢理解了，比如判断一个字符串不为空，并且这个字符串指定的目录还存在就可以写成</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ -n <span class="string">"<span class="variable">$1</span>"</span> -a -d <span class="string">"<span class="variable">$1</span>"</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$1</span> directory is exist</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p>使用双小括号来比较数值变量，写在双小括号中的变量前面可以不加 <code>$</code> 符号，还有诸多特权等着你去发现</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">num1=<span class="variable">$1</span></span><br><span class="line">num2=<span class="variable">$2</span></span><br><span class="line"><span class="keyword">if</span> (( num1 &gt; num2)); <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> num1 \&gt; num2</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p>总之在学习这些条件比较的时候踩了不少坑，有很多情况都没有注意到，不过慢慢也适应了这种语法，但还是免不了会出现一个小问题，这里提供一个 <code>Shell</code> 语法检查的在线网站 <a href="https://www.shellcheck.net/" target="_blank" rel="noopener">《shellcheck》</a>，将要检查的脚本放到页面上检测，会给出详细的错误信息，当然也有命令版本，可以自己到对应的 github 页面上下载哦~</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li><code>Shell</code> 脚本中获取命令的执行结果，可以通过反引号<code>`</code>command<code>`</code>，或者小括号 <code>$(command)</code> 的方式得到</li><li><code>Shell</code> 脚本中有一系列 <code>$</code> 开头的变量，用好他们是脚本和函数传递参数的关键</li><li><code>Shell</code> 脚本中的条件判断对于初学者来说很头大，有许多注意的点要记住，判断形式也多种多样</li><li>脚本中有单引号、双引号、反引号，简单来记就是单引号中原样输出，双引号中变量求值后输出，反引号中只能写需要执行的命令</li><li>脚本中还要中括号、双中括号、小括号、双小括号等，上面都提到过，可以自己练习下，具体的细节怕是要单独总结了，放到一起太多了</li><li>脚本的中的分号起到语句结束的作用，如果有换行就不需要分号了，比如 <code>if</code> 条件后面的 <code>then</code> 如果换行，那么 <code>then</code> 前面的分号可以省略</li><li>再记住一个坑，脚本赋值等号两端不能有空格，脚本判断等号两端必须有空格</li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/107147803" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>有些局，选择不入便立于不败之地，选择介入，即使曾身经百战，也恐难全身而退，更不要谈什么收益了~</p></blockquote><hr><blockquote><p>2020-7-11 00:30:00</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;最近在处理一个 &lt;code&gt;Python&lt;/code&gt; 局部变量的作用域问题时发现有些奇怪，想起了之前常写的 &lt;code&gt;Lua&lt;/code&gt; 脚本，于是想写个函数测试一下，结果发现短短的十几行代码出现了多个错误，这可是我写了近三年的代码啊，才放下半年就记不清了，所以知识这个东西还是要不断“温故”，今天要总结的 &lt;code&gt;Shell&lt;/code&gt; 脚本命令也是，基本属于一看就会，一写不对的状态，所以还是要把常用的操作总结到一起，方便查找和复习。&lt;/p&gt;
    
    </summary>
    
      <category term="shell" scheme="http://AlbertGithubHome.github.io/blog/categories/shell/"/>
    
    
      <category term="if" scheme="http://AlbertGithubHome.github.io/blog/tags/if/"/>
    
      <category term="Shell" scheme="http://AlbertGithubHome.github.io/blog/tags/Shell/"/>
    
      <category term="command" scheme="http://AlbertGithubHome.github.io/blog/tags/command/"/>
    
  </entry>
  
  <entry>
    <title>根证书的应用和信任基础</title>
    <link href="http://AlbertGithubHome.github.io/blog/2020/07/06/%E6%A0%B9%E8%AF%81%E4%B9%A6%E7%9A%84%E5%BA%94%E7%94%A8%E5%92%8C%E4%BF%A1%E4%BB%BB%E5%9F%BA%E7%A1%80/"/>
    <id>http://AlbertGithubHome.github.io/blog/2020/07/06/根证书的应用和信任基础/</id>
    <published>2020-07-06T14:54:28.000Z</published>
    <updated>2020-07-11T07:54:29.538Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>人生在世总要相信点什么，信亲人、信朋友、信你面前的陌生人，即便这些你都不信，也要信自己吧，假如连自己都不信了，那在地球上恐怕很难生存了。</p><a id="more"></a><p>我们把钱存入银行，因为我们相信当我们需要用钱时可以通过银行卡把钱取出来；我们拿着车票准时来到候车大厅，因为我们相信除非特殊情况，我们买的那趟车绝不会提前丢下我们而去；遇到纠纷我们会选择打官司，因为我们相信法官最后会给我们公正的判决结果。</p><p>生活中我们信任自己的经验，信任自己的亲人朋友，并依赖这些信任来做许多事情，这些信任是我们正常生活学习的前提，缺了这些我们将寸步难行。而在网络中我们同样需要信任，这些信任是筑造网络社会的基石。</p><p>有些信任是有条件的，比如银行贷款时不能通过空口白话就借来白花花的银子，而抵押物是贷款银行为了相信你附加的筹码；有些信任是无条件的，比如前面一篇总结 <a href="https://blog.csdn.net/albertsh/article/details/106754135" target="_blank" rel="noopener">《认证、HTTPS、证书的基本含义》</a>中提到的根证书，我们必须无条件信任，否则我们将置身于网络猜疑的海洋之中，无法正常利用网络带给我们的便利。</p><h1 id="信任链"><a href="#信任链" class="headerlink" title="信任链"></a>信任链</h1><p>我们常听说 <code>HTTPS</code> 更加安全，它是通过非对称加密技术，让我们可以在不确定的网络环境中可以确认对方的身份，安全传输密钥，但这一切都是有前提的，你得相信你的操作环境是安全的，你没有被人监控，你的电脑没有被人控制，你的数据没有被人篡改，抛开环境谈安全都是耍流氓~</p><p>好了，我们可以回顾一下，要想验证一个网站的身份，我们需要得到网站的公钥，如果可以解开网站拿私钥加密的消息，我们就证明了网站的身份，而网站的公钥不能由网站直接发给我们，需要找权威机构给它证明，相当于找了个担保人。</p><p>权威机构会用自己的私钥把网站的信息和公钥合在一起生成证书，当我们访问网站时首先得到这个证书，然后用权威机构的公钥来解开证书内容，得到网站的信息和网站的公钥，然后进行信息比对和公钥解密来认证身份，这时我们需要思考，权威机构的公钥从哪里来？</p><p>权威机构可以找更加权威的机构按照相同的方式给它做证书，这样一环一环的就走下去，形成了信任链，然后就无穷无尽了，一个权威机构给另一个权威机构证明，我可以玩到天荒地老，到底什么时候是个头啊，其实我们可以人为的确定一个，那就是根证书，他不需要找别的人给它证明，如果一个网站证书最终信任链顶端是有效的根证书，那么网站身份被确认。</p><h1 id="根证书"><a href="#根证书" class="headerlink" title="根证书"></a>根证书</h1><p>接下来看看根证书在哪呢？它内置在我们的浏览器（Firefox）和操作系统中，我们需要无条件的信任，从理论上讲没办法判断根证书的真假，它是自证清白的。这里需要注意，根证书不止有一个，它可以有很多个，“根”只是说明信任链到此为止，整条信任链上的节点都是“可信”的。所以说还是不要随意安装根证书，因为有了它就可以在你的电脑为所欲为。</p><p>说到这里有些人会想，根证书内置在操作系统和浏览器（Firefox）中，如果我下载一个被恶意修改的浏览器岂不是危险了，这种担心是有必要的，所以请尽量在正规网站下载，可是怎么证明哪些网站是正规网站呢？可以使用系统自带的根证书判断。</p><p>如果我的系统是盗版系统，根证书被人改过，那不是更危险了，事实确实如此，算了吧，还是暂时不相信网络了，我去买个系统光盘吧（不知道现在还有没有人用光盘装系统），可是卖你光盘的人能保证光盘的内容不被篡改吗？你说那不能，因为他是微软高级经理的小舅子，应该不能卖盗版碟吧。</p><p>即使光盘不是盗版的，但是制作光盘的内容有没有人动过手脚呢？这些我们还是无法确认，我们能做的只是尽可能的在正规渠道购买正版系统，这种情况遇到证书被篡改的情况很小，然后就无条件相信这个系统了，这就是我文章开头说的，我么总要信点什么，试想如果盖茨在 <code>Windows</code> 操作系统的证书中留有后门，你又能做些什么呢，所以还是不要纠结了，既然用就在正常使用的前提下信任它。</p><h1 id="应用及分析"><a href="#应用及分析" class="headerlink" title="应用及分析"></a>应用及分析</h1><p>说是应用，实际上我只是想吐槽而已，在吐槽之前我们应该了解，证书可以跟各大证书机构（也就是各种CA）来买，也可以自己生成，可能有人会想了，自己生成挺好啊，不用花钱谁还买啊？可是刚刚说过了，跟CA买的证书都是操作系统内置证书认证过的，自己生成的证书操作系统和浏览器可不认，那怎么办呢？</p><p>干脆自己安装个根证书，自己给自己认证得了，用户岂是你想让安装就安装的，别说，还真是这样，只要你说的情况很危急，必须安装，那么大多数的小白用户是会自动安装的，这时你想到了谁？</p><p>不知道大家想到了谁，反正我是想到了建行网银证书和令人“可歌可气”的12306，接下来简单扒一扒他们两个的故事…</p><h2 id="建行网银证书"><a href="#建行网银证书" class="headerlink" title="建行网银证书"></a>建行网银证书</h2><p>最先接触的证书就是建行网银证书，我的第一代网银盾用了将近10年，去年才刚刚升级成2代，可以说真的是太稳定了，不知道做网银的产品经理是谁，你简直就是程序员的福音，在2020年的今天打开建行的官网，首页倒是好看了许多，但是有些内容，比如证书安装、U盾介绍的页面还是原来丑丑的样子。</p><p><img src="https://cdn.jsdelivr.net/gh/albertgithubhome/cdn/img/auth03/ccb2.png" alt="ccb2"></p><p>之前办理U盾时还花钱，根本都不懂啊，使用U盾必须装证书啊，不装就不安全啊，现在回想起来，和我说这话的人可能根本就不懂什么是安全，什么是不安全，反正装就是了，每次付款都要启动建行验证程序，这也是我手动安装过的次数最多的证书，是它开启了我网上购物的里程。</p><p>已经2020年了，打开建行的官网依旧提示我正在使用不安全的连接，使用网银依旧让我自己安装证书，可能作为一个大银行，官方网站迟迟不启用 <code>HTTPS</code>，使用网银盾坚持要用户自己安装证书，应该不仅仅是证书价格的问题，可能还有什么其他的原因。</p><p><img src="https://cdn.jsdelivr.net/gh/albertgithubhome/cdn/img/auth03/ccb3.png" alt="ccb3"></p><h2 id="神奇的12306"><a href="#神奇的12306" class="headerlink" title="神奇的12306"></a>神奇的12306</h2><p>毕业后直接在12306买票的次数就少了，现在一般使用 APP 来解决，前一阵发现12306居然不要求自己安装证书了，仔细一查原来从2017年开始，12306官网就购买了 <code>DigiCert Inc</code> 认证的证书，确实是一个进步的boy，终于舍得花点钱买证书了，作为一个巨大型的网站，它方便了人们购票的方式，是值得歌颂和称赞的，但是每次购票前还要安装烦人的证书，确实挺令人生气的。</p><p><img src="https://cdn.jsdelivr.net/gh/albertgithubhome/cdn/img/auth03/12306_0.png" alt="12306_0"></p><p>原来“根证书”3个红字显示在页面正中间，确实起到了提醒的作用，挺扎眼的，不过那已经一去不复返了，我再放个图，大家一起回顾一下。</p><p><img src="https://cdn.jsdelivr.net/gh/albertgithubhome/cdn/img/auth03/12306.png" alt="12306"></p><h2 id="ESET-SSL-Filter-CA"><a href="#ESET-SSL-Filter-CA" class="headerlink" title="ESET SSL Filter CA"></a>ESET SSL Filter CA</h2><p>最后放一个例子，让你感受下根证书的威力，ESET是总部位于斯洛伐克布拉迪斯拉发的一家世界知名的电脑安全软件公司，主要做杀毒软件，前不久复习 <code>HTTPS</code> 知识的时候发现，我访问各大网站的证书全都变成了 <code>ESET SSL Filter CA</code>，这是什么鬼，难道 <code>ESET SSL Filter CA</code> 是个特别大的证书机构？</p><p>当时还没有意识到是杀毒软件的证书，以为大家都是买的这家证书，后来发现不太对，百度、谷歌、GitHub、Stack Overflow，怎么都是一样的证书，继续深究才发现被“窃听”了。</p><p>我们知道使用 <code>HTTPS</code> 通信因为使用了非对称加密，没有私钥是无法窃听加密内容的，但是这款杀毒软件做到了，它有一个HTTPS 内容过滤的功能，做了我的电脑和各大网站的中间人，按理说 <code>HTTPS</code> 是可以检测出中间人的，但是这款软件在电脑中安装了根证书，所有浏览器认为它是合法的，理论上可以窃听你所有内容，甚至为所欲为。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>信任不仅是人类社会的基石，在网络世界同样重要</li><li>证书之间的层层信任构成了信任链，而根证书是不需要被其他人证明的</li><li>不要随意安装来历不明的根证书，那样可能会使的电脑更容易遭受到攻击</li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/106976688" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>若衣食无忧，谁甘愿拼搏！努力鞭策自己无非是为了挣得可以选择生活的权利~</p></blockquote><hr><blockquote><p>2020-7-5 23:44:41</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;人生在世总要相信点什么，信亲人、信朋友、信你面前的陌生人，即便这些你都不信，也要信自己吧，假如连自己都不信了，那在地球上恐怕很难生存了。&lt;/p&gt;
    
    </summary>
    
      <category term="加密与认证" scheme="http://AlbertGithubHome.github.io/blog/categories/%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%AE%A4%E8%AF%81/"/>
    
    
      <category term="认证" scheme="http://AlbertGithubHome.github.io/blog/tags/%E8%AE%A4%E8%AF%81/"/>
    
      <category term="非对称加密" scheme="http://AlbertGithubHome.github.io/blog/tags/%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/"/>
    
      <category term="HTTPS" scheme="http://AlbertGithubHome.github.io/blog/tags/HTTPS/"/>
    
      <category term="根证书" scheme="http://AlbertGithubHome.github.io/blog/tags/%E6%A0%B9%E8%AF%81%E4%B9%A6/"/>
    
      <category term="中间人" scheme="http://AlbertGithubHome.github.io/blog/tags/%E4%B8%AD%E9%97%B4%E4%BA%BA/"/>
    
  </entry>
  
  <entry>
    <title>码龄10年工作6年的搬砖小哥，最常访问的学习网站都在这里了</title>
    <link href="http://AlbertGithubHome.github.io/blog/2020/06/18/%E7%A0%81%E9%BE%8410%E5%B9%B4%E5%B7%A5%E4%BD%9C6%E5%B9%B4%E7%9A%84%E6%90%AC%E7%A0%96%E5%B0%8F%E5%93%A5%EF%BC%8C%E6%9C%80%E5%B8%B8%E8%AE%BF%E9%97%AE%E7%9A%84%E5%AD%A6%E4%B9%A0%E7%BD%91%E7%AB%99%E9%83%BD%E5%9C%A8%E8%BF%99%E9%87%8C%E4%BA%86/"/>
    <id>http://AlbertGithubHome.github.io/blog/2020/06/18/码龄10年工作6年的搬砖小哥，最常访问的学习网站都在这里了/</id>
    <published>2020-06-18T14:31:18.000Z</published>
    <updated>2020-06-20T04:09:35.073Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这完全是一篇水文，主要看别人分享的文章很有收藏价值，所以也想试着总结一下这种类型的文章，不过之前确实用过一些比较好的网站，有些网站是查找问题时找到的，但是解决完问题就找不到了很可惜，所以我养成了收藏网址的习惯，感觉有用就会分门别类的添加到书签中，再次遇到之前解决过的问题就先在书签里搜一下，有时候会加快解决问题的进度，下面这幅图是我浏览器书签中的一部分。</p><a id="more"></a><p><img src="https://img-blog.csdnimg.cn/20200618224021946.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9hbGJlcnRnaXRodWJob21lLmdpdGh1Yi5pby9ibG9nL2Fib3V0,size_10,color_FFFFFF,t_70#pic_center" alt="bookmark"><br>网络技术飞速发展到今天，越来越多的功能被搬到了“云”上，导致原来需要在本地安装的多种开发环境完全不需要搭建了，如果是临时使用完全可以在浏览器中实现，比如对于程序猿来说不可或缺的编程开发环境，已经出现很多在线编译和运行的网站，再比如原来被称作 <code>PS大神</code> 的设计者们必须要在电脑上安装 <code>Photoshop</code> 这个庞然大物，可是现在你可以发现很多在线 <code>PS</code> 的软件，处理简单功能分分钟搞定，这是我截取的网页上 <code>在线PS软件</code> 的一部分，足以以假乱真。</p><p><img src="https://img-blog.csdnimg.cn/2020061822583286.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9hbGJlcnRnaXRodWJob21lLmdpdGh1Yi5pby9ibG9nL2Fib3V0,size_10,color_FFFFFF,t_70#pic_center" alt="onlinePS"><br>好了，开始进入正题了，作为一个天天写代码的搬砖小伙，每天都在敲敲敲，不是在敲代码就是在敲代码的路上，还有一种可能就是在学习如何敲代码，那么这样的榆木脑袋每天都会访问哪些学习网站呢？接下来我把最常访问的一些网站列举一下，有可能后续会更新，但我要是犯懒就算了。</p><h1 id="网站列表"><a href="#网站列表" class="headerlink" title="网站列表"></a>网站列表</h1><p>接下来会分成几个大类来列举一个我最常用的一些网站，每个人的喜好不同，但是仔细看看，或许有些你会感兴趣哦！</p><h2 id="一、文档项目"><a href="#一、文档项目" class="headerlink" title="一、文档项目"></a>一、文档项目</h2><p>如果写一个功能有现成的轮子给我用就好了，其实网络上有很多现成的轮子，我们要善于利用别人的成果转换为自己进步的阶梯。</p><p>1、<strong>cppreference</strong> &gt;&gt; <a href="https://en.cppreference.com/w/" target="_blank" rel="noopener">https://en.cppreference.com/w/</a></p><p>首推这个网站其实是有点偏心的，因为每天都在写C++，所以还是首先就想到了这个网站，这个网站中可以查到已经发布的各个C++标准的库函数，特性、头文件等等，对于不确定的函数返回值、新标准的特性、函数的常见用法都可以在这个网站找到，这个网站还有中文版的，学习C++的小伙伴可以常来逛逛。</p><p><img src="https://img-blog.csdnimg.cn/20200618233424911.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9hbGJlcnRnaXRodWJob21lLmdpdGh1Yi5pby9ibG9nL2Fib3V0,size_10,color_FFFFFF,t_70#pic_center" alt="cppreference"></p><p>2、 <strong>GitHub</strong> &gt;&gt; <a href="https://github.com/" target="_blank" rel="noopener">https://github.com/</a></p><p>被广大程序员调侃成“全球最大的同性交友网站”怎么能不上榜，<code>GitHub</code> 这个网站就算你不常用但也会常听到吧，上面充满了全世界精英团队编写的轮子，有趣的是这样一个最支持开源的网站居然被微软的这个最大的闭源厂商受够了，不过现在还是发展的越来越好了。你可以在上面阅读一些开源代码，看看那些明星产品究竟是怎样实现的，真正为我所用。</p><p><img src="https://img-blog.csdnimg.cn/20200618233959952.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9hbGJlcnRnaXRodWJob21lLmdpdGh1Yi5pby9ibG9nL2Fib3V0,size_10,color_FFFFFF,t_70#pic_center" alt="github"></p><h2 id="二、数据仓库"><a href="#二、数据仓库" class="headerlink" title="二、数据仓库"></a>二、数据仓库</h2><p>程序发展离不开数据存储，数据是支撑程序发展的基石，现在的数据库已经不是当初的关系数据满天下了，各种各样的数据库类型被发明了出来，列数据库、文档数据库、键值数据库等等，真的是太多了。</p><p>1、 <strong>Redis</strong> &gt;&gt; <a href="https://redis.io/commands" target="_blank" rel="noopener">https://redis.io/commands</a></p><p>非关系型数据库中最火的一个了吧，在认真学习之前一度认为它是一个新产品，后来才知道 <code>Redis</code> 其实在 2009 年就已经诞生了，作为一款键值型的内存数据库，现在被广泛引用于各个领域，而 <code>Redis</code> 的官方文档是需要不断去翻阅的，最近发布了 <code>Redis 6.0</code>，引入了网络多线程，以后的面试题可能要留神了。</p><p><img src="https://img-blog.csdnimg.cn/20200618235824411.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9hbGJlcnRnaXRodWJob21lLmdpdGh1Yi5pby9ibG9nL2Fib3V0,size_10,color_FFFFFF,t_70#pic_center" alt="redis"></p><p>2、 <strong>MySQL</strong>  &gt;&gt; <a href="https://dev.mysql.com/doc/refman/8.0/en/" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/8.0/en/</a></p><p>虽然 <code>NoSQL</code> 数据库在各个领域兴起，但是现在还是关系数据库占据着主导地位，<code>MySQL</code> 就是关系数据库中的明星产品了，自从被 <code>ORACLE</code> 收购以后也在不断发展，最近版本从5.7一跃直接到8.0，据说<code>MySQL 8</code> 要比 <code>MySQL 5.7</code> 快 2 倍，还带来了大量的改进和更快的性能！感兴趣的可以查阅一下 <code>MySQL</code> 的文档，它的文档格式特别棒，看着就让人赏心悦目。</p><p><img src="https://img-blog.csdnimg.cn/20200619000455910.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9hbGJlcnRnaXRodWJob21lLmdpdGh1Yi5pby9ibG9nL2Fib3V0,size_10,color_FFFFFF,t_70#pic_center" alt="MySQL"><br>3、 <strong>墨天轮</strong> &gt;&gt; <a href="https://www.modb.pro/dbRank" target="_blank" rel="noopener">https://www.modb.pro/dbRank</a></p><p>墨天轮上聚集了很多数据库爱好者，是一个新兴的数据库技术交流平台，一直渴望成为一个专业的技术社区，高效便捷、开放互助、乐于分享，能够承载我们数据人的学习和成长，促进整个行业的发展和创新，在这个网站上我们可以看到各大数据库排行，了解数据库相关的最新发展和方向。</p><p><img src="https://img-blog.csdnimg.cn/20200619002322531.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9hbGJlcnRnaXRodWJob21lLmdpdGh1Yi5pby9ibG9nL2Fib3V0,size_10,color_FFFFFF,t_70#pic_center" alt="modb"></p><h2 id="三、工具集合"><a href="#三、工具集合" class="headerlink" title="三、工具集合"></a>三、工具集合</h2><p>文章开头也提到了，如今很多工具都搬到了线上，这样既节省了电脑空间，也免去了安装和配置工具的麻烦，只要不是IDE的重度依赖者，使用在线工具还是很方便的。</p><p>1、 <strong>在线工具</strong> &gt;&gt; <a href="https://tool.lu/" target="_blank" rel="noopener">https://tool.lu/</a></p><p>这个网站提供了众多的在线工具，每次一用到时间戳转换或者URL编码等操作，我肯定会第一时间打开这个页面，因为本地调 <code>API</code> 太麻烦了，有时还需要搭建环境，在网站上找到对应的工具直接操作就可以了，还带有实时刷新的功能，完全没必要自己在本地写代码。</p><p><img src="https://img-blog.csdnimg.cn/2020061922082255.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9hbGJlcnRnaXRodWJob21lLmdpdGh1Yi5pby9ibG9nL2Fib3V0,size_10,color_FFFFFF,t_70#pic_center" alt="tool"></p><p>2、<strong>AlbertWorld</strong> &gt;&gt; <a href="http://www.008ct.top/blog/tools/" target="_blank" rel="noopener">http://www.008ct.top</a></p><p>这个网站收录了很多有用的网址，不仅仅是工具，文档、教程、数据、资源包括方方面面，其中包括很多讲解原理的知识和有用的素材，很像一个小小的杂货铺，偶尔上新哦！</p><p><img src="https://img-blog.csdnimg.cn/20200619220657719.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9hbGJlcnRnaXRodWJob21lLmdpdGh1Yi5pby9ibG9nL2Fib3V0,size_10,color_FFFFFF,t_70#pic_center" alt="008ct"></p><h2 id="四、疑难解答"><a href="#四、疑难解答" class="headerlink" title="四、疑难解答"></a>四、疑难解答</h2><p>解决问题是程序员每天都要面临的功课，而程序员要解决的问题往往是没见过的，如果一个程序猿天天值只处理那么几个相同的问题，那么他已经走上了被淘汰的道路，查找问题原因，给出解决方案，祝贺你，你今天又进步了。</p><p>1、 <strong>CSDN</strong> &gt;&gt; <a href="https://www.csdn.net/" target="_blank" rel="noopener">https://www.csdn.net/</a></p><p>用了这么久的 <code>CSDN</code> 一直不知道全称是什么？前几天才查了一下全称是 <code>Chinese Software Developer Network</code>，立意很深远的样子，不过确实是一个不错的网站，从去年开始大面积调整，原来的广告真是惨不忍睹，改版后现在好多了，工作中很多解决方案都出自这个网站，之前在论坛里没少逛，解答问题的同时，自己的知识也得到了巩固。</p><p><img src="https://img-blog.csdnimg.cn/20200619220017417.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9hbGJlcnRnaXRodWJob21lLmdpdGh1Yi5pby9ibG9nL2Fib3V0,size_10,color_FFFFFF,t_70#pic_center" alt="csdn"></p><p>2、 <strong>StackOverflow</strong> &gt;&gt; <a href="https://stackoverflow.com/" target="_blank" rel="noopener">https://stackoverflow.com/</a></p><p>一个和 <code>GitHub</code> 比肩的网站，一个专门解决程序猿问题的网站，你要坚信，作为一个普通的程序搬砖工，你遇到的问题别人也遇到过，所以遇到问题来这个网站查一查，有时问题瞬间就被解决了，特别是一些专业的工具仅仅报了一个错误代码，通过搜索引擎很难定位具体问题，但是在这个网站上的前辈已经为你趟好路了。</p><p><img src="https://img-blog.csdnimg.cn/20200619002926880.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9hbGJlcnRnaXRodWJob21lLmdpdGh1Yi5pby9ibG9nL2Fib3V0,size_10,color_FFFFFF,t_70#pic_center" alt="stackoverflow"></p><h2 id="五、进阶刷题"><a href="#五、进阶刷题" class="headerlink" title="五、进阶刷题"></a>五、进阶刷题</h2><p>程序猿就是一个活到老学到老的职业（如果35岁被淘汰就不用学了），必须时刻保证自己的学习状态，更新自己的知识储备，刷题成为了一项锻炼脑力的活动，因为很多公司特别是大公司都会要求算法达到一定的水平，所以没事多刷刷题，不要让自己的大脑锈住了。</p><p>1、<strong>力扣</strong> &gt;&gt; <a href="https://leetcode-cn.com/problemset/all/" target="_blank" rel="noopener">https://leetcode-cn.com/problemset/all/</a></p><p>这个网站貌似有很多名字，现在显示的是力扣，之前是在全球服注册的，后来莫名其妙的有注册了一次，变成了家门口的版本，这上面有很多算法题，一段时间没看居然还加上了面试题，不过它搞的那个竞赛挺有意思的，作为长期的两题选手，看着高手们10分钟做完4题，犹如神仙打架一般。</p><p><img src="https://img-blog.csdnimg.cn/20200619220440231.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9hbGJlcnRnaXRodWJob21lLmdpdGh1Yi5pby9ibG9nL2Fib3V0,size_10,color_FFFFFF,t_70#pic_center" alt="leetcode"></p><p>2、 <strong>POJ</strong> &gt;&gt; <a href="http://poj.org/" target="_blank" rel="noopener">http://poj.org/</a></p><p>这个 <code>Online Judge</code> 有些历史了，不过一直保持着更新，<code>ACM</code> 竞赛时也尝试在这里刷过题，和 <code>LeetCode</code> 比起来这里的题似乎更难一些，如果想挑战更高难度，不妨来这里试一下。</p><p><img src="https://img-blog.csdnimg.cn/20200619221129502.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9hbGJlcnRnaXRodWJob21lLmdpdGh1Yi5pby9ibG9nL2Fib3V0,size_10,color_FFFFFF,t_70#pic_center" alt="poj"></p><h2 id="六、教程案例"><a href="#六、教程案例" class="headerlink" title="六、教程案例"></a>六、教程案例</h2><p>当我们想学习一门新技术的时候，很渴望得到一份简单明了的教程，实际上很多技术的官方网站文档都非常完整，但是对于初学者来说理解起来会有些难度，这时候可以看一些边学边做的教程，在不断尝试中学习知识。</p><p>1、<strong>廖雪峰官网</strong> &gt;&gt; <a href="https://www.liaoxuefeng.com/wiki/1016959663602400" target="_blank" rel="noopener">https://www.liaoxuefeng.com/wiki/1016959663602400</a></p><p>廖雪峰此乃神人也，看看我截取的这篇教程的访问量你就清楚了，前两年我看到这篇文章的时候访问量才几亿，跟着教程完整的学了一遍，现在访问量已经400多亿了，受欢迎程序难以想象，廖大神写得教程浅显易懂，非常适合初学者，从头来一步步的就学会了，想当初我跟着他学爬虫把他的文章都爬了，哈哈~<br><img src="https://img-blog.csdnimg.cn/20200619221531788.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9hbGJlcnRnaXRodWJob21lLmdpdGh1Yi5pby9ibG9nL2Fib3V0,size_10,color_FFFFFF,t_70#pic_center" alt="liaoxuefeng"><br>2、 <strong>菜鸟教程</strong> &gt;&gt; <a href="https://www.runoob.com/" target="_blank" rel="noopener">https://www.runoob.com/</a></p><p>同样是一个接地气的教程网站，谁刚开始学的时候不是一只菜鸟呢，这个网站教程很多，只要你想学总能找到你喜欢的那款，并且在讲解时会有例子和函数参数说明，非常适合初学者。<br><img src="https://img-blog.csdnimg.cn/20200619221355785.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9hbGJlcnRnaXRodWJob21lLmdpdGh1Yi5pby9ibG9nL2Fib3V0,size_10,color_FFFFFF,t_70#pic_center" alt="runoob"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>总有小伙伴调侃说：收藏从未停止，学习从未开始，其实收藏是一个好苗头，只有想学才有可能去学</li><li>如果仔细看了这些网站，你会发现有些网站的设计让人真的很舒服，临时补充一个 <code>https://git-scm.com/</code></li><li>真正应了那句话，比你优秀的人比你还努力，你的产品都那么强了，网站居然还那么好看，还让不让人活了~</li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/106754135" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>我们没有生活在和平的年代，只是生活在了和平的国度，想开点，珍惜眼前的一切，灾难都会过去，我们还有一双手去争夺属于自己的未来。</p><p>2020-6-20 00:16:49</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;这完全是一篇水文，主要看别人分享的文章很有收藏价值，所以也想试着总结一下这种类型的文章，不过之前确实用过一些比较好的网站，有些网站是查找问题时找到的，但是解决完问题就找不到了很可惜，所以我养成了收藏网址的习惯，感觉有用就会分门别类的添加到书签中，再次遇到之前解决过的问题就先在书签里搜一下，有时候会加快解决问题的进度，下面这幅图是我浏览器书签中的一部分。&lt;/p&gt;
    
    </summary>
    
      <category term="Thinking" scheme="http://AlbertGithubHome.github.io/blog/categories/Thinking/"/>
    
    
      <category term="收集" scheme="http://AlbertGithubHome.github.io/blog/tags/%E6%94%B6%E9%9B%86/"/>
    
      <category term="网站" scheme="http://AlbertGithubHome.github.io/blog/tags/%E7%BD%91%E7%AB%99/"/>
    
      <category term="working" scheme="http://AlbertGithubHome.github.io/blog/tags/working/"/>
    
  </entry>
  
  <entry>
    <title>C++中的std::lower_bound()和std::upper_bound()函数</title>
    <link href="http://AlbertGithubHome.github.io/blog/2020/06/15/C-%E4%B8%AD%E7%9A%84std-lower-bound-%E5%92%8Cstd-upper-bound-%E5%87%BD%E6%95%B0/"/>
    <id>http://AlbertGithubHome.github.io/blog/2020/06/15/C-中的std-lower-bound-和std-upper-bound-函数/</id>
    <published>2020-06-15T15:17:39.000Z</published>
    <updated>2020-06-27T02:12:52.819Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>问题是躲不掉的，该来的总会来，这不是代码中又遇到了 <code>std::upper_bound()</code> 函数，再来学习一遍好了，在我的印象中每次看到这 <code>lower_bound</code> 和 <code>upper_bound</code> 两个函数都有些别扭，凡是见到他们必须查一遍，因为我记得它们两个函数的作用不对称，这一点记得很清楚，但是它们两个函数查找的细节却记不住，这次总结一下，强化记忆，下次回忆起来应该会快一点。</p><a id="more"></a><h1 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h1><p>今天看到这两个函数时挠挠头又打开了搜索引擎，看到文章里写到 <code>std::lower_bound()</code> 是返回大于等于 <code>value</code> 值的位置，而 <code>std::upper_bound()</code> 是返回第一个大于 <code>value</code> 值的位置，第一反应真是瞎写，怎么俩都是大于，肯定应该是一个大于一个小于啊，这样才“合理”嘛！</p><p>但是当看到多个文章中采用相同的说法时，刚刚还“坚定”的想法开始动摇，然后开始查C++标准文档，一遍遍读着那有些拗口的文字:</p><blockquote><p>std::lower_bound returns an iterator pointing to the first element in the range [first, last) that is not less than (i.e. greater or equal to) value, or last if no such element is found.</p><p>std::upper_bound returns an iterator pointing to the first element in the range [first, last) that is greater than value, or last if no such element is found.</p></blockquote><p>这些标准文档上的文字印证了刚刚查询到的结果，两个函数返回的结果都是迭代器，<code>std::lower_bound()</code> 是在区间内找到第一个大于等于 <code>value</code> 的值的位置并返回，如果没找到就返回 <code>end()</code> 位置。而 <code>std::upper_bound()</code> 是找到第一个大于 <code>value</code> 值的位置并返回，如果找不到同样返回 <code>end()</code> 位置。</p><p>两个函数都提到了大于操作，而没有涉及到小于操作，这就是我前面提到的不对称，也是我感觉不合理的地方，但是当尝试使用了几次这两个函数之后，我发现这两个函数的设计的恰到好处，这样的设计很方便我们来做一些具体的操作。</p><h1 id="实际例子"><a href="#实际例子" class="headerlink" title="实际例子"></a>实际例子</h1><p>首先说明这两个函数内部使用了二分查找，所以必须用在有序的区间上，满足有序的结构中有两个常见的面孔：<code>std::map</code> 和 <code>std::set</code>，他们本身就是有序的，所以提供了 <code>std::map::lower_bound()</code> 和 <code>std::set::lower_bound()</code> 这种类似的成员函数，但是原理都是一样的，我们可以弄明白一个，另外类似的函数就都清楚了。</p><h2 id="自己设计"><a href="#自己设计" class="headerlink" title="自己设计"></a>自己设计</h2><p>如果你看了这两个函数的具体含义也和我一样不太理解为什么这样设计，可以思考一下接下来这个需求，找出数组内所有值为2和3的元素，图例如下：</p><p><img src="https://cdn.jsdelivr.net/gh/albertgithubhome/cdn/img/lower_bound.png" alt="lower_bound()"></p><p>对于一个有序数组，我们在实现 <code>lower_bound()</code> 函数和 <code>upper_bound()</code> 函数时可以让它返回指定的位置来确定取值区间，第①种情况就是标准函数库的实现方式，而第②种和第③种就是我第一印象中感觉应该对称的样子，这样看起来也没什么问题，下面具体来分析下后两种设计有哪些不好的地方。</p><h2 id="具体分析"><a href="#具体分析" class="headerlink" title="具体分析"></a>具体分析</h2><p>假如我们采用第②种实现方式，那么实现打印元素2和3的代码要写成下面这样：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v&#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">8</span>&#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::const_iterator itorLower = <span class="built_in">std</span>::lower_bound(v.begin(), v.end(), <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::const_iterator itorUpper = <span class="built_in">std</span>::upper_bound(v.begin(), v.end(), <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *itorLower &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">if</span> (itorLower == itorUpper)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        ++itorLower;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码看起来还可以，打印完元素后判断到达了结尾直接跳出循环，但是如果要是数组中不包含元素2和3呢，那么也会打印出一个元素，还有可能导致程序崩溃。</p><p>如果我们采用第③种实现方式，那么实现打印元素2和3的代码要写成下面这样：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v&#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">8</span>&#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::const_iterator itorLower = <span class="built_in">std</span>::lower_bound(v.begin(), v.end(), <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::const_iterator itorUpper = <span class="built_in">std</span>::upper_bound(v.begin(), v.end(), <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">for</span>(++itorLower; itorLower != itorUpper; ++itorLower)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *itorLower &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这代码看起来简洁了很多，但是在循环开始前需要先调用 <code>++itorLower</code>，因为第一个元素并不是需要找到的元素，所以要先跳过它，这样看来确实多做了一步操作，一开始就让 <code>itorLow</code> 指向第一个2就好了呀。</p><h2 id="最终版本"><a href="#最终版本" class="headerlink" title="最终版本"></a>最终版本</h2><p>当你尝试几种实现方式就会发现，还是标准库提供的这种方式使用起来更加方便，虽然采取的不是对称的方式，但是统一了存在查找元素和不存在查找元素的的情况，写出的代码也比较简洁，没有多余的步骤，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v&#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">8</span>&#125;;</span><br><span class="line">    <span class="keyword">auto</span> itorUpper = <span class="built_in">std</span>::upper_bound(v.begin(), v.end(), <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> itorLower = <span class="built_in">std</span>::lower_bound(v.begin(), v.end(), <span class="number">2</span>); itorLower != itorUpper; ++itorLower)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *itorLower &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>有些函数的实现方式和我们想象的并不一样，但是我们可以通过熟练使用来了解它为什么这样设计</li><li>对称结构虽然是很美的，但是非对称的结构在编程中常常出现，同样有其美丽所在</li><li>遇到类似的问题可以动笔画一画，列举出各种情况会有利于你做出正确的判断</li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/106844850" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>有时会很焦虑，看到优秀的人比你还努力时总让人感到急迫，但是一味的忧患是无意义的，脚下迈出的每一步才是真真正正的前进，不要去忧虑可能根本就不会发生的事情，那样你会轻松许多</p><p>2020-6-26 23:21:40</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;问题是躲不掉的，该来的总会来，这不是代码中又遇到了 &lt;code&gt;std::upper_bound()&lt;/code&gt; 函数，再来学习一遍好了，在我的印象中每次看到这 &lt;code&gt;lower_bound&lt;/code&gt; 和 &lt;code&gt;upper_bound&lt;/code&gt; 两个函数都有些别扭，凡是见到他们必须查一遍，因为我记得它们两个函数的作用不对称，这一点记得很清楚，但是它们两个函数查找的细节却记不住，这次总结一下，强化记忆，下次回忆起来应该会快一点。&lt;/p&gt;
    
    </summary>
    
      <category term="C/C++" scheme="http://AlbertGithubHome.github.io/blog/categories/C-C/"/>
    
    
      <category term="C/C++" scheme="http://AlbertGithubHome.github.io/blog/tags/C-C/"/>
    
      <category term="lower_bound" scheme="http://AlbertGithubHome.github.io/blog/tags/lower-bound/"/>
    
      <category term="upper_bound" scheme="http://AlbertGithubHome.github.io/blog/tags/upper-bound/"/>
    
      <category term="查找" scheme="http://AlbertGithubHome.github.io/blog/tags/%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>认证、HTTPS、证书的基本含义</title>
    <link href="http://AlbertGithubHome.github.io/blog/2020/06/14/%E8%AE%A4%E8%AF%81%E3%80%81HTTPS%E3%80%81%E8%AF%81%E4%B9%A6%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%90%AB%E4%B9%89/"/>
    <id>http://AlbertGithubHome.github.io/blog/2020/06/14/认证、HTTPS、证书的基本含义/</id>
    <published>2020-06-14T14:50:35.000Z</published>
    <updated>2020-06-15T14:53:13.612Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>通过前面的总结 <a href="https://blog.csdn.net/albertsh/article/details/106536857" target="_blank" rel="noopener">《对称加密、非对称加密、公钥、私钥究竟是个啥？》</a>，我们基本了解了对称加密和非对称加密的概念和特点，考虑到效率和安全性，一般可以使用非对称加密来传递对称加密所需密钥，之后就采取对称加密通信了，这样可以大大提高数据发送的的效率。</p><a id="more"></a><p>其实密码技术除了应用在加密领域外还有很多其他的用途，比如验证数据的完整性、用来做认证、提供一些不可否认的证据等，这些应用也常常出现在我们的日常生活中，比如很多官方网站在提供软件下载链接的同时，还附带一个验证的字符串，实际上很多就是md5码或者hash码，这些就是供下载的人来验证完整性的，防止被其他人篡改。</p><p><img src="https://img-blog.csdnimg.cn/20200614233255231.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9hbGJlcnRnaXRodWJob21lLmdpdGh1Yi5pby9ibG9nL2Fib3V0,size_18,color_FFFFFF,t_70#pic_center" alt="download"></p><p>我们下载完软件之后，使用工具来将软件转化成一串字符，听起来很神奇，实际上就是计算一下软件的md5码或hash码，然后和网站上的标注的信息进行对比，如果一致那么软件就是完整的。我曾经就遇到过一次，当时做的游戏发包，同事给我发了测试包，安装之后无法正常使用，检查包的大小与发送端的一样，后来使用检测工具计算发现md5是不同的，原因可能是发送包的时候电脑卡死过，导致最后发来数据包与原始数据产生了差异。</p><p>但是你有没有想过，这个软件虽然是完整的，通过md5计算发现也没有被其他人篡改，那么怎么证明你下载的网站真的是官网呢？万一官网也是伪造的呢？如果有人伪造了官网，又将上面的软件进行修改重新计算md5然后上传到自己伪造的界面上，你要怎么来识别呢？</p><p><img src="https://img-blog.csdnimg.cn/20200614233512429.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9hbGJlcnRnaXRodWJob21lLmdpdGh1Yi5pby9ibG9nL2Fib3V0,size_18,color_FFFFFF,t_70#pic_center" alt="fish"></p><p>可能有的人会想到看网址啊，<code>taobao.com</code> 就一定是淘宝的网站吗？这个域名是可以伪造的，所以要验证网站上东西是真的，那么首先要验证你看到的网站是真的，这就涉及到了认证身份，接下来可以简单了解下什么是认证。</p><h1 id="认证"><a href="#认证" class="headerlink" title="认证"></a>认证</h1><p>其实密钥不仅仅可以用来加密，还可以用来认证的，那么什么是认证？认证是一种信用保证形式，表示对一种事物或一个人的信任和认可，比如常见的毕业证书、结婚证书都是对人一段经历或一种关系的证明和认可。最简单的网站登录是基于密码的验证，这实际上就是利用对称加密的认证。</p><p>网站保存了你的用户信息和密码，下次再登录的时候输入密码后，网站会用你输入的密码和之前保存的密码进行对比，如果密码相同则认证成功，成功的证明了“你”就是“你”，而非对称加密同样可以用来做认证。</p><p>在非对称加密的实现中，私钥是只有自己保存的，而私钥加密的内容可以使用公钥解开，如果一份加密数据可以用 <code>Jerry</code>的公钥解开，那么我们就可以认为这份数据是 <code>Jerry</code> 发出的，因为只有 <code>Jerry</code> 自己有私钥，所以可以通过这种方式来进行认证。</p><p>而在网络上想要认证一个网站的身份，确认它不是钓鱼网站，第一个映入脑海中的就是 <code>https</code>，一般提到 <code>https</code> 都会说它是加密的、安全的，是 <code>http</code> 的升级版，但是 <code>https</code> 的安全不仅仅体现在加密上，还有它的认证功能，可以使你免受钓鱼网站的侵害。</p><h1 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h1><p>简单了解下 <code>HTTPS</code>，一般来说网络模型常说的有OSI七层模型和五层模型，<code>HTTPS</code> 的诞生并没有增加模型的层数，<code>HTTP</code> 是建立在 <code>TCP</code>基础上的应用层协议，而 <code>HTTPS</code> 是在 <code>TCP</code> 和 <code>HTTP</code> 之间的会话层中加了一些特殊操作，使原来明文传输的内容，在会话层这一步进行加密，并且可以对数据来源进行认证。</p><p>提到 <code>HTTPS</code> 就不得不说 <code>SSL</code> 和 <code>TSL</code>， <code>SSL</code> 是应用在 <code>HTTP</code>上的一个协议加密层，最初是由网络大佬网景公司（Netscape）研发，后来升级为 <code>TSL</code>，简单的理解就是 <code>HTTP + SSL/TSL = HTTPS</code>。</p><p><img src="https://img-blog.csdnimg.cn/20200614233628484.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9hbGJlcnRnaXRodWJob21lLmdpdGh1Yi5pby9ibG9nL2Fib3V0,size_18,color_FFFFFF,t_70#pic_center" alt="safe"></p><p>随着网络安全逐渐得到大家的认识，一些主流网站基本都都将访问方式改成了 <code>https</code>，支持 <code>https</code> 的网站在浏览器的地址栏中通常有一把小锁，点开会提醒你访问的是安全的连接，如果你访问的连接疑似被人篡改或者仿冒，那么这把小锁会被斜线划掉，提醒你网站危险请谨慎访问。</p><p><img src="https://img-blog.csdnimg.cn/20200614233645628.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9hbGJlcnRnaXRodWJob21lLmdpdGh1Yi5pby9ibG9nL2Fib3V0,size_18,color_FFFFFF,t_70#pic_center" alt="dangerous"></p><p>那么 <code>https</code> 是怎么判断出来哪些网站是安全的，哪些网站是仿冒的呢？毕竟有些网址都很像甚至可以做成一模一样的，这就用到了非对称加密的认证功能，当我用 <code>A</code> 的公钥可以解密一段消息，那么就可以证明消息是 <code>A</code> 发来的，<code>https</code> 的认证功能正是利用了这个特点。</p><p>当访问一个网站的时候，网站先给我发一个用它的私钥加密的数据，然后我用它的公钥来解密，如果解密成功就说明我访问的网站是正常的，可以继续访问，如果解密失败则很有可能是虚假或者仿冒的网站，应该仔细辨别一下了。</p><p>这里会有一个问题，我怎么才能得到网站的公钥呢？之前说过密钥配送问题，直接由网站发给我肯定不行，中间可能被篡改，也有可能一个虚假网站把它自己的公钥发给我了，我用假的公钥验证对应的假的私钥也是成功的，这样就起不到认证的效果了，必须给他找个证明人才行，这就要用到我们下面要说的证书了。</p><h1 id="证书"><a href="#证书" class="headerlink" title="证书"></a>证书</h1><p>证书是用来证明一件事情或东西的，刚才说网站的公钥不能它自己来发，这样不能证明它的身份，我们可以找一个权威的机构给它认证一下，我每次从权威机构获得网站的证书，从这个证书中取得公钥，如果用这个公钥可以解开网站私钥加密的内容，那么就可以认证它的身份了。</p><p>这里提到的证书就是网站所有者找权威机构申请的，权威机构把网站信息、有效时期、对应的公钥、序列号消息等数据存储到证书中，当我们需要能某个网站的公钥时，去证书中取就可以了，这里的证书有点像营业执照了，由权威机构发布，用来证明你的身份。</p><p>但是权威机构的证书怎么发给我呢？我们有理由认为网络是不安全的，那证书如果直接通过网络发给我同样是不安全的，还有一个问题就是网站虽然找了一个权威机构，但是我认为它不够权威怎么办？这时这个权威机构可以找一个更权威的机构证明自己，让更权威的机构给自己颁发一个证书，这样就形成了证书链。</p><p><img src="https://img-blog.csdnimg.cn/20200614233914722.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9hbGJlcnRnaXRodWJob21lLmdpdGh1Yi5pby9ibG9nL2Fib3V0,size_18,color_FFFFFF,t_70#pic_center" alt="capath"></p><p>就像现实生活中我要找个人来干活，因为工期比较紧所以找的人要求踏实，必须能老老实实把活干完，不能半路撂挑子，张三过来应聘，正在我犹豫时，走过来一个叫李四的人说张三没问题，但是我还是不能确定，因为李四我也不熟悉，然后李四居然把我爸叫来了，我爸和我说李四这个人特别诚实，从来不说谎，这时一条证书链就形成了，李四为张三证明，我爸为李四证明，那谁来证明我爸说的是真的呢？不需要的，我无条件相信他。</p><p>这在计算机的证书链中就是根证书，根证书不需要别人来证明，你只能无条件相信它，它是整个信息链的源头，通常内置在操作系统或者浏览器中，关于根证书还要一些好玩的故事和一些变态的应用，下次再说吧，准备睡觉了~</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>密码技术除了应用在加密领域，还可以用来验证数据的完整性、用来做认证、提供一些不可否认的证据</li><li><code>HTTPS</code> 不仅可以用来加密通信内容，还可以用来验证网站的真实性</li><li>正规的支持 <code>HTTPS</code>的网站在访问时会地址栏会有一把安全的小锁头，但是有些不出现小锁头的网站并不一定都是非法的</li><li><code>HTTP</code> 网站是没有小锁头的，因为有些数据不需要加密，毕竟绝大多数的 <code>HTTPS</code> 证书是要钱的，有很多网站由于经费问题还未投身于 <code>HTTPS</code> 的怀抱</li><li>根证书通常内置的操作系统或者浏览器中，是证书链的源头，你必须无条件的信任他。</li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/106536857" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>当我们拼劲全力到达自己的终点时，可能会看到同行的人正在你的终点线前伸伸懒腰准备出发，然后一骑绝尘消失在你震惊的目光中，但是这不是我们放弃努力的理由，因为如果你不努力，你甚至连他们的背影也看不到~</p></blockquote><hr><blockquote><p>2020-6-14 23:20:21</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;通过前面的总结 &lt;a href=&quot;https://blog.csdn.net/albertsh/article/details/106536857&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《对称加密、非对称加密、公钥、私钥究竟是个啥？》&lt;/a&gt;，我们基本了解了对称加密和非对称加密的概念和特点，考虑到效率和安全性，一般可以使用非对称加密来传递对称加密所需密钥，之后就采取对称加密通信了，这样可以大大提高数据发送的的效率。&lt;/p&gt;
    
    </summary>
    
      <category term="加密与认证" scheme="http://AlbertGithubHome.github.io/blog/categories/%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%AE%A4%E8%AF%81/"/>
    
    
      <category term="加密" scheme="http://AlbertGithubHome.github.io/blog/tags/%E5%8A%A0%E5%AF%86/"/>
    
      <category term="认证" scheme="http://AlbertGithubHome.github.io/blog/tags/%E8%AE%A4%E8%AF%81/"/>
    
      <category term="非对称加密" scheme="http://AlbertGithubHome.github.io/blog/tags/%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/"/>
    
      <category term="HTTPS" scheme="http://AlbertGithubHome.github.io/blog/tags/HTTPS/"/>
    
      <category term="证书" scheme="http://AlbertGithubHome.github.io/blog/tags/%E8%AF%81%E4%B9%A6/"/>
    
  </entry>
  
  <entry>
    <title>对称加密、非对称加密、公钥、私钥究竟是个啥？</title>
    <link href="http://AlbertGithubHome.github.io/blog/2020/06/07/%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E3%80%81%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E3%80%81%E5%85%AC%E9%92%A5%E3%80%81%E7%A7%81%E9%92%A5%E7%A9%B6%E7%AB%9F%E6%98%AF%E4%B8%AA%E5%95%A5%EF%BC%9F/"/>
    <id>http://AlbertGithubHome.github.io/blog/2020/06/07/对称加密、非对称加密、公钥、私钥究竟是个啥？/</id>
    <published>2020-06-07T14:50:10.000Z</published>
    <updated>2020-06-15T14:52:08.577Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>进入正题之前先唠叨几句，不久前听到一个名词叫——费曼学习法，核心思想就是用通俗的话语把复杂道理或技术讲清楚，如果你已经明白了这个方法的含义，那么我好像离成功又进了一步。其实这个方法一直在尝试使用，但是没想到它居然有个“洋气”的名字。</p><a id="more"></a><p>由于之前学习时接触了加密、验证、HTTPS、证书等知识，感觉挺有意思的，最近也用到了一些这方面的内容，所以决定把这些概念重新梳理一下，免得一段时间不复习又还给书本了。本打算写一篇总结把这些概念整理到一起，但是初步想了一下很难实现，涉及到的概念实在太多了，所有还是决定分成几次来写吧。</p><p>分开写就比较随便了，写到哪完全看心情，不过我还是力图用最简单的描述来讲清楚问题，抛开具体的实现细节（其实我也不懂），梳理流程和概念性的知识，想了解具体的实现细节还是找专业的书籍去补充吧，我曾经看了一遍《图解密码技术》，过了这么久整本书我就记得两个词——异或、求余，再比如使用公钥和私钥来完成非对称加密，就是利用了两个大质数 <code>(p,q)</code> 乘积 <code>(n)</code> 难以逆向求解，这些太细节的东西很难展开一点点讲清楚。</p><p>最理想的状态是把学习知识当成是看故事书，阅读完一个个情节就吸收的差不多了，而不是把这些知识当成武功秘籍，然后一点点参悟，最后觉得枯燥而放弃，所以为了知识解惑，也算是将学习成果做个笔记，我们开始从最基础的知识学起。</p><h1 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h1><p>对称加密一般指：加密和解密使用的是同一个密钥的加密方式。就像防盗门的钥匙一样，可以用钥匙把门锁上，也可以用这同一把钥匙再把门打开。</p><h2 id="对称加密示例"><a href="#对称加密示例" class="headerlink" title="对称加密示例"></a>对称加密示例</h2><p>至于密钥怎么使用要看具体的加密算法了，可以举一个简单的例子，比如有下面这样一句话：</p><blockquote><p>I like cat</p></blockquote><p>我想把它发给一个好朋友，但是又不想被别人看到，万一有其他人一眼看到，那我的喜好就暴露了（那有怎样呢？），这时我们可以把这句话改的稍微隐晦一点，我可以和好友约定一个密码，假设是 <code>1</code>，然后我把原来这句话的每个非空白字母都替换一下，按字母表顺序使用后一个字母替换前一个字母，比如用字母 <code>b</code> 替换字母 <code>a</code>，那么这句话就变成了：</p><blockquote><p>J mjlf dbu</p></blockquote><p>这时就不怕被别人一眼看穿消息内容了，没有意义的字符串是比较难记的，但是当我的好友收到这句话时，使用我们约定的密码 <code>1</code> 就知道字母顺序变换了1位，所以他再将将字母反向替换回来就能够将文字还原。</p><p>这个例子很简单，但可以说明对称加密的关键，就是加密解密使用同一个密钥，例子中的 <code>1</code> 就是这个密钥，它可以让解密者知道，还原信息时需要反向移动1位即可，消息发送流程如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">A[I like cat] -- 用1加密 --&gt; B((J mjlf dbu))</span><br><span class="line">B((J mjlf dbu))-- 发送给好友 --&gt; C((J mjlf dbu))</span><br><span class="line">C((J mjlf dbu))-- 用1解密  --&gt; D[I like cat]</span><br></pre></td></tr></table></figure><h2 id="对称加密的问题"><a href="#对称加密的问题" class="headerlink" title="对称加密的问题"></a>对称加密的问题</h2><p>刚才的例子已经说了对称加密的流程，但是有一个问题需要解决，这个密码 <code>1</code> 我要怎么告诉我的好友呢？直接发消息被别人看到怎么办，打电话也有可能被别人窃听啊！</p><h2 id="密钥配送"><a href="#密钥配送" class="headerlink" title="密钥配送"></a>密钥配送</h2><p>这就涉及到了一个密钥配送的问题，如果想让对方解密就需要把密码发过去，但是密钥有可能被其他人窃取，这样秘密就不再是秘密了，可能你会想即使密码被别人窃取了也不要紧，因为他根本不知道怎么用。</p><p>请不要做这种假设，简单的情况没有密码都能破解，更何况在密码和数据都被窃取的情况下呢，另外在密码领域我们建议使用完全公开的密码算法，这样的算法经过时间的检验才能被用于加密，千万不要独创一套自认为很安全的加密算法，单靠隐藏算法的细节来达到加密的目的是很危险的。</p><p>发送密钥可能被窃取，不发送密钥对方无法解密，这个加密的密钥配送问题是使用对称加密必须要解决的，而下面要说的这种非对称就不同了，可以将一把密钥直接发送给对方，即使被窃取也没有关系。</p><h1 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h1><p>看这个名字就知道它有点“针对”那个叫做对称加密的小伙伴，从定义上来说对称加密指的是加密和解密使用相同的密钥（为啥不叫同钥加密咧），而非对称加密指的是加密和解密过程使用不同的密钥来进行。</p><p>乍一听好像有点不可思议啊，怎么滴，难道还能两把不同的钥匙开一把锁？确实可以！这有点像中学物理里面的两个开关控制一个灯泡。在一个漆黑的楼梯两端，分别有一个开关，控制着楼梯上方的一个灯泡，上楼前先打开楼梯下面的开关，然后上楼后关掉楼梯上面的开关，而下楼时进行相反的操作，先打开楼梯上面的开关，然后下楼后默认楼梯下面的开关，找了张电路图，感兴趣可以再分析一下。</p><p><img src="https://cdn.jsdelivr.net/gh/albertgithubhome/cdn/img/card/elecswitch.png" alt="单刀双掷开关"></p><p>不过非对称加密和这种双掷开关不完全相同，使用开关时可以在同一端打开或关闭，但是非对称加密时，只能在一端加密，然后在另一端解密，同一端是不能同时加密和解密的。</p><h2 id="公钥与私钥"><a href="#公钥与私钥" class="headerlink" title="公钥与私钥"></a>公钥与私钥</h2><p>具体地，非对称加密指的是根据特殊规则生成两把密钥 <code>A</code> 和 <code>B</code>，分别叫做公钥和私钥。私钥自己保留，公钥则分发给自己的小伙伴用来用来和自己通信，理论上生成的两把密钥选择哪一把作为私钥都可以，但是出于效率和安全等方面的要求，公钥和私钥再生成时会给出特殊的条件，所以在实际使用过程中，两者通常是不会互换的。</p><h2 id="非对称加密的示例"><a href="#非对称加密的示例" class="headerlink" title="非对称加密的示例"></a>非对称加密的示例</h2><p>使用公钥和私钥怎样完成非对称加密呢？下面来看一个具体的场景，比如有 Tom 、Jerry 、Spike 三个小伙伴，有一天 Jerry 想给 Tom 发点小秘密，又不想让 Spike 发现，首先他想到的是对称加密，先和 Tom 约定一个密码，再给 Tom 发送加密消息，但是想到前几天，自己和 Tom 的消息被 Spike 破解了，因为两个人发送密钥和加密消息的过程都被窃听了，如果这次的消息再被窃听到怎么办？</p><p>后来Jerry想起Tom曾经自己生成了一对公钥和私钥，然后把公钥发给了自己和 Spike，那这样就可以使用非对称加密了，Jerry 使用 Tom 给的公钥把要发送的小秘密进行加密，然后发送给了 Tom。这时 Spike 果然在窃听，但是窃听到的消息使用了 Tom 的公钥进行了加密，只有 Tom 拥有解开这条消息的私钥，而 Spike 虽然拥有 Tom 的公钥也是解不开的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">A[I like cat] -- Jerry用Tom公钥加密 --&gt; B((密文))</span><br><span class="line">B((密文))-- 发送给Tom --&gt; C((密文))</span><br><span class="line">C((密文))-- Tom用自己的私钥解密  --&gt; D[I like cat]</span><br></pre></td></tr></table></figure><h2 id="怎么判断解开"><a href="#怎么判断解开" class="headerlink" title="怎么判断解开"></a>怎么判断解开</h2><p>上面的描述中出现了“解开”一词，这两个字在我刚开始学习加密这些知识的时候困扰了我好久，查了好多讲解也没弄明白，什么叫能解开，什么叫解不开。它不像现实生活中的事物那么形象，比如把电视打开，那么电视就出现图像了，把锁解开门就能打开了。在数据加密的过程中，数据本质上是一堆二进制数据，加密之后还是一堆二进制数据，解密时使用密钥进行特定的运算就会得到解密后的二进制数据，怎么判定这些“解开”的数据是否是原数据呢？</p><p>后来在不断的学习过程中，接触了一些开源的非对称加密算法实现，比如常用的 RSA，基础的函数包括公钥加密、私钥解密、私钥加密、公钥解密等，当你在解密时将密文和密钥传入解密函数进行特定的运算，计算过程和计算结果必须满足特定的条件，这些条件是算法保证的，如果有条件不满足那么解密失败，这就是上面所提到的解不开。</p><h2 id="非对称加密的问题"><a href="#非对称加密的问题" class="headerlink" title="非对称加密的问题"></a>非对称加密的问题</h2><p>之前提到对称加密时，密钥配送问题是一个难题，因为网络上发送密钥很容易被截获，无法保证密钥不被窃取。很多情况下又不能面对面的传递密钥，而非对称加密的出现解决了这个问题，因为公钥是可以被任何人知道的，所以网络上发送公钥就不怕被窃取，但是如果例子中，Jerry 收到的 Tom 的公钥实际上在途中被 Spike 替换了怎么办？</p><p>这就又引入了一个问题——中间人攻击，形象的来表述就是有第三方 Spike 侵入了原本两个人 Tom 和 Jerry 的通信中，Spike 对 Tom 时把自己伪装成 Jerry，和 Jerry 沟通时又将自己伪装成 Tom，这样原本两个人的沟通信息全都被第三方窃取了，这个问题的根本就是获取公钥不可信，不过证书中心可以解决这个问题，后面我们再继续深入了解，这里就不展开了。</p><h1 id="对称加密和非对称加密对比"><a href="#对称加密和非对称加密对比" class="headerlink" title="对称加密和非对称加密对比"></a>对称加密和非对称加密对比</h1><table><thead><tr><th style="text-align:left">加密类型</th><th style="text-align:center">常见算法</th><th style="text-align:center">加密处理速度</th><th style="text-align:center">遇到的问题</th><th style="text-align:center">解决办法</th></tr></thead><tbody><tr><td style="text-align:left">对称加密</td><td style="text-align:center">DES、AES</td><td style="text-align:center">快</td><td style="text-align:center">密钥配送问题</td><td style="text-align:center">面对面交换或者使用非对称加密传送秘密</td></tr><tr><td style="text-align:left">非对称加密</td><td style="text-align:center">RSA、DSA</td><td style="text-align:center">慢</td><td style="text-align:center">中间人攻击问题</td><td style="text-align:center">通过证书中心来解决中间人攻击</td></tr></tbody></table><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>虽然想写的尽可能的通俗易懂，但还是不免会引入一些令人犯困的概念，一开始记住就好，后面理解了不会觉得枯燥</li><li>还在不断尝试表达方式，总结中融入了一些我当时学习时的想法和疑惑，我遇到的这些问题应该很多人也遇到过</li><li>使用对称加密方法，速度快，效率高，但是会面临密钥配送的问题</li><li>非对称加密虽然很巧妙的，但是效率较低，所以一般的用法是使用非对称加密来传送简短的对称加密密钥，然后再使用对称加密的方式传送数据</li><li>为了更好的加密你的数据，应使用公开的加密算法，他们都是经过时间考验的，单靠隐藏加密细节来加密时很危险的</li></ul><hr><center><a href="https://blog.csdn.net/albertsh/article/details/106448035" target="_blank" rel="noopener"> ==&gt;&gt; 反爬链接，请勿点击，原地爆炸，概不负责！&lt;&lt;== </a></center><hr><blockquote><p>见过了外面的大千世界，便不再甘心留在原地，而这种不甘心恰恰就是动力~</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;进入正题之前先唠叨几句，不久前听到一个名词叫——费曼学习法，核心思想就是用通俗的话语把复杂道理或技术讲清楚，如果你已经明白了这个方法的含义，那么我好像离成功又进了一步。其实这个方法一直在尝试使用，但是没想到它居然有个“洋气”的名字。&lt;/p&gt;
    
    </summary>
    
      <category term="加密与认证" scheme="http://AlbertGithubHome.github.io/blog/categories/%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%AE%A4%E8%AF%81/"/>
    
    
      <category term="加密" scheme="http://AlbertGithubHome.github.io/blog/tags/%E5%8A%A0%E5%AF%86/"/>
    
      <category term="认证" scheme="http://AlbertGithubHome.github.io/blog/tags/%E8%AE%A4%E8%AF%81/"/>
    
      <category term="非对称加密" scheme="http://AlbertGithubHome.github.io/blog/tags/%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/"/>
    
      <category term="公钥" scheme="http://AlbertGithubHome.github.io/blog/tags/%E5%85%AC%E9%92%A5/"/>
    
      <category term="私钥" scheme="http://AlbertGithubHome.github.io/blog/tags/%E7%A7%81%E9%92%A5/"/>
    
  </entry>
  
  <entry>
    <title>git在回退版本时HEAD\~和HEAD^的作用和区别</title>
    <link href="http://AlbertGithubHome.github.io/blog/2020/05/30/git%E5%9C%A8%E5%9B%9E%E9%80%80%E7%89%88%E6%9C%AC%E6%97%B6HEAD%E2%80%A6-%E5%92%8CHEAD-%E7%9A%84%E4%BD%9C%E7%94%A8%E5%92%8C%E5%8C%BA%E5%88%AB/"/>
    <id>http://AlbertGithubHome.github.io/blog/2020/05/30/git在回退版本时HEAD…-和HEAD-的作用和区别/</id>
    <published>2020-05-29T16:39:59.000Z</published>
    <updated>2020-06-15T14:49:16.945Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>今天总结一个小知识点，虽然不难，但是对新手有很强的迷惑性，了解一下也挺好。我们在使用 Git 回退到版本的时候，可能见过这种写法 <code>git reset --hard HEAD~</code>，有时候也会遇到这种写法 <code>git reset --hard HEAD^</code>，这两个语句都是将代码库还原到上一个版本，但是只差了一个符号，他们究竟有什么区别呢？这里先给出结论：<code>HEAD~</code> 和 <code>HEAD^</code> 含义不同，功能一样！</p><a id="more"></a><h1 id="HEAD"><a href="#HEAD" class="headerlink" title="HEAD"></a>HEAD</h1><p><code>HEAD</code> 这个词在 <code>git</code> 使用过程中经常出现，作用很像是数据结构中指向二叉树根节点<code>root</code>的指针。有个 <code>root</code> 指针我们就可以对二叉树进行任意操作，它是二叉树的根基。而 <code>git</code> 中的 <code>HEAD</code> 概念也类似一个指针，它指向是当前分支的“头”，通过这个头节点可以追寻到当前分支之前的所有提交记录。</p><p><code>git</code> 的提交记录之间的关系很像一棵树，或者说是一张图，通过当前的提交记录指向上一次提交记录串联起来，形成一个头结构，而在 <code>git</code> 中我们常常说的切换分支，只不过是 <code>git</code> 客户端帮你把要操作的那条路径的头节点，存储到了 <code>HEAD</code> 文件中。</p><p><code>HEAD</code> 在 <code>git</code> 版本控制中代表头节点，也就是分支的最后一次提交，同时也是一个文件，通常在版本库中 <code>repository/.git/HEAD</code>，其中保存的一般是 <code>ref: refs/heads/master</code> 这种分支的名字，而本质上就是指向一次提交的 <code>hash</code> 值，一般长成这个样子 <code>ce11d9be5cc7007995b607fb12285a43cd03154b</code>。</p><h1 id="HEAD-和-HEAD"><a href="#HEAD-和-HEAD" class="headerlink" title="HEAD~ 和 HEAD^"></a>HEAD~ 和 HEAD^</h1><p>在 <code>HEAD</code> 后面加 <code>^</code> 或者 <code>~</code> 其实就是以 <code>HEAD</code> 为基准，来表示之前的版本，因为 <code>HEAD</code> 被认为是当前分支的最新版本，那么 <code>HEAD~</code> 和 <code>HEAD^</code> 都是指次新版本，也就是倒数第二个版本，<code>HEAD~~</code> 和 <code>HEAD^^</code> 都是指次次新版本，也就是倒数第三个版本，以此类推。</p><p>这个说法在之前的总结 <a href="https://blog.csdn.net/albertsh/article/details/104719370" target="_blank" rel="noopener">《git checkout/git reset/git revert/git restore常用回退操作》</a> 中提到过，但是并未展开说，今天就来测试一下。</p><h1 id="HEAD-后面-和-的区别"><a href="#HEAD-后面-和-的区别" class="headerlink" title="HEAD 后面 ~ 和 ^ 的区别"></a>HEAD 后面 ~ 和 ^ 的区别</h1><p>其实 <code>HEAD~</code> 和 <code>HEAD^</code> 的作用是相同的，这两者的区别出现在重复使用或者加数字的情况，下面来分情况说明一下。</p><h2 id="HEAD-和-HEAD-后面都加1"><a href="#HEAD-和-HEAD-后面都加1" class="headerlink" title="HEAD~ 和 HEAD^后面都加1"></a><code>HEAD~</code> 和 <code>HEAD^</code>后面都加1</h2><p>加上参数1之后变成了 <code>HEAD~1</code> 和 <code>HEAD^1</code>，其实这就是他们本来的面貌，在参数为 1 的情况下可以省略，<code>HEAD~1</code> 表示回退一步，参数1表示后退的步数，默认推到第一个父提交上，而<code>HEAD^1</code>表示后退一步，直接后退到第n个父提交上，数字1表示是第一个父提交。</p><p>这里引入一个父提交的概念，也就是在最新提交之前的最近的提交我称它为父提交，但是父提交会有两个吗？实际上会的，直接的父提交可能会有很多，分支合并是产生父提交的一种常见原因，两个分支合并到一起时，这两个分支的原 <code>HEAD</code> 都会成为合并后最新提交的父提交。</p><p>理解了这个概念，我们发现虽然数字是一样的，但是含义却不相同，<code>HEAD~1</code> 中指的是后退的步数，<code>HEAD^1</code>指的是退到第几个父提交上。</p><h2 id="HEAD-和-HEAD-后面都加0"><a href="#HEAD-和-HEAD-后面都加0" class="headerlink" title="HEAD~ 和 HEAD^后面都加0"></a><code>HEAD~</code> 和 <code>HEAD^</code>后面都加0</h2><p>这是一种比较特殊的情况， 加上参数0之后变成了 <code>HEAD~0</code> 和 <code>HEAD^0</code>，其实他们指向的节点没有改变，还是代表了 <code>HEAD</code>，只要了解这种情况就行了，我还没有见过谁这样写过。</p><h2 id="HEAD-和-HEAD-后面都加大于1的数字"><a href="#HEAD-和-HEAD-后面都加大于1的数字" class="headerlink" title="HEAD~ 和 HEAD^后面都加大于1的数字"></a><code>HEAD~</code> 和 <code>HEAD^</code>后面都加大于1的数字</h2><p>这时就会发现两者的不同了，比如我们把数字都定为2，那么 <code>HEAD~2</code> 代表后退两步，每一步都后退到第一个父提交上，而 <code>HEAD^2</code> 代表后退一步，这一步退到第二个父提交上，如果没有第二个父提交就会报出以下错误：</p><blockquote><p>fatal: ambiguous argument ‘HEAD^2’: unknown revision or path not in the working tree.<br>Use ‘–’ to separate paths from revisions, like this:<br>‘git <command> [<revision>…] – [<file>…]’</file></revision></p></blockquote><h1 id="具体示例"><a href="#具体示例" class="headerlink" title="具体示例"></a>具体示例</h1><p>上面说了几种加数字的情况，如果是第一次接触可能还是不太明白，没关系，我可以实际操作一下，看个具体的例子就明白了。</p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>下面是一个测试代码库的分支结构，一共有 <code>dev1</code>、<code>dev2</code>、<code>dev3</code>、<code>dev4</code> 四个分支，最终合并到 <code>dev1</code> 分支，提交记录如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc MINGW64 /d/gitstart (dev1)</span><br><span class="line">$ git alllog</span><br><span class="line">*   ce11d9b (HEAD -&gt; dev1) Merge branch <span class="string">'dev3'</span> into dev1</span><br><span class="line">|\</span><br><span class="line">| * e330eac (dev3) update at dev3 - 3</span><br><span class="line">| *   7ab3c98 Merge branch <span class="string">'dev4'</span> into dev3</span><br><span class="line">| |\</span><br><span class="line">| | * c8795e8 (dev4) update at dev4 - 2</span><br><span class="line">| | * 155d3db update at dev4 - 1</span><br><span class="line">| * | ccdf16a update at dev3 - 2</span><br><span class="line">| * | 9f08bb0 update at dev3 - 1</span><br><span class="line">| |/</span><br><span class="line">* | f82b57b update at dev1 - 3</span><br><span class="line">* |   dcdcb87 Merge branch <span class="string">'dev2'</span> into dev1</span><br><span class="line">|\ \</span><br><span class="line">| * | 32d6213 (dev2) update at dev2 - 2</span><br><span class="line">| * | ca4db4a update at dev2 - 1</span><br><span class="line">| |/</span><br><span class="line">| * d8d80b7 update readme at dev2</span><br><span class="line">* | 034ccb6 update readme at dev1 - 2</span><br><span class="line">* | d58fedc update readme at dev1 - 1</span><br></pre></td></tr></table></figure><p>也许有颜色标记会看得更清楚一些，所以截个图放在这：</p><p><img src="https://cdn.jsdelivr.net/gh/albertgithubhome/cdn/img/card/githead.png" alt="git_branch_head"></p><p>刚看这种图的时候要注意一点，记录列表中的先后关系不代表提交时间的先后，如果习惯于看SVN的记录以后，很容易在看日志信息时加上时间因素，但是这个时间因素在 <code>git</code> 查看记录时变得不再明显，比如上面记录中的 <code>e330eac</code> 在图形上要比 <code>f82b57b</code> 更接近 HEAD 提交 <code>ce11d9b</code>，但是因为处在不同的分支上，在合并之前他俩的修改时间还真不一定是哪个更早一些。</p><h2 id="树形记录"><a href="#树形记录" class="headerlink" title="树形记录"></a>树形记录</h2><p>在 <code>git</code> 的提交记录图上，我们可以确定当前提交的父提交（所依赖的提交）是哪一个或者哪几个，但是不能确定任意两个提交的时间先后，为了能更清楚的看清分支提交的依赖关系，还是看下面这个树形图更方便一些。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">graph TB</span><br><span class="line">    ce11d9b--&gt;f82b57b;</span><br><span class="line">    f82b57b--&gt;dcdcb87;</span><br><span class="line">    dcdcb87--&gt;034ccb6;</span><br><span class="line">    034ccb6--&gt;d58fedc;</span><br><span class="line">    d58fedc--&gt;dev1;</span><br><span class="line"></span><br><span class="line">    dcdcb87--&gt;32d6213;</span><br><span class="line">    32d6213--&gt;ca4db4a;</span><br><span class="line">    ca4db4a--&gt;dev2;</span><br><span class="line"></span><br><span class="line">    ce11d9b--&gt;e330eac;</span><br><span class="line">    e330eac--&gt;7ab3c98;</span><br><span class="line">    7ab3c98--&gt;ccdf16a;</span><br><span class="line">    ccdf16a--&gt;9f08bb0;</span><br><span class="line">    9f08bb0--&gt;dev3;</span><br><span class="line"></span><br><span class="line">    7ab3c98--&gt;c8795e8;</span><br><span class="line">    c8795e8--&gt;155d3db;</span><br><span class="line">    155d3db--&gt;dev4;</span><br></pre></td></tr></table></figure><h2 id="查看命令"><a href="#查看命令" class="headerlink" title="查看命令"></a>查看命令</h2><p>在验证 <code>HEAD~</code> 和 <code>HEAD^</code> 之前我们先学习一个命令 <code>git rev-parse HEAD</code> 这个命令可以显示出 <code>HEAD</code> 对应的提交的 hash 值，加上 <code>--short</code> 参数就可以显示出长度为7位的短 hash，用起来比较方便，测试如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc MINGW64 /d/gitstart (dev1)</span><br><span class="line">$ git rev-parse HEAD</span><br><span class="line">ce11d9be5cc7007995b607fb12285a43cd03154b</span><br><span class="line"></span><br><span class="line">albert@home-pc MINGW64 /d/gitstart (dev1)</span><br><span class="line">$ git rev-parse --short HEAD</span><br><span class="line">ce11d9b</span><br></pre></td></tr></table></figure><h2 id="开始测试"><a href="#开始测试" class="headerlink" title="开始测试"></a>开始测试</h2><p>下面可以用 <code>git rev-parse --short</code> 命令来测试 <code>HEAD</code> 后面跟不同参数时对应的提交是哪一个了，测试如下：</p><h3 id="HEAD-、HEAD-、HEAD-1、HEAD-1"><a href="#HEAD-、HEAD-、HEAD-1、HEAD-1" class="headerlink" title="HEAD~、HEAD^、HEAD~1、HEAD^1"></a><code>HEAD~</code>、<code>HEAD^</code>、<code>HEAD~1</code>、<code>HEAD^1</code></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc MINGW64 /d/gitstart (dev1)</span><br><span class="line">$ git rev-parse --short HEAD~</span><br><span class="line">f82b57b</span><br><span class="line"></span><br><span class="line">albert@home-pc MINGW64 /d/gitstart (dev1)</span><br><span class="line">$ git rev-parse --short HEAD^</span><br><span class="line">f82b57b</span><br><span class="line"></span><br><span class="line">albert@home-pc MINGW64 /d/gitstart (dev1)</span><br><span class="line">$ git rev-parse --short HEAD~1</span><br><span class="line">f82b57b</span><br><span class="line"></span><br><span class="line">albert@home-pc MINGW64 /d/gitstart (dev1)</span><br><span class="line">$ git rev-parse --short HEAD^1</span><br><span class="line">f82b57b</span><br></pre></td></tr></table></figure><p>测试后发现，这四种写法结果是一样的，都是指向 <code>HEAD</code> 的第一个父提交，这和我们前面说的观点一致。</p><h3 id="HEAD-、HEAD-、HEAD-2、HEAD-2"><a href="#HEAD-、HEAD-、HEAD-2、HEAD-2" class="headerlink" title="HEAD~~、HEAD^^、HEAD~2、HEAD^2"></a><code>HEAD~~</code>、<code>HEAD^^</code>、<code>HEAD~2</code>、<code>HEAD^2</code></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc MINGW64 /d/gitstart (dev1)</span><br><span class="line">$ git rev-parse --short HEAD~~</span><br><span class="line">dcdcb87</span><br><span class="line"></span><br><span class="line">albert@home-pc MINGW64 /d/gitstart (dev1)</span><br><span class="line">$ git rev-parse --short HEAD^^</span><br><span class="line">dcdcb87</span><br><span class="line"></span><br><span class="line">albert@home-pc MINGW64 /d/gitstart (dev1)</span><br><span class="line">$ git rev-parse --short HEAD~2</span><br><span class="line">dcdcb87</span><br><span class="line"></span><br><span class="line">albert@home-pc MINGW64 /d/gitstart (dev1)</span><br><span class="line">$ git rev-parse --short HEAD^2</span><br><span class="line">e330eac</span><br></pre></td></tr></table></figure><p>这次我们发现，前三个表示方法是一样的，指向同一个提交记录，但是最后一个与他们不同，这时根据前面提到定义来看就行了，<code>HEAD~~</code> 实际上是 <code>HEAD~1~1</code>的简写，而<code>~</code> 后的数字就是指的后退的步数，所以 <code>HEAD~~</code> 等价于 <code>HEAD~2</code>，属于一种合并计算。</p><p><code>HEAD^^</code> 是 <code>HEAD^1^1</code> 的简写，而 <code>^</code> 后面的数字表示后退一步到第几个父提交上，因为数字是1，所以 <code>HEAD^^</code> 表示退一步到第一个父提交上，在退一步到第一个父提交上，这时与 <code>HEAD~~</code> 的作用是相同的。</p><p><code>HEAD^2</code> 就有些不同了，它表示后退一步到第二个父提交上，所以对照树形图是第二排的第二个节点。</p><h3 id="和-混合使用"><a href="#和-混合使用" class="headerlink" title="~ 和 ^ 混合使用"></a>~ 和 ^ 混合使用</h3><p>看了上面的例子对于 <code>~</code> 和 <code>^</code> 的使用应该有些明白了，它俩其实可以组合使用的，比如想退到第5排、第2个节点上，也就是 <code>ca4db4a</code> 上，简单来看需要第一步到第一个父提交上，在退一步到第一个父提交上，然后退一步到第二个父提交上，最后退一步到第一个父提交上。</p><p>那么我们根据需求可以写成 <code>HEAD^1^1^2^1</code>，测试一下看看 hash 是否正确：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc MINGW64 /d/gitstart (dev1)</span><br><span class="line">$ git rev-parse --short HEAD^1^1^2^1</span><br><span class="line">ca4db4a</span><br></pre></td></tr></table></figure><p>测试发现没有问题，其实还可以合并啊，我们知道1是可以省略的，所以可以简写成 <code>HEAD^^^2^</code>，另外多个 <code>^</code> 还可以写成 <code>~n</code> 的形式，所以这个节点还可以表示成 <code>HEAD~2^2^</code>的样子，测试如下，结果是一样的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc MINGW64 /d/gitstart (dev1)</span><br><span class="line">$ git rev-parse --short HEAD^^^2^</span><br><span class="line">ca4db4a</span><br><span class="line"></span><br><span class="line">albert@home-pc MINGW64 /d/gitstart (dev1)</span><br><span class="line">$ git rev-parse --short HEAD~2^2^</span><br><span class="line">ca4db4a</span><br></pre></td></tr></table></figure><h3 id="关于-git-reset-的一点思考"><a href="#关于-git-reset-的一点思考" class="headerlink" title="关于 git reset 的一点思考"></a>关于 git reset 的一点思考</h3><p>刚学习 <code>git reset</code> 的命令时一直认为是一个回退命令，其实学习一段时间之后发现，这个命令其实很符合它的名字，就是一个重置(reset)命令，通过 <code>git reset</code> 命令可以修改 <code>HEAD</code> 指向不同的提交，这个提交甚至都不必是当前分支上的某次提交，测试后发现，只要是版本库中合法提交都可以使用这个命令进行设置，相应的版本库的内容也会发生对应的变化，从这一点来看，它真的太强大了，它可以使你正在开发的 <code>dev</code> 分支瞬间变成 <code>master</code> 分支。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li><code>HEAD~</code> 后面加数字表示后退的步数，每次后退都默认退到第一个父提交上，<code>HEAD~2</code> 表示连退两步。</li><li><code>HEAD^</code> 后面加数字表示只退一步，但是这一步后退到数字表示的父提交上，<code>HEAD^2</code> 表示退一步到第二个父提交上。</li><li><code>git</code> 在查看多分支提交记录时，日志的先后顺序不代表提交时间的先后顺序。</li><li><code>git reset</code> 命令是一个重置 <code>HEAD</code> 的命令，可以指挥版本库指向任何一个合法提交。</li></ul><hr><blockquote><p>俗话说：人不犯我，我不犯人；可俗话又说：先下手为强，后下手遭殃！<br>俗话说：宁为玉碎，不为瓦全；可俗话又说：留得青山在，不怕没柴烧！<br>…<br>其实只要你变成了那个成功的“俗话”，你说的就是金科玉律，警世哲理！</p><p>2020-5-31 14:51:49</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;今天总结一个小知识点，虽然不难，但是对新手有很强的迷惑性，了解一下也挺好。我们在使用 Git 回退到版本的时候，可能见过这种写法 &lt;code&gt;git reset --hard HEAD~&lt;/code&gt;，有时候也会遇到这种写法 &lt;code&gt;git reset --hard HEAD^&lt;/code&gt;，这两个语句都是将代码库还原到上一个版本，但是只差了一个符号，他们究竟有什么区别呢？这里先给出结论：&lt;code&gt;HEAD~&lt;/code&gt; 和 &lt;code&gt;HEAD^&lt;/code&gt; 含义不同，功能一样！&lt;/p&gt;
    
    </summary>
    
      <category term="Git" scheme="http://AlbertGithubHome.github.io/blog/categories/Git/"/>
    
    
      <category term="reset" scheme="http://AlbertGithubHome.github.io/blog/tags/reset/"/>
    
      <category term="版本控制" scheme="http://AlbertGithubHome.github.io/blog/tags/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"/>
    
      <category term="Git" scheme="http://AlbertGithubHome.github.io/blog/tags/Git/"/>
    
      <category term="HEAD" scheme="http://AlbertGithubHome.github.io/blog/tags/HEAD/"/>
    
  </entry>
  
  <entry>
    <title>配置Beyond Compare 4作为git mergetool来解决git merge命令导致的文件冲突</title>
    <link href="http://AlbertGithubHome.github.io/blog/2020/05/21/%E9%85%8D%E7%BD%AEBeyond-Compare-4%E4%BD%9C%E4%B8%BAgit-mergetool%E6%9D%A5%E8%A7%A3%E5%86%B3git-merge%E5%91%BD%E4%BB%A4%E5%AF%BC%E8%87%B4%E7%9A%84%E6%96%87%E4%BB%B6%E5%86%B2%E7%AA%81/"/>
    <id>http://AlbertGithubHome.github.io/blog/2020/05/21/配置Beyond-Compare-4作为git-mergetool来解决git-merge命令导致的文件冲突/</id>
    <published>2020-05-21T15:31:49.000Z</published>
    <updated>2020-05-22T16:48:27.315Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>使用 <code>git merge</code> 命令合并代码的时候可能会产生文件冲突，产生这种冲突的根本原因是文件的同一处同时被多次修改，这种同时修改常体现的不同分支上，当多个分支修改了同一处代码，再合并代码的时候就会产生冲突，因为 <code>git</code> 程序也不知道我们想要保留哪一份修改，这时就需要我们手动修改产生冲突的文件。</p><p>当冲突内容很少的时候我们可以打开文本编辑器，找到 <code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code>、<code>===========</code> 和 <code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code> 这三行字符包裹的内容就是需要解决冲突的部分，但是当冲突内容特别多时我们还是习惯于通过可视化的工具来处理，<code>Beyond Compare</code> 就是这样一款工具，可以用来比较不同的文本文件、表格文件，还可以比较文件夹内容，之前用着比较习惯，所以在处理 <code>git</code> 冲突的时候也想使用这个工具来做，通过查找技术文档发现了下面的方法。</p><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p>鉴于大家都比较急，查找问题时想要直接找到答案，所以我这里直接说明配置步骤，送给不求甚解的小伙伴，也方便今后我可以直接找到，不过配置之前还是要先看一下前提。</p><h2 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h2><ul><li>在 Windows 上安装了 <code>git</code> 客户端，可以执行 <code>git</code> 命令（废话！没装 <code>git</code> 怎么产生冲突的）</li><li>安装了 <code>Beyond Compare 4</code> 这个软件，下载链接很多，自己找一个吧，实在找不到，那就放弃吧（找我要）</li></ul><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>首先找到 <code>Beyond Compare</code> 的安装路径，比如我的软件安装路径是 <code>D:\mybc4\BComp.exe</code>，然后在 <code>git</code> 命令行客户端中执行下面命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git config --global merge.tool bc4</span><br><span class="line">git config --global mergetool.bc4.cmd <span class="string">"\"D:\\mybc4\\BComp.exe\" \"\$LOCAL\" \"\$REMOTE\" \"\$BASE\" \"\$MERGED\""</span></span><br><span class="line">git config --global mergetool.bc4.trustExitCode <span class="literal">true</span></span><br><span class="line">git config --global mergetool.keepBackup <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>至此，<code>git mergetool</code> 就配置完了，当下次冲突的时候，直接使用 <code>git mergetool</code> 命令就可以调用 <code>Beyond Compare</code> 解决冲突文件了，但是你不好奇，这些设置命令都是什么意思吗？为什么执行完这些命令就能调用 <code>Beyond Compare 4</code> 这个软件了，如果你感兴趣可以接下往下看一看。</p><h1 id="Beyond-Compare"><a href="#Beyond-Compare" class="headerlink" title="Beyond Compare"></a>Beyond Compare</h1><p>这是一款强大的比较工具，前面提到它可以比较文本、比较表格、比较文件夹，但是它的能力不仅限于此，它甚至可以比较MP3、比较图片、比较注册表，我们的目的是调用它的比较功能，但是前提是这款软件允许你调用，如果它不给你提供接口，你就是想调用也得绕上八百个圈才可以。</p><p>这一点我们可以查询文档确定，文档是安装软件时自带的，名字为 <code>BCompare.chm</code>，如果找不到，安利你一个叫做 <code>Everything</code> 的软件，装上它以后，电脑中的一切东西都能搜索找到。</p><p>这个文档应该很容易找到的，与软件的可执行文件在同一目录，其实我们使用的比较工具应该是 <code>BCompare.exe</code>，但是为什么在配置 <code>git mergetool</code> 的是后用的是 <code>BComp.exe</code> 呢？这一点文档中有写：</p><blockquote><p>BCompare.exe: This is the main application.  Only one copy will run at a time, regardless of how many windows you have open.  If you launch a second copy it will tell the existing copy to start a comparison and exit immediately.<br>BComp.exe: This is a Win32 GUI program.  If launched from a version control system, it should work just fine.  If launched from a console window, the console (or batch file) will not wait for it.</p></blockquote><p>文档是英文的，但是比较容易理解，总的来说 <code>BCompare.exe</code> 是主程序，<code>BComp.exe</code> 用在版本控制工具中更加优秀，至于文档中提到的主程序只能启动一个副本的说明，我试了一下并不是这样的，但是这不是重点，根据文档建议，我们应该调用 <code>BComp.exe</code> 程序。</p><p>关于调用参数，文档中对于每种形式的比较也给出了说明，我们这里只列举两个文件和四个文件这两种参数，两个文件作为参数时常用来对比，我直接使用主程序对比文件就是这种形式，参数格式为 <code>BCompare.exe &quot;C:\Left File.ext&quot; &quot;C:\Right File.ext&quot;</code>，但是使用时我常把文件直接拖拽到软件上进行比较。四个文件作为参数时常用来处理文件冲突，参数类型为 <code>BCompare.exe C:\Left.ext C:\Right.ext C:\Center.ext C:\Output.ext</code>，参数中文件的名字表明处理时的位置和作用，看下面这个图就明白了。</p><p><img src="https://cdn.jsdelivr.net/gh/albertgithubhome/cdn/img/card/bc4_cmp.png" alt="解决文件合并冲突1"></p><p>从红框圈定的位置就可以发现和文件的对应关系了，最下面是最终的输出文件，也是我们可以手动修改的文件。</p><h1 id="文件冲突及处理"><a href="#文件冲突及处理" class="headerlink" title="文件冲突及处理"></a>文件冲突及处理</h1><h2 id="产生冲突"><a href="#产生冲突" class="headerlink" title="产生冲突"></a>产生冲突</h2><p>先看一下 <code>git</code> 仓库的原始情况</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc MINGW64 /d/gitstart (dev)</span><br><span class="line">$ git status</span><br><span class="line">On branch dev</span><br><span class="line">Your branch is up to date with <span class="string">'origin/dev'</span>.</span><br><span class="line"></span><br><span class="line">nothing to commit, working tree clean</span><br><span class="line"></span><br><span class="line">albert@home-pc MINGW64 /d/gitstart (dev)</span><br><span class="line">$ ls</span><br><span class="line">README.md</span><br><span class="line"></span><br><span class="line">albert@home-pc MINGW64 /d/gitstart (dev)</span><br><span class="line">$ cat README.md</span><br><span class="line">learn git branch <span class="built_in">command</span></span><br><span class="line">m2</span><br><span class="line"><span class="built_in">test</span> checkout</span><br></pre></td></tr></table></figure><p>在此基础上新建两个分支 <code>dev1</code> 和 <code>dev2</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc MINGW64 /d/gitstart (dev)</span><br><span class="line">$ git checkout -b dev1</span><br><span class="line">Switched to a new branch <span class="string">'dev1'</span></span><br><span class="line"></span><br><span class="line">albert@home-pc MINGW64 /d/gitstart (dev1)</span><br><span class="line">$ git checkout -b dev2</span><br><span class="line">Switched to a new branch <span class="string">'dev2'</span></span><br><span class="line"></span><br><span class="line">albert@home-pc MINGW64 /d/gitstart (dev2)</span><br><span class="line">$ git branch | grep dev</span><br><span class="line">  dev</span><br><span class="line">  dev1</span><br><span class="line">* dev2</span><br></pre></td></tr></table></figure><p>在 <code>dev2</code> 分支上修改 <code>README.md</code> 文件后提交</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc MINGW64 /d/gitstart (dev2)</span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">"this is dev2 test"</span>&gt;&gt;README.md</span><br><span class="line"></span><br><span class="line">albert@home-pc MINGW64 /d/gitstart (dev2)</span><br><span class="line">$ git add README.md</span><br><span class="line">warning: LF will be replaced by CRLF <span class="keyword">in</span> README.md.</span><br><span class="line">The file will have its original line endings <span class="keyword">in</span> your working directory</span><br><span class="line"></span><br><span class="line">albert@home-pc MINGW64 /d/gitstart (dev2)</span><br><span class="line">$ git commit -m<span class="string">"update readme at dev2"</span></span><br><span class="line">[dev2 d8d80b7] update readme at dev2</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line"></span><br><span class="line">albert@home-pc MINGW64 /d/gitstart (dev2)</span><br><span class="line">$ cat README.md</span><br><span class="line">learn git branch <span class="built_in">command</span></span><br><span class="line">m2</span><br><span class="line"><span class="built_in">test</span> checkout</span><br><span class="line">this is dev2 <span class="built_in">test</span></span><br></pre></td></tr></table></figure><p>切换回 <code>dev1</code> 分支修改 <code>README.md</code> 文件后提交</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc MINGW64 /d/gitstart (dev2)</span><br><span class="line">$ git checkout dev1</span><br><span class="line">Switched to branch <span class="string">'dev1'</span></span><br><span class="line"></span><br><span class="line">albert@home-pc MINGW64 /d/gitstart (dev1)</span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">"this is dev1 test"</span>&gt;&gt;README.md</span><br><span class="line"></span><br><span class="line">albert@home-pc MINGW64 /d/gitstart (dev1)</span><br><span class="line">$ git add README.md</span><br><span class="line">warning: LF will be replaced by CRLF <span class="keyword">in</span> README.md.</span><br><span class="line">The file will have its original line endings <span class="keyword">in</span> your working directory</span><br><span class="line">git com -</span><br><span class="line">albert@home-pc MINGW64 /d/gitstart (dev1)</span><br><span class="line">$ git commit -m<span class="string">"update readme at dev1"</span></span><br><span class="line">[dev1 3136341] update readme at dev1</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line"></span><br><span class="line">albert@home-pc MINGW64 /d/gitstart (dev1)</span><br><span class="line">$ cat README.md</span><br><span class="line">learn git branch <span class="built_in">command</span></span><br><span class="line">m2</span><br><span class="line"><span class="built_in">test</span> checkout</span><br><span class="line">this is dev1 <span class="built_in">test</span></span><br></pre></td></tr></table></figure><p>这时在 <code>dev1</code> 分支上合并 <code>dev2</code> 分支上的修改就会产生冲突</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc MINGW64 /d/gitstart (dev1)</span><br><span class="line">$ git merge dev2</span><br><span class="line">Auto-merging README.md</span><br><span class="line">CONFLICT (content): Merge conflict <span class="keyword">in</span> README.md</span><br><span class="line">Automatic merge failed; fix conflicts and <span class="keyword">then</span> commit the result.</span><br><span class="line"></span><br><span class="line">albert@home-pc MINGW64 /d/gitstart (dev1|MERGING)</span><br><span class="line">$ cat README.md</span><br><span class="line">learn git branch <span class="built_in">command</span></span><br><span class="line">m2</span><br><span class="line"><span class="built_in">test</span> checkout</span><br><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span><br><span class="line">this is dev1 <span class="built_in">test</span></span><br><span class="line">=======</span><br><span class="line">this is dev2 <span class="built_in">test</span></span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; dev2</span><br><span class="line"></span><br><span class="line">albert@home-pc MINGW64 /d/gitstart (dev1|MERGING)</span><br><span class="line">$ ls</span><br><span class="line">README.md</span><br></pre></td></tr></table></figure><p>冲突产生了，文档中同一位置被两个分支修改后合并导致的，内容里出现了 <code>&lt;&lt;&lt;</code>、<code>===</code>、<code>&gt;&gt;&gt;</code>，包裹的内容被分成了两部分，上面一部分是当前分支修改的，下面一部分是从 <code>dev2</code> 分支合并过来的，还要注意虽然产生了产生了冲突，但是目录中并没有产生其他多余的文件。</p><h2 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h2><p>这样的冲突比较简单，我们只要使用文本工具删除不想要的内容，保存后 <code>git add README.md</code>，然后再 <code>git commit</code> 就完成了冲突的解决，但是因为配置了 <code>git mergetool</code>，我们可以用它来解决冲突，直接在命令行敲命令 <code>git mergetool</code> 就可以:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc MINGW64 /d/gitstart (dev1|MERGING)</span><br><span class="line">$ git mergetool</span><br><span class="line">Merging:</span><br><span class="line">README.md</span><br><span class="line"></span><br><span class="line">Normal merge conflict <span class="keyword">for</span> <span class="string">'README.md'</span>:</span><br><span class="line">  &#123;<span class="built_in">local</span>&#125;: modified file</span><br><span class="line">  &#123;remote&#125;: modified file</span><br></pre></td></tr></table></figure><p>这时光标不会退出，一闪一闪并且打开 <code>BComp.exe</code> 工具，截图如下：</p><p><img src="https://cdn.jsdelivr.net/gh/albertgithubhome/cdn/img/card/bc4_save.png" alt="解决文件合并冲突2"></p><p>这时如果你打开 <code>git</code> 库所在目录会发现除了 <code>README.md</code> 还多了下面4个文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">README.md</span><br><span class="line">README_BACKUP_584.md</span><br><span class="line">README_BASE_584.md</span><br><span class="line">README_LOCAL_584.md</span><br><span class="line">README_REMOTE_584.md</span><br></pre></td></tr></table></figure><p>按照自己的实际情况修改最下面的文件，然后点击箭头所指的保存按钮，关闭 <code>Beyond Compare</code>，查询一下仓库状态</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc MINGW64 /d/gitstart (dev1|MERGING)</span><br><span class="line">$ git status</span><br><span class="line">On branch dev1</span><br><span class="line">All conflicts fixed but you are still merging.</span><br><span class="line">  (use <span class="string">"git commit"</span> to conclude merge)</span><br><span class="line"></span><br><span class="line">Changes to be committed:</span><br><span class="line">        modified:   README.md</span><br><span class="line"></span><br><span class="line">albert@home-pc MINGW64 /d/gitstart (dev1|MERGING)</span><br><span class="line">$ ls</span><br><span class="line">README.md</span><br></pre></td></tr></table></figure><p>不但冲突文件没有了，还给我们自动执行 <code>git add README.md</code> 命令，我们只需要执行 <code>git commit</code> 就解决完了冲突。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc MINGW64 /d/gitstart (dev1|MERGING)</span><br><span class="line">$ git commit</span><br><span class="line">[dev1 b348ae6] Merge branch <span class="string">'dev2'</span> into dev1</span><br><span class="line"></span><br><span class="line">albert@home-pc MINGW64 /d/gitstart (dev1)</span><br><span class="line">$ git adog</span><br><span class="line">*   b348ae6 (HEAD -&gt; dev1) Merge branch <span class="string">'dev2'</span> into dev1</span><br><span class="line">|\</span><br><span class="line">| * d8d80b7 (dev2) update readme at dev2</span><br><span class="line">* | 3136341 update readme at dev1</span><br><span class="line">|/</span><br><span class="line">* 5f4181e (origin/dev, dev) add comments</span><br></pre></td></tr></table></figure><h1 id="工具配置的参数含义"><a href="#工具配置的参数含义" class="headerlink" title="工具配置的参数含义"></a>工具配置的参数含义</h1><p>回过头来再看看 <code>git mergetool</code> 的4句配置到底有什么用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git config --global merge.tool bc4</span><br><span class="line">git config --global mergetool.bc4.cmd <span class="string">"\"D:\\mybc4\\BComp.exe\" \"\$LOCAL\" \"\$REMOTE\" \"\$BASE\" \"\$MERGED\""</span></span><br><span class="line">git config --global mergetool.bc4.trustExitCode <span class="literal">true</span></span><br><span class="line">git config --global mergetool.keepBackup <span class="literal">false</span></span><br></pre></td></tr></table></figure><h2 id="git-config"><a href="#git-config" class="headerlink" title="git config"></a>git config</h2><p>首先你需要知道 <code>git config</code> 的作用，就是用来配置 <code>git</code> 的，加上了 <code>--global</code> 表示调整全局 <code>git</code> 配置，不加的话就是调整当前库的 <code>git</code> 配置。windows上的全局配置一般在 <code>C:\Users\用户名\.gitconfig</code>，如果你之前用过 <code>git</code>，一般会执行过 <code>git config --global user.name xxx</code> 对吧，这些命令都是来调整 <code>git</code> 配置的，打开这个 <code>.gitconfig</code> 你会看到</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[user]</span><br><span class="line">    name = albert</span><br><span class="line">    email = albert@163.com</span><br><span class="line">[core]</span><br><span class="line">    autocrlf = true</span><br><span class="line">[alias]</span><br><span class="line">    st = status</span><br><span class="line">    adog = &quot;log --all --decorate --oneline --graph&quot;</span><br><span class="line">[merge]</span><br><span class="line">    tool = bc4</span><br><span class="line">[mergetool &quot;bc4&quot;]</span><br><span class="line">    cmd = \&quot;D:\\mybc4\\BComp.exe\&quot; \&quot;$LOCAL\&quot; \&quot;$REMOTE\&quot; \&quot;$BASE\&quot; \&quot;$MERGED\&quot;</span><br><span class="line">    trustExitCode = true</span><br><span class="line">[mergetool]</span><br><span class="line">    keepBackup = false</span><br></pre></td></tr></table></figure><p>看看最后几行就是我们添加的4项配置，只不过到文件中变成了键值对的形式，经过测试后发现，这些属性最少两级，比如 <code>user.name</code> 、<code>core.autocrlf</code>，最多三级比如 <code>mergetool.bc4.cmd</code>、 <code>mergetool.bc4.trustExitCode</code>，如果级数再多会怎么办，你可以试试 <code>git config --global a.b.c.d.e test</code>，它最终也会被拆成三级如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[a &quot;b.c.d&quot;]</span><br><span class="line">    e = test</span><br></pre></td></tr></table></figure><h2 id="git-mergetool"><a href="#git-mergetool" class="headerlink" title="git mergetool"></a>git mergetool</h2><p>这个需要查一下官方文档了，<code>git mergetool --help</code> 就能打开<a href="https://git-scm.com/docs" target="_blank" rel="noopener">git官方文档</a>，文档写得真不错，排版格式看着就很舒服。</p><p>文档提到添加 <code>--tool-help</code> 选项可以列举可以的合并工具，展示如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">albert@home-pc MINGW64 /d/gitstart (dev1)</span><br><span class="line">$ git mergetool --tool-help</span><br><span class="line"><span class="string">'git mergetool --tool=&lt;tool&gt;'</span> may be <span class="built_in">set</span> to one of the following:</span><br><span class="line">                vimdiff</span><br><span class="line">                vimdiff2</span><br><span class="line">                vimdiff3</span><br><span class="line"></span><br><span class="line">        user-defined:</span><br><span class="line">                bc4.cmd <span class="string">"D:\Program Files\Beyond Compare 4\BComp.exe"</span> <span class="string">"<span class="variable">$LOCAL</span>"</span> <span class="string">"<span class="variable">$REMOTE</span>"</span> <span class="string">"<span class="variable">$BASE</span>"</span> <span class="string">"<span class="variable">$MERGED</span>"</span></span><br><span class="line"></span><br><span class="line">The following tools are valid, but not currently available:</span><br><span class="line">                araxis</span><br><span class="line">                bc</span><br><span class="line">                bc3</span><br><span class="line">                codecompare</span><br><span class="line">                deltawalker</span><br><span class="line">                diffmerge</span><br><span class="line">                diffuse</span><br><span class="line">                ecmerge</span><br><span class="line">                emerge</span><br><span class="line">                examdiff</span><br><span class="line">                guiffy</span><br><span class="line">                gvimdiff</span><br><span class="line">                gvimdiff2</span><br><span class="line">                gvimdiff3</span><br><span class="line">                kdiff3</span><br><span class="line">                meld</span><br><span class="line">                opendiff</span><br><span class="line">                p4merge</span><br><span class="line">                smerge</span><br><span class="line">                tkdiff</span><br><span class="line">                tortoisemerge</span><br><span class="line">                winmerge</span><br><span class="line">                xxdiff</span><br><span class="line"></span><br><span class="line">Some of the tools listed above only work <span class="keyword">in</span> a windowed</span><br><span class="line">environment. If run <span class="keyword">in</span> a terminal-only session, they will fail.</span><br></pre></td></tr></table></figure><p>这一查才发现，原来 <code>git mergetool</code> 支持的工具有这么多，不过下面这些我都没安装，用一下上面列举的3个，试试 <code>git mergetool --tool=vimdiff</code>，果然打开了一个界面</p><p><img src="https://cdn.jsdelivr.net/gh/albertgithubhome/cdn/img/card/bc4_vimdiff.png" alt="解决文件合并冲突3"></p><p>幸亏不如 <code>Beyond Compare</code> 好用，不然我不是白配置了，不过这些工具确实方便，都不需要配置，只要安装了参数中指定一下就可以用了，比如这个 <code>bc3</code>，我猜它是 <code>Beyond Compare 3</code>，只不过我安装的是 <code>Beyond Compare 4</code> 这个版本。</p><p>这些内置工具使用的前提是已经安装了，并且安装软件的目录放在了环境变量 <code>Path</code> 中，如果没有放在这个变量中需要通过 <code>mergetool.&lt;tool&gt;.path</code> 参数来配置，比如我把 <code>Beyond Compare 3</code> 安装在了 <code>D</code> 盘根目录，就可以设置 <code>git config --global mergetool.bc3.path &quot;D:\\&quot;</code>。</p><p>我们在可用工具中没有找到 <code>Beyond Compare 4</code> 为什么我们可以用呢？因为 <code>git mergetool</code> 命令还支持自定义合并解决冲突的工具，只要指定 <code>mergetool.&lt;tool&gt;.cmd</code> 就可以调用了，就像 <code>git mergetool --tool-help</code> 查询结果中提到的 <code>user-defined: bc4.cmd &quot;D:\Program Files\Beyond Compare 4\BComp.exe&quot; &quot;$LOCAL&quot; &quot;$REMOTE&quot; &quot;$BASE&quot; &quot;$MERGED&quot;</code>，<code>git mergetool</code> 把 <code>bc4</code> 作为了一个等同于内置合并工具的软件。</p><p>再来看看这4句配置的含义：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git config --global merge.tool bc4</span><br><span class="line">git config --global mergetool.bc4.cmd <span class="string">"\"D:\\mybc4\\BComp.exe\" \"\$LOCAL\" \"\$REMOTE\" \"\$BASE\" \"\$MERGED\""</span></span><br><span class="line">git config --global mergetool.bc4.trustExitCode <span class="literal">true</span></span><br><span class="line">git config --global mergetool.keepBackup <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>第一句 <code>git config --global merge.tool bc4</code> 是说把 <code>git mergetool</code> 的默认工具配置成 <code>bc4</code>，如果不指定默认工具在使用时就需要写成 <code>git mergetool --tool=bc4</code> 或者 <code>git mergetool -t bc4</code> 了，可是 <code>bc4</code> 是我们自己起的名字，根本就没有这个名字啊，接着往下看。</p><p>第二句 <code>git config --global mergetool.bc4.cmd &quot;\&quot;D:\\mybc4\\BComp.exe\&quot; \&quot;\$LOCAL\&quot; \&quot;\$REMOTE\&quot; \&quot;\$BASE\&quot; \&quot;\$MERGED\&quot;&quot;</code> 指定了工具 <code>bc4</code> 的调用路径和参数，后面的这4个参数都是 <code>git mergetool</code> 命令提供的，依次代表本地修改，被合并分支修改，两端未修改前版本文件，最终合并导出的文本文件。</p><p>第三句 <code>git config --global mergetool.bc4.trustExitCode true</code>， 设置为 <code>true</code> 表示信任软件的返回码，并依据返回码确定合并是否成功，如果设置成 <code>false</code> 就会在合并完成后问你是否解决完冲突，设置成 <code>true</code> 会方便很多。</p><p>第四句 <code>git config --global mergetool.keepBackup false</code>， 是指定在合并完成后删除备份文件 <code>*.orig</code>，这个文件会在调用 <code>git mergetool</code> 是产生 <code>*.orig</code> 备份文件，成功合并后自动删除就可以了。</p><h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><p>至此终于弄明白这个 <code>git mergetool</code> 是怎么工作的了，但是想这样一个问题，这个 <code>&lt;tool&gt;.cmd</code> 一定得调用冲突解决工具吗？如果你从头看到这里应该会明白，这里只是给用户提供了一个调用自定义工具的方式，至于你调用什么它是不关心的，你完全可以在 <code>git mergetool</code> 的时候让电脑关机，这些都是可以的，在你明白了原理以后，一切都变得简单了。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li><code>Beyond Compare</code> 是一款强大的比较工具，合理的使用可以有效的提升工作效率</li><li><code>git mergetool</code> 内置了很多可以使用的合并工具，并且支持调用自定义的合并工具</li><li><code>git</code> 的官方文档写得真的挺详细，有时间可以多看一看，你会发现很多有意思的功能</li><li>急于解决问题时可以不求甚解，解决问题后最好可以明白其中的缘由，这其实就是一种进步</li></ul><hr><blockquote><p>尽管科技很发达，但有些人一旦分开可能真的就是一生不见了</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;使用 &lt;code&gt;git merge&lt;/code&gt; 命令合并代码的时候可能会产生文件冲突，产生这种冲突的根本原因是文件的同一处同时被多次修改
      
    
    </summary>
    
      <category term="Git" scheme="http://AlbertGithubHome.github.io/blog/categories/Git/"/>
    
    
      <category term="git" scheme="http://AlbertGithubHome.github.io/blog/tags/git/"/>
    
      <category term="工具" scheme="http://AlbertGithubHome.github.io/blog/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="mergetool" scheme="http://AlbertGithubHome.github.io/blog/tags/mergetool/"/>
    
      <category term="文件冲突" scheme="http://AlbertGithubHome.github.io/blog/tags/%E6%96%87%E4%BB%B6%E5%86%B2%E7%AA%81/"/>
    
      <category term="bc4" scheme="http://AlbertGithubHome.github.io/blog/tags/bc4/"/>
    
  </entry>
  
  <entry>
    <title>使用c++filt命令还原C++编译后的函数名</title>
    <link href="http://AlbertGithubHome.github.io/blog/2020/05/16/%E4%BD%BF%E7%94%A8c-filt%E5%91%BD%E4%BB%A4%E8%BF%98%E5%8E%9FC-%E7%BC%96%E8%AF%91%E5%90%8E%E7%9A%84%E5%87%BD%E6%95%B0%E5%90%8D/"/>
    <id>http://AlbertGithubHome.github.io/blog/2020/05/16/使用c-filt命令还原C-编译后的函数名/</id>
    <published>2020-05-16T13:22:43.000Z</published>
    <updated>2020-05-17T03:22:00.538Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这个命令功能单一，但是非常强大，可以用来还原C++编译后的函数名，为什么C++的函数名需要单独的命令来还原，因为他们看起来都是这样 <code>_ZNK4Json5ValueixEPKc</code>、这样 <code>_Z41__static_initialization_and_destruction_0ii</code> 或者这样的 <code>_ZN6apsara5pangu15ScopedChunkInfoINS0_12RafChunkInfoEED1Ev</code>，仅通过这一串字母很难知道原函数的名字是什么，参数类型就更难分析了，实际上C++在编译函数时有一套命名函数的规则，每种参数使用什么字母表示都是有约定的，但是通过学习这些约定来还原函数太麻烦了，还好有人编写了 <code>c++filt</code> 命令可以让我们直接得到编译前的函数名，真好……</p><h1 id="C-编译后的函数名"><a href="#C-编译后的函数名" class="headerlink" title="C++编译后的函数名"></a>C++编译后的函数名</h1><p><code>C++</code> 编译后的函数名字非常古怪，相比而言 <code>C</code> 语言编译后的函数看起来就正常许多了，<code>extern &quot;C&quot;</code>、函数重载、<code>name mangling</code> 这些知识点都与 <code>C++</code> 这个奇怪的函数名有些关系，<code>extern &quot;C&quot;</code> 的作用简而言之就是告诉编译器和链接器被“我”修饰的变量和函数需要按照 <code>C</code> 语言方式进行编译和链接，这样做是由于 <code>C++</code> 支持函数重载，而 <code>C</code> 语言不支持，结果导致函数被 <code>C++</code> 编译后在符号库中的名字和被 <code>C</code>语言编译后的名字是不一样的，程序编译和连接就会出现问题，此类问题一般出现在 <code>C++</code> 代码调用 <code>C</code> 语言写的库函数的时候。</p><p>而 <code>name mangling</code> 就是实现 <code>C++</code> 函数重载的一种技术或者叫做方式，要求同名的 <code>C++</code> 函数参数个数不同或参数类型不同，如果只有返回值类型不同，那么两个函数被认为是相同的函数，无法成功通过编译。接下来我们就来看几个例子，看看 <code>C++</code> 编译后的函数名有什么变化。</p><h2 id="C-和C语言编译后的函数名对比"><a href="#C-和C语言编译后的函数名对比" class="headerlink" title="C++和C语言编译后的函数名对比"></a>C++和C语言编译后的函数名对比</h2><p>我们来写一段相同的代码，分别使用 <code>gcc</code> 和 <code>g++</code> 进行编译，从代码到可执行文件需要经历“预处理、编译、汇编、链接”4个步骤，接下来为了看到编译后函数名的不同，我们只进行前两步，生成汇编代码，再来比较不同。</p><h3 id="gcc编译simple-c文件"><a href="#gcc编译simple-c文件" class="headerlink" title="gcc编译simple.c文件"></a>gcc编译simple.c文件</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// simple.c</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">myadd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">110</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">119</span>;</span><br><span class="line">    <span class="keyword">int</span> c = myadd(a, b);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>gcc simple.c -S</code> 生成汇编代码文件simple.s内容</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">    .file   <span class="string">"simple.c"</span></span><br><span class="line">    .text</span><br><span class="line">    .globl  myadd</span><br><span class="line">    .type   myadd, @function</span><br><span class="line">myadd:</span><br><span class="line">.LFB0:</span><br><span class="line">    .cfi_startproc</span><br><span class="line">    pushq   %rbp</span><br><span class="line">    .cfi_def_cfa_offset <span class="number">16</span></span><br><span class="line">    .cfi_offset <span class="number">6</span>, <span class="number">-16</span></span><br><span class="line">    movq    %rsp, %rbp</span><br><span class="line">    .cfi_def_cfa_register <span class="number">6</span></span><br><span class="line">    movl    %edi, <span class="number">-4</span>(%rbp)</span><br><span class="line">    movl    %esi, <span class="number">-8</span>(%rbp)</span><br><span class="line">    movl    <span class="number">-4</span>(%rbp), %edx</span><br><span class="line">    movl    <span class="number">-8</span>(%rbp), %eax</span><br><span class="line">    addl    %edx, %eax</span><br><span class="line">    popq    %rbp</span><br><span class="line">    .cfi_def_cfa <span class="number">7</span>, <span class="number">8</span></span><br><span class="line">    ret</span><br><span class="line">    .cfi_endproc</span><br><span class="line">.LFE0:</span><br><span class="line">    .size   myadd, .-myadd</span><br><span class="line">    .globl  main</span><br><span class="line">    .type   main, @function</span><br><span class="line">main:</span><br><span class="line">.LFB1:</span><br><span class="line">    .cfi_startproc</span><br><span class="line">    pushq   %rbp</span><br><span class="line">    .cfi_def_cfa_offset <span class="number">16</span></span><br><span class="line">    .cfi_offset <span class="number">6</span>, <span class="number">-16</span></span><br><span class="line">    movq    %rsp, %rbp</span><br><span class="line">    .cfi_def_cfa_register <span class="number">6</span></span><br><span class="line">    subq    $<span class="number">16</span>, %rsp</span><br><span class="line">    movl    $<span class="number">110</span>, <span class="number">-12</span>(%rbp)</span><br><span class="line">    movl    $<span class="number">119</span>, <span class="number">-8</span>(%rbp)</span><br><span class="line">    movl    <span class="number">-8</span>(%rbp), %edx</span><br><span class="line">    movl    <span class="number">-12</span>(%rbp), %eax</span><br><span class="line">    movl    %edx, %esi</span><br><span class="line">    movl    %eax, %edi</span><br><span class="line">    call    myadd</span><br><span class="line">    movl    %eax, <span class="number">-4</span>(%rbp)</span><br><span class="line">    movl    $<span class="number">0</span>, %eax</span><br><span class="line">    leave</span><br><span class="line">    .cfi_def_cfa <span class="number">7</span>, <span class="number">8</span></span><br><span class="line">    ret</span><br><span class="line">    .cfi_endproc</span><br><span class="line">.LFE1:</span><br><span class="line">    .size   main, .-main</span><br><span class="line">    .ident  <span class="string">"GCC: (Ubuntu 5.4.0-6ubuntu1~16.04.12) 5.4.0 20160609"</span></span><br><span class="line">    .section    .note.GNU-<span class="built_in">stack</span>,<span class="string">""</span>,@progbits</span><br></pre></td></tr></table></figure><h3 id="g-编译simple-cpp文件"><a href="#g-编译simple-cpp文件" class="headerlink" title="g++编译simple.cpp文件"></a>g++编译simple.cpp文件</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// simple.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">myadd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">110</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">119</span>;</span><br><span class="line">    <span class="keyword">int</span> c = myadd(a, b);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>g++ simple.cpp -S</code> 生成汇编代码文件simple.s内容</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">    .file   <span class="string">"simple.cpp"</span></span><br><span class="line">    .text</span><br><span class="line">    .globl  _Z5myaddii</span><br><span class="line">    .type   _Z5myaddii, @function</span><br><span class="line">_Z5myaddii:</span><br><span class="line">.LFB0:</span><br><span class="line">    .cfi_startproc</span><br><span class="line">    pushq   %rbp</span><br><span class="line">    .cfi_def_cfa_offset <span class="number">16</span></span><br><span class="line">    .cfi_offset <span class="number">6</span>, <span class="number">-16</span></span><br><span class="line">    movq    %rsp, %rbp</span><br><span class="line">    .cfi_def_cfa_register <span class="number">6</span></span><br><span class="line">    movl    %edi, <span class="number">-20</span>(%rbp)</span><br><span class="line">    movl    %esi, <span class="number">-24</span>(%rbp)</span><br><span class="line">    movl    $<span class="number">0</span>, <span class="number">-4</span>(%rbp)</span><br><span class="line">    movl    <span class="number">-20</span>(%rbp), %edx</span><br><span class="line">    movl    <span class="number">-24</span>(%rbp), %eax</span><br><span class="line">    addl    %edx, %eax</span><br><span class="line">    movl    %eax, <span class="number">-4</span>(%rbp)</span><br><span class="line">    movl    <span class="number">-4</span>(%rbp), %eax</span><br><span class="line">    popq    %rbp</span><br><span class="line">    .cfi_def_cfa <span class="number">7</span>, <span class="number">8</span></span><br><span class="line">    ret</span><br><span class="line">    .cfi_endproc</span><br><span class="line">.LFE0:</span><br><span class="line">    .size   _Z5myaddii, .-_Z5myaddii</span><br><span class="line">    .globl  main</span><br><span class="line">    .type   main, @function</span><br><span class="line">main:</span><br><span class="line">.LFB1:</span><br><span class="line">    .cfi_startproc</span><br><span class="line">    pushq   %rbp</span><br><span class="line">    .cfi_def_cfa_offset <span class="number">16</span></span><br><span class="line">    .cfi_offset <span class="number">6</span>, <span class="number">-16</span></span><br><span class="line">    movq    %rsp, %rbp</span><br><span class="line">    .cfi_def_cfa_register <span class="number">6</span></span><br><span class="line">    subq    $<span class="number">16</span>, %rsp</span><br><span class="line">    movl    $<span class="number">110</span>, <span class="number">-12</span>(%rbp)</span><br><span class="line">    movl    $<span class="number">119</span>, <span class="number">-8</span>(%rbp)</span><br><span class="line">    movl    $<span class="number">0</span>, <span class="number">-4</span>(%rbp)</span><br><span class="line">    movl    <span class="number">-8</span>(%rbp), %edx</span><br><span class="line">    movl    <span class="number">-12</span>(%rbp), %eax</span><br><span class="line">    movl    %edx, %esi</span><br><span class="line">    movl    %eax, %edi</span><br><span class="line">    call    _Z5myaddii</span><br><span class="line">    movl    %eax, <span class="number">-4</span>(%rbp)</span><br><span class="line">    movl    $<span class="number">0</span>, %eax</span><br><span class="line">    leave</span><br><span class="line">    .cfi_def_cfa <span class="number">7</span>, <span class="number">8</span></span><br><span class="line">    ret</span><br><span class="line">    .cfi_endproc</span><br><span class="line">.LFE1:</span><br><span class="line">    .size   main, .-main</span><br><span class="line">    .ident  <span class="string">"GCC: (Ubuntu 5.4.0-6ubuntu1~16.04.12) 5.4.0 20160609"</span></span><br><span class="line">    .section    .note.GNU-<span class="built_in">stack</span>,<span class="string">""</span>,@progbits</span><br></pre></td></tr></table></figure><p>虽然只有几行代码，可是生成汇编文件之后变成了50多行，我们只需要关注 <code>myadd()</code> 这个函数编译之后变成了什么就可以了，汇编代码虽然不好读，但是查找一个函数名应该没问题的，对照着上面的代码我们发现，<code>myadd()</code> 这个函数通过 <code>gcc</code> 编译之后的函数名还是 <code>myadd</code>，而通过 <code>g++</code> 编译之后的函数名变成了 <code>_Z5myaddii</code>，可以明显感觉到最后的两个字母 <code>i</code> 代表的是参数 <code>int</code>，使用 <code>c++filt</code> 命令还原如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ c++filt _Z5myaddii</span><br><span class="line">myadd(int, int)</span><br></pre></td></tr></table></figure><h2 id="C-函数重载编译后的函数名对比"><a href="#C-函数重载编译后的函数名对比" class="headerlink" title="C++函数重载编译后的函数名对比"></a>C++函数重载编译后的函数名对比</h2><p>我们还是在刚才的代码的基础上增加一个参数类型不同的 <code>myadd</code> 函数，修改后的代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">myadd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">myadd</span><span class="params">(<span class="keyword">float</span> a, <span class="keyword">float</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c = myadd(<span class="number">110</span>, <span class="number">119</span>);</span><br><span class="line">    <span class="keyword">float</span> d = myadd(<span class="number">52.0f</span>, <span class="number">13.14f</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>g++ simple.cpp -S</code> 生成汇编代码文件simple.s内容为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">    .file   <span class="string">"simple.cpp"</span></span><br><span class="line">    .text</span><br><span class="line">    .globl  _Z5myaddii</span><br><span class="line">    .type   _Z5myaddii, @function</span><br><span class="line">_Z5myaddii:</span><br><span class="line">.LFB0:</span><br><span class="line">    .cfi_startproc</span><br><span class="line">    pushq   %rbp</span><br><span class="line">    .cfi_def_cfa_offset <span class="number">16</span></span><br><span class="line">    .cfi_offset <span class="number">6</span>, <span class="number">-16</span></span><br><span class="line">    movq    %rsp, %rbp</span><br><span class="line">    .cfi_def_cfa_register <span class="number">6</span></span><br><span class="line">    movl    %edi, <span class="number">-4</span>(%rbp)</span><br><span class="line">    movl    %esi, <span class="number">-8</span>(%rbp)</span><br><span class="line">    movl    <span class="number">-4</span>(%rbp), %edx</span><br><span class="line">    movl    <span class="number">-8</span>(%rbp), %eax</span><br><span class="line">    addl    %edx, %eax</span><br><span class="line">    popq    %rbp</span><br><span class="line">    .cfi_def_cfa <span class="number">7</span>, <span class="number">8</span></span><br><span class="line">    ret</span><br><span class="line">    .cfi_endproc</span><br><span class="line">.LFE0:</span><br><span class="line">    .size   _Z5myaddii, .-_Z5myaddii</span><br><span class="line">    .globl  _Z5myaddff</span><br><span class="line">    .type   _Z5myaddff, @function</span><br><span class="line">_Z5myaddff:</span><br><span class="line">.LFB1:</span><br><span class="line">    .cfi_startproc</span><br><span class="line">    pushq   %rbp</span><br><span class="line">    .cfi_def_cfa_offset <span class="number">16</span></span><br><span class="line">    .cfi_offset <span class="number">6</span>, <span class="number">-16</span></span><br><span class="line">    movq    %rsp, %rbp</span><br><span class="line">    .cfi_def_cfa_register <span class="number">6</span></span><br><span class="line">    movss   %xmm0, <span class="number">-4</span>(%rbp)</span><br><span class="line">    movss   %xmm1, <span class="number">-8</span>(%rbp)</span><br><span class="line">    movss   <span class="number">-4</span>(%rbp), %xmm0</span><br><span class="line">    addss   <span class="number">-8</span>(%rbp), %xmm0</span><br><span class="line">    popq    %rbp</span><br><span class="line">    .cfi_def_cfa <span class="number">7</span>, <span class="number">8</span></span><br><span class="line">    ret</span><br><span class="line">    .cfi_endproc</span><br><span class="line">.LFE1:</span><br><span class="line">    .size   _Z5myaddff, .-_Z5myaddff</span><br><span class="line">    .globl  main</span><br><span class="line">    .type   main, @function</span><br><span class="line">main:</span><br><span class="line">.LFB2:</span><br><span class="line">    .cfi_startproc</span><br><span class="line">    pushq   %rbp</span><br><span class="line">    .cfi_def_cfa_offset <span class="number">16</span></span><br><span class="line">    .cfi_offset <span class="number">6</span>, <span class="number">-16</span></span><br><span class="line">    movq    %rsp, %rbp</span><br><span class="line">    .cfi_def_cfa_register <span class="number">6</span></span><br><span class="line">    subq    $<span class="number">16</span>, %rsp</span><br><span class="line">    movl    $<span class="number">119</span>, %esi</span><br><span class="line">    movl    $<span class="number">110</span>, %edi</span><br><span class="line">    call    _Z5myaddii</span><br><span class="line">    movl    %eax, <span class="number">-8</span>(%rbp)</span><br><span class="line">    movss   .LC0(%rip), %xmm1</span><br><span class="line">    movss   .LC1(%rip), %xmm0</span><br><span class="line">    call    _Z5myaddff</span><br><span class="line">    movd    %xmm0, %eax</span><br><span class="line">    movl    %eax, <span class="number">-4</span>(%rbp)</span><br><span class="line">    movl    $<span class="number">0</span>, %eax</span><br><span class="line">    leave</span><br><span class="line">    .cfi_def_cfa <span class="number">7</span>, <span class="number">8</span></span><br><span class="line">    ret</span><br><span class="line">    .cfi_endproc</span><br><span class="line">.LFE2:</span><br><span class="line">    .size   main, .-main</span><br><span class="line">    .section    .rodata</span><br><span class="line">    .align <span class="number">4</span></span><br><span class="line">.LC0:</span><br><span class="line">    .<span class="keyword">long</span>   <span class="number">1095908721</span></span><br><span class="line">    .align <span class="number">4</span></span><br><span class="line">.LC1:</span><br><span class="line">    .<span class="keyword">long</span>   <span class="number">1112539136</span></span><br><span class="line">    .ident  <span class="string">"GCC: (Ubuntu 5.4.0-6ubuntu1~16.04.12) 5.4.0 20160609"</span></span><br><span class="line">    .section    .note.GNU-<span class="built_in">stack</span>,<span class="string">""</span>,@progbits</span><br></pre></td></tr></table></figure><p>这次一共3个函数，生成的汇编代码更长，但是我们一眼就能看见汇编代码中包含 <code>_Z5myaddii</code> 和 <code>_Z5myaddff</code> 两个函数，这就是函数重载的产物，两个参数类型不同的同名函数编译之后生成了不同的名字，<code>_Z5myaddff</code> 函数末尾的两个 <code>f</code> 应该指的就是参数类型 <code>float</code>。</p><h1 id="使用c-filt定位问题示例"><a href="#使用c-filt定位问题示例" class="headerlink" title="使用c++filt定位问题示例"></a>使用c++filt定位问题示例</h1><p>c++filt的作用就是还原函数名字，它可以帮我们查找动态链接库中缺少的函数，还原崩溃堆栈中一大串的函数名字母等等，下面来看一个崩溃堆栈的例子，代码内容尽量简写，只为了说明问题，现实情况可能要复杂的多。</p><!-- ldd -r test.so --><p>首先定义一个打印函数堆栈的函数，参考之前的总结<a href="https://blog.csdn.net/albertsh/article/details/100594143" target="_blank" rel="noopener">《linux环境下C++代码打印函数堆栈调用情况》</a>，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;execinfo.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_stack</span><span class="params">(<span class="keyword">int</span> nSignal)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> MAX_STACK_FRAMES = <span class="number">12</span>;</span><br><span class="line">    <span class="keyword">void</span> *pStack[MAX_STACK_FRAMES];</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> szStackInfo[<span class="number">1024</span> * MAX_STACK_FRAMES];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> ** pStackList = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> frames = backtrace(pStack, MAX_STACK_FRAMES);</span><br><span class="line">    pStackList = backtrace_symbols(pStack, frames);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == pStackList)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">strcpy</span>(szStackInfo, <span class="string">"stack traceback:\n"</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; frames; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">NULL</span> == pStackList[i])</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">strncat</span>(szStackInfo, pStackList[i], <span class="number">1024</span>);</span><br><span class="line">        <span class="built_in">strcat</span>(szStackInfo, <span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; szStackInfo; <span class="comment">// 输出到控制台，也可以打印到日志文件中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再写一段隐藏着崩溃问题的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CTest</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span>&amp; <span class="title">get_string</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> s;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set_string</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; str)</span> </span>&#123;s = str;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> s;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">float</span> z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *p = <span class="literal">nullptr</span>;</span><br><span class="line">    *p = <span class="number">110</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; z;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CTest* pTest = <span class="keyword">new</span> CTest();</span><br><span class="line">    pTest-&gt;set_string(<span class="string">"20200517"</span>);</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; s = pTest-&gt;get_string();</span><br><span class="line">    <span class="keyword">delete</span> pTest;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="string">"20200517"</span>) foo(<span class="number">13.14</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> s = <span class="built_in">std</span>::to_string(a) + <span class="built_in">std</span>::to_string(b);</span><br><span class="line">    test(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    signal(SIGSEGV, show_stack);</span><br><span class="line">    func(<span class="number">250</span>, <span class="number">520</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译运行，果然崩溃了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ g++ simple.cpp --std=c++11</span><br><span class="line">$ ./a.out</span><br><span class="line">stack traceback:</span><br><span class="line">./a.out() [0x401aff]</span><br><span class="line">/lib/x86_64-linux-gnu/libc.so.6(+0x354b0) [0x7fd5f98b54b0]</span><br><span class="line">/lib/x86_64-linux-gnu/libc.so.6(+0x16eff6) [0x7fd5f99eeff6]</span><br><span class="line">/usr/lib/x86_64-linux-gnu/libstdc++.so.6(_ZNKSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE7compareEPKc+0x3a) [0x7fd5f9f9145a]</span><br><span class="line">./a.out() [0x4022b6]</span><br><span class="line">./a.out() [0x401d30]</span><br><span class="line">./a.out() [0x401e27]</span><br><span class="line">./a.out() [0x401ed8]</span><br><span class="line">/lib/x86_64-linux-gnu/libc.so.6(__libc_start_main+0xf0) [0x7fd5f98a0830]</span><br><span class="line">./a.out() [0x4019f9]</span><br></pre></td></tr></table></figure><p>这时崩溃的堆栈中发现了一个特别长的函数 <code>_ZNKSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE7compareEPKc</code>，使用 <code>c++filt</code> 命令来还原函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ c++filt _ZNKSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE7compareEPKc</span><br><span class="line"><span class="built_in">std</span>::__cxx11::basic_string&lt;<span class="keyword">char</span>, <span class="built_in">std</span>::char_traits&lt;<span class="keyword">char</span>&gt;, <span class="built_in">std</span>::allocator&lt;<span class="keyword">char</span>&gt; &gt;::compare(<span class="keyword">char</span> <span class="keyword">const</span>*) <span class="keyword">const</span></span><br></pre></td></tr></table></figure><p>从函数名来看是一个与字符串相关的 <code>compare</code> 函数，查看代码发现是 <code>s == &quot;20200517&quot;</code> 这一句的问题，所以说能确切的知道函数名对我们查找问题来说还是挺有帮助的。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li><code>c++filt</code> 命令可以还原 <code>C++</code> 为实现函数重载采用 <code>name mangling</code> 搞出来的奇奇怪怪的函数名</li><li>注册信号回调函数方式：<code>signal(SIGSEGV, show_stack);</code>，<code>SIGSEGV</code>代表无效的内存引用</li><li>注意 <code>C</code> 语言和 <code>C++</code> 在编译后函数命名方式的不同，<code>C</code> 语言不支持严格意义的重载，C++支持</li></ul><hr><blockquote><p>阳光、空气、水，这些真的是好东西，当你真的快要失去它们才意识的到的话就有些晚了…</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;这个命令功能单一，但是非常强大，可以用来还原C++编译后的函数名，为什么C++的函数名需要单独的命令来还原，因为他们看起来都是这样 &lt;cod
      
    
    </summary>
    
      <category term="C/C++" scheme="http://AlbertGithubHome.github.io/blog/categories/C-C/"/>
    
    
      <category term="C/C++" scheme="http://AlbertGithubHome.github.io/blog/tags/C-C/"/>
    
      <category term="linux" scheme="http://AlbertGithubHome.github.io/blog/tags/linux/"/>
    
      <category term="工具" scheme="http://AlbertGithubHome.github.io/blog/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="c++filt" scheme="http://AlbertGithubHome.github.io/blog/tags/c-filt/"/>
    
  </entry>
  
  <entry>
    <title>汇编指令入门级整理</title>
    <link href="http://AlbertGithubHome.github.io/blog/2020/05/09/%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4%E5%85%A5%E9%97%A8%E7%BA%A7%E6%95%B4%E7%90%86/"/>
    <id>http://AlbertGithubHome.github.io/blog/2020/05/09/汇编指令入门级整理/</id>
    <published>2020-05-08T16:00:11.000Z</published>
    <updated>2020-05-10T12:42:32.561Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我们大都是被高级语言惯坏了的一代，源源不断的新特性正在逐步添加到各类高级语言之中，汇编作为最接近机器指令的低级语言，已经很少被直接拿来写程序了，不过我还真的遇到了一个，那是之前的一个同事，因为在写代码时遇到了成员函数权限及可见性的问题，导致他无法正确调用想执行的函数，结果他就开始在 <code>C++</code> 代码里嵌入汇编了，绕过了种种限制终于如愿以偿，但是读代码的我们傻眼了…</p><a id="more"></a><p>因为项目是跨平台的，代码推送的 Linux 上编译的时候他才发现，汇编代码的语法在 Linux 和 Windows 上居然是不一样的，结果他又用一个判断平台的宏定义“完美”的解决了，最终这些代码肯定是重写了啊，因为可读性太差了，最近在学习左值、右值、左引用和右引用的时候，总是有人用程序编译生成的中间汇编代码来解释问题，看得我迷迷糊糊，所以决定熟悉一下简单的汇编指令，边学习边记录，方便今后忘记了可以直接拿来复习。</p><h1 id="什么是汇编语言"><a href="#什么是汇编语言" class="headerlink" title="什么是汇编语言"></a>什么是汇编语言</h1><p>汇编语言是最接近机器语言的编程语言，引用百科中的一段话解释为：</p><blockquote><p>汇编语言（assembly language）是一种用于电子计算机、微处理器、微控制器或其他可编程器件的低级语言，亦称为符号语言。在汇编语言中，用助记符代替机器指令的操作码，用地址符号或标号代替指令或操作数的地址。汇编语言又被称为第二代计算机语言。</p></blockquote><h2 id="汇编语言产生的原因"><a href="#汇编语言产生的原因" class="headerlink" title="汇编语言产生的原因"></a>汇编语言产生的原因</h2><p>对于绝大多数人来说，二进制程序是不可读的，当然有能人可以读，比如第一代程序员，但这类人快灭绝了，直接看二进制不容易看出来究竟做了什么事情，比如最简单的加法指令二进制表示为 <code>00000011</code>，如果它混在一大串01字符串中就很难把它找出来，所以汇编语言主要就是为了解决二进制编码的可读性问题。</p><h2 id="汇编与二进制的关系"><a href="#汇编与二进制的关系" class="headerlink" title="汇编与二进制的关系"></a>汇编与二进制的关系</h2><p>换句话来说，汇编语言就是把给机器看的二进制编码翻译成人话，汇编指令是机器指令的助记符，与机器指令是一一对应的关系，是一种便于阅读和记忆的书写格式。有效地解决了机器指令编写程序难度大的问题，并且使用编译器，可以很方便的把汇编程序转译成机器指令程序，比如之前提到的 <code>00000011</code> 加法指令，对应的汇编指令是 <code>ADD</code>，在调用汇编器时就会把 <code>ADD</code> 翻译成 <code>00000011</code>。</p><h1 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h1><p>说到汇编指令不得不提到寄存器，寄存器本身是用来存数据的，因为 <code>CPU</code> 本身只负责逻辑运算，数据需要单独储存在其他的地方，但是对于不熟悉寄存器的人来说会有疑惑，数据不是存在硬盘上吗？或者说数据不是存在内存中吗？这些想法都没错，那么寄存器是用来做什么的呢？</p><h2 id="寄存器作用"><a href="#寄存器作用" class="headerlink" title="寄存器作用"></a>寄存器作用</h2><p>其实硬盘、内存都是用来存储数据的，但是 <code>CPU</code> 的运算速度远高于内存的读写速度，更不用说从硬盘上取数据了，所以为了避免被拖慢速度影响效率，<code>CPU</code> 都自带一级缓存和二级缓存，一些 <code>CPU</code> 甚至增加了三级缓存，从这些缓存中读写数据要比内存快很多，但是还是无法使用飞速运转的 <code>CPU</code>，所以才会有寄存器的存在。</p><p>寄存器不是后来增加的，在最初的计算中就已经设计出来，相比而言，多级缓存出现的更晚一些，通常那些最频繁读写的数据都会被放在寄存器里面，<code>CPU</code> 优先读写寄存器，再通过寄存器、缓存跟内存来交换数据，达到缓冲的目的，因为可以通过名称访问寄存器，这样访问速度是最快的，因此也被称为零级缓存。</p><h2 id="存取速度比较"><a href="#存取速度比较" class="headerlink" title="存取速度比较"></a>存取速度比较</h2><p>通过上面的叙述我们可以知道存取速度从高到低分别是: <code>寄存器 &gt; 1级缓存 &gt; 2级缓存 &gt; 3级缓存 &gt; 内存 &gt; 硬盘</code>，关于它们的存取速度，举个例子很容易就能明白了，比如我们做菜（CPU工作）时，取手中（寄存器）正拿着的肉和蔬菜肯定是最快的，如果没有就需要把案板上（1级缓存）处理好的菜拿过来，如果案板上没有就在更远一点的洗菜池（2级缓存）中找一找，还没找到的话就要到冰箱（3级缓存）中看一看了，这时发现家里真没有，那去楼下的菜店（内存）去买点吧，转了一圈发现没有想要的，最后还是开车去农贸市场（硬盘）买吧。</p><p>通过上面这个例子应该能明白它们的速度关系了，既然缓存这么快，为什么不用缓存代替内存，或者将2、3级缓存都换成1级缓存呢？这里边有一个成本问题，速度越快对应着价格越高，如果你买过机械硬盘和固态硬盘应该很容易就理解了。</p><h2 id="寄存器分类"><a href="#寄存器分类" class="headerlink" title="寄存器分类"></a>寄存器分类</h2><p>常用的 <code>x86 CPU</code> 寄存器有8个：<code>EAX</code> 、<code>EBX</code>、<code>ECX</code>、<code>EDX</code>、<code>EDI</code>、<code>ESI</code>、<code>EBP</code>、<code>ESP</code>，据说现在寄存器总数已经超过100个了，等我找到相关资料再来补充，上面这几个寄存器是最常用的，这些名字也常常出现在汇编的代码中。</p><p>我们常说的32位、64位 <code>CPU</code> 是指数据总线的宽度或根数，而寄存器是暂存数据和中间结果的单元，因此寄存器的位数也就是处理数据的长度与数据总线的根数是相同的，所以32位 <code>CPU</code> 对应的寄存器也应该是32位的。</p><h2 id="常用寄存器用途"><a href="#常用寄存器用途" class="headerlink" title="常用寄存器用途"></a>常用寄存器用途</h2><p>上面提到大8个寄存器都有其特定的用途，我们以32位 <code>CPU</code> 为例简单说明下这些寄存器的作用，整理如下表：</p><table><thead><tr><th style="text-align:center">寄存器</th><th style="text-align:center">含义</th><th style="text-align:center">用途</th><th style="text-align:center">包含寄存器</th></tr></thead><tbody><tr><td style="text-align:center">EAX</td><td style="text-align:center">累加(Accumulator)寄存器</td><td style="text-align:center">常用于乘、除法和函数返回值</td><td style="text-align:center">AX(AH、AL)</td></tr><tr><td style="text-align:center">EBX</td><td style="text-align:center">基址(Base)寄存器</td><td style="text-align:center">常做内存数据的指针, 或者说常以它为基址来访问内存.</td><td style="text-align:center">BX(BH、BL)</td></tr><tr><td style="text-align:center">ECX</td><td style="text-align:center">计数器(Counter)寄存器</td><td style="text-align:center">常做字符串和循环操作中的计数器</td><td style="text-align:center">CX(CH、CL)</td></tr><tr><td style="text-align:center">EDX</td><td style="text-align:center">数据(Data)寄存器</td><td style="text-align:center">常用于乘、除法和 I/O 指针</td><td style="text-align:center">DX(DH、DL)</td></tr><tr><td style="text-align:center">ESI</td><td style="text-align:center">来源索引(Source Index)寄存器</td><td style="text-align:center">常做内存数据指针和源字符串指针</td><td style="text-align:center">SI</td></tr><tr><td style="text-align:center">EDI</td><td style="text-align:center">目的索引(Destination Index)寄存器</td><td style="text-align:center">常做内存数据指针和目的字符串指针</td><td style="text-align:center">DI</td></tr><tr><td style="text-align:center">ESP</td><td style="text-align:center">堆栈指针(Stack Point)寄存器</td><td style="text-align:center">只做堆栈的栈顶指针; 不能用于算术运算与数据传送</td><td style="text-align:center">SP</td></tr><tr><td style="text-align:center">EBP</td><td style="text-align:center">基址指针(Base Point)寄存器</td><td style="text-align:center">只做堆栈指针, 可以访问堆栈内任意地址, 经常用于中转 ESP 中的数据, 也常以它为基址来访问堆栈; 不能用于算术运算与数据传送</td><td style="text-align:center">BP</td></tr></tbody></table><h2 id="寄存器EAX、AX、AH、AL的关系"><a href="#寄存器EAX、AX、AH、AL的关系" class="headerlink" title="寄存器EAX、AX、AH、AL的关系"></a>寄存器EAX、AX、AH、AL的关系</h2><p>在上面的图标中每个常用寄存器后面还有其他的名字，它们是同一个寄存器不同用法下的不同名字，比如在32位 <code>CPU</code> 上，EAX是32位的寄存器，而AX是EAX的低16位，AH是AX的高8位，而AL是AX的低8位，它们的对照关系如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">00000000 00000000 00000000 00000000</span><br><span class="line">|===============EAX===============|---4个字节</span><br><span class="line">                  |======AX=======|---2个字节</span><br><span class="line">                  |==AH===|-----------1个字节</span><br><span class="line">                          |===AL==|---1个字节</span><br></pre></td></tr></table></figure><h1 id="汇编语言指令"><a href="#汇编语言指令" class="headerlink" title="汇编语言指令"></a>汇编语言指令</h1><p>终于说到汇编常用指令了，因为 <code>linux</code> 和 <code>windows</code> 下的汇编语法是有些不同的，所以下面我们先通过 <code>windows</code> 下的汇编指令来简单学习一下，后续再来比较两者的不同。</p><h2 id="数据传送指令"><a href="#数据传送指令" class="headerlink" title="数据传送指令"></a>数据传送指令</h2><table><thead><tr><th style="text-align:center">指令</th><th style="text-align:center">名称</th><th style="text-align:center">示例</th><th style="text-align:center">备注</th></tr></thead><tbody><tr><td style="text-align:center">MOV</td><td style="text-align:center">传送指令</td><td style="text-align:center">MOV dest, src</td><td style="text-align:center">将数据从src移动到dest</td></tr><tr><td style="text-align:center">PUSH</td><td style="text-align:center">进栈指令</td><td style="text-align:center">PUSH src</td><td style="text-align:center">把源操作数src压入堆栈</td></tr><tr><td style="text-align:center">POP</td><td style="text-align:center">出栈指令</td><td style="text-align:center">POP desc</td><td style="text-align:center">从栈顶弹出字数据到dest</td></tr></tbody></table><h2 id="算术运算指令"><a href="#算术运算指令" class="headerlink" title="算术运算指令"></a>算术运算指令</h2><table><thead><tr><th style="text-align:center">指令</th><th style="text-align:center">名称</th><th style="text-align:center">示例</th><th style="text-align:center">备注</th></tr></thead><tbody><tr><td style="text-align:center">ADD</td><td style="text-align:center">加法指令</td><td style="text-align:center">ADD dest, src</td><td style="text-align:center">在dest基础上加src</td></tr><tr><td style="text-align:center">SUB</td><td style="text-align:center">减法指令</td><td style="text-align:center">SUB dest, src</td><td style="text-align:center">在dest基础上减src</td></tr><tr><td style="text-align:center">INC</td><td style="text-align:center">加1指令</td><td style="text-align:center">INC dest</td><td style="text-align:center">在dest基础上加1</td></tr><tr><td style="text-align:center">DEC</td><td style="text-align:center">减1指令</td><td style="text-align:center">DEC dest</td><td style="text-align:center">在dest基础上减1</td></tr></tbody></table><h2 id="逻辑运算指令"><a href="#逻辑运算指令" class="headerlink" title="逻辑运算指令"></a>逻辑运算指令</h2><table><thead><tr><th style="text-align:center">指令</th><th style="text-align:center">名称</th><th style="text-align:center">示例</th><th style="text-align:center">备注</th></tr></thead><tbody><tr><td style="text-align:center">NOT</td><td style="text-align:center">取反运算指令</td><td style="text-align:center">NOT dest</td><td style="text-align:center">把操作数dest按位取反</td></tr><tr><td style="text-align:center">AND</td><td style="text-align:center">与运算指令</td><td style="text-align:center">AND dest, src</td><td style="text-align:center">把dest和src进行与运算之后送回dest</td></tr><tr><td style="text-align:center">OR</td><td style="text-align:center">或运算指令</td><td style="text-align:center">OR dest, src</td><td style="text-align:center">把dest和src进行或运算之后送回dest</td></tr><tr><td style="text-align:center">XOR</td><td style="text-align:center">异或运算</td><td style="text-align:center">XOR dest, src</td><td style="text-align:center">把dest和src进行异或运算之后送回dest</td></tr></tbody></table><h2 id="循环控制指令"><a href="#循环控制指令" class="headerlink" title="循环控制指令"></a>循环控制指令</h2><table><thead><tr><th style="text-align:center">指令</th><th style="text-align:center">名称</th><th style="text-align:center">示例</th><th style="text-align:center">备注</th></tr></thead><tbody><tr><td style="text-align:center">LOOP</td><td style="text-align:center">计数循环指令</td><td style="text-align:center">LOOP label</td><td style="text-align:center">使ECX的值减1，当ECX的值不为0的时候跳转至label，否则执行LOOP之后的语句</td></tr></tbody></table><h2 id="转移指令"><a href="#转移指令" class="headerlink" title="转移指令"></a>转移指令</h2><table><thead><tr><th style="text-align:center">指令</th><th style="text-align:center">名称</th><th style="text-align:center">示例</th><th style="text-align:center">备注</th></tr></thead><tbody><tr><td style="text-align:center">JMP</td><td style="text-align:center">无条件转移指令</td><td style="text-align:center">JMP lable</td><td style="text-align:center">无条件地转移到标号为label的位置</td></tr><tr><td style="text-align:center">CALL</td><td style="text-align:center">过程调用指令</td><td style="text-align:center">CALL labal</td><td style="text-align:center">直接调用label</td></tr><tr><td style="text-align:center">JE</td><td style="text-align:center">条件转移指令</td><td style="text-align:center">JE lable</td><td style="text-align:center">zf =1 时跳转到标号为label的位置</td></tr><tr><td style="text-align:center">JNE</td><td style="text-align:center">条件转移指令</td><td style="text-align:center">JNE lable</td><td style="text-align:center">zf=0 时跳转到标号为label的位置</td></tr></tbody></table><h1 id="linux-和-windows-下汇编的区别"><a href="#linux-和-windows-下汇编的区别" class="headerlink" title="linux 和 windows 下汇编的区别"></a>linux 和 windows 下汇编的区别</h1><p>前面说到 <code>linux</code> 和 <code>windows</code> 下的汇编语法是不同的，其实两种语法的不同和系统不同没有绝对的关系，一般在 <code>linux</code> 上会使用 <code>gcc/g++</code> 编译器，而在 <code>windows</code> 上会使用微软的 <code>cl</code> 也就是 <code>MSBUILD</code>，所以产生不同的代码是因为编译器不同，<code>gcc</code> 下采用的是AT&amp;T的汇编语法格式，<code>MSBUILD</code> 采用的是Intel汇编语法格式。</p><table><thead><tr><th style="text-align:center">差异</th><th style="text-align:center">Intel</th><th style="text-align:center">AT&amp;T</th></tr></thead><tbody><tr><td style="text-align:center">引用寄存器名字</td><td style="text-align:center">eax</td><td style="text-align:center">%eax</td></tr><tr><td style="text-align:center">赋值操作数顺序</td><td style="text-align:center">mov dest, src</td><td style="text-align:center">movl src, dest</td></tr><tr><td style="text-align:center">寄存器、立即数指令前缀</td><td style="text-align:center">mov  ebx, 0xd00d</td><td style="text-align:center">movl  $0xd00d, %ebx</td></tr><tr><td style="text-align:center">寄存器间接寻址</td><td style="text-align:center">[eax]</td><td style="text-align:center">(%eax)</td></tr><tr><td style="text-align:center">数据类型大小</td><td style="text-align:center">操作码后加后缀字母，“l” 32位，“w” 16位，“b” 8位（mov dx, word ptr [eax]）</td><td style="text-align:center">操作数前面加dword ptr， word ptr，byte ptr的格式 （movb %bl %al）</td></tr></tbody></table><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>汇编指令是机器指令的助记符，与机器指令是一一对应的</li><li>AT&amp;T的汇编语法格式和Intel汇编语法格式的是不同的</li><li>常用寄存器：<code>EAX</code> 、<code>EBX</code>、<code>ECX</code>、<code>EDX</code>、<code>EDI</code>、<code>ESI</code>、<code>EBP</code>、<code>ESP</code></li><li>存取速度从高到低分别是: <code>寄存器 &gt; 1级缓存 &gt; 2级缓存 &gt; 3级缓存 &gt; 内存 &gt; 硬盘</code></li><li>常用的汇编指令：<code>mov</code>、<code>je</code>、<code>jmp</code>、<code>call</code>、<code>add</code>、<code>sub</code>、<code>inc</code>、<code>dec</code>、<code>and</code>、<code>or</code></li></ul><hr><blockquote><p>如今的每分每秒都是人生，不要总想着将自然发生的事情拖到预定的时刻才进行~</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;我们大都是被高级语言惯坏了的一代，源源不断的新特性正在逐步添加到各类高级语言之中，汇编作为最接近机器指令的低级语言，已经很少被直接拿来写程序了，不过我还真的遇到了一个，那是之前的一个同事，因为在写代码时遇到了成员函数权限及可见性的问题，导致他无法正确调用想执行的函数，结果他就开始在 &lt;code&gt;C++&lt;/code&gt; 代码里嵌入汇编了，绕过了种种限制终于如愿以偿，但是读代码的我们傻眼了…&lt;/p&gt;
    
    </summary>
    
      <category term="ASM" scheme="http://AlbertGithubHome.github.io/blog/categories/ASM/"/>
    
    
      <category term="C/C++" scheme="http://AlbertGithubHome.github.io/blog/tags/C-C/"/>
    
      <category term="linux" scheme="http://AlbertGithubHome.github.io/blog/tags/linux/"/>
    
      <category term="汇编" scheme="http://AlbertGithubHome.github.io/blog/tags/%E6%B1%87%E7%BC%96/"/>
    
      <category term="windows" scheme="http://AlbertGithubHome.github.io/blog/tags/windows/"/>
    
      <category term="asm" scheme="http://AlbertGithubHome.github.io/blog/tags/asm/"/>
    
  </entry>
  
  <entry>
    <title>C++11在左值引用的基础上增加右值引用</title>
    <link href="http://AlbertGithubHome.github.io/blog/2020/05/05/C-11%E5%9C%A8%E5%B7%A6%E5%80%BC%E5%BC%95%E7%94%A8%E7%9A%84%E5%9F%BA%E7%A1%80%E4%B8%8A%E5%A2%9E%E5%8A%A0%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8/"/>
    <id>http://AlbertGithubHome.github.io/blog/2020/05/05/C-11在左值引用的基础上增加右值引用/</id>
    <published>2020-05-05T08:52:16.000Z</published>
    <updated>2020-05-05T15:23:10.588Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>右值引用这个词是最开始是学习 <code>easylogging++</code> 这个日志开源项目的时候遇到的，当时遇到 <code>&amp;&amp;</code> 这样的写法先是一愣，还有这种写法？难道是引用的地址？结果查询资料才明白这叫做右值引用。</p><a id="more"></a><h1 id="右值引用的出现"><a href="#右值引用的出现" class="headerlink" title="右值引用的出现"></a>右值引用的出现</h1><p>其实右值引用是在 <code>C++11</code> 时增加的新内容，在此之前，引用是没有左值和右值之分的，只存在一种引用，也就是后来 <code>C++11</code> 标准中的左值引用，而右值引用的提出主要是为了解决之前左值引用出现的一些尴尬的问题。</p><h1 id="左值和右值"><a href="#左值和右值" class="headerlink" title="左值和右值"></a>左值和右值</h1><p>说到右值引用需要先了解下左值和右值，这也是我自己学习的过程，之前在 <a href="https://blog.csdn.net/albertsh/article/details/105756674" target="_blank" rel="noopener">《简单聊聊C/C++中的左值和右值》</a> 这篇笔记中总结过，可以简单理解左值就是放在 <code>=</code> 左边，可以取到地址，可以被赋值的表达式，而右值通常是放在 <code>=</code> 右侧，不能取地址，只能被当成一个“值”的表达式。</p><h1 id="右值引用的作用"><a href="#右值引用的作用" class="headerlink" title="右值引用的作用"></a>右值引用的作用</h1><p>右值引用的出现并不是为了取代左值引用，也不是和左值引用形成对立，而是充分利用右值内容来减少对象构造和析构操作，以达到提高程序代码效率的目的。</p><p>也就是说增加右值引用这个特性是为了提高效率，之前的总结中也提到过，在 <code>C++11</code> 中还引入了 <code>std::move()</code> 函数，并用这个函数改写了 <code>std::remove_if()</code> 函数，这就是提高效率的例子。</p><p>使用 <code>std::move()</code> 函数意味着放弃所有权，对于一个左值，如果我们明确放弃对其资源的所有权，则可以通过 <code>std::move()</code> 来将其转为右值引用，放弃所有权的这个操作不一定都是方便的，比如 <code>std::auto_ptr</code> 这个第一代的智能指针，就是因为转移了所有权，使用起来不太方便，才在最新标准中被废弃的。但如果你明确要转移所有权，并且合理使用，有时可以有效的提高程序效率。</p><h1 id="引用类型的对比"><a href="#引用类型的对比" class="headerlink" title="引用类型的对比"></a>引用类型的对比</h1><p>在学习使用右值引用之前先复习一下左值引用，对比学习更有利于我们的记忆。</p><h2 id="左值引用"><a href="#左值引用" class="headerlink" title="左值引用"></a>左值引用</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">22</span>;</span><br><span class="line"><span class="keyword">int</span>&amp; j = i;</span><br><span class="line"></span><br><span class="line">j = <span class="number">11</span>;</span><br></pre></td></tr></table></figure><p>上面这几行代码就是最常见左值引用的例子，变量 <code>j</code> 引用了变量 <code>i</code> 的存储位置，修改变量 <code>j</code> 就修改了变量 <code>i</code> 的值，但是如果引用一个值会怎么样呢？比如下面这行代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>&amp; j = <span class="number">22</span>;</span><br></pre></td></tr></table></figure><p>编译这行代码会得到一个编译错误：</p><blockquote><p>error: invalid initialization of non-const reference of type ‘int&amp;’ from an rvalue of type ‘int’<br>   int&amp; j = 22;</p></blockquote><p>像上面这种问题，可以使用常量引用来解决。</p><h2 id="常量引用"><a href="#常量引用" class="headerlink" title="常量引用"></a>常量引用</h2><p>针对上面的编译错误，改成常量引用就可以通过编译了，就像这样：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>&amp; j = <span class="number">22</span>;</span><br></pre></td></tr></table></figure><p>使用常量引用来引用数字常量22，可以编译通过是因为内存上产生了临时变量保存了22这个数据，这个临时变量是可以进行取地址操作的，因此变量 <code>j</code> 引用的其实是这个临时变量，相当于下面的这两句：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> temp = <span class="number">22</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;j = temp;</span><br></pre></td></tr></table></figure><p>看到这里我们发现常量引用可以解决引用常量的问题，那么为什么非得新增一个右值引用呢？那是因为使用常引用后，我们只能通过引用来读取数据，无法去修改数据，这在很多情况下是很不方便的。</p><h2 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h2><p>常量引用可以使用右值引用来改写，改写之后可以正常编译，并且还可以进行修改：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>&amp;&amp; j = <span class="number">22</span>;</span><br></pre></td></tr></table></figure><p>这句代码有两个需要注意的点，第一是右值引用是 <code>C++11</code> 中才增加的，所以需要增加 <code>--std=c++11</code> 这个编译选项才能正常编译，第二是右值引用的两个地址符需要连着写成 <code>&amp;&amp;</code>, 如果中间有空格写成 <code>&amp; &amp;</code> 会被认为是引用的引用而导致编译错误，这是不符合语法的。</p><h1 id="右值引用的示例"><a href="#右值引用的示例" class="headerlink" title="右值引用的示例"></a>右值引用的示例</h1><p>前面对引用类型进行了对比，但是还没有发现右值引用的好处，接下来用一个例子来展示一下增加右值引用之前的写法，和使用右值引用的写法，通过对比来了解一下右值引用究竟有什么好处。</p><p>我们来实现一个自定义缓冲区，先使用最常见的方法来实现拷贝构造函数和拷贝赋值函数，简单实现如下，功能不太完整，但是可以说明右值引用的作用：</p><h2 id="常量引用实现"><a href="#常量引用实现" class="headerlink" title="常量引用实现"></a>常量引用实现</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CBuffer</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    CBuffer(<span class="keyword">int</span> size = <span class="number">1024</span>): m_size(size)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"CBuffer(int)"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        m_buffer = <span class="keyword">new</span> <span class="keyword">char</span>[size];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~CBuffer()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"~CBuffer()"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">delete</span>[] m_buffer;</span><br><span class="line">        m_buffer = <span class="literal">nullptr</span>;</span><br><span class="line">        m_size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拷贝构造</span></span><br><span class="line">    CBuffer(<span class="keyword">const</span> CBuffer &amp;origin): m_size(origin.m_size)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"CBuffer(const CBuffer&amp;)"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        m_buffer = <span class="keyword">new</span> <span class="keyword">char</span>[origin.m_size];</span><br><span class="line">        <span class="built_in">memcpy</span>(m_buffer, origin.m_buffer, m_size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 赋值重载</span></span><br><span class="line">    CBuffer&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> CBuffer &amp;origin)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"operator=(const CBuffer&amp;)"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;origin) <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">delete</span>[] m_buffer;</span><br><span class="line"></span><br><span class="line">        m_size = origin.m_size;</span><br><span class="line">        m_buffer = <span class="keyword">new</span> <span class="keyword">char</span>[origin.m_size];</span><br><span class="line">        <span class="built_in">memcpy</span>(m_buffer, origin.m_buffer, m_size);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get_size</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> CBuffer <span class="title">gen_buffer</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">CBuffer <span class="title">temp_buffer</span><span class="params">(size)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> temp_buffer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span> *m_buffer;</span><br><span class="line">    <span class="keyword">int</span> m_size;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CBuffer b1;</span><br><span class="line">    <span class="function">CBuffer <span class="title">b2</span><span class="params">(b1)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"b1.size = "</span> &lt;&lt; b1.get_size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"b2.size = "</span> &lt;&lt; b2.get_size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    b2 = CBuffer::gen_buffer(<span class="number">100</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果是：</p><blockquote><p>CBuffer(int)<br>CBuffer(const CBuffer&amp;)<br>b1.size = 1024<br>b2.size = 1024<br>CBuffer(int)<br>operator=(const CBuffer&amp;)<br>~CBuffer()<br>~CBuffer()<br>~CBuffer()</p></blockquote><p>这个例子不具有实用性，只为了说明问题，<code>CBuffer</code> 这个类定义为了拷贝构造函数并且重载了 <code>=</code> 运算符，两个函数参数均使用常量引用的类型，这就是一般的写法。</p><p>但是这样实现有一个问题，因为参数是常量引用，所以没办法修改原对象的值，我们看到拷贝构造和赋值重载两个函数中都有申请空间和拷贝的操作，这种操作在操作内存较大的对象是比较耗时，所以应该尽量避免，我们想到可以使用新对象的指针指向旧对象指针来解决，这样就不用拷贝了，可是这样修改会导致两个对象指向同一块内存，这个问题需要解决。</p><h2 id="改为左值引用实现报错"><a href="#改为左值引用实现报错" class="headerlink" title="改为左值引用实现报错"></a>改为左值引用实现报错</h2><p>如果两个对象指向同一块内存，那么对象在析构的时候就会将一块内存释放两次导致奔溃，这时考虑在拷贝构造或者赋值重载时，将原来对象的指针设置成空就可以了，但是参数是常量没有办法修改啊，那我们将 <code>const</code> 关键字去掉试试，将两个函数改成这样：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 拷贝构造</span></span><br><span class="line">CBuffer(CBuffer &amp;origin): m_size(origin.m_size)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"CBuffer(CBuffer&amp;)"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    m_buffer = origin.m_buffer;</span><br><span class="line"></span><br><span class="line">    origin.m_buffer = <span class="literal">nullptr</span>;</span><br><span class="line">    origin.m_size = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 赋值重载</span></span><br><span class="line">CBuffer&amp; <span class="keyword">operator</span>=(CBuffer &amp;origin)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"operator=(CBuffer&amp;)"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;origin) <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">    m_buffer = origin.m_buffer;</span><br><span class="line"></span><br><span class="line">    origin.m_buffer = <span class="literal">nullptr</span>;</span><br><span class="line">    origin.m_size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看起来没有什么问题，但是编译的时候会报错：</p><blockquote><p>error: invalid initialization of non-const reference of type ‘CBuffer&amp;’ from an rvalue of type ‘CBuffer’<br>    b2 = CBuffer::gen_buffer(100);<br>                            ^<br>note:   initializing argument 1 of ‘CBuffer&amp; CBuffer::operator=(CBuffer&amp;)’<br>    CBuffer&amp; operator=(CBuffer &amp;origin)</p></blockquote><p>这个错误是什么意思呢？其实说的就是在调用 <code>CBuffer::gen_buffer(100);</code> 函数时，会产生一个临时对象，这个临时对象在赋值给 <code>b2</code> 是会调用<br><code>CBuffer&amp; operator=(CBuffer &amp;origin)</code> 函数，但是这个函数的参数是一个左值引用类型，而临时对象是一个右值，无法绑定到左值引用上，所以报错了。</p><p>还有拷贝构造函数也是有相同的问题，当写出类似 <code>b2 = CBuffer(CBuffer(1000))</code> 类型会产生临时对象的语句时，同样会因为左值引用不能绑定到右值上而报错，这时候就要请出右值引用了。</p><h2 id="改为右值引用实现"><a href="#改为右值引用实现" class="headerlink" title="改为右值引用实现"></a>改为右值引用实现</h2><p>对于赋值重载函数，我们使用右值引用将其改写为:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 赋值重载</span></span><br><span class="line">CBuffer&amp; <span class="keyword">operator</span>=(CBuffer &amp;&amp;origin)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"operator=(CBuffer&amp;&amp;)"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;origin) <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">    m_buffer = origin.m_buffer;</span><br><span class="line"></span><br><span class="line">    origin.m_buffer = <span class="literal">nullptr</span>;</span><br><span class="line">    origin.m_size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时可以正常通过编译，并且只是修改了指针的指向，并没有申请和拷贝另外一份内存。</p><h2 id="std-move-函数"><a href="#std-move-函数" class="headerlink" title="std::move() 函数"></a>std::move() 函数</h2><p>如果我们将拷贝构造函数的参数也改成右值引用的形式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 拷贝构造</span></span><br><span class="line">CBuffer(CBuffer &amp;&amp;origin): m_size(origin.m_size)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"CBuffer(CBuffer&amp;)"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    m_buffer = origin.m_buffer;</span><br><span class="line"></span><br><span class="line">    origin.m_buffer = <span class="literal">nullptr</span>;</span><br><span class="line">    origin.m_size = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译时就会发现编译错误：</p><blockquote><p>error: use of deleted function ‘constexpr CBuffer::CBuffer(const CBuffer&amp;)’<br>    CBuffer b2(b1);<br>                  ^<br>note: ‘constexpr CBuffer::CBuffer(const CBuffer&amp;)’ is implicitly declared<br>   as deleted because ‘CBuffer’ declares a move constructor or move assignment operator<br>   class CBuffer</p></blockquote><p>其本质问题就是主函数中 <code>CBuffer b2(b1);</code> 这一句引起的，因为变量 <code>b1</code> 是一个左值，但是拷贝构造函数接受的是右值引用，所以类型不匹配导致了编译错误，这时可以使用 <code>std::move()</code> 函数改成这条语句为 <code>CBuffer b2(std::move(b1));</code> 就可以正常编译运行了，运行结果为：</p><blockquote><p>CBuffer(int)<br>CBuffer(CBuffer&amp;)<br>b1.size = 0<br>b2.size = 1024<br>CBuffer(int)<br>operator=(CBuffer&amp;&amp;)<br>~CBuffer()<br>~CBuffer()<br>~CBuffer()</p></blockquote><p>查看运行结果会发现 <code>b1.size = 0</code>，因为 <code>b1</code> 调用了 <code>std::move()</code> 函数，转移了资源的所有权，内部已经被“掏空”了，所以在明确所有权转移之后，不要再直接使用变量 <code>b1</code> 了。</p><h1 id="万能引用"><a href="#万能引用" class="headerlink" title="万能引用"></a>万能引用</h1><p>听到这个名字就感觉很厉害，什么是万能引用，其实就是可以同时接受左值和右值的引用类型，但是这种完能引用只能发生在推导的情况下，下面给出了一个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(T&amp;&amp; val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; val &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> year = <span class="number">2020</span>;</span><br><span class="line">    func(year);</span><br><span class="line">    func(<span class="number">2020</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码中 <code>T&amp;&amp; val</code> 就是万能引用，因为是在模板中，类型需要推导，如果是在普通函数中 <code>T&amp;&amp; val</code> 这个形式就是右值引用。</p><h1 id="左值引用和右值引用判定的函数"><a href="#左值引用和右值引用判定的函数" class="headerlink" title="左值引用和右值引用判定的函数"></a>左值引用和右值引用判定的函数</h1><p>文中多次提到左值和右值，可能刚学习这块内容的小伙伴会有些懵，其实 <code>C++</code> 中提供了判定左值引用和右值引用的函数，头文件为 <code>&lt;type_traits&gt;</code>，函数名为 <code>is_reference</code>、 <code>is_rvalue_reference</code>、 <code>is_lvalue_reference</code>，看名字就可以知道他们的用途，看下面的例子就更清楚了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;type_traits&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">22</span>;</span><br><span class="line">    <span class="keyword">int</span>&amp; j = i;</span><br><span class="line">    <span class="keyword">int</span>&amp;&amp; k = <span class="number">11</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"i is_reference: "</span> &lt;&lt; is_reference&lt;<span class="keyword">decltype</span>(i)&gt;::value &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"i is_lvalue_reference: "</span> &lt;&lt; is_lvalue_reference&lt;<span class="keyword">decltype</span>(i)&gt;::value &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"i is_rvalue_reference: "</span> &lt;&lt; is_rvalue_reference&lt;<span class="keyword">decltype</span>(i)&gt;::value &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"j is_reference: "</span> &lt;&lt; is_reference&lt;<span class="keyword">decltype</span>(j)&gt;::value &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"j is_lvalue_reference: "</span> &lt;&lt; is_lvalue_reference&lt;<span class="keyword">decltype</span>(j)&gt;::value &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"j is_rvalue_reference: "</span> &lt;&lt; is_rvalue_reference&lt;<span class="keyword">decltype</span>(j)&gt;::value &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"k is_reference: "</span> &lt;&lt; is_reference&lt;<span class="keyword">decltype</span>(k)&gt;::value &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"k is_lvalue_reference: "</span> &lt;&lt; is_lvalue_reference&lt;<span class="keyword">decltype</span>(k)&gt;::value &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"k is_rvalue_reference: "</span> &lt;&lt; is_rvalue_reference&lt;<span class="keyword">decltype</span>(k)&gt;::value &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下，满足返回1，否则返回0：</p><blockquote><p>i is_reference: 0<br>i is_lvalue_reference: 0<br>i is_rvalue_reference: 0<br>j is_reference: 1<br>j is_lvalue_reference: 1<br>j is_rvalue_reference: 0<br>k is_reference: 1<br>k is_lvalue_reference: 0<br>k is_rvalue_reference: 1</p></blockquote><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>右值引用的写法为 <code>T&amp;&amp; val</code>，两个地址符要挨在一起，在模板中被称为万能引用</li><li>注意左值引用和右值引用的使用区别，其实本质都是为了减少无效的拷贝</li><li><code>std::move()</code> 函数会转移对象的所有权，转移操作之后将左值转为右值引用，原对象不可再直接使用</li><li>可以使用 <code>is_reference</code>、 <code>is_rvalue_reference</code>、 <code>is_lvalue_reference</code> 来判断引用类型</li></ul><hr><blockquote><p>陪伴是最长情的告白，等待是最极致的思念<br>五一离家返工了，心里有些不是滋味，为了家出来奋斗却将“家”抛在了身后，珍惜眼前人吧~</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;右值引用这个词是最开始是学习 &lt;code&gt;easylogging++&lt;/code&gt; 这个日志开源项目的时候遇到的，当时遇到 &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; 这样的写法先是一愣，还有这种写法？难道是引用的地址？结果查询资料才明白这叫做右值引用。&lt;/p&gt;
    
    </summary>
    
      <category term="C/C++" scheme="http://AlbertGithubHome.github.io/blog/categories/C-C/"/>
    
    
      <category term="C/C++" scheme="http://AlbertGithubHome.github.io/blog/tags/C-C/"/>
    
      <category term="左值" scheme="http://AlbertGithubHome.github.io/blog/tags/%E5%B7%A6%E5%80%BC/"/>
    
      <category term="右值" scheme="http://AlbertGithubHome.github.io/blog/tags/%E5%8F%B3%E5%80%BC/"/>
    
      <category term="左值引用" scheme="http://AlbertGithubHome.github.io/blog/tags/%E5%B7%A6%E5%80%BC%E5%BC%95%E7%94%A8/"/>
    
      <category term="右值引用" scheme="http://AlbertGithubHome.github.io/blog/tags/%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>简单聊聊C/C++中的左值和右值</title>
    <link href="http://AlbertGithubHome.github.io/blog/2020/04/24/%E7%AE%80%E5%8D%95%E8%81%8A%E8%81%8AC-C-%E4%B8%AD%E7%9A%84%E5%B7%A6%E5%80%BC%E5%92%8C%E5%8F%B3%E5%80%BC/"/>
    <id>http://AlbertGithubHome.github.io/blog/2020/04/24/简单聊聊C-C-中的左值和右值/</id>
    <published>2020-04-24T15:26:23.000Z</published>
    <updated>2020-04-25T13:36:02.099Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>为什么标题要写成简单聊聊，而不是写成什么“C++中左值与右值详解”或者现在很流行的“惊了！看了这一篇左值与右值讲解，他吊打了面试官”，其实带有详解这个词是需要勇气的，最起码要融会贯通之后才敢这么说吧，本来是学习右值引用的，结果涉及到了左值和右值，然后去了解他们历史发现也是有些混乱，操作中又经常涉及到运算符优先级，真是越学越乱了。</p><a id="more"></a><!-- https://www.cnblogs.com/catch/p/3500678.html --><!-- https://www.cnblogs.com/catch/p/3251937.html --><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>索性也把右值引用放一边，从头来看看这个左值和右值，其实我跟这两个词一点都不熟，最多就是在编译报错的提示框中看到他们，当然有时候也会看到他们的英文名字 <code>lvalue</code> 和 <code>rvalue</code>，这时候一般就是编译器开始抱怨了，说我写了什么它不能理解的东西，其实嘛，我自己都没完全理解，从现在开始边学边总结了，先展示一个常见报错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error: lvalue required as increment operand</span><br></pre></td></tr></table></figure><p>这是什么意思，这么绕嘴，左值需要作为增长操作数，请说人话：自增操作需要一个可以赋值的变量作为操作数，需要变量就直说嘛，为什么要左值、右值的把人都绕蒙了。</p><h1 id="历史渊源"><a href="#历史渊源" class="headerlink" title="历史渊源"></a>历史渊源</h1><p>这个世界一直是在变化的，可能之前你一直引以为豪的经验大楼，转眼之间就会倾塌。关于左值和右值的历史，普遍的观点是最初来源于 <code>C</code> 语言，后来被引入到了 <code>C++</code>，但是关于左值和右值的含义和实现却在一直改变和完善，对于它的历史讲解发现一篇总结的比较好的文章 <a href="https://www.cnblogs.com/dejavu/archive/2012/09/02/2667640.html" target="_blank" rel="noopener">《C/C++ 左值和右值, L-value和R-value》</a>。</p><p>这是2012年的一篇文章，文中给出了历史说明依据，最后还举了一些例子来说明 <code>C</code> 和 <code>C++</code> 关于左值实现的不同，但是实际操作后你会发现，时间的车轮早已向前行进了一大截，文中提到的那些不同，在最新的 <code>gcc</code> 和 <code>g++</code> 编译器上早已变得相同，文中提到的反例现在看来几乎没有意义了。</p><p>简单梳理下，左值的定义最早出现在 《The C Programming Language 》一书中，指的是引用一个对象，放在赋值表达式 <code>=</code> 左边的值。</p><p>后来在新的 <code>C</code> 语言标准中提到左值是赋值表达式 <code>=</code> 左边的值或者需要被改变的值，而等号的右边的值被称为右值。左值更好的表达为可以定位的值，而右值是一种表达数据的值，基于这个表述 <code>L-value</code> 可以理解为 <code>locator value</code>，代表可寻址，而 <code>R-value</code> 可以理解为 <code>read value</code>，代表可读取。</p><p>不过以上的新解，完全是人们为了理解左值、右值赋予的新含义，从历史发展来看，一开始左值和右值完全就是通过等号的左边和右边来命名的，只不过随着标准的完善和语言的发展、更替，虽然两个名字保留了下来，但是它们的含义却在逐步发生改变，与最初诞生时的 <code>=</code> 左右两边的值这个含义相比，已经相差很多了。</p><h1 id="认识左值和右值"><a href="#认识左值和右值" class="headerlink" title="认识左值和右值"></a>认识左值和右值</h1><p>关于左值右值有几条规则和特点，先列举在这里，后面可以跟随例子慢慢体会：</p><ol><li>左值和右值都是指的表达式，比如 <code>int a = 1</code> 中的 <code>a</code> 是左值，<code>++a</code> 是左值, <code>func()</code> 也可能是左值，而 <code>a+1</code> 是右值， <code>110</code> 也是一个右值。</li><li>左值可以放在 <code>=</code> 的左边，右值只能放在 <code>=</code> 的右边，这其中隐含的意思就是左值也能放在 <code>=</code> 的右边，但是右值不能放在 <code>=</code> 的左边。</li><li>左值可以取地址，代表着内存中某个位置，可以存储数据，右值仅仅是一个值，不能取地址，或者它看起来是一个变量，但它是临时的无法取地址，例如一个函数的非引用的值返回。</li></ol><p>以上规则从定义来看一点也不严谨，比如一个常量定义是可以赋值，后面就不行了，它也可以取地址，但是不能赋值的它到底是左值还是右值，这点其实不用纠结，心里知道这个情况就可以了。</p><p>再比如一个普通变量，它原本是一个左值，当用它给其他变量赋值的时候，它又化身为一个右值，这时它也可以取地址，好像与上面的说法相违背了，但是仔细想想真的是这样吗？它只是临时化身为右值，其实是一个左值，所以才可以取地址的。</p><p>其实你如果不做学术研究、不斤斤计较，那么完全可以把能够赋值的表达式作为左值，然后把左值以外的表达式看成右值，如果你不熟悉解左值和右值可能根本不会影响你平时的工作和学习，但是了解它有助于我们深入理解一些内置运算符和程序执行过程，以及在出现编译错误的时候及时定位问题。</p><h1 id="具体的示例"><a href="#具体的示例" class="headerlink" title="具体的示例"></a>具体的示例</h1><h2 id="最简单的赋值语句"><a href="#最简单的赋值语句" class="headerlink" title="最简单的赋值语句"></a>最简单的赋值语句</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> age = <span class="number">18</span>;</span><br></pre></td></tr></table></figure><p>这个赋值语句很简单，<code>=</code> 作为分界线，左边的 <code>age</code> 是左值，可以被赋值，可以取地址，它其实就是一个表达式，代表一个可以存储整数的内存地址；右边的 <code>18</code> 也是一个表达式，明显只能作为右值，不能取地址。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">18</span> = age;</span><br></pre></td></tr></table></figure><p>这个语句在编译时会提示下面的错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error: lvalue required as left operand of assignment</span><br></pre></td></tr></table></figure><p>错误提示显示：赋值语句的左边需要一个左值，显然 <code>18</code> 不能作为左值，它不代表任何内存地址，不能被改变。</p><p>如果程序中的表达式都这么简单就不需要纠结了，接着我们往下看一些复杂点的例子。</p><h2 id="自增自减运算"><a href="#自增自减运算" class="headerlink" title="自增自减运算"></a>自增自减运算</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">++age++;</span><br></pre></td></tr></table></figure><p>第一眼看到这个表达式，你感觉它会怎样运算，编译一下，你会发现编译失败了，错误如下：</p><blockquote><p>error: lvalue required as increment operand</p></blockquote><p>加个括号试试：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">++(age++)</span><br></pre></td></tr></table></figure><p>编译之后会出现相同的错误：</p><blockquote><p>error: lvalue required as increment operand</p></blockquote><p>再换一种加括号的方式再编译一次：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(++age)++</span><br></pre></td></tr></table></figure><p>这次成功编译了，并且输出值之后发现 <code>age</code> 变量增加了两次。</p><p>先不考虑左值右值的问题，我们可以从这个例子中发现自增运算的优先级，后置自增 <code>age++</code> 的优先级要高于前置自增 <code>++age</code> 的优先级。</p><p>现在回过头来看看之前的编译错误，为什么我们加括号改变运算顺序之后就可以正常执行了呢？这其实和自增运算的实现有关。</p><h3 id="前置自增"><a href="#前置自增" class="headerlink" title="前置自增"></a>前置自增</h3><p>前置自增的一般实现，是直接修改原对象，在原对象上实现自增，然后将原对象以引用方式返回：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">UPInt&amp; UPInt::<span class="keyword">operator</span>++()</span><br><span class="line">&#123;</span><br><span class="line">　*<span class="keyword">this</span> += <span class="number">1</span>;    <span class="comment">// 原对象自增</span></span><br><span class="line">　<span class="keyword">return</span> *<span class="keyword">this</span>;  <span class="comment">// 返回原对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里一直操作的是原对象，返回的也是原对象的引用，所以前置自增表达式的结果是左值，它引用的是原对象之前所占用的内存。</p><h3 id="后置自增"><a href="#后置自增" class="headerlink" title="后置自增"></a>后置自增</h3><p>后置自增的一般实现，是先将原对象的数据存储到临时变量中，接着在原对象上实现自增，然后将临时变量以只读的方式返回：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> UPInt UPInt::<span class="keyword">operator</span>++(<span class="keyword">int</span>)</span><br><span class="line">&#123;</span><br><span class="line">　UPInt oldValue = *<span class="keyword">this</span>; <span class="comment">// 将原对象赋值给临时变量</span></span><br><span class="line">　++(*<span class="keyword">this</span>);              <span class="comment">// 原对象自增</span></span><br><span class="line">　<span class="keyword">return</span> oldValue;        <span class="comment">// 返回临时变量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里返回的是临时变量，在函数返回后就被销毁了，无法对其取地址，所以后置自增表达式的结果是右值，不能对其进行赋值。</p><p>所以表达式 <code>++age++;</code> 先进行后置自增，然后再进行前置自增就报出编译错误了，因为不能修改右值，也不能对右值进行自增操作。</p><h3 id="自增表达式赋值"><a href="#自增表达式赋值" class="headerlink" title="自增表达式赋值"></a>自增表达式赋值</h3><p>前面说到前置自增表达式是一个左值，那能不能对其赋值呢？当然可以！试试下面的语句：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">++age = <span class="number">20</span>;</span><br></pre></td></tr></table></figure><p>这条语句是可以正常通过编译的，并且执行之后 <code>age</code> 变量的值为 <code>20</code>。</p><h2 id="函数表达式"><a href="#函数表达式" class="headerlink" title="函数表达式"></a>函数表达式</h2><p>函数可以作为左值吗？带着这个疑问我们看一下这个赋值语句：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func() = <span class="number">6</span>;</span><br></pre></td></tr></table></figure><p>可能有些同学会有疑问，这是正常的语句吗？其实它是可以正常的，只要 <code>func()</code> 是一个左值就可以，怎么才能让他成为一个左值呢，想想刚才的前置自增运算可能会给你启发，要想让他成为左值，它必须代表一个内存地址，写成下面这样就可以了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> g;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>&amp; <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> g;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    func() = <span class="number">100</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数 <code>func()</code> 返回的是全局变量 <code>g</code> 的引用，变量 <code>g</code> 是一个可取地址的左值，所以 <code>func()</code> 表达式也是一个左值，对其赋值后就改变了全局变量 <code>g</code> 的值。</p><p>那么我们注意到这里 <code>func()</code> 函数返回的是全局变量的引用，如果是局部变量会怎么样呢？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>&amp; <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">101</span>;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    func() = <span class="number">100</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码编译没有错误，但是会产生一个警告，提示返回了局部变量的引用:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">warning: reference to local variable ‘i’ returned [-Wreturn-local-addr]</span><br></pre></td></tr></table></figure><p>运行之后可就惨了，直接显示段错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Segmentation fault (core dumped)</span><br></pre></td></tr></table></figure><p>改为局部变量之后，<code>func()</code> 函数虽然返回了一个值，但是这个值是一个临时值，函数返回之后该值被销毁，对应的内存空间也不属于它了，所以在最后赋值的时候才会出现段错误，就和我们访问非法内存是产生的错误时一样的。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>可以被赋值的表达式是左值，左值可以取地址。</li><li>右值应该是一个表示值的表达式，不是左值的表达式都可以看成是右值</li><li>后置自增操作符的优先级要高于前置自增操作符，它们是按照从右向左结合的</li><li>关于左值和右值的知识点还有很多，后续想到了再补充，我也是边学边总结，如果有错误也欢迎小伙伴们及时指出，我会及时改正的</li></ul><hr><blockquote><p>时刻静下来想想当初为什么出发，不要在现实的汪洋中偏离航向</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;为什么标题要写成简单聊聊，而不是写成什么“C++中左值与右值详解”或者现在很流行的“惊了！看了这一篇左值与右值讲解，他吊打了面试官”，其实带有详解这个词是需要勇气的，最起码要融会贯通之后才敢这么说吧，本来是学习右值引用的，结果涉及到了左值和右值，然后去了解他们历史发现也是有些混乱，操作中又经常涉及到运算符优先级，真是越学越乱了。&lt;/p&gt;
    
    </summary>
    
      <category term="C/C++" scheme="http://AlbertGithubHome.github.io/blog/categories/C-C/"/>
    
    
      <category term="C/C++" scheme="http://AlbertGithubHome.github.io/blog/tags/C-C/"/>
    
      <category term="左值" scheme="http://AlbertGithubHome.github.io/blog/tags/%E5%B7%A6%E5%80%BC/"/>
    
      <category term="右值" scheme="http://AlbertGithubHome.github.io/blog/tags/%E5%8F%B3%E5%80%BC/"/>
    
      <category term="lvalue" scheme="http://AlbertGithubHome.github.io/blog/tags/lvalue/"/>
    
      <category term="rvalue" scheme="http://AlbertGithubHome.github.io/blog/tags/rvalue/"/>
    
  </entry>
  
  <entry>
    <title>.bat批处理（九）：替换带有等号=的字符串的子串</title>
    <link href="http://AlbertGithubHome.github.io/blog/2020/04/18/bat%E6%89%B9%E5%A4%84%E7%90%86%EF%BC%88%E4%B9%9D%EF%BC%89%EF%BC%9A%E6%9B%BF%E6%8D%A2%E5%B8%A6%E6%9C%89%E7%AD%89%E5%8F%B7-%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%AD%90%E4%B8%B2/"/>
    <id>http://AlbertGithubHome.github.io/blog/2020/04/18/bat批处理（九）：替换带有等号-的字符串的子串/</id>
    <published>2020-04-18T10:01:16.000Z</published>
    <updated>2020-04-19T03:08:08.169Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>今天写这篇记录要解决的问题来源于最近一名读者的提问，之前写过一篇名为<a href="https://blog.csdn.net/albertsh/article/details/79919465" target="_blank" rel="noopener">《.bat批处理（六）：替换字符串中匹配的子串》</a>的总结文章，结果有读者在评论区提问说，如果想要替换的子串中包含等号 <code>=</code>，那么就无法替换了，问有没有什么办法可以解决。遇到这个问题的第一感觉应该挺好处理的吧，如果批处理程序在替换操作中认为等号 <code>=</code> 比较特殊，那就加个转义字符应该就可以了，但事实却证明这种想法有些天真了。</p><a id="more"></a><p>在尝试多次失败之后，我意识到事情远没有想象的那么简单，开始在网上寻找解决方案，结果有些让人意外，绝大多数人都说这是 <code>SET</code> 命令的执行规则决定的，无法实现这种需求。当要替换的子串中包含 <code>=</code> 时，第一个 <code>=</code> 就会被认为是替换语法中的 <code>=</code>，进而导致无法得到正确的结果，即使是使用转义字符都无法完成正确替换，加入的转义字符会影响匹配，导致替换失败。还有一些人建议用其他工具来完整这种需求，比如记事本的替换功能 <code>O(∩_∩)O</code>。</p><h1 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h1><p>看了上面的叙述，可能有些小伙伴对我所说的问题还没有太直观的认识，接下来我们举个例子来说一下这个问题究竟是怎样产生的。</p><h2 id="0x00-带有-的字符串"><a href="#0x00-带有-的字符串" class="headerlink" title="0x00 带有 = 的字符串"></a>0x00 带有 = 的字符串</h2><p>首先需要被替换的字符串中要包含等号，我们来定义一个这样的变量：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> STR=abcdo=ocar12a=ajdjko=ot</span><br></pre></td></tr></table></figure><p>变量的名字是 <code>STR</code>，变量的值是 <code>abcdo=ocar12a=ajdjko=ot</code>，其中包含了三个 <code>=</code>。</p><h2 id="0x01-带有-的想要被替换的子串"><a href="#0x01-带有-的想要被替换的子串" class="headerlink" title="0x01 带有 = 的想要被替换的子串"></a>0x01 带有 = 的想要被替换的子串</h2><p>确定一下我们想要替换的子串 <code>o=o</code>，假如我们想把它替换成字母 <code>A</code>，按照一般的替换规则<code>X:Y=Z</code>，在 <code>X</code> 串中寻找到 <code>Y</code> 串之后把它替换成 <code>Z</code> 串，实现的代码如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> STR=abcdo=ocar12a=ajdjko=ot</span><br><span class="line"><span class="built_in">set</span> RESULT=%STR:o=o=A%</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> %RESULT%</span><br><span class="line">pause &gt; nul</span><br></pre></td></tr></table></figure><p>运行之后的结果是：</p><blockquote><p>abcdo=A=o=Acar12a=ajdjko=A=o=At</p></blockquote><p>和我们想法不一样，我们本来想把 <code>o=o</code> 替换成 <code>A</code>，但是从结果来看应该是把 <code>o</code> 替换成了 <code>o=A</code>，原因就是我们选择的被替换中的子串 <code>o=o</code> 包含一个 <code>=</code>，而这个 <code>=</code> 被当成了替换语法 <code>X:Y=Z</code> 中的 <code>=</code>，所以就不对了。</p><h2 id="0x02-尝试用转义字符来处理"><a href="#0x02-尝试用转义字符来处理" class="headerlink" title="0x02 尝试用转义字符来处理"></a>0x02 尝试用转义字符来处理</h2><p>很多语言中都有转义字符，比如 Markdown 语法中的反斜杠 <code>\</code>，在 Markdown 语法中被星号 <code>*</code> 包裹的文字是倾斜的，但是如果想正常的输出一个 <code>*</code> 怎么办呢？就需要在 <code>*</code> 前面加一个反斜杠 <code>\</code>，变成 <code>\*</code>，这样 <code>*</code> 原本的倾斜文字的作用就被转义了，变成了一个普通的输出字符。</p><p>在批处理中也有转义字符的概念，它就是 <code>^</code>，我们知道在批处理中 <code>&gt;</code>、<code>|</code> 等符号都是有特殊用处的，所以不能简单的输出，比如 <code>echo &gt;</code> 是无法输出一个大于号的，要写成 <code>echo ^&gt;</code> 才能正常输出一个 <code>&gt;</code> 符号。</p><p>我们就利用这个转义字符来告诉替换命令，被替换的子串中的 <code>=</code> 是一个普通字符，不能作为替换规则的一部分，所以被替换的子串写成了 <code>o^=o</code>，我们实现下面的代码，看看能不能达到目的：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> STR=abcdo=ocar12a=ajdjko=ot</span><br><span class="line"><span class="built_in">set</span> RESULT=%STR:o^=o=A%</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> %RESULT%</span><br><span class="line">pause &gt; nul</span><br></pre></td></tr></table></figure><p>运行之后结果如下：</p><blockquote><p>abcdo=ocar12a=ajdjko=ot</p></blockquote><p>与替换前对比发现没有任何变化，看来转义字符的想法没能帮助我们解决问题，还是想想其他的办法吧。</p><h1 id="稳扎稳打的解决方案"><a href="#稳扎稳打的解决方案" class="headerlink" title="稳扎稳打的解决方案"></a>稳扎稳打的解决方案</h1><p>既然 <code>=</code> 这么特殊，我们就先想办法干掉等号，直接替换的方式不好使，我们可以一个字符一个字符的判断啊，虽然麻烦一点，但是解决问题才是最重要的。</p><p>既然要一个个的字符去判断，就需要遍历原字符串，最简单的可以使用字符串分割啊，语法为 <code>原串:~偏移,长度</code> 就可以了，如果不太清楚可以参考一下 <a href="https://blog.csdn.net/albertsh/article/details/52797519" target="_blank" rel="noopener">《.bat批处理（三）：变量声明、设置、拼接、截取》</a>，截取第一个字符的语法是 <code>原串:~0,1</code>， 截取第二个字符的语法是 <code>原串:~1,1</code>，以此类推。</p><p>具体的思路就是我们先判断第一个字符，如果是 <code>=</code> 就进行替换，如果不是 <code>=</code> 就放到结果字符串里，然后继续判断第二个字符进行操作，最后所有的字符处理一遍就完成了替换。</p><p>需要使用 <code>goto</code> 语句来写一个循环，代码逻辑比较简单，就是遍历所有字符，是 <code>=</code> 就替换，不是 <code>=</code> 就保留，假设我们先把 <code>=</code> 替换成 <code>#</code>，实现的代码如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> STR=abcdo=ocar12a=ajdjko=ot</span><br><span class="line"><span class="built_in">set</span> CURSTR=%STR%</span><br><span class="line"><span class="built_in">set</span> RESULT=</span><br><span class="line"></span><br><span class="line">:next</span><br><span class="line"><span class="keyword">if</span> <span class="string">"%CURSTR%"</span> equ <span class="string">""</span> goto end</span><br><span class="line"><span class="built_in">set</span> a=%CURSTR:~0,1%</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="string">"%a%"</span> equ <span class="string">"="</span> (<span class="built_in">set</span> RESULT=%RESULT%<span class="comment">#) else (set RESULT=%RESULT%%a%)</span></span><br><span class="line"><span class="built_in">set</span> CURSTR=%CURSTR:~1%</span><br><span class="line">goto next</span><br><span class="line"></span><br><span class="line">:end</span><br><span class="line"><span class="built_in">echo</span> <span class="built_in">source</span> string is %STR%</span><br><span class="line"><span class="built_in">echo</span> result string is %RESULT%</span><br><span class="line">pause &gt; nul</span><br></pre></td></tr></table></figure><p><code>:next</code> 是循环的入口，每次截取第一个字符，判断是 <code>=</code> 就在结果中拼接 <code>#</code> 字符，相当于完成了替换，如果字符不是 <code>=</code> ，就将字符直接拼接到结果中，操作之后将原串的第一个字符删除形成新的原串，然后再判断第一个字符，以此类推，直到原串为空，运行结果如下：</p><blockquote><p>source string is abcdo=ocar12a=ajdjko=ot<br>result string is abcdo#ocar12a#ajdjko#ot</p></blockquote><h1 id="最终方案"><a href="#最终方案" class="headerlink" title="最终方案"></a>最终方案</h1><p>事情到了这里好像还没完，在实际操作中有些情况不是替换一个 <code>=</code>，往往是替换的内容中包含 <code>=</code>，上面将 <code>=</code> 替换成 <code>#</code> 不具有通用型，如果是一开始的请求，将 <code>o=o</code>替换成 <code>A</code> 就不能这样写了，就应该是每次判断3个字符了，写起来有些麻烦，批处理中没有获得字符串长度的函数，需要自己实现一个，如果是100个字符的被替换串，那代码就很难写了。</p><p>既然 <code>=</code> 都能被我们替换掉，肯定有办法实现上面我们这种将 <code>o=o</code>替换成 <code>A</code> 的要求，下面我们就列举一种通用的处理方法。</p><h2 id="0x00-首先将-替换成一个原串中不可能出现的字符或者序列"><a href="#0x00-首先将-替换成一个原串中不可能出现的字符或者序列" class="headerlink" title="0x00 首先将 = 替换成一个原串中不可能出现的字符或者序列"></a>0x00 首先将 <code>=</code> 替换成一个原串中不可能出现的字符或者序列</h2><p>这步替换可能最后需要还原的，所以要求我们替换成的目标序列不能在原串中出现，比如我们上面把 <code>=</code> 替换成了 <code>#</code>， 如果原串中有 <code>#</code> 就会弄混了，不能确定是原来字符串中就存在的 <code>#</code>，还是由 <code>=</code> 变成的 <code>#</code>。</p><p>这个序列我们可以定义的变态一点，比如把 <code>=</code> 替换成 <code>###i#am#happy###</code>，我们把它记作 <code>α</code>。</p><h2 id="0x01-用这个不能出现序列替换我们之前要查找替换子串中的"><a href="#0x01-用这个不能出现序列替换我们之前要查找替换子串中的" class="headerlink" title="0x01 用这个不能出现序列替换我们之前要查找替换子串中的 ="></a>0x01 用这个不能出现序列替换我们之前要查找替换子串中的 <code>=</code></h2><p>我们之前要查找替换的子串是 <code>o=o</code>，那么替换之后形成 <code>o###i#am#happy###o</code>，我们把它记作 <code>β</code>。</p><h2 id="0x02-将第1步结束获得的替换结果作为原串，将其中的-β-替换成-A"><a href="#0x02-将第1步结束获得的替换结果作为原串，将其中的-β-替换成-A" class="headerlink" title="0x02 将第1步结束获得的替换结果作为原串，将其中的 β 替换成 A"></a>0x02 将第1步结束获得的替换结果作为原串，将其中的 <code>β</code> 替换成 <code>A</code></h2><p>其实就是把第1步替换完结果作为原串，把其中的 <code>o###i#am#happy###o</code> 也就是原来的 <code>o=o</code> 替换成 <code>A</code>。</p><h2 id="0x03-将第3步结果的子串作为原串，将其中的-α-替换为"><a href="#0x03-将第3步结果的子串作为原串，将其中的-α-替换为" class="headerlink" title="0x03 将第3步结果的子串作为原串，将其中的 α 替换为 ="></a>0x03 将第3步结果的子串作为原串，将其中的 <code>α</code> 替换为 <code>=</code></h2><p>这一步就是处理那些虽然是 <code>=</code>，但是这个 <code>=</code> 不是我要替换的结果子串中的，所以要还原</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><p>步骤梳理清楚了，下面来写代码，按照步骤一步步写就可以了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line"></span><br><span class="line">rem 第一步</span><br><span class="line"><span class="built_in">set</span> CORESTR=<span class="comment">###i#am#happy###</span></span><br><span class="line"><span class="built_in">set</span> STR=abcdo=ocar12a=ajdjko=ot</span><br><span class="line"><span class="built_in">set</span> CURSTR=%STR%</span><br><span class="line"><span class="built_in">set</span> RESULT1=</span><br><span class="line"></span><br><span class="line">:next1</span><br><span class="line"><span class="keyword">if</span> <span class="string">"%CURSTR%"</span> equ <span class="string">""</span> goto end1</span><br><span class="line"><span class="built_in">set</span> a=%CURSTR:~0,1%</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="string">"%a%"</span> equ <span class="string">"="</span> (<span class="built_in">set</span> RESULT1=%RESULT1%%CORESTR%) <span class="keyword">else</span> (<span class="built_in">set</span> RESULT1=%RESULT1%%a%)</span><br><span class="line"><span class="built_in">set</span> CURSTR=%CURSTR:~1%</span><br><span class="line">goto next1</span><br><span class="line"></span><br><span class="line">:end1</span><br><span class="line"><span class="built_in">echo</span> source1 string is %STR%</span><br><span class="line"><span class="built_in">echo</span> result1 string is %RESULT1%</span><br><span class="line">pause &gt; nul</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">rem 第 2 步</span><br><span class="line"><span class="built_in">set</span> CORESTR=<span class="comment">###i#am#happy###</span></span><br><span class="line"><span class="built_in">set</span> STR=o=o</span><br><span class="line"><span class="built_in">set</span> CURSTR=%STR%</span><br><span class="line"><span class="built_in">set</span> RESULT2=</span><br><span class="line"></span><br><span class="line">:next2</span><br><span class="line"><span class="keyword">if</span> <span class="string">"%CURSTR%"</span> equ <span class="string">""</span> goto end2</span><br><span class="line"><span class="built_in">set</span> a=%CURSTR:~0,1%</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="string">"%a%"</span> equ <span class="string">"="</span> (<span class="built_in">set</span> RESULT2=%RESULT2%%CORESTR%) <span class="keyword">else</span> (<span class="built_in">set</span> RESULT2=%RESULT2%%a%)</span><br><span class="line"><span class="built_in">set</span> CURSTR=%CURSTR:~1%</span><br><span class="line">goto next2</span><br><span class="line"></span><br><span class="line">:end2</span><br><span class="line"><span class="built_in">echo</span> source2 string is %STR%</span><br><span class="line"><span class="built_in">echo</span> result2 string is %RESULT2%</span><br><span class="line">pause &gt; nul</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">rem 第3步，需要开启延迟变量</span><br><span class="line">setlocal ENABLEDELAYEDEXPANSION</span><br><span class="line"><span class="built_in">set</span> RESULT3=!RESULT1:%RESULT2%=A!</span><br><span class="line"><span class="built_in">echo</span> result3 string is %RESULT3%</span><br><span class="line">pause &gt; nul</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">rem 第4步</span><br><span class="line"><span class="built_in">set</span> RESULT4=!RESULT3:%CORESTR%==!</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> finally result is %RESULT4%</span><br></pre></td></tr></table></figure><p>运行之后的结果为：</p><blockquote><p>source1 string is abcdo=ocar12a=ajdjko=ot<br>result1 string is abcdo###i#am#happy###ocar12a###i#am#happy###ajdjko###i#am#happy###ot<br>source2 string is o=o<br>result2 string is o###i#am#happy###o<br>result3 string is abcdAcar12a###i#am#happy###ajdjkAt<br>finally result is abcdAcar12a=ajdjkAt</p></blockquote><p>这次终于替换成功了，<code>o=o</code> 被成功替换成了字母 <code>A</code>，代码中用到了延迟变量，主要是为了实现被替换字符串是变量的情况，不清楚延迟变量的用法可以简单查询一下，至此文章开头提出的问题我们就成功解决了，虽然路途有些坎坷。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol><li>批处理程序中的 <code>=</code> 比较特殊，使用常规的 <code>X:Y=Z</code> 的语法不能替换包含 <code>=</code> 的子串</li><li>遇到上述情况可以将字符串切割，采用逐个字符比较的方式，将 <code>=</code> 替换成其他字符再进行后续操作</li><li>有时候也不必非得使用批处理来替换包含 <code>=</code> 的字符串，随便一个文本工具，比如记事本都可以文本进行替换</li><li>如果非得用命令解决，也可以使用从 linux 的 <code>sed</code> 命令移植到 windows 的 <code>sed.exe</code> 程序来很方便的进行替换</li><li>使用 sed 命令的语法是 <code>echo abcdo=ocar12a=ajdjko=ot | sed -e &quot;s/o=o/A/g&quot;</code>，一步就可以完成了文章开头的需求了</li><li>如果你暂时没有 <code>sed.exe</code> 程序，可以点击这个链接 <a href="https://download.csdn.net/download/shihengzhen101/12335608" target="_blank" rel="noopener">sed.exe程序</a> 下载，若不是在同一目录使用，记得将命令目录添加到环境变量中</li></ol><hr><blockquote><p>时间慢慢地磨去了年少轻狂，也渐渐地沉淀了冷暖自知。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;今天写这篇记录要解决的问题来源于最近一名读者的提问，之前写过一篇名为&lt;a href=&quot;https://blog.csdn.net/albertsh/article/details/79919465&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《.bat批处理（六）：替换字符串中匹配的子串》&lt;/a&gt;的总结文章，结果有读者在评论区提问说，如果想要替换的子串中包含等号 &lt;code&gt;=&lt;/code&gt;，那么就无法替换了，问有没有什么办法可以解决。遇到这个问题的第一感觉应该挺好处理的吧，如果批处理程序在替换操作中认为等号 &lt;code&gt;=&lt;/code&gt; 比较特殊，那就加个转义字符应该就可以了，但事实却证明这种想法有些天真了。&lt;/p&gt;
    
    </summary>
    
      <category term="bat" scheme="http://AlbertGithubHome.github.io/blog/categories/bat/"/>
    
    
      <category term="实用工具" scheme="http://AlbertGithubHome.github.io/blog/tags/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/"/>
    
      <category term="bat" scheme="http://AlbertGithubHome.github.io/blog/tags/bat/"/>
    
  </entry>
  
</feed>
